/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'green.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'green.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'green.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'green.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'green.ap-southeast-1.aliyuncs.com',
    cn-chengdu = 'green.aliyuncs.com',
    cn-hongkong = 'green.aliyuncs.com',
    cn-huhehaote = 'green.aliyuncs.com',
    cn-qingdao = 'green.aliyuncs.com',
    cn-zhangjiakou = 'green.aliyuncs.com',
    eu-central-1 = 'green.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'green.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'green.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'green.ap-southeast-1.aliyuncs.com',
    cn-hangzhou-finance = 'green.aliyuncs.com',
    cn-shenzhen-finance-1 = 'green.aliyuncs.com',
    cn-shanghai-finance-1 = 'green.aliyuncs.com',
    cn-north-2-gov-1 = 'green.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('green', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddFacesRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model AddFacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddFacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddFacesResponse
 */
async function addFacesWithOptions(request: AddFacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddFacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddFaces',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/face/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddFacesRequest
 * @return AddFacesResponse
 */
async function addFaces(request: AddFacesRequest): AddFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addFacesWithOptions(request, headers, runtime);
}

model AddGroupsRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model AddGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddGroupsResponse
 */
async function addGroupsWithOptions(request: AddGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddGroups',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person/groups/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddGroupsRequest
 * @return AddGroupsResponse
 */
async function addGroups(request: AddGroupsRequest): AddGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addGroupsWithOptions(request, headers, runtime);
}

model AddPersonRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model AddPersonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddPersonRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddPersonResponse
 */
async function addPersonWithOptions(request: AddPersonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddPersonResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddPerson',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddPersonRequest
 * @return AddPersonResponse
 */
async function addPerson(request: AddPersonRequest): AddPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addPersonWithOptions(request, headers, runtime);
}

model AddSimilarityImageRequest {
  clientInfo?: string(name='ClientInfo'),
}

model AddSimilarityImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddSimilarityImageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSimilarityImageResponse
 */
async function addSimilarityImageWithOptions(request: AddSimilarityImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddSimilarityImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSimilarityImage',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/image/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddSimilarityImageRequest
 * @return AddSimilarityImageResponse
 */
async function addSimilarityImage(request: AddSimilarityImageRequest): AddSimilarityImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSimilarityImageWithOptions(request, headers, runtime);
}

model AddSimilarityLibraryRequest {
  clientInfo?: string(name='ClientInfo'),
}

model AddSimilarityLibraryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddSimilarityLibraryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddSimilarityLibraryResponse
 */
async function addSimilarityLibraryWithOptions(request: AddSimilarityLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddSimilarityLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddSimilarityLibrary',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/library/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddSimilarityLibraryRequest
 * @return AddSimilarityLibraryResponse
 */
async function addSimilarityLibrary(request: AddSimilarityLibraryRequest): AddSimilarityLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addSimilarityLibraryWithOptions(request, headers, runtime);
}

model AddVideoDnaRequest {
  clientInfo?: string(name='ClientInfo'),
}

model AddVideoDnaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddVideoDnaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVideoDnaResponse
 */
async function addVideoDnaWithOptions(request: AddVideoDnaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddVideoDnaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVideoDna',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/dna/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddVideoDnaRequest
 * @return AddVideoDnaResponse
 */
async function addVideoDna(request: AddVideoDnaRequest): AddVideoDnaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addVideoDnaWithOptions(request, headers, runtime);
}

model AddVideoDnaGroupRequest {
  clientInfo?: string(name='ClientInfo'),
}

model AddVideoDnaGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request AddVideoDnaGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddVideoDnaGroupResponse
 */
async function addVideoDnaGroupWithOptions(request: AddVideoDnaGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AddVideoDnaGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddVideoDnaGroup',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/dna/group/add`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request AddVideoDnaGroupRequest
 * @return AddVideoDnaGroupResponse
 */
async function addVideoDnaGroup(request: AddVideoDnaGroupRequest): AddVideoDnaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return addVideoDnaGroupWithOptions(request, headers, runtime);
}

model DeleteFacesRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model DeleteFacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteFacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFacesResponse
 */
async function deleteFacesWithOptions(request: DeleteFacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFaces',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/face/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteFacesRequest
 * @return DeleteFacesResponse
 */
async function deleteFaces(request: DeleteFacesRequest): DeleteFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFacesWithOptions(request, headers, runtime);
}

model DeleteGroupsRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model DeleteGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteGroupsResponse
 */
async function deleteGroupsWithOptions(request: DeleteGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroups',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person/groups/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteGroupsRequest
 * @return DeleteGroupsResponse
 */
async function deleteGroups(request: DeleteGroupsRequest): DeleteGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteGroupsWithOptions(request, headers, runtime);
}

model DeletePersonRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model DeletePersonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeletePersonRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeletePersonResponse
 */
async function deletePersonWithOptions(request: DeletePersonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePersonResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePerson',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeletePersonRequest
 * @return DeletePersonResponse
 */
async function deletePerson(request: DeletePersonRequest): DeletePersonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePersonWithOptions(request, headers, runtime);
}

model DeleteSimilarityImageRequest {
  clientInfo?: string(name='ClientInfo'),
}

model DeleteSimilarityImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteSimilarityImageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSimilarityImageResponse
 */
async function deleteSimilarityImageWithOptions(request: DeleteSimilarityImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSimilarityImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSimilarityImage',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/image/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSimilarityImageRequest
 * @return DeleteSimilarityImageResponse
 */
async function deleteSimilarityImage(request: DeleteSimilarityImageRequest): DeleteSimilarityImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSimilarityImageWithOptions(request, headers, runtime);
}

model DeleteSimilarityLibraryRequest {
  clientInfo?: string(name='ClientInfo'),
}

model DeleteSimilarityLibraryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteSimilarityLibraryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSimilarityLibraryResponse
 */
async function deleteSimilarityLibraryWithOptions(request: DeleteSimilarityLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSimilarityLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSimilarityLibrary',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/library/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteSimilarityLibraryRequest
 * @return DeleteSimilarityLibraryResponse
 */
async function deleteSimilarityLibrary(request: DeleteSimilarityLibraryRequest): DeleteSimilarityLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSimilarityLibraryWithOptions(request, headers, runtime);
}

model DeleteVideoDnaRequest {
  clientInfo?: string(name='ClientInfo'),
}

model DeleteVideoDnaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteVideoDnaRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVideoDnaResponse
 */
async function deleteVideoDnaWithOptions(request: DeleteVideoDnaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVideoDnaResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideoDna',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/dna/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteVideoDnaRequest
 * @return DeleteVideoDnaResponse
 */
async function deleteVideoDna(request: DeleteVideoDnaRequest): DeleteVideoDnaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVideoDnaWithOptions(request, headers, runtime);
}

model DeleteVideoDnaGroupRequest {
  clientInfo?: string(name='ClientInfo'),
}

model DeleteVideoDnaGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DeleteVideoDnaGroupRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVideoDnaGroupResponse
 */
async function deleteVideoDnaGroupWithOptions(request: DeleteVideoDnaGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteVideoDnaGroupResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideoDnaGroup',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/dna/group/delete`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DeleteVideoDnaGroupRequest
 * @return DeleteVideoDnaGroupResponse
 */
async function deleteVideoDnaGroup(request: DeleteVideoDnaGroupRequest): DeleteVideoDnaGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteVideoDnaGroupWithOptions(request, headers, runtime);
}

model DetectFaceRequest {
  clientInfo?: string(name='ClientInfo'),
}

model DetectFaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request DetectFaceRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetectFaceResponse
 */
async function detectFaceWithOptions(request: DetectFaceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DetectFaceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetectFace',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/face/detect`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DetectFaceRequest
 * @return DetectFaceResponse
 */
async function detectFace(request: DetectFaceRequest): DetectFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return detectFaceWithOptions(request, headers, runtime);
}

model FileAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model FileAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request FileAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileAsyncScanResponse
 */
async function fileAsyncScanWithOptions(request: FileAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FileAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/file/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request FileAsyncScanRequest
 * @return FileAsyncScanResponse
 */
async function fileAsyncScan(request: FileAsyncScanRequest): FileAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAsyncScanWithOptions(request, headers, runtime);
}

model FileAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model FileAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request FileAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileAsyncScanResultsResponse
 */
async function fileAsyncScanResultsWithOptions(request: FileAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FileAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FileAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/file/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request FileAsyncScanResultsRequest
 * @return FileAsyncScanResultsResponse
 */
async function fileAsyncScanResults(request: FileAsyncScanResultsRequest): FileAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAsyncScanResultsWithOptions(request, headers, runtime);
}

model FileAsyncScanV2ResponseBody = {
  requestId?: string(name='requestId', example='DA36A1DA-C466-538D-AD52-E64D75597750'),
}

model FileAsyncScanV2Response = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FileAsyncScanV2ResponseBody(name='body'),
}

/**
 * @summary 文件检测新版本
 *
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return FileAsyncScanV2Response
 */
async function fileAsyncScanV2WithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): FileAsyncScanV2Response {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'FileAsyncScanV2',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/file/asyncscanv2`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 文件检测新版本
 *
 * @return FileAsyncScanV2Response
 */
async function fileAsyncScanV2(): FileAsyncScanV2Response {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return fileAsyncScanV2WithOptions(headers, runtime);
}

model GetFacesRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model GetFacesResponseBody = {
  requestId?: string(name='RequestId'),
}

model GetFacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetFacesResponseBody(name='body'),
}

/**
 * @param request GetFacesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetFacesResponse
 */
async function getFacesWithOptions(request: GetFacesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetFacesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetFaces',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/faces`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetFacesRequest
 * @return GetFacesResponse
 */
async function getFaces(request: GetFacesRequest): GetFacesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getFacesWithOptions(request, headers, runtime);
}

model GetGroupsRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model GetGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request GetGroupsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetGroupsResponse
 */
async function getGroupsWithOptions(request: GetGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGroups',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/groups`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetGroupsRequest
 * @return GetGroupsResponse
 */
async function getGroups(request: GetGroupsRequest): GetGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getGroupsWithOptions(request, headers, runtime);
}

model GetPersonRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model GetPersonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request GetPersonRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPersonResponse
 */
async function getPersonWithOptions(request: GetPersonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPersonResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPerson',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetPersonRequest
 * @return GetPersonResponse
 */
async function getPerson(request: GetPersonRequest): GetPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPersonWithOptions(request, headers, runtime);
}

model GetPersonsRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model GetPersonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request GetPersonsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetPersonsResponse
 */
async function getPersonsWithOptions(request: GetPersonsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetPersonsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPersons',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/group/persons`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetPersonsRequest
 * @return GetPersonsResponse
 */
async function getPersons(request: GetPersonsRequest): GetPersonsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPersonsWithOptions(request, headers, runtime);
}

model GetSimilarityImageRequest {
  clientInfo?: string(name='ClientInfo'),
}

model GetSimilarityImageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request GetSimilarityImageRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSimilarityImageResponse
 */
async function getSimilarityImageWithOptions(request: GetSimilarityImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSimilarityImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSimilarityImage',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/image/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSimilarityImageRequest
 * @return GetSimilarityImageResponse
 */
async function getSimilarityImage(request: GetSimilarityImageRequest): GetSimilarityImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSimilarityImageWithOptions(request, headers, runtime);
}

model GetSimilarityLibraryRequest {
  clientInfo?: string(name='ClientInfo'),
}

model GetSimilarityLibraryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request GetSimilarityLibraryRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSimilarityLibraryResponse
 */
async function getSimilarityLibraryWithOptions(request: GetSimilarityLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSimilarityLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSimilarityLibrary',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/library/get`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetSimilarityLibraryRequest
 * @return GetSimilarityLibraryResponse
 */
async function getSimilarityLibrary(request: GetSimilarityLibraryRequest): GetSimilarityLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSimilarityLibraryWithOptions(request, headers, runtime);
}

model ImageAsyncManualScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageAsyncManualScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageAsyncManualScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageAsyncManualScanResponse
 */
async function imageAsyncManualScanWithOptions(request: ImageAsyncManualScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageAsyncManualScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageAsyncManualScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/manual/asyncScan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageAsyncManualScanRequest
 * @return ImageAsyncManualScanResponse
 */
async function imageAsyncManualScan(request: ImageAsyncManualScanRequest): ImageAsyncManualScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageAsyncManualScanWithOptions(request, headers, runtime);
}

model ImageAsyncManualScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageAsyncManualScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageAsyncManualScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageAsyncManualScanResultsResponse
 */
async function imageAsyncManualScanResultsWithOptions(request: ImageAsyncManualScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageAsyncManualScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageAsyncManualScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/manual/scan/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageAsyncManualScanResultsRequest
 * @return ImageAsyncManualScanResultsResponse
 */
async function imageAsyncManualScanResults(request: ImageAsyncManualScanResultsRequest): ImageAsyncManualScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageAsyncManualScanResultsWithOptions(request, headers, runtime);
}

model ImageAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageAsyncScanResponse
 */
async function imageAsyncScanWithOptions(request: ImageAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageAsyncScanRequest
 * @return ImageAsyncScanResponse
 */
async function imageAsyncScan(request: ImageAsyncScanRequest): ImageAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageAsyncScanWithOptions(request, headers, runtime);
}

model ImageAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageAsyncScanResultsResponse
 */
async function imageAsyncScanResultsWithOptions(request: ImageAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageAsyncScanResultsRequest
 * @return ImageAsyncScanResultsResponse
 */
async function imageAsyncScanResults(request: ImageAsyncScanResultsRequest): ImageAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageAsyncScanResultsWithOptions(request, headers, runtime);
}

model ImageScanFeedbackRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageScanFeedbackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageScanFeedbackRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageScanFeedbackResponse
 */
async function imageScanFeedbackWithOptions(request: ImageScanFeedbackRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageScanFeedbackResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageScanFeedback',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/feedback`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageScanFeedbackRequest
 * @return ImageScanFeedbackResponse
 */
async function imageScanFeedback(request: ImageScanFeedbackRequest): ImageScanFeedbackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageScanFeedbackWithOptions(request, headers, runtime);
}

model ImageSyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ImageSyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
}

/**
 * @param request ImageSyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImageSyncScanResponse
 */
async function imageSyncScanWithOptions(request: ImageSyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ImageSyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImageSyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/image/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request ImageSyncScanRequest
 * @return ImageSyncScanResponse
 */
async function imageSyncScan(request: ImageSyncScanRequest): ImageSyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return imageSyncScanWithOptions(request, headers, runtime);
}

model ListSimilarityImagesRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ListSimilarityImagesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ListSimilarityImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSimilarityImagesResponseBody(name='body'),
}

/**
 * @summary 获取相似图
 *
 * @param request ListSimilarityImagesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSimilarityImagesResponse
 */
async function listSimilarityImagesWithOptions(request: ListSimilarityImagesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSimilarityImagesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSimilarityImages',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/image/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取相似图
 *
 * @param request ListSimilarityImagesRequest
 * @return ListSimilarityImagesResponse
 */
async function listSimilarityImages(request: ListSimilarityImagesRequest): ListSimilarityImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSimilarityImagesWithOptions(request, headers, runtime);
}

model ListSimilarityLibrariesRequest {
  clientInfo?: string(name='ClientInfo'),
}

model ListSimilarityLibrariesResponseBody = {
  requestId?: string(name='RequestId'),
}

model ListSimilarityLibrariesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSimilarityLibrariesResponseBody(name='body'),
}

/**
 * @summary 获取相似图库
 *
 * @param request ListSimilarityLibrariesRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSimilarityLibrariesResponse
 */
async function listSimilarityLibrariesWithOptions(request: ListSimilarityLibrariesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSimilarityLibrariesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSimilarityLibraries',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/similarity/library/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取相似图库
 *
 * @param request ListSimilarityLibrariesRequest
 * @return ListSimilarityLibrariesResponse
 */
async function listSimilarityLibraries(request: ListSimilarityLibrariesRequest): ListSimilarityLibrariesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSimilarityLibrariesWithOptions(request, headers, runtime);
}

model LiveStreamAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model LiveStreamAsyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model LiveStreamAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LiveStreamAsyncScanResponseBody(name='body'),
}

/**
 * @summary 直播流异步检测
 *
 * @param request LiveStreamAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return LiveStreamAsyncScanResponse
 */
async function liveStreamAsyncScanWithOptions(request: LiveStreamAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LiveStreamAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LiveStreamAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/livestream/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 直播流异步检测
 *
 * @param request LiveStreamAsyncScanRequest
 * @return LiveStreamAsyncScanResponse
 */
async function liveStreamAsyncScan(request: LiveStreamAsyncScanRequest): LiveStreamAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return liveStreamAsyncScanWithOptions(request, headers, runtime);
}

model LiveStreamAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model LiveStreamAsyncScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model LiveStreamAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LiveStreamAsyncScanResultsResponseBody(name='body'),
}

/**
 * @summary 直播流异步检测结果
 *
 * @param request LiveStreamAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return LiveStreamAsyncScanResultsResponse
 */
async function liveStreamAsyncScanResultsWithOptions(request: LiveStreamAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LiveStreamAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LiveStreamAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/livestream/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 直播流异步检测结果
 *
 * @param request LiveStreamAsyncScanResultsRequest
 * @return LiveStreamAsyncScanResultsResponse
 */
async function liveStreamAsyncScanResults(request: LiveStreamAsyncScanResultsRequest): LiveStreamAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return liveStreamAsyncScanResultsWithOptions(request, headers, runtime);
}

model LiveStreamCancelScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model LiveStreamCancelScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model LiveStreamCancelScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LiveStreamCancelScanResponseBody(name='body'),
}

/**
 * @summary 直播流取消检测
 *
 * @param request LiveStreamCancelScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return LiveStreamCancelScanResponse
 */
async function liveStreamCancelScanWithOptions(request: LiveStreamCancelScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): LiveStreamCancelScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LiveStreamCancelScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/livestream/cancelscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 直播流取消检测
 *
 * @param request LiveStreamCancelScanRequest
 * @return LiveStreamCancelScanResponse
 */
async function liveStreamCancelScan(request: LiveStreamCancelScanRequest): LiveStreamCancelScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return liveStreamCancelScanWithOptions(request, headers, runtime);
}

model SetPersonRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model SetPersonResponseBody = {
  requestId?: string(name='RequestId'),
}

model SetPersonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetPersonResponseBody(name='body'),
}

/**
 * @summary 设置个体
 *
 * @param request SetPersonRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetPersonResponse
 */
async function setPersonWithOptions(request: SetPersonRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SetPersonResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetPerson',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/sface/person/update`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 设置个体
 *
 * @param request SetPersonRequest
 * @return SetPersonResponse
 */
async function setPerson(request: SetPersonRequest): SetPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return setPersonWithOptions(request, headers, runtime);
}

model TextAsyncManualScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model TextAsyncManualScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model TextAsyncManualScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TextAsyncManualScanResponseBody(name='body'),
}

/**
 * @summary 文本异步人工审核
 *
 * @param request TextAsyncManualScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TextAsyncManualScanResponse
 */
async function textAsyncManualScanWithOptions(request: TextAsyncManualScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TextAsyncManualScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TextAsyncManualScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/text/manual/asyncScan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 文本异步人工审核
 *
 * @param request TextAsyncManualScanRequest
 * @return TextAsyncManualScanResponse
 */
async function textAsyncManualScan(request: TextAsyncManualScanRequest): TextAsyncManualScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return textAsyncManualScanWithOptions(request, headers, runtime);
}

model TextAsyncManualScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model TextAsyncManualScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model TextAsyncManualScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TextAsyncManualScanResultsResponseBody(name='body'),
}

/**
 * @summary 文本异步人工审核结果
 *
 * @param request TextAsyncManualScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TextAsyncManualScanResultsResponse
 */
async function textAsyncManualScanResultsWithOptions(request: TextAsyncManualScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TextAsyncManualScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TextAsyncManualScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/text/manual/scan/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 文本异步人工审核结果
 *
 * @param request TextAsyncManualScanResultsRequest
 * @return TextAsyncManualScanResultsResponse
 */
async function textAsyncManualScanResults(request: TextAsyncManualScanResultsRequest): TextAsyncManualScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return textAsyncManualScanResultsWithOptions(request, headers, runtime);
}

model TextFeedbackRequest {
  clientInfo?: string(name='ClientInfo'),
}

model TextFeedbackResponseBody = {
  requestId?: string(name='RequestId'),
}

model TextFeedbackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TextFeedbackResponseBody(name='body'),
}

/**
 * @summary 文本结果反馈
 *
 * @param request TextFeedbackRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TextFeedbackResponse
 */
async function textFeedbackWithOptions(request: TextFeedbackRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TextFeedbackResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TextFeedback',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/text/feedback`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 文本结果反馈
 *
 * @param request TextFeedbackRequest
 * @return TextFeedbackResponse
 */
async function textFeedback(request: TextFeedbackRequest): TextFeedbackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return textFeedbackWithOptions(request, headers, runtime);
}

model TextScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model TextScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model TextScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TextScanResponseBody(name='body'),
}

/**
 * @param request TextScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return TextScanResponse
 */
async function textScanWithOptions(request: TextScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TextScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TextScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/text/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request TextScanRequest
 * @return TextScanResponse
 */
async function textScan(request: TextScanRequest): TextScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return textScanWithOptions(request, headers, runtime);
}

model UploadCredentialsRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model UploadCredentialsResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadCredentialsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UploadCredentialsResponseBody(name='body'),
}

/**
 * @summary 获取上传证书
 *
 * @param request UploadCredentialsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return UploadCredentialsResponse
 */
async function uploadCredentialsWithOptions(request: UploadCredentialsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UploadCredentialsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadCredentials',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/credentials/uploadcredentials`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取上传证书
 *
 * @param request UploadCredentialsRequest
 * @return UploadCredentialsResponse
 */
async function uploadCredentials(request: UploadCredentialsRequest): UploadCredentialsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return uploadCredentialsWithOptions(request, headers, runtime);
}

model VideoAsyncManualScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoAsyncManualScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoAsyncManualScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoAsyncManualScanResponseBody(name='body'),
}

/**
 * @summary 视频异步人工审核
 *
 * @param request VideoAsyncManualScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoAsyncManualScanResponse
 */
async function videoAsyncManualScanWithOptions(request: VideoAsyncManualScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoAsyncManualScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoAsyncManualScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/manual/asyncScan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频异步人工审核
 *
 * @param request VideoAsyncManualScanRequest
 * @return VideoAsyncManualScanResponse
 */
async function videoAsyncManualScan(request: VideoAsyncManualScanRequest): VideoAsyncManualScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoAsyncManualScanWithOptions(request, headers, runtime);
}

model VideoAsyncManualScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoAsyncManualScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoAsyncManualScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoAsyncManualScanResultsResponseBody(name='body'),
}

/**
 * @summary 视频异步人工审核结果
 *
 * @param request VideoAsyncManualScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoAsyncManualScanResultsResponse
 */
async function videoAsyncManualScanResultsWithOptions(request: VideoAsyncManualScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoAsyncManualScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoAsyncManualScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/manual/scan/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频异步人工审核结果
 *
 * @param request VideoAsyncManualScanResultsRequest
 * @return VideoAsyncManualScanResultsResponse
 */
async function videoAsyncManualScanResults(request: VideoAsyncManualScanResultsRequest): VideoAsyncManualScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoAsyncManualScanResultsWithOptions(request, headers, runtime);
}

model VideoAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoAsyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoAsyncScanResponseBody(name='body'),
}

/**
 * @summary 视频异步检测
 *
 * @param request VideoAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoAsyncScanResponse
 */
async function videoAsyncScanWithOptions(request: VideoAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频异步检测
 *
 * @param request VideoAsyncScanRequest
 * @return VideoAsyncScanResponse
 */
async function videoAsyncScan(request: VideoAsyncScanRequest): VideoAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoAsyncScanWithOptions(request, headers, runtime);
}

model VideoAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoAsyncScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoAsyncScanResultsResponseBody(name='body'),
}

/**
 * @summary 视频异步检测结果
 *
 * @param request VideoAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoAsyncScanResultsResponse
 */
async function videoAsyncScanResultsWithOptions(request: VideoAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频异步检测结果
 *
 * @param request VideoAsyncScanResultsRequest
 * @return VideoAsyncScanResultsResponse
 */
async function videoAsyncScanResults(request: VideoAsyncScanResultsRequest): VideoAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoAsyncScanResultsWithOptions(request, headers, runtime);
}

model VideoCancelScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoCancelScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoCancelScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoCancelScanResponseBody(name='body'),
}

/**
 * @summary 视频取消检测
 *
 * @param request VideoCancelScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoCancelScanResponse
 */
async function videoCancelScanWithOptions(request: VideoCancelScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoCancelScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoCancelScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/cancelscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频取消检测
 *
 * @param request VideoCancelScanRequest
 * @return VideoCancelScanResponse
 */
async function videoCancelScan(request: VideoCancelScanRequest): VideoCancelScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoCancelScanWithOptions(request, headers, runtime);
}

model VideoFeedbackRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoFeedbackResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoFeedbackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoFeedbackResponseBody(name='body'),
}

/**
 * @summary 视频结果反馈
 *
 * @param request VideoFeedbackRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoFeedbackResponse
 */
async function videoFeedbackWithOptions(request: VideoFeedbackRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoFeedbackResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoFeedback',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/feedback`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频结果反馈
 *
 * @param request VideoFeedbackRequest
 * @return VideoFeedbackResponse
 */
async function videoFeedback(request: VideoFeedbackRequest): VideoFeedbackResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoFeedbackWithOptions(request, headers, runtime);
}

model VideoSyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VideoSyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VideoSyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VideoSyncScanResponseBody(name='body'),
}

/**
 * @summary 视频同步检测
 *
 * @param request VideoSyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VideoSyncScanResponse
 */
async function videoSyncScanWithOptions(request: VideoSyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VideoSyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VideoSyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/video/syncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频同步检测
 *
 * @param request VideoSyncScanRequest
 * @return VideoSyncScanResponse
 */
async function videoSyncScan(request: VideoSyncScanRequest): VideoSyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return videoSyncScanWithOptions(request, headers, runtime);
}

model VodAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VodAsyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VodAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VodAsyncScanResponseBody(name='body'),
}

/**
 * @summary 视频点播异步检测
 *
 * @param request VodAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VodAsyncScanResponse
 */
async function vodAsyncScanWithOptions(request: VodAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VodAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VodAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/vod/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频点播异步检测
 *
 * @param request VodAsyncScanRequest
 * @return VodAsyncScanResponse
 */
async function vodAsyncScan(request: VodAsyncScanRequest): VodAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return vodAsyncScanWithOptions(request, headers, runtime);
}

model VodAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VodAsyncScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model VodAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VodAsyncScanResultsResponseBody(name='body'),
}

/**
 * @summary 视频点播异步检测结果
 *
 * @param request VodAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VodAsyncScanResultsResponse
 */
async function vodAsyncScanResultsWithOptions(request: VodAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VodAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VodAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/vod/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 视频点播异步检测结果
 *
 * @param request VodAsyncScanResultsRequest
 * @return VodAsyncScanResultsResponse
 */
async function vodAsyncScanResults(request: VodAsyncScanResultsRequest): VodAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return vodAsyncScanResultsWithOptions(request, headers, runtime);
}

model VoiceAsyncManualScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VoiceAsyncManualScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceAsyncManualScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceAsyncManualScanResponseBody(name='body'),
}

/**
 * @summary 语音异步人工审核
 *
 * @param request VoiceAsyncManualScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceAsyncManualScanResponse
 */
async function voiceAsyncManualScanWithOptions(request: VoiceAsyncManualScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceAsyncManualScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceAsyncManualScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/manual/asyncScan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音异步人工审核
 *
 * @param request VoiceAsyncManualScanRequest
 * @return VoiceAsyncManualScanResponse
 */
async function voiceAsyncManualScan(request: VoiceAsyncManualScanRequest): VoiceAsyncManualScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceAsyncManualScanWithOptions(request, headers, runtime);
}

model VoiceAsyncManualScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VoiceAsyncManualScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceAsyncManualScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceAsyncManualScanResultsResponseBody(name='body'),
}

/**
 * @summary 语音异步人工审核结果
 *
 * @param request VoiceAsyncManualScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceAsyncManualScanResultsResponse
 */
async function voiceAsyncManualScanResultsWithOptions(request: VoiceAsyncManualScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceAsyncManualScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceAsyncManualScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/manual/scan/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音异步人工审核结果
 *
 * @param request VoiceAsyncManualScanResultsRequest
 * @return VoiceAsyncManualScanResultsResponse
 */
async function voiceAsyncManualScanResults(request: VoiceAsyncManualScanResultsRequest): VoiceAsyncManualScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceAsyncManualScanResultsWithOptions(request, headers, runtime);
}

model VoiceAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VoiceAsyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceAsyncScanResponseBody(name='body'),
}

/**
 * @summary 语音异步检测
 *
 * @param request VoiceAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceAsyncScanResponse
 */
async function voiceAsyncScanWithOptions(request: VoiceAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音异步检测
 *
 * @param request VoiceAsyncScanRequest
 * @return VoiceAsyncScanResponse
 */
async function voiceAsyncScan(request: VoiceAsyncScanRequest): VoiceAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceAsyncScanWithOptions(request, headers, runtime);
}

model VoiceAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VoiceAsyncScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceAsyncScanResultsResponseBody(name='body'),
}

/**
 * @summary 语音异步检测结果
 *
 * @param request VoiceAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceAsyncScanResultsResponse
 */
async function voiceAsyncScanResultsWithOptions(request: VoiceAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音异步检测结果
 *
 * @param request VoiceAsyncScanResultsRequest
 * @return VoiceAsyncScanResultsResponse
 */
async function voiceAsyncScanResults(request: VoiceAsyncScanResultsRequest): VoiceAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceAsyncScanResultsWithOptions(request, headers, runtime);
}

model VoiceCancelScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model VoiceCancelScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceCancelScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceCancelScanResponseBody(name='body'),
}

/**
 * @summary 语音取消检测
 *
 * @param request VoiceCancelScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceCancelScanResponse
 */
async function voiceCancelScanWithOptions(request: VoiceCancelScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceCancelScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceCancelScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/cancelscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音取消检测
 *
 * @param request VoiceCancelScanRequest
 * @return VoiceCancelScanResponse
 */
async function voiceCancelScan(request: VoiceCancelScanRequest): VoiceCancelScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceCancelScanWithOptions(request, headers, runtime);
}

model VoiceIdentityCheckRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model VoiceIdentityCheckResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceIdentityCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceIdentityCheckResponseBody(name='body'),
}

/**
 * @summary 声纹比对
 *
 * @param request VoiceIdentityCheckRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceIdentityCheckResponse
 */
async function voiceIdentityCheckWithOptions(request: VoiceIdentityCheckRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceIdentityCheckResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceIdentityCheck',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/auth/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 声纹比对
 *
 * @param request VoiceIdentityCheckRequest
 * @return VoiceIdentityCheckResponse
 */
async function voiceIdentityCheck(request: VoiceIdentityCheckRequest): VoiceIdentityCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceIdentityCheckWithOptions(request, headers, runtime);
}

model VoiceIdentityRegisterRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model VoiceIdentityRegisterResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceIdentityRegisterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceIdentityRegisterResponseBody(name='body'),
}

/**
 * @summary 声纹注册
 *
 * @param request VoiceIdentityRegisterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceIdentityRegisterResponse
 */
async function voiceIdentityRegisterWithOptions(request: VoiceIdentityRegisterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceIdentityRegisterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceIdentityRegister',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/auth/register`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 声纹注册
 *
 * @param request VoiceIdentityRegisterRequest
 * @return VoiceIdentityRegisterResponse
 */
async function voiceIdentityRegister(request: VoiceIdentityRegisterRequest): VoiceIdentityRegisterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceIdentityRegisterWithOptions(request, headers, runtime);
}

model VoiceIdentityStartCheckRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model VoiceIdentityStartCheckResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceIdentityStartCheckResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceIdentityStartCheckResponseBody(name='body'),
}

/**
 * @summary 声纹开始比对
 *
 * @param request VoiceIdentityStartCheckRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceIdentityStartCheckResponse
 */
async function voiceIdentityStartCheckWithOptions(request: VoiceIdentityStartCheckRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceIdentityStartCheckResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceIdentityStartCheck',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/auth/start/check`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 声纹开始比对
 *
 * @param request VoiceIdentityStartCheckRequest
 * @return VoiceIdentityStartCheckResponse
 */
async function voiceIdentityStartCheck(request: VoiceIdentityStartCheckRequest): VoiceIdentityStartCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceIdentityStartCheckWithOptions(request, headers, runtime);
}

model VoiceIdentityStartRegisterRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model VoiceIdentityStartRegisterResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceIdentityStartRegisterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceIdentityStartRegisterResponseBody(name='body'),
}

/**
 * @summary 声纹开始注册
 *
 * @param request VoiceIdentityStartRegisterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceIdentityStartRegisterResponse
 */
async function voiceIdentityStartRegisterWithOptions(request: VoiceIdentityStartRegisterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceIdentityStartRegisterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceIdentityStartRegister',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/auth/start/register`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 声纹开始注册
 *
 * @param request VoiceIdentityStartRegisterRequest
 * @return VoiceIdentityStartRegisterResponse
 */
async function voiceIdentityStartRegister(request: VoiceIdentityStartRegisterRequest): VoiceIdentityStartRegisterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceIdentityStartRegisterWithOptions(request, headers, runtime);
}

model VoiceIdentityUnregisterRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId'),
}

model VoiceIdentityUnregisterResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceIdentityUnregisterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceIdentityUnregisterResponseBody(name='body'),
}

/**
 * @summary 声纹注销
 *
 * @param request VoiceIdentityUnregisterRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceIdentityUnregisterResponse
 */
async function voiceIdentityUnregisterWithOptions(request: VoiceIdentityUnregisterRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceIdentityUnregisterResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceIdentityUnregister',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/auth/unregister`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 声纹注销
 *
 * @param request VoiceIdentityUnregisterRequest
 * @return VoiceIdentityUnregisterResponse
 */
async function voiceIdentityUnregister(request: VoiceIdentityUnregisterRequest): VoiceIdentityUnregisterResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceIdentityUnregisterWithOptions(request, headers, runtime);
}

model VoiceSyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
  regionId?: string(name='RegionId', description='This parameter is required.'),
}

model VoiceSyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model VoiceSyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VoiceSyncScanResponseBody(name='body'),
}

/**
 * @summary 语音同步检测
 *
 * @param request VoiceSyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return VoiceSyncScanResponse
 */
async function voiceSyncScanWithOptions(request: VoiceSyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): VoiceSyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VoiceSyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/voice/syncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 语音同步检测
 *
 * @param request VoiceSyncScanRequest
 * @return VoiceSyncScanResponse
 */
async function voiceSyncScan(request: VoiceSyncScanRequest): VoiceSyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return voiceSyncScanWithOptions(request, headers, runtime);
}

model WebpageAsyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model WebpageAsyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model WebpageAsyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: WebpageAsyncScanResponseBody(name='body'),
}

/**
 * @summary 站点异步检测
 *
 * @param request WebpageAsyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return WebpageAsyncScanResponse
 */
async function webpageAsyncScanWithOptions(request: WebpageAsyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): WebpageAsyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WebpageAsyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/webpage/asyncscan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 站点异步检测
 *
 * @param request WebpageAsyncScanRequest
 * @return WebpageAsyncScanResponse
 */
async function webpageAsyncScan(request: WebpageAsyncScanRequest): WebpageAsyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return webpageAsyncScanWithOptions(request, headers, runtime);
}

model WebpageAsyncScanResultsRequest {
  clientInfo?: string(name='ClientInfo'),
}

model WebpageAsyncScanResultsResponseBody = {
  requestId?: string(name='RequestId'),
}

model WebpageAsyncScanResultsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: WebpageAsyncScanResultsResponseBody(name='body'),
}

/**
 * @summary 站点异步检测结果
 *
 * @param request WebpageAsyncScanResultsRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return WebpageAsyncScanResultsResponse
 */
async function webpageAsyncScanResultsWithOptions(request: WebpageAsyncScanResultsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): WebpageAsyncScanResultsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WebpageAsyncScanResults',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/webpage/results`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 站点异步检测结果
 *
 * @param request WebpageAsyncScanResultsRequest
 * @return WebpageAsyncScanResultsResponse
 */
async function webpageAsyncScanResults(request: WebpageAsyncScanResultsRequest): WebpageAsyncScanResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return webpageAsyncScanResultsWithOptions(request, headers, runtime);
}

model WebpageSyncScanRequest {
  clientInfo?: string(name='ClientInfo'),
}

model WebpageSyncScanResponseBody = {
  requestId?: string(name='RequestId'),
}

model WebpageSyncScanResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: WebpageSyncScanResponseBody(name='body'),
}

/**
 * @summary 站点同步检测
 *
 * @param request WebpageSyncScanRequest
 * @param headers map
 * @param runtime runtime options for this request RuntimeOptions
 * @return WebpageSyncScanResponse
 */
async function webpageSyncScanWithOptions(request: WebpageSyncScanRequest, headers: map[string]string, runtime: Util.RuntimeOptions): WebpageSyncScanResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'WebpageSyncScan',
    version = '2018-05-09',
    protocol = 'HTTPS',
    pathname = `/green/webpage/scan`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 站点同步检测
 *
 * @param request WebpageSyncScanRequest
 * @return WebpageSyncScanResponse
 */
async function webpageSyncScan(request: WebpageSyncScanRequest): WebpageSyncScanResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return webpageSyncScanWithOptions(request, headers, runtime);
}

