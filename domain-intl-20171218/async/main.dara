/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Domain-intl';
  @version = '2017-12-18';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AcknowledgeTaskResultRequest {
  lang?: string(name='Lang', position='Query'),
  taskDetailNo: [ string ](name='TaskDetailNo', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model AcknowledgeTaskResultResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model AcknowledgeTaskResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcknowledgeTaskResultResponseBody(name='body'),
}

async function acknowledgeTaskResult(request: AcknowledgeTaskResultRequest): AcknowledgeTaskResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AcknowledgeTaskResult', 'POST', '/', 'json', false, 'json', request);
}

model BatchFuzzyMatchDomainSensitiveWordRequest {
  keyword: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model BatchFuzzyMatchDomainSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  sensitiveWordMatchResultList?: {
    sensitiveWordMatchResult?: [ 
    {
      exist?: boolean(name='Exist'),
      keyword?: string(name='Keyword'),
      matchedSentiveWords?: {
        matchedSensitiveWord?: [ 
        {
          word?: string(name='Word'),
        }
      ](name='MatchedSensitiveWord')
      }(name='MatchedSentiveWords'),
    }
  ](name='SensitiveWordMatchResult')
  }(name='SensitiveWordMatchResultList'),
}

model BatchFuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchFuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function batchFuzzyMatchDomainSensitiveWord(request: BatchFuzzyMatchDomainSensitiveWordRequest): BatchFuzzyMatchDomainSensitiveWordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchFuzzyMatchDomainSensitiveWord', 'POST', '/', 'json', false, 'json', request);
}

model CancelDomainVerificationRequest {
  actionType: string(name='ActionType', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model CancelDomainVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelDomainVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDomainVerificationResponseBody(name='body'),
}

async function cancelDomainVerification(request: CancelDomainVerificationRequest): CancelDomainVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelDomainVerification', 'POST', '/', 'json', false, 'json', request);
}

model CancelTaskRequest {
  lang?: string(name='Lang', position='Query'),
  taskNo: string(name='TaskNo', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelTask', 'POST', '/', 'json', false, 'json', request);
}

model CheckDomainRequest {
  domainName: string(name='DomainName', position='Query'),
  feeCommand?: string(name='FeeCommand', position='Query'),
  feeCurrency?: string(name='FeeCurrency', position='Query'),
  feePeriod?: int32(name='FeePeriod', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model CheckDomainResponseBody = {
  avail?: string(name='Avail'),
  domainName?: string(name='DomainName'),
  dynamicCheck?: boolean(name='DynamicCheck'),
  premium?: string(name='Premium'),
  price?: long(name='Price'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
}

model CheckDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDomainResponseBody(name='body'),
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDomain', 'POST', '/', 'json', false, 'json', request);
}

model CheckDomainSunriseClaimRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model CheckDomainSunriseClaimResponseBody = {
  claimKey?: string(name='ClaimKey'),
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model CheckDomainSunriseClaimResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDomainSunriseClaimResponseBody(name='body'),
}

async function checkDomainSunriseClaim(request: CheckDomainSunriseClaimRequest): CheckDomainSunriseClaimResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDomainSunriseClaim', 'POST', '/', 'json', false, 'json', request);
}

model CheckTransferInFeasibilityRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  transferAuthorizationCode?: string(name='TransferAuthorizationCode', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model CheckTransferInFeasibilityResponseBody = {
  canTransfer?: boolean(name='CanTransfer'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  productId?: string(name='ProductId'),
  requestId?: string(name='RequestId'),
}

model CheckTransferInFeasibilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTransferInFeasibilityResponseBody(name='body'),
}

async function checkTransferInFeasibility(request: CheckTransferInFeasibilityRequest): CheckTransferInFeasibilityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckTransferInFeasibility', 'POST', '/', 'json', false, 'json', request);
}

model ConfirmTransferInEmailRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  email: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model ConfirmTransferInEmailResponseBody = {
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
}

model ConfirmTransferInEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmTransferInEmailResponseBody(name='body'),
}

async function confirmTransferInEmail(request: ConfirmTransferInEmailRequest): ConfirmTransferInEmailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfirmTransferInEmail', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEmailVerificationRequest {
  email: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DeleteEmailVerificationResponseBody = {
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model DeleteEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEmailVerificationResponseBody(name='body'),
}

async function deleteEmailVerification(request: DeleteEmailVerificationRequest): DeleteEmailVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEmailVerification', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRegistrantProfileRequest {
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model DeleteRegistrantProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRegistrantProfileResponseBody(name='body'),
}

async function deleteRegistrantProfile(request: DeleteRegistrantProfileRequest): DeleteRegistrantProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRegistrantProfile', 'POST', '/', 'json', false, 'json', request);
}

model EmailVerifiedRequest {
  email: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model EmailVerifiedResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmailVerifiedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EmailVerifiedResponseBody(name='body'),
}

async function emailVerified(request: EmailVerifiedRequest): EmailVerifiedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EmailVerified', 'POST', '/', 'json', false, 'json', request);
}

model FuzzyMatchDomainSensitiveWordRequest {
  keyword: string(name='Keyword', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model FuzzyMatchDomainSensitiveWordResponseBody = {
  exist?: boolean(name='Exist'),
  keyword?: string(name='Keyword'),
  matchedSentiveWords?: {
    matchedSensitiveWord?: [ 
    {
      word?: string(name='Word'),
    }
  ](name='MatchedSensitiveWord')
  }(name='MatchedSentiveWords'),
  requestId?: string(name='RequestId'),
}

model FuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function fuzzyMatchDomainSensitiveWord(request: FuzzyMatchDomainSensitiveWordRequest): FuzzyMatchDomainSensitiveWordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FuzzyMatchDomainSensitiveWord', 'POST', '/', 'json', false, 'json', request);
}

model ListEmailVerificationRequest {
  beginCreateTime?: long(name='BeginCreateTime', position='Query'),
  email?: string(name='Email', position='Query'),
  endCreateTime?: long(name='EndCreateTime', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  verificationStatus?: int32(name='VerificationStatus', position='Query'),
}

model ListEmailVerificationResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      confirmIp?: string(name='ConfirmIp'),
      email?: string(name='Email'),
      emailVerificationNo?: string(name='EmailVerificationNo'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      sendIp?: string(name='SendIp'),
      tokenSendTime?: string(name='TokenSendTime'),
      userId?: string(name='UserId'),
      verificationStatus?: int32(name='VerificationStatus'),
      verificationTime?: string(name='VerificationTime'),
    }
  ](name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model ListEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEmailVerificationResponseBody(name='body'),
}

async function listEmailVerification(request: ListEmailVerificationRequest): ListEmailVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEmailVerification', 'POST', '/', 'json', false, 'json', request);
}

model LookupTmchNoticeRequest {
  claimKey: string(name='ClaimKey', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model LookupTmchNoticeResponseBody = {
  claims?: {
    claim?: [ 
    {
      classDescs?: {
        classDesc?: [ 
        {
          classNum?: int32(name='ClassNum'),
          desc?: string(name='Desc'),
        }
      ](name='ClassDesc')
      }(name='ClassDescs'),
      contacts?: {
        contact?: [ 
        {
          addr?: {
            cc?: string(name='Cc'),
            city?: string(name='City'),
            pc?: string(name='Pc'),
            sp?: string(name='Sp'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          email?: string(name='Email'),
          fax?: string(name='Fax'),
          name?: string(name='Name'),
          org?: string(name='Org'),
          type?: string(name='Type'),
          voice?: string(name='Voice'),
        }
      ](name='Contact')
      }(name='Contacts'),
      goodsAndServices?: string(name='GoodsAndServices'),
      holders?: {
        holder?: [ 
        {
          addr?: {
            cc?: string(name='Cc'),
            city?: string(name='City'),
            pc?: string(name='Pc'),
            sp?: string(name='Sp'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          entitlement?: string(name='Entitlement'),
          org?: string(name='Org'),
        }
      ](name='Holder')
      }(name='Holders'),
      jurDesc?: {
        desc?: string(name='Desc'),
        jurCC?: string(name='JurCC'),
      }(name='JurDesc'),
      markName?: string(name='MarkName'),
    }
  ](name='Claim')
  }(name='Claims'),
  id?: long(name='Id'),
  label?: string(name='Label'),
  notAfter?: string(name='NotAfter'),
  notBefore?: string(name='NotBefore'),
  requestId?: string(name='RequestId'),
}

model LookupTmchNoticeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LookupTmchNoticeResponseBody(name='body'),
}

async function lookupTmchNotice(request: LookupTmchNoticeRequest): LookupTmchNoticeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LookupTmchNotice', 'POST', '/', 'json', false, 'json', request);
}

model PollTaskResultRequest {
  domainName?: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  taskNo?: string(name='TaskNo', position='Query'),
  taskResultStatus?: int32(name='TaskResultStatus', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model PollTaskResultResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskDetail?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model PollTaskResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PollTaskResultResponseBody(name='body'),
}

async function pollTaskResult(request: PollTaskResultRequest): PollTaskResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PollTaskResult', 'POST', '/', 'json', false, 'json', request);
}

model QueryArtExtensionRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryArtExtensionResponseBody = {
  dateOrPeriod?: string(name='DateOrPeriod'),
  dimensions?: string(name='Dimensions'),
  features?: string(name='Features'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings'),
  maker?: string(name='Maker'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques'),
  objectType?: string(name='ObjectType'),
  reference?: string(name='Reference'),
  requestId?: string(name='RequestId'),
  subject?: string(name='Subject'),
  title?: string(name='Title'),
}

model QueryArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryArtExtensionResponseBody(name='body'),
}

async function queryArtExtension(request: QueryArtExtensionRequest): QueryArtExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryArtExtension', 'POST', '/', 'json', false, 'json', request);
}

model QueryChangeLogListRequest {
  domainName?: string(name='DomainName', position='Query'),
  endDate?: long(name='EndDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum: int32(name='PageNum', minimum=1, position='Query'),
  pageSize: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  startDate?: long(name='StartDate', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryChangeLogListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    changeLog?: [ 
    {
      details?: string(name='Details'),
      domainName?: string(name='DomainName'),
      operation?: string(name='Operation'),
      operationIPAddress?: string(name='OperationIPAddress'),
      result?: string(name='Result'),
      time?: string(name='Time'),
    }
  ](name='ChangeLog')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  resultLimit?: boolean(name='ResultLimit'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryChangeLogListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryChangeLogListResponseBody(name='body'),
}

async function queryChangeLogList(request: QueryChangeLogListRequest): QueryChangeLogListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryChangeLogList', 'POST', '/', 'json', false, 'json', request);
}

model QueryContactInfoRequest {
  contactType: string(name='ContactType', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryContactInfoResponseBody = {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  createDate?: string(name='CreateDate'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  requestId?: string(name='RequestId'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
}

model QueryContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryContactInfoResponseBody(name='body'),
}

async function queryContactInfo(request: QueryContactInfoRequest): QueryContactInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryContactInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryDSRecordRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDSRecordResponseBody = {
  DSRecordList?: [ 
    {
      algorithm?: int32(name='Algorithm'),
      digest?: string(name='Digest'),
      digestType?: int32(name='DigestType'),
      keyTag?: int32(name='KeyTag'),
    }
  ](name='DSRecordList'),
  requestId?: string(name='RequestId'),
}

model QueryDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDSRecordResponseBody(name='body'),
}

async function queryDSRecord(request: QueryDSRecordRequest): QueryDSRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDSRecord', 'POST', '/', 'json', false, 'json', request);
}

model QueryDnsHostRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDnsHostResponseBody = {
  dnsHostList?: [ 
    {
      dnsName?: string(name='DnsName'),
      ipList?: [ string ](name='IpList'),
    }
  ](name='DnsHostList'),
  requestId?: string(name='RequestId'),
}

model QueryDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDnsHostResponseBody(name='body'),
}

async function queryDnsHost(request: QueryDnsHostRequest): QueryDnsHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDnsHost', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainByDomainNameRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDomainByDomainNameResponseBody = {
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  domainName?: string(name='DomainName'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  email?: string(name='Email'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  premium?: boolean(name='Premium'),
  realNameStatus?: string(name='RealNameStatus'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  requestId?: string(name='RequestId'),
  transferOutStatus?: string(name='TransferOutStatus'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
  userId?: string(name='UserId'),
}

model QueryDomainByDomainNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainByDomainNameResponseBody(name='body'),
}

async function queryDomainByDomainName(request: QueryDomainByDomainNameRequest): QueryDomainByDomainNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainByDomainName', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainByInstanceIdRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDomainByInstanceIdResponseBody = {
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  domainName?: string(name='DomainName'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  email?: string(name='Email'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  premium?: boolean(name='Premium'),
  realNameStatus?: string(name='RealNameStatus'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  requestId?: string(name='RequestId'),
  transferOutStatus?: string(name='TransferOutStatus'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
  userId?: string(name='UserId'),
}

model QueryDomainByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainByInstanceIdResponseBody(name='body'),
}

async function queryDomainByInstanceId(request: QueryDomainByInstanceIdRequest): QueryDomainByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainByInstanceId', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainListRequest {
  domainName?: string(name='DomainName', position='Query'),
  endExpirationDate?: long(name='EndExpirationDate', position='Query'),
  endRegistrationDate?: long(name='EndRegistrationDate', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderByType?: string(name='OrderByType', position='Query'),
  orderKeyType?: string(name='OrderKeyType', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  productDomainType?: string(name='ProductDomainType', position='Query'),
  queryType?: string(name='QueryType', position='Query'),
  startExpirationDate?: long(name='StartExpirationDate', position='Query'),
  startRegistrationDate?: long(name='StartRegistrationDate', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDomainListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    domain?: [ 
    {
      domainAuditStatus?: string(name='DomainAuditStatus'),
      domainName?: string(name='DomainName'),
      domainStatus?: string(name='DomainStatus'),
      domainType?: string(name='DomainType'),
      expirationCurrDateDiff?: int32(name='ExpirationCurrDateDiff'),
      expirationDate?: string(name='ExpirationDate'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      expirationDateStatus?: string(name='ExpirationDateStatus'),
      instanceId?: string(name='InstanceId'),
      premium?: boolean(name='Premium'),
      productId?: string(name='ProductId'),
      registrantType?: string(name='RegistrantType'),
      registrationDate?: string(name='RegistrationDate'),
      registrationDateLong?: long(name='RegistrationDateLong'),
      remark?: string(name='Remark'),
    }
  ](name='Domain')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryDomainListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainListResponseBody(name='body'),
}

async function queryDomainList(request: QueryDomainListRequest): QueryDomainListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainList', 'POST', '/', 'json', false, 'json', request);
}

model QueryDomainRealNameVerificationInfoRequest {
  domainName: string(name='DomainName', position='Query'),
  fetchImage?: boolean(name='FetchImage', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryDomainRealNameVerificationInfoResponseBody = {
  domainName?: string(name='DomainName'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  submissionDate?: string(name='SubmissionDate'),
}

model QueryDomainRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainRealNameVerificationInfoResponseBody(name='body'),
}

async function queryDomainRealNameVerificationInfo(request: QueryDomainRealNameVerificationInfoRequest): QueryDomainRealNameVerificationInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDomainRealNameVerificationInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryEnsAssociationRequest {
  domainName: string(name='DomainName', example='abc.luxe', position='Query'),
  lang?: string(name='Lang', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1', position='Query'),
}

model QueryEnsAssociationResponseBody = {
  address?: string(name='Address', example='0x0000000000000000000000000000000000000003'),
  requestId?: string(name='RequestId', example='AF7D4DCE-0776-47F2-A9B2-6FB85A87AA60'),
}

model QueryEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEnsAssociationResponseBody(name='body'),
}

async function queryEnsAssociation(request: QueryEnsAssociationRequest): QueryEnsAssociationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryEnsAssociation', 'POST', '/', 'json', false, 'json', request);
}

model QueryFailReasonForDomainRealNameVerificationRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  realNameVerificationAction: string(name='RealNameVerificationAction', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryFailReasonForDomainRealNameVerificationResponseBody = {
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryFailReasonForDomainRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFailReasonForDomainRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForDomainRealNameVerification(request: QueryFailReasonForDomainRealNameVerificationRequest): QueryFailReasonForDomainRealNameVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryFailReasonForDomainRealNameVerification', 'POST', '/', 'json', false, 'json', request);
}

model QueryFailReasonForRegistrantProfileRealNameVerificationRequest {
  lang?: string(name='Lang', position='Query'),
  registrantProfileID: long(name='RegistrantProfileID', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody = {
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForRegistrantProfileRealNameVerification(request: QueryFailReasonForRegistrantProfileRealNameVerificationRequest): QueryFailReasonForRegistrantProfileRealNameVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryFailReasonForRegistrantProfileRealNameVerification', 'POST', '/', 'json', false, 'json', request);
}

model QueryLocalEnsAssociationRequest {
  domainName: string(name='DomainName', example='abc.luxe', position='Query'),
  lang?: string(name='Lang', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1', position='Query'),
}

model QueryLocalEnsAssociationResponseBody = {
  address?: string(name='Address', example='0x0000000000000000000000000000000000000003'),
  requestId?: string(name='RequestId', example='AF7D4DCE-0776-47F2-A9B2-6FB85A87AA60'),
}

model QueryLocalEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryLocalEnsAssociationResponseBody(name='body'),
}

async function queryLocalEnsAssociation(request: QueryLocalEnsAssociationRequest): QueryLocalEnsAssociationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryLocalEnsAssociation', 'POST', '/', 'json', false, 'json', request);
}

model QueryRegistrantProfileRealNameVerificationInfoRequest {
  fetchImage?: boolean(name='FetchImage', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponseBody = {
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
  modificationDate?: string(name='ModificationDate'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  requestId?: string(name='RequestId'),
  submissionDate?: string(name='SubmissionDate'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRegistrantProfileRealNameVerificationInfoResponseBody(name='body'),
}

async function queryRegistrantProfileRealNameVerificationInfo(request: QueryRegistrantProfileRealNameVerificationInfoRequest): QueryRegistrantProfileRealNameVerificationInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryRegistrantProfileRealNameVerificationInfo', 'POST', '/', 'json', false, 'json', request);
}

model QueryRegistrantProfilesRequest {
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile', position='Query'),
  email?: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum?: int32(name='PageNum', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  realNameStatus?: string(name='RealNameStatus', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  registrantProfileId?: long(name='RegistrantProfileId', position='Query'),
  registrantProfileType?: string(name='RegistrantProfileType', position='Query'),
  registrantType?: string(name='RegistrantType', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryRegistrantProfilesResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  registrantProfiles?: {
    registrantProfile?: [ 
    {
      address?: string(name='Address'),
      city?: string(name='City'),
      country?: string(name='Country'),
      createTime?: string(name='CreateTime'),
      defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
      email?: string(name='Email'),
      emailVerificationStatus?: int32(name='EmailVerificationStatus'),
      postalCode?: string(name='PostalCode'),
      province?: string(name='Province'),
      realNameStatus?: string(name='RealNameStatus'),
      registrantName?: string(name='RegistrantName'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      registrantProfileType?: string(name='RegistrantProfileType'),
      registrantType?: string(name='RegistrantType'),
      telArea?: string(name='TelArea'),
      telExt?: string(name='TelExt'),
      telephone?: string(name='Telephone'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='RegistrantProfile')
  }(name='RegistrantProfiles'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryRegistrantProfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRegistrantProfilesResponseBody(name='body'),
}

async function queryRegistrantProfiles(request: QueryRegistrantProfilesRequest): QueryRegistrantProfilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryRegistrantProfiles', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskDetailHistoryRequest {
  domainName?: string(name='DomainName', position='Query'),
  domainNameCursor?: string(name='DomainNameCursor', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  taskDetailNoCursor?: string(name='TaskDetailNoCursor', position='Query'),
  taskNo: string(name='TaskNo', position='Query'),
  taskStatus?: int32(name='TaskStatus', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTaskDetailHistoryResponseBody = {
  currentPageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='CurrentPageCursor'),
  nextPageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='NextPageCursor'),
  objects?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Objects'),
  pageSize?: int32(name='PageSize'),
  prePageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='PrePageCursor'),
  requestId?: string(name='RequestId'),
}

model QueryTaskDetailHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskDetailHistoryResponseBody(name='body'),
}

async function queryTaskDetailHistory(request: QueryTaskDetailHistoryRequest): QueryTaskDetailHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskDetailHistory', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskDetailListRequest {
  domainName?: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  taskNo: string(name='TaskNo', position='Query'),
  taskStatus?: int32(name='TaskStatus', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTaskDetailListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskDetail?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskDetailListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskDetailListResponseBody(name='body'),
}

async function queryTaskDetailList(request: QueryTaskDetailListRequest): QueryTaskDetailListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskDetailList', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskInfoHistoryRequest {
  beginCreateTime?: long(name='BeginCreateTime', position='Query'),
  createTimeCursor?: long(name='CreateTimeCursor', position='Query'),
  endCreateTime?: long(name='EndCreateTime', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  taskNoCursor?: string(name='TaskNoCursor', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTaskInfoHistoryResponseBody = {
  currentPageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='CurrentPageCursor'),
  nextPageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='NextPageCursor'),
  objects?: [ 
    {
      clientip?: string(name='Clientip'),
      createTime?: string(name='CreateTime'),
      createTimeLong?: long(name='CreateTimeLong'),
      taskNo?: string(name='TaskNo'),
      taskNum?: int32(name='TaskNum'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
    }
  ](name='Objects'),
  pageSize?: int32(name='PageSize'),
  prePageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='PrePageCursor'),
  requestId?: string(name='RequestId'),
}

model QueryTaskInfoHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskInfoHistoryResponseBody(name='body'),
}

async function queryTaskInfoHistory(request: QueryTaskInfoHistoryRequest): QueryTaskInfoHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskInfoHistory', 'POST', '/', 'json', false, 'json', request);
}

model QueryTaskListRequest {
  beginCreateTime?: long(name='BeginCreateTime', position='Query'),
  endCreateTime?: long(name='EndCreateTime', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTaskListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskInfo?: [ 
    {
      clientip?: string(name='Clientip'),
      createTime?: string(name='CreateTime'),
      taskCancelStatus?: string(name='TaskCancelStatus'),
      taskCancelStatusCode?: int32(name='TaskCancelStatusCode'),
      taskNo?: string(name='TaskNo'),
      taskNum?: int32(name='TaskNum'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
    }
  ](name='TaskInfo')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTaskList', 'POST', '/', 'json', false, 'json', request);
}

model QueryTransferInByInstanceIdRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTransferInByInstanceIdResponseBody = {
  domainName?: string(name='DomainName'),
  email?: string(name='Email'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  modificationDate?: string(name='ModificationDate'),
  modificationDateLong?: long(name='ModificationDateLong'),
  needMailCheck?: boolean(name='NeedMailCheck'),
  progressBarType?: int32(name='ProgressBarType'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultDate?: string(name='ResultDate'),
  resultDateLong?: long(name='ResultDateLong'),
  resultMsg?: string(name='ResultMsg'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
  status?: int32(name='Status'),
  submissionDate?: string(name='SubmissionDate'),
  submissionDateLong?: long(name='SubmissionDateLong'),
  transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
  transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
  userId?: string(name='UserId'),
  whoisMailStatus?: boolean(name='WhoisMailStatus'),
}

model QueryTransferInByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferInByInstanceIdResponseBody(name='body'),
}

async function queryTransferInByInstanceId(request: QueryTransferInByInstanceIdRequest): QueryTransferInByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTransferInByInstanceId', 'POST', '/', 'json', false, 'json', request);
}

model QueryTransferInListRequest {
  domainName?: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  pageNum: int32(name='PageNum', position='Query'),
  pageSize: int32(name='PageSize', position='Query'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus', position='Query'),
  submissionEndDate?: long(name='SubmissionEndDate', position='Query'),
  submissionStartDate?: long(name='SubmissionStartDate', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTransferInListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    transferInInfo?: [ 
    {
      domainName?: string(name='DomainName'),
      email?: string(name='Email'),
      expirationDate?: string(name='ExpirationDate'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      instanceId?: string(name='InstanceId'),
      modificationDate?: string(name='ModificationDate'),
      modificationDateLong?: long(name='ModificationDateLong'),
      needMailCheck?: boolean(name='NeedMailCheck'),
      progressBarType?: int32(name='ProgressBarType'),
      resultCode?: string(name='ResultCode'),
      resultDate?: string(name='ResultDate'),
      resultDateLong?: long(name='ResultDateLong'),
      resultMsg?: string(name='ResultMsg'),
      simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
      status?: int32(name='Status'),
      submissionDate?: string(name='SubmissionDate'),
      submissionDateLong?: long(name='SubmissionDateLong'),
      transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
      transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
      userId?: string(name='UserId'),
      whoisMailStatus?: boolean(name='WhoisMailStatus'),
    }
  ](name='TransferInInfo')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTransferInListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferInListResponseBody(name='body'),
}

async function queryTransferInList(request: QueryTransferInListRequest): QueryTransferInListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTransferInList', 'POST', '/', 'json', false, 'json', request);
}

model QueryTransferOutInfoRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model QueryTransferOutInfoResponseBody = {
  email?: string(name='Email'),
  expirationDate?: string(name='ExpirationDate'),
  pendingRequestDate?: string(name='PendingRequestDate'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMsg?: string(name='ResultMsg'),
  status?: int32(name='Status'),
  transferAuthorizationCodeSendDate?: string(name='TransferAuthorizationCodeSendDate'),
}

model QueryTransferOutInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferOutInfoResponseBody(name='body'),
}

async function queryTransferOutInfo(request: QueryTransferOutInfoRequest): QueryTransferOutInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryTransferOutInfo', 'POST', '/', 'json', false, 'json', request);
}

model RegistrantProfileRealNameVerificationRequest {
  identityCredential: string(name='IdentityCredential', position='Body'),
  identityCredentialNo: string(name='IdentityCredentialNo', position='Query'),
  identityCredentialType: string(name='IdentityCredentialType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileID: long(name='RegistrantProfileID', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model RegistrantProfileRealNameVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function registrantProfileRealNameVerification(request: RegistrantProfileRealNameVerificationRequest): RegistrantProfileRealNameVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegistrantProfileRealNameVerification', 'POST', '/', 'json', true, 'form', request);
}

model ResendEmailVerificationRequest {
  email: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model ResendEmailVerificationResponseBody = {
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model ResendEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResendEmailVerificationResponseBody(name='body'),
}

async function resendEmailVerification(request: ResendEmailVerificationRequest): ResendEmailVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResendEmailVerification', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForCreatingOrderActivateRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderActivateParam: [ 
    {
      address?: string(name='Address'),
      aliyunDns?: boolean(name='AliyunDns'),
      city?: string(name='City'),
      country?: string(name='Country'),
      dns1?: string(name='Dns1'),
      dns2?: string(name='Dns2'),
      domainName?: string(name='DomainName'),
      email?: string(name='Email'),
      enableDomainProxy?: boolean(name='EnableDomainProxy'),
      permitPremiumActivation?: boolean(name='PermitPremiumActivation'),
      postalCode?: string(name='PostalCode'),
      province?: string(name='Province'),
      registrantName?: string(name='RegistrantName'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      registrantType?: string(name='RegistrantType'),
      subscriptionDuration?: int32(name='SubscriptionDuration'),
      telArea?: string(name='TelArea'),
      telExt?: string(name='TelExt'),
      telephone?: string(name='Telephone'),
      trademarkDomainActivation?: boolean(name='TrademarkDomainActivation'),
    }
  ](name='OrderActivateParam', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderActivate(request: SaveBatchTaskForCreatingOrderActivateRequest): SaveBatchTaskForCreatingOrderActivateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForCreatingOrderActivate', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForCreatingOrderRedeemRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderRedeemParam: [ 
    {
      currentExpirationDate?: long(name='CurrentExpirationDate'),
      domainName?: string(name='DomainName'),
    }
  ](name='OrderRedeemParam', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRedeem(request: SaveBatchTaskForCreatingOrderRedeemRequest): SaveBatchTaskForCreatingOrderRedeemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForCreatingOrderRedeem', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForCreatingOrderRenewRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderRenewParam: [ 
    {
      currentExpirationDate?: long(name='CurrentExpirationDate'),
      domainName?: string(name='DomainName'),
      subscriptionDuration?: int32(name='SubscriptionDuration'),
    }
  ](name='OrderRenewParam', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRenew(request: SaveBatchTaskForCreatingOrderRenewRequest): SaveBatchTaskForCreatingOrderRenewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForCreatingOrderRenew', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForCreatingOrderTransferRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  lang?: string(name='Lang', position='Query'),
  orderTransferParam: [ 
    {
      authorizationCode?: string(name='AuthorizationCode'),
      domainName?: string(name='DomainName'),
      permitPremiumTransfer?: boolean(name='PermitPremiumTransfer'),
      registrantProfileId?: long(name='RegistrantProfileId'),
    }
  ](name='OrderTransferParam', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderTransfer(request: SaveBatchTaskForCreatingOrderTransferRequest): SaveBatchTaskForCreatingOrderTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForCreatingOrderTransfer', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForDomainNameProxyServiceRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
  status: boolean(name='status', position='Query'),
}

model SaveBatchTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveBatchTaskForDomainNameProxyService(request: SaveBatchTaskForDomainNameProxyServiceRequest): SaveBatchTaskForDomainNameProxyServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForDomainNameProxyService', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForModifyingDomainDnsRequest {
  aliyunDns: boolean(name='AliyunDns', position='Query'),
  domainName: [ string ](name='DomainName', position='Query'),
  domainNameServer?: [ string ](name='DomainNameServer', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForModifyingDomainDnsResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForModifyingDomainDnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForModifyingDomainDnsResponseBody(name='body'),
}

async function saveBatchTaskForModifyingDomainDns(request: SaveBatchTaskForModifyingDomainDnsRequest): SaveBatchTaskForModifyingDomainDnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForModifyingDomainDns', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForReserveDropListDomainRequest {
  contactTemplateId: string(name='ContactTemplateId', position='Query'),
  domains: [ 
    {
      domainName: string(name='DomainName'),
    }
  ](name='Domains', position='Query'),
}

model SaveBatchTaskForReserveDropListDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForReserveDropListDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForReserveDropListDomainResponseBody(name='body'),
}

async function saveBatchTaskForReserveDropListDomain(request: SaveBatchTaskForReserveDropListDomainRequest): SaveBatchTaskForReserveDropListDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForReserveDropListDomain', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForTransferProhibitionLockRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: boolean(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForTransferProhibitionLock(request: SaveBatchTaskForTransferProhibitionLockRequest): SaveBatchTaskForTransferProhibitionLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForTransferProhibitionLock', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForUpdateProhibitionLockRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: boolean(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForUpdateProhibitionLock(request: SaveBatchTaskForUpdateProhibitionLockRequest): SaveBatchTaskForUpdateProhibitionLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForUpdateProhibitionLock', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForUpdatingContactInfoRequest {
  addTransferLock?: boolean(name='AddTransferLock', position='Query'),
  contactType: string(name='ContactType', position='Query'),
  domainName: [ string ](name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForUpdatingContactInfoResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdatingContactInfoResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfo(request: SaveBatchTaskForUpdatingContactInfoRequest): SaveBatchTaskForUpdatingContactInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForUpdatingContactInfo', 'POST', '/', 'json', false, 'json', request);
}

model SaveBatchTaskForUpdatingContactInfoByNewContactRequest {
  address?: string(name='Address', position='Query'),
  city?: string(name='City', position='Query'),
  contactType: string(name='ContactType', position='Query'),
  country?: string(name='Country', position='Query'),
  domainName: [ string ](name='DomainName', position='Query'),
  email?: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  postalCode?: string(name='PostalCode', position='Query'),
  province?: string(name='Province', position='Query'),
  registrantName?: string(name='RegistrantName', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  telArea?: string(name='TelArea', position='Query'),
  telExt?: string(name='TelExt', position='Query'),
  telephone?: string(name='Telephone', position='Query'),
  transferOutProhibited?: boolean(name='TransferOutProhibited', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfoByNewContact(request: SaveBatchTaskForUpdatingContactInfoByNewContactRequest): SaveBatchTaskForUpdatingContactInfoByNewContactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveBatchTaskForUpdatingContactInfoByNewContact', 'POST', '/', 'json', false, 'json', request);
}

model SaveRegistrantProfileRequest {
  address?: string(name='Address', position='Query'),
  city?: string(name='City', position='Query'),
  country?: string(name='Country', position='Query'),
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile', position='Query'),
  email?: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  postalCode?: string(name='PostalCode', position='Query'),
  province?: string(name='Province', position='Query'),
  registrantName?: string(name='RegistrantName', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  registrantProfileId?: long(name='RegistrantProfileId', position='Query'),
  registrantProfileType?: string(name='RegistrantProfileType', position='Query'),
  registrantType?: string(name='RegistrantType', position='Query'),
  telArea?: string(name='TelArea', position='Query'),
  telExt?: string(name='TelExt', position='Query'),
  telephone?: string(name='Telephone', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveRegistrantProfileResponseBody = {
  registrantProfileId?: long(name='RegistrantProfileId'),
  requestId?: string(name='RequestId'),
}

model SaveRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveRegistrantProfileResponseBody(name='body'),
}

async function saveRegistrantProfile(request: SaveRegistrantProfileRequest): SaveRegistrantProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveRegistrantProfile', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForAddingDSRecordRequest {
  algorithm: int32(name='Algorithm', position='Query'),
  digest: string(name='Digest', position='Query'),
  digestType: int32(name='DigestType', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  keyTag: int32(name='KeyTag', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForAddingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForAddingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForAddingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForAddingDSRecord(request: SaveSingleTaskForAddingDSRecordRequest): SaveSingleTaskForAddingDSRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForAddingDSRecord', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForApprovingTransferOutRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForApprovingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForApprovingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForApprovingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForApprovingTransferOut(request: SaveSingleTaskForApprovingTransferOutRequest): SaveSingleTaskForApprovingTransferOutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForApprovingTransferOut', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForAssociatingEnsRequest {
  address: string(name='Address', example='0x0000000000000000000000000000000000000003', position='Query'),
  domainName: string(name='DomainName', example='abc.luxe', position='Query'),
  lang?: string(name='Lang', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1', position='Query'),
}

model SaveSingleTaskForAssociatingEnsResponseBody = {
  requestId?: string(name='RequestId', example='A9C35C47-3366-482E-B872-8C9EA4733FE9'),
  taskNo?: string(name='TaskNo', example='561bc091-f16f-4132-8d63-f15edce45731'),
}

model SaveSingleTaskForAssociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForAssociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForAssociatingEns(request: SaveSingleTaskForAssociatingEnsRequest): SaveSingleTaskForAssociatingEnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForAssociatingEns', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCancelingTransferInRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCancelingTransferInResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferInResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCancelingTransferInResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferIn(request: SaveSingleTaskForCancelingTransferInRequest): SaveSingleTaskForCancelingTransferInResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCancelingTransferIn', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCancelingTransferOutRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCancelingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCancelingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferOut(request: SaveSingleTaskForCancelingTransferOutRequest): SaveSingleTaskForCancelingTransferOutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCancelingTransferOut', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCreatingDnsHostRequest {
  dnsName: string(name='DnsName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ip: [ string ](name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCreatingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForCreatingDnsHost(request: SaveSingleTaskForCreatingDnsHostRequest): SaveSingleTaskForCreatingDnsHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCreatingDnsHost', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCreatingOrderActivateRequest {
  address?: string(name='Address', position='Query'),
  aliyunDns?: boolean(name='AliyunDns', position='Query'),
  city?: string(name='City', position='Query'),
  country?: string(name='Country', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  dns1?: string(name='Dns1', position='Query'),
  dns2?: string(name='Dns2', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  email?: string(name='Email', position='Query'),
  enableDomainProxy?: boolean(name='EnableDomainProxy', position='Query'),
  lang?: string(name='Lang', position='Query'),
  permitPremiumActivation?: boolean(name='PermitPremiumActivation', position='Query'),
  postalCode?: string(name='PostalCode', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  province?: string(name='Province', position='Query'),
  registrantName?: string(name='RegistrantName', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  registrantProfileId?: long(name='RegistrantProfileId', position='Query'),
  registrantType?: string(name='RegistrantType', position='Query'),
  subscriptionDuration?: int32(name='SubscriptionDuration', position='Query'),
  telArea?: string(name='TelArea', position='Query'),
  telExt?: string(name='TelExt', position='Query'),
  telephone?: string(name='Telephone', position='Query'),
  trademarkDomainActivation?: boolean(name='TrademarkDomainActivation', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderActivate(request: SaveSingleTaskForCreatingOrderActivateRequest): SaveSingleTaskForCreatingOrderActivateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCreatingOrderActivate', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCreatingOrderRedeemRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  currentExpirationDate: long(name='CurrentExpirationDate', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRedeem(request: SaveSingleTaskForCreatingOrderRedeemRequest): SaveSingleTaskForCreatingOrderRedeemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCreatingOrderRedeem', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCreatingOrderRenewRequest {
  couponNo?: string(name='CouponNo', position='Query'),
  currentExpirationDate: long(name='CurrentExpirationDate', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  subscriptionDuration: int32(name='SubscriptionDuration', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRenew(request: SaveSingleTaskForCreatingOrderRenewRequest): SaveSingleTaskForCreatingOrderRenewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCreatingOrderRenew', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForCreatingOrderTransferRequest {
  authorizationCode: string(name='AuthorizationCode', position='Query'),
  couponNo?: string(name='CouponNo', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  permitPremiumTransfer?: boolean(name='PermitPremiumTransfer', position='Query'),
  promotionNo?: string(name='PromotionNo', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  useCoupon?: boolean(name='UseCoupon', position='Query'),
  usePromotion?: boolean(name='UsePromotion', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderTransfer(request: SaveSingleTaskForCreatingOrderTransferRequest): SaveSingleTaskForCreatingOrderTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForCreatingOrderTransfer', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForDeletingDSRecordRequest {
  domainName: string(name='DomainName', position='Query'),
  keyTag: int32(name='KeyTag', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForDeletingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDeletingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDSRecord(request: SaveSingleTaskForDeletingDSRecordRequest): SaveSingleTaskForDeletingDSRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForDeletingDSRecord', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForDeletingDnsHostRequest {
  dnsName: string(name='DnsName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ip: [ string ](name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForDeletingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDeletingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDnsHost(request: SaveSingleTaskForDeletingDnsHostRequest): SaveSingleTaskForDeletingDnsHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForDeletingDnsHost', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForDisassociatingEnsRequest {
  domainName: string(name='DomainName', example='abc.luxe', position='Query'),
  lang?: string(name='Lang', example='en', position='Query'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1', position='Query'),
}

model SaveSingleTaskForDisassociatingEnsResponseBody = {
  requestId?: string(name='RequestId', example='A9C35C47-3366-482E-B872-8C9EA4733FE9'),
  taskNo?: string(name='TaskNo', example='561bc091-f16f-4132-8d63-f15edce45731'),
}

model SaveSingleTaskForDisassociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDisassociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForDisassociatingEns(request: SaveSingleTaskForDisassociatingEnsRequest): SaveSingleTaskForDisassociatingEnsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForDisassociatingEns', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForDomainNameProxyServiceRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: boolean(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveSingleTaskForDomainNameProxyService(request: SaveSingleTaskForDomainNameProxyServiceRequest): SaveSingleTaskForDomainNameProxyServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForDomainNameProxyService', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForModifyingDSRecordRequest {
  algorithm: int32(name='Algorithm', position='Query'),
  digest: string(name='Digest', position='Query'),
  digestType: int32(name='DigestType', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  keyTag: int32(name='KeyTag', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForModifyingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForModifyingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDSRecord(request: SaveSingleTaskForModifyingDSRecordRequest): SaveSingleTaskForModifyingDSRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForModifyingDSRecord', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForModifyingDnsHostRequest {
  dnsName: string(name='DnsName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  ip: [ string ](name='Ip', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForModifyingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForModifyingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDnsHost(request: SaveSingleTaskForModifyingDnsHostRequest): SaveSingleTaskForModifyingDnsHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForModifyingDnsHost', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody(name='body'),
}

async function saveSingleTaskForQueryingTransferAuthorizationCode(request: SaveSingleTaskForQueryingTransferAuthorizationCodeRequest): SaveSingleTaskForQueryingTransferAuthorizationCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForQueryingTransferAuthorizationCode', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForSaveArtExtensionRequest {
  dateOrPeriod?: string(name='DateOrPeriod', position='Query'),
  dimensions?: string(name='Dimensions', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  features?: string(name='Features', position='Query'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings', position='Query'),
  lang?: string(name='Lang', position='Query'),
  maker?: string(name='Maker', position='Query'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques', position='Query'),
  objectType?: string(name='ObjectType', position='Query'),
  reference?: string(name='Reference', position='Query'),
  subject?: string(name='Subject', position='Query'),
  title?: string(name='Title', position='Query'),
}

model SaveSingleTaskForSaveArtExtensionResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSaveArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSaveArtExtensionResponseBody(name='body'),
}

async function saveSingleTaskForSaveArtExtension(request: SaveSingleTaskForSaveArtExtensionRequest): SaveSingleTaskForSaveArtExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForSaveArtExtension', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForSynchronizingDSRecordRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForSynchronizingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSynchronizingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDSRecord(request: SaveSingleTaskForSynchronizingDSRecordRequest): SaveSingleTaskForSynchronizingDSRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForSynchronizingDSRecord', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForSynchronizingDnsHostRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForSynchronizingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSynchronizingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDnsHost(request: SaveSingleTaskForSynchronizingDnsHostRequest): SaveSingleTaskForSynchronizingDnsHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForSynchronizingDnsHost', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForTransferProhibitionLockRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: boolean(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForTransferProhibitionLock(request: SaveSingleTaskForTransferProhibitionLockRequest): SaveSingleTaskForTransferProhibitionLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForTransferProhibitionLock', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForUpdateProhibitionLockRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  status: boolean(name='Status', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForUpdateProhibitionLock(request: SaveSingleTaskForUpdateProhibitionLockRequest): SaveSingleTaskForUpdateProhibitionLockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForUpdateProhibitionLock', 'POST', '/', 'json', false, 'json', request);
}

model SaveSingleTaskForUpdatingContactInfoRequest {
  addTransferLock?: boolean(name='AddTransferLock', position='Query'),
  contactType: string(name='ContactType', position='Query'),
  domainName: string(name='DomainName', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveSingleTaskForUpdatingContactInfoResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdatingContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForUpdatingContactInfoResponseBody(name='body'),
}

async function saveSingleTaskForUpdatingContactInfo(request: SaveSingleTaskForUpdatingContactInfoRequest): SaveSingleTaskForUpdatingContactInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveSingleTaskForUpdatingContactInfo', 'POST', '/', 'json', false, 'json', request);
}

model SaveTaskForSubmittingDomainDeleteRequest {
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveTaskForSubmittingDomainDeleteResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainDeleteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainDeleteResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainDelete(request: SaveTaskForSubmittingDomainDeleteRequest): SaveTaskForSubmittingDomainDeleteResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTaskForSubmittingDomainDelete', 'POST', '/', 'json', false, 'json', request);
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  identityCredential: string(name='IdentityCredential', position='Body'),
  identityCredentialNo: string(name='IdentityCredentialNo', position='Query'),
  identityCredentialType: string(name='IdentityCredentialType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByIdentityCredential(request: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest): SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredential', 'POST', '/', 'json', true, 'form', request);
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest {
  domainName: string(name='DomainName', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID(request: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest): SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID', 'POST', '/', 'json', false, 'json', request);
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest {
  address?: string(name='Address', position='Query'),
  city?: string(name='City', position='Query'),
  country?: string(name='Country', position='Query'),
  domainName: [ string ](name='DomainName', position='Query'),
  email?: string(name='Email', position='Query'),
  identityCredential: string(name='IdentityCredential', position='Body'),
  identityCredentialNo: string(name='IdentityCredentialNo', position='Query'),
  identityCredentialType: string(name='IdentityCredentialType', position='Query'),
  lang?: string(name='Lang', position='Query'),
  postalCode?: string(name='PostalCode', position='Query'),
  province?: string(name='Province', position='Query'),
  registrantName?: string(name='RegistrantName', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  registrantType: string(name='RegistrantType', position='Query'),
  telArea: string(name='TelArea', position='Query'),
  telExt?: string(name='TelExt', position='Query'),
  telephone: string(name='Telephone', position='Query'),
  transferOutProhibited: boolean(name='TransferOutProhibited', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByIdentityCredential(request: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest): SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTaskForUpdatingRegistrantInfoByIdentityCredential', 'POST', '/', 'json', true, 'form', request);
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest {
  domainName: [ string ](name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  registrantProfileId: long(name='RegistrantProfileId', position='Query'),
  transferOutProhibited: boolean(name='TransferOutProhibited', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByRegistrantProfileID(request: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest): SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveTaskForUpdatingRegistrantInfoByRegistrantProfileID', 'POST', '/', 'json', false, 'json', request);
}

model SubmitEmailVerificationRequest {
  email: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  sendIfExist?: boolean(name='SendIfExist', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model SubmitEmailVerificationResponseBody = {
  existList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='ExistList'),
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model SubmitEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitEmailVerificationResponseBody(name='body'),
}

async function submitEmailVerification(request: SubmitEmailVerificationRequest): SubmitEmailVerificationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SubmitEmailVerification', 'POST', '/', 'json', false, 'json', request);
}

model TransferInCheckMailTokenRequest {
  lang?: string(name='Lang', position='Query'),
  token: string(name='Token', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model TransferInCheckMailTokenResponseBody = {
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
}

model TransferInCheckMailTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInCheckMailTokenResponseBody(name='body'),
}

async function transferInCheckMailToken(request: TransferInCheckMailTokenRequest): TransferInCheckMailTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferInCheckMailToken', 'POST', '/', 'json', false, 'json', request);
}

model TransferInReenterTransferAuthorizationCodeRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  transferAuthorizationCode: string(name='TransferAuthorizationCode', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model TransferInReenterTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInReenterTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInReenterTransferAuthorizationCodeResponseBody(name='body'),
}

async function transferInReenterTransferAuthorizationCode(request: TransferInReenterTransferAuthorizationCodeRequest): TransferInReenterTransferAuthorizationCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferInReenterTransferAuthorizationCode', 'POST', '/', 'json', false, 'json', request);
}

model TransferInRefetchWhoisEmailRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model TransferInRefetchWhoisEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInRefetchWhoisEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInRefetchWhoisEmailResponseBody(name='body'),
}

async function transferInRefetchWhoisEmail(request: TransferInRefetchWhoisEmailRequest): TransferInRefetchWhoisEmailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferInRefetchWhoisEmail', 'POST', '/', 'json', false, 'json', request);
}

model TransferInResendMailTokenRequest {
  domainName: string(name='DomainName', position='Query'),
  lang?: string(name='Lang', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model TransferInResendMailTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInResendMailTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInResendMailTokenResponseBody(name='body'),
}

async function transferInResendMailToken(request: TransferInResendMailTokenRequest): TransferInResendMailTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransferInResendMailToken', 'POST', '/', 'json', false, 'json', request);
}

model VerifyContactFieldRequest {
  address?: string(name='Address', position='Query'),
  city?: string(name='City', position='Query'),
  country?: string(name='Country', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  email?: string(name='Email', position='Query'),
  lang?: string(name='Lang', position='Query'),
  postalCode?: string(name='PostalCode', position='Query'),
  province?: string(name='Province', position='Query'),
  registrantName?: string(name='RegistrantName', position='Query'),
  registrantOrganization?: string(name='RegistrantOrganization', position='Query'),
  registrantType?: string(name='RegistrantType', position='Query'),
  telArea?: string(name='TelArea', position='Query'),
  telExt?: string(name='TelExt', position='Query'),
  telephone?: string(name='Telephone', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model VerifyContactFieldResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyContactFieldResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyContactFieldResponseBody(name='body'),
}

async function verifyContactField(request: VerifyContactFieldRequest): VerifyContactFieldResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyContactField', 'POST', '/', 'json', false, 'json', request);
}

model VerifyEmailRequest {
  lang?: string(name='Lang', position='Query'),
  token: string(name='Token', position='Query'),
  userClientIp?: string(name='UserClientIp', position='Query'),
}

model VerifyEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyEmailResponseBody(name='body'),
}

async function verifyEmail(request: VerifyEmailRequest): VerifyEmailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyEmail', 'POST', '/', 'json', false, 'json', request);
}

