/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('domain-intl', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AcknowledgeTaskResultRequest {
  lang?: string(name='Lang'),
  taskDetailNo?: [ string ](name='TaskDetailNo'),
  userClientIp?: string(name='UserClientIp'),
}

model AcknowledgeTaskResultResponseBody = {
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model AcknowledgeTaskResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AcknowledgeTaskResultResponseBody(name='body'),
}

async function acknowledgeTaskResultWithOptions(request: AcknowledgeTaskResultRequest, runtime: Util.RuntimeOptions): AcknowledgeTaskResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskDetailNo)) {
    query['TaskDetailNo'] = request.taskDetailNo;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AcknowledgeTaskResult',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function acknowledgeTaskResult(request: AcknowledgeTaskResultRequest): AcknowledgeTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return acknowledgeTaskResultWithOptions(request, runtime);
}

model BatchFuzzyMatchDomainSensitiveWordRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model BatchFuzzyMatchDomainSensitiveWordResponseBody = {
  requestId?: string(name='RequestId'),
  sensitiveWordMatchResultList?: {
    sensitiveWordMatchResult?: [ 
    {
      exist?: boolean(name='Exist'),
      keyword?: string(name='Keyword'),
      matchedSentiveWords?: {
        matchedSensitiveWord?: [ 
        {
          word?: string(name='Word'),
        }
      ](name='MatchedSensitiveWord')
      }(name='MatchedSentiveWords'),
    }
  ](name='SensitiveWordMatchResult')
  }(name='SensitiveWordMatchResultList'),
}

model BatchFuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchFuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function batchFuzzyMatchDomainSensitiveWordWithOptions(request: BatchFuzzyMatchDomainSensitiveWordRequest, runtime: Util.RuntimeOptions): BatchFuzzyMatchDomainSensitiveWordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchFuzzyMatchDomainSensitiveWord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchFuzzyMatchDomainSensitiveWord(request: BatchFuzzyMatchDomainSensitiveWordRequest): BatchFuzzyMatchDomainSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchFuzzyMatchDomainSensitiveWordWithOptions(request, runtime);
}

model CancelDomainVerificationRequest {
  actionType?: string(name='ActionType'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model CancelDomainVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelDomainVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelDomainVerificationResponseBody(name='body'),
}

async function cancelDomainVerificationWithOptions(request: CancelDomainVerificationRequest, runtime: Util.RuntimeOptions): CancelDomainVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelDomainVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelDomainVerification(request: CancelDomainVerificationRequest): CancelDomainVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelDomainVerificationWithOptions(request, runtime);
}

model CancelTaskRequest {
  lang?: string(name='Lang'),
  taskNo?: string(name='TaskNo'),
  userClientIp?: string(name='UserClientIp'),
}

model CancelTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelTaskResponseBody(name='body'),
}

async function cancelTaskWithOptions(request: CancelTaskRequest, runtime: Util.RuntimeOptions): CancelTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.taskNo)) {
    query['TaskNo'] = request.taskNo;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelTask',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelTask(request: CancelTaskRequest): CancelTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelTaskWithOptions(request, runtime);
}

model CheckDomainRequest {
  domainName?: string(name='DomainName'),
  feeCommand?: string(name='FeeCommand'),
  feeCurrency?: string(name='FeeCurrency'),
  feePeriod?: int32(name='FeePeriod'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model CheckDomainResponseBody = {
  avail?: string(name='Avail'),
  domainName?: string(name='DomainName'),
  dynamicCheck?: boolean(name='DynamicCheck'),
  premium?: string(name='Premium'),
  price?: long(name='Price'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
}

model CheckDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDomainResponseBody(name='body'),
}

async function checkDomainWithOptions(request: CheckDomainRequest, runtime: Util.RuntimeOptions): CheckDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.feeCommand)) {
    query['FeeCommand'] = request.feeCommand;
  }
  if (!Util.isUnset(request.feeCurrency)) {
    query['FeeCurrency'] = request.feeCurrency;
  }
  if (!Util.isUnset(request.feePeriod)) {
    query['FeePeriod'] = request.feePeriod;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDomain',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainWithOptions(request, runtime);
}

model CheckDomainSunriseClaimRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model CheckDomainSunriseClaimResponseBody = {
  claimKey?: string(name='ClaimKey'),
  requestId?: string(name='RequestId'),
  result?: int32(name='Result'),
}

model CheckDomainSunriseClaimResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDomainSunriseClaimResponseBody(name='body'),
}

async function checkDomainSunriseClaimWithOptions(request: CheckDomainSunriseClaimRequest, runtime: Util.RuntimeOptions): CheckDomainSunriseClaimResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDomainSunriseClaim',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDomainSunriseClaim(request: CheckDomainSunriseClaimRequest): CheckDomainSunriseClaimResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainSunriseClaimWithOptions(request, runtime);
}

model CheckTransferInFeasibilityRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  transferAuthorizationCode?: string(name='TransferAuthorizationCode'),
  userClientIp?: string(name='UserClientIp'),
}

model CheckTransferInFeasibilityResponseBody = {
  canTransfer?: boolean(name='CanTransfer'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  productId?: string(name='ProductId'),
  requestId?: string(name='RequestId'),
}

model CheckTransferInFeasibilityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckTransferInFeasibilityResponseBody(name='body'),
}

async function checkTransferInFeasibilityWithOptions(request: CheckTransferInFeasibilityRequest, runtime: Util.RuntimeOptions): CheckTransferInFeasibilityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.transferAuthorizationCode)) {
    query['TransferAuthorizationCode'] = request.transferAuthorizationCode;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckTransferInFeasibility',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkTransferInFeasibility(request: CheckTransferInFeasibilityRequest): CheckTransferInFeasibilityResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkTransferInFeasibilityWithOptions(request, runtime);
}

model ConfirmTransferInEmailRequest {
  domainName?: [ string ](name='DomainName'),
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model ConfirmTransferInEmailResponseBody = {
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
}

model ConfirmTransferInEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmTransferInEmailResponseBody(name='body'),
}

async function confirmTransferInEmailWithOptions(request: ConfirmTransferInEmailRequest, runtime: Util.RuntimeOptions): ConfirmTransferInEmailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmTransferInEmail',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmTransferInEmail(request: ConfirmTransferInEmailRequest): ConfirmTransferInEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmTransferInEmailWithOptions(request, runtime);
}

model DeleteEmailVerificationRequest {
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model DeleteEmailVerificationResponseBody = {
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model DeleteEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEmailVerificationResponseBody(name='body'),
}

async function deleteEmailVerificationWithOptions(request: DeleteEmailVerificationRequest, runtime: Util.RuntimeOptions): DeleteEmailVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEmailVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEmailVerification(request: DeleteEmailVerificationRequest): DeleteEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEmailVerificationWithOptions(request, runtime);
}

model DeleteRegistrantProfileRequest {
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  userClientIp?: string(name='UserClientIp'),
}

model DeleteRegistrantProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRegistrantProfileResponseBody(name='body'),
}

async function deleteRegistrantProfileWithOptions(request: DeleteRegistrantProfileRequest, runtime: Util.RuntimeOptions): DeleteRegistrantProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRegistrantProfile',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRegistrantProfile(request: DeleteRegistrantProfileRequest): DeleteRegistrantProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRegistrantProfileWithOptions(request, runtime);
}

model EmailVerifiedRequest {
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model EmailVerifiedResponseBody = {
  requestId?: string(name='RequestId'),
}

model EmailVerifiedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EmailVerifiedResponseBody(name='body'),
}

async function emailVerifiedWithOptions(request: EmailVerifiedRequest, runtime: Util.RuntimeOptions): EmailVerifiedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EmailVerified',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function emailVerified(request: EmailVerifiedRequest): EmailVerifiedResponse {
  var runtime = new Util.RuntimeOptions{};
  return emailVerifiedWithOptions(request, runtime);
}

model FuzzyMatchDomainSensitiveWordRequest {
  keyword?: string(name='Keyword'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model FuzzyMatchDomainSensitiveWordResponseBody = {
  exist?: boolean(name='Exist'),
  keyword?: string(name='Keyword'),
  matchedSentiveWords?: {
    matchedSensitiveWord?: [ 
    {
      word?: string(name='Word'),
    }
  ](name='MatchedSensitiveWord')
  }(name='MatchedSentiveWords'),
  requestId?: string(name='RequestId'),
}

model FuzzyMatchDomainSensitiveWordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FuzzyMatchDomainSensitiveWordResponseBody(name='body'),
}

async function fuzzyMatchDomainSensitiveWordWithOptions(request: FuzzyMatchDomainSensitiveWordRequest, runtime: Util.RuntimeOptions): FuzzyMatchDomainSensitiveWordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FuzzyMatchDomainSensitiveWord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function fuzzyMatchDomainSensitiveWord(request: FuzzyMatchDomainSensitiveWordRequest): FuzzyMatchDomainSensitiveWordResponse {
  var runtime = new Util.RuntimeOptions{};
  return fuzzyMatchDomainSensitiveWordWithOptions(request, runtime);
}

model ListEmailVerificationRequest {
  beginCreateTime?: long(name='BeginCreateTime'),
  email?: string(name='Email'),
  endCreateTime?: long(name='EndCreateTime'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  userClientIp?: string(name='UserClientIp'),
  verificationStatus?: int32(name='VerificationStatus'),
}

model ListEmailVerificationResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: [ 
    {
      confirmIp?: string(name='ConfirmIp'),
      email?: string(name='Email'),
      emailVerificationNo?: string(name='EmailVerificationNo'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      sendIp?: string(name='SendIp'),
      tokenSendTime?: string(name='TokenSendTime'),
      userId?: string(name='UserId'),
      verificationStatus?: int32(name='VerificationStatus'),
      verificationTime?: string(name='VerificationTime'),
    }
  ](name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model ListEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEmailVerificationResponseBody(name='body'),
}

async function listEmailVerificationWithOptions(request: ListEmailVerificationRequest, runtime: Util.RuntimeOptions): ListEmailVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginCreateTime)) {
    query['BeginCreateTime'] = request.beginCreateTime;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.endCreateTime)) {
    query['EndCreateTime'] = request.endCreateTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.verificationStatus)) {
    query['VerificationStatus'] = request.verificationStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEmailVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEmailVerification(request: ListEmailVerificationRequest): ListEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEmailVerificationWithOptions(request, runtime);
}

model LookupTmchNoticeRequest {
  claimKey?: string(name='ClaimKey'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model LookupTmchNoticeResponseBody = {
  claims?: {
    claim?: [ 
    {
      classDescs?: {
        classDesc?: [ 
        {
          classNum?: int32(name='ClassNum'),
          desc?: string(name='Desc'),
        }
      ](name='ClassDesc')
      }(name='ClassDescs'),
      contacts?: {
        contact?: [ 
        {
          addr?: {
            cc?: string(name='Cc'),
            city?: string(name='City'),
            pc?: string(name='Pc'),
            sp?: string(name='Sp'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          email?: string(name='Email'),
          fax?: string(name='Fax'),
          name?: string(name='Name'),
          org?: string(name='Org'),
          type?: string(name='Type'),
          voice?: string(name='Voice'),
        }
      ](name='Contact')
      }(name='Contacts'),
      goodsAndServices?: string(name='GoodsAndServices'),
      holders?: {
        holder?: [ 
        {
          addr?: {
            cc?: string(name='Cc'),
            city?: string(name='City'),
            pc?: string(name='Pc'),
            sp?: string(name='Sp'),
            street?: {
              street?: [ string ](name='Street')
            }(name='Street'),
          }(name='Addr'),
          entitlement?: string(name='Entitlement'),
          org?: string(name='Org'),
        }
      ](name='Holder')
      }(name='Holders'),
      jurDesc?: {
        desc?: string(name='Desc'),
        jurCC?: string(name='JurCC'),
      }(name='JurDesc'),
      markName?: string(name='MarkName'),
    }
  ](name='Claim')
  }(name='Claims'),
  id?: long(name='Id'),
  label?: string(name='Label'),
  notAfter?: string(name='NotAfter'),
  notBefore?: string(name='NotBefore'),
  requestId?: string(name='RequestId'),
}

model LookupTmchNoticeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LookupTmchNoticeResponseBody(name='body'),
}

async function lookupTmchNoticeWithOptions(request: LookupTmchNoticeRequest, runtime: Util.RuntimeOptions): LookupTmchNoticeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.claimKey)) {
    query['ClaimKey'] = request.claimKey;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LookupTmchNotice',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function lookupTmchNotice(request: LookupTmchNoticeRequest): LookupTmchNoticeResponse {
  var runtime = new Util.RuntimeOptions{};
  return lookupTmchNoticeWithOptions(request, runtime);
}

model PollTaskResultRequest {
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  taskNo?: string(name='TaskNo'),
  taskResultStatus?: int32(name='TaskResultStatus'),
  userClientIp?: string(name='UserClientIp'),
}

model PollTaskResultResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskDetail?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model PollTaskResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PollTaskResultResponseBody(name='body'),
}

async function pollTaskResultWithOptions(request: PollTaskResultRequest, runtime: Util.RuntimeOptions): PollTaskResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskNo)) {
    query['TaskNo'] = request.taskNo;
  }
  if (!Util.isUnset(request.taskResultStatus)) {
    query['TaskResultStatus'] = request.taskResultStatus;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PollTaskResult',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function pollTaskResult(request: PollTaskResultRequest): PollTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return pollTaskResultWithOptions(request, runtime);
}

model QueryArtExtensionRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryArtExtensionResponseBody = {
  dateOrPeriod?: string(name='DateOrPeriod'),
  dimensions?: string(name='Dimensions'),
  features?: string(name='Features'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings'),
  maker?: string(name='Maker'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques'),
  objectType?: string(name='ObjectType'),
  reference?: string(name='Reference'),
  requestId?: string(name='RequestId'),
  subject?: string(name='Subject'),
  title?: string(name='Title'),
}

model QueryArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryArtExtensionResponseBody(name='body'),
}

async function queryArtExtensionWithOptions(request: QueryArtExtensionRequest, runtime: Util.RuntimeOptions): QueryArtExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryArtExtension',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryArtExtension(request: QueryArtExtensionRequest): QueryArtExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryArtExtensionWithOptions(request, runtime);
}

model QueryChangeLogListRequest {
  domainName?: string(name='DomainName'),
  endDate?: long(name='EndDate'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startDate?: long(name='StartDate'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryChangeLogListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    changeLog?: [ 
    {
      details?: string(name='Details'),
      domainName?: string(name='DomainName'),
      operation?: string(name='Operation'),
      operationIPAddress?: string(name='OperationIPAddress'),
      result?: string(name='Result'),
      time?: string(name='Time'),
    }
  ](name='ChangeLog')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  resultLimit?: boolean(name='ResultLimit'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryChangeLogListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryChangeLogListResponseBody(name='body'),
}

async function queryChangeLogListWithOptions(request: QueryChangeLogListRequest, runtime: Util.RuntimeOptions): QueryChangeLogListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryChangeLogList',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryChangeLogList(request: QueryChangeLogListRequest): QueryChangeLogListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryChangeLogListWithOptions(request, runtime);
}

model QueryContactInfoRequest {
  contactType?: string(name='ContactType'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryContactInfoResponseBody = {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  createDate?: string(name='CreateDate'),
  email?: string(name='Email'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  requestId?: string(name='RequestId'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
}

model QueryContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryContactInfoResponseBody(name='body'),
}

async function queryContactInfoWithOptions(request: QueryContactInfoRequest, runtime: Util.RuntimeOptions): QueryContactInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactType)) {
    query['ContactType'] = request.contactType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryContactInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryContactInfo(request: QueryContactInfoRequest): QueryContactInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryContactInfoWithOptions(request, runtime);
}

model QueryDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDSRecordResponseBody = {
  DSRecordList?: [ 
    {
      algorithm?: int32(name='Algorithm'),
      digest?: string(name='Digest'),
      digestType?: int32(name='DigestType'),
      keyTag?: int32(name='KeyTag'),
    }
  ](name='DSRecordList'),
  requestId?: string(name='RequestId'),
}

model QueryDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDSRecordResponseBody(name='body'),
}

async function queryDSRecordWithOptions(request: QueryDSRecordRequest, runtime: Util.RuntimeOptions): QueryDSRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDSRecord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDSRecord(request: QueryDSRecordRequest): QueryDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDSRecordWithOptions(request, runtime);
}

model QueryDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDnsHostResponseBody = {
  dnsHostList?: [ 
    {
      dnsName?: string(name='DnsName'),
      ipList?: [ string ](name='IpList'),
    }
  ](name='DnsHostList'),
  requestId?: string(name='RequestId'),
}

model QueryDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDnsHostResponseBody(name='body'),
}

async function queryDnsHostWithOptions(request: QueryDnsHostRequest, runtime: Util.RuntimeOptions): QueryDnsHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDnsHost',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDnsHost(request: QueryDnsHostRequest): QueryDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDnsHostWithOptions(request, runtime);
}

model QueryDomainByDomainNameRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainByDomainNameResponseBody = {
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  domainName?: string(name='DomainName'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  email?: string(name='Email'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  premium?: boolean(name='Premium'),
  realNameStatus?: string(name='RealNameStatus'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  requestId?: string(name='RequestId'),
  transferOutStatus?: string(name='TransferOutStatus'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
  userId?: string(name='UserId'),
}

model QueryDomainByDomainNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainByDomainNameResponseBody(name='body'),
}

async function queryDomainByDomainNameWithOptions(request: QueryDomainByDomainNameRequest, runtime: Util.RuntimeOptions): QueryDomainByDomainNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainByDomainName',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDomainByDomainName(request: QueryDomainByDomainNameRequest): QueryDomainByDomainNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainByDomainNameWithOptions(request, runtime);
}

model QueryDomainByInstanceIdRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainByInstanceIdResponseBody = {
  dnsList?: {
    dns?: [ string ](name='Dns')
  }(name='DnsList'),
  domainName?: string(name='DomainName'),
  domainNameProxyService?: boolean(name='DomainNameProxyService'),
  domainNameVerificationStatus?: string(name='DomainNameVerificationStatus'),
  email?: string(name='Email'),
  emailVerificationClientHold?: boolean(name='EmailVerificationClientHold'),
  emailVerificationStatus?: int32(name='EmailVerificationStatus'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  premium?: boolean(name='Premium'),
  realNameStatus?: string(name='RealNameStatus'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  registrantUpdatingStatus?: string(name='RegistrantUpdatingStatus'),
  registrationDate?: string(name='RegistrationDate'),
  registrationDateLong?: long(name='RegistrationDateLong'),
  requestId?: string(name='RequestId'),
  transferOutStatus?: string(name='TransferOutStatus'),
  transferProhibitionLock?: string(name='TransferProhibitionLock'),
  updateProhibitionLock?: string(name='UpdateProhibitionLock'),
  userId?: string(name='UserId'),
}

model QueryDomainByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainByInstanceIdResponseBody(name='body'),
}

async function queryDomainByInstanceIdWithOptions(request: QueryDomainByInstanceIdRequest, runtime: Util.RuntimeOptions): QueryDomainByInstanceIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainByInstanceId',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDomainByInstanceId(request: QueryDomainByInstanceIdRequest): QueryDomainByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainByInstanceIdWithOptions(request, runtime);
}

model QueryDomainListRequest {
  domainName?: string(name='DomainName'),
  endExpirationDate?: long(name='EndExpirationDate'),
  endRegistrationDate?: long(name='EndRegistrationDate'),
  lang?: string(name='Lang'),
  orderByType?: string(name='OrderByType'),
  orderKeyType?: string(name='OrderKeyType'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productDomainType?: string(name='ProductDomainType'),
  queryType?: string(name='QueryType'),
  startExpirationDate?: long(name='StartExpirationDate'),
  startRegistrationDate?: long(name='StartRegistrationDate'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    domain?: [ 
    {
      domainAuditStatus?: string(name='DomainAuditStatus'),
      domainName?: string(name='DomainName'),
      domainStatus?: string(name='DomainStatus'),
      domainType?: string(name='DomainType'),
      expirationCurrDateDiff?: int32(name='ExpirationCurrDateDiff'),
      expirationDate?: string(name='ExpirationDate'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      expirationDateStatus?: string(name='ExpirationDateStatus'),
      instanceId?: string(name='InstanceId'),
      premium?: boolean(name='Premium'),
      productId?: string(name='ProductId'),
      registrantType?: string(name='RegistrantType'),
      registrationDate?: string(name='RegistrationDate'),
      registrationDateLong?: long(name='RegistrationDateLong'),
      remark?: string(name='Remark'),
    }
  ](name='Domain')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryDomainListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainListResponseBody(name='body'),
}

async function queryDomainListWithOptions(request: QueryDomainListRequest, runtime: Util.RuntimeOptions): QueryDomainListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.endExpirationDate)) {
    query['EndExpirationDate'] = request.endExpirationDate;
  }
  if (!Util.isUnset(request.endRegistrationDate)) {
    query['EndRegistrationDate'] = request.endRegistrationDate;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderByType)) {
    query['OrderByType'] = request.orderByType;
  }
  if (!Util.isUnset(request.orderKeyType)) {
    query['OrderKeyType'] = request.orderKeyType;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productDomainType)) {
    query['ProductDomainType'] = request.productDomainType;
  }
  if (!Util.isUnset(request.queryType)) {
    query['QueryType'] = request.queryType;
  }
  if (!Util.isUnset(request.startExpirationDate)) {
    query['StartExpirationDate'] = request.startExpirationDate;
  }
  if (!Util.isUnset(request.startRegistrationDate)) {
    query['StartRegistrationDate'] = request.startRegistrationDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainList',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDomainList(request: QueryDomainListRequest): QueryDomainListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainListWithOptions(request, runtime);
}

model QueryDomainRealNameVerificationInfoRequest {
  domainName?: string(name='DomainName'),
  fetchImage?: boolean(name='FetchImage'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryDomainRealNameVerificationInfoResponseBody = {
  domainName?: string(name='DomainName'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
  submissionDate?: string(name='SubmissionDate'),
}

model QueryDomainRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDomainRealNameVerificationInfoResponseBody(name='body'),
}

async function queryDomainRealNameVerificationInfoWithOptions(request: QueryDomainRealNameVerificationInfoRequest, runtime: Util.RuntimeOptions): QueryDomainRealNameVerificationInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.fetchImage)) {
    query['FetchImage'] = request.fetchImage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDomainRealNameVerificationInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDomainRealNameVerificationInfo(request: QueryDomainRealNameVerificationInfoRequest): QueryDomainRealNameVerificationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDomainRealNameVerificationInfoWithOptions(request, runtime);
}

model QueryEnsAssociationRequest {
  domainName?: string(name='DomainName', example='abc.luxe'),
  lang?: string(name='Lang', example='en'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1'),
}

model QueryEnsAssociationResponseBody = {
  address?: string(name='Address', example='0x0000000000000000000000000000000000000003'),
  requestId?: string(name='RequestId', example='AF7D4DCE-0776-47F2-A9B2-6FB85A87AA60'),
}

model QueryEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEnsAssociationResponseBody(name='body'),
}

async function queryEnsAssociationWithOptions(request: QueryEnsAssociationRequest, runtime: Util.RuntimeOptions): QueryEnsAssociationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEnsAssociation',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEnsAssociation(request: QueryEnsAssociationRequest): QueryEnsAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEnsAssociationWithOptions(request, runtime);
}

model QueryFailReasonForDomainRealNameVerificationRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  realNameVerificationAction?: string(name='RealNameVerificationAction'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryFailReasonForDomainRealNameVerificationResponseBody = {
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryFailReasonForDomainRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFailReasonForDomainRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForDomainRealNameVerificationWithOptions(request: QueryFailReasonForDomainRealNameVerificationRequest, runtime: Util.RuntimeOptions): QueryFailReasonForDomainRealNameVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.realNameVerificationAction)) {
    query['RealNameVerificationAction'] = request.realNameVerificationAction;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFailReasonForDomainRealNameVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFailReasonForDomainRealNameVerification(request: QueryFailReasonForDomainRealNameVerificationRequest): QueryFailReasonForDomainRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFailReasonForDomainRealNameVerificationWithOptions(request, runtime);
}

model QueryFailReasonForRegistrantProfileRealNameVerificationRequest {
  lang?: string(name='Lang'),
  registrantProfileID?: long(name='RegistrantProfileID'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody = {
  data?: [ 
    {
      date?: string(name='Date'),
      failReason?: string(name='FailReason'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryFailReasonForRegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFailReasonForRegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function queryFailReasonForRegistrantProfileRealNameVerificationWithOptions(request: QueryFailReasonForRegistrantProfileRealNameVerificationRequest, runtime: Util.RuntimeOptions): QueryFailReasonForRegistrantProfileRealNameVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileID)) {
    query['RegistrantProfileID'] = request.registrantProfileID;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFailReasonForRegistrantProfileRealNameVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFailReasonForRegistrantProfileRealNameVerification(request: QueryFailReasonForRegistrantProfileRealNameVerificationRequest): QueryFailReasonForRegistrantProfileRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFailReasonForRegistrantProfileRealNameVerificationWithOptions(request, runtime);
}

model QueryLocalEnsAssociationRequest {
  domainName?: string(name='DomainName', example='abc.luxe'),
  lang?: string(name='Lang', example='en'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1'),
}

model QueryLocalEnsAssociationResponseBody = {
  address?: string(name='Address', example='0x0000000000000000000000000000000000000003'),
  requestId?: string(name='RequestId', example='AF7D4DCE-0776-47F2-A9B2-6FB85A87AA60'),
}

model QueryLocalEnsAssociationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryLocalEnsAssociationResponseBody(name='body'),
}

async function queryLocalEnsAssociationWithOptions(request: QueryLocalEnsAssociationRequest, runtime: Util.RuntimeOptions): QueryLocalEnsAssociationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryLocalEnsAssociation',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryLocalEnsAssociation(request: QueryLocalEnsAssociationRequest): QueryLocalEnsAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryLocalEnsAssociationWithOptions(request, runtime);
}

model QueryRegistrantProfileRealNameVerificationInfoRequest {
  fetchImage?: boolean(name='FetchImage'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponseBody = {
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  identityCredentialUrl?: string(name='IdentityCredentialUrl'),
  modificationDate?: string(name='ModificationDate'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  requestId?: string(name='RequestId'),
  submissionDate?: string(name='SubmissionDate'),
}

model QueryRegistrantProfileRealNameVerificationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRegistrantProfileRealNameVerificationInfoResponseBody(name='body'),
}

async function queryRegistrantProfileRealNameVerificationInfoWithOptions(request: QueryRegistrantProfileRealNameVerificationInfoRequest, runtime: Util.RuntimeOptions): QueryRegistrantProfileRealNameVerificationInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fetchImage)) {
    query['FetchImage'] = request.fetchImage;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRegistrantProfileRealNameVerificationInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRegistrantProfileRealNameVerificationInfo(request: QueryRegistrantProfileRealNameVerificationInfoRequest): QueryRegistrantProfileRealNameVerificationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRegistrantProfileRealNameVerificationInfoWithOptions(request, runtime);
}

model QueryRegistrantProfilesRequest {
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  realNameStatus?: string(name='RealNameStatus'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  registrantProfileType?: string(name='RegistrantProfileType'),
  registrantType?: string(name='RegistrantType'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryRegistrantProfilesResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  registrantProfiles?: {
    registrantProfile?: [ 
    {
      address?: string(name='Address'),
      city?: string(name='City'),
      country?: string(name='Country'),
      createTime?: string(name='CreateTime'),
      defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
      email?: string(name='Email'),
      emailVerificationStatus?: int32(name='EmailVerificationStatus'),
      postalCode?: string(name='PostalCode'),
      province?: string(name='Province'),
      realNameStatus?: string(name='RealNameStatus'),
      registrantName?: string(name='RegistrantName'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      registrantProfileType?: string(name='RegistrantProfileType'),
      registrantType?: string(name='RegistrantType'),
      telArea?: string(name='TelArea'),
      telExt?: string(name='TelExt'),
      telephone?: string(name='Telephone'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='RegistrantProfile')
  }(name='RegistrantProfiles'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryRegistrantProfilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRegistrantProfilesResponseBody(name='body'),
}

async function queryRegistrantProfilesWithOptions(request: QueryRegistrantProfilesRequest, runtime: Util.RuntimeOptions): QueryRegistrantProfilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultRegistrantProfile)) {
    query['DefaultRegistrantProfile'] = request.defaultRegistrantProfile;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.realNameStatus)) {
    query['RealNameStatus'] = request.realNameStatus;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.registrantProfileType)) {
    query['RegistrantProfileType'] = request.registrantProfileType;
  }
  if (!Util.isUnset(request.registrantType)) {
    query['RegistrantType'] = request.registrantType;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRegistrantProfiles',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRegistrantProfiles(request: QueryRegistrantProfilesRequest): QueryRegistrantProfilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRegistrantProfilesWithOptions(request, runtime);
}

model QueryTaskDetailHistoryRequest {
  domainName?: string(name='DomainName'),
  domainNameCursor?: string(name='DomainNameCursor'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  taskDetailNoCursor?: string(name='TaskDetailNoCursor'),
  taskNo?: string(name='TaskNo'),
  taskStatus?: int32(name='TaskStatus'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTaskDetailHistoryResponseBody = {
  currentPageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='CurrentPageCursor'),
  nextPageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='NextPageCursor'),
  objects?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Objects'),
  pageSize?: int32(name='PageSize'),
  prePageCursor?: {
    createTime?: string(name='CreateTime'),
    domainName?: string(name='DomainName'),
    errorMsg?: string(name='ErrorMsg'),
    instanceId?: string(name='InstanceId'),
    taskDetailNo?: string(name='TaskDetailNo'),
    taskNo?: string(name='TaskNo'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
    tryCount?: int32(name='TryCount'),
    updateTime?: string(name='UpdateTime'),
  }(name='PrePageCursor'),
  requestId?: string(name='RequestId'),
}

model QueryTaskDetailHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskDetailHistoryResponseBody(name='body'),
}

async function queryTaskDetailHistoryWithOptions(request: QueryTaskDetailHistoryRequest, runtime: Util.RuntimeOptions): QueryTaskDetailHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainNameCursor)) {
    query['DomainNameCursor'] = request.domainNameCursor;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskDetailNoCursor)) {
    query['TaskDetailNoCursor'] = request.taskDetailNoCursor;
  }
  if (!Util.isUnset(request.taskNo)) {
    query['TaskNo'] = request.taskNo;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskDetailHistory',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskDetailHistory(request: QueryTaskDetailHistoryRequest): QueryTaskDetailHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskDetailHistoryWithOptions(request, runtime);
}

model QueryTaskDetailListRequest {
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  taskNo?: string(name='TaskNo'),
  taskStatus?: int32(name='TaskStatus'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTaskDetailListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskDetail?: [ 
    {
      createTime?: string(name='CreateTime'),
      domainName?: string(name='DomainName'),
      errorMsg?: string(name='ErrorMsg'),
      instanceId?: string(name='InstanceId'),
      taskDetailNo?: string(name='TaskDetailNo'),
      taskNo?: string(name='TaskNo'),
      taskResult?: string(name='TaskResult'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
      tryCount?: int32(name='TryCount'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='TaskDetail')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskDetailListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskDetailListResponseBody(name='body'),
}

async function queryTaskDetailListWithOptions(request: QueryTaskDetailListRequest, runtime: Util.RuntimeOptions): QueryTaskDetailListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskNo)) {
    query['TaskNo'] = request.taskNo;
  }
  if (!Util.isUnset(request.taskStatus)) {
    query['TaskStatus'] = request.taskStatus;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskDetailList',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskDetailList(request: QueryTaskDetailListRequest): QueryTaskDetailListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskDetailListWithOptions(request, runtime);
}

model QueryTaskInfoHistoryRequest {
  beginCreateTime?: long(name='BeginCreateTime'),
  createTimeCursor?: long(name='CreateTimeCursor'),
  endCreateTime?: long(name='EndCreateTime'),
  lang?: string(name='Lang'),
  pageSize?: int32(name='PageSize'),
  taskNoCursor?: string(name='TaskNoCursor'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTaskInfoHistoryResponseBody = {
  currentPageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='CurrentPageCursor'),
  nextPageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='NextPageCursor'),
  objects?: [ 
    {
      clientip?: string(name='Clientip'),
      createTime?: string(name='CreateTime'),
      createTimeLong?: long(name='CreateTimeLong'),
      taskNo?: string(name='TaskNo'),
      taskNum?: int32(name='TaskNum'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
    }
  ](name='Objects'),
  pageSize?: int32(name='PageSize'),
  prePageCursor?: {
    clientip?: string(name='Clientip'),
    createTime?: string(name='CreateTime'),
    createTimeLong?: long(name='CreateTimeLong'),
    taskNo?: string(name='TaskNo'),
    taskNum?: int32(name='TaskNum'),
    taskStatus?: string(name='TaskStatus'),
    taskStatusCode?: int32(name='TaskStatusCode'),
    taskType?: string(name='TaskType'),
    taskTypeDescription?: string(name='TaskTypeDescription'),
  }(name='PrePageCursor'),
  requestId?: string(name='RequestId'),
}

model QueryTaskInfoHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskInfoHistoryResponseBody(name='body'),
}

async function queryTaskInfoHistoryWithOptions(request: QueryTaskInfoHistoryRequest, runtime: Util.RuntimeOptions): QueryTaskInfoHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginCreateTime)) {
    query['BeginCreateTime'] = request.beginCreateTime;
  }
  if (!Util.isUnset(request.createTimeCursor)) {
    query['CreateTimeCursor'] = request.createTimeCursor;
  }
  if (!Util.isUnset(request.endCreateTime)) {
    query['EndCreateTime'] = request.endCreateTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskNoCursor)) {
    query['TaskNoCursor'] = request.taskNoCursor;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskInfoHistory',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskInfoHistory(request: QueryTaskInfoHistoryRequest): QueryTaskInfoHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskInfoHistoryWithOptions(request, runtime);
}

model QueryTaskListRequest {
  beginCreateTime?: long(name='BeginCreateTime'),
  endCreateTime?: long(name='EndCreateTime'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTaskListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    taskInfo?: [ 
    {
      clientip?: string(name='Clientip'),
      createTime?: string(name='CreateTime'),
      taskCancelStatus?: string(name='TaskCancelStatus'),
      taskCancelStatusCode?: int32(name='TaskCancelStatusCode'),
      taskNo?: string(name='TaskNo'),
      taskNum?: int32(name='TaskNum'),
      taskStatus?: string(name='TaskStatus'),
      taskStatusCode?: int32(name='TaskStatusCode'),
      taskType?: string(name='TaskType'),
      taskTypeDescription?: string(name='TaskTypeDescription'),
    }
  ](name='TaskInfo')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTaskListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTaskListResponseBody(name='body'),
}

async function queryTaskListWithOptions(request: QueryTaskListRequest, runtime: Util.RuntimeOptions): QueryTaskListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginCreateTime)) {
    query['BeginCreateTime'] = request.beginCreateTime;
  }
  if (!Util.isUnset(request.endCreateTime)) {
    query['EndCreateTime'] = request.endCreateTime;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTaskList',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTaskList(request: QueryTaskListRequest): QueryTaskListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTaskListWithOptions(request, runtime);
}

model QueryTransferInByInstanceIdRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTransferInByInstanceIdResponseBody = {
  domainName?: string(name='DomainName'),
  email?: string(name='Email'),
  expirationDate?: string(name='ExpirationDate'),
  expirationDateLong?: long(name='ExpirationDateLong'),
  instanceId?: string(name='InstanceId'),
  modificationDate?: string(name='ModificationDate'),
  modificationDateLong?: long(name='ModificationDateLong'),
  needMailCheck?: boolean(name='NeedMailCheck'),
  progressBarType?: int32(name='ProgressBarType'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultDate?: string(name='ResultDate'),
  resultDateLong?: long(name='ResultDateLong'),
  resultMsg?: string(name='ResultMsg'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
  status?: int32(name='Status'),
  submissionDate?: string(name='SubmissionDate'),
  submissionDateLong?: long(name='SubmissionDateLong'),
  transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
  transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
  userId?: string(name='UserId'),
  whoisMailStatus?: boolean(name='WhoisMailStatus'),
}

model QueryTransferInByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferInByInstanceIdResponseBody(name='body'),
}

async function queryTransferInByInstanceIdWithOptions(request: QueryTransferInByInstanceIdRequest, runtime: Util.RuntimeOptions): QueryTransferInByInstanceIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTransferInByInstanceId',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTransferInByInstanceId(request: QueryTransferInByInstanceIdRequest): QueryTransferInByInstanceIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferInByInstanceIdWithOptions(request, runtime);
}

model QueryTransferInListRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
  submissionEndDate?: long(name='SubmissionEndDate'),
  submissionStartDate?: long(name='SubmissionStartDate'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTransferInListResponseBody = {
  currentPageNum?: int32(name='CurrentPageNum'),
  data?: {
    transferInInfo?: [ 
    {
      domainName?: string(name='DomainName'),
      email?: string(name='Email'),
      expirationDate?: string(name='ExpirationDate'),
      expirationDateLong?: long(name='ExpirationDateLong'),
      instanceId?: string(name='InstanceId'),
      modificationDate?: string(name='ModificationDate'),
      modificationDateLong?: long(name='ModificationDateLong'),
      needMailCheck?: boolean(name='NeedMailCheck'),
      progressBarType?: int32(name='ProgressBarType'),
      resultCode?: string(name='ResultCode'),
      resultDate?: string(name='ResultDate'),
      resultDateLong?: long(name='ResultDateLong'),
      resultMsg?: string(name='ResultMsg'),
      simpleTransferInStatus?: string(name='SimpleTransferInStatus'),
      status?: int32(name='Status'),
      submissionDate?: string(name='SubmissionDate'),
      submissionDateLong?: long(name='SubmissionDateLong'),
      transferAuthorizationCodeSubmissionDate?: string(name='TransferAuthorizationCodeSubmissionDate'),
      transferAuthorizationCodeSubmissionDateLong?: long(name='TransferAuthorizationCodeSubmissionDateLong'),
      userId?: string(name='UserId'),
      whoisMailStatus?: boolean(name='WhoisMailStatus'),
    }
  ](name='TransferInInfo')
  }(name='Data'),
  nextPage?: boolean(name='NextPage'),
  pageSize?: int32(name='PageSize'),
  prePage?: boolean(name='PrePage'),
  requestId?: string(name='RequestId'),
  totalItemNum?: int32(name='TotalItemNum'),
  totalPageNum?: int32(name='TotalPageNum'),
}

model QueryTransferInListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferInListResponseBody(name='body'),
}

async function queryTransferInListWithOptions(request: QueryTransferInListRequest, runtime: Util.RuntimeOptions): QueryTransferInListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.simpleTransferInStatus)) {
    query['SimpleTransferInStatus'] = request.simpleTransferInStatus;
  }
  if (!Util.isUnset(request.submissionEndDate)) {
    query['SubmissionEndDate'] = request.submissionEndDate;
  }
  if (!Util.isUnset(request.submissionStartDate)) {
    query['SubmissionStartDate'] = request.submissionStartDate;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTransferInList',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTransferInList(request: QueryTransferInListRequest): QueryTransferInListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferInListWithOptions(request, runtime);
}

model QueryTransferOutInfoRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model QueryTransferOutInfoResponseBody = {
  email?: string(name='Email'),
  expirationDate?: string(name='ExpirationDate'),
  pendingRequestDate?: string(name='PendingRequestDate'),
  requestId?: string(name='RequestId'),
  resultCode?: string(name='ResultCode'),
  resultMsg?: string(name='ResultMsg'),
  status?: int32(name='Status'),
  transferAuthorizationCodeSendDate?: string(name='TransferAuthorizationCodeSendDate'),
}

model QueryTransferOutInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryTransferOutInfoResponseBody(name='body'),
}

async function queryTransferOutInfoWithOptions(request: QueryTransferOutInfoRequest, runtime: Util.RuntimeOptions): QueryTransferOutInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryTransferOutInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryTransferOutInfo(request: QueryTransferOutInfoRequest): QueryTransferOutInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryTransferOutInfoWithOptions(request, runtime);
}

model RegistrantProfileRealNameVerificationRequest {
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  lang?: string(name='Lang'),
  registrantProfileID?: long(name='RegistrantProfileID'),
  userClientIp?: string(name='UserClientIp'),
}

model RegistrantProfileRealNameVerificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model RegistrantProfileRealNameVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegistrantProfileRealNameVerificationResponseBody(name='body'),
}

async function registrantProfileRealNameVerificationWithOptions(request: RegistrantProfileRealNameVerificationRequest, runtime: Util.RuntimeOptions): RegistrantProfileRealNameVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.identityCredentialNo)) {
    query['IdentityCredentialNo'] = request.identityCredentialNo;
  }
  if (!Util.isUnset(request.identityCredentialType)) {
    query['IdentityCredentialType'] = request.identityCredentialType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileID)) {
    query['RegistrantProfileID'] = request.registrantProfileID;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.identityCredential)) {
    body['IdentityCredential'] = request.identityCredential;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegistrantProfileRealNameVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registrantProfileRealNameVerification(request: RegistrantProfileRealNameVerificationRequest): RegistrantProfileRealNameVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return registrantProfileRealNameVerificationWithOptions(request, runtime);
}

model ResendEmailVerificationRequest {
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model ResendEmailVerificationResponseBody = {
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model ResendEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResendEmailVerificationResponseBody(name='body'),
}

async function resendEmailVerificationWithOptions(request: ResendEmailVerificationRequest, runtime: Util.RuntimeOptions): ResendEmailVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResendEmailVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resendEmailVerification(request: ResendEmailVerificationRequest): ResendEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return resendEmailVerificationWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderActivateRequest {
  couponNo?: string(name='CouponNo'),
  lang?: string(name='Lang'),
  orderActivateParam?: [ 
    {
      address?: string(name='Address'),
      aliyunDns?: boolean(name='AliyunDns'),
      city?: string(name='City'),
      country?: string(name='Country'),
      dns1?: string(name='Dns1'),
      dns2?: string(name='Dns2'),
      domainName?: string(name='DomainName'),
      email?: string(name='Email'),
      enableDomainProxy?: boolean(name='EnableDomainProxy'),
      permitPremiumActivation?: boolean(name='PermitPremiumActivation'),
      postalCode?: string(name='PostalCode'),
      province?: string(name='Province'),
      registrantName?: string(name='RegistrantName'),
      registrantOrganization?: string(name='RegistrantOrganization'),
      registrantProfileId?: long(name='RegistrantProfileId'),
      registrantType?: string(name='RegistrantType'),
      subscriptionDuration?: int32(name='SubscriptionDuration'),
      telArea?: string(name='TelArea'),
      telExt?: string(name='TelExt'),
      telephone?: string(name='Telephone'),
      trademarkDomainActivation?: boolean(name='TrademarkDomainActivation'),
    }
  ](name='OrderActivateParam'),
  promotionNo?: string(name='PromotionNo'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderActivateWithOptions(request: SaveBatchTaskForCreatingOrderActivateRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderActivateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderActivateParam)) {
    query['OrderActivateParam'] = request.orderActivateParam;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForCreatingOrderActivate',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForCreatingOrderActivate(request: SaveBatchTaskForCreatingOrderActivateRequest): SaveBatchTaskForCreatingOrderActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderActivateWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderRedeemRequest {
  couponNo?: string(name='CouponNo'),
  lang?: string(name='Lang'),
  orderRedeemParam?: [ 
    {
      currentExpirationDate?: long(name='CurrentExpirationDate'),
      domainName?: string(name='DomainName'),
    }
  ](name='OrderRedeemParam'),
  promotionNo?: string(name='PromotionNo'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRedeemWithOptions(request: SaveBatchTaskForCreatingOrderRedeemRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderRedeemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderRedeemParam)) {
    query['OrderRedeemParam'] = request.orderRedeemParam;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForCreatingOrderRedeem',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForCreatingOrderRedeem(request: SaveBatchTaskForCreatingOrderRedeemRequest): SaveBatchTaskForCreatingOrderRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderRedeemWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderRenewRequest {
  couponNo?: string(name='CouponNo'),
  lang?: string(name='Lang'),
  orderRenewParam?: [ 
    {
      currentExpirationDate?: long(name='CurrentExpirationDate'),
      domainName?: string(name='DomainName'),
      subscriptionDuration?: int32(name='SubscriptionDuration'),
    }
  ](name='OrderRenewParam'),
  promotionNo?: string(name='PromotionNo'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderRenewWithOptions(request: SaveBatchTaskForCreatingOrderRenewRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderRenewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderRenewParam)) {
    query['OrderRenewParam'] = request.orderRenewParam;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForCreatingOrderRenew',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForCreatingOrderRenew(request: SaveBatchTaskForCreatingOrderRenewRequest): SaveBatchTaskForCreatingOrderRenewResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderRenewWithOptions(request, runtime);
}

model SaveBatchTaskForCreatingOrderTransferRequest {
  couponNo?: string(name='CouponNo'),
  lang?: string(name='Lang'),
  orderTransferParam?: [ 
    {
      authorizationCode?: string(name='AuthorizationCode'),
      domainName?: string(name='DomainName'),
      permitPremiumTransfer?: boolean(name='PermitPremiumTransfer'),
      registrantProfileId?: long(name='RegistrantProfileId'),
    }
  ](name='OrderTransferParam'),
  promotionNo?: string(name='PromotionNo'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveBatchTaskForCreatingOrderTransferWithOptions(request: SaveBatchTaskForCreatingOrderTransferRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForCreatingOrderTransferResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.orderTransferParam)) {
    query['OrderTransferParam'] = request.orderTransferParam;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForCreatingOrderTransfer',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForCreatingOrderTransfer(request: SaveBatchTaskForCreatingOrderTransferRequest): SaveBatchTaskForCreatingOrderTransferResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForCreatingOrderTransferWithOptions(request, runtime);
}

model SaveBatchTaskForDomainNameProxyServiceRequest {
  domainName?: [ string ](name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
  status?: boolean(name='status'),
}

model SaveBatchTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveBatchTaskForDomainNameProxyServiceWithOptions(request: SaveBatchTaskForDomainNameProxyServiceRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForDomainNameProxyServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForDomainNameProxyService',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForDomainNameProxyService(request: SaveBatchTaskForDomainNameProxyServiceRequest): SaveBatchTaskForDomainNameProxyServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForDomainNameProxyServiceWithOptions(request, runtime);
}

model SaveBatchTaskForModifyingDomainDnsRequest {
  aliyunDns?: boolean(name='AliyunDns'),
  domainName?: [ string ](name='DomainName'),
  domainNameServer?: [ string ](name='DomainNameServer'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForModifyingDomainDnsResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForModifyingDomainDnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForModifyingDomainDnsResponseBody(name='body'),
}

async function saveBatchTaskForModifyingDomainDnsWithOptions(request: SaveBatchTaskForModifyingDomainDnsRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForModifyingDomainDnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliyunDns)) {
    query['AliyunDns'] = request.aliyunDns;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.domainNameServer)) {
    query['DomainNameServer'] = request.domainNameServer;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForModifyingDomainDns',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForModifyingDomainDns(request: SaveBatchTaskForModifyingDomainDnsRequest): SaveBatchTaskForModifyingDomainDnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForModifyingDomainDnsWithOptions(request, runtime);
}

model SaveBatchTaskForReserveDropListDomainRequest {
  contactTemplateId?: string(name='ContactTemplateId'),
  domains?: [ 
    {
      domainName?: string(name='DomainName'),
    }
  ](name='Domains'),
}

model SaveBatchTaskForReserveDropListDomainResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForReserveDropListDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForReserveDropListDomainResponseBody(name='body'),
}

async function saveBatchTaskForReserveDropListDomainWithOptions(request: SaveBatchTaskForReserveDropListDomainRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForReserveDropListDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.contactTemplateId)) {
    query['ContactTemplateId'] = request.contactTemplateId;
  }
  if (!Util.isUnset(request.domains)) {
    query['Domains'] = request.domains;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForReserveDropListDomain',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForReserveDropListDomain(request: SaveBatchTaskForReserveDropListDomainRequest): SaveBatchTaskForReserveDropListDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForReserveDropListDomainWithOptions(request, runtime);
}

model SaveBatchTaskForTransferProhibitionLockRequest {
  domainName?: [ string ](name='DomainName'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForTransferProhibitionLockWithOptions(request: SaveBatchTaskForTransferProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForTransferProhibitionLockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForTransferProhibitionLock',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForTransferProhibitionLock(request: SaveBatchTaskForTransferProhibitionLockRequest): SaveBatchTaskForTransferProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForTransferProhibitionLockWithOptions(request, runtime);
}

model SaveBatchTaskForUpdateProhibitionLockRequest {
  domainName?: [ string ](name='DomainName'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveBatchTaskForUpdateProhibitionLockWithOptions(request: SaveBatchTaskForUpdateProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdateProhibitionLockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForUpdateProhibitionLock',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForUpdateProhibitionLock(request: SaveBatchTaskForUpdateProhibitionLockRequest): SaveBatchTaskForUpdateProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdateProhibitionLockWithOptions(request, runtime);
}

model SaveBatchTaskForUpdatingContactInfoRequest {
  addTransferLock?: boolean(name='AddTransferLock'),
  contactType?: string(name='ContactType'),
  domainName?: [ string ](name='DomainName'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForUpdatingContactInfoResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdatingContactInfoResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfoWithOptions(request: SaveBatchTaskForUpdatingContactInfoRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdatingContactInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addTransferLock)) {
    query['AddTransferLock'] = request.addTransferLock;
  }
  if (!Util.isUnset(request.contactType)) {
    query['ContactType'] = request.contactType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForUpdatingContactInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForUpdatingContactInfo(request: SaveBatchTaskForUpdatingContactInfoRequest): SaveBatchTaskForUpdatingContactInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdatingContactInfoWithOptions(request, runtime);
}

model SaveBatchTaskForUpdatingContactInfoByNewContactRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  contactType?: string(name='ContactType'),
  country?: string(name='Country'),
  domainName?: [ string ](name='DomainName'),
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveBatchTaskForUpdatingContactInfoByNewContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveBatchTaskForUpdatingContactInfoByNewContactResponseBody(name='body'),
}

async function saveBatchTaskForUpdatingContactInfoByNewContactWithOptions(request: SaveBatchTaskForUpdatingContactInfoByNewContactRequest, runtime: Util.RuntimeOptions): SaveBatchTaskForUpdatingContactInfoByNewContactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.contactType)) {
    query['ContactType'] = request.contactType;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.postalCode)) {
    query['PostalCode'] = request.postalCode;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.registrantName)) {
    query['RegistrantName'] = request.registrantName;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.telArea)) {
    query['TelArea'] = request.telArea;
  }
  if (!Util.isUnset(request.telExt)) {
    query['TelExt'] = request.telExt;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }
  if (!Util.isUnset(request.transferOutProhibited)) {
    query['TransferOutProhibited'] = request.transferOutProhibited;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveBatchTaskForUpdatingContactInfoByNewContact',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveBatchTaskForUpdatingContactInfoByNewContact(request: SaveBatchTaskForUpdatingContactInfoByNewContactRequest): SaveBatchTaskForUpdatingContactInfoByNewContactResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveBatchTaskForUpdatingContactInfoByNewContactWithOptions(request, runtime);
}

model SaveRegistrantProfileRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  defaultRegistrantProfile?: boolean(name='DefaultRegistrantProfile'),
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  registrantProfileType?: string(name='RegistrantProfileType'),
  registrantType?: string(name='RegistrantType'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveRegistrantProfileResponseBody = {
  registrantProfileId?: long(name='RegistrantProfileId'),
  requestId?: string(name='RequestId'),
}

model SaveRegistrantProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveRegistrantProfileResponseBody(name='body'),
}

async function saveRegistrantProfileWithOptions(request: SaveRegistrantProfileRequest, runtime: Util.RuntimeOptions): SaveRegistrantProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.defaultRegistrantProfile)) {
    query['DefaultRegistrantProfile'] = request.defaultRegistrantProfile;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.postalCode)) {
    query['PostalCode'] = request.postalCode;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.registrantName)) {
    query['RegistrantName'] = request.registrantName;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.registrantProfileType)) {
    query['RegistrantProfileType'] = request.registrantProfileType;
  }
  if (!Util.isUnset(request.registrantType)) {
    query['RegistrantType'] = request.registrantType;
  }
  if (!Util.isUnset(request.telArea)) {
    query['TelArea'] = request.telArea;
  }
  if (!Util.isUnset(request.telExt)) {
    query['TelExt'] = request.telExt;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveRegistrantProfile',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveRegistrantProfile(request: SaveRegistrantProfileRequest): SaveRegistrantProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveRegistrantProfileWithOptions(request, runtime);
}

model SaveSingleTaskForAddingDSRecordRequest {
  algorithm?: int32(name='Algorithm'),
  digest?: string(name='Digest'),
  digestType?: int32(name='DigestType'),
  domainName?: string(name='DomainName'),
  keyTag?: int32(name='KeyTag'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForAddingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForAddingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForAddingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForAddingDSRecordWithOptions(request: SaveSingleTaskForAddingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForAddingDSRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.digestType)) {
    query['DigestType'] = request.digestType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyTag)) {
    query['KeyTag'] = request.keyTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForAddingDSRecord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForAddingDSRecord(request: SaveSingleTaskForAddingDSRecordRequest): SaveSingleTaskForAddingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForAddingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForApprovingTransferOutRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForApprovingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForApprovingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForApprovingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForApprovingTransferOutWithOptions(request: SaveSingleTaskForApprovingTransferOutRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForApprovingTransferOutResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForApprovingTransferOut',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForApprovingTransferOut(request: SaveSingleTaskForApprovingTransferOutRequest): SaveSingleTaskForApprovingTransferOutResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForApprovingTransferOutWithOptions(request, runtime);
}

model SaveSingleTaskForAssociatingEnsRequest {
  address?: string(name='Address', example='0x0000000000000000000000000000000000000003'),
  domainName?: string(name='DomainName', example='abc.luxe'),
  lang?: string(name='Lang', example='en'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1'),
}

model SaveSingleTaskForAssociatingEnsResponseBody = {
  requestId?: string(name='RequestId', example='A9C35C47-3366-482E-B872-8C9EA4733FE9'),
  taskNo?: string(name='TaskNo', example='561bc091-f16f-4132-8d63-f15edce45731'),
}

model SaveSingleTaskForAssociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForAssociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForAssociatingEnsWithOptions(request: SaveSingleTaskForAssociatingEnsRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForAssociatingEnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForAssociatingEns',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForAssociatingEns(request: SaveSingleTaskForAssociatingEnsRequest): SaveSingleTaskForAssociatingEnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForAssociatingEnsWithOptions(request, runtime);
}

model SaveSingleTaskForCancelingTransferInRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCancelingTransferInResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferInResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCancelingTransferInResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferInWithOptions(request: SaveSingleTaskForCancelingTransferInRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCancelingTransferInResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCancelingTransferIn',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCancelingTransferIn(request: SaveSingleTaskForCancelingTransferInRequest): SaveSingleTaskForCancelingTransferInResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCancelingTransferInWithOptions(request, runtime);
}

model SaveSingleTaskForCancelingTransferOutRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCancelingTransferOutResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCancelingTransferOutResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCancelingTransferOutResponseBody(name='body'),
}

async function saveSingleTaskForCancelingTransferOutWithOptions(request: SaveSingleTaskForCancelingTransferOutRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCancelingTransferOutResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCancelingTransferOut',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCancelingTransferOut(request: SaveSingleTaskForCancelingTransferOutRequest): SaveSingleTaskForCancelingTransferOutResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCancelingTransferOutWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingDnsHostRequest {
  dnsName?: string(name='DnsName'),
  instanceId?: string(name='InstanceId'),
  ip?: [ string ](name='Ip'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCreatingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForCreatingDnsHostWithOptions(request: SaveSingleTaskForCreatingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingDnsHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dnsName)) {
    query['DnsName'] = request.dnsName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCreatingDnsHost',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCreatingDnsHost(request: SaveSingleTaskForCreatingDnsHostRequest): SaveSingleTaskForCreatingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderActivateRequest {
  address?: string(name='Address'),
  aliyunDns?: boolean(name='AliyunDns'),
  city?: string(name='City'),
  country?: string(name='Country'),
  couponNo?: string(name='CouponNo'),
  dns1?: string(name='Dns1'),
  dns2?: string(name='Dns2'),
  domainName?: string(name='DomainName'),
  email?: string(name='Email'),
  enableDomainProxy?: boolean(name='EnableDomainProxy'),
  lang?: string(name='Lang'),
  permitPremiumActivation?: boolean(name='PermitPremiumActivation'),
  postalCode?: string(name='PostalCode'),
  promotionNo?: string(name='PromotionNo'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  registrantType?: string(name='RegistrantType'),
  subscriptionDuration?: int32(name='SubscriptionDuration'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
  trademarkDomainActivation?: boolean(name='TrademarkDomainActivation'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCreatingOrderActivateResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderActivateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderActivateResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderActivateWithOptions(request: SaveSingleTaskForCreatingOrderActivateRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderActivateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.aliyunDns)) {
    query['AliyunDns'] = request.aliyunDns;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.dns1)) {
    query['Dns1'] = request.dns1;
  }
  if (!Util.isUnset(request.dns2)) {
    query['Dns2'] = request.dns2;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.enableDomainProxy)) {
    query['EnableDomainProxy'] = request.enableDomainProxy;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.permitPremiumActivation)) {
    query['PermitPremiumActivation'] = request.permitPremiumActivation;
  }
  if (!Util.isUnset(request.postalCode)) {
    query['PostalCode'] = request.postalCode;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.registrantName)) {
    query['RegistrantName'] = request.registrantName;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.registrantType)) {
    query['RegistrantType'] = request.registrantType;
  }
  if (!Util.isUnset(request.subscriptionDuration)) {
    query['SubscriptionDuration'] = request.subscriptionDuration;
  }
  if (!Util.isUnset(request.telArea)) {
    query['TelArea'] = request.telArea;
  }
  if (!Util.isUnset(request.telExt)) {
    query['TelExt'] = request.telExt;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }
  if (!Util.isUnset(request.trademarkDomainActivation)) {
    query['TrademarkDomainActivation'] = request.trademarkDomainActivation;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCreatingOrderActivate',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCreatingOrderActivate(request: SaveSingleTaskForCreatingOrderActivateRequest): SaveSingleTaskForCreatingOrderActivateResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderActivateWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderRedeemRequest {
  couponNo?: string(name='CouponNo'),
  currentExpirationDate?: long(name='CurrentExpirationDate'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  promotionNo?: string(name='PromotionNo'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCreatingOrderRedeemResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRedeemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderRedeemResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRedeemWithOptions(request: SaveSingleTaskForCreatingOrderRedeemRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderRedeemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.currentExpirationDate)) {
    query['CurrentExpirationDate'] = request.currentExpirationDate;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCreatingOrderRedeem',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCreatingOrderRedeem(request: SaveSingleTaskForCreatingOrderRedeemRequest): SaveSingleTaskForCreatingOrderRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderRedeemWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderRenewRequest {
  couponNo?: string(name='CouponNo'),
  currentExpirationDate?: long(name='CurrentExpirationDate'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  promotionNo?: string(name='PromotionNo'),
  subscriptionDuration?: int32(name='SubscriptionDuration'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCreatingOrderRenewResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderRenewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderRenewResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderRenewWithOptions(request: SaveSingleTaskForCreatingOrderRenewRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderRenewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.currentExpirationDate)) {
    query['CurrentExpirationDate'] = request.currentExpirationDate;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.subscriptionDuration)) {
    query['SubscriptionDuration'] = request.subscriptionDuration;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCreatingOrderRenew',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCreatingOrderRenew(request: SaveSingleTaskForCreatingOrderRenewRequest): SaveSingleTaskForCreatingOrderRenewResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderRenewWithOptions(request, runtime);
}

model SaveSingleTaskForCreatingOrderTransferRequest {
  authorizationCode?: string(name='AuthorizationCode'),
  couponNo?: string(name='CouponNo'),
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  permitPremiumTransfer?: boolean(name='PermitPremiumTransfer'),
  promotionNo?: string(name='PromotionNo'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  useCoupon?: boolean(name='UseCoupon'),
  usePromotion?: boolean(name='UsePromotion'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForCreatingOrderTransferResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForCreatingOrderTransferResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForCreatingOrderTransferResponseBody(name='body'),
}

async function saveSingleTaskForCreatingOrderTransferWithOptions(request: SaveSingleTaskForCreatingOrderTransferRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForCreatingOrderTransferResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizationCode)) {
    query['AuthorizationCode'] = request.authorizationCode;
  }
  if (!Util.isUnset(request.couponNo)) {
    query['CouponNo'] = request.couponNo;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.permitPremiumTransfer)) {
    query['PermitPremiumTransfer'] = request.permitPremiumTransfer;
  }
  if (!Util.isUnset(request.promotionNo)) {
    query['PromotionNo'] = request.promotionNo;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.useCoupon)) {
    query['UseCoupon'] = request.useCoupon;
  }
  if (!Util.isUnset(request.usePromotion)) {
    query['UsePromotion'] = request.usePromotion;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForCreatingOrderTransfer',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForCreatingOrderTransfer(request: SaveSingleTaskForCreatingOrderTransferRequest): SaveSingleTaskForCreatingOrderTransferResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForCreatingOrderTransferWithOptions(request, runtime);
}

model SaveSingleTaskForDeletingDSRecordRequest {
  domainName?: string(name='DomainName'),
  keyTag?: int32(name='KeyTag'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForDeletingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDeletingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDSRecordWithOptions(request: SaveSingleTaskForDeletingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDeletingDSRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyTag)) {
    query['KeyTag'] = request.keyTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForDeletingDSRecord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForDeletingDSRecord(request: SaveSingleTaskForDeletingDSRecordRequest): SaveSingleTaskForDeletingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDeletingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForDeletingDnsHostRequest {
  dnsName?: string(name='DnsName'),
  instanceId?: string(name='InstanceId'),
  ip?: [ string ](name='Ip'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForDeletingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDeletingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDeletingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForDeletingDnsHostWithOptions(request: SaveSingleTaskForDeletingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDeletingDnsHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dnsName)) {
    query['DnsName'] = request.dnsName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForDeletingDnsHost',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForDeletingDnsHost(request: SaveSingleTaskForDeletingDnsHostRequest): SaveSingleTaskForDeletingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDeletingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForDisassociatingEnsRequest {
  domainName?: string(name='DomainName', example='abc.luxe'),
  lang?: string(name='Lang', example='en'),
  userClientIp?: string(name='UserClientIp', example='127.0.0.1'),
}

model SaveSingleTaskForDisassociatingEnsResponseBody = {
  requestId?: string(name='RequestId', example='A9C35C47-3366-482E-B872-8C9EA4733FE9'),
  taskNo?: string(name='TaskNo', example='561bc091-f16f-4132-8d63-f15edce45731'),
}

model SaveSingleTaskForDisassociatingEnsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDisassociatingEnsResponseBody(name='body'),
}

async function saveSingleTaskForDisassociatingEnsWithOptions(request: SaveSingleTaskForDisassociatingEnsRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDisassociatingEnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForDisassociatingEns',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForDisassociatingEns(request: SaveSingleTaskForDisassociatingEnsRequest): SaveSingleTaskForDisassociatingEnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDisassociatingEnsWithOptions(request, runtime);
}

model SaveSingleTaskForDomainNameProxyServiceRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForDomainNameProxyServiceResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForDomainNameProxyServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForDomainNameProxyServiceResponseBody(name='body'),
}

async function saveSingleTaskForDomainNameProxyServiceWithOptions(request: SaveSingleTaskForDomainNameProxyServiceRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForDomainNameProxyServiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForDomainNameProxyService',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForDomainNameProxyService(request: SaveSingleTaskForDomainNameProxyServiceRequest): SaveSingleTaskForDomainNameProxyServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForDomainNameProxyServiceWithOptions(request, runtime);
}

model SaveSingleTaskForModifyingDSRecordRequest {
  algorithm?: int32(name='Algorithm'),
  digest?: string(name='Digest'),
  digestType?: int32(name='DigestType'),
  domainName?: string(name='DomainName'),
  keyTag?: int32(name='KeyTag'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForModifyingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForModifyingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDSRecordWithOptions(request: SaveSingleTaskForModifyingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForModifyingDSRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.digest)) {
    query['Digest'] = request.digest;
  }
  if (!Util.isUnset(request.digestType)) {
    query['DigestType'] = request.digestType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.keyTag)) {
    query['KeyTag'] = request.keyTag;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForModifyingDSRecord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForModifyingDSRecord(request: SaveSingleTaskForModifyingDSRecordRequest): SaveSingleTaskForModifyingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForModifyingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForModifyingDnsHostRequest {
  dnsName?: string(name='DnsName'),
  instanceId?: string(name='InstanceId'),
  ip?: [ string ](name='Ip'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForModifyingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForModifyingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForModifyingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForModifyingDnsHostWithOptions(request: SaveSingleTaskForModifyingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForModifyingDnsHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dnsName)) {
    query['DnsName'] = request.dnsName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForModifyingDnsHost',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForModifyingDnsHost(request: SaveSingleTaskForModifyingDnsHostRequest): SaveSingleTaskForModifyingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForModifyingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForQueryingTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForQueryingTransferAuthorizationCodeResponseBody(name='body'),
}

async function saveSingleTaskForQueryingTransferAuthorizationCodeWithOptions(request: SaveSingleTaskForQueryingTransferAuthorizationCodeRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForQueryingTransferAuthorizationCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForQueryingTransferAuthorizationCode',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForQueryingTransferAuthorizationCode(request: SaveSingleTaskForQueryingTransferAuthorizationCodeRequest): SaveSingleTaskForQueryingTransferAuthorizationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForQueryingTransferAuthorizationCodeWithOptions(request, runtime);
}

model SaveSingleTaskForSaveArtExtensionRequest {
  dateOrPeriod?: string(name='DateOrPeriod'),
  dimensions?: string(name='Dimensions'),
  domainName?: string(name='DomainName'),
  features?: string(name='Features'),
  inscriptionsAndMarkings?: string(name='InscriptionsAndMarkings'),
  lang?: string(name='Lang'),
  maker?: string(name='Maker'),
  materialsAndTechniques?: string(name='MaterialsAndTechniques'),
  objectType?: string(name='ObjectType'),
  reference?: string(name='Reference'),
  subject?: string(name='Subject'),
  title?: string(name='Title'),
}

model SaveSingleTaskForSaveArtExtensionResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSaveArtExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSaveArtExtensionResponseBody(name='body'),
}

async function saveSingleTaskForSaveArtExtensionWithOptions(request: SaveSingleTaskForSaveArtExtensionRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSaveArtExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dateOrPeriod)) {
    query['DateOrPeriod'] = request.dateOrPeriod;
  }
  if (!Util.isUnset(request.dimensions)) {
    query['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.features)) {
    query['Features'] = request.features;
  }
  if (!Util.isUnset(request.inscriptionsAndMarkings)) {
    query['InscriptionsAndMarkings'] = request.inscriptionsAndMarkings;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.maker)) {
    query['Maker'] = request.maker;
  }
  if (!Util.isUnset(request.materialsAndTechniques)) {
    query['MaterialsAndTechniques'] = request.materialsAndTechniques;
  }
  if (!Util.isUnset(request.objectType)) {
    query['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.reference)) {
    query['Reference'] = request.reference;
  }
  if (!Util.isUnset(request.subject)) {
    query['Subject'] = request.subject;
  }
  if (!Util.isUnset(request.title)) {
    query['Title'] = request.title;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForSaveArtExtension',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForSaveArtExtension(request: SaveSingleTaskForSaveArtExtensionRequest): SaveSingleTaskForSaveArtExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSaveArtExtensionWithOptions(request, runtime);
}

model SaveSingleTaskForSynchronizingDSRecordRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForSynchronizingDSRecordResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDSRecordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSynchronizingDSRecordResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDSRecordWithOptions(request: SaveSingleTaskForSynchronizingDSRecordRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSynchronizingDSRecordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForSynchronizingDSRecord',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForSynchronizingDSRecord(request: SaveSingleTaskForSynchronizingDSRecordRequest): SaveSingleTaskForSynchronizingDSRecordResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSynchronizingDSRecordWithOptions(request, runtime);
}

model SaveSingleTaskForSynchronizingDnsHostRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForSynchronizingDnsHostResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForSynchronizingDnsHostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForSynchronizingDnsHostResponseBody(name='body'),
}

async function saveSingleTaskForSynchronizingDnsHostWithOptions(request: SaveSingleTaskForSynchronizingDnsHostRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForSynchronizingDnsHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForSynchronizingDnsHost',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForSynchronizingDnsHost(request: SaveSingleTaskForSynchronizingDnsHostRequest): SaveSingleTaskForSynchronizingDnsHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForSynchronizingDnsHostWithOptions(request, runtime);
}

model SaveSingleTaskForTransferProhibitionLockRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForTransferProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForTransferProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForTransferProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForTransferProhibitionLockWithOptions(request: SaveSingleTaskForTransferProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForTransferProhibitionLockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForTransferProhibitionLock',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForTransferProhibitionLock(request: SaveSingleTaskForTransferProhibitionLockRequest): SaveSingleTaskForTransferProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForTransferProhibitionLockWithOptions(request, runtime);
}

model SaveSingleTaskForUpdateProhibitionLockRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  status?: boolean(name='Status'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForUpdateProhibitionLockResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdateProhibitionLockResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForUpdateProhibitionLockResponseBody(name='body'),
}

async function saveSingleTaskForUpdateProhibitionLockWithOptions(request: SaveSingleTaskForUpdateProhibitionLockRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForUpdateProhibitionLockResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForUpdateProhibitionLock',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForUpdateProhibitionLock(request: SaveSingleTaskForUpdateProhibitionLockRequest): SaveSingleTaskForUpdateProhibitionLockResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForUpdateProhibitionLockWithOptions(request, runtime);
}

model SaveSingleTaskForUpdatingContactInfoRequest {
  addTransferLock?: boolean(name='AddTransferLock'),
  contactType?: string(name='ContactType'),
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveSingleTaskForUpdatingContactInfoResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveSingleTaskForUpdatingContactInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveSingleTaskForUpdatingContactInfoResponseBody(name='body'),
}

async function saveSingleTaskForUpdatingContactInfoWithOptions(request: SaveSingleTaskForUpdatingContactInfoRequest, runtime: Util.RuntimeOptions): SaveSingleTaskForUpdatingContactInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addTransferLock)) {
    query['AddTransferLock'] = request.addTransferLock;
  }
  if (!Util.isUnset(request.contactType)) {
    query['ContactType'] = request.contactType;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveSingleTaskForUpdatingContactInfo',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveSingleTaskForUpdatingContactInfo(request: SaveSingleTaskForUpdatingContactInfoRequest): SaveSingleTaskForUpdatingContactInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveSingleTaskForUpdatingContactInfoWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainDeleteRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveTaskForSubmittingDomainDeleteResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainDeleteResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainDeleteResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainDeleteWithOptions(request: SaveTaskForSubmittingDomainDeleteRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainDeleteResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForSubmittingDomainDelete',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForSubmittingDomainDelete(request: SaveTaskForSubmittingDomainDeleteRequest): SaveTaskForSubmittingDomainDeleteResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainDeleteWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest {
  domainName?: [ string ](name='DomainName'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialWithOptions(request: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.identityCredentialNo)) {
    query['IdentityCredentialNo'] = request.identityCredentialNo;
  }
  if (!Util.isUnset(request.identityCredentialType)) {
    query['IdentityCredentialType'] = request.identityCredentialType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.identityCredential)) {
    body['IdentityCredential'] = request.identityCredential;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredential',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForSubmittingDomainRealNameVerificationByIdentityCredential(request: SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialRequest): SaveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainRealNameVerificationByIdentityCredentialWithOptions(request, runtime);
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest {
  domainName?: string(name='DomainName'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDWithOptions(request: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest, runtime: Util.RuntimeOptions): SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileID(request: SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDRequest): SaveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForSubmittingDomainRealNameVerificationByRegistrantProfileIDWithOptions(request, runtime);
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  domainName?: [ string ](name='DomainName'),
  email?: string(name='Email'),
  identityCredential?: string(name='IdentityCredential'),
  identityCredentialNo?: string(name='IdentityCredentialNo'),
  identityCredentialType?: string(name='IdentityCredentialType'),
  lang?: string(name='Lang'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByIdentityCredentialWithOptions(request: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest, runtime: Util.RuntimeOptions): SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.identityCredentialNo)) {
    query['IdentityCredentialNo'] = request.identityCredentialNo;
  }
  if (!Util.isUnset(request.identityCredentialType)) {
    query['IdentityCredentialType'] = request.identityCredentialType;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.postalCode)) {
    query['PostalCode'] = request.postalCode;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.registrantName)) {
    query['RegistrantName'] = request.registrantName;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.registrantType)) {
    query['RegistrantType'] = request.registrantType;
  }
  if (!Util.isUnset(request.telArea)) {
    query['TelArea'] = request.telArea;
  }
  if (!Util.isUnset(request.telExt)) {
    query['TelExt'] = request.telExt;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }
  if (!Util.isUnset(request.transferOutProhibited)) {
    query['TransferOutProhibited'] = request.transferOutProhibited;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.identityCredential)) {
    body['IdentityCredential'] = request.identityCredential;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForUpdatingRegistrantInfoByIdentityCredential',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForUpdatingRegistrantInfoByIdentityCredential(request: SaveTaskForUpdatingRegistrantInfoByIdentityCredentialRequest): SaveTaskForUpdatingRegistrantInfoByIdentityCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForUpdatingRegistrantInfoByIdentityCredentialWithOptions(request, runtime);
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest {
  domainName?: [ string ](name='DomainName'),
  lang?: string(name='Lang'),
  registrantProfileId?: long(name='RegistrantProfileId'),
  transferOutProhibited?: boolean(name='TransferOutProhibited'),
  userClientIp?: string(name='UserClientIp'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody = {
  requestId?: string(name='RequestId'),
  taskNo?: string(name='TaskNo'),
}

model SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponseBody(name='body'),
}

async function saveTaskForUpdatingRegistrantInfoByRegistrantProfileIDWithOptions(request: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest, runtime: Util.RuntimeOptions): SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.registrantProfileId)) {
    query['RegistrantProfileId'] = request.registrantProfileId;
  }
  if (!Util.isUnset(request.transferOutProhibited)) {
    query['TransferOutProhibited'] = request.transferOutProhibited;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveTaskForUpdatingRegistrantInfoByRegistrantProfileID',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveTaskForUpdatingRegistrantInfoByRegistrantProfileID(request: SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDRequest): SaveTaskForUpdatingRegistrantInfoByRegistrantProfileIDResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveTaskForUpdatingRegistrantInfoByRegistrantProfileIDWithOptions(request, runtime);
}

model SubmitEmailVerificationRequest {
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  sendIfExist?: boolean(name='SendIfExist'),
  userClientIp?: string(name='UserClientIp'),
}

model SubmitEmailVerificationResponseBody = {
  existList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='ExistList'),
  failList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: [ 
    {
      code?: string(name='Code'),
      email?: string(name='Email'),
      message?: string(name='Message'),
    }
  ](name='SuccessList'),
}

model SubmitEmailVerificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubmitEmailVerificationResponseBody(name='body'),
}

async function submitEmailVerificationWithOptions(request: SubmitEmailVerificationRequest, runtime: Util.RuntimeOptions): SubmitEmailVerificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.sendIfExist)) {
    query['SendIfExist'] = request.sendIfExist;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubmitEmailVerification',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitEmailVerification(request: SubmitEmailVerificationRequest): SubmitEmailVerificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitEmailVerificationWithOptions(request, runtime);
}

model TransferInCheckMailTokenRequest {
  lang?: string(name='Lang'),
  token?: string(name='Token'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInCheckMailTokenResponseBody = {
  failList?: {
    failDomain?: [ string ](name='FailDomain')
  }(name='FailList'),
  requestId?: string(name='RequestId'),
  successList?: {
    successDomain?: [ string ](name='SuccessDomain')
  }(name='SuccessList'),
}

model TransferInCheckMailTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInCheckMailTokenResponseBody(name='body'),
}

async function transferInCheckMailTokenWithOptions(request: TransferInCheckMailTokenRequest, runtime: Util.RuntimeOptions): TransferInCheckMailTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferInCheckMailToken',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferInCheckMailToken(request: TransferInCheckMailTokenRequest): TransferInCheckMailTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInCheckMailTokenWithOptions(request, runtime);
}

model TransferInReenterTransferAuthorizationCodeRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  transferAuthorizationCode?: string(name='TransferAuthorizationCode'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInReenterTransferAuthorizationCodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInReenterTransferAuthorizationCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInReenterTransferAuthorizationCodeResponseBody(name='body'),
}

async function transferInReenterTransferAuthorizationCodeWithOptions(request: TransferInReenterTransferAuthorizationCodeRequest, runtime: Util.RuntimeOptions): TransferInReenterTransferAuthorizationCodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.transferAuthorizationCode)) {
    query['TransferAuthorizationCode'] = request.transferAuthorizationCode;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferInReenterTransferAuthorizationCode',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferInReenterTransferAuthorizationCode(request: TransferInReenterTransferAuthorizationCodeRequest): TransferInReenterTransferAuthorizationCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInReenterTransferAuthorizationCodeWithOptions(request, runtime);
}

model TransferInRefetchWhoisEmailRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInRefetchWhoisEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInRefetchWhoisEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInRefetchWhoisEmailResponseBody(name='body'),
}

async function transferInRefetchWhoisEmailWithOptions(request: TransferInRefetchWhoisEmailRequest, runtime: Util.RuntimeOptions): TransferInRefetchWhoisEmailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferInRefetchWhoisEmail',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferInRefetchWhoisEmail(request: TransferInRefetchWhoisEmailRequest): TransferInRefetchWhoisEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInRefetchWhoisEmailWithOptions(request, runtime);
}

model TransferInResendMailTokenRequest {
  domainName?: string(name='DomainName'),
  lang?: string(name='Lang'),
  userClientIp?: string(name='UserClientIp'),
}

model TransferInResendMailTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model TransferInResendMailTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferInResendMailTokenResponseBody(name='body'),
}

async function transferInResendMailTokenWithOptions(request: TransferInResendMailTokenRequest, runtime: Util.RuntimeOptions): TransferInResendMailTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferInResendMailToken',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferInResendMailToken(request: TransferInResendMailTokenRequest): TransferInResendMailTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferInResendMailTokenWithOptions(request, runtime);
}

model VerifyContactFieldRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  domainName?: string(name='DomainName'),
  email?: string(name='Email'),
  lang?: string(name='Lang'),
  postalCode?: string(name='PostalCode'),
  province?: string(name='Province'),
  registrantName?: string(name='RegistrantName'),
  registrantOrganization?: string(name='RegistrantOrganization'),
  registrantType?: string(name='RegistrantType'),
  telArea?: string(name='TelArea'),
  telExt?: string(name='TelExt'),
  telephone?: string(name='Telephone'),
  userClientIp?: string(name='UserClientIp'),
}

model VerifyContactFieldResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyContactFieldResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyContactFieldResponseBody(name='body'),
}

async function verifyContactFieldWithOptions(request: VerifyContactFieldRequest, runtime: Util.RuntimeOptions): VerifyContactFieldResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.address)) {
    query['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    query['City'] = request.city;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.domainName)) {
    query['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.postalCode)) {
    query['PostalCode'] = request.postalCode;
  }
  if (!Util.isUnset(request.province)) {
    query['Province'] = request.province;
  }
  if (!Util.isUnset(request.registrantName)) {
    query['RegistrantName'] = request.registrantName;
  }
  if (!Util.isUnset(request.registrantOrganization)) {
    query['RegistrantOrganization'] = request.registrantOrganization;
  }
  if (!Util.isUnset(request.registrantType)) {
    query['RegistrantType'] = request.registrantType;
  }
  if (!Util.isUnset(request.telArea)) {
    query['TelArea'] = request.telArea;
  }
  if (!Util.isUnset(request.telExt)) {
    query['TelExt'] = request.telExt;
  }
  if (!Util.isUnset(request.telephone)) {
    query['Telephone'] = request.telephone;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyContactField',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyContactField(request: VerifyContactFieldRequest): VerifyContactFieldResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyContactFieldWithOptions(request, runtime);
}

model VerifyEmailRequest {
  lang?: string(name='Lang'),
  token?: string(name='Token'),
  userClientIp?: string(name='UserClientIp'),
}

model VerifyEmailResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyEmailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyEmailResponseBody(name='body'),
}

async function verifyEmailWithOptions(request: VerifyEmailRequest, runtime: Util.RuntimeOptions): VerifyEmailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.userClientIp)) {
    query['UserClientIp'] = request.userClientIp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyEmail',
    version = '2017-12-18',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyEmail(request: VerifyEmailRequest): VerifyEmailResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyEmailWithOptions(request, runtime);
}

