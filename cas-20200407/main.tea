/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'cas.aliyuncs.com',
    ap-northeast-2-pop = 'cas.aliyuncs.com',
    ap-southeast-1 = 'cas.aliyuncs.com',
    ap-southeast-3 = 'cas.aliyuncs.com',
    ap-southeast-5 = 'cas.aliyuncs.com',
    cn-beijing = 'cas.aliyuncs.com',
    cn-beijing-finance-1 = 'cas.aliyuncs.com',
    cn-beijing-finance-pop = 'cas.aliyuncs.com',
    cn-beijing-gov-1 = 'cas.aliyuncs.com',
    cn-beijing-nu16-b01 = 'cas.aliyuncs.com',
    cn-chengdu = 'cas.aliyuncs.com',
    cn-edge-1 = 'cas.aliyuncs.com',
    cn-fujian = 'cas.aliyuncs.com',
    cn-haidian-cm12-c01 = 'cas.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'cas.aliyuncs.com',
    cn-hangzhou-finance = 'cas.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'cas.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'cas.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'cas.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'cas.aliyuncs.com',
    cn-hangzhou-test-306 = 'cas.aliyuncs.com',
    cn-hongkong = 'cas.aliyuncs.com',
    cn-hongkong-finance-pop = 'cas.aliyuncs.com',
    cn-huhehaote = 'cas.aliyuncs.com',
    cn-north-2-gov-1 = 'cas.aliyuncs.com',
    cn-qingdao = 'cas.aliyuncs.com',
    cn-qingdao-nebula = 'cas.aliyuncs.com',
    cn-shanghai = 'cas.aliyuncs.com',
    cn-shanghai-et15-b01 = 'cas.aliyuncs.com',
    cn-shanghai-et2-b01 = 'cas.aliyuncs.com',
    cn-shanghai-finance-1 = 'cas.aliyuncs.com',
    cn-shanghai-inner = 'cas.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'cas.aliyuncs.com',
    cn-shenzhen = 'cas.aliyuncs.com',
    cn-shenzhen-finance-1 = 'cas.aliyuncs.com',
    cn-shenzhen-inner = 'cas.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'cas.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'cas.aliyuncs.com',
    cn-wuhan = 'cas.aliyuncs.com',
    cn-yushanfang = 'cas.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'cas.aliyuncs.com',
    cn-zhangjiakou = 'cas.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'cas.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'cas.aliyuncs.com',
    eu-west-1 = 'cas.aliyuncs.com',
    eu-west-1-oxs = 'cas.aliyuncs.com',
    rus-west-1-pop = 'cas.aliyuncs.com',
    us-east-1 = 'cas.aliyuncs.com',
    us-west-1 = 'cas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('cas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CancelCertificateForPackageRequestRequest {
  orderId?: long(name='OrderId'),
}

model CancelCertificateForPackageRequestResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelCertificateForPackageRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelCertificateForPackageRequestResponseBody(name='body'),
}

async function cancelCertificateForPackageRequestWithOptions(request: CancelCertificateForPackageRequestRequest, runtime: Util.RuntimeOptions): CancelCertificateForPackageRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelCertificateForPackageRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelCertificateForPackageRequest(request: CancelCertificateForPackageRequestRequest): CancelCertificateForPackageRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelCertificateForPackageRequestWithOptions(request, runtime);
}

model CancelOrderRequestRequest {
  orderId?: long(name='OrderId'),
}

model CancelOrderRequestResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelOrderRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelOrderRequestResponseBody(name='body'),
}

async function cancelOrderRequestWithOptions(request: CancelOrderRequestRequest, runtime: Util.RuntimeOptions): CancelOrderRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOrderRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelOrderRequest(request: CancelOrderRequestRequest): CancelOrderRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOrderRequestWithOptions(request, runtime);
}

model CreateCertificateForPackageRequestRequest {
  companyName?: string(name='CompanyName'),
  csr?: string(name='Csr'),
  domain?: string(name='Domain'),
  email?: string(name='Email'),
  phone?: string(name='Phone'),
  productCode?: string(name='ProductCode'),
  username?: string(name='Username'),
  validateType?: string(name='ValidateType'),
}

model CreateCertificateForPackageRequestResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCertificateForPackageRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCertificateForPackageRequestResponseBody(name='body'),
}

async function createCertificateForPackageRequestWithOptions(request: CreateCertificateForPackageRequestRequest, runtime: Util.RuntimeOptions): CreateCertificateForPackageRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.companyName)) {
    query['CompanyName'] = request.companyName;
  }
  if (!Util.isUnset(request.csr)) {
    query['Csr'] = request.csr;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  if (!Util.isUnset(request.validateType)) {
    query['ValidateType'] = request.validateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCertificateForPackageRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCertificateForPackageRequest(request: CreateCertificateForPackageRequestRequest): CreateCertificateForPackageRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateForPackageRequestWithOptions(request, runtime);
}

model CreateCertificateRequestRequest {
  domain?: string(name='Domain'),
  email?: string(name='Email'),
  phone?: string(name='Phone'),
  productCode?: string(name='ProductCode'),
  username?: string(name='Username'),
  validateType?: string(name='ValidateType'),
}

model CreateCertificateRequestResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCertificateRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCertificateRequestResponseBody(name='body'),
}

async function createCertificateRequestWithOptions(request: CreateCertificateRequestRequest, runtime: Util.RuntimeOptions): CreateCertificateRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  if (!Util.isUnset(request.validateType)) {
    query['ValidateType'] = request.validateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCertificateRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCertificateRequest(request: CreateCertificateRequestRequest): CreateCertificateRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateRequestWithOptions(request, runtime);
}

model CreateCertificateWithCsrRequestRequest {
  csr?: string(name='Csr'),
  email?: string(name='Email'),
  phone?: string(name='Phone'),
  productCode?: string(name='ProductCode'),
  username?: string(name='Username'),
  validateType?: string(name='ValidateType'),
}

model CreateCertificateWithCsrRequestResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateCertificateWithCsrRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCertificateWithCsrRequestResponseBody(name='body'),
}

async function createCertificateWithCsrRequestWithOptions(request: CreateCertificateWithCsrRequestRequest, runtime: Util.RuntimeOptions): CreateCertificateWithCsrRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.csr)) {
    query['Csr'] = request.csr;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.phone)) {
    query['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  if (!Util.isUnset(request.validateType)) {
    query['ValidateType'] = request.validateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCertificateWithCsrRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCertificateWithCsrRequest(request: CreateCertificateWithCsrRequestRequest): CreateCertificateWithCsrRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCertificateWithCsrRequestWithOptions(request, runtime);
}

model CreateWHCertificateWithExtensionRequest {
  afterTime?: long(name='AfterTime'),
  algorithmKeySize?: string(name='AlgorithmKeySize'),
  aliasName?: string(name='AliasName'),
  appendCrl?: boolean(name='AppendCrl'),
  basicConstraintsCritical?: boolean(name='BasicConstraintsCritical'),
  beforeTime?: long(name='BeforeTime'),
  certType?: string(name='CertType'),
  commonName?: string(name='CommonName'),
  countryCode?: string(name='CountryCode'),
  csrPemString?: string(name='CsrPemString'),
  immediately?: long(name='Immediately'),
  locality?: string(name='Locality'),
  organization?: string(name='Organization'),
  organizationUnit?: string(name='OrganizationUnit'),
  parentIdentifier?: string(name='ParentIdentifier'),
  sans?: string(name='Sans'),
  state?: string(name='State'),
}

model CreateWHCertificateWithExtensionResponseBody = {
  certificate?: string(name='Certificate'),
  certificateChain?: string(name='CertificateChain'),
  identifier?: string(name='Identifier'),
  requestId?: string(name='RequestId'),
}

model CreateWHCertificateWithExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWHCertificateWithExtensionResponseBody(name='body'),
}

async function createWHCertificateWithExtensionWithOptions(request: CreateWHCertificateWithExtensionRequest, runtime: Util.RuntimeOptions): CreateWHCertificateWithExtensionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.afterTime)) {
    query['AfterTime'] = request.afterTime;
  }
  if (!Util.isUnset(request.algorithmKeySize)) {
    query['AlgorithmKeySize'] = request.algorithmKeySize;
  }
  if (!Util.isUnset(request.aliasName)) {
    query['AliasName'] = request.aliasName;
  }
  if (!Util.isUnset(request.appendCrl)) {
    query['AppendCrl'] = request.appendCrl;
  }
  if (!Util.isUnset(request.basicConstraintsCritical)) {
    query['BasicConstraintsCritical'] = request.basicConstraintsCritical;
  }
  if (!Util.isUnset(request.beforeTime)) {
    query['BeforeTime'] = request.beforeTime;
  }
  if (!Util.isUnset(request.certType)) {
    query['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.commonName)) {
    query['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.countryCode)) {
    query['CountryCode'] = request.countryCode;
  }
  if (!Util.isUnset(request.csrPemString)) {
    query['CsrPemString'] = request.csrPemString;
  }
  if (!Util.isUnset(request.immediately)) {
    query['Immediately'] = request.immediately;
  }
  if (!Util.isUnset(request.locality)) {
    query['Locality'] = request.locality;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  if (!Util.isUnset(request.organizationUnit)) {
    query['OrganizationUnit'] = request.organizationUnit;
  }
  if (!Util.isUnset(request.parentIdentifier)) {
    query['ParentIdentifier'] = request.parentIdentifier;
  }
  if (!Util.isUnset(request.sans)) {
    query['Sans'] = request.sans;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWHCertificateWithExtension',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWHCertificateWithExtension(request: CreateWHCertificateWithExtensionRequest): CreateWHCertificateWithExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWHCertificateWithExtensionWithOptions(request, runtime);
}

model CreateWHClientCertificateRequest {
  afterTime?: long(name='AfterTime'),
  algorithm?: string(name='Algorithm'),
  beforeTime?: long(name='BeforeTime'),
  commonName?: string(name='CommonName'),
  country?: string(name='Country'),
  csr?: string(name='Csr'),
  days?: long(name='Days'),
  immediately?: long(name='Immediately'),
  locality?: string(name='Locality'),
  months?: long(name='Months'),
  organization?: string(name='Organization'),
  organizationUnit?: string(name='OrganizationUnit'),
  parentIdentifier?: string(name='ParentIdentifier'),
  sanType?: long(name='SanType'),
  sanValue?: string(name='SanValue'),
  state?: string(name='State'),
  years?: long(name='Years'),
}

model CreateWHClientCertificateResponseBody = {
  certificateChain?: string(name='CertificateChain'),
  identifier?: string(name='Identifier'),
  parentX509Certificate?: string(name='ParentX509Certificate'),
  requestId?: string(name='RequestId'),
  rootX509Certificate?: string(name='RootX509Certificate'),
  x509Certificate?: string(name='X509Certificate'),
}

model CreateWHClientCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWHClientCertificateResponseBody(name='body'),
}

async function createWHClientCertificateWithOptions(request: CreateWHClientCertificateRequest, runtime: Util.RuntimeOptions): CreateWHClientCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.afterTime)) {
    query['AfterTime'] = request.afterTime;
  }
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.beforeTime)) {
    query['BeforeTime'] = request.beforeTime;
  }
  if (!Util.isUnset(request.commonName)) {
    query['CommonName'] = request.commonName;
  }
  if (!Util.isUnset(request.country)) {
    query['Country'] = request.country;
  }
  if (!Util.isUnset(request.csr)) {
    query['Csr'] = request.csr;
  }
  if (!Util.isUnset(request.days)) {
    query['Days'] = request.days;
  }
  if (!Util.isUnset(request.immediately)) {
    query['Immediately'] = request.immediately;
  }
  if (!Util.isUnset(request.locality)) {
    query['Locality'] = request.locality;
  }
  if (!Util.isUnset(request.months)) {
    query['Months'] = request.months;
  }
  if (!Util.isUnset(request.organization)) {
    query['Organization'] = request.organization;
  }
  if (!Util.isUnset(request.organizationUnit)) {
    query['OrganizationUnit'] = request.organizationUnit;
  }
  if (!Util.isUnset(request.parentIdentifier)) {
    query['ParentIdentifier'] = request.parentIdentifier;
  }
  if (!Util.isUnset(request.sanType)) {
    query['SanType'] = request.sanType;
  }
  if (!Util.isUnset(request.sanValue)) {
    query['SanValue'] = request.sanValue;
  }
  if (!Util.isUnset(request.state)) {
    query['State'] = request.state;
  }
  if (!Util.isUnset(request.years)) {
    query['Years'] = request.years;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateWHClientCertificate',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWHClientCertificate(request: CreateWHClientCertificateRequest): CreateWHClientCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWHClientCertificateWithOptions(request, runtime);
}

model DecryptRequest {
  algorithm?: string(name='Algorithm'),
  certIdentifier?: string(name='CertIdentifier'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  messageType?: string(name='MessageType'),
}

model DecryptResponseBody = {
  certIdentifier?: string(name='CertIdentifier'),
  plaintext?: string(name='Plaintext'),
  requestId?: string(name='RequestId'),
}

model DecryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DecryptResponseBody(name='body'),
}

async function decryptWithOptions(request: DecryptRequest, runtime: Util.RuntimeOptions): DecryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.ciphertextBlob)) {
    query['CiphertextBlob'] = request.ciphertextBlob;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Decrypt',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function decrypt(request: DecryptRequest): DecryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return decryptWithOptions(request, runtime);
}

model DeleteCertificateRequestRequest {
  orderId?: long(name='OrderId'),
}

model DeleteCertificateRequestResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCertificateRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCertificateRequestResponseBody(name='body'),
}

async function deleteCertificateRequestWithOptions(request: DeleteCertificateRequestRequest, runtime: Util.RuntimeOptions): DeleteCertificateRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCertificateRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCertificateRequest(request: DeleteCertificateRequestRequest): DeleteCertificateRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCertificateRequestWithOptions(request, runtime);
}

model DeletePCACertRequest {
  identifier?: string(name='Identifier'),
}

model DeletePCACertResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePCACertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePCACertResponseBody(name='body'),
}

async function deletePCACertWithOptions(request: DeletePCACertRequest, runtime: Util.RuntimeOptions): DeletePCACertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePCACert',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePCACert(request: DeletePCACertRequest): DeletePCACertResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePCACertWithOptions(request, runtime);
}

model DescribeCertificateStateRequest {
  orderId?: long(name='OrderId'),
}

model DescribeCertificateStateResponseBody = {
  certificate?: string(name='Certificate'),
  content?: string(name='Content'),
  domain?: string(name='Domain'),
  privateKey?: string(name='PrivateKey'),
  recordDomain?: string(name='RecordDomain'),
  recordType?: string(name='RecordType'),
  recordValue?: string(name='RecordValue'),
  requestId?: string(name='RequestId'),
  type?: string(name='Type'),
  uri?: string(name='Uri'),
  validateType?: string(name='ValidateType'),
}

model DescribeCertificateStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCertificateStateResponseBody(name='body'),
}

async function describeCertificateStateWithOptions(request: DescribeCertificateStateRequest, runtime: Util.RuntimeOptions): DescribeCertificateStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCertificateState',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCertificateState(request: DescribeCertificateStateRequest): DescribeCertificateStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCertificateStateWithOptions(request, runtime);
}

model DescribePackageStateRequest {
  productCode?: string(name='ProductCode'),
}

model DescribePackageStateResponseBody = {
  issuedCount?: long(name='IssuedCount'),
  productCode?: string(name='ProductCode'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  usedCount?: long(name='UsedCount'),
}

model DescribePackageStateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePackageStateResponseBody(name='body'),
}

async function describePackageStateWithOptions(request: DescribePackageStateRequest, runtime: Util.RuntimeOptions): DescribePackageStateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePackageState',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePackageState(request: DescribePackageStateRequest): DescribePackageStateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePackageStateWithOptions(request, runtime);
}

model EncryptRequest {
  algorithm?: string(name='Algorithm'),
  certIdentifier?: string(name='CertIdentifier'),
  messageType?: string(name='MessageType'),
  plaintext?: string(name='Plaintext'),
}

model EncryptResponseBody = {
  certIdentifier?: string(name='CertIdentifier'),
  ciphertextBlob?: string(name='CiphertextBlob'),
  requestId?: string(name='RequestId'),
}

model EncryptResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EncryptResponseBody(name='body'),
}

async function encryptWithOptions(request: EncryptRequest, runtime: Util.RuntimeOptions): EncryptResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.algorithm)) {
    query['Algorithm'] = request.algorithm;
  }
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.plaintext)) {
    query['Plaintext'] = request.plaintext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Encrypt',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function encrypt(request: EncryptRequest): EncryptResponse {
  var runtime = new Util.RuntimeOptions{};
  return encryptWithOptions(request, runtime);
}

model ListCertRequest {
  currentPage?: long(name='CurrentPage'),
  keyWord?: string(name='KeyWord'),
  showSize?: long(name='ShowSize'),
  status?: string(name='Status'),
  warehouseId?: long(name='WarehouseId'),
}

model ListCertResponseBody = {
  certList?: [ 
    {
      afterDate?: long(name='AfterDate'),
      beforeDate?: long(name='BeforeDate'),
      commonName?: string(name='CommonName'),
      existPrivateKey?: boolean(name='ExistPrivateKey'),
      identifier?: string(name='Identifier'),
      issuer?: string(name='Issuer'),
      sans?: string(name='Sans'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      whId?: long(name='WhId'),
      whInstanceId?: string(name='WhInstanceId'),
    }
  ](name='CertList'),
  currentPage?: long(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  showSize?: long(name='ShowSize'),
  totalCount?: long(name='TotalCount'),
}

model ListCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCertResponseBody(name='body'),
}

async function listCertWithOptions(request: ListCertRequest, runtime: Util.RuntimeOptions): ListCertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.keyWord)) {
    query['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.showSize)) {
    query['ShowSize'] = request.showSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.warehouseId)) {
    query['WarehouseId'] = request.warehouseId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCert',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCert(request: ListCertRequest): ListCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCertWithOptions(request, runtime);
}

model ListCertWarehouseRequest {
  currentPage?: long(name='CurrentPage'),
  instanceId?: string(name='InstanceId'),
  name?: string(name='Name'),
  showSize?: long(name='ShowSize'),
  type?: string(name='Type'),
}

model ListCertWarehouseResponseBody = {
  certWarehouseList?: [ 
    {
      endTime?: long(name='EndTime'),
      instanceId?: string(name='InstanceId'),
      isExpired?: boolean(name='IsExpired'),
      name?: string(name='Name'),
      pcaInstanceId?: string(name='PcaInstanceId'),
      qps?: long(name='Qps'),
      type?: string(name='Type'),
      whId?: long(name='WhId'),
    }
  ](name='CertWarehouseList'),
  currentPage?: long(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  showSize?: long(name='ShowSize'),
  totalCount?: long(name='TotalCount'),
}

model ListCertWarehouseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCertWarehouseResponseBody(name='body'),
}

async function listCertWarehouseWithOptions(request: ListCertWarehouseRequest, runtime: Util.RuntimeOptions): ListCertWarehouseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.showSize)) {
    query['ShowSize'] = request.showSize;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCertWarehouse',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCertWarehouse(request: ListCertWarehouseRequest): ListCertWarehouseResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCertWarehouseWithOptions(request, runtime);
}

model ListUserCertificateOrderRequest {
  currentPage?: long(name='CurrentPage'),
  keyword?: string(name='Keyword'),
  orderType?: string(name='OrderType'),
  showSize?: long(name='ShowSize'),
  status?: string(name='Status'),
}

model ListUserCertificateOrderResponseBody = {
  certificateOrderList?: [ 
    {
      algorithm?: string(name='Algorithm'),
      aliyunOrderId?: long(name='AliyunOrderId'),
      buyDate?: long(name='BuyDate'),
      certEndTime?: long(name='CertEndTime'),
      certStartTime?: long(name='CertStartTime'),
      certType?: string(name='CertType'),
      domain?: string(name='Domain'),
      domainCount?: long(name='DomainCount'),
      domainType?: string(name='DomainType'),
      instanceId?: string(name='InstanceId'),
      orderId?: long(name='OrderId'),
      partnerOrderId?: string(name='PartnerOrderId'),
      productCode?: string(name='ProductCode'),
      productName?: string(name='ProductName'),
      rootBrand?: string(name='RootBrand'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      trusteeStatus?: string(name='TrusteeStatus'),
      wildDomainCount?: long(name='WildDomainCount'),
    }
  ](name='CertificateOrderList'),
  currentPage?: long(name='CurrentPage'),
  requestId?: string(name='RequestId'),
  showSize?: long(name='ShowSize'),
  totalCount?: long(name='TotalCount'),
}

model ListUserCertificateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserCertificateOrderResponseBody(name='body'),
}

async function listUserCertificateOrderWithOptions(request: ListUserCertificateOrderRequest, runtime: Util.RuntimeOptions): ListUserCertificateOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.showSize)) {
    query['ShowSize'] = request.showSize;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserCertificateOrder',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserCertificateOrder(request: ListUserCertificateOrderRequest): ListUserCertificateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserCertificateOrderWithOptions(request, runtime);
}

model RenewCertificateOrderForPackageRequestRequest {
  csr?: string(name='Csr'),
  orderId?: long(name='OrderId'),
}

model RenewCertificateOrderForPackageRequestResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewCertificateOrderForPackageRequestResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewCertificateOrderForPackageRequestResponseBody(name='body'),
}

async function renewCertificateOrderForPackageRequestWithOptions(request: RenewCertificateOrderForPackageRequestRequest, runtime: Util.RuntimeOptions): RenewCertificateOrderForPackageRequestResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.csr)) {
    query['Csr'] = request.csr;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewCertificateOrderForPackageRequest',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewCertificateOrderForPackageRequest(request: RenewCertificateOrderForPackageRequestRequest): RenewCertificateOrderForPackageRequestResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewCertificateOrderForPackageRequestWithOptions(request, runtime);
}

model RevokeWHClientCertificateRequest {
  identifier?: string(name='Identifier'),
}

model RevokeWHClientCertificateResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeWHClientCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeWHClientCertificateResponseBody(name='body'),
}

async function revokeWHClientCertificateWithOptions(request: RevokeWHClientCertificateRequest, runtime: Util.RuntimeOptions): RevokeWHClientCertificateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeWHClientCertificate',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeWHClientCertificate(request: RevokeWHClientCertificateRequest): RevokeWHClientCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeWHClientCertificateWithOptions(request, runtime);
}

model SignRequest {
  certIdentifier?: string(name='CertIdentifier'),
  message?: string(name='Message'),
  messageType?: string(name='MessageType'),
  signingAlgorithm?: string(name='SigningAlgorithm'),
}

model SignResponseBody = {
  requestId?: string(name='RequestId'),
  signature?: string(name='Signature'),
}

model SignResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SignResponseBody(name='body'),
}

async function signWithOptions(request: SignRequest, runtime: Util.RuntimeOptions): SignResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.signingAlgorithm)) {
    query['SigningAlgorithm'] = request.signingAlgorithm;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Sign',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sign(request: SignRequest): SignResponse {
  var runtime = new Util.RuntimeOptions{};
  return signWithOptions(request, runtime);
}

model UploadPCACertRequest {
  cert?: string(name='Cert'),
  name?: string(name='Name'),
  privateKey?: string(name='PrivateKey'),
  warehouseId?: long(name='WarehouseId'),
}

model UploadPCACertResponseBody = {
  requestId?: string(name='RequestId'),
}

model UploadPCACertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadPCACertResponseBody(name='body'),
}

async function uploadPCACertWithOptions(request: UploadPCACertRequest, runtime: Util.RuntimeOptions): UploadPCACertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cert)) {
    query['Cert'] = request.cert;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.warehouseId)) {
    query['WarehouseId'] = request.warehouseId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UploadPCACert',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadPCACert(request: UploadPCACertRequest): UploadPCACertResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadPCACertWithOptions(request, runtime);
}

model VerifyRequest {
  certIdentifier?: string(name='CertIdentifier'),
  message?: string(name='Message'),
  messageType?: string(name='MessageType'),
  signatureValue?: string(name='SignatureValue'),
  signingAlgorithm?: string(name='SigningAlgorithm'),
}

model VerifyResponseBody = {
  requestId?: string(name='RequestId'),
  signatureValid?: boolean(name='SignatureValid'),
}

model VerifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyResponseBody(name='body'),
}

async function verifyWithOptions(request: VerifyRequest, runtime: Util.RuntimeOptions): VerifyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certIdentifier)) {
    query['CertIdentifier'] = request.certIdentifier;
  }
  if (!Util.isUnset(request.message)) {
    query['Message'] = request.message;
  }
  if (!Util.isUnset(request.messageType)) {
    query['MessageType'] = request.messageType;
  }
  if (!Util.isUnset(request.signatureValue)) {
    query['SignatureValue'] = request.signatureValue;
  }
  if (!Util.isUnset(request.signingAlgorithm)) {
    query['SigningAlgorithm'] = request.signingAlgorithm;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Verify',
    version = '2020-04-07',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verify(request: VerifyRequest): VerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyWithOptions(request, runtime);
}

