/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ehpc', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddonNodeTemplate {
  autoRenew?: boolean(name='AutoRenew', example='false'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', example='1'),
  dataDisks?: [ 
    {
      category?: string(name='Category', example='cloud_auto'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', example='false'),
      level?: string(name='Level', example='PL0'),
      size?: int32(name='Size', example='40'),
    }
  ](name='DataDisks'),
  duration?: int32(name='Duration', example='1'),
  enableHT?: boolean(name='EnableHT', example='true'),
  imageId?: string(name='ImageId', description='This parameter is required.', example='aliyun_3_x64_20G_alibase_20221102.vhd'),
  instanceChargeType?: string(name='InstanceChargeType', example='PostPaid'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType', description='This parameter is required.', example='ecs.c7.4xlarge'),
  osName?: string(name='OsName', description='This parameter is required.', example='CentOS  7.6 64 ä½'),
  osNameEN?: string(name='OsNameEN', description='This parameter is required.', example='CentOS  7.6 64 bit'),
  period?: int32(name='Period', example='1'),
  periodUnit?: string(name='PeriodUnit', example='Month'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.97'),
  spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
  systemDisk?: {
    category?: string(name='Category', example='cloud_auto'),
    level?: string(name='Level', example='PL0'),
    size?: int32(name='Size', example='40'),
  }(name='SystemDisk'),
}

model NodeTemplate {
  autoRenew?: boolean(name='AutoRenew', example='false'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', example='1'),
  dataDisks?: [ 
    {
      category?: string(name='Category', example='cloud_auto'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', example='false'),
      device?: string(name='Device', example='/dev/xvdb'),
      level?: string(name='Level', example='PL0'),
      mountDir?: string(name='MountDir', example='/data1'),
      size?: int32(name='Size', example='40'),
      snapshotId?: string(name='SnapshotId', example='s-bp1ei2b44ripxuo46hym'),
    }
  ](name='DataDisks'),
  duration?: int32(name='Duration', example='1'),
  enableHT?: boolean(name='EnableHT', example='true'),
  imageId?: string(name='ImageId', example='aliyun_3_x64_20G_alibase_20221102.vhd'),
  instanceChargeType?: string(name='InstanceChargeType', example='PostPaid'),
  instanceType?: string(name='InstanceType', example='ecs.c7.4xlarge'),
  period?: int32(name='Period', example='1'),
  periodUnit?: string(name='PeriodUnit', example='Month'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.97'),
  spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
  systemDisk?: {
    category?: string(name='Category', example='cloud_auto'),
    level?: string(name='Level', example='PL0'),
    size?: int32(name='Size', example='40'),
  }(name='SystemDisk'),
}

model QueueTemplate {
  allocationStrategy?: string(name='AllocationStrategy', example='PriorityInstanceType'),
  computeNodes?: [
    NodeTemplate
  ](name='ComputeNodes'),
  enableScaleIn?: boolean(name='EnableScaleIn', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', example='true'),
  hostnamePrefix?: string(name='HostnamePrefix', example='compute'),
  hostnameSuffix?: string(name='HostnameSuffix'),
  initialCount?: int32(name='InitialCount', example='0'),
  interConnect?: string(name='InterConnect', example='erdma'),
  keepAliveNodes?: [ string ](name='KeepAliveNodes'),
  maxCount?: int32(name='MaxCount', example='1000'),
  maxCountPerCycle?: long(name='MaxCountPerCycle', example='99'),
  minCount?: int32(name='MinCount', example='0'),
  queueName?: string(name='QueueName', description='This parameter is required.', example='comp'),
  ramRole?: string(name='RamRole', example='AliyunECSInstanceForEHPCRole'),
  reservedNodePoolId?: string(name='ReservedNodePoolId', example='rnp-756vlp7a'),
  vSwitchIds?: [ string ](name='VSwitchIds'),
}

model SharedStorageTemplate {
  fileSystemId?: string(name='FileSystemId', example='008b63****'),
  mountDirectory?: string(name='MountDirectory', example='/home'),
  mountOptions?: string(name='MountOptions', example='-t nfs -o vers=3,nolock,noresvport'),
  mountTargetDomain?: string(name='MountTargetDomain', example='008b****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
  NASDirectory?: string(name='NASDirectory', example='/'),
  protocolType?: string(name='ProtocolType', example='NFS'),
}

model AttachNodesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='ehpc-hz-xxxxxxx'),
  computeNode?: {
    imageId?: string(name='ImageId', description='The image ID. This image will be used to replace the original system disk image.

This parameter is required.', example='m-bp1h765oyqyxxxxxxxxx'),
    instanceIds?: [ string ](name='InstanceIds', description='The IDs of ECS instances.

This parameter is required.'),
  }(name='ComputeNode', description='The list of compute nodes.

This parameter is required.'),
  queueName?: string(name='QueueName', description='The name of the queue to which the instance is to be added.', example='comp'),
}

model AttachNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The ID of the cluster.

This parameter is required.', example='ehpc-hz-xxxxxxx'),
  computeNodeShrink?: string(name='ComputeNode', description='The list of compute nodes.

This parameter is required.'),
  queueName?: string(name='QueueName', description='The name of the queue to which the instance is to be added.', example='comp'),
}

model AttachNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2263XXXX-XXXX-XXXX-XXXX-XXXX2448XXXX'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

Valid values:

*   true
*   false', example='true'),
}

model AttachNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachNodesResponseBody(name='body'),
}

/**
 * @summary Adds Elastic Compute Service (ECS) instances as compute nodes to Elastic High Performance Computing (E-HPC) clusters.
 *
 * @description The ECS instances must meet the following requirements:
 * *   The ECS instances do not belong to any E-HPC cluster.
 * *   The ECS instances reside in the same virtual private cloud (VPC) as the cluster.
 * *   The ECS instances are in the Stopped state.
 * Take of the following limits:
 * *   You can specify multiple instance IDs to add them at a time. However, the instances must be of the same type.
 * *   When an instance is added to the cluster, [the system disk is reset](https://help.aliyun.com/zh/ecs/user-guide/re-initialize-a-system-disk) by using the image specified by the input parameters.
 * *   If the instance has data disks, they are not automatically created and mounted after the instance is added.
 * *   The hostname of the instance remains the same. Therefore, you must ensure that the hostname of the instance to be added is different from the hostname of an existing node in the cluster.
 *
 * @param tmpReq AttachNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachNodesResponse
 */
async function attachNodesWithOptions(tmpReq: AttachNodesRequest, runtime: Util.RuntimeOptions): AttachNodesResponse {
  Util.validateModel(tmpReq);
  var request = new AttachNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.computeNode)) {
    request.computeNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.computeNode, 'ComputeNode', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.computeNodeShrink)) {
    query['ComputeNode'] = request.computeNodeShrink;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachNodes',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds Elastic Compute Service (ECS) instances as compute nodes to Elastic High Performance Computing (E-HPC) clusters.
 *
 * @description The ECS instances must meet the following requirements:
 * *   The ECS instances do not belong to any E-HPC cluster.
 * *   The ECS instances reside in the same virtual private cloud (VPC) as the cluster.
 * *   The ECS instances are in the Stopped state.
 * Take of the following limits:
 * *   You can specify multiple instance IDs to add them at a time. However, the instances must be of the same type.
 * *   When an instance is added to the cluster, [the system disk is reset](https://help.aliyun.com/zh/ecs/user-guide/re-initialize-a-system-disk) by using the image specified by the input parameters.
 * *   If the instance has data disks, they are not automatically created and mounted after the instance is added.
 * *   The hostname of the instance remains the same. Therefore, you must ensure that the hostname of the instance to be added is different from the hostname of an existing node in the cluster.
 *
 * @param request AttachNodesRequest
 * @return AttachNodesResponse
 */
async function attachNodes(request: AttachNodesRequest): AttachNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachNodesWithOptions(request, runtime);
}

model AttachSharedStoragesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  sharedStorages?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system to be attached.

This parameter is required.', example='0bd504b0**'),
      location?: string(name='Location', description='The storage location of the file system to be attached. Valid values:

*   OnPremise: The file system is deployed on a hybrid cloud.
*   PublicCloud: The file system is deployed on a public cloud.', example='PublicCloud'),
      mountDirectory?: string(name='MountDirectory', description='The local mount directory of the file system that you want to attach.

This parameter is required.', example='/test'),
      mountOptions?: string(name='MountOptions', description='The attaching options of the file system to be attached. Valid values:

*   \\\\-t nfs -o vers=3,nolock,proto=tcp,noresvport
*   \\\\-t nfs -o vers=4.0,noresvport

Default value:-t nfs -o vers=3,nolock,proto=tcp,noresvport

>  The v3 version is recommended for higher performance if multiple Elastic Compute Service (ECS) instances do not edit the same file at the same time.', example='-t nfs -o vers=3,nolock,proto=tcp,noresvport'),
      mountTarget?: string(name='MountTarget', description='The address of the mount point of the file system to be attached.

This parameter is required.', example='0bd504b***-ngq26.cn-hangzhou.nas.aliyuncs.com'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system to be attached. Valid values:

*   NFS
*   SMB

This parameter is required.', example='NFS'),
      storageDirectory?: string(name='StorageDirectory', description='The storage directory of the file system. You can mount any directory in the file system to the specified cluster directory.

This parameter is required.', example='/testehpc'),
      volumeType?: string(name='VolumeType', description='The type of the file system to be attached. Valid values:

*   nas
*   cpfs

This parameter is required.', example='nas'),
    }
  ](name='SharedStorages', description='The information about the shared storage resources that you want to attach to the cluster.

This parameter is required.'),
}

model AttachSharedStoragesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  sharedStoragesShrink?: string(name='SharedStorages', description='The information about the shared storage resources that you want to attach to the cluster.

This parameter is required.'),
}

model AttachSharedStoragesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='F9B7BEF8-E42E-5090-9880-55FB7872****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model AttachSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachSharedStoragesResponseBody(name='body'),
}

/**
 * @summary Attaches shared storage to an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * When you call this operation, take note of the following items:
 * *   The file system that you want to attach must be created in advance in the same virtual private cloud (VPC) as the destination cluster. For more information, see [Create a file system](https://help.aliyun.com/document_detail/27530.html) and [Manage mount targets](https://help.aliyun.com/document_detail/27531.html).
 * *   E-HPC clusters support Apsara File Storage NAS file systems.
 *
 * @param tmpReq AttachSharedStoragesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachSharedStoragesResponse
 */
async function attachSharedStoragesWithOptions(tmpReq: AttachSharedStoragesRequest, runtime: Util.RuntimeOptions): AttachSharedStoragesResponse {
  Util.validateModel(tmpReq);
  var request = new AttachSharedStoragesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sharedStorages)) {
    request.sharedStoragesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sharedStorages, 'SharedStorages', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.sharedStoragesShrink)) {
    query['SharedStorages'] = request.sharedStoragesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachSharedStorages',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Attaches shared storage to an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * When you call this operation, take note of the following items:
 * *   The file system that you want to attach must be created in advance in the same virtual private cloud (VPC) as the destination cluster. For more information, see [Create a file system](https://help.aliyun.com/document_detail/27530.html) and [Manage mount targets](https://help.aliyun.com/document_detail/27531.html).
 * *   E-HPC clusters support Apsara File Storage NAS file systems.
 *
 * @param request AttachSharedStoragesRequest
 * @return AttachSharedStoragesResponse
 */
async function attachSharedStorages(request: AttachSharedStoragesRequest): AttachSharedStoragesResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachSharedStoragesWithOptions(request, runtime);
}

model CreateClusterRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The name of the software that you want to install in the cluster.', example='mpich'),
      version?: string(name='Version', description='The version of the software that you want to install in the cluster.', example='4.0.3'),
    }
  ](name='AdditionalPackages', description='The list of software that you want to install in the cluster. Valid values of N: 0 to 10.'),
  addons?: [ 
    {
      name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      resourcesSpec?: string(name='ResourcesSpec', description='The resource configurations of the addon.', example='"{\\\\\\\\"EipResource\\\\\\\\": {\\\\\\\\"AutoCreate\\\\\\\\": true}, \\\\\\\\"EcsResources\\\\\\\\": [{\\\\\\\\"InstanceType\\\\\\\\": \\\\\\\\"ecs.c7.xlarge\\\\\\\\", \\\\\\\\"ImageId\\\\\\\\": \\\\\\\\"centos_7_6_x64_20G_alibase_20211130.vhd\\\\\\\\", \\\\\\\\"SystemDisk\\\\\\\\": {\\\\\\\\"Category\\\\\\\\": \\\\\\\\"cloud_essd\\\\\\\\", \\\\\\\\"Size\\\\\\\\": 40, \\\\\\\\"Level\\\\\\\\": \\\\\\\\"PL0\\\\\\\\"}, \\\\\\\\"EnableHT\\\\\\\\": true, \\\\\\\\"InstanceChargeType\\\\\\\\": \\\\\\\\"PostPaid\\\\\\\\", \\\\\\\\"SpotStrategy\\\\\\\\": \\\\\\\\"NoSpot\\\\\\\\"}]}"'),
      servicesSpec?: string(name='ServicesSpec', description='The service configurations of the addon.', example='"[{\\\\\\\\"ServiceName\\\\\\\\": \\\\\\\\"SSH\\\\\\\\", \\\\\\\\"ServiceAccessType\\\\\\\\": null, \\\\\\\\"ServiceAccessUrl\\\\\\\\": null, \\\\\\\\"NetworkACL\\\\\\\\": [{\\\\\\\\"IpProtocol\\\\\\\\": \\\\\\\\"TCP\\\\\\\\", \\\\\\\\"Port\\\\\\\\": 22, \\\\\\\\"SourceCidrIp\\\\\\\\": \\\\\\\\"0.0.0.0/0\\\\\\\\"}]}, {\\\\\\\\"ServiceName\\\\\\\\": \\\\\\\\"VNC\\\\\\\\", \\\\\\\\"ServiceAccessType\\\\\\\\": null, \\\\\\\\"ServiceAccessUrl\\\\\\\\": null, \\\\\\\\"NetworkACL\\\\\\\\": [{\\\\\\\\"IpProtocol\\\\\\\\": \\\\\\\\"TCP\\\\\\\\", \\\\\\\\"Port\\\\\\\\": 12016, \\\\\\\\"SourceCidrIp\\\\\\\\": \\\\\\\\"0.0.0.0/0\\\\\\\\"}]}, {\\\\\\\\"ServiceName\\\\\\\\": \\\\\\\\"CLIENT\\\\\\\\", \\\\\\\\"ServiceAccessType\\\\\\\\": \\\\\\\\"URL\\\\\\\\", \\\\\\\\"ServiceAccessUrl\\\\\\\\": \\\\\\\\"\\\\\\\\", \\\\\\\\"NetworkACL\\\\\\\\": [{\\\\\\\\"IpProtocol\\\\\\\\": \\\\\\\\"TCP\\\\\\\\", \\\\\\\\"Port\\\\\\\\": 12011, \\\\\\\\"SourceCidrIp\\\\\\\\": \\\\\\\\"0.0.0.0/0\\\\\\\\"}]}]"'),
      version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The configurations of the custom addons in the cluster. Only one addon is supported.'),
  clientVersion?: string(name='ClientVersion', description='The client version. By default, the latest version is used.', example='2.1.0'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
  clusterCredentials?: {
    keyPairName?: string(name='KeyPairName', description='The name of the key pair. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain digits, letters, colons (:), underscores (_), and hyphens (-).

>  For more information, see [Create a key pair](https://help.aliyun.com/document_detail/51793.html).', example='ali0824'),
    password?: string(name='Password', description='The password for the root user to log on to the node. The password must be 8 to 20 characters in length, and must contain at least 3 of the following character types: uppercase letters, lowercase letters, digits, and special characters. The following special characters are supported: `() ~ ! @ # $ % ^ & * - = + { } [ ] : ; \\\\" < > , . ? /`

>  We recommend that you use HTTPS to call the API operation to prevent password leakage.', example='**********'),
  }(name='ClusterCredentials', description='The access credentials of the cluster.'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='The runtime parameters of the script after the cluster is created.', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The URL that is used to download the post-processing script.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.'),
  clusterDescription?: string(name='ClusterDescription', description='The cluster description. The description must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718'),
  clusterMode?: string(name='ClusterMode', description='The deployment mode of the cluster. Valid values:

*   Integrated
*   Hybrid
*   Custom', example='Integrated'),
  clusterName?: string(name='ClusterName', description='The cluster name. The name must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718'),
  clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch that you want the cluster to use. The vSwitch must reside in the VPC that is specified by the `ClusterVpcId` parameter.

You can call the [DescribeVpcs](https://help.aliyun.com/document_detail/448581.html) operation to query information about the created VPCs and vSwitches.', example='vsw-f8za5p0mwzgdu3wgx****'),
  clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) in which the cluster resides.', example='vpc-m5efjevmclc0xdmys****'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection for the cluster. Deletion protection decides whether the cluster can be deleted in the console or by calling the [DeleteCluster](https://help.aliyun.com/document_detail/424406.html) operation. Valid values:

*   true
*   false

Default value: false.', example='false'),
  isEnterpriseSecurityGroup?: boolean(name='IsEnterpriseSecurityGroup', description='Specifies whether to use an advanced security group. Valid values:

*   true: automatically creates and uses an advanced security group.
*   false: automatically creates and uses a basic security group.

For more information, see [Basic security groups and advanced security groups](https://help.aliyun.com/document_detail/605897.html).', example='false'),
  manager?: {
    DNS?: {
      type?: string(name='Type', description='The domain name resolution type.

Valid values:

*   NIS', example='NIS'),
      version?: string(name='Version', description='The version of the domain name resolution service.', example='2.31'),
    }(name='DNS', description='The configurations of the domain name resolution service.'),
    directoryService?: {
      type?: string(name='Type', description='The type of the domain account.

Valid values:

*   NIS', example='NIS'),
      version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
    }(name='DirectoryService', description='The configurations of the domain account service.'),
    managerNode?: NodeTemplate(name='ManagerNode', description='The hardware configurations of the management node.'),
    scheduler?: {
      type?: string(name='Type', description='The scheduler type. Valid values:

*   SLURM
*   PBS
*   OPENGRIDSCHEDULER
*   LSF_PLUGIN
*   PBS_PLUGIN', example='SLURM'),
      version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
    }(name='Scheduler', description='The configurations of the scheduler service.'),
  }(name='Manager', description='The configurations of the cluster management node.'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The maximum number of vCPUs that can be used by compute nodes in the cluster. Valid values: 0 to 100,000.', example='10000'),
  maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage. Valid values: 0 to 5,000.', example='500'),
  queues?: [
    QueueTemplate
  ](name='Queues', description='The queues in the cluster. The number of queues can be 0 to 8.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.

You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html) operation to obtain the IDs of the resource groups.', example='rg-acfmxazb4******'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the cluster belongs.

You can call the [DescribeSecurityGroups](https://help.aliyun.com/document_detail/25556.html) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****'),
  sharedStorages?: [
    SharedStorageTemplate
  ](name='SharedStorages', description='The shared storage resources of the cluster.'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='ClusterId'),
      value?: string(name='Value', description='The tag value. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.', example='ehpc-hz-******'),
    }
  ](name='Tags', description='The tags of the cluster.'),
}

model CreateClusterShrinkRequest {
  additionalPackagesShrink?: string(name='AdditionalPackages', description='The list of software that you want to install in the cluster. Valid values of N: 0 to 10.'),
  addonsShrink?: string(name='Addons', description='The configurations of the custom addons in the cluster. Only one addon is supported.'),
  clientVersion?: string(name='ClientVersion', description='The client version. By default, the latest version is used.', example='2.1.0'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
  clusterCredentialsShrink?: string(name='ClusterCredentials', description='The access credentials of the cluster.'),
  clusterCustomConfigurationShrink?: string(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.'),
  clusterDescription?: string(name='ClusterDescription', description='The cluster description. The description must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718'),
  clusterMode?: string(name='ClusterMode', description='The deployment mode of the cluster. Valid values:

*   Integrated
*   Hybrid
*   Custom', example='Integrated'),
  clusterName?: string(name='ClusterName', description='The cluster name. The name must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718'),
  clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch that you want the cluster to use. The vSwitch must reside in the VPC that is specified by the `ClusterVpcId` parameter.

You can call the [DescribeVpcs](https://help.aliyun.com/document_detail/448581.html) operation to query information about the created VPCs and vSwitches.', example='vsw-f8za5p0mwzgdu3wgx****'),
  clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) in which the cluster resides.', example='vpc-m5efjevmclc0xdmys****'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection for the cluster. Deletion protection decides whether the cluster can be deleted in the console or by calling the [DeleteCluster](https://help.aliyun.com/document_detail/424406.html) operation. Valid values:

*   true
*   false

Default value: false.', example='false'),
  isEnterpriseSecurityGroup?: boolean(name='IsEnterpriseSecurityGroup', description='Specifies whether to use an advanced security group. Valid values:

*   true: automatically creates and uses an advanced security group.
*   false: automatically creates and uses a basic security group.

For more information, see [Basic security groups and advanced security groups](https://help.aliyun.com/document_detail/605897.html).', example='false'),
  managerShrink?: string(name='Manager', description='The configurations of the cluster management node.'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The maximum number of vCPUs that can be used by compute nodes in the cluster. Valid values: 0 to 100,000.', example='10000'),
  maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage. Valid values: 0 to 5,000.', example='500'),
  queuesShrink?: string(name='Queues', description='The queues in the cluster. The number of queues can be 0 to 8.'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.

You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html) operation to obtain the IDs of the resource groups.', example='rg-acfmxazb4******'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the cluster belongs.

You can call the [DescribeSecurityGroups](https://help.aliyun.com/document_detail/25556.html) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****'),
  sharedStoragesShrink?: string(name='SharedStorages', description='The shared storage resources of the cluster.'),
  tagsShrink?: string(name='Tags', description='The tags of the cluster.'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr******'),
  requestId?: string(name='RequestId', description='The request ID.', example='F6757FA4-8FED-4602-B7F5-3550C0******'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='F6757FA4-8FED-4602-B7F5-3550C0******'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
 * @summary Creates a pay-as-you-go or subscription Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you call this operation, make sure that you are familiar with the billing and pricing of E-HPC. For more information, see [Overview](https://help.aliyun.com/document_detail/2842985.html).
 *
 * @param tmpReq CreateClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateClusterResponse
 */
async function createClusterWithOptions(tmpReq: CreateClusterRequest, runtime: Util.RuntimeOptions): CreateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new CreateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalPackages)) {
    request.additionalPackagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalPackages, 'AdditionalPackages', 'json');
  }
  if (!Util.isUnset(tmpReq.addons)) {
    request.addonsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addons, 'Addons', 'json');
  }
  if (!Util.isUnset(tmpReq.clusterCredentials)) {
    request.clusterCredentialsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clusterCredentials, 'ClusterCredentials', 'json');
  }
  if (!Util.isUnset(tmpReq.clusterCustomConfiguration)) {
    request.clusterCustomConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clusterCustomConfiguration, 'ClusterCustomConfiguration', 'json');
  }
  if (!Util.isUnset(tmpReq.manager)) {
    request.managerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.manager, 'Manager', 'json');
  }
  if (!Util.isUnset(tmpReq.queues)) {
    request.queuesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queues, 'Queues', 'json');
  }
  if (!Util.isUnset(tmpReq.sharedStorages)) {
    request.sharedStoragesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sharedStorages, 'SharedStorages', 'json');
  }
  if (!Util.isUnset(tmpReq.tags)) {
    request.tagsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tags, 'Tags', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.additionalPackagesShrink)) {
    query['AdditionalPackages'] = request.additionalPackagesShrink;
  }
  if (!Util.isUnset(request.addonsShrink)) {
    query['Addons'] = request.addonsShrink;
  }
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.clusterCategory)) {
    query['ClusterCategory'] = request.clusterCategory;
  }
  if (!Util.isUnset(request.clusterCredentialsShrink)) {
    query['ClusterCredentials'] = request.clusterCredentialsShrink;
  }
  if (!Util.isUnset(request.clusterCustomConfigurationShrink)) {
    query['ClusterCustomConfiguration'] = request.clusterCustomConfigurationShrink;
  }
  if (!Util.isUnset(request.clusterDescription)) {
    query['ClusterDescription'] = request.clusterDescription;
  }
  if (!Util.isUnset(request.clusterMode)) {
    query['ClusterMode'] = request.clusterMode;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.clusterVSwitchId)) {
    query['ClusterVSwitchId'] = request.clusterVSwitchId;
  }
  if (!Util.isUnset(request.clusterVpcId)) {
    query['ClusterVpcId'] = request.clusterVpcId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.isEnterpriseSecurityGroup)) {
    query['IsEnterpriseSecurityGroup'] = request.isEnterpriseSecurityGroup;
  }
  if (!Util.isUnset(request.managerShrink)) {
    query['Manager'] = request.managerShrink;
  }
  if (!Util.isUnset(request.maxCoreCount)) {
    query['MaxCoreCount'] = request.maxCoreCount;
  }
  if (!Util.isUnset(request.maxCount)) {
    query['MaxCount'] = request.maxCount;
  }
  if (!Util.isUnset(request.queuesShrink)) {
    query['Queues'] = request.queuesShrink;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.sharedStoragesShrink)) {
    query['SharedStorages'] = request.sharedStoragesShrink;
  }
  if (!Util.isUnset(request.tagsShrink)) {
    query['Tags'] = request.tagsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCluster',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a pay-as-you-go or subscription Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you call this operation, make sure that you are familiar with the billing and pricing of E-HPC. For more information, see [Overview](https://help.aliyun.com/document_detail/2842985.html).
 *
 * @param request CreateClusterRequest
 * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClusterWithOptions(request, runtime);
}

model CreateJobRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  jobName?: string(name='JobName', description='The job name.', example='TestJob'),
  jobSpec?: {
    arrayRequest?: string(name='ArrayRequest', description='The jobs in the queue.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-5:2'),
    commandLine?: string(name='CommandLine', description='The command or script that is used to run the job. If you want to use a command, you must specify the full path of the command, for example, /bin/ping.

If you want to use a script, you must make sure that you have the execution permissions on it. By default, the user root directory ~/ is used as the default script path on the cluster side. If your script is not in that directory, you must specify the full path in this parameter, such as /home/xxx/job.sh Note that in this mode, if requirements on resources such as CPU and memory are specified in the script, the job will be run based on the resource requirements specified in the script. In this case, do not specify resource requirements in the Resource parameter. Otherwise, the job may fail to run.

If you want to run the job directly by using the CLI, you must specify the absolute path of the command and add two hyphens and a space (-- ) before the path, such as -- /bin/ping -c 10 localhost.

This parameter is required.', example='/home/xxx/test.job'),
    jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='comp'),
    postCmdLine?: string(name='PostCmdLine', description='The post-processing command of the job.', example='/bin/sleep 10'),
    priority?: string(name='Priority', description='The job priority.', example='1'),
    resources?: {
      cores?: int32(name='Cores', description='The number of vCPUs to be allocated to each compute node.', example='2'),
      gpus?: int32(name='Gpus', description='The number of GPUs to be allocated to each compute node.', example='1'),
      memory?: string(name='Memory', description='The memory size to be allocated to each compute node. The memory size is in string format. Unit: MB or GB.', example='4gb'),
      nodes?: int32(name='Nodes', description='The number of compute nodes to be allocated to the job.', example='2'),
    }(name='Resources', description='The resource configurations of the job.'),
    runasUser?: string(name='RunasUser', description='The cluster-side user as which you want to submit the job.', example='testuser'),
    runasUserPassword?: string(name='RunasUserPassword', description='The password of the user specified by the RunasUser parameter.', example='xxx'),
    stderrPath?: string(name='StderrPath', description='The path of the standard error output file of the job. You need to specify the full path.', example='/home/xxx/job.err'),
    stdoutPath?: string(name='StdoutPath', description='The path of the standard output file of the job. You need to specify the full path.', example='/home/xxx/job.out'),
    variables?: string(name='Variables', description='The environment variables of the job. The value is a string in the JSON array format. Each array member is a JSON object that contains two members: Name and Value. Name indicates the name of the environment variable, and Value indicates the value of the environment variable.', example='[{"Name":"x", "Value":"y"}]'),
    wallTime?: string(name='WallTime', description='The maximum duration for which the job can be run. Format: `hour: minute: second`. For example, `01:00:00` indicates 1 hour.', example='360:48:50'),
  }(name='JobSpec', description='The job configurations.'),
}

model CreateJobShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  jobName?: string(name='JobName', description='The job name.', example='TestJob'),
  jobSpecShrink?: string(name='JobSpec', description='The job configurations.'),
}

model CreateJobResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='Submitted batch job 10\\\\n'),
  requestId?: string(name='RequestId', description='The request ID.', example='A0A38A38-1565-555E-B597-E48A2E******'),
  success?: string(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJobResponseBody(name='body'),
}

/**
 * @summary Creates a job for a cluster.
 *
 * @description Before you call this operation, make sure that you understand the billing and [pricing](https://www.aliyun.com/price/product#/ecs/detail) of E-HPC.
 *
 * @param tmpReq CreateJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJobResponse
 */
async function createJobWithOptions(tmpReq: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobSpec)) {
    request.jobSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobSpec, 'JobSpec', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.jobName)) {
    query['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.jobSpecShrink)) {
    query['JobSpec'] = request.jobSpecShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a job for a cluster.
 *
 * @description Before you call this operation, make sure that you understand the billing and [pricing](https://www.aliyun.com/price/product#/ecs/detail) of E-HPC.
 *
 * @param request CreateJobRequest
 * @return CreateJobResponse
 */
async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  computeNode?: NodeTemplate(name='ComputeNode', description='The hardware configurations of the compute nodes.'),
  count?: int32(name='Count', description='The number of compute nodes that you want to add. Valid values: 1 to 99. The MinCount value must be smaller than the Count value.

*   If the number of available Elastic Compute Service (ECS) instances is smaller than the MinCount value, the nodes fail to be added.
*   If the number of available ECS instances is larger than the MinCount value but smaller than the Count value, nodes are added based on the MinCount value.
*   If the number of available ECS instances is larger than the Count value, nodes are added based on the Count value.', example='10'),
  deploymentSetId?: string(name='DeploymentSetId', description='Deployment set ID. You can obtain the deployment set ID through [DescribeDeploymentSets](https://help.aliyun.com/document_detail/91313.html). Currently, only deployment sets with a low network latency strategy are supported.', example='ds-bp1frxuzdg87zh4pzq****'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The type of the network between compute nodes. Valid values:

*   vpc
*   eRDMA', example='vpc'),
  hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the added compute nodes.', example='compute'),
  hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the added compute nodes.', example='demo'),
  keepAlive?: string(name='KeepAlive', description='Specifies whether to enable deletion protection for the added compute nodes.', example='false'),
  queueName?: string(name='QueueName', description='The name of the queue for which you want to create compute nodes.', example='test1'),
  ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role to be assumed by the added nodes.', example='AliyunServiceRoleForOOSBandwidthScheduler'),
  reservedNodePoolId?: string(name='ReservedNodePoolId', description='Preset node pool ID.', example='rnp-756vlp7a'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to be used by the added nodes.', example='vsw-bp1lfcjbfb099rrjn****'),
}

model CreateNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  computeNodeShrink?: string(name='ComputeNode', description='The hardware configurations of the compute nodes.'),
  count?: int32(name='Count', description='The number of compute nodes that you want to add. Valid values: 1 to 99. The MinCount value must be smaller than the Count value.

*   If the number of available Elastic Compute Service (ECS) instances is smaller than the MinCount value, the nodes fail to be added.
*   If the number of available ECS instances is larger than the MinCount value but smaller than the Count value, nodes are added based on the MinCount value.
*   If the number of available ECS instances is larger than the Count value, nodes are added based on the Count value.', example='10'),
  deploymentSetId?: string(name='DeploymentSetId', description='Deployment set ID. You can obtain the deployment set ID through [DescribeDeploymentSets](https://help.aliyun.com/document_detail/91313.html). Currently, only deployment sets with a low network latency strategy are supported.', example='ds-bp1frxuzdg87zh4pzq****'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The type of the network between compute nodes. Valid values:

*   vpc
*   eRDMA', example='vpc'),
  hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the added compute nodes.', example='compute'),
  hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the added compute nodes.', example='demo'),
  keepAlive?: string(name='KeepAlive', description='Specifies whether to enable deletion protection for the added compute nodes.', example='false'),
  queueName?: string(name='QueueName', description='The name of the queue for which you want to create compute nodes.', example='test1'),
  ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role to be assumed by the added nodes.', example='AliyunServiceRoleForOOSBandwidthScheduler'),
  reservedNodePoolId?: string(name='ReservedNodePoolId', description='Preset node pool ID.', example='rnp-756vlp7a'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to be used by the added nodes.', example='vsw-bp1lfcjbfb099rrjn****'),
}

model CreateNodesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the compute nodes to be created.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model CreateNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNodesResponseBody(name='body'),
}

/**
 * @summary Creates compute nodes for an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)
 *
 * @param tmpReq CreateNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNodesResponse
 */
async function createNodesWithOptions(tmpReq: CreateNodesRequest, runtime: Util.RuntimeOptions): CreateNodesResponse {
  Util.validateModel(tmpReq);
  var request = new CreateNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.computeNode)) {
    request.computeNodeShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.computeNode, 'ComputeNode', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.computeNodeShrink)) {
    query['ComputeNode'] = request.computeNodeShrink;
  }
  if (!Util.isUnset(request.count)) {
    query['Count'] = request.count;
  }
  if (!Util.isUnset(request.deploymentSetId)) {
    query['DeploymentSetId'] = request.deploymentSetId;
  }
  if (!Util.isUnset(request.HPCInterConnect)) {
    query['HPCInterConnect'] = request.HPCInterConnect;
  }
  if (!Util.isUnset(request.hostnamePrefix)) {
    query['HostnamePrefix'] = request.hostnamePrefix;
  }
  if (!Util.isUnset(request.hostnameSuffix)) {
    query['HostnameSuffix'] = request.hostnameSuffix;
  }
  if (!Util.isUnset(request.keepAlive)) {
    query['KeepAlive'] = request.keepAlive;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.ramRole)) {
    query['RamRole'] = request.ramRole;
  }
  if (!Util.isUnset(request.reservedNodePoolId)) {
    query['ReservedNodePoolId'] = request.reservedNodePoolId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNodes',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates compute nodes for an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)
 *
 * @param request CreateNodesRequest
 * @return CreateNodesResponse
 */
async function createNodes(request: CreateNodesRequest): CreateNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNodesWithOptions(request, runtime);
}

model CreateQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queue?: QueueTemplate(name='Queue', description='The configurations of the queue to be created.'),
}

model CreateQueueShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queueShrink?: string(name='Queue', description='The configurations of the queue to be created.'),
}

model CreateQueueResponseBody = {
  name?: string(name='Name', description='The name of the created queue.', example='test'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

/**
 * @summary Creates a queue for an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq CreateQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQueueResponse
 */
async function createQueueWithOptions(tmpReq: CreateQueueRequest, runtime: Util.RuntimeOptions): CreateQueueResponse {
  Util.validateModel(tmpReq);
  var request = new CreateQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queue)) {
    request.queueShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queue, 'Queue', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queueShrink)) {
    query['Queue'] = request.queueShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateQueue',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a queue for an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @param request CreateQueueRequest
 * @return CreateQueueResponse
 */
async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQueueWithOptions(request, runtime);
}

model CreateUsersRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      authKey?: string(name='AuthKey', description='The public key of the user.

You can add up to 20 users in a call.

Specify one of the Password and AuthKey parameters. The AuthKey parameter takes effect only when the cluster authentication method is set to Key. Key authentication is not recommended.', example='Abc****'),
      group?: string(name='Group', description='The permission group to which the user belongs. Valid values:

users: ordinary permissions, which are suitable for ordinary users that need only to submit and debug jobs. wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes. You can add up to 20 users in a call.', example='users'),
      password?: string(name='Password', description='The password of the user. The password must be 6 to 30 characters in length and must contain three of the following character types:

*   Uppercase letters
*   Lowercase letters
*   Digits
*   Special characters ()~!@#$%^&\\\\*-_+=|{}[]:;\\\\"/<>,.?/

You can add up to 20 users in a call.

Specify one of the Password and AuthKey parameters. The Password parameter takes effect only when the cluster authentication method is set to Password. Password authentication is recommended.', example='1@a2****'),
      userName?: string(name='UserName', description='The username. The username must be 1 to 30 characters in length. It must start with a letter and can contain digits, letters, and periods (.).

You can add up to 20 users in a call.', example='testuser'),
    }
  ](name='User', description='The users that you want to add.'),
}

model CreateUsersShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  userShrink?: string(name='User', description='The users that you want to add.'),
}

model CreateUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model CreateUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUsersResponseBody(name='body'),
}

/**
 * @summary Adds users to an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq CreateUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateUsersResponse
 */
async function createUsersWithOptions(tmpReq: CreateUsersRequest, runtime: Util.RuntimeOptions): CreateUsersResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUsersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.user)) {
    request.userShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.user, 'User', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.userShrink)) {
    query['User'] = request.userShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUsers',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds users to an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request CreateUsersRequest
 * @return CreateUsersResponse
 */
async function createUsers(request: CreateUsersRequest): CreateUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUsersWithOptions(request, runtime);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster to be released.', example='ehpc-hz-QKKVqO****'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

/**
 * @summary Releases an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Make sure that data of the cluster to be deleted is backed up before you call this operation.
 * > After a cluster is released, you cannot restore the data stored in the cluster. Exercise caution when you release a cluster.
 *
 * @param request DeleteClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteClusterResponse
 */
async function deleteClusterWithOptions(request: DeleteClusterRequest, runtime: Util.RuntimeOptions): DeleteClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCluster',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Make sure that data of the cluster to be deleted is backed up before you call this operation.
 * > After a cluster is released, you cannot restore the data stored in the cluster. Exercise caution when you release a cluster.
 *
 * @param request DeleteClusterRequest
 * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClusterWithOptions(request, runtime);
}

model DeleteNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [listclusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the compute nodes that you want to delete.'),
}

model DeleteNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [listclusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  instanceIdsShrink?: string(name='InstanceIds', description='The instance IDs of the compute nodes that you want to delete.'),
}

model DeleteNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNodesResponseBody(name='body'),
}

/**
 * @summary Deletes compute nodes from an Enterprise High Performance Computing (E-HPC) cluster at a time.
 *
 * @description ## [](#)Usage notes
 * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
 *
 * @param tmpReq DeleteNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNodesResponse
 */
async function deleteNodesWithOptions(tmpReq: DeleteNodesRequest, runtime: Util.RuntimeOptions): DeleteNodesResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNodes',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes compute nodes from an Enterprise High Performance Computing (E-HPC) cluster at a time.
 *
 * @description ## [](#)Usage notes
 * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
 *
 * @param request DeleteNodesRequest
 * @return DeleteNodesResponse
 */
async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNodesWithOptions(request, runtime);
}

model DeleteQueuesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queueNames?: [ string ](name='QueueNames', description='The queues that you want to delete.'),
}

model DeleteQueuesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queueNamesShrink?: string(name='QueueNames', description='The queues that you want to delete.'),
}

model DeleteQueuesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model DeleteQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueuesResponseBody(name='body'),
}

/**
 * @summary Deletes queues from an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you delete a queue, you must delete all compute nodes in the queue.
 *
 * @param tmpReq DeleteQueuesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQueuesResponse
 */
async function deleteQueuesWithOptions(tmpReq: DeleteQueuesRequest, runtime: Util.RuntimeOptions): DeleteQueuesResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteQueuesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQueues',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes queues from an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you delete a queue, you must delete all compute nodes in the queue.
 *
 * @param request DeleteQueuesRequest
 * @return DeleteQueuesResponse
 */
async function deleteQueues(request: DeleteQueuesRequest): DeleteQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueuesWithOptions(request, runtime);
}

model DeleteUsersRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  user?: [ 
    {
      userName?: string(name='UserName', description='The name of user N that you want to delete.

Valid values of N: 1 to 100.

This parameter is required.', example='testuser'),
    }
  ](name='User', description='The users that you want to delete.

This parameter is required.'),
}

model DeleteUsersShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  userShrink?: string(name='User', description='The users that you want to delete.

This parameter is required.'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE****'),
}

model DeleteUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUsersResponseBody(name='body'),
}

/**
 * @summary Deletes users from a cluster.
 *
 * @param tmpReq DeleteUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteUsersResponse
 */
async function deleteUsersWithOptions(tmpReq: DeleteUsersRequest, runtime: Util.RuntimeOptions): DeleteUsersResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteUsersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.user)) {
    request.userShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.user, 'User', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUsers',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes users from a cluster.
 *
 * @param request DeleteUsersRequest
 * @return DeleteUsersResponse
 */
async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUsersWithOptions(request, runtime);
}

model DescribeAddonTemplateRequest {
  addonName?: string(name='AddonName', description='The addon name.

This parameter is required.', example='Login'),
  addonVersion?: string(name='AddonVersion', description='The addon version.

This parameter is required.', example='1.0'),
  pageNumber?: long(name='PageNumber', description='The page number of the page returned. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='20'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
}

model DescribeAddonTemplateResponseBody = {
  addon?: {
    description?: string(name='Description', description='The addon description.'),
    icon?: string(name='Icon', description='The addon icon.', example='/assets/icons/your_icon.svg'),
    label?: string(name='Label', description='The addon label.'),
    lastUpdate?: string(name='LastUpdate', description='The date when the addon template was last updated.', example='2024-08-22 18:11:17'),
    name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
    resourcesSpec?: {
      ecsResources?: [
        AddonNodeTemplate
      ](name='EcsResources', description='The Elastic Compute Service (ECS) resource configurations of the addon.'),
      eipResource?: {
        autoCreate?: boolean(name='AutoCreate', description='Indicates whether the EIP is automatically created.', example='True'),
        bandwidth?: string(name='Bandwidth', description='The maximum bandwidth of the EIP. Unit: Mbit/s.', example='100'),
        eipInstanceId?: string(name='EipInstanceId', description='The EIP ID.', example='eip-bp1jwtsuoiif2qf90****'),
        instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the EIP. Valid values:

*   PostPaid: pay-as-you-go.
*   PrePaid: subscription.

Default value: PostPaid', example='PostPaid'),
        internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay by bandwidth.
*   PayByTraffic: pay by data transfer.

Valid values of N: 1 to 10.', example='PayByTraffic'),
      }(name='EipResource', description='The Elastic IP Address (EIP) configurations of the service.'),
    }(name='ResourcesSpec', description='The resource configurations of the addon.'),
    servicesSpec?: [ 
      {
        inputParams?: [ 
          {
            helpText?: string(name='HelpText', description='The help information of the parameter.'),
            label?: string(name='Label', description='The parameter label.'),
            name?: string(name='Name', description='The parameter name.

This parameter is required.', example='MYSQL_HOME'),
            type?: string(name='Type', description='The parameter type.

This parameter is required.', example='String'),
            value?: string(name='Value', description='The parameter value.

This parameter is required.', example='usr/local/mysql'),
          }
        ](name='InputParams', description='The parameter configurations of the service.'),
        networkACL?: [ 
          {
            ipProtocol?: string(name='IpProtocol', description='The protocol type. Valid values:

*   **TCP**: forwards TCP packets.
*   **UDP**: forwards UDP packets.
*   **Any**: forwards all packets.

This parameter is required.', example='TCP'),
            port?: float(name='Port', description='The port number.

This parameter is required.', example='3306'),
            sourceCidrIp?: string(name='SourceCidrIp', description='The source CIDR block.

This parameter is required.', example='172.16.0.0/12'),
          }
        ](name='NetworkACL', description='The security group configurations of the service.'),
        serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
        serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
        serviceName?: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
      }
    ](name='ServicesSpec', description='The addon configurations.'),
    version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
  }(name='Addon', description='The details of the addon template.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeAddonTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAddonTemplateResponseBody(name='body'),
}

/**
 * @summary Queries the details of an addon template.
 *
 * @param request DescribeAddonTemplateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAddonTemplateResponse
 */
async function describeAddonTemplateWithOptions(request: DescribeAddonTemplateRequest, runtime: Util.RuntimeOptions): DescribeAddonTemplateResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addonName)) {
    query['AddonName'] = request.addonName;
  }
  if (!Util.isUnset(request.addonVersion)) {
    query['AddonVersion'] = request.addonVersion;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAddonTemplate',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an addon template.
 *
 * @param request DescribeAddonTemplateRequest
 * @return DescribeAddonTemplateResponse
 */
async function describeAddonTemplate(request: DescribeAddonTemplateRequest): DescribeAddonTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAddonTemplateWithOptions(request, runtime);
}

model DetachSharedStoragesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  sharedStorages?: [ 
    {
      mountDirectory?: string(name='MountDirectory', description='The local mount directory of the mounted file system.

This parameter is required.', example='/test'),
    }
  ](name='SharedStorages', description='The information about mounted shared storage resources.

This parameter is required.'),
}

model DetachSharedStoragesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  sharedStoragesShrink?: string(name='SharedStorages', description='The information about mounted shared storage resources.

This parameter is required.'),
}

model DetachSharedStoragesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model DetachSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachSharedStoragesResponseBody(name='body'),
}

/**
 * @summary Unmounts shared storage from the mount directory of a cluster.
 *
 * @param tmpReq DetachSharedStoragesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachSharedStoragesResponse
 */
async function detachSharedStoragesWithOptions(tmpReq: DetachSharedStoragesRequest, runtime: Util.RuntimeOptions): DetachSharedStoragesResponse {
  Util.validateModel(tmpReq);
  var request = new DetachSharedStoragesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sharedStorages)) {
    request.sharedStoragesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sharedStorages, 'SharedStorages', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.sharedStoragesShrink)) {
    query['SharedStorages'] = request.sharedStoragesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachSharedStorages',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unmounts shared storage from the mount directory of a cluster.
 *
 * @param request DetachSharedStoragesRequest
 * @return DetachSharedStoragesResponse
 */
async function detachSharedStorages(request: DetachSharedStoragesRequest): DetachSharedStoragesResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachSharedStoragesWithOptions(request, runtime);
}

model GetAddonRequest {
  addonId?: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
}

model GetAddonResponseBody = {
  addon?: {
    addonId?: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W2g****'),
    description?: string(name='Description', description='The addon description.'),
    icon?: string(name='Icon', description='The addon icon.', example='/assets/icons/your_icon.svg'),
    installTime?: string(name='InstallTime', description='The time when the addon was installed.', example='2024-08-22 18:11:17'),
    label?: string(name='Label', description='The addon label.'),
    name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
    resourcesSpec?: {
      ecsResources?: [
        AddonNodeTemplate
      ](name='EcsResources', description='The Elastic Compute Service (ECS) resource configurations of the addon.'),
      eipResource?: {
        autoCreate?: boolean(name='AutoCreate', description='Indicates whether the EIP is automatically created.', example='True'),
        bandwidth?: string(name='Bandwidth', description='The maximum bandwidth of the EIP. Unit: Mbit/s.', example='100'),
        eipAddress?: string(name='EipAddress', description='The EIP.', example='39.108.xx.xx'),
        eipInstanceId?: string(name='EipInstanceId', description='The EIP ID.', example='eip-bp1vi9124tbx1g3kr****'),
        instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the EIP.

*   PostPaid: pay-as-you-go.
*   PrePaid: subscription.

Default value: PostPaid.', example='PostPaid'),
        internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay by bandwidth.
*   PayByTraffic: pay by data transfer.

Valid values of N: 1 to 10.', example='PayByTraffic'),
      }(name='EipResource', description='The Elastic IP Address (EIP) configurations.'),
    }(name='ResourcesSpec', description='The resource configurations of the addon.'),
    servicesSpec?: [ 
      {
        inputParams?: [ 
          {
            helpText?: string(name='HelpText', description='The help information of the parameter.'),
            label?: string(name='Label', description='The parameter label.'),
            name?: string(name='Name', description='The parameter name.

This parameter is required.', example='MYSQL_HOME'),
            type?: string(name='Type', description='The parameter type.

This parameter is required.', example='String'),
            value?: string(name='Value', description='The parameter value.

This parameter is required.', example='usr/local/mysql'),
          }
        ](name='InputParams', description='The parameter configurations of the service.'),
        networkACL?: [ 
          {
            ipProtocol?: string(name='IpProtocol', description='The protocol type. Valid values:

TCP: forwards TCP packets.

UDP: forwards UDP packets.

Any: forwards all packets.

This parameter is required.', example='TCP'),
            port?: float(name='Port', description='The port number.

This parameter is required.', example='3306'),
            sourceCidrIp?: string(name='SourceCidrIp', description='The source CIDR block.

This parameter is required.', example='172.16.0.0/12'),
          }
        ](name='NetworkACL', description='The security group configurations of the service.'),
        serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
        serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
        serviceName?: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
      }
    ](name='ServicesSpec', description='The service configurations of the addon.'),
    status?: string(name='Status', description='The addon status.', example='Running'),
    version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
  }(name='Addon', description='The information about the addon.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
}

model GetAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAddonResponseBody(name='body'),
}

/**
 * @summary Queries the details of an installed addon.
 *
 * @param request GetAddonRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAddonResponse
 */
async function getAddonWithOptions(request: GetAddonRequest, runtime: Util.RuntimeOptions): GetAddonResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addonId)) {
    query['AddonId'] = request.addonId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAddon',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an installed addon.
 *
 * @param request GetAddonRequest
 * @return GetAddonResponse
 */
async function getAddon(request: GetAddonRequest): GetAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAddonWithOptions(request, runtime);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
}

model GetClusterResponseBody = {
  clientVersion?: string(name='ClientVersion', description='The E-HPC Util version.', example='2.0.31'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
  clusterCreateTime?: string(name='ClusterCreateTime', description='The time when the cluster was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='The arguments that are used to run the script after the scrip is installed.', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The URL that is used to download the post-processing script.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  clusterMode?: string(name='ClusterMode', description='The deployment type of the cluster. Valid values:

*   Integrated: The cluster is deployed on a public cloud.
*   Hybrid: The cluster is deployed on a hybrid cloud.
*   Custom: The cluster is a custom cluster.', example='Integrated'),
  clusterModifyTime?: string(name='ClusterModifyTime', description='The time when the cluster was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='slurm22.05.8-cluster-20240614'),
  clusterStatus?: string(name='ClusterStatus', description='The cluster state. Valid values:

*   uninit: The cluster is being installed.
*   creating: The cluster is being created.
*   initing: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster has run into an exception.
*   raleasing: The cluster is being released.
*   stopping: The cluster is being stopped.
*   stopped: The cluster is stopped.
*   pending: The cluster is waiting to be configured.', example='running'),
  clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch used by the cluster.', example='vsw-bp1p2uugqsjppno******'),
  clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) used by the cluster.', example='vpc-uf6u3lk1pjy28eg*****'),
  deleteProtection?: string(name='DeleteProtection', description='Indicates whether deletion protection is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  ehpcVersion?: string(name='EhpcVersion', description='The E-HPC version.', example='2.0.0'),
  enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether automatic scale-in is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether automatic scale-out is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  growInterval?: int32(name='GrowInterval', description='The interval at which the cluster is automatically scaled out.', example='2'),
  idleInterval?: int32(name='IdleInterval', description='The idle duration of the compute nodes allowed by the cluster.', example='4'),
  manager?: {
    DNS?: {
      status?: string(name='Status', description='The state of the domain name resolution service. Valid values:

*   uninit: The service is being installed.
*   initing: The service is being initialized.
*   running: The service is running.
*   exception: The service has run into an exception.
*   releasing: The service is being released.
*   stopped: The service is stopped.
*   pending: The service is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The resolution type.', example='nis'),
      version?: string(name='Version', description='The version of the resolution service.', example='2.31'),
    }(name='DNS', description='The configurations of the domain name resolution service.'),
    directoryService?: {
      status?: string(name='Status', description='The state of the domain account service. Valid values:

*   uninit: The service is being installed.
*   initing: The service is being initialized.
*   running: The service is running.
*   exception: The service has run into an exception.
*   releasing: The service is being released.
*   stopped: The service is stopped.
*   pending: The service is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The type of the domain account.', example='nis'),
      version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
    }(name='DirectoryService', description='The information about the domain account service.'),
    managerNode?: {
      autoRenew?: boolean(name='AutoRenew'),
      autoRenewPeriod?: long(name='AutoRenewPeriod', example='Month'),
      duration?: long(name='Duration', example='1'),
      enableHt?: boolean(name='EnableHt'),
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the management node.', example='2099-12-31T15:59Z'),
      imageId?: string(name='ImageId', example='aliyun_2_1903_x64_20G_alibase_20200324.vhd'),
      instanceChargeType?: string(name='InstanceChargeType', description='The instance billing method of the management node. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
      instanceId?: string(name='InstanceId', description='The instance ID of the management node.', example='i-bp1a170jgea1vl******'),
      instanceType?: string(name='InstanceType', description='The instance type of the management node.', example='ecs.g6.4xlarge'),
      period?: long(name='Period', example='1'),
      periodUnit?: string(name='PeriodUnit', example='Month'),
      spotPriceLimit?: float(name='SpotPriceLimit', example='1'),
      spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
      systemDisk?: {
        category?: string(name='Category', example='cloud_ssd'),
        level?: string(name='Level', example='PL0'),
        size?: long(name='Size', example='40'),
      }(name='SystemDisk'),
    }(name='ManagerNode', description='The configurations of the management node.'),
    scheduler?: {
      status?: string(name='Status', description='The scheduler state. Valid values:

*   uninit: The scheduler is being installed.
*   initing: The scheduler is being initialized.
*   running: The scheduler is running.
*   exception: The scheduler has run into an exception.
*   releasing: The scheduler is being released.
*   stopped: The scheduler is stopped.
*   pending: The scheduler is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The scheduler type. Valid values:

*   SLURM
*   PBS
*   OPENGRIDSCHEDULER
*   LSF_PLUGIN
*   PBS_PLUGIN', example='SLURM'),
      version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
    }(name='Scheduler', description='The information about the scheduler.'),
  }(name='Manager', description='The management node configurations.'),
  maxCoreCount?: string(name='MaxCoreCount', description='The maximum total number of vCPUs that can be used by all compute nodes managed by the cluster.', example='10000'),
  maxCount?: string(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage.', example='100'),
  monitorSpec?: {
    enableComputeLoadMonitor?: boolean(name='EnableComputeLoadMonitor', description='Indicates whether the monitoring component of compute nodes is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  }(name='MonitorSpec', description='The monitoring details of the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxazb4ph****'),
  schedulerSpec?: {
    enableTopologyAwareness?: boolean(name='EnableTopologyAwareness', description='Indicates whether the topology awareness feature is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  }(name='SchedulerSpec', description='The scheduler specifications of the cluster.'),
  securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-f8z9vb2zaezpkr69a21k'),
}

model GetClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterResponseBody(name='body'),
}

/**
 * @summary Queries information about an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request GetClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetClusterResponse
 */
async function getClusterWithOptions(request: GetClusterRequest, runtime: Util.RuntimeOptions): GetClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCluster',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request GetClusterRequest
 * @return GetClusterResponse
 */
async function getCluster(request: GetClusterRequest): GetClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return getClusterWithOptions(request, runtime);
}

model GetCommonLogDetailRequest {
  from?: long(name='From', description='The start time of the time range within which the logs that you want to query were generated. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821542'),
  hiddenProcess?: boolean(name='HiddenProcess', description='Specifies whether to hide the process of each step. Valid values:

*   true: hides the process and returns only the result log of each step.
*   false: does not hide the process and displays the start and result logs of each step.

Default value: true.', example='true'),
  logRequestId?: string(name='LogRequestId', description='The request ID.

This parameter is required.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  to?: long(name='To', description='The end time of the time range within which the logs that you want to query were generated. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821666'),
}

model GetCommonLogDetailResponseBody = {
  action?: string(name='Action', description='The action name.', example='CreateCluster'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-abc***'),
  logDetail?: [ 
    {
      stageName?: string(name='StageName', description='The stage name of the log.', example='ConfigNetwork'),
      stages?: [ 
        {
          logLevel?: string(name='LogLevel', description='The log level.

Valid values:

*   ERROR
*   INFO
*   WARN', example='INFO'),
          message?: string(name='Message', description='The output message of the log.', example='Successfully created security group sg-bcd***'),
          method?: string(name='Method', description='The method involved in the log.', example='CreateSecurityGroup'),
          requestId?: string(name='RequestId', description='The request ID associated with the log.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
          status?: string(name='Status', description='The action state involved in the log. Valid values:

*   InProgress: The action is being performed.
*   Finished: The action is completed.
*   Failed: The action failed.', example='Finished'),
          target?: string(name='Target', description='The resource involved in the log.', example='sg-bcd***'),
          time?: string(name='Time', description='The time when the log was generated.', example='2024-08-22 14:21:54'),
        }
      ](name='Stages', description='The information about the log stages.'),
    }
  ](name='LogDetail', description='The information about the logs.'),
  logType?: string(name='LogType', description='The log type.', example='operation'),
  operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='239***'),
  requestId?: string(name='RequestId', description='The request ID.', example='464E9919-D04F-4D1D-B375-15989492****'),
  uid?: string(name='Uid', description='The ID of the Alibaba Cloud account.', example='137***'),
}

model GetCommonLogDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommonLogDetailResponseBody(name='body'),
}

/**
 * @summary Query logs based on a request ID. Logs for specific actions can be queried thanks to an Action-Stage-Method three-layer log splitting structure.
 *
 * @param request GetCommonLogDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCommonLogDetailResponse
 */
async function getCommonLogDetailWithOptions(request: GetCommonLogDetailRequest, runtime: Util.RuntimeOptions): GetCommonLogDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.hiddenProcess)) {
    query['HiddenProcess'] = request.hiddenProcess;
  }
  if (!Util.isUnset(request.logRequestId)) {
    query['LogRequestId'] = request.logRequestId;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCommonLogDetail',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Query logs based on a request ID. Logs for specific actions can be queried thanks to an Action-Stage-Method three-layer log splitting structure.
 *
 * @param request GetCommonLogDetailRequest
 * @return GetCommonLogDetailResponse
 */
async function getCommonLogDetail(request: GetCommonLogDetailRequest): GetCommonLogDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCommonLogDetailWithOptions(request, runtime);
}

model GetJobRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  jobId?: string(name='JobId', description='The job ID. You can call the ListJobs operation to query the job ID.

This parameter is required.', example='1.manager'),
}

model GetJobResponseBody = {
  jobInfo?: {
    arrayJobId?: string(name='ArrayJobId', description='The parent job ID. If the return value is a non-empty string, the job is an array job.', example='1'),
    arrayJobSubId?: string(name='ArrayJobSubId', description='The sub-job ID. This parameter is valid when the ArrayJobId parameter is a non-empty string.', example='3'),
    arrayRequest?: string(name='ArrayRequest', description='The job queue. If the job is not in a queue, the output is empty.

The format is X-Y:Z. X indicates the first index, Y indicates the final index, and Z indicates the step size. For example, 2-7:2 indicates three sub-jobs numbered 2, 4, and 6.', example='1-5:2'),
    commandLine?: string(name='CommandLine', description='The command that is used to run the job.', example='/home/huangsf/ehpc/job_meta.pbs'),
    createTime?: string(name='CreateTime', description='The time when the job was submitted.', example='2024-08-16T10:52:48'),
    errorLog?: string(name='ErrorLog', description='The error log file of the job.', example='/home/xxx/STDIN.e1'),
    extraInfo?: string(name='ExtraInfo', description='Additional information.', example='{}'),
    jobId?: string(name='JobId', description='The job ID.', example='1.manager'),
    jobName?: string(name='JobName', description='The job name.', example='testJob'),
    jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='workq'),
    lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='2024-08-16T10:52:48'),
    nodeList?: string(name='NodeList', description='The compute nodes that are used to run the job.', example='compute000'),
    outputLog?: string(name='OutputLog', description='The standard output log file of the job.', example='/home/xxx/STDIN.o1'),
    priority?: string(name='Priority', description='The priority of the job.', example='0'),
    resources?: {
      cores?: string(name='Cores', description='The number of vCPUs used by the job on each node.', example='2'),
      gpus?: string(name='Gpus', description='The number of GPUs used by the job on each node.', example='1'),
      memory?: string(name='Memory', description='The memory size used by the job on each node.', example='1gb'),
      nodes?: string(name='Nodes', description='The number of nodes that are used to run the job.', example='1'),
    }(name='Resources', description='The resources that were requested when the job was submitted.'),
    resourcesUsed?: {
      cores?: string(name='Cores', description='The number of vCPUs used by the job on each node.', example='2'),
      memory?: string(name='Memory', description='The memory size used by the job on each node.', example='512mb'),
      nodes?: string(name='Nodes', description='The number of nodes that are used to run the job.', example='2'),
    }(name='ResourcesUsed', description='The resources that are actually used by the job.'),
    runasUser?: string(name='RunasUser', description='The user to which the job belongs or that is used to submit the job. This user is a cluster-side user.', example='testuser'),
    startTime?: string(name='StartTime', description='The time when the job was started.', example='2024-08-16T10:52:48'),
    state?: string(name='State', description='The job state.', example='Running'),
    variables?: [ 
      {
        name?: string(name='Name', description='The name of the environment variable.', example='ProxyIP'),
        value?: string(name='Value', description='The value of the environment variable.', example='10.x.x.x'),
      }
    ](name='Variables', description='The variables of the job.'),
  }(name='JobInfo', description='The job details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0****-1335-****-A1D7-6C044FE7****'),
  success?: string(name='Success', description='The request result. Valid values:

*   true
*   false', example='true'),
}

model GetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobResponseBody(name='body'),
}

/**
 * @summary Obtains the details of a job.
 *
 * @param request GetJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobResponse
 */
async function getJobWithOptions(request: GetJobRequest, runtime: Util.RuntimeOptions): GetJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the details of a job.
 *
 * @param request GetJobRequest
 * @return GetJobResponse
 */
async function getJob(request: GetJobRequest): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobWithOptions(request, runtime);
}

model GetJobLogRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-jeJki6****'),
  jobId?: string(name='JobId', description='The job ID.

This parameter is required.', example='1.manager'),
  logType?: string(name='LogType', description='The log type. Valid values:

*   stdout: standard output logs.
*   stderr: error output logs.
*   all: all logs.

Default value: all.', example='stdout'),
  offset?: string(name='Offset', description='The position where logs start to be read.

Unit: bytes.

Default value: 0.', example='0'),
  size?: string(name='Size', description='The maximum size of logs that you can read in a single request.

Unit: bytes.

Default value: 10240.', example='20480'),
}

model GetJobLogResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='1.manager'),
  requestId?: string(name='RequestId', description='The request ID.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  stderrLog?: string(name='StderrLog', description='The error output log that is encoded in Base64.', example='aG9zdG5hbWU='),
  stderrLogSize?: string(name='StderrLogSize', description='The size of the error output file.', example='0'),
  stdoutLog?: string(name='StdoutLog', description='The standard output log that is encoded in Base64.', example='aG9zdG5hbWU='),
  stdoutLogSize?: string(name='StdoutLogSize', description='The size of the standard output file.', example='4096'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model GetJobLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobLogResponseBody(name='body'),
}

/**
 * @summary Queries the output logs of a job, including standard output logs and error output logs.
 *
 * @description ## [](#)Usage notes
 * Currently, only Slurm and PBS Pro schedulers for Standard Edition clusters are supported.
 *
 * @param request GetJobLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobLogResponse
 */
async function getJobLogWithOptions(request: GetJobLogRequest, runtime: Util.RuntimeOptions): GetJobLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.offset)) {
    query['Offset'] = request.offset;
  }
  if (!Util.isUnset(request.size)) {
    query['Size'] = request.size;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobLog',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the output logs of a job, including standard output logs and error output logs.
 *
 * @description ## [](#)Usage notes
 * Currently, only Slurm and PBS Pro schedulers for Standard Edition clusters are supported.
 *
 * @param request GetJobLogRequest
 * @return GetJobLogResponse
 */
async function getJobLog(request: GetJobLogRequest): GetJobLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobLogWithOptions(request, runtime);
}

model GetQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  queueName?: string(name='QueueName', description='The queue name.', example='comp'),
}

model GetQueueResponseBody = {
  queue?: {
    allocationStrategy?: string(name='AllocationStrategy', description='The auto scale-out policy of the queue.', example='PriorityInstanceType'),
    computeNodes?: [
      NodeTemplate
    ](name='ComputeNodes', description='The hardware configurations of the compute nodes in the queue.'),
    enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether auto scale-in is enabled for the queue. Valid values:

*   true
*   false', example='true'),
    enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether auto scale-out is enabled for the queue. Valid values:

*   true
*   false', example='true'),
    hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the compute nodes in the queue.', example='compute'),
    hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the compute nodes in the queue.', example='demo'),
    initialCount?: int32(name='InitialCount', description='The initial number of nodes in the queue.', example='0'),
    interConnect?: string(name='InterConnect', description='The type of the network between compute nodes in the queue. Valid values:

*   vpc
*   eRDMA', example='erdma'),
    keepAliveNodes?: [ string ](name='KeepAliveNodes', description='The nodes for which deletion protection is enabled in the queue.'),
    maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='1000'),
    maxCountPerCycle?: long(name='MaxCountPerCycle', description='The minimum number of nodes that are delivered to the queue in each scale-out cycle.', example='99'),
    minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
    queueName?: string(name='QueueName', description='The queue name.

This parameter is required.', example='comp'),
    ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role that is assumed by compute nodes in the queue.', example='AliyunECSInstanceForEHPCRole'),
    reservedNodePoolId?: string(name='ReservedNodePoolId', description='Preset node pool ID.', example='rnp-756vlp7a'),
    vSwitchIds?: [ string ](name='VSwitchIds', description='The available vSwitches for compute nodes in the queue. Valid values of N: 1 to 5.'),
  }(name='Queue', description='The queue configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model GetQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueResponseBody(name='body'),
}

/**
 * @summary Queries the details of a queue in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request GetQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueueResponse
 */
async function getQueueWithOptions(request: GetQueueRequest, runtime: Util.RuntimeOptions): GetQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueue',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a queue in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request GetQueueRequest
 * @return GetQueueResponse
 */
async function getQueue(request: GetQueueRequest): GetQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueWithOptions(request, runtime);
}

model InstallAddonRequest {
  addonName?: string(name='AddonName', description='The addon name.

This parameter is required.', example='Login'),
  addonVersion?: string(name='AddonVersion', description='The addon version.

This parameter is required.', example='1.0'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  resourcesSpec?: string(name='ResourcesSpec', description='The resource configurations of the addon.

This parameter is required.', example='`{"EipResource": {"AutoCreate": true}, "EcsResources": [{"InstanceType": "ecs.c7.xlarge", "ImageId": "centos_7_6_xxx.vhd", "SystemDisk": {"Category": "cloud_essd", "Size": 40, "Level": "PL0"}]}`'),
  servicesSpec?: string(name='ServicesSpec', description='The service configurations of the addon.

This parameter is required.', example='`[{"ServiceName": "SSH", "ServiceAccessType": null, "ServiceAccessUrl": null, "NetworkACL": [{"IpProtocol": "TCP", "Port": 22, "SourceCidrIp": "0.0.0.0/0"}]}, {"ServiceName": "VNC", "ServiceAccessType": null, "ServiceAccessUrl": null, "NetworkACL": [{"IpProtocol": "TCP", "Port": 12016, "SourceCidrIp": "0.0.0.0/0"}]}]`'),
}

model InstallAddonResponseBody = {
  addonId?: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model InstallAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallAddonResponseBody(name='body'),
}

/**
 * @summary Installs an addon.
 *
 * @description ## [](#)Usage notes
 * Take note of the following items when you call this operation:
 * *   The cluster must be in the `Running` state.
 * *   Clusters fall into two types:
 *     *   Regular clusters on Alibaba Cloud Public Cloud
 *     *   Managed clusters on Alibaba Cloud Public Cloud
 *
 * @param request InstallAddonRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallAddonResponse
 */
async function installAddonWithOptions(request: InstallAddonRequest, runtime: Util.RuntimeOptions): InstallAddonResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addonName)) {
    query['AddonName'] = request.addonName;
  }
  if (!Util.isUnset(request.addonVersion)) {
    query['AddonVersion'] = request.addonVersion;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourcesSpec)) {
    query['ResourcesSpec'] = request.resourcesSpec;
  }
  if (!Util.isUnset(request.servicesSpec)) {
    query['ServicesSpec'] = request.servicesSpec;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallAddon',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Installs an addon.
 *
 * @description ## [](#)Usage notes
 * Take note of the following items when you call this operation:
 * *   The cluster must be in the `Running` state.
 * *   Clusters fall into two types:
 *     *   Regular clusters on Alibaba Cloud Public Cloud
 *     *   Managed clusters on Alibaba Cloud Public Cloud
 *
 * @param request InstallAddonRequest
 * @return InstallAddonResponse
 */
async function installAddon(request: InstallAddonRequest): InstallAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  return installAddonWithOptions(request, runtime);
}

model InstallSoftwaresRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The software name.', example='gromacs'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackages', description='The information about the software systems that you want to install.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
}

model InstallSoftwaresShrinkRequest {
  additionalPackagesShrink?: string(name='AdditionalPackages', description='The information about the software systems that you want to install.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
}

model InstallSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model InstallSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallSoftwaresResponseBody(name='body'),
}

/**
 * @summary Install software for the specified cluster.
 *
 * @description ## Interface Description
 * When calling this interface, please note the following:
 * - The cluster status must be `Running`. 
 * - If the cluster series is `Serverless`, ensure that there is at least one login node or compute node in the cluster; otherwise, software cannot be added to the target cluster.
 *
 * @param tmpReq InstallSoftwaresRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstallSoftwaresResponse
 */
async function installSoftwaresWithOptions(tmpReq: InstallSoftwaresRequest, runtime: Util.RuntimeOptions): InstallSoftwaresResponse {
  Util.validateModel(tmpReq);
  var request = new InstallSoftwaresShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalPackages)) {
    request.additionalPackagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalPackages, 'AdditionalPackages', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallSoftwares',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Install software for the specified cluster.
 *
 * @description ## Interface Description
 * When calling this interface, please note the following:
 * - The cluster status must be `Running`. 
 * - If the cluster series is `Serverless`, ensure that there is at least one login node or compute node in the cluster; otherwise, software cannot be added to the target cluster.
 *
 * @param request InstallSoftwaresRequest
 * @return InstallSoftwaresResponse
 */
async function installSoftwares(request: InstallSoftwaresRequest): InstallSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return installSoftwaresWithOptions(request, runtime);
}

model ListAddonTemplatesRequest {
  addonNames?: [ string ](name='AddonNames', description='The addon names.'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
  pageNumber?: long(name='PageNumber', description='The page number of the page to return. Pages start from page 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='10'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-shanghai'),
}

model ListAddonTemplatesResponseBody = {
  addons?: [ 
    {
      description?: string(name='Description', description='The addon description.'),
      label?: string(name='Label', description='The addon label'),
      name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The information about the addon templates.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAddonTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonTemplatesResponseBody(name='body'),
}

/**
 * @summary Queries supported addon templates.
 *
 * @param request ListAddonTemplatesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAddonTemplatesResponse
 */
async function listAddonTemplatesWithOptions(request: ListAddonTemplatesRequest, runtime: Util.RuntimeOptions): ListAddonTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addonNames)) {
    query['AddonNames'] = request.addonNames;
  }
  if (!Util.isUnset(request.clusterCategory)) {
    query['ClusterCategory'] = request.clusterCategory;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAddonTemplates',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries supported addon templates.
 *
 * @param request ListAddonTemplatesRequest
 * @return ListAddonTemplatesResponse
 */
async function listAddonTemplates(request: ListAddonTemplatesRequest): ListAddonTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAddonTemplatesWithOptions(request, runtime);
}

model ListAddonsRequest {
  addonIds?: [ string ](name='AddonIds', description='The addon IDs.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListAddonsShrinkRequest {
  addonIdsShrink?: string(name='AddonIds', description='The addon IDs.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListAddonsResponseBody = {
  addons?: [ 
    {
      addonId?: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****'),
      description?: string(name='Description', description='The addon description.'),
      installTime?: string(name='InstallTime', description='The time when the addon was installed.', example='2024-08-22 18:11:17'),
      label?: string(name='Label', description='The addon label.'),
      name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      status?: string(name='Status', description='The addon state.', example='Running'),
      version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The information about the addons.'),
  pageNumber?: int32(name='PageNumber', description='The number of entries per page.', example='20'),
  pageSize?: int32(name='PageSize', description='The page number of the returned page. Default value: 1', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonsResponseBody(name='body'),
}

/**
 * @summary Queries installed addons of an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq ListAddonsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAddonsResponse
 */
async function listAddonsWithOptions(tmpReq: ListAddonsRequest, runtime: Util.RuntimeOptions): ListAddonsResponse {
  Util.validateModel(tmpReq);
  var request = new ListAddonsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.addonIds)) {
    request.addonIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.addonIds, 'AddonIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.addonIdsShrink)) {
    query['AddonIds'] = request.addonIdsShrink;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAddons',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries installed addons of an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request ListAddonsRequest
 * @return ListAddonsResponse
 */
async function listAddons(request: ListAddonsRequest): ListAddonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAddonsWithOptions(request, runtime);
}

model ListAvailableFileSystemsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Page starts from page 1. Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50. Default value: 10', example='10'),
}

model ListAvailableFileSystemsResponseBody = {
  fileSystemList?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2024-7-29 15:43:53'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='2fa0248***'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system. Valid values:

*   standard: general-purpose network-attached storage (NAS) file system
*   extreme: extreme NAS file system', example='cpfs'),
      mountTargetList?: [ 
        {
          mountTargetDomain?: string(name='MountTargetDomain', description='The address of the mount target.', example='c0967****.cn-hangzhou.cpfs.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type. Valid values: Valid values:

*   vpc', example='vpc'),
          status?: string(name='Status', description='The state of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.
*   Pending: The mount target is being mounted.
*   Deleting: The mount target is being deleted.', example='Active'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-2ze0c41hwu7lc29ris***'),
          vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargetList', description='The mount targets of the file system.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system. Valid values:

*   nfs
*   smb
*   cpfs', example='cpfs'),
      status?: string(name='Status', description='The state of the file system. Valid values:

*   Pending: The file system is processing a task.
*   Running: The file system is available. You can perform subsequent operations, such as creating a mount target, only when the file system is in the Running state.
*   Stopped: The file system is unavailable.
*   Extending: The file system is being scaled out.
*   Stopping: The file system is being stopped.
*   Deleting: The file system is being deleted.', example='Running'),
      storageType?: string(name='StorageType', description='The storage type of the file system.

*   Valid values if FileSystemType is set to standard: Capacity and Performance.
*   Valid values if FileSystemType is set to extreme: standard and advance.', example='Performance'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp132kgui8n0targb****'),
    }
  ](name='FileSystemList', description='The file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='BF4E8AB1-02A3-5ECF-87CC-3AB7BE98**'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='65'),
}

model ListAvailableFileSystemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableFileSystemsResponseBody(name='body'),
}

/**
 * @summary Queries the file systems that can be attached in a region.
 *
 * @param request ListAvailableFileSystemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableFileSystemsResponse
 */
async function listAvailableFileSystemsWithOptions(request: ListAvailableFileSystemsRequest, runtime: Util.RuntimeOptions): ListAvailableFileSystemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableFileSystems',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the file systems that can be attached in a region.
 *
 * @param request ListAvailableFileSystemsRequest
 * @return ListAvailableFileSystemsResponse
 */
async function listAvailableFileSystems(request: ListAvailableFileSystemsRequest): ListAvailableFileSystemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableFileSystemsWithOptions(request, runtime);
}

model ListAvailableImagesRequest {
  directoryService?: {
    type?: string(name='Type', description='The type of the domain account.', example='NIS'),
    version?: string(name='Version', description='The version of the domain account service.', example='1.0'),
  }(name='DirectoryService', description='The information about the domain account service.'),
  enableHT?: boolean(name='EnableHT', description='Specifies whether to return images in which hyper-threading is enabled.', example='true'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The network type of the images that you want to query.', example='vpc'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The image source. Valid values:

*   system: system image.
*   self: custom image.
*   others: shared image.', example='self'),
  instanceType?: string(name='InstanceType', description='The instance type.

>  By default, if you do not specify an instance type, the list of images that are supported by all instance types are queried. For more information, see [Instance families](https://help.aliyun.com/document_detail/25378.html).', example='ecs.c7.large'),
  isPublic?: boolean(name='IsPublic', description='Specifies whether to return published community images. Valid values:

*   true: returns published community images. If you set the value of this parameter to `true`, the `ImageOwnerAlias` parameter must be set to `others`.
*   false: returns non-community images. The value of the `ImageOwnerAlias` parameter prevails.

Default value: false.', example='true'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50. Default value: 10.', example='1'),
  scheduler?: {
    type?: string(name='Type', description='The scheduler type.', example='SLURM'),
    version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
  }(name='Scheduler', description='The scheduler information about the images that you want to query.'),
}

model ListAvailableImagesShrinkRequest {
  directoryServiceShrink?: string(name='DirectoryService', description='The information about the domain account service.'),
  enableHT?: boolean(name='EnableHT', description='Specifies whether to return images in which hyper-threading is enabled.', example='true'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The network type of the images that you want to query.', example='vpc'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The image source. Valid values:

*   system: system image.
*   self: custom image.
*   others: shared image.', example='self'),
  instanceType?: string(name='InstanceType', description='The instance type.

>  By default, if you do not specify an instance type, the list of images that are supported by all instance types are queried. For more information, see [Instance families](https://help.aliyun.com/document_detail/25378.html).', example='ecs.c7.large'),
  isPublic?: boolean(name='IsPublic', description='Specifies whether to return published community images. Valid values:

*   true: returns published community images. If you set the value of this parameter to `true`, the `ImageOwnerAlias` parameter must be set to `others`.
*   false: returns non-community images. The value of the `ImageOwnerAlias` parameter prevails.

Default value: false.', example='true'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50. Default value: 10.', example='1'),
  schedulerShrink?: string(name='Scheduler', description='The scheduler information about the images that you want to query.'),
}

model ListAvailableImagesResponseBody = {
  images?: [ 
    {
      architecture?: string(name='Architecture', description='The OS architecture of the image. Valid values:

*   x86_64
*   arm64', example='x86_64'),
      bootMode?: string(name='BootMode', description='The boot mode of the image. Valid values:

*   BIOS: Basic Input/Output System (BIOS).
*   UEFI: Unified Extensible Firmware Interface (UEFI).

>  When you change the OS boot mode of an instance, you must make sure that the boot mode matches the boot mode of the associated image. Otherwise, the instance fails to be booted.', example='BIOS'),
      description?: string(name='Description', description='The image description.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The image ID.', example='centos_7_06_64_20G_alibase_2019071****'),
      imageName?: string(name='ImageName', description='The image name.', example='CHESS5V5.0.27'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The image source. Valid values:

*   system: system image.
*   self: custom image.
*   others: shared image.', example='self'),
      OSName?: string(name='OSName', description='The OS name in Chinese.'),
      OSNameEn?: string(name='OSNameEn', description='The OS name in English.', example='CentOS  7.9 64 bit'),
      platform?: string(name='Platform', description='The OS. Valid values:

*   CentOS
*   windows', example='windows'),
      size?: string(name='Size', description='The image size. Unit: GiB', example='40'),
    }
  ](name='Images', description='The information about the images.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.

*   Pages start from page 1.
*   Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAvailableImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableImagesResponseBody(name='body'),
}

/**
 * @summary Queries images that are available for Elastic High Performance Computing (E-HPC) clusters.
 *
 * @param tmpReq ListAvailableImagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListAvailableImagesResponse
 */
async function listAvailableImagesWithOptions(tmpReq: ListAvailableImagesRequest, runtime: Util.RuntimeOptions): ListAvailableImagesResponse {
  Util.validateModel(tmpReq);
  var request = new ListAvailableImagesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.directoryService)) {
    request.directoryServiceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.directoryService, 'DirectoryService', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduler)) {
    request.schedulerShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduler, 'Scheduler', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableImages',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries images that are available for Elastic High Performance Computing (E-HPC) clusters.
 *
 * @param request ListAvailableImagesRequest
 * @return ListAvailableImagesResponse
 */
async function listAvailableImages(request: ListAvailableImagesRequest): ListAvailableImagesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableImagesWithOptions(request, runtime);
}

model ListClustersRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs. You can specify up to 20 IDs.'),
  clusterNames?: [ string ](name='ClusterNames', description='The cluster names. You can specify up to 20 names.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 10 to 100. Default value: 10', example='10'),
}

model ListClustersShrinkRequest {
  clusterIdsShrink?: string(name='ClusterIds', description='The cluster IDs. You can specify up to 20 IDs.'),
  clusterNamesShrink?: string(name='ClusterNames', description='The cluster names. You can specify up to 20 names.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 10 to 100. Default value: 10', example='10'),
}

model ListClustersResponseBody = {
  clusters?: [ 
    {
      additionalPackages?: [ 
        {
          name?: string(name='Name', description='The software name.', example='gromacs'),
          version?: string(name='Version', description='The software version.', example='2024.1'),
        }
      ](name='AdditionalPackages', description='The information about installed software in the cluster.'),
      addons?: [ 
        {
          addonId?: string(name='AddonId', description='The addon ID.', example='Login-1.0-W2g****'),
          description?: string(name='Description', description='The addon description.'),
          label?: string(name='Label', description='The addon label.'),
          name?: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
          resourcesSpec?: {
            ecsInstanceId?: string(name='EcsInstanceId', description='The instance ID.', example='i-bp1bg85d2q6laic8****'),
            eipInstanceId?: string(name='EipInstanceId', description='The Elastic IP Address (EIP) ID.', example='eip-bp1vi9124tbx1g3kr****'),
          }(name='ResourcesSpec', description='The resource configurations of the addon.'),
          servicesSpec?: [ 
            {
              serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
              serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
              serviceName?: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
            }
          ](name='ServicesSpec', description='The information about the addon services.'),
          status?: string(name='Status', description='The addon state.', example='Running'),
          version?: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
        }
      ](name='Addons', description='The information about the addons in the cluster.'),
      clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
      clusterCreateTime?: string(name='ClusterCreateTime', description='The time when the cluster was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
      clusterCredentials?: [ string ](name='ClusterCredentials', description='The logon credential type of the cluster. Valid values:

*   password: requires passwords for logons.
*   keypair: requires key pairs for logons.'),
      clusterCustomConfiguration?: {
        args?: string(name='Args', description='The parameters of the post-processing script.', example='demo'),
        script?: string(name='Script', description='The link to the post-processing script.', example='https://xxxxx'),
      }(name='ClusterCustomConfiguration', description='The post-processing script used by the cluster.'),
      clusterDescription?: string(name='ClusterDescription', description='The cluster description.', example='Demo'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-VMKe******'),
      clusterMode?: string(name='ClusterMode', description='The deployment type of the cluster. Valid values:

*   Integrated: public cloud
*   Hybrid: hybrid cloud
*   Custom: a custom cluster', example='Integrated'),
      clusterModifyTime?: string(name='ClusterModifyTime', description='The time when the cluster was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='slurm22.05.8-cluster-20240227'),
      clusterStatus?: string(name='ClusterStatus', description='The cluster state. Valid values:

*   uninit: The cluster is being installed.
*   creating: The cluster is being created.
*   initing: The cluster is being initialized.
*   running: The cluster is running.
*   Releasing: The cluster is being released.
*   stopping: The cluster is being stopped.
*   stopped: The cluster is stopped.
*   exception: The cluster has run into an exception.
*   pending: The cluster is waiting to be configured.', example='running'),
      clusterUsedCoreTime?: float(name='ClusterUsedCoreTime', description='The vCPU-hour usage of the cluster.', example='1000'),
      clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch used by the cluster.', example='vsw-f8za5p0mwzgdu3wgx****'),
      clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) used by the cluster.', example='vpc-m5efjevmclc0xdmys****'),
      deletionProtection?: boolean(name='DeletionProtection', description='Indicates whether deletion protection is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
      ehpcVersion?: string(name='EhpcVersion', description='The Elastic High Performance Computing (E-HPC) version.', example='2.0.0'),
      manager?: {
        DNS?: {
          type?: string(name='Type', description='The resolution type.', example='NIS'),
          version?: string(name='Version', description='The version of the domain name resolution service.', example='2.31'),
        }(name='DNS', description='The configurations of the domain name resolution service.'),
        directoryService?: {
          type?: string(name='Type', description='The type of the domain account.', example='NIS'),
          version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
        }(name='DirectoryService', description='The configurations of the directory service.'),
        scheduler?: {
          type?: string(name='Type', description='The scheduler type.', example='SLURM'),
          version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
        }(name='Scheduler', description='The configurations of the scheduler service.'),
      }(name='Manager', description='The configurations of the cluster management node.'),
      maxCoreCount?: long(name='MaxCoreCount', description='The maximum total number of vCPUs used by the compute nodes that can be managed by the cluster.', example='10000'),
      maxCount?: long(name='MaxCount', description='The maximum number of compute nodes that can be managed by the cluster.', example='500'),
      nodes?: {
        abnormalCounts?: int32(name='AbnormalCounts', description='The number of malfunctioning compute nodes.', example='0'),
        creatingCounts?: int32(name='CreatingCounts', description='The number of compute nodes that are being created.', example='0'),
        runningCounts?: int32(name='RunningCounts', description='The number of running compute nodes.', example='1'),
      }(name='Nodes', description='The node statistics of the cluster.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxazb4ph****'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group used by the cluster.', example='sg-bp13n61xsydodfyg****'),
      users?: {
        normalCounts?: int32(name='NormalCounts', description='The number of ordinary users.', example='2'),
        sudoCounts?: int32(name='SudoCounts', description='The number of administrators.', example='2'),
      }(name='Users', description='The user attribute information of the cluster.'),
    }
  ](name='Clusters', description='The list of clusters.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClustersResponseBody(name='body'),
}

/**
 * @summary Queries all clusters of a user in each region.
 *
 * @param tmpReq ListClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListClustersResponse
 */
async function listClustersWithOptions(tmpReq: ListClustersRequest, runtime: Util.RuntimeOptions): ListClustersResponse {
  Util.validateModel(tmpReq);
  var request = new ListClustersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clusterIds)) {
    request.clusterIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clusterIds, 'ClusterIds', 'json');
  }
  if (!Util.isUnset(tmpReq.clusterNames)) {
    request.clusterNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clusterNames, 'ClusterNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterIdsShrink)) {
    query['ClusterIds'] = request.clusterIdsShrink;
  }
  if (!Util.isUnset(request.clusterNamesShrink)) {
    query['ClusterNames'] = request.clusterNamesShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClusters',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all clusters of a user in each region.
 *
 * @param request ListClustersRequest
 * @return ListClustersResponse
 */
async function listClusters(request: ListClustersRequest): ListClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClustersWithOptions(request, runtime);
}

model ListCommonLogsRequest {
  actionName?: [ string ](name='ActionName', description='The action types.'),
  actionStatus?: string(name='ActionStatus', description='The action status. Logs associated with the specific action status are returned.

Valid values:

*   Finished: The action is completed.
*   Failed: The action failed.
*   InProgress: The action is being performed.', example='Finished'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  from?: long(name='From', description='The start time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821542'),
  isReverse?: boolean(name='IsReverse', description='Specifies whether to display results in reverse order.

Default value: true', example='true'),
  logRequestId?: string(name='LogRequestId', description='The request ID of the action. Logs associated with the specific request ID are returned.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  logType?: string(name='LogType', description='The log type. Logs of the specific type are returned.', example='Operation'),
  operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='137***'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.

Default value: 20.', example='10'),
  resource?: string(name='Resource', description='The name of the resource involved in the action. Logs associated with the specific resource are returned. This parameter is not recommended.', example='i-abc***'),
  to?: long(name='To', description='The end time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821666'),
}

model ListCommonLogsShrinkRequest {
  actionNameShrink?: string(name='ActionName', description='The action types.'),
  actionStatus?: string(name='ActionStatus', description='The action status. Logs associated with the specific action status are returned.

Valid values:

*   Finished: The action is completed.
*   Failed: The action failed.
*   InProgress: The action is being performed.', example='Finished'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  from?: long(name='From', description='The start time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821542'),
  isReverse?: boolean(name='IsReverse', description='Specifies whether to display results in reverse order.

Default value: true', example='true'),
  logRequestId?: string(name='LogRequestId', description='The request ID of the action. Logs associated with the specific request ID are returned.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  logType?: string(name='LogType', description='The log type. Logs of the specific type are returned.', example='Operation'),
  operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='137***'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.

Default value: 20.', example='10'),
  resource?: string(name='Resource', description='The name of the resource involved in the action. Logs associated with the specific resource are returned. This parameter is not recommended.', example='i-abc***'),
  to?: long(name='To', description='The end time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821666'),
}

model ListCommonLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action', description='The name of the action corresponding to the log.', example='CreaterCluster'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-9T3xPNezoS'),
      logType?: string(name='LogType', description='The log type.', example='Operation'),
      message?: string(name='Message', description='The message of the log.', example='ok'),
      operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='137***'),
      requestId?: string(name='RequestId', description='The request ID associated with the action that generated the log.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
      status?: string(name='Status', description='The action state in the log. Valid values:

*   InProgress: The action is being performed.
*   Finished: The action is completed.
*   Failed: The action failed.', example='Finished'),
      target?: string(name='Target', description='The involved resource.', example='i-abc***'),
      time?: string(name='Time', description='The time when the log was generated.', example='2024-08-22 14:21:54'),
    }
  ](name='Logs', description='The brief information of operation logs.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='464E9919-D04F-4D1D-B375-15989492****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='15'),
  uid?: string(name='Uid', description='The ID of the Alibaba Cloud account.', example='137***'),
}

model ListCommonLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCommonLogsResponseBody(name='body'),
}

/**
 * @summary Queries the logs of a cluster that are generated within a time range.
 *
 * @param tmpReq ListCommonLogsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListCommonLogsResponse
 */
async function listCommonLogsWithOptions(tmpReq: ListCommonLogsRequest, runtime: Util.RuntimeOptions): ListCommonLogsResponse {
  Util.validateModel(tmpReq);
  var request = new ListCommonLogsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.actionName)) {
    request.actionNameShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.actionName, 'ActionName', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.actionNameShrink)) {
    query['ActionName'] = request.actionNameShrink;
  }
  if (!Util.isUnset(request.actionStatus)) {
    query['ActionStatus'] = request.actionStatus;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.from)) {
    query['From'] = request.from;
  }
  if (!Util.isUnset(request.isReverse)) {
    query['IsReverse'] = request.isReverse;
  }
  if (!Util.isUnset(request.logRequestId)) {
    query['LogRequestId'] = request.logRequestId;
  }
  if (!Util.isUnset(request.logType)) {
    query['LogType'] = request.logType;
  }
  if (!Util.isUnset(request.operatorUid)) {
    query['OperatorUid'] = request.operatorUid;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resource)) {
    query['Resource'] = request.resource;
  }
  if (!Util.isUnset(request.to)) {
    query['To'] = request.to;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommonLogs',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the logs of a cluster that are generated within a time range.
 *
 * @param request ListCommonLogsRequest
 * @return ListCommonLogsResponse
 */
async function listCommonLogs(request: ListCommonLogsRequest): ListCommonLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommonLogsWithOptions(request, runtime);
}

model ListInstalledSoftwaresRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListInstalledSoftwaresResponseBody = {
  additionalPackages?: {
    additionalPackageInfos?: [ 
    {
      category?: string(name='Category', description='The category into which the software falls.', example='NWP'),
      createTime?: string(name='CreateTime', description='The time when the software was installed.', example='2024-03-05 18:24:08'),
      description?: string(name='Description', description='The software description.'),
      icon?: string(name='Icon', description='The URL of the software icon.', example='https://gw.alicdn.com/imgextra/i2/O1CN01FIkxZ81LmE0fvrAyR_!!6000000001341-55-tps-6349-1603.svg'),
      name?: string(name='Name', description='The software name.', example='gromacs'),
      status?: string(name='Status', description='The installation status of the software.

Valid values:

*   Installed
*   Uninstalled
*   Installing
*   Exception', example='Installed'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackageInfos')
  }(name='AdditionalPackages', description='The list of installed software.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListInstalledSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstalledSoftwaresResponseBody(name='body'),
}

/**
 * @summary Queries the installed software of a cluster.
 *
 * @param request ListInstalledSoftwaresRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstalledSoftwaresResponse
 */
async function listInstalledSoftwaresWithOptions(request: ListInstalledSoftwaresRequest, runtime: Util.RuntimeOptions): ListInstalledSoftwaresResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstalledSoftwares',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the installed software of a cluster.
 *
 * @param request ListInstalledSoftwaresRequest
 * @return ListInstalledSoftwaresResponse
 */
async function listInstalledSoftwares(request: ListInstalledSoftwaresRequest): ListInstalledSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstalledSoftwaresWithOptions(request, runtime);
}

model ListJobsRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-csbua72***'),
  jobFilter?: {
    createTimeEnd?: string(name='CreateTimeEnd', description='The time when the job was last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since 1970-01-01T00:00:00Z.', example='1724123085'),
    createTimeStart?: string(name='CreateTimeStart', description='The time when the job started. The value is a UNIX timestamp representing the number of seconds that have elapsed since 1970-01-01T00:00:00Z.', example='1724122486'),
    diagnosis?: [ 
      {
        operator?: string(name='Operator', description='Job diagnosis threshold comparator.', example='greater'),
        option?: string(name='Option', description='Job diagnosis and analysis metrics', example='run_duration'),
        threshold?: string(name='Threshold', description='Job diagnosis threshold.', example='24'),
      }
    ](name='Diagnosis', description='Job diagnosis and analysis list.'),
    jobName?: string(name='JobName', description='The job name. Fuzzy match is supported.', example='testjob'),
    jobStatus?: string(name='JobStatus', description='The job status. Valid values:

*   all: returns all jobs.
*   finished: returns completed jobs.
*   notfinish: returns uncompleted jobs.

Default value: all.', example='all'),
    nodes?: [ string ](name='Nodes', description='The compute nodes that run the jobs.'),
    queues?: [ string ](name='Queues', description='The queues to which the jobs belong.'),
    sortBy?: {
      executeOrder?: string(name='ExecuteOrder', description='The order in which jobs are sorted based on their execution time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='asc'),
      pendOrder?: string(name='PendOrder', description='The order in which jobs are sorted based on their queuing time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='desc'),
      submitOrder?: string(name='SubmitOrder', description='The order in which jobs are sorted based on their submitting time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='asc'),
    }(name='SortBy', description='The result sorting configurations.'),
    users?: [ string ](name='Users', description='The users that run the jobs.'),
  }(name='JobFilter', description='The job filter information.'),
  pageNumber?: string(name='PageNumber', description='The page number of the page to return.

*   Pages start from page 1.
*   Default value: 1', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.

*   Maximum value: 50.
*   Default value: 10', example='10'),
}

model ListJobsShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-csbua72***'),
  jobFilterShrink?: string(name='JobFilter', description='The job filter information.'),
  pageNumber?: string(name='PageNumber', description='The page number of the page to return.

*   Pages start from page 1.
*   Default value: 1', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.

*   Maximum value: 50.
*   Default value: 10', example='10'),
}

model ListJobsResponseBody = {
  jobs?: [ 
    {
      jobName?: string(name='JobName', description='The job name.', example='testjob'),
      jobSpec?: {
        arrayJobId?: string(name='ArrayJobId', description='The array job ID.', example='4'),
        arrayJobSubId?: string(name='ArrayJobSubId', description='The ID of the job in the array.', example='1'),
        arrayRequest?: string(name='ArrayRequest', description='The queue format of the job.

*   If the job is not in a queue, the output is empty.
*   The format is X-Y:Z. X indicates the first index, Y indicates the final index, and Z indicates the step size. For example, 2-7:2 indicates three sub-jobs numbered 2, 4, and 6.', example='1-5:2'),
        comment?: string(name='Comment', description='The job description.', example='jobDescription'),
        id?: string(name='Id', description='The job ID.', example='12'),
        jobQueue?: string(name='JobQueue', description='The queue name.', example='comp'),
        lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last updated.', example='1724123085'),
        nodeList?: string(name='NodeList', description='The compute nodes that were used to run the job.', example='compute[002,005,003]'),
        priority?: string(name='Priority', description='The job priority. Valid values: 0 to 9. A larger value indicates a higher priority.', example='0'),
        resources?: {
          cores?: string(name='Cores', description='The number of vCPUs that were used to run the job.', example='6'),
          gpus?: string(name='Gpus', description='The number of GPUs that were used to run the job.', example='0'),
          memory?: string(name='Memory', description='The size of memory that was used to run the job.', example='1536MB'),
          nodes?: string(name='Nodes', description='The number of compute nodes that were used to run the job.', example='3'),
        }(name='Resources', description='The information about the resources required to run the job.'),
        resourcesActualOccupied?: {
          cores?: string(name='Cores', description='Number of CPU cores.', example='4'),
          gpus?: string(name='Gpus', description='Number of CPUs', example='0'),
          memory?: string(name='Memory', description='Number of memory.', example='982MB'),
          nodes?: string(name='Nodes', description='Number of compute nodes.', example='2'),
        }(name='ResourcesActualOccupied', description='Actual resource usage of the job program'),
        runasUser?: string(name='RunasUser', description='The user that ran the job.', example='testuser1'),
        startTime?: string(name='StartTime', description='Job start time.', example='1724122486'),
        state?: string(name='State', description='The job state. Valid values: (PBS cluster and Slurm cluster)

*   FINISHED/Completed
*   RUNNING/Running
*   QUEUED/Pending
*   FAILED/Failed', example='Running'),
        stderrPath?: string(name='StderrPath', description='The error output path.', example='./Temp'),
        stdoutPath?: string(name='StdoutPath', description='The standard output path.', example='./Temp'),
        submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='1724122486'),
        variables?: string(name='Variables', description='The variables of the job.', example='{"PBS_O_SHELL":"/bin/bash", 	"PBS_O_HOST":"manager", 	"PBS_O_SYSTEM":"Linux", 	"PBS_O_LANG":"en_US.UTF-8", 	"PBS_O_QUEUE":"workq"}'),
      }(name='JobSpec', description='The job configurations.'),
    }
  ](name='Jobs', description='The jobs.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='EABFBD93-58BE-53F3-BBFE-8654BB2E****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='10'),
}

model ListJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobsResponseBody(name='body'),
}

/**
 * @summary Queries the jobs in a cluster.
 *
 * @param tmpReq ListJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobsResponse
 */
async function listJobsWithOptions(tmpReq: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(tmpReq);
  var request = new ListJobsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobFilter)) {
    request.jobFilterShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobFilter, 'JobFilter', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.jobFilterShrink)) {
    query['JobFilter'] = request.jobFilterShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the jobs in a cluster.
 *
 * @param request ListJobsRequest
 * @return ListJobsResponse
 */
async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  hostnames?: [ string ](name='Hostnames', description='The hostnames of the compute nodes that you want to query.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='The IP addresses of the compute nodes that you want to query.'),
  queueNames?: [ string ](name='QueueNames', description='The queues to which the nodes belong.'),
  sequence?: string(name='Sequence', description='Specifies whether the results are sorted in ascending or descending order. Valid values:

*   Forward: ascending
*   Backward: descending

Default value: Forward.', example='Forward'),
  sortBy?: string(name='SortBy', description='The sorting method of the node list. Valid values:

*   AddedTime: sorts the nodes by the time that they were added.
*   HostName: sorts the nodes by their hostnames.

Default value: addedtime.', example='AddedTime'),
  status?: [ string ](name='Status', description='The states of the compute nodes to be queried.'),
}

model ListNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  hostnamesShrink?: string(name='Hostnames', description='The hostnames of the compute nodes that you want to query.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  privateIpAddressShrink?: string(name='PrivateIpAddress', description='The IP addresses of the compute nodes that you want to query.'),
  queueNamesShrink?: string(name='QueueNames', description='The queues to which the nodes belong.'),
  sequence?: string(name='Sequence', description='Specifies whether the results are sorted in ascending or descending order. Valid values:

*   Forward: ascending
*   Backward: descending

Default value: Forward.', example='Forward'),
  sortBy?: string(name='SortBy', description='The sorting method of the node list. Valid values:

*   AddedTime: sorts the nodes by the time that they were added.
*   HostName: sorts the nodes by their hostnames.

Default value: addedtime.', example='AddedTime'),
  statusShrink?: string(name='Status', description='The states of the compute nodes to be queried.'),
}

model ListNodesResponseBody = {
  nodes?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was created.', example='2020-06-09T06:22:02.000Z'),
      deploymentSetId?: string(name='DeploymentSetId', description='The deployment set ID.', example='ds-8vbe4av4gededlqg****'),
      expiredTime?: string(name='ExpiredTime', description='The time when the node expires.', example='2020-06-09T06:22:02.000Z'),
      hostname?: string(name='Hostname', description='The hostname of the node.', example='edas.cn-shanghai.aliyuncs.com'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether hyper-threading is enabled.', example='true'),
      id?: string(name='Id', description='The instance ID of the node.', example='i-bp15707mys2rsy0j****'),
      imageId?: string(name='ImageId', description='The image ID of the node.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
      instanceType?: string(name='InstanceType', description='The instance type of the node.', example='ecs.c5.large'),
      ipAddress?: string(name='IpAddress', description='The VPC IP address of the node.', example='``172.16.**.**``'),
      keepAlive?: boolean(name='KeepAlive', description='Indicates whether deletion protection is enabled for the node. Valid values:

*   true
*   false', example='true'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='``172.16.**.**``'),
      queueName?: string(name='QueueName', description='The name of the queue to which the node belongs.', example='autoque3'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the node. Valid values:

*   NoSpot: The instances of the compute node are pay-as-you-go instances.
*   SpotWithPriceLimit: The instances are created as preemptible instances with a user-defined maximum hourly price.
*   SpotAsPriceGo: The node is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The node state in the scheduler.', example='active'),
      status?: string(name='Status', description='The node state. Valid values:

*   uninit: The node is being installed.
*   initing: The node is being initialized.
*   running: The node is running.
*   releasing: The node is being released.
*   stopped: The node is stopped.
*   exception: The node has run into an exception.
*   untracking: The node is not added to the cluster.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The amount of memory. Unit: GiB.', example='1024'),
      }(name='TotalResources', description='The hardware configurations of the node.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the node.', example='vsw-bp1e47optm9g58zcu****'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The zone ID of the node.', example='cn-hangzhou-b'),
    }
  ](name='Nodes', description='The information about the nodes.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodesResponseBody(name='body'),
}

/**
 * @summary Queries the nodes of an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq ListNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNodesResponse
 */
async function listNodesWithOptions(tmpReq: ListNodesRequest, runtime: Util.RuntimeOptions): ListNodesResponse {
  Util.validateModel(tmpReq);
  var request = new ListNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.hostnames)) {
    request.hostnamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostnames, 'Hostnames', 'json');
  }
  if (!Util.isUnset(tmpReq.privateIpAddress)) {
    request.privateIpAddressShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.privateIpAddress, 'PrivateIpAddress', 'json');
  }
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  if (!Util.isUnset(tmpReq.status)) {
    request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, 'Status', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hostnamesShrink)) {
    query['Hostnames'] = request.hostnamesShrink;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.privateIpAddressShrink)) {
    query['PrivateIpAddress'] = request.privateIpAddressShrink;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  if (!Util.isUnset(request.sequence)) {
    query['Sequence'] = request.sequence;
  }
  if (!Util.isUnset(request.sortBy)) {
    query['SortBy'] = request.sortBy;
  }
  if (!Util.isUnset(request.statusShrink)) {
    query['Status'] = request.statusShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNodes',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the nodes of an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request ListNodesRequest
 * @return ListNodesResponse
 */
async function listNodes(request: ListNodesRequest): ListNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNodesWithOptions(request, runtime);
}

model ListQueuesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queueNames?: [ string ](name='QueueNames', description='The names of the queues that you want to query. You can specify up to eight names.'),
}

model ListQueuesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  queueNamesShrink?: string(name='QueueNames', description='The names of the queues that you want to query. You can specify up to eight names.'),
}

model ListQueuesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  queues?: [ 
    {
      computeNodes?: [
        NodeTemplate
      ](name='ComputeNodes', description='The hardware configurations of the compute nodes that are added in auto scale-outs. Up to five nodes are displayed.'),
      createTime?: string(name='CreateTime', description='The time when the queue was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2023-11-10T02:04:00Z'),
      enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether auto scale-in is enabled for the queue. Valid values:

*   true
*   false', example='true'),
      enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether auto scale-out is enabled for the queue. Valid values:

*   true
*   false', example='true'),
      maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='100'),
      maxCountPerCycle?: int32(name='MaxCountPerCycle', description='The minimum number of compute nodes that are added to the queue in each auto scale-out.', example='1'),
      minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
      nodes?: {
        creatingCounts?: int32(name='CreatingCounts', description='The number of compute nodes that are not ready.', example='2'),
        exceptionCounts?: int32(name='ExceptionCounts', description='The number of malfunctioning compute nodes.', example='0'),
        runningCounts?: int32(name='RunningCounts', description='The number of running compute nodes.', example='1'),
      }(name='Nodes', description='The statistics about the compute nodes in the queue.'),
      queueName?: string(name='QueueName', description='The queue name.', example='comp'),
      totalCores?: int32(name='TotalCores', description='The total number of vCPUs that are used by all compute nodes in the queue.', example='24'),
      updateTime?: string(name='UpdateTime', description='The time when the queue was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-04-25T02:02:32'),
      vSwitchIds?: [ string ](name='VSwitchIds', description='The vSwitches that can be used for added nodes during auto scale-outs. Up to three vSwitches are displayed.'),
    }
  ](name='Queues', description='The information about the queues.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C6E5005C-00B0-4F27-98BB-95AB88016C22'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueuesResponseBody(name='body'),
}

/**
 * @summary Queries queues in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq ListQueuesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueuesResponse
 */
async function listQueuesWithOptions(tmpReq: ListQueuesRequest, runtime: Util.RuntimeOptions): ListQueuesResponse {
  Util.validateModel(tmpReq);
  var request = new ListQueuesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueues',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries queues in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request ListQueuesRequest
 * @return ListQueuesResponse
 */
async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueuesWithOptions(request, runtime);
}

model ListRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', example='zh-CN'),
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='caeba0bbb2be03f84eb48b699f0axxxx'),
  specCode?: string(name='SpecCode', example='Next'),
}

model ListRegionsResponseBody = {
  maxResults?: int32(name='MaxResults', example='20'),
  nextToken?: string(name='NextToken', example='caeba0bbb2be03f84eb48b699f0axxxx'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId', example='cn-hangzhou'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', example='16'),
}

model ListRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRegionsResponseBody(name='body'),
}

/**
 * @summary æŸ¥è¯¢äº§å“æ”¯æŒçš„åœ°åŸŸåˆ—è¡¨ã€‚
 *
 * @param request ListRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRegionsResponse
 */
async function listRegionsWithOptions(request: ListRegionsRequest, runtime: Util.RuntimeOptions): ListRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.specCode)) {
    query['SpecCode'] = request.specCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary æŸ¥è¯¢äº§å“æ”¯æŒçš„åœ°åŸŸåˆ—è¡¨ã€‚
 *
 * @param request ListRegionsRequest
 * @return ListRegionsResponse
 */
async function listRegions(request: ListRegionsRequest): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(request, runtime);
}

model ListSharedStoragesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the attached file system.', example='0bd504b0**'),
  fileSystemType?: string(name='FileSystemType', description='The type of the attached file system. Valid values:

*   nas
*   cpfs', example='nas'),
}

model ListSharedStoragesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
  sharedStorages?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the attached file system.', example='08c7f4b***'),
      fileSystemProtocol?: string(name='FileSystemProtocol', description='The protocol used by the attached file system. Valid values:

*   nfs3
*   nfs4
*   cpfs', example='nfs4'),
      fileSystemType?: string(name='FileSystemType', description='The type of the attached file system. Valid values:

*   nas
*   cpfs', example='nas'),
      mountInfo?: [ 
        {
          mountDirectory?: string(name='MountDirectory', description='The local mount directory of the attached file system.', example='/test'),
          mountOptions?: string(name='MountOptions', description='The mount options for the attached file system. Valid values:

*   \\\\-t nfs -o vers=3,nolock,proto=tcp,noresvport
*   \\\\-t nfs -o vers=4.0,noresvport', example='-t nfs -o vers=4.0,noresvport'),
          mountTarget?: string(name='MountTarget', description='The mount target of the attached file system.', example='0bd504b***-ngq26.cn-hangzhou.nas.aliyuncs.com'),
          protocolType?: string(name='ProtocolType', description='The protocol used by the mount target of the attached file system. Valid values:

*   nfs3
*   nfs4
*   cpfs', example='nfs3'),
          storageDirectory?: string(name='StorageDirectory', description='The storage directory of the attached file system.', example='/testehpc'),
        }
      ](name='MountInfo', description='The mount information.'),
    }
  ](name='SharedStorages', description='The information about the attached shared storage.'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model ListSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSharedStoragesResponseBody(name='body'),
}

/**
 * @summary Queries the shared storage that is attached to a cluster.
 *
 * @param request ListSharedStoragesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSharedStoragesResponse
 */
async function listSharedStoragesWithOptions(request: ListSharedStoragesRequest, runtime: Util.RuntimeOptions): ListSharedStoragesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSharedStorages',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the shared storage that is attached to a cluster.
 *
 * @param request ListSharedStoragesRequest
 * @return ListSharedStoragesResponse
 */
async function listSharedStorages(request: ListSharedStoragesRequest): ListSharedStoragesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSharedStoragesWithOptions(request, runtime);
}

model ListSoftwaresRequest {
  category?: string(name='Category', description='The application category.', example='NWP'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  name?: string(name='Name', description='The software name.', example='gromacs'),
  osInfos?: [ 
    {
      architecture?: string(name='Architecture', description='The OS architecture. Valid values:

*   x86_64
*   arm64', example='x86_64'),
      osTag?: string(name='OsTag', description='The image tag.', example='CentOS_7.9_64'),
    }
  ](name='OsInfos', description='The operating system (OS) information.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
}

model ListSoftwaresResponseBody = {
  additionalPackages?: {
    additionalPackageInfos?: [ 
    {
      category?: string(name='Category', description='The application category.', example='NWP'),
      description?: string(name='Description', description='The software description.'),
      icon?: string(name='Icon', description='The URL of the software icon.', example='https://gw.alicdn.com/imgextra/i2/O1CN01FIkxZ81LmE0fvrAyR_!!6000000001341-55-tps-6349-1603.svg'),
      name?: string(name='Name', description='The software name.', example='gromacs'),
      versions?: {
        versionInfos?: [ 
        {
          latest?: string(name='Latest', description='Indicates whether the version is the latest.', example='false'),
          supportOs?: {
            supportOsInfos?: [ 
            {
              architecture?: string(name='Architecture', description='The OS architecture. Valid values:

*   x86_64
*   arm64', example='x86_64'),
              osTag?: string(name='OsTag', description='The image tag.', example='Alibaba Cloud Linux  3.2104 LTS 64 bit ARM Edition'),
            }
          ](name='SupportOsInfos')
          }(name='SupportOs', description='The information about the supported OSs.'),
          version?: string(name='Version', description='The software version.', example='2024.1'),
        }
      ](name='VersionInfos')
      }(name='Versions', description='The information about the software versions that can be installed in the cluster.'),
    }
  ](name='AdditionalPackageInfos')
  }(name='AdditionalPackages', description='The information about the software that can be installed in the cluster.'),
  pageNumber?: string(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSoftwaresResponseBody(name='body'),
}

/**
 * @summary Queries the software that can be installed in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request ListSoftwaresRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListSoftwaresResponse
 */
async function listSoftwaresWithOptions(request: ListSoftwaresRequest, runtime: Util.RuntimeOptions): ListSoftwaresResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSoftwares',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the software that can be installed in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request ListSoftwaresRequest
 * @return ListSoftwaresResponse
 */
async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSoftwaresWithOptions(request, runtime);
}

model ListUsersRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1.

Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50.

Default value: 10.', example='10'),
}

model ListUsersResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='15'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the user was first added.', example='2014-08-22T17:46:47'),
      group?: string(name='Group', description='The name of the permission group. Valid values:

users: ordinary permissions, which are suitable for regular users that need only to submit and debug jobs.

wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes.', example='users'),
      groupId?: string(name='GroupId', description='The permission group ID.', example='100'),
      userId?: string(name='UserId', description='The user ID.', example='1001'),
      userName?: string(name='UserName', description='The username.', example='testuser'),
    }
  ](name='UserInfo')
  }(name='Users', description='The information about the users.'),
}

model ListUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUsersResponseBody(name='body'),
}

/**
 * @summary Queries the users of a cluster.
 *
 * @param request ListUsersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListUsersResponse
 */
async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the users of a cluster.
 *
 * @param request ListUsersRequest
 * @return ListUsersResponse
 */
async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model StopJobsRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  jobIds?: [ string ](name='JobIds', description='The IDs of the jobs that you want to stop.'),
}

model StopJobsShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  jobIdsShrink?: string(name='JobIds', description='The IDs of the jobs that you want to stop.'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8868A00-6757-5542-BDD6-E1040D94****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model StopJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopJobsResponseBody(name='body'),
}

/**
 * @summary Stops uncompleted jobs in a batch in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq StopJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopJobsResponse
 */
async function stopJobsWithOptions(tmpReq: StopJobsRequest, runtime: Util.RuntimeOptions): StopJobsResponse {
  Util.validateModel(tmpReq);
  var request = new StopJobsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.jobIds)) {
    request.jobIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobIds, 'JobIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.jobIdsShrink)) {
    query['JobIds'] = request.jobIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopJobs',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops uncompleted jobs in a batch in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request StopJobsRequest
 * @return StopJobsResponse
 */
async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopJobsWithOptions(request, runtime);
}

model UnInstallAddonRequest {
  addonId?: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W2g****'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
}

model UnInstallAddonResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model UnInstallAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnInstallAddonResponseBody(name='body'),
}

/**
 * @summary Uninstalls an addon.
 *
 * @description ## [](#)Usage notes
 * Take note of the following items when you call this operation:
 * *   The cluster must be in the `Running` state.
 * *   Clusters fall into the following types:
 *     *   Regular clusters on Alibaba Cloud Public Cloud
 *     *   Managed clusters on Alibaba Cloud Public Cloud
 *
 * @param request UnInstallAddonRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnInstallAddonResponse
 */
async function unInstallAddonWithOptions(request: UnInstallAddonRequest, runtime: Util.RuntimeOptions): UnInstallAddonResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addonId)) {
    query['AddonId'] = request.addonId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnInstallAddon',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Uninstalls an addon.
 *
 * @description ## [](#)Usage notes
 * Take note of the following items when you call this operation:
 * *   The cluster must be in the `Running` state.
 * *   Clusters fall into the following types:
 *     *   Regular clusters on Alibaba Cloud Public Cloud
 *     *   Managed clusters on Alibaba Cloud Public Cloud
 *
 * @param request UnInstallAddonRequest
 * @return UnInstallAddonResponse
 */
async function unInstallAddon(request: UnInstallAddonRequest): UnInstallAddonResponse {
  var runtime = new Util.RuntimeOptions{};
  return unInstallAddonWithOptions(request, runtime);
}

model UninstallSoftwaresRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The software name.', example='gromacs'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackages', description='The information about the software systems that you want to uninstall.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
}

model UninstallSoftwaresShrinkRequest {
  additionalPackagesShrink?: string(name='AdditionalPackages', description='The information about the software systems that you want to uninstall.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
}

model UninstallSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UninstallSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallSoftwaresResponseBody(name='body'),
}

/**
 * @summary Uninstalls software systems from an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## Interface Description
 * When calling this interface, please note:
 * The cluster status must be `Running`.
 *
 * @param tmpReq UninstallSoftwaresRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UninstallSoftwaresResponse
 */
async function uninstallSoftwaresWithOptions(tmpReq: UninstallSoftwaresRequest, runtime: Util.RuntimeOptions): UninstallSoftwaresResponse {
  Util.validateModel(tmpReq);
  var request = new UninstallSoftwaresShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.additionalPackages)) {
    request.additionalPackagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.additionalPackages, 'AdditionalPackages', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallSoftwares',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Uninstalls software systems from an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## Interface Description
 * When calling this interface, please note:
 * The cluster status must be `Running`.
 *
 * @param request UninstallSoftwaresRequest
 * @return UninstallSoftwaresResponse
 */
async function uninstallSoftwares(request: UninstallSoftwaresRequest): UninstallSoftwaresResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallSoftwaresWithOptions(request, runtime);
}

model UpdateClusterRequest {
  clientVersion?: string(name='ClientVersion', description='Specifies whether to enable auto scale-out for the cluster. Valid values:

*   true
*   false', example='2.1.0'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='Specifies whether to enable the monitoring component of compute nodes. Valid values:

*   true
*   false', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The monitoring details of the cluster.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='Specifies whether to enable auto scale-in for the cluster. Valid values:

*   true
*   false'),
  clusterDescription?: string(name='ClusterDescription', description='The URL that is used to download the post-processing script.', example='slurm22.05.8-serverless-cluster-20240805'),
  clusterId?: string(name='ClusterId', description='The client version. By default, the latest version is used.', example='ehpc-hz-FYUr32****'),
  clusterName?: string(name='ClusterName', description='The post-processing script of the cluster.', example='slurm22.05.8-serverless-cluster-20240805'),
  deletionProtection?: boolean(name='DeletionProtection', description='The idle duration of the compute nodes allowed by the cluster.', example='false'),
  enableScaleIn?: boolean(name='EnableScaleIn', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', description='The response parameters.', example='true'),
  growInterval?: int32(name='GrowInterval', description='The scheduler specifications of the cluster.', example='2'),
  idleInterval?: int32(name='IdleInterval', description='Specifies whether to enable the topology awareness feature. Valid values:

*   true
*   false', example='4'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The interval at which the cluster is automatically scaled out.', example='10000'),
  maxCount?: int32(name='MaxCount', description='The arguments that are used to run the post-processing script.', example='500'),
  monitorSpec?: {
    enableComputeLoadMonitor?: boolean(name='EnableComputeLoadMonitor', description='Specifies whether to enable the monitoring component of compute nodes. Valid values:

*   true
*   false', example='true'),
  }(name='MonitorSpec', description='The monitoring details of the cluster.'),
  schedulerSpec?: {
    enableTopologyAwareness?: boolean(name='EnableTopologyAwareness', description='Specifies whether to enable the topology awareness feature. Valid values:

*   true
*   false', example='true'),
  }(name='SchedulerSpec', description='The scheduler specifications of the cluster.'),
}

model UpdateClusterShrinkRequest {
  clientVersion?: string(name='ClientVersion', description='Specifies whether to enable auto scale-out for the cluster. Valid values:

*   true
*   false', example='2.1.0'),
  clusterCustomConfigurationShrink?: string(name='ClusterCustomConfiguration', description='Specifies whether to enable auto scale-in for the cluster. Valid values:

*   true
*   false'),
  clusterDescription?: string(name='ClusterDescription', description='The URL that is used to download the post-processing script.', example='slurm22.05.8-serverless-cluster-20240805'),
  clusterId?: string(name='ClusterId', description='The client version. By default, the latest version is used.', example='ehpc-hz-FYUr32****'),
  clusterName?: string(name='ClusterName', description='The post-processing script of the cluster.', example='slurm22.05.8-serverless-cluster-20240805'),
  deletionProtection?: boolean(name='DeletionProtection', description='The idle duration of the compute nodes allowed by the cluster.', example='false'),
  enableScaleIn?: boolean(name='EnableScaleIn', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', description='The response parameters.', example='true'),
  growInterval?: int32(name='GrowInterval', description='The scheduler specifications of the cluster.', example='2'),
  idleInterval?: int32(name='IdleInterval', description='Specifies whether to enable the topology awareness feature. Valid values:

*   true
*   false', example='4'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The interval at which the cluster is automatically scaled out.', example='10000'),
  maxCount?: int32(name='MaxCount', description='The arguments that are used to run the post-processing script.', example='500'),
  monitorSpecShrink?: string(name='MonitorSpec', description='The monitoring details of the cluster.'),
  schedulerSpecShrink?: string(name='SchedulerSpec', description='The scheduler specifications of the cluster.'),
}

model UpdateClusterResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='Request result, possible values: 
- true: request succeeded 
- false: request failed', example='true'),
}

model UpdateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClusterResponseBody(name='body'),
}

/**
 * @summary Modify the basic information of a specified cluster.
 *
 * @param tmpReq UpdateClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateClusterResponse
 */
async function updateClusterWithOptions(tmpReq: UpdateClusterRequest, runtime: Util.RuntimeOptions): UpdateClusterResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateClusterShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clusterCustomConfiguration)) {
    request.clusterCustomConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clusterCustomConfiguration, 'ClusterCustomConfiguration', 'json');
  }
  if (!Util.isUnset(tmpReq.monitorSpec)) {
    request.monitorSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.monitorSpec, 'MonitorSpec', 'json');
  }
  if (!Util.isUnset(tmpReq.schedulerSpec)) {
    request.schedulerSpecShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.schedulerSpec, 'SchedulerSpec', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientVersion)) {
    query['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.clusterCustomConfigurationShrink)) {
    query['ClusterCustomConfiguration'] = request.clusterCustomConfigurationShrink;
  }
  if (!Util.isUnset(request.clusterDescription)) {
    query['ClusterDescription'] = request.clusterDescription;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.enableScaleIn)) {
    query['EnableScaleIn'] = request.enableScaleIn;
  }
  if (!Util.isUnset(request.enableScaleOut)) {
    query['EnableScaleOut'] = request.enableScaleOut;
  }
  if (!Util.isUnset(request.growInterval)) {
    query['GrowInterval'] = request.growInterval;
  }
  if (!Util.isUnset(request.idleInterval)) {
    query['IdleInterval'] = request.idleInterval;
  }
  if (!Util.isUnset(request.maxCoreCount)) {
    query['MaxCoreCount'] = request.maxCoreCount;
  }
  if (!Util.isUnset(request.maxCount)) {
    query['MaxCount'] = request.maxCount;
  }
  if (!Util.isUnset(request.monitorSpecShrink)) {
    query['MonitorSpec'] = request.monitorSpecShrink;
  }
  if (!Util.isUnset(request.schedulerSpecShrink)) {
    query['SchedulerSpec'] = request.schedulerSpecShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCluster',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modify the basic information of a specified cluster.
 *
 * @param request UpdateClusterRequest
 * @return UpdateClusterResponse
 */
async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClusterWithOptions(request, runtime);
}

model UpdateNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  instances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the compute node.', example='i-bp1bzqq1ddeemuddn****'),
      keepAlive?: boolean(name='KeepAlive', description='Specifies whether to enable deletion protection for the compute node.', example='true'),
    }
  ](name='Instances', description='The information about the compute nodes that you want to update.'),
}

model UpdateNodesShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  instancesShrink?: string(name='Instances', description='The information about the compute nodes that you want to update.'),
}

model UpdateNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodesResponseBody(name='body'),
}

/**
 * @summary Updates the configurations of compute nodes in an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
 *
 * @param tmpReq UpdateNodesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNodesResponse
 */
async function updateNodesWithOptions(tmpReq: UpdateNodesRequest, runtime: Util.RuntimeOptions): UpdateNodesResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateNodesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instances)) {
    request.instancesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instances, 'Instances', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.instancesShrink)) {
    query['Instances'] = request.instancesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateNodes',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configurations of compute nodes in an Enterprise High Performance Computing (E-HPC) cluster.
 *
 * @description ## [](#)Usage notes
 * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
 *
 * @param request UpdateNodesRequest
 * @return UpdateNodesResponse
 */
async function updateNodes(request: UpdateNodesRequest): UpdateNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateNodesWithOptions(request, runtime);
}

model UpdateQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  queue?: {
    allocationStrategy?: string(name='AllocationStrategy', description='The policy based on which instance types are selected for compute nodes during auto scale-outs. Valid values:

*   PriorityInstanceType', example='PriorityInstanceType'),
    computeNodes?: [
      NodeTemplate
    ](name='ComputeNodes', description='The hardware configurations of the compute nodes in the queue. Valid values of N: 1 to 10.'),
    enableScaleIn?: boolean(name='EnableScaleIn', description='Specifies whether to enable auto scale-in for the queue. Valid values:

*   true
*   false', example='true'),
    enableScaleOut?: boolean(name='EnableScaleOut', description='Specifies whether to enable auto scale-out for the queue. Valid values:

*   true
*   false', example='true'),
    hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the added compute nodes.', example='compute'),
    hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the compute nodes in the queue.', example='hpc'),
    initialCount?: int32(name='InitialCount', description='The initial number of compute nodes in the queue.', example='0'),
    interConnect?: string(name='InterConnect', description='The type of the network for interconnecting compute nodes in the queue.', example='erdma'),
    keepAliveNodes?: [ string ](name='KeepAliveNodes', description='List of excluded compute nodes in the queue.'),
    maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='1000'),
    maxCountPerCycle?: long(name='MaxCountPerCycle', description='The minimum number of compute nodes that are added to the queue during an automatic scale-out.', example='99'),
    minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
    queueName?: string(name='QueueName', description='The queue name.

This parameter is required.', example='comp'),
    ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role that is assumed by compute nodes in the queue.', example='AliyunECSInstanceForEHPCRole'),
    reservedNodePoolId?: string(name='ReservedNodePoolId'),
    vSwitchIds?: [ string ](name='VSwitchIds', description='The vSwitches available for use by compute nodes in the queue.'),
  }(name='Queue', description='The information about the queue to be updated.'),
}

model UpdateQueueShrinkRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  queueShrink?: string(name='Queue', description='The information about the queue to be updated.'),
}

model UpdateQueueResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateQueueResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of a queue in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param tmpReq UpdateQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateQueueResponse
 */
async function updateQueueWithOptions(tmpReq: UpdateQueueRequest, runtime: Util.RuntimeOptions): UpdateQueueResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queue)) {
    request.queueShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queue, 'Queue', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.queueShrink)) {
    query['Queue'] = request.queueShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQueue',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of a queue in an Elastic High Performance Computing (E-HPC) cluster.
 *
 * @param request UpdateQueueRequest
 * @return UpdateQueueResponse
 */
async function updateQueue(request: UpdateQueueRequest): UpdateQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQueueWithOptions(request, runtime);
}

model UpdateUserRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****'),
  group?: string(name='Group', description='The user group attribute of the user that you want to update. Valid values:

*   users: ordinary permissions, which are suitable for ordinary users that need only to submit and debug jobs.
*   wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes.', example='users'),
  password?: string(name='Password', description='The password attribute of the user that you want to update. The password must be 6 to 30 characters in length and must contain three of the following four character types:

*   Uppercase letters
*   Lowercase letters
*   Digits
*   Special characters ()~!@#$%^&\\\\*-_+=|{}[]:;\\\\"/<>,.?/', example='123****'),
  userName?: string(name='UserName', description='The username.

This parameter is required.', example='testuser'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: string(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserResponseBody(name='body'),
}

/**
 * @summary Updates the information of a user in an Elastic High Performance Computing (E-HPC) cluster, including the user group and password.
 *
 * @param request UpdateUserRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateUserResponse
 */
async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.group)) {
    query['Group'] = request.group;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2024-07-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information of a user in an Elastic High Performance Computing (E-HPC) cluster, including the user group and password.
 *
 * @param request UpdateUserRequest
 * @return UpdateUserResponse
 */
async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

