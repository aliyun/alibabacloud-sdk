/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'EHPC';
  @version = '2024-07-30';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddonNodeTemplate {
  autoRenew?: boolean(name='AutoRenew', example='false'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', example='1'),
  dataDisks?: [ 
    {
      category?: string(name='Category', example='cloud_auto'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', example='false'),
      level?: string(name='Level', example='PL0'),
      size?: int32(name='Size', example='40'),
    }
  ](name='DataDisks'),
  duration?: int32(name='Duration', example='1'),
  enableHT?: boolean(name='EnableHT', example='true'),
  imageId: string(name='ImageId', description='This parameter is required.', example='aliyun_3_x64_20G_alibase_20221102.vhd'),
  instanceChargeType?: string(name='InstanceChargeType', example='PostPaid'),
  instanceId?: string(name='InstanceId'),
  instanceType: string(name='InstanceType', description='This parameter is required.', example='ecs.c7.4xlarge'),
  osName: string(name='OsName', description='This parameter is required.', example='CentOS  7.6 64 位'),
  osNameEN: string(name='OsNameEN', description='This parameter is required.', example='CentOS  7.6 64 bit'),
  period?: int32(name='Period', example='1'),
  periodUnit?: string(name='PeriodUnit', example='Month'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.97'),
  spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
  systemDisk?: {
    category?: string(name='Category', example='cloud_auto'),
    level?: string(name='Level', example='PL0'),
    size?: int32(name='Size', example='40'),
  }(name='SystemDisk'),
}

model NodeTemplate {
  autoRenew?: boolean(name='AutoRenew', example='false'),
  autoRenewPeriod?: int32(name='AutoRenewPeriod', example='1'),
  dataDisks?: [ 
    {
      category?: string(name='Category', example='cloud_auto'),
      deleteWithInstance?: boolean(name='DeleteWithInstance', example='false'),
      level?: string(name='Level', example='PL0'),
      mountDir?: string(name='MountDir', example='/data1'),
      size?: int32(name='Size', example='40'),
    }
  ](name='DataDisks'),
  duration?: int32(name='Duration', example='1'),
  enableHT?: boolean(name='EnableHT', example='true'),
  imageId?: string(name='ImageId', example='aliyun_3_x64_20G_alibase_20221102.vhd'),
  instanceChargeType?: string(name='InstanceChargeType', example='PostPaid'),
  instanceType?: string(name='InstanceType', example='ecs.c7.4xlarge'),
  period?: int32(name='Period', example='1'),
  periodUnit?: string(name='PeriodUnit', example='Month'),
  spotPriceLimit?: float(name='SpotPriceLimit', example='0.97'),
  spotStrategy?: string(name='SpotStrategy', example='NoSpot'),
  systemDisk?: {
    category?: string(name='Category', example='cloud_auto'),
    level?: string(name='Level', example='PL0'),
    size?: int32(name='Size', example='40'),
  }(name='SystemDisk'),
}

model QueueTemplate {
  allocationStrategy?: string(name='AllocationStrategy', example='PriorityInstanceType'),
  computeNodes?: [
    NodeTemplate
  ](name='ComputeNodes'),
  enableScaleIn?: boolean(name='EnableScaleIn', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', example='true'),
  hostnamePrefix?: string(name='HostnamePrefix', example='compute'),
  hostnameSuffix?: string(name='HostnameSuffix'),
  initialCount?: int32(name='InitialCount', example='0'),
  interConnect?: string(name='InterConnect', example='erdma'),
  keepAliveNodes?: [ string ](name='KeepAliveNodes'),
  maxCount?: int32(name='MaxCount', example='1000'),
  maxCountPerCycle?: long(name='MaxCountPerCycle', example='99'),
  minCount?: int32(name='MinCount', example='0'),
  queueName: string(name='QueueName', description='This parameter is required.', example='comp'),
  ramRole?: string(name='RamRole', example='AliyunECSInstanceForEHPCRole'),
  vSwitchIds?: [ string ](name='VSwitchIds'),
}

model SharedStorageTemplate {
  fileSystemId?: string(name='FileSystemId', example='008b63****'),
  mountDirectory?: string(name='MountDirectory', example='/home'),
  mountOptions?: string(name='MountOptions', example='-t nfs -o vers=3,nolock,noresvport'),
  mountTargetDomain?: string(name='MountTargetDomain', example='008b****-sihc.cn-hangzhou.extreme.nas.aliyuncs.com'),
  NASDirectory?: string(name='NASDirectory', example='/'),
  protocolType?: string(name='ProtocolType', example='NFS'),
}

model AttachSharedStoragesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  sharedStorages: [ 
    {
      fileSystemId: string(name='FileSystemId', description='The ID of the file system to be attached.

This parameter is required.', example='0bd504b0**'),
      location?: string(name='Location', description='The storage location of the file system to be attached. Valid values:

*   OnPremise: The file system is deployed on a hybrid cloud.
*   PublicCloud: The file system is deployed on a public cloud.', example='PublicCloud'),
      mountDirectory: string(name='MountDirectory', description='The local mount directory of the file system that you want to attach.

This parameter is required.', example='/test'),
      mountOptions?: string(name='MountOptions', description='The attaching options of the file system to be attached. Valid values:

*   \\-t nfs -o vers=3,nolock,proto=tcp,noresvport
*   \\-t nfs -o vers=4.0,noresvport

Default value:-t nfs -o vers=3,nolock,proto=tcp,noresvport

>  The v3 version is recommended for higher performance if multiple Elastic Compute Service (ECS) instances do not edit the same file at the same time.', example='-t nfs -o vers=3,nolock,proto=tcp,noresvport'),
      mountTarget: string(name='MountTarget', description='The address of the mount point of the file system to be attached.

This parameter is required.', example='0bd504b***-ngq26.cn-hangzhou.nas.aliyuncs.com'),
      protocolType: string(name='ProtocolType', description='The protocol type of the file system to be attached. Valid values:

*   NFS
*   SMB

This parameter is required.', example='NFS'),
      storageDirectory: string(name='StorageDirectory', description='The storage directory of the file system. You can mount any directory in the file system to the specified cluster directory.

This parameter is required.', example='/testehpc'),
      volumeType: string(name='VolumeType', description='The type of the file system to be attached. Valid values:

*   nas
*   cpfs

This parameter is required.', example='nas'),
    }
  ](name='SharedStorages', description='The information about the shared storage resources that you want to attach to the cluster.

This parameter is required.', shrink='json', position='Query'),
}

model AttachSharedStoragesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='F9B7BEF8-E42E-5090-9880-55FB7872****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model AttachSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachSharedStoragesResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * When you call this operation, take note of the following items:
  * *   The file system that you want to attach must be created in advance in the same virtual private cloud (VPC) as the destination cluster. For more information, see [Create a file system](https://help.aliyun.com/document_detail/27530.html) and [Manage mount targets](https://help.aliyun.com/document_detail/27531.html).
  * *   E-HPC clusters support Apsara File Storage NAS file systems.
  * @param request  the request parameters of AttachSharedStorages  AttachSharedStoragesRequest
  * @return AttachSharedStoragesResponse
 */
async function attachSharedStorages(request: AttachSharedStoragesRequest): AttachSharedStoragesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachSharedStorages', 'POST', '/', 'json', false, 'json', request);
}

model CreateClusterRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The name of the software that you want to install in the cluster.', example='mpich'),
      version?: string(name='Version', description='The version of the software that you want to install in the cluster.', example='4.0.3'),
    }
  ](name='AdditionalPackages', description='The list of software that you want to install in the cluster. Valid values of N: 0 to 10.', shrink='json', position='Query'),
  addons?: [ 
    {
      name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      resourcesSpec?: string(name='ResourcesSpec', description='The resource configurations of the addon.', example='"{\\\\"EipResource\\\\": {\\\\"AutoCreate\\\\": true}, \\\\"EcsResources\\\\": [{\\\\"InstanceType\\\\": \\\\"ecs.c7.xlarge\\\\", \\\\"ImageId\\\\": \\\\"centos_7_6_x64_20G_alibase_20211130.vhd\\\\", \\\\"SystemDisk\\\\": {\\\\"Category\\\\": \\\\"cloud_essd\\\\", \\\\"Size\\\\": 40, \\\\"Level\\\\": \\\\"PL0\\\\"}, \\\\"EnableHT\\\\": true, \\\\"InstanceChargeType\\\\": \\\\"PostPaid\\\\", \\\\"SpotStrategy\\\\": \\\\"NoSpot\\\\"}]}"'),
      servicesSpec?: string(name='ServicesSpec', description='The service configurations of the addon.', example='"[{\\\\"ServiceName\\\\": \\\\"SSH\\\\", \\\\"ServiceAccessType\\\\": null, \\\\"ServiceAccessUrl\\\\": null, \\\\"NetworkACL\\\\": [{\\\\"IpProtocol\\\\": \\\\"TCP\\\\", \\\\"Port\\\\": 22, \\\\"SourceCidrIp\\\\": \\\\"0.0.0.0/0\\\\"}]}, {\\\\"ServiceName\\\\": \\\\"VNC\\\\", \\\\"ServiceAccessType\\\\": null, \\\\"ServiceAccessUrl\\\\": null, \\\\"NetworkACL\\\\": [{\\\\"IpProtocol\\\\": \\\\"TCP\\\\", \\\\"Port\\\\": 12016, \\\\"SourceCidrIp\\\\": \\\\"0.0.0.0/0\\\\"}]}, {\\\\"ServiceName\\\\": \\\\"CLIENT\\\\", \\\\"ServiceAccessType\\\\": \\\\"URL\\\\", \\\\"ServiceAccessUrl\\\\": \\\\"\\\\", \\\\"NetworkACL\\\\": [{\\\\"IpProtocol\\\\": \\\\"TCP\\\\", \\\\"Port\\\\": 12011, \\\\"SourceCidrIp\\\\": \\\\"0.0.0.0/0\\\\"}]}]"'),
      version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The configurations of the custom addons in the cluster. Only one addon is supported.', shrink='json', position='Query'),
  clientVersion?: string(name='ClientVersion', description='The client version. By default, the latest version is used.', example='2.1.0', position='Query'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard', position='Query'),
  clusterCredentials?: {
    keyPairName?: string(name='KeyPairName', description='The name of the key pair. The name must be 2 to 128 characters in length. The name must start with a letter but cannot start with `http://` or `https://`. The name can contain digits, letters, colons (:), underscores (_), and hyphens (-).

>  For more information, see [Create a key pair](https://help.aliyun.com/document_detail/51793.html).', example='ali0824'),
    password?: string(name='Password', description='The password for the root user to log on to the node. The password must be 8 to 20 characters in length, and must contain at least 3 of the following character types: uppercase letters, lowercase letters, digits, and special characters. The following special characters are supported: `() ~ ! @ # $ % ^ & * - = + { } [ ] : ; \\" < > , . ? /`

>  We recommend that you use HTTPS to call the API operation to prevent password leakage.', example='**********'),
  }(name='ClusterCredentials', description='The access credentials of the cluster.', shrink='json', position='Query'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='The runtime parameters of the script after the cluster is created.', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The URL that is used to download the post-processing script.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.', shrink='json', position='Query'),
  clusterDescription?: string(name='ClusterDescription', description='The cluster description. The description must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718', position='Query'),
  clusterMode?: string(name='ClusterMode', description='The deployment mode of the cluster. Valid values:

*   Integrated
*   Hybrid
*   Custom', example='Integrated', position='Query'),
  clusterName?: string(name='ClusterName', description='The cluster name. The name must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-cluster-20240718', position='Query'),
  clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch that you want the cluster to use. The vSwitch must reside in the VPC that is specified by the `ClusterVpcId` parameter.

You can call the [DescribeVpcs](https://help.aliyun.com/document_detail/448581.html) operation to query information about the created VPCs and vSwitches.', example='vsw-f8za5p0mwzgdu3wgx****', position='Query'),
  clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) in which the cluster resides.', example='vpc-m5efjevmclc0xdmys****', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection for the cluster. Deletion protection decides whether the cluster can be deleted in the console or by calling the [DeleteCluster](https://help.aliyun.com/document_detail/424406.html) operation. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  isEnterpriseSecurityGroup?: boolean(name='IsEnterpriseSecurityGroup', description='Specifies whether to use an advanced security group. Valid values:

*   true: automatically creates and uses an advanced security group.
*   false: automatically creates and uses a basic security group.

For more information, see [Basic security groups and advanced security groups](https://help.aliyun.com/document_detail/605897.html).', example='false', position='Query'),
  manager?: {
    DNS?: {
      type?: string(name='Type', description='The domain name resolution type.

Valid values:

*   NIS: NIS.', example='NIS'),
      version?: string(name='Version', description='The version of the domain name resolution service.', example='2.31'),
    }(name='DNS', description='The configurations of the domain name resolution service.'),
    directoryService?: {
      type?: string(name='Type', description='The type of the domain account.

Valid values:

*   NIS: NIS.', example='NIS'),
      version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
    }(name='DirectoryService', description='The configurations of the directory service.'),
    managerNode?: NodeTemplate(name='ManagerNode', description='The hardware configurations of the management node.'),
    scheduler?: {
      type?: string(name='Type', description='The scheduler type. Valid values:

*   SLURM
*   PBS
*   OPENGRIDSCHEDULER
*   LSF_PLUGIN
*   PBS_PLUGIN', example='SLURM'),
      version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
    }(name='Scheduler', description='The configurations of the scheduler service.'),
  }(name='Manager', description='The configurations of the cluster management node.', shrink='json', position='Query'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The maximum number of vCPUs that can be used by compute nodes in the cluster. Valid values: 0 to 100,000.', example='10000', position='Query'),
  maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage. Valid values: 0 to 5,000.', example='500', position='Query'),
  queues?: [
    QueueTemplate
  ](name='Queues', description='The configurations of the queues in the cluster. The number of queues can be 0 to 8.', shrink='json', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.

You can call the [ListResourceGroups](https://help.aliyun.com/document_detail/158855.html) operation to obtain the IDs of the resource groups.', example='rg-acfmxazb4******', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the cluster belongs.

You can call the [DescribeSecurityGroups](https://help.aliyun.com/document_detail/25556.html) operation to query available security groups in the current region.', example='sg-bp13n61xsydodfyg****', position='Query'),
  sharedStorages?: [
    SharedStorageTemplate
  ](name='SharedStorages', description='The configurations of shared storage in the cluster.', shrink='json', position='Query'),
  tags?: [ 
    {
      key?: string(name='Key', description='The tag key. Valid values of N: 1 to 20. The tag key cannot be an empty string. The tag key can be up to 128 characters in length and cannot start with `acs:` or `aliyun`. The tag key cannot contain `http://` or `https://`.', example='ClusterId'),
      value?: string(name='Value', description='The tag value. Valid values of N: 1 to 20. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`.', example='ehpc-hz-******'),
    }
  ](name='Tags', description='The tags of the cluster.', shrink='json', position='Query'),
}

model CreateClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr******'),
  requestId?: string(name='RequestId', description='The request ID.', example='F6757FA4-8FED-4602-B7F5-3550C0******'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='F6757FA4-8FED-4602-B7F5-3550C0******'),
}

model CreateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateClusterResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Before you call this operation, make sure that you are familiar with the billing and pricing of E-HPC. For more information, see [Overview](https://help.aliyun.com/document_detail/2842985.html).
  * @param request  the request parameters of CreateCluster  CreateClusterRequest
  * @return CreateClusterResponse
 */
async function createCluster(request: CreateClusterRequest): CreateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCluster', 'POST', '/', 'json', false, 'json', request);
}

model CreateJobRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  jobName?: string(name='JobName', description='The job name.', example='TestJob', position='Query'),
  jobSpec?: {
    arrayRequest?: string(name='ArrayRequest', description='The jobs in the queue.

Format: X-Y:Z. X is the minimum index value. Y is the maximum index value. Z is the step size. For example, 2-7:2 indicates that three jobs need to be run and their index values are 2, 4, and 6.', example='1-5:2'),
    commandLine: string(name='CommandLine', description='The command or script that is used to run the job. If you want to use a command, you must specify the full path of the command, for example, /bin/ping.

If you want to use a script, you must make sure that you have the execution permissions on it. By default, the user root directory ~/ is used as the default script path on the cluster side. If your script is not in that directory, you must specify the full path in this parameter, such as /home/xxx/job.sh Note that in this mode, if requirements on resources such as CPU and memory are specified in the script, the job will be run based on the resource requirements specified in the script. In this case, do not specify resource requirements in the Resource parameter. Otherwise, the job may fail to run.

If you want to run the job directly by using the CLI, you must specify the absolute path of the command and add two hyphens and a space (-- ) before the path, such as -- /bin/ping -c 10 localhost.

This parameter is required.', example='/home/xxx/test.job'),
    jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='comp'),
    postCmdLine?: string(name='PostCmdLine', description='The post-processing command of the job.', example='/bin/sleep 10'),
    priority?: string(name='Priority', description='The job priority.', example='1'),
    resources?: {
      cores?: int32(name='Cores', description='The number of vCPUs to be allocated to each compute node.', example='2'),
      gpus?: int32(name='Gpus', description='The number of GPUs to be allocated to each compute node.', example='1'),
      memory?: string(name='Memory', description='The memory size to be allocated to each compute node. The memory size is in string format. Unit: MB or GB.', example='4gb'),
      nodes?: int32(name='Nodes', description='The number of compute nodes to be allocated to the job.', example='2'),
    }(name='Resources', description='The resource configurations of the job.'),
    runasUser?: string(name='RunasUser', description='The cluster-side user as which you want to submit the job.', example='testuser'),
    runasUserPassword?: string(name='RunasUserPassword', description='The password of the user specified by the RunasUser parameter.', example='xxx'),
    stderrPath?: string(name='StderrPath', description='The path of the standard error output file of the job. You need to specify the full path.', example='/home/xxx/job.err'),
    stdoutPath?: string(name='StdoutPath', description='The path of the standard output file of the job. You need to specify the full path.', example='/home/xxx/job.out'),
    variables?: string(name='Variables', description='The environment variables of the job. The value is a string in the JSON array format. Each array member is a JSON object that contains two members: Name and Value. Name indicates the name of the environment variable, and Value indicates the value of the environment variable.', example='[{"Name":"x", "Value":"y"}]'),
    wallTime?: string(name='WallTime', description='The maximum duration for which the job can be run. Format: `hour: minute: second`. For example, `01:00:00` indicates 1 hour.', example='360:48:50'),
  }(name='JobSpec', description='The job configurations.', shrink='json', position='Query'),
}

model CreateJobResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='Submitted batch job 10\\n'),
  requestId?: string(name='RequestId', description='The request ID.', example='A0A38A38-1565-555E-B597-E48A2E******'),
  success?: string(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJobResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you understand the billing and [pricing](https://www.aliyun.com/price/product#/ecs/detail) of E-HPC.
  * @param request  the request parameters of CreateJob  CreateJobRequest
  * @return CreateJobResponse
 */
async function createJob(request: CreateJobRequest): CreateJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  computeNode?: NodeTemplate(name='ComputeNode', description='The hardware configurations of the compute nodes.', shrink='json', position='Query'),
  count?: int32(name='Count', description='The number of compute nodes that you want to add. Valid values: 1 to 99. The MinCount value must be smaller than the Count value.

*   If the number of available Elastic Compute Service (ECS) instances is smaller than the MinCount value, the nodes fail to be added.
*   If the number of available ECS instances is larger than the MinCount value but smaller than the Count value, nodes are added based on the MinCount value.
*   If the number of available ECS instances is larger than the Count value, nodes are added based on the Count value.', example='10', position='Query'),
  deploymentSetId?: string(name='DeploymentSetId', position='Query'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The type of the network between compute nodes. Valid values:

*   vpc
*   eRDMA', example='vpc', position='Query'),
  hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the added compute nodes.', example='compute', position='Query'),
  hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the added compute nodes.', example='demo', position='Query'),
  keepAlive?: string(name='KeepAlive', description='Specifies whether to enable deletion protection for the added compute nodes.', example='false', position='Query'),
  queueName?: string(name='QueueName', description='The name of the queue for which you want to create compute nodes.', example='test1', position='Query'),
  ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role to be assumed by the added nodes.', example='AliyunServiceRoleForOOSBandwidthScheduler', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to be used by the added nodes.', example='vsw-bp1lfcjbfb099rrjn****', position='Query'),
}

model CreateNodesResponseBody = {
  instanceIds?: [ string ](name='InstanceIds', description='The IDs of the compute nodes to be created.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model CreateNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNodesResponseBody(name='body'),
}

/**
  * @description ## [](#)
  * @param request  the request parameters of CreateNodes  CreateNodesRequest
  * @return CreateNodesResponse
 */
async function createNodes(request: CreateNodesRequest): CreateNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNodes', 'POST', '/', 'json', false, 'json', request);
}

model CreateQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queue?: QueueTemplate(name='Queue', description='The configurations of the queue to be created.', shrink='json', position='Query'),
}

model CreateQueueResponseBody = {
  name?: string(name='Name', description='The name of the created queue.', example='test'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateQueue  CreateQueueRequest
  * @return CreateQueueResponse
 */
async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQueue', 'POST', '/', 'json', false, 'json', request);
}

model CreateUsersRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  user?: [ 
    {
      authKey?: string(name='AuthKey', description='The public key of the user.

You can add up to 20 users in a call.

Specify one of the Password and AuthKey parameters. The AuthKey parameter takes effect only when the cluster authentication method is set to Key. Key authentication is not recommended.', example='Abc****'),
      group?: string(name='Group', description='The permission group to which the user belongs. Valid values:

users: ordinary permissions, which are suitable for ordinary users that need only to submit and debug jobs. wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes. You can add up to 20 users in a call.', example='users'),
      password?: string(name='Password', description='The password of the user. The password must be 6 to 30 characters in length and must contain three of the following character types:

*   Uppercase letters
*   Lowercase letters
*   Digits
*   Special characters ()~!@#$%^&\\*-_+=|{}[]:;\\"/<>,.?/

You can add up to 20 users in a call.

Specify one of the Password and AuthKey parameters. The Password parameter takes effect only when the cluster authentication method is set to Password. Password authentication is recommended.', example='1@a2****'),
      userName?: string(name='UserName', description='The username. The username must be 1 to 30 characters in length. It must start with a letter and can contain digits, letters, and periods (.).

You can add up to 20 users in a call.', example='testuser'),
    }
  ](name='User', description='The users that you want to add.', shrink='json', position='Query'),
}

model CreateUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model CreateUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateUsers  CreateUsersRequest
  * @return CreateUsersResponse
 */
async function createUsers(request: CreateUsersRequest): CreateUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUsers', 'POST', '/', 'json', false, 'json', request);
}

model DeleteClusterRequest {
  clusterId?: string(name='ClusterId', description='The ID of the E-HPC cluster to be released.', example='ehpc-hz-QKKVqO****', position='Query'),
}

model DeleteClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='F1AB6D8D-E185-4D94-859C-7CE7B8B7****'),
}

model DeleteClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteClusterResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Make sure that data of the cluster to be deleted is backed up before you call this operation.
  * > After a cluster is released, you cannot restore the data stored in the cluster. Exercise caution when you release a cluster.
  * @param request  the request parameters of DeleteCluster  DeleteClusterRequest
  * @return DeleteClusterResponse
 */
async function deleteCluster(request: DeleteClusterRequest): DeleteClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCluster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [listclusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instanceIds?: [ string ](name='InstanceIds', description='The instance IDs of the compute nodes that you want to delete.', shrink='json', position='Query'),
}

model DeleteNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The task ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model DeleteNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNodesResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
  * @param request  the request parameters of DeleteNodes  DeleteNodesRequest
  * @return DeleteNodesResponse
 */
async function deleteNodes(request: DeleteNodesRequest): DeleteNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteNodes', 'POST', '/', 'json', false, 'json', request);
}

model DeleteQueuesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queueNames?: [ string ](name='QueueNames', description='The queues that you want to delete.', shrink='json', position='Query'),
}

model DeleteQueuesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model DeleteQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueuesResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Before you delete a queue, you must delete all compute nodes in the queue.
  * @param request  the request parameters of DeleteQueues  DeleteQueuesRequest
  * @return DeleteQueuesResponse
 */
async function deleteQueues(request: DeleteQueuesRequest): DeleteQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueues', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUsersRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  user: [ 
    {
      userName: string(name='UserName', description='The name of user N that you want to delete.

Valid values of N: 1 to 100.

This parameter is required.', example='testuser'),
    }
  ](name='User', description='The users that you want to delete.

This parameter is required.', shrink='json', position='Query'),
}

model DeleteUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE****'),
}

model DeleteUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteUsers  DeleteUsersRequest
  * @return DeleteUsersResponse
 */
async function deleteUsers(request: DeleteUsersRequest): DeleteUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUsers', 'GET', '/', 'json', false, 'json', request);
}

model DescribeAddonTemplateRequest {
  addonName: string(name='AddonName', description='The addon name.

This parameter is required.', example='Login', position='Query'),
  addonVersion: string(name='AddonVersion', description='The addon version.

This parameter is required.', example='1.0', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number of the page returned. Pages start from page 1. Default value: 1.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='20', position='Query'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b', position='Query'),
}

model DescribeAddonTemplateResponseBody = {
  addon?: {
    description?: string(name='Description', description='The addon description.'),
    icon?: string(name='Icon', description='The addon icon.', example='/assets/icons/your_icon.svg'),
    label?: string(name='Label', description='The addon label.'),
    lastUpdate?: string(name='LastUpdate', description='The date when the addon template was last updated.', example='2024-08-22 18:11:17'),
    name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
    resourcesSpec?: {
      ecsResources?: [
        AddonNodeTemplate
      ](name='EcsResources', description='The Elastic Compute Service (ECS) resource configurations of the addon.'),
      eipResource?: {
        autoCreate?: boolean(name='AutoCreate', description='Indicates whether the EIP is automatically created.', example='True'),
        bandwidth?: string(name='Bandwidth', description='The maximum bandwidth of the EIP. Unit: Mbit/s.', example='100'),
        eipInstanceId?: string(name='EipInstanceId', description='The EIP ID.', example='eip-bp1jwtsuoiif2qf90****'),
        instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the EIP. Valid values:

*   PostPaid: pay-as-you-go.
*   PrePaid: subscription.

Default value: PostPaid', example='PostPaid'),
        internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay by bandwidth.
*   PayByTraffic: pay by data transfer.

Valid values of N: 1 to 10.', example='PayByTraffic'),
      }(name='EipResource', description='The Elastic IP Address (EIP) configurations of the service.'),
    }(name='ResourcesSpec', description='The resource configurations of the addon.'),
    servicesSpec?: [ 
      {
        inputParams?: [ 
          {
            helpText?: string(name='HelpText', description='The help information of the parameter.'),
            label?: string(name='Label', description='The parameter label.'),
            name: string(name='Name', description='The parameter name.

This parameter is required.', example='MYSQL_HOME'),
            type: string(name='Type', description='The parameter type.

This parameter is required.', example='String'),
            value: string(name='Value', description='The parameter value.

This parameter is required.', example='usr/local/mysql'),
          }
        ](name='InputParams', description='The parameter configurations of the service.'),
        networkACL?: [ 
          {
            ipProtocol: string(name='IpProtocol', description='The protocol type. Valid values:

*   **TCP**: forwards TCP packets.
*   **UDP**: forwards UDP packets.
*   **Any**: forwards all packets.

This parameter is required.', example='TCP'),
            port: float(name='Port', description='The port number.

This parameter is required.', example='3306'),
            sourceCidrIp: string(name='SourceCidrIp', description='The source CIDR block.

This parameter is required.', example='172.16.0.0/12'),
          }
        ](name='NetworkACL', description='The security group configurations of the service.'),
        serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
        serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
        serviceName: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
      }
    ](name='ServicesSpec', description='The addon configurations.'),
    version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
  }(name='Addon', description='The details of the addon template.'),
  pageNumber?: long(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeAddonTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAddonTemplateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeAddonTemplate  DescribeAddonTemplateRequest
  * @return DescribeAddonTemplateResponse
 */
async function describeAddonTemplate(request: DescribeAddonTemplateRequest): DescribeAddonTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAddonTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DetachSharedStoragesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  sharedStorages: [ 
    {
      mountDirectory: string(name='MountDirectory', description='The local mount directory of the mounted file system.

This parameter is required.', example='/test'),
    }
  ](name='SharedStorages', description='The information about mounted shared storage resources.

This parameter is required.', shrink='json', position='Query'),
}

model DetachSharedStoragesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model DetachSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachSharedStoragesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DetachSharedStorages  DetachSharedStoragesRequest
  * @return DetachSharedStoragesResponse
 */
async function detachSharedStorages(request: DetachSharedStoragesRequest): DetachSharedStoragesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachSharedStorages', 'POST', '/', 'json', false, 'json', request);
}

model GetAddonRequest {
  addonId: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
}

model GetAddonResponseBody = {
  addon?: {
    addonId: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W2g****'),
    description?: string(name='Description', description='The addon description.'),
    icon?: string(name='Icon', description='The addon icon.', example='/assets/icons/your_icon.svg'),
    installTime?: string(name='InstallTime', description='The time when the addon was installed.', example='2024-08-22 18:11:17'),
    label?: string(name='Label', description='The addon label.'),
    name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
    resourcesSpec?: {
      ecsResources?: [
        AddonNodeTemplate
      ](name='EcsResources', description='The Elastic Compute Service (ECS) resource configurations of the addon.'),
      eipResource?: {
        autoCreate?: boolean(name='AutoCreate', description='Indicates whether the EIP is automatically created.', example='True'),
        bandwidth?: string(name='Bandwidth', description='The maximum bandwidth of the EIP. Unit: Mbit/s.', example='100'),
        eipAddress?: string(name='EipAddress', description='The EIP.', example='39.108.xx.xx'),
        eipInstanceId?: string(name='EipInstanceId', description='The EIP ID.', example='eip-bp1vi9124tbx1g3kr****'),
        instanceChargeType?: string(name='InstanceChargeType', description='The billing method of the EIP.

*   PostPaid: pay-as-you-go.
*   PrePaid: subscription.

Default value: PostPaid.', example='PostPaid'),
        internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay by bandwidth.
*   PayByTraffic: pay by data transfer.

Valid values of N: 1 to 10.', example='PayByTraffic'),
      }(name='EipResource', description='The Elastic IP Address (EIP) configurations.'),
    }(name='ResourcesSpec', description='The resource configurations of the addon.'),
    servicesSpec?: [ 
      {
        inputParams?: [ 
          {
            helpText?: string(name='HelpText', description='The help information of the parameter.'),
            label?: string(name='Label', description='The parameter label.'),
            name: string(name='Name', description='The parameter name.

This parameter is required.', example='MYSQL_HOME'),
            type: string(name='Type', description='The parameter type.

This parameter is required.', example='String'),
            value: string(name='Value', description='The parameter value.

This parameter is required.', example='usr/local/mysql'),
          }
        ](name='InputParams', description='The parameter configurations of the service.'),
        networkACL?: [ 
          {
            ipProtocol: string(name='IpProtocol', description='The protocol type. Valid values:

TCP: forwards TCP packets.

UDP: forwards UDP packets.

Any: forwards all packets.

This parameter is required.', example='TCP'),
            port: float(name='Port', description='The port number.

This parameter is required.', example='3306'),
            sourceCidrIp: string(name='SourceCidrIp', description='The source CIDR block.

This parameter is required.', example='172.16.0.0/12'),
          }
        ](name='NetworkACL', description='The security group configurations of the service.'),
        serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
        serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
        serviceName: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
      }
    ](name='ServicesSpec', description='The service configurations of the addon.'),
    status?: string(name='Status', description='The addon status.', example='Running'),
    version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
  }(name='Addon', description='The details about the addon.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BBC2F93D-003A-49C4-850C-B826EECF****'),
}

model GetAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAddonResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAddon  GetAddonRequest
  * @return GetAddonResponse
 */
async function getAddon(request: GetAddonRequest): GetAddonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAddon', 'POST', '/', 'json', false, 'json', request);
}

model GetClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
}

model GetClusterResponseBody = {
  clientVersion?: string(name='ClientVersion', description='The E-HPC Util version.', example='2.0.31'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
  clusterCreateTime?: string(name='ClusterCreateTime', description='The time when the cluster was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='The arguments that are used to run the script after the scrip is installed.', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The URL that is used to download the post-processing script.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  clusterMode?: string(name='ClusterMode', description='The deployment type of the cluster. Valid values:

*   Integrated: The cluster is deployed on a public cloud.
*   Hybrid: The cluster is deployed on a hybrid cloud.
*   Custom: The cluster is a custom cluster.', example='Integrated'),
  clusterModifyTime?: string(name='ClusterModifyTime', description='The time when the cluster was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
  clusterName?: string(name='ClusterName', description='The cluster name.', example='slurm22.05.8-cluster-20240614'),
  clusterStatus?: string(name='ClusterStatus', description='The cluster state. Valid values:

*   uninit: The cluster is being installed.
*   creating: The cluster is being created.
*   initing: The cluster is being initialized.
*   running: The cluster is running.
*   exception: The cluster has run into an exception.
*   raleasing: The cluster is being released.
*   stopping: The cluster is being stopped.
*   stopped: The cluster is stopped.
*   pending: The cluster is waiting to be configured.', example='running'),
  clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch used by the cluster.', example='vsw-bp1p2uugqsjppno******'),
  clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) used by the cluster.', example='vpc-uf6u3lk1pjy28eg*****'),
  deleteProtection?: string(name='DeleteProtection', description='Indicates whether deletion protection is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  ehpcVersion?: string(name='EhpcVersion', description='The E-HPC version.', example='2.0.0'),
  enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether automatic scale-in is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether automatic scale-out is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
  growInterval?: int32(name='GrowInterval', description='The interval at which the cluster is automatically scaled out.', example='2'),
  idleInterval?: int32(name='IdleInterval', description='The idle duration of the compute nodes allowed by the cluster.', example='4'),
  manager?: {
    DNS?: {
      status?: string(name='Status', description='The state of the domain name resolution service. Valid values:

*   uninit: The service is being installed.
*   initing: The service is being initialized.
*   running: The service is running.
*   exception: The service has run into an exception.
*   releasing: The service is being released.
*   stopped: The service is stopped.
*   pending: The service is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The resolution type.', example='nis'),
      version?: string(name='Version', description='The version of the resolution service.', example='2.31'),
    }(name='DNS', description='The configurations of the domain name resolution service.'),
    directoryService?: {
      status?: string(name='Status', description='The state of the domain account service. Valid values:

*   uninit: The service is being installed.
*   initing: The service is being initialized.
*   running: The service is running.
*   exception: The service has run into an exception.
*   releasing: The service is being released.
*   stopped: The service is stopped.
*   pending: The service is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The type of the domain account.', example='nis'),
      version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
    }(name='DirectoryService', description='The information about the domain account service.'),
    managerNode?: {
      expiredTime?: string(name='ExpiredTime', description='The expiration time of the management node.', example='2099-12-31T15:59Z'),
      instanceChargeType?: string(name='InstanceChargeType', description='The instance billing method of the management node. Valid values:

*   PostPaid: pay-as-you-go
*   PrePaid: subscription', example='PostPaid'),
      instanceId?: string(name='InstanceId', description='The instance ID of the management node.', example='i-bp1a170jgea1vl******'),
      instanceType?: string(name='InstanceType', description='The instance type of the management node.', example='ecs.g6.4xlarge'),
    }(name='ManagerNode', description='The configurations of the management node.'),
    scheduler?: {
      status?: string(name='Status', description='The scheduler state. Valid values:

*   uninit: The scheduler is being installed.
*   initing: The scheduler is being initialized.
*   running: The scheduler is running.
*   exception: The scheduler has run into an exception.
*   releasing: The scheduler is being released.
*   stopped: The scheduler is stopped.
*   pending: The scheduler is waiting to be configured.', example='running'),
      type?: string(name='Type', description='The scheduler type. Valid values:

*   SLURM
*   PBS
*   OPENGRIDSCHEDULER
*   LSF_PLUGIN
*   PBS_PLUGIN', example='SLURM'),
      version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
    }(name='Scheduler', description='The information about the scheduler.'),
  }(name='Manager', description='The management node configurations.'),
  maxCoreCount?: string(name='MaxCoreCount', description='The maximum total number of vCPUs that can be used by all compute nodes managed by the cluster.', example='10000'),
  maxCount?: string(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage.', example='100'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxazb4ph****'),
  securityGroupId?: string(name='SecurityGroupId', description='The security group ID.', example='sg-f8z9vb2zaezpkr69a21k'),
}

model GetClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCluster  GetClusterRequest
  * @return GetClusterResponse
 */
async function getCluster(request: GetClusterRequest): GetClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCluster', 'POST', '/', 'json', false, 'json', request);
}

model GetCommonLogDetailRequest {
  from: long(name='From', description='The start time of the time range within which the logs that you want to query were generated. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821542', position='Query'),
  hiddenProcess?: boolean(name='HiddenProcess', description='Specifies whether to hide the process of each step. Valid values:

*   true: hides the process and returns only the result log of each step.
*   false: does not hide the process and displays the start and result logs of each step.

Default value: true.', example='true', position='Query'),
  logRequestId: string(name='LogRequestId', description='The request ID.

This parameter is required.', example='04F0F334-1335-436C-A1D7-6C044FE7****', position='Query'),
  to: long(name='To', description='The end time of the time range within which the logs that you want to query were generated. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821666', position='Query'),
}

model GetCommonLogDetailResponseBody = {
  action?: string(name='Action', description='The action name.', example='CreateCluster'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-abc***'),
  logDetail?: [ 
    {
      stageName?: string(name='StageName', description='The stage name of the log.', example='ConfigNetwork'),
      stages?: [ 
        {
          logLevel?: string(name='LogLevel', description='The log level.

Valid values:

*   ERROR
*   INFO
*   WARN', example='INFO'),
          message?: string(name='Message', description='The output message of the log.', example='Successfully created security group sg-bcd***'),
          method?: string(name='Method', description='The method involved in the log.', example='CreateSecurityGroup'),
          requestId?: string(name='RequestId', description='The request ID associated with the log.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
          status?: string(name='Status', description='The action state involved in the log. Valid values:

*   InProgress: The action is being performed.
*   Finished: The action is completed.
*   Failed: The action failed.', example='Finished'),
          target?: string(name='Target', description='The resource involved in the log.', example='sg-bcd***'),
          time?: string(name='Time', description='The time when the log was generated.', example='2024-08-22 14:21:54'),
        }
      ](name='Stages', description='The information about the log stages.'),
    }
  ](name='LogDetail', description='The information about the logs.'),
  logType?: string(name='LogType', description='The log type.', example='operation'),
  operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='239***'),
  requestId?: string(name='RequestId', description='The request ID.', example='464E9919-D04F-4D1D-B375-15989492****'),
  uid?: string(name='Uid', description='The ID of the Alibaba Cloud account.', example='137***'),
}

model GetCommonLogDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommonLogDetailResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCommonLogDetail  GetCommonLogDetailRequest
  * @return GetCommonLogDetailResponse
 */
async function getCommonLogDetail(request: GetCommonLogDetailRequest): GetCommonLogDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCommonLogDetail', 'POST', '/', 'json', false, 'json', request);
}

model GetJobRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  jobId: string(name='JobId', description='The job ID. You can call the ListJobs operation to query the job ID.

This parameter is required.', example='1.manager', position='Query'),
}

model GetJobResponseBody = {
  jobInfo?: {
    arrayJobId?: string(name='ArrayJobId', description='The parent job ID. If the return value is a non-empty string, the job is an array job.', example='1'),
    arrayJobSubId?: string(name='ArrayJobSubId', description='The sub-job ID. This parameter is valid when the ArrayJobId parameter is a non-empty string.', example='3'),
    arrayRequest?: string(name='ArrayRequest', description='The job queue. If the job is not in a queue, the output is empty.

The format is X-Y:Z. X indicates the first index, Y indicates the final index, and Z indicates the step size. For example, 2-7:2 indicates three sub-jobs numbered 2, 4, and 6.', example='1-5:2'),
    commandLine?: string(name='CommandLine', description='The command that is used to run the job.', example='/home/huangsf/ehpc/job_meta.pbs'),
    createTime?: string(name='CreateTime', description='The time when the job was submitted.', example='2024-08-16T10:52:48'),
    errorLog?: string(name='ErrorLog', description='The error log file of the job.', example='/home/xxx/STDIN.e1'),
    extraInfo?: string(name='ExtraInfo', description='Additional information.', example='{}'),
    jobId?: string(name='JobId', description='The job ID.', example='1.manager'),
    jobName?: string(name='JobName', description='The job name.', example='testJob'),
    jobQueue?: string(name='JobQueue', description='The queue to which the job belongs.', example='workq'),
    lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last modified.', example='2024-08-16T10:52:48'),
    nodeList?: string(name='NodeList', description='The compute nodes that are used to run the job.', example='compute000'),
    outputLog?: string(name='OutputLog', description='The standard output log file of the job.', example='/home/xxx/STDIN.o1'),
    priority?: string(name='Priority', description='The priority of the job.', example='0'),
    resources?: {
      cores?: string(name='Cores', description='The number of vCPUs used by the job on each node.', example='2'),
      gpus?: string(name='Gpus', description='The number of GPUs used by the job on each node.', example='1'),
      memory?: string(name='Memory', description='The memory size used by the job on each node.', example='1gb'),
      nodes?: string(name='Nodes', description='The number of nodes that are used to run the job.', example='1'),
    }(name='Resources', description='The resources that were requested when the job was submitted.'),
    resourcesUsed?: {
      cores?: string(name='Cores', description='The number of vCPUs used by the job on each node.', example='2'),
      memory?: string(name='Memory', description='The memory size used by the job on each node.', example='512mb'),
      nodes?: string(name='Nodes', description='The number of nodes that are used to run the job.', example='2'),
    }(name='ResourcesUsed', description='The resources that are actually used by the job.'),
    runasUser?: string(name='RunasUser', description='The user to which the job belongs or that is used to submit the job. This user is a cluster-side user.', example='testuser'),
    startTime?: string(name='StartTime', description='The time when the job was started.', example='2024-08-16T10:52:48'),
    state?: string(name='State', description='The job state.', example='Running'),
    variables?: [ 
      {
        name?: string(name='Name', description='The name of the environment variable.', example='ProxyIP'),
        value?: string(name='Value', description='The value of the environment variable.', example='10.x.x.x'),
      }
    ](name='Variables', description='The variables of the job.'),
  }(name='JobInfo', description='The job details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0****-1335-****-A1D7-6C044FE7****'),
  success?: string(name='Success', description='The request result. Valid values:

*   true
*   false', example='true'),
}

model GetJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetJob  GetJobRequest
  * @return GetJobResponse
 */
async function getJob(request: GetJobRequest): GetJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJob', 'POST', '/', 'json', false, 'json', request);
}

model GetJobLogRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-jeJki6****', position='Query'),
  jobId: string(name='JobId', description='The job ID.

This parameter is required.', example='1.manager', position='Query'),
  logType?: string(name='LogType', description='The log type. Valid values:

*   stdout: standard output logs.
*   stderr: error output logs.
*   all: all logs.

Default value: all.', example='stdout', position='Query'),
  offset?: string(name='Offset', description='The position where logs start to be read.

Unit: bytes.

Default value: 0.', example='0', position='Query'),
  size?: string(name='Size', description='The maximum size of logs that you can read in a single request.

Unit: bytes.

Default value: 10240.', example='20480', position='Query'),
}

model GetJobLogResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='1.manager'),
  requestId?: string(name='RequestId', description='The request ID.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
  stderrLog?: string(name='StderrLog', description='The error output log that is encoded in Base64.', example='aG9zdG5hbWU='),
  stderrLogSize?: string(name='StderrLogSize', description='The size of the error output file.', example='0'),
  stdoutLog?: string(name='StdoutLog', description='The standard output log that is encoded in Base64.', example='aG9zdG5hbWU='),
  stdoutLogSize?: string(name='StdoutLogSize', description='The size of the standard output file.', example='4096'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model GetJobLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobLogResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Currently, only Slurm and PBS Pro schedulers for Standard Edition clusters are supported.
  * @param request  the request parameters of GetJobLog  GetJobLogRequest
  * @return GetJobLogResponse
 */
async function getJobLog(request: GetJobLogRequest): GetJobLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobLog', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queueName?: string(name='QueueName', description='The queue name.', example='comp', position='Query'),
}

model GetQueueResponseBody = {
  queue?: {
    allocationStrategy?: string(name='AllocationStrategy', description='The auto scale-out policy of the queue.', example='PriorityInstanceType'),
    computeNodes?: [
      NodeTemplate
    ](name='ComputeNodes', description='The hardware configurations of the compute nodes in the queue.'),
    enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether auto scale-in is enabled for the queue. Valid values:

*   true
*   false', example='true'),
    enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether auto scale-out is enabled for the queue. Valid values:

*   true
*   false', example='true'),
    hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the compute nodes in the queue.', example='compute'),
    hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the compute nodes in the queue.', example='demo'),
    initialCount?: int32(name='InitialCount', description='The initial number of nodes in the queue.', example='0'),
    interConnect?: string(name='InterConnect', description='The type of the network between compute nodes in the queue. Valid values:

*   vpc
*   eRDMA', example='erdma'),
    keepAliveNodes?: [ string ](name='KeepAliveNodes', description='The nodes for which deletion protection is enabled in the queue.'),
    maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='1000'),
    maxCountPerCycle?: long(name='MaxCountPerCycle', description='The minimum number of nodes that are delivered to the queue in each scale-out cycle.', example='99'),
    minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
    queueName: string(name='QueueName', description='The queue name.

This parameter is required.', example='comp'),
    ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role that is assumed by compute nodes in the queue.', example='AliyunECSInstanceForEHPCRole'),
    vSwitchIds?: [ string ](name='VSwitchIds', description='The available vSwitches for compute nodes in the queue. Valid values of N: 1 to 5.'),
  }(name='Queue', description='The queue configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model GetQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQueue  GetQueueRequest
  * @return GetQueueResponse
 */
async function getQueue(request: GetQueueRequest): GetQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueue', 'POST', '/', 'json', false, 'json', request);
}

model InstallAddonRequest {
  addonName: string(name='AddonName', description='The addon name.

This parameter is required.', example='Login', position='Query'),
  addonVersion: string(name='AddonVersion', description='The addon version.

This parameter is required.', example='1.0', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  resourcesSpec: string(name='ResourcesSpec', description='The resource configurations of the addon.

This parameter is required.', example='`{"EipResource": {"AutoCreate": true}, "EcsResources": [{"InstanceType": "ecs.c7.xlarge", "ImageId": "centos_7_6_xxx.vhd", "SystemDisk": {"Category": "cloud_essd", "Size": 40, "Level": "PL0"}]}`', position='Query'),
  servicesSpec: string(name='ServicesSpec', description='The service configurations of the addon.

This parameter is required.', example='`[{"ServiceName": "SSH", "ServiceAccessType": null, "ServiceAccessUrl": null, "NetworkACL": [{"IpProtocol": "TCP", "Port": 22, "SourceCidrIp": "0.0.0.0/0"}]}, {"ServiceName": "VNC", "ServiceAccessType": null, "ServiceAccessUrl": null, "NetworkACL": [{"IpProtocol": "TCP", "Port": 12016, "SourceCidrIp": "0.0.0.0/0"}]}]`', position='Query'),
}

model InstallAddonResponseBody = {
  addonId: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****'),
  requestId?: string(name='RequestId', description='The request ID.', example='B745C159-3155-4B94-95D0-4B73D4D2****'),
}

model InstallAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallAddonResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Take note of the following items when you call this operation:
  * *   The cluster must be in the `Running` state.
  * *   Clusters fall into two types:
  *     *   Regular clusters on Alibaba Cloud Public Cloud
  *     *   Managed clusters on Alibaba Cloud Public Cloud
  * @param request  the request parameters of InstallAddon  InstallAddonRequest
  * @return InstallAddonResponse
 */
async function installAddon(request: InstallAddonRequest): InstallAddonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallAddon', 'POST', '/', 'json', false, 'json', request);
}

model InstallSoftwaresRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The software name.', example='gromacs'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackages', description='The information about the software systems that you want to install.', shrink='json', position='Query'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
}

model InstallSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model InstallSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstallSoftwaresResponseBody(name='body'),
}

/**
  * @param request  the request parameters of InstallSoftwares  InstallSoftwaresRequest
  * @return InstallSoftwaresResponse
 */
async function installSoftwares(request: InstallSoftwaresRequest): InstallSoftwaresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallSoftwares', 'GET', '/', 'json', false, 'json', request);
}

model ListAddonTemplatesRequest {
  addonNames?: [ string ](name='AddonNames', description='The addon names.', position='Query'),
  clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number of the page to return. Pages start from page 1.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: 20.', example='10', position='Query'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-shanghai', position='Query'),
}

model ListAddonTemplatesResponseBody = {
  addons?: [ 
    {
      description?: string(name='Description', description='The addon description.'),
      label?: string(name='Label', description='The addon label'),
      name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The information about the addon templates.'),
  pageNumber?: long(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAddonTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonTemplatesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAddonTemplates  ListAddonTemplatesRequest
  * @return ListAddonTemplatesResponse
 */
async function listAddonTemplates(request: ListAddonTemplatesRequest): ListAddonTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAddonTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListAddonsRequest {
  addonIds?: [ string ](name='AddonIds', description='The addon IDs.', shrink='json', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', position='Query'),
}

model ListAddonsResponseBody = {
  addons?: [ 
    {
      addonId: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W4g****'),
      description?: string(name='Description', description='The addon description.'),
      installTime?: string(name='InstallTime', description='The time when the addon was installed.', example='2024-08-22 18:11:17'),
      label?: string(name='Label', description='The addon label.'),
      name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
      status?: string(name='Status', description='The addon state.', example='Running'),
      version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
    }
  ](name='Addons', description='The information about the addons.'),
  pageNumber?: int32(name='PageNumber', description='The number of entries per page.', example='20'),
  pageSize?: int32(name='PageSize', description='The page number of the returned page. Default value: 1', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAddonsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAddonsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAddons  ListAddonsRequest
  * @return ListAddonsResponse
 */
async function listAddons(request: ListAddonsRequest): ListAddonsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAddons', 'POST', '/', 'json', false, 'json', request);
}

model ListAvailableFileSystemsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Page starts from page 1. Default value: 1', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50. Default value: 10', example='10', position='Query'),
}

model ListAvailableFileSystemsResponseBody = {
  fileSystemList?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2024-7-29 15:43:53'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='2fa0248***'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system. Valid values:

*   standard: general-purpose network-attached storage (NAS) file system
*   extreme: extreme NAS file system', example='cpfs'),
      mountTargetList?: [ 
        {
          mountTargetDomain?: string(name='MountTargetDomain', description='The address of the mount target.', example='c0967****.cn-hangzhou.cpfs.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type. Valid values: Valid values:

*   vpc', example='vpc'),
          status?: string(name='Status', description='The state of the mount target. Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.
*   Pending: The mount target is being mounted.
*   Deleting: The mount target is being deleted.', example='Active'),
          vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-2ze0c41hwu7lc29ris***'),
          vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-8vbvb34rtyh6xb3zrehs1****'),
        }
      ](name='MountTargetList', description='The mount targets of the file system.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system. Valid values:

*   nfs
*   smb
*   cpfs', example='cpfs'),
      status?: string(name='Status', description='The state of the file system. Valid values:

*   Pending: The file system is processing a task.
*   Running: The file system is available. You can perform subsequent operations, such as creating a mount target, only when the file system is in the Running state.
*   Stopped: The file system is unavailable.
*   Extending: The file system is being scaled out.
*   Stopping: The file system is being stopped.
*   Deleting: The file system is being deleted.', example='Running'),
      storageType?: string(name='StorageType', description='The storage type of the file system.

*   Valid values if FileSystemType is set to standard: Capacity and Performance.
*   Valid values if FileSystemType is set to extreme: standard and advance.', example='Performance'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp132kgui8n0targb****'),
    }
  ](name='FileSystemList', description='The file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='BF4E8AB1-02A3-5ECF-87CC-3AB7BE98**'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='65'),
}

model ListAvailableFileSystemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableFileSystemsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAvailableFileSystems  ListAvailableFileSystemsRequest
  * @return ListAvailableFileSystemsResponse
 */
async function listAvailableFileSystems(request: ListAvailableFileSystemsRequest): ListAvailableFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model ListAvailableImagesRequest {
  directoryService?: {
    type?: string(name='Type', description='The type of the domain account.', example='NIS'),
    version?: string(name='Version', description='The version of the domain account service.', example='1.0'),
  }(name='DirectoryService', description='The information about the domain account service.', shrink='json', position='Query'),
  enableHT?: boolean(name='EnableHT', description='Specifies whether to return images in which hyper-threading is enabled.', example='true', position='Query'),
  HPCInterConnect?: string(name='HPCInterConnect', description='The network type of the images that you want to query.', example='vpc', position='Query'),
  imageOwnerAlias?: string(name='ImageOwnerAlias', description='The image source. Valid values:

*   system: system image.
*   self: custom image.
*   others: shared image.', example='self', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type.

>  By default, if you do not specify an instance type, the list of images that are supported by all instance types are queried. For more information, see [Instance families](https://help.aliyun.com/document_detail/25378.html).', example='ecs.c7.large', position='Query'),
  isPublic?: boolean(name='IsPublic', description='Specifies whether to return published community images. Valid values:

*   true: returns published community images. If you set the value of this parameter to `true`, the `ImageOwnerAlias` parameter must be set to `others`.
*   false: returns non-community images. The value of the `ImageOwnerAlias` parameter prevails.

Default value: false.', example='true', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50. Default value: 10.', example='1', position='Query'),
  scheduler?: {
    type?: string(name='Type', description='The scheduler type.', example='SLURM'),
    version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
  }(name='Scheduler', description='The scheduler information about the images that you want to query.', shrink='json', position='Query'),
}

model ListAvailableImagesResponseBody = {
  images?: [ 
    {
      architecture?: string(name='Architecture', description='The OS architecture of the image. Valid values:

*   x86_64
*   arm64', example='x86_64'),
      bootMode?: string(name='BootMode', description='The boot mode of the image. Valid values:

*   BIOS: Basic Input/Output System (BIOS).
*   UEFI: Unified Extensible Firmware Interface (UEFI).

>  When you change the OS boot mode of an instance, you must make sure that the boot mode matches the boot mode of the associated image. Otherwise, the instance fails to be booted.', example='BIOS'),
      description?: string(name='Description', description='The image description.', example='ExampleDescription'),
      imageId?: string(name='ImageId', description='The image ID.', example='centos_7_06_64_20G_alibase_2019071****'),
      imageName?: string(name='ImageName', description='The image name.', example='CHESS5V5.0.27'),
      imageOwnerAlias?: string(name='ImageOwnerAlias', description='The image source. Valid values:

*   system: system image.
*   self: custom image.
*   others: shared image.', example='self'),
      OSName?: string(name='OSName', description='The OS name in Chinese.'),
      OSNameEn?: string(name='OSNameEn', description='The OS name in English.', example='CentOS  7.9 64 bit'),
      platform?: string(name='Platform', description='The OS. Valid values:

*   CentOS
*   windows', example='windows'),
      size?: string(name='Size', description='The image size. Unit: GiB', example='40'),
    }
  ](name='Images', description='The information about the images.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.

*   Pages start from page 1.
*   Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListAvailableImagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAvailableImagesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListAvailableImages  ListAvailableImagesRequest
  * @return ListAvailableImagesResponse
 */
async function listAvailableImages(request: ListAvailableImagesRequest): ListAvailableImagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableImages', 'GET', '/', 'json', false, 'json', request);
}

model ListClustersRequest {
  clusterIds?: [ string ](name='ClusterIds', description='The cluster IDs. You can specify up to 20 IDs.', shrink='json', position='Query'),
  clusterNames?: [ string ](name='ClusterNames', description='The cluster names. You can specify up to 20 names.', shrink='json', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 10 to 100. Default value: 10', example='10', position='Query'),
}

model ListClustersResponseBody = {
  clusters?: [ 
    {
      additionalPackages?: [ 
        {
          name?: string(name='Name', description='The software name.', example='gromacs'),
          version?: string(name='Version', description='The software version.', example='2024.1'),
        }
      ](name='AdditionalPackages', description='The information about installed software in the cluster.'),
      addons?: [ 
        {
          addonId?: string(name='AddonId', description='The addon ID.', example='Login-1.0-W2g****'),
          description?: string(name='Description', description='The addon description.'),
          label?: string(name='Label', description='The addon label.'),
          name: string(name='Name', description='The addon name.

This parameter is required.', example='Login'),
          resourcesSpec?: {
            ecsInstanceId?: string(name='EcsInstanceId', description='The instance ID.', example='i-bp1bg85d2q6laic8****'),
            eipInstanceId?: string(name='EipInstanceId', description='The Elastic IP Address (EIP) ID.', example='eip-bp1vi9124tbx1g3kr****'),
          }(name='ResourcesSpec', description='The resource configurations of the addon.'),
          servicesSpec?: [ 
            {
              serviceAccessType?: string(name='ServiceAccessType', description='The service access type.', example='URL'),
              serviceAccessUrl?: string(name='ServiceAccessUrl', description='The service access URL.', example='https://47.96.xx.xx:12008'),
              serviceName: string(name='ServiceName', description='The service name.

This parameter is required.', example='Web Portal'),
            }
          ](name='ServicesSpec', description='The information about the addon services.'),
          status?: string(name='Status', description='The addon state.', example='Running'),
          version: string(name='Version', description='The addon version.

This parameter is required.', example='1.0'),
        }
      ](name='Addons', description='The information about the addons in the cluster.'),
      clusterCategory?: string(name='ClusterCategory', description='The cluster type. Valid values:

*   Standard
*   Serverless', example='Standard'),
      clusterCreateTime?: string(name='ClusterCreateTime', description='The time when the cluster was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
      clusterCredentials?: [ string ](name='ClusterCredentials', description='The logon credential type of the cluster. Valid values:

*   password: requires passwords for logons.
*   keypair: requires key pairs for logons.'),
      clusterCustomConfiguration?: {
        args?: string(name='Args', description='The parameters of the post-processing script.', example='demo'),
        script?: string(name='Script', description='The link to the post-processing script.', example='https://xxxxx'),
      }(name='ClusterCustomConfiguration', description='The post-processing script used by the cluster.'),
      clusterDescription?: string(name='ClusterDescription', description='The cluster description.', example='Demo'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-VMKe******'),
      clusterMode?: string(name='ClusterMode', description='The deployment type of the cluster. Valid values:

*   Integrated: public cloud
*   Hybrid: hybrid cloud
*   Custom: a custom cluster', example='Integrated'),
      clusterModifyTime?: string(name='ClusterModifyTime', description='The time when the cluster was modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-08-06T12:43:01.000Z'),
      clusterName?: string(name='ClusterName', description='The cluster name.', example='slurm22.05.8-cluster-20240227'),
      clusterStatus?: string(name='ClusterStatus', description='The cluster state. Valid values:

*   uninit: The cluster is being installed.
*   creating: The cluster is being created.
*   initing: The cluster is being initialized.
*   running: The cluster is running.
*   Releasing: The cluster is being released.
*   stopping: The cluster is being stopped.
*   stopped: The cluster is stopped.
*   exception: The cluster has run into an exception.
*   pending: The cluster is waiting to be configured.', example='running'),
      clusterUsedCoreTime?: float(name='ClusterUsedCoreTime', description='The vCPU-hour usage of the cluster.', example='1000'),
      clusterVSwitchId?: string(name='ClusterVSwitchId', description='The ID of the vSwitch used by the cluster.', example='vsw-f8za5p0mwzgdu3wgx****'),
      clusterVpcId?: string(name='ClusterVpcId', description='The ID of the virtual private cloud (VPC) used by the cluster.', example='vpc-m5efjevmclc0xdmys****'),
      deletionProtection?: boolean(name='DeletionProtection', description='Indicates whether deletion protection is enabled for the cluster. Valid values:

*   true
*   false', example='true'),
      ehpcVersion?: string(name='EhpcVersion', description='The Elastic High Performance Computing (E-HPC) version.', example='2.0.0'),
      manager?: {
        DNS?: {
          type?: string(name='Type', description='The resolution type.', example='NIS'),
          version?: string(name='Version', description='The version of the domain name resolution service.', example='2.31'),
        }(name='DNS', description='The configurations of the domain name resolution service.'),
        directoryService?: {
          type?: string(name='Type', description='The type of the domain account.', example='NIS'),
          version?: string(name='Version', description='The version of the domain account service.', example='2.31'),
        }(name='DirectoryService', description='The configurations of the directory service.'),
        scheduler?: {
          type?: string(name='Type', description='The scheduler type.', example='SLURM'),
          version?: string(name='Version', description='The scheduler version.', example='22.05.8'),
        }(name='Scheduler', description='The configurations of the scheduler service.'),
      }(name='Manager', description='The configurations of the cluster management node.'),
      maxCoreCount?: long(name='MaxCoreCount', description='The maximum total number of vCPUs used by the compute nodes that can be managed by the cluster.', example='10000'),
      maxCount?: long(name='MaxCount', description='The maximum number of compute nodes that can be managed by the cluster.', example='500'),
      nodes?: {
        abnormalCounts?: int32(name='AbnormalCounts', description='The number of malfunctioning compute nodes.', example='0'),
        creatingCounts?: int32(name='CreatingCounts', description='The number of compute nodes that are being created.', example='0'),
        runningCounts?: int32(name='RunningCounts', description='The number of running compute nodes.', example='1'),
      }(name='Nodes', description='The node statistics of the cluster.'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmxazb4ph****'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group used by the cluster.', example='sg-bp13n61xsydodfyg****'),
      users?: {
        normalCounts?: int32(name='NormalCounts', description='The number of ordinary users.', example='2'),
        sudoCounts?: int32(name='SudoCounts', description='The number of administrators.', example='2'),
      }(name='Users', description='The user attribute information of the cluster.'),
    }
  ](name='Clusters', description='The list of clusters.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListClustersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListClusters  ListClustersRequest
  * @return ListClustersResponse
 */
async function listClusters(request: ListClustersRequest): ListClustersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClusters', 'POST', '/', 'json', false, 'json', request);
}

model ListCommonLogsRequest {
  actionName?: [ string ](name='ActionName', description='The action types.', shrink='json', position='Query'),
  actionStatus?: string(name='ActionStatus', description='The action status. Logs associated with the specific action status are returned.

Valid values:

*   Finished: The action is completed.
*   Failed: The action failed.
*   InProgress: The action is being performed.', example='Finished', position='Query'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  from: long(name='From', description='The start time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821542', position='Query'),
  isReverse?: boolean(name='IsReverse', description='Specifies whether to display results in reverse order.

Default value: true', example='true', position='Query'),
  logRequestId?: string(name='LogRequestId', description='The request ID of the action. Logs associated with the specific request ID are returned.', example='04F0F334-1335-436C-A1D7-6C044FE7****', position='Query'),
  logType?: string(name='LogType', description='The log type. Logs of the specific type are returned.', example='Operation', position='Query'),
  operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='137***', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.

Default value: 20.', example='10', position='Query'),
  resource?: string(name='Resource', description='The name of the resource involved in the action. Logs associated with the specific resource are returned. This parameter is not recommended.', example='i-abc***', position='Query'),
  to: long(name='To', description='The end time of the time range. The time is a timestamp. This value is a UNIX timestamp representing the number of seconds that have elapsed since the epoch time January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1703821666', position='Query'),
}

model ListCommonLogsResponseBody = {
  logs?: [ 
    {
      action?: string(name='Action', description='The name of the action corresponding to the log.', example='CreaterCluster'),
      clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-9T3xPNezoS'),
      logType?: string(name='LogType', description='The log type.', example='Operation'),
      message?: string(name='Message', description='The message of the log.', example='ok'),
      operatorUid?: string(name='OperatorUid', description='The account ID of the operator.', example='137***'),
      requestId?: string(name='RequestId', description='The request ID associated with the action that generated the log.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
      status?: string(name='Status', description='The action state in the log. Valid values:

*   InProgress: The action is being performed.
*   Finished: The action is completed.
*   Failed: The action failed.', example='Finished'),
      target?: string(name='Target', description='The involved resource.', example='i-abc***'),
      time?: string(name='Time', description='The time when the log was generated.', example='2024-08-22 14:21:54'),
    }
  ](name='Logs', description='The brief information of operation logs.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='464E9919-D04F-4D1D-B375-15989492****'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='15'),
  uid?: string(name='Uid', description='The ID of the Alibaba Cloud account.', example='137***'),
}

model ListCommonLogsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCommonLogsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListCommonLogs  ListCommonLogsRequest
  * @return ListCommonLogsResponse
 */
async function listCommonLogs(request: ListCommonLogsRequest): ListCommonLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCommonLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListInstalledSoftwaresRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number of the page to return.', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10', position='Query'),
}

model ListInstalledSoftwaresResponseBody = {
  additionalPackages?: {
    additionalPackageInfos?: [ 
    {
      category?: string(name='Category', description='The category into which the software falls.', example='NWP'),
      createTime?: string(name='CreateTime', description='The time when the software was installed.', example='2024-03-05 18:24:08'),
      description?: string(name='Description', description='The software description.'),
      icon?: string(name='Icon', description='The URL of the software icon.', example='https://gw.alicdn.com/imgextra/i2/O1CN01FIkxZ81LmE0fvrAyR_!!6000000001341-55-tps-6349-1603.svg'),
      name?: string(name='Name', description='The software name.', example='gromacs'),
      status?: string(name='Status', description='The installation status of the software.

Valid values:

*   Installed
*   Uninstalled
*   Installing
*   Exception', example='Installed'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackageInfos')
  }(name='AdditionalPackages', description='The list of installed software.'),
  pageNumber?: string(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListInstalledSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstalledSoftwaresResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListInstalledSoftwares  ListInstalledSoftwaresRequest
  * @return ListInstalledSoftwaresResponse
 */
async function listInstalledSoftwares(request: ListInstalledSoftwaresRequest): ListInstalledSoftwaresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstalledSoftwares', 'GET', '/', 'json', false, 'json', request);
}

model ListJobsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-csbua72***', position='Query'),
  jobFilter?: {
    createTimeEnd?: string(name='CreateTimeEnd', description='The time when the job was last updated. The value is a UNIX timestamp representing the number of seconds that have elapsed since 1970-01-01T00:00:00Z.', example='1724123085'),
    createTimeStart?: string(name='CreateTimeStart', description='The time when the job started. The value is a UNIX timestamp representing the number of seconds that have elapsed since 1970-01-01T00:00:00Z.', example='1724122486'),
    jobName?: string(name='JobName', description='The job name. Fuzzy match is supported.', example='testjob'),
    jobStatus?: string(name='JobStatus', description='The job state. Valid values:

*   all: returns all jobs.
*   finished: returns completed jobs.
*   notfinish: returns uncompleted jobs.

Default value: all.', example='all'),
    nodes?: [ string ](name='Nodes', description='The compute nodes that run the jobs.'),
    queues?: [ string ](name='Queues', description='The queues to which the jobs belong.'),
    sortBy?: {
      executeOrder?: string(name='ExecuteOrder', description='The order in which jobs are sorted based on their execution time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='asc'),
      pendOrder?: string(name='PendOrder', description='The order in which jobs are sorted based on their queuing time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='desc'),
      submitOrder?: string(name='SubmitOrder', description='The order in which jobs are sorted based on their submitting time. Valid values:

*   asc: in ascending order.
*   desc: in descending order.

Default value: desc.', example='asc'),
    }(name='SortBy', description='The result sorting configurations.'),
    users?: [ string ](name='Users', description='The users that run the jobs.'),
  }(name='JobFilter', description='The job filter information.', shrink='json', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number of the page to return.

*   Pages start from page 1.
*   Default value: 1', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries per page.

*   Maximum value: 50.
*   Default value: 10', example='10', position='Query'),
}

model ListJobsResponseBody = {
  jobs?: [ 
    {
      jobName?: string(name='JobName', description='The job name.', example='testjob'),
      jobSpec?: {
        arrayJobId?: string(name='ArrayJobId', description='The array job ID.', example='4'),
        arrayJobSubId?: string(name='ArrayJobSubId', description='The ID of the job in the array.', example='1'),
        arrayRequest?: string(name='ArrayRequest', description='The queue format of the job.

*   If the job is not in a queue, the output is empty.
*   The format is X-Y:Z. X indicates the first index, Y indicates the final index, and Z indicates the step size. For example, 2-7:2 indicates three sub-jobs numbered 2, 4, and 6.', example='1-5:2'),
        comment?: string(name='Comment', description='The job description.', example='jobDescription'),
        id?: string(name='Id', description='The job ID.', example='12'),
        jobQueue?: string(name='JobQueue', description='The queue name.', example='comp'),
        lastModifyTime?: string(name='LastModifyTime', description='The time when the job was last updated.', example='1724123085'),
        nodeList?: string(name='NodeList', description='The compute nodes that were used to run the job.', example='compute[002,005,003]'),
        priority?: string(name='Priority', description='The job priority. Valid values: 0 to 9. A larger value indicates a higher priority.', example='0'),
        resources?: {
          cores?: string(name='Cores', description='The number of vCPUs that were used to run the job.', example='6'),
          gpus?: string(name='Gpus', description='The number of GPUs that were used to run the job.', example='0'),
          memory?: string(name='Memory', description='The size of memory that was used to run the job.', example='1536MB'),
          nodes?: string(name='Nodes', description='The number of compute nodes that were used to run the job.', example='3'),
        }(name='Resources', description='The information about the resources required to run the job.'),
        runasUser?: string(name='RunasUser', description='The user that ran the job.', example='testuser1'),
        state?: string(name='State', description='The job state. Valid values: (PBS cluster and Slurm cluster)

*   FINISHED/Completed
*   RUNNING/Running
*   QUEUED/Pending
*   FAILED/Failed', example='Running'),
        stderrPath?: string(name='StderrPath', description='The error output path.', example='./Temp'),
        stdoutPath?: string(name='StdoutPath', description='The standard output path.', example='./Temp'),
        submitTime?: string(name='SubmitTime', description='The time when the job was submitted.', example='1724122486'),
        variables?: string(name='Variables', description='The variables of the job.', example='{"PBS_O_SHELL":"/bin/bash", 	"PBS_O_HOST":"manager", 	"PBS_O_SYSTEM":"Linux", 	"PBS_O_LANG":"en_US.UTF-8", 	"PBS_O_QUEUE":"workq"}'),
      }(name='JobSpec', description='The job configurations.'),
    }
  ](name='Jobs', description='The jobs.'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='EABFBD93-58BE-53F3-BBFE-8654BB2E****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='10'),
}

model ListJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListJobs  ListJobsRequest
  * @return ListJobsResponse
 */
async function listJobs(request: ListJobsRequest): ListJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobs', 'POST', '/', 'json', false, 'json', request);
}

model ListNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID. You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  hostnames?: [ string ](name='Hostnames', description='The hostnames of the compute nodes that you want to query.', shrink='json', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1', position='Query'),
  privateIpAddress?: [ string ](name='PrivateIpAddress', description='The IP addresses of the compute nodes that you want to query.', shrink='json', position='Query'),
  queueNames?: [ string ](name='QueueNames', description='The queues to which the nodes belong.', shrink='json', position='Query'),
  sequence?: string(name='Sequence', description='Specifies whether the results are sorted in ascending or descending order. Valid values:

*   Forward: ascending
*   Backward: descending

Default value: Forward.', example='Forward', position='Query'),
  sortBy?: string(name='SortBy', description='The sorting method of the node list. Valid values:

*   AddedTime: sorts the nodes by the time that they were added.
*   HostName: sorts the nodes by their hostnames.

Default value: addedtime.', example='AddedTime', position='Query'),
  status?: [ string ](name='Status', description='The states of the compute nodes to be queried.', shrink='json', position='Query'),
}

model ListNodesResponseBody = {
  nodes?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the node was created.', example='2020-06-09T06:22:02.000Z'),
      deploymentSetId?: string(name='DeploymentSetId'),
      expiredTime?: string(name='ExpiredTime', description='The time when the node expires.', example='2020-06-09T06:22:02.000Z'),
      hostname?: string(name='Hostname', description='The hostname of the node.', example='edas.cn-shanghai.aliyuncs.com'),
      htEnabled?: boolean(name='HtEnabled', description='Indicates whether hyper-threading is enabled.', example='true'),
      id?: string(name='Id', description='The instance ID of the node.', example='i-bp15707mys2rsy0j****'),
      imageId?: string(name='ImageId', description='The image ID of the node.', example='centos_7_06_64_20G_alibase_20190711.vhd'),
      instanceType?: string(name='InstanceType', description='The instance type of the node.', example='ecs.c5.large'),
      ipAddress?: string(name='IpAddress', description='The VPC IP address of the node.', example='`172.16.**.**`'),
      keepAlive?: boolean(name='KeepAlive', description='Indicates whether deletion protection is enabled for the node. Valid values:

*   true
*   false', example='true'),
      publicIpAddress?: string(name='PublicIpAddress', description='The public IP address of the node.', example='`172.16.**.**`'),
      queueName?: string(name='QueueName', description='The name of the queue to which the node belongs.', example='autoque3'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding policy of the node. Valid values:

*   NoSpot: The instances of the compute node are pay-as-you-go instances.
*   SpotWithPriceLimit: The instances are created as preemptible instances with a user-defined maximum hourly price.
*   SpotAsPriceGo: The node is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.', example='NoSpot'),
      stateInSched?: string(name='StateInSched', description='The node state in the scheduler.', example='active'),
      status?: string(name='Status', description='The node state. Valid values:

*   uninit: The node is being installed.
*   initing: The node is being initialized.
*   running: The node is running.
*   releasing: The node is being released.
*   stopped: The node is stopped.
*   exception: The node has run into an exception.
*   untracking: The node is not added to the cluster.', example='running'),
      totalResources?: {
        cpu?: int32(name='Cpu', description='The number of vCPUs.', example='1'),
        gpu?: int32(name='Gpu', description='The number of GPUs.', example='0'),
        memory?: int32(name='Memory', description='The amount of memory. Unit: GiB.', example='1024'),
      }(name='TotalResources', description='The hardware configurations of the node.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the node.', example='vsw-bp1e47optm9g58zcu****'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-bp1gnu8br4ay7beb2w****'),
      zoneId?: string(name='ZoneId', description='The zone ID of the node.', example='cn-hangzhou-b'),
    }
  ](name='Nodes', description='The information about the nodes.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='89A1AC0F-4A6C-4F3D-98F9-BEF9A823****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNodesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListNodes  ListNodesRequest
  * @return ListNodesResponse
 */
async function listNodes(request: ListNodesRequest): ListNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNodes', 'POST', '/', 'json', false, 'json', request);
}

model ListQueuesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queueNames?: [ string ](name='QueueNames', description='The names of the queues that you want to query. You can specify up to eight names.', shrink='json', position='Query'),
}

model ListQueuesResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  queues?: [ 
    {
      computeNodes?: [
        NodeTemplate
      ](name='ComputeNodes', description='The hardware configurations of the compute nodes that are added in auto scale-outs. Up to five nodes are displayed.'),
      createTime?: string(name='CreateTime', description='The time when the queue was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2023-11-10T02:04:00Z'),
      enableScaleIn?: boolean(name='EnableScaleIn', description='Indicates whether auto scale-in is enabled for the queue. Valid values:

*   true
*   false', example='true'),
      enableScaleOut?: boolean(name='EnableScaleOut', description='Indicates whether auto scale-out is enabled for the queue. Valid values:

*   true
*   false', example='true'),
      maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='100'),
      maxCountPerCycle?: int32(name='MaxCountPerCycle', description='The minimum number of compute nodes that are added to the queue in each auto scale-out.', example='1'),
      minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
      nodes?: {
        creatingCounts?: int32(name='CreatingCounts', description='The number of compute nodes that are not ready.', example='2'),
        exceptionCounts?: int32(name='ExceptionCounts', description='The number of malfunctioning compute nodes.', example='0'),
        runningCounts?: int32(name='RunningCounts', description='The number of running compute nodes.', example='1'),
      }(name='Nodes', description='The statistics about the compute nodes in the queue.'),
      queueName?: string(name='QueueName', description='The queue name.', example='comp'),
      totalCores?: int32(name='TotalCores', description='The total number of vCPUs that are used by all compute nodes in the queue.', example='24'),
      updateTime?: string(name='UpdateTime', description='The time when the queue was updated. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC. For more information, see [ISO 8601](https://help.aliyun.com/document_detail/25696.html).', example='2024-04-25T02:02:32'),
      vSwitchIds?: [ string ](name='VSwitchIds', description='The vSwitches that can be used for added nodes during auto scale-outs. Up to three vSwitches are displayed.'),
    }
  ](name='Queues', description='The information about the queues.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C6E5005C-00B0-4F27-98BB-95AB88016C22'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model ListQueuesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueuesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListQueues  ListQueuesRequest
  * @return ListQueuesResponse
 */
async function listQueues(request: ListQueuesRequest): ListQueuesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueues', 'POST', '/', 'json', false, 'json', request);
}

model ListSharedStoragesRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the attached file system.', example='0bd504b0**', position='Query'),
  fileSystemType?: string(name='FileSystemType', description='The type of the attached file system. Valid values:

*   nas
*   cpfs', example='nas', position='Query'),
}

model ListSharedStoragesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F6757FA4-8FED-4602-B7F5-3550C084****'),
  sharedStorages?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the attached file system.', example='08c7f4b***'),
      fileSystemProtocol?: string(name='FileSystemProtocol', description='The protocol used by the attached file system. Valid values:

*   nfs3
*   nfs4
*   cpfs', example='nfs4'),
      fileSystemType?: string(name='FileSystemType', description='The type of the attached file system. Valid values:

*   nas
*   cpfs', example='nas'),
      mountInfo?: [ 
        {
          mountDirectory?: string(name='MountDirectory', description='The local mount directory of the attached file system.', example='/test'),
          mountOptions?: string(name='MountOptions', description='The mount options for the attached file system. Valid values:

*   \\-t nfs -o vers=3,nolock,proto=tcp,noresvport
*   \\-t nfs -o vers=4.0,noresvport', example='-t nfs -o vers=4.0,noresvport'),
          mountTarget?: string(name='MountTarget', description='The mount target of the attached file system.', example='0bd504b***-ngq26.cn-hangzhou.nas.aliyuncs.com'),
          protocolType?: string(name='ProtocolType', description='The protocol used by the mount target of the attached file system. Valid values:

*   nfs3
*   nfs4
*   cpfs', example='nfs3'),
          storageDirectory?: string(name='StorageDirectory', description='The storage directory of the attached file system.', example='/testehpc'),
        }
      ](name='MountInfo', description='The mount information.'),
    }
  ](name='SharedStorages', description='The information about the attached shared storage.'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model ListSharedStoragesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSharedStoragesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListSharedStorages  ListSharedStoragesRequest
  * @return ListSharedStoragesResponse
 */
async function listSharedStorages(request: ListSharedStoragesRequest): ListSharedStoragesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSharedStorages', 'POST', '/', 'json', false, 'json', request);
}

model ListSoftwaresRequest {
  category?: string(name='Category', description='The application category.', example='NWP', position='Query'),
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  name?: string(name='Name', description='The software name.', example='gromacs', position='Query'),
  osInfos?: [ 
    {
      architecture?: string(name='Architecture', description='The OS architecture. Valid values:

*   x86_64
*   arm64', example='x86_64'),
      osTag?: string(name='OsTag', description='The image tag.', example='CentOS_7.9_64'),
    }
  ](name='OsInfos', description='The operating system (OS) information.', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number of the page to return.', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10', position='Query'),
}

model ListSoftwaresResponseBody = {
  additionalPackages?: {
    additionalPackageInfos?: [ 
    {
      category?: string(name='Category', description='The application category.', example='NWP'),
      description?: string(name='Description', description='The software description.'),
      icon?: string(name='Icon', description='The URL of the software icon.', example='https://gw.alicdn.com/imgextra/i2/O1CN01FIkxZ81LmE0fvrAyR_!!6000000001341-55-tps-6349-1603.svg'),
      name?: string(name='Name', description='The software name.', example='gromacs'),
      versions?: {
        versionInfos?: [ 
        {
          latest?: string(name='Latest', description='Indicates whether the version is the latest.', example='false'),
          supportOs?: {
            supportOsInfos?: [ 
            {
              architecture?: string(name='Architecture', description='The OS architecture. Valid values:

*   x86_64
*   arm64', example='x86_64'),
              osTag?: string(name='OsTag', description='The image tag.', example='Alibaba Cloud Linux  3.2104 LTS 64 bit ARM Edition'),
            }
          ](name='SupportOsInfos')
          }(name='SupportOs', description='The information about the supported OSs.'),
          version?: string(name='Version', description='The software version.', example='2024.1'),
        }
      ](name='VersionInfos')
      }(name='Versions', description='The information about the software versions that can be installed in the cluster.'),
    }
  ](name='AdditionalPackageInfos')
  }(name='AdditionalPackages', description='The information about the software that can be installed in the cluster.'),
  pageNumber?: string(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='2'),
}

model ListSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListSoftwaresResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListSoftwares  ListSoftwaresRequest
  * @return ListSoftwaresResponse
 */
async function listSoftwares(request: ListSoftwaresRequest): ListSoftwaresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSoftwares', 'GET', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number of the page to return.

Pages start from page 1.

Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 50.

Default value: 10', example='10', maximum=50, position='Query'),
}

model ListUsersResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='15'),
  users?: {
    userInfo?: [ 
    {
      addTime?: string(name='AddTime', description='The time when the user was first added.', example='2014-08-22T17:46:47'),
      group?: string(name='Group', description='The name of the permission group. Valid values:

users: ordinary permissions, which are suitable for regular users that need only to submit and debug jobs.

wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes.', example='users'),
      groupId?: string(name='GroupId', description='The permission group ID.', example='100'),
      userId?: string(name='UserId', description='The user ID.', example='1001'),
      userName?: string(name='UserName', description='The username.', example='testuser'),
    }
  ](name='UserInfo')
  }(name='Users', description='The information about the users.'),
}

model ListUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListUsersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListUsers  ListUsersRequest
  * @return ListUsersResponse
 */
async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'GET', '/', 'json', false, 'json', request);
}

model StopJobsRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  jobIds?: [ string ](name='JobIds', description='The IDs of the jobs that you want to stop.', shrink='json', position='Query'),
}

model StopJobsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8868A00-6757-5542-BDD6-E1040D94****'),
  success?: string(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model StopJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopJobsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopJobs  StopJobsRequest
  * @return StopJobsResponse
 */
async function stopJobs(request: StopJobsRequest): StopJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopJobs', 'POST', '/', 'json', false, 'json', request);
}

model UnInstallAddonRequest {
  addonId: string(name='AddonId', description='The addon ID.

This parameter is required.', example='Login-1.0-W2g****', position='Query'),
  clusterId: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
}

model UnInstallAddonResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
}

model UnInstallAddonResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnInstallAddonResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Take note of the following items when you call this operation:
  * *   The cluster must be in the `Running` state.
  * *   Clusters fall into the following types:
  *     *   Regular clusters on Alibaba Cloud Public Cloud
  *     *   Managed clusters on Alibaba Cloud Public Cloud
  * @param request  the request parameters of UnInstallAddon  UnInstallAddonRequest
  * @return UnInstallAddonResponse
 */
async function unInstallAddon(request: UnInstallAddonRequest): UnInstallAddonResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnInstallAddon', 'POST', '/', 'json', false, 'json', request);
}

model UninstallSoftwaresRequest {
  additionalPackages?: [ 
    {
      name?: string(name='Name', description='The software name.', example='gromacs'),
      version?: string(name='Version', description='The software version.', example='2024.1'),
    }
  ](name='AdditionalPackages', description='The information about the software systems that you want to uninstall.', shrink='json', position='Query'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
}

model UninstallSoftwaresResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model UninstallSoftwaresResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UninstallSoftwaresResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UninstallSoftwares  UninstallSoftwaresRequest
  * @return UninstallSoftwaresResponse
 */
async function uninstallSoftwares(request: UninstallSoftwaresRequest): UninstallSoftwaresResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallSoftwares', 'GET', '/', 'json', false, 'json', request);
}

model UpdateClusterRequest {
  clientVersion?: string(name='ClientVersion', description='The client version. By default, the latest version is used.', example='2.1.0', position='Query'),
  clusterCustomConfiguration?: {
    args?: string(name='Args', description='The arguments that are used to run the post-processing script.', example='E-HPC cn-hangzhou'),
    script?: string(name='Script', description='The URL that is used to download the post-processing script.', example='http://*****'),
  }(name='ClusterCustomConfiguration', description='The post-processing script of the cluster.', shrink='json', position='Query'),
  clusterDescription?: string(name='ClusterDescription', description='The cluster description. The description must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-serverless-cluster-20240805', position='Query'),
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  clusterName?: string(name='ClusterName', description='The cluster name. The name must be 1 to 128 characters in length and can contain letters, digits, hyphens (-), and underscores (_).', example='slurm22.05.8-serverless-cluster-20240805', position='Query'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection for the cluster. Deletion protection decides whether the cluster can be deleted in the console or by calling the DeleteCluster operation. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  enableScaleIn?: boolean(name='EnableScaleIn', description='Specifies whether to enable auto scale-in for the cluster. Valid values:

*   true
*   false', example='true', position='Query'),
  enableScaleOut?: boolean(name='EnableScaleOut', description='Specifies whether to enable auto scale-out for the cluster. Valid values:

*   true
*   false', example='true', position='Query'),
  growInterval?: int32(name='GrowInterval', description='The interval at which the cluster is automatically scaled out.', example='2', position='Query'),
  idleInterval?: int32(name='IdleInterval', description='The idle duration of the compute nodes allowed by the cluster.', example='4', position='Query'),
  maxCoreCount?: int32(name='MaxCoreCount', description='The total maximum number of vCPUs for use by compute nodes in the cluster. Valid values: 0 to 100,000.', example='10000', position='Query'),
  maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the cluster can manage. Valid values: 0 to 5,000.', example='500', position='Query'),
}

model UpdateClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateClusterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateCluster  UpdateClusterRequest
  * @return UpdateClusterResponse
 */
async function updateCluster(request: UpdateClusterRequest): UpdateClusterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCluster', 'POST', '/', 'json', false, 'json', request);
}

model UpdateNodesRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  instances?: [ 
    {
      instanceId?: string(name='InstanceId', description='The instance ID of the compute node.', example='i-bp1bzqq1ddeemuddn****'),
      keepAlive?: boolean(name='KeepAlive', description='Specifies whether to enable deletion protection for the compute node.', example='true'),
    }
  ](name='Instances', description='The information about the compute nodes that you want to update.', shrink='json', position='Query'),
}

model UpdateNodesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateNodesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNodesResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Before you delete a compute node, we recommend that you export all job data from the node to prevent data loss.
  * @param request  the request parameters of UpdateNodes  UpdateNodesRequest
  * @return UpdateNodesResponse
 */
async function updateNodes(request: UpdateNodesRequest): UpdateNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateNodes', 'POST', '/', 'json', false, 'json', request);
}

model UpdateQueueRequest {
  clusterId?: string(name='ClusterId', description='The cluster ID.

You can call the [ListClusters](https://help.aliyun.com/document_detail/87116.html) operation to query the cluster ID.', example='ehpc-hz-FYUr32****', position='Query'),
  queue?: {
    allocationStrategy?: string(name='AllocationStrategy', description='The policy based on which instance types are selected for compute nodes during auto scale-outs. Valid values:

*   PriorityInstanceType', example='PriorityInstanceType'),
    computeNodes?: [
      NodeTemplate
    ](name='ComputeNodes', description='The hardware configurations of the compute nodes in the queue. Valid values of N: 1 to 10.'),
    enableScaleIn?: boolean(name='EnableScaleIn', description='Specifies whether to enable auto scale-in for the queue. Valid values:

*   true
*   false', example='true'),
    enableScaleOut?: boolean(name='EnableScaleOut', description='Specifies whether to enable auto scale-out for the queue. Valid values:

*   true
*   false', example='true'),
    hostnamePrefix?: string(name='HostnamePrefix', description='The hostname prefix of the compute nodes in the queue.', example='compute'),
    hostnameSuffix?: string(name='HostnameSuffix', description='The hostname suffix of the compute nodes in the queue.', example='hpc'),
    initialCount?: int32(name='InitialCount', description='The initial number of compute nodes in the queue.', example='0'),
    interConnect?: string(name='InterConnect', description='The type of the network for interconnecting compute nodes in the queue.', example='erdma'),
    keepAliveNodes?: [ string ](name='KeepAliveNodes', description='The nodes for which deletion protection is enabled in the queue.'),
    maxCount?: int32(name='MaxCount', description='The maximum number of compute nodes that the queue can contain.', example='1000'),
    maxCountPerCycle?: long(name='MaxCountPerCycle', description='The minimum number of compute nodes that are added to the queue during an automatic scale-out.', example='99'),
    minCount?: int32(name='MinCount', description='The minimum number of compute nodes that the queue must contain.', example='0'),
    queueName: string(name='QueueName', description='The queue name.

This parameter is required.', example='comp'),
    ramRole?: string(name='RamRole', description='The Resource Access Management (RAM) role that is assumed by compute nodes in the queue.', example='AliyunECSInstanceForEHPCRole'),
    vSwitchIds?: [ string ](name='VSwitchIds', description='The vSwitches available for use by compute nodes in the queue.'),
  }(name='Queue', description='The information about the queue to be updated.', shrink='json', position='Query'),
}

model UpdateQueueResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateQueue  UpdateQueueRequest
  * @return UpdateQueueResponse
 */
async function updateQueue(request: UpdateQueueRequest): UpdateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateQueue', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  clusterId: string(name='ClusterId', description='The cluster ID.

This parameter is required.', example='ehpc-hz-FYUr32****', position='Query'),
  group?: string(name='Group', description='The user group attribute of the user that you want to update. Valid values:

*   users: ordinary permissions, which are suitable for ordinary users that need only to submit and debug jobs.
*   wheel: sudo permissions, which are suitable for administrators who need to manage clusters. In addition to submitting and debugging jobs, you can also run sudo commands to install software and restart nodes.', example='users', position='Query'),
  password?: string(name='Password', description='The password attribute of the user that you want to update. The password must be 6 to 30 characters in length and must contain three of the following four character types:

*   Uppercase letters
*   Lowercase letters
*   Digits
*   Special characters ()~!@#$%^&\\*-_+=|{}[]:;\\"/<>,.?/', example='123****', position='Query'),
  userName: string(name='UserName', description='The username.

This parameter is required.', example='testuser', position='Query'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE7****'),
  success?: string(name='Success', description='The request result. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
}

model UpdateUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateUserResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateUser  UpdateUserRequest
  * @return UpdateUserResponse
 */
async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

