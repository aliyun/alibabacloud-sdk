/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('wyota', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateDeviceRequest {
  uuid?: string(name='Uuid'),
}

model ActivateDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ActivateDeviceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateDeviceResponseBody(name='body'),
}

async function activateDeviceWithOptions(request: ActivateDeviceRequest, runtime: Util.RuntimeOptions): ActivateDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ActivateDevice',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateDevice(request: ActivateDeviceRequest): ActivateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateDeviceWithOptions(request, runtime);
}

model AddDeviceFromSNRequest {
  alias?: string(name='Alias'),
  labelContents?: string(name='LabelContents'),
  serialNo?: string(name='SerialNo'),
}

model AddDeviceFromSNResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddDeviceFromSNResponse = {
  headers: map[string]string(name='headers'),
  body: AddDeviceFromSNResponseBody(name='body'),
}

async function addDeviceFromSNWithOptions(request: AddDeviceFromSNRequest, runtime: Util.RuntimeOptions): AddDeviceFromSNResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alias)) {
    body['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.labelContents)) {
    body['LabelContents'] = request.labelContents;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDeviceFromSN',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDeviceFromSN(request: AddDeviceFromSNRequest): AddDeviceFromSNResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDeviceFromSNWithOptions(request, runtime);
}

model AddDevicesFromCSVRequest {
  fileName?: string(name='FileName'),
  fileType?: int32(name='FileType'),
  seatCol?: int32(name='SeatCol'),
  siteId?: string(name='SiteId'),
  siteName?: string(name='SiteName'),
}

model AddDevicesFromCSVResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddDevicesFromCSVResponse = {
  headers: map[string]string(name='headers'),
  body: AddDevicesFromCSVResponseBody(name='body'),
}

async function addDevicesFromCSVWithOptions(request: AddDevicesFromCSVRequest, runtime: Util.RuntimeOptions): AddDevicesFromCSVResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.seatCol)) {
    body['SeatCol'] = request.seatCol;
  }
  if (!Util.isUnset(request.siteId)) {
    body['SiteId'] = request.siteId;
  }
  if (!Util.isUnset(request.siteName)) {
    body['SiteName'] = request.siteName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDevicesFromCSV',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDevicesFromCSV(request: AddDevicesFromCSVRequest): AddDevicesFromCSVResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDevicesFromCSVWithOptions(request, runtime);
}

model AddLabelsRequest {
  labelContents?: string(name='LabelContents'),
}

model AddLabelsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AddLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: AddLabelsResponseBody(name='body'),
}

async function addLabelsWithOptions(request: AddLabelsRequest, runtime: Util.RuntimeOptions): AddLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelContents)) {
    body['LabelContents'] = request.labelContents;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddLabels',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addLabels(request: AddLabelsRequest): AddLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addLabelsWithOptions(request, runtime);
}

model AttachEndUsersRequest {
  endUserIds?: string(name='EndUserIds'),
  serialNo?: string(name='SerialNo'),
}

model AttachEndUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachEndUsersResponse = {
  headers: map[string]string(name='headers'),
  body: AttachEndUsersResponseBody(name='body'),
}

async function attachEndUsersWithOptions(request: AttachEndUsersRequest, runtime: Util.RuntimeOptions): AttachEndUsersResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.endUserIds)) {
    body['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachEndUsers',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachEndUsers(request: AttachEndUsersRequest): AttachEndUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachEndUsersWithOptions(request, runtime);
}

model AttachLabelRequest {
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
  serialNo?: string(name='SerialNo'),
}

model AttachLabelResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachLabelResponse = {
  headers: map[string]string(name='headers'),
  body: AttachLabelResponseBody(name='body'),
}

async function attachLabelWithOptions(request: AttachLabelRequest, runtime: Util.RuntimeOptions): AttachLabelResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachLabel',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachLabel(request: AttachLabelRequest): AttachLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachLabelWithOptions(request, runtime);
}

model AttachLabelsRequest {
  labelIds?: string(name='LabelIds'),
  serialNo?: string(name='SerialNo'),
}

model AttachLabelsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model AttachLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: AttachLabelsResponseBody(name='body'),
}

async function attachLabelsWithOptions(request: AttachLabelsRequest, runtime: Util.RuntimeOptions): AttachLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelIds)) {
    body['LabelIds'] = request.labelIds;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachLabels',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachLabels(request: AttachLabelsRequest): AttachLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachLabelsWithOptions(request, runtime);
}

model CheckUuidValidRequest {
  buildId?: string(name='BuildId'),
  chipId?: string(name='ChipId'),
  clientId?: string(name='ClientId'),
  customId?: string(name='CustomId'),
  serialNo?: string(name='SerialNo'),
  uuid?: string(name='Uuid'),
}

model CheckUuidValidResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CheckUuidValidResponse = {
  headers: map[string]string(name='headers'),
  body: CheckUuidValidResponseBody(name='body'),
}

async function checkUuidValidWithOptions(request: CheckUuidValidRequest, runtime: Util.RuntimeOptions): CheckUuidValidResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.buildId)) {
    body['BuildId'] = request.buildId;
  }
  if (!Util.isUnset(request.chipId)) {
    body['ChipId'] = request.chipId;
  }
  if (!Util.isUnset(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.customId)) {
    body['CustomId'] = request.customId;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  if (!Util.isUnset(request.uuid)) {
    body['Uuid'] = request.uuid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckUuidValid',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUuidValid(request: CheckUuidValidRequest): CheckUuidValidResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkUuidValidWithOptions(request, runtime);
}

model DeleteDevicesRequest {
  force?: string(name='Force'),
  serialNos?: string(name='SerialNos'),
}

model DeleteDevicesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteDevicesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDevicesResponseBody(name='body'),
}

async function deleteDevicesWithOptions(request: DeleteDevicesRequest, runtime: Util.RuntimeOptions): DeleteDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.force)) {
    body['Force'] = request.force;
  }
  if (!Util.isUnset(request.serialNos)) {
    body['SerialNos'] = request.serialNos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevices',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevices(request: DeleteDevicesRequest): DeleteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevicesWithOptions(request, runtime);
}

model DeleteLabelRequest {
  force?: string(name='Force'),
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
}

model DeleteLabelResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteLabelResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLabelResponseBody(name='body'),
}

async function deleteLabelWithOptions(request: DeleteLabelRequest, runtime: Util.RuntimeOptions): DeleteLabelResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.force)) {
    body['Force'] = request.force;
  }
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLabel',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLabel(request: DeleteLabelRequest): DeleteLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLabelWithOptions(request, runtime);
}

model DescribeDeviceSeatsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serialNoList?: [ string ](name='SerialNoList'),
  siteId?: string(name='SiteId'),
  tenantId?: string(name='TenantId'),
}

model DescribeDeviceSeatsShrinkRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serialNoListShrink?: string(name='SerialNoList'),
  siteId?: string(name='SiteId'),
  tenantId?: string(name='TenantId'),
}

model DescribeDeviceSeatsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      seatCol?: int32(name='SeatCol'),
      seatName?: string(name='SeatName'),
      seatNo?: string(name='SeatNo'),
      seatRow?: int32(name='SeatRow'),
      serialNo?: string(name='SerialNo'),
      siteId?: string(name='SiteId'),
      siteName?: string(name='SiteName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model DescribeDeviceSeatsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDeviceSeatsResponseBody(name='body'),
}

async function describeDeviceSeatsWithOptions(tmpReq: DescribeDeviceSeatsRequest, runtime: Util.RuntimeOptions): DescribeDeviceSeatsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeDeviceSeatsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serialNoList)) {
    request.serialNoListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serialNoList, 'SerialNoList', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serialNoListShrink)) {
    body['SerialNoList'] = request.serialNoListShrink;
  }
  if (!Util.isUnset(request.siteId)) {
    body['SiteId'] = request.siteId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDeviceSeats',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDeviceSeats(request: DescribeDeviceSeatsRequest): DescribeDeviceSeatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDeviceSeatsWithOptions(request, runtime);
}

model DetachEndUsersRequest {
  endUserIds?: string(name='EndUserIds'),
  serialNo?: string(name='SerialNo'),
}

model DetachEndUsersResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachEndUsersResponse = {
  headers: map[string]string(name='headers'),
  body: DetachEndUsersResponseBody(name='body'),
}

async function detachEndUsersWithOptions(request: DetachEndUsersRequest, runtime: Util.RuntimeOptions): DetachEndUsersResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.endUserIds)) {
    body['EndUserIds'] = request.endUserIds;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachEndUsers',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachEndUsers(request: DetachEndUsersRequest): DetachEndUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachEndUsersWithOptions(request, runtime);
}

model DetachLabelRequest {
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
  serialNo?: string(name='SerialNo'),
}

model DetachLabelResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachLabelResponse = {
  headers: map[string]string(name='headers'),
  body: DetachLabelResponseBody(name='body'),
}

async function detachLabelWithOptions(request: DetachLabelRequest, runtime: Util.RuntimeOptions): DetachLabelResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachLabel',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachLabel(request: DetachLabelRequest): DetachLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachLabelWithOptions(request, runtime);
}

model DetachLabelsRequest {
  labelIds?: string(name='LabelIds'),
  serialNo?: string(name='SerialNo'),
}

model DetachLabelsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: DetachLabelsResponseBody(name='body'),
}

async function detachLabelsWithOptions(request: DetachLabelsRequest, runtime: Util.RuntimeOptions): DetachLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelIds)) {
    body['LabelIds'] = request.labelIds;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DetachLabels',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachLabels(request: DetachLabelsRequest): DetachLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachLabelsWithOptions(request, runtime);
}

model GetAppOtaLatestVersionRequest {
  baseVersion?: string(name='BaseVersion'),
  clientType?: int32(name='ClientType'),
  clientUid?: string(name='ClientUid'),
  osType?: string(name='OsType'),
  project?: string(name='Project'),
}

model GetAppOtaLatestVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    appVersion?: string(name='AppVersion'),
    downloadUrl?: string(name='DownloadUrl'),
    forceUpgrade?: int32(name='ForceUpgrade'),
    md5?: string(name='Md5'),
    releaseNote?: string(name='ReleaseNote'),
    size?: long(name='Size'),
    taskUid?: string(name='TaskUid'),
    versionCode?: string(name='VersionCode'),
    versionType?: string(name='VersionType'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetAppOtaLatestVersionResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppOtaLatestVersionResponseBody(name='body'),
}

async function getAppOtaLatestVersionWithOptions(request: GetAppOtaLatestVersionRequest, runtime: Util.RuntimeOptions): GetAppOtaLatestVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baseVersion)) {
    query['BaseVersion'] = request.baseVersion;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clientUid)) {
    query['ClientUid'] = request.clientUid;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppOtaLatestVersion',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppOtaLatestVersion(request: GetAppOtaLatestVersionRequest): GetAppOtaLatestVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppOtaLatestVersionWithOptions(request, runtime);
}

model GetDeviceConfigsRequest {
  deviceId?: string(name='DeviceId'),
  userCustomId?: string(name='UserCustomId'),
}

model GetDeviceConfigsResponseBody = {
  code?: string(name='Code'),
  data?: {
    secureNetworkType?: string(name='SecureNetworkType'),
    uuid?: string(name='Uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceConfigsResponseBody(name='body'),
}

async function getDeviceConfigsWithOptions(request: GetDeviceConfigsRequest, runtime: Util.RuntimeOptions): GetDeviceConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.userCustomId)) {
    body['UserCustomId'] = request.userCustomId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceConfigs',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceConfigs(request: GetDeviceConfigsRequest): GetDeviceConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceConfigsWithOptions(request, runtime);
}

model GetDeviceOtaAutoStatusResponseBody = {
  code?: string(name='Code'),
  data?: {
    status?: int32(name='Status'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceOtaAutoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceOtaAutoStatusResponseBody(name='body'),
}

async function getDeviceOtaAutoStatusWithOptions(runtime: Util.RuntimeOptions): GetDeviceOtaAutoStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDeviceOtaAutoStatus',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceOtaAutoStatus(): GetDeviceOtaAutoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceOtaAutoStatusWithOptions(runtime);
}

model GetDeviceOtaInfoRequest {
  baseVersion?: string(name='BaseVersion'),
  deviceId?: string(name='DeviceId'),
  model?: string(name='Model'),
  networkType?: string(name='NetworkType'),
  osVersion?: string(name='OsVersion'),
  region?: string(name='Region'),
  regionId?: string(name='RegionId'),
  targetVersionType?: string(name='TargetVersionType'),
  tenantId?: string(name='TenantId'),
}

model GetDeviceOtaInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    version?: {
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      forceUpgrade?: int32(name='ForceUpgrade'),
      localDownloadUrl?: string(name='LocalDownloadUrl'),
      md5?: string(name='Md5'),
      model?: string(name='Model'),
      releaseNote?: string(name='ReleaseNote'),
      releaseNoteEn?: string(name='ReleaseNoteEn'),
      size?: long(name='Size'),
      version?: string(name='Version'),
      versionCode?: string(name='VersionCode'),
      versionType?: string(name='VersionType'),
    }(name='Version'),
  }(name='Data', description='data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceOtaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceOtaInfoResponseBody(name='body'),
}

async function getDeviceOtaInfoWithOptions(request: GetDeviceOtaInfoRequest, runtime: Util.RuntimeOptions): GetDeviceOtaInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.baseVersion)) {
    body['BaseVersion'] = request.baseVersion;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.networkType)) {
    body['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.osVersion)) {
    body['OsVersion'] = request.osVersion;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.targetVersionType)) {
    body['TargetVersionType'] = request.targetVersionType;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceOtaInfo',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceOtaInfo(request: GetDeviceOtaInfoRequest): GetDeviceOtaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceOtaInfoWithOptions(request, runtime);
}

model GetDeviceOtaInfoTestRequest {
  baseVersion?: string(name='BaseVersion'),
  deviceId?: string(name='DeviceId'),
  model?: string(name='Model'),
  tenantId?: string(name='TenantId'),
}

model GetDeviceOtaInfoTestResponseBody = {
  code?: string(name='Code'),
  data?: {
    version?: {
      creator?: string(name='Creator'),
      downloadUrl?: string(name='DownloadUrl'),
      forceUpgrade?: int32(name='ForceUpgrade'),
      localDownloadUrl?: string(name='LocalDownloadUrl'),
      md5?: string(name='Md5'),
      model?: string(name='Model'),
      releaseNote?: string(name='ReleaseNote'),
      size?: long(name='Size'),
      version?: string(name='Version'),
      versionCode?: string(name='VersionCode'),
      versionType?: string(name='VersionType'),
    }(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceOtaInfoTestResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceOtaInfoTestResponseBody(name='body'),
}

async function getDeviceOtaInfoTestWithOptions(request: GetDeviceOtaInfoTestRequest, runtime: Util.RuntimeOptions): GetDeviceOtaInfoTestResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.baseVersion)) {
    body['BaseVersion'] = request.baseVersion;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceOtaInfoTest',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceOtaInfoTest(request: GetDeviceOtaInfoTestRequest): GetDeviceOtaInfoTestResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceOtaInfoTestWithOptions(request, runtime);
}

model GetDeviceOtaTaskVersionInfoRequest {
  taskId?: string(name='TaskId'),
}

model GetDeviceOtaTaskVersionInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    releaseNote?: string(name='ReleaseNote'),
    size?: long(name='Size'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetDeviceOtaTaskVersionInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetDeviceOtaTaskVersionInfoResponseBody(name='body'),
}

async function getDeviceOtaTaskVersionInfoWithOptions(request: GetDeviceOtaTaskVersionInfoRequest, runtime: Util.RuntimeOptions): GetDeviceOtaTaskVersionInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceOtaTaskVersionInfo',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceOtaTaskVersionInfo(request: GetDeviceOtaTaskVersionInfoRequest): GetDeviceOtaTaskVersionInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceOtaTaskVersionInfoWithOptions(request, runtime);
}

model GetFbOssConfigRequest {
  dirPrefix?: string(name='DirPrefix'),
  isDedicatedLine?: int32(name='IsDedicatedLine'),
  region?: string(name='Region'),
}

model GetFbOssConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    endPoint?: string(name='EndPoint'),
    ossPolicy?: string(name='OssPolicy'),
    ossSignature?: string(name='OssSignature'),
    sessionId?: string(name='SessionId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetFbOssConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetFbOssConfigResponseBody(name='body'),
}

async function getFbOssConfigWithOptions(request: GetFbOssConfigRequest, runtime: Util.RuntimeOptions): GetFbOssConfigResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dirPrefix)) {
    body['DirPrefix'] = request.dirPrefix;
  }
  if (!Util.isUnset(request.isDedicatedLine)) {
    body['IsDedicatedLine'] = request.isDedicatedLine;
  }
  if (!Util.isUnset(request.region)) {
    body['Region'] = request.region;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFbOssConfig',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFbOssConfig(request: GetFbOssConfigRequest): GetFbOssConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFbOssConfigWithOptions(request, runtime);
}

model GetOssConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    endPoint?: string(name='EndPoint'),
    ossPolicy?: string(name='OssPolicy'),
    ossSignature?: string(name='OssSignature'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetOssConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetOssConfigResponseBody(name='body'),
}

async function getOssConfigWithOptions(runtime: Util.RuntimeOptions): GetOssConfigResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetOssConfig',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOssConfig(): GetOssConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssConfigWithOptions(runtime);
}

model ListDeviceOtaTaskByTenantRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDeviceOtaTaskByTenantResponseBody = {
  code?: string(name='Code'),
  data?: {
    tenantDeviceOtaTasks?: [ 
      {
        model?: string(name='Model'),
        operationStatus?: int32(name='OperationStatus'),
        publishTime?: string(name='PublishTime'),
        status?: int32(name='Status'),
        taskId?: int32(name='TaskId'),
        upgradeCount?: long(name='UpgradeCount'),
        version?: string(name='Version'),
      }
    ](name='TenantDeviceOtaTasks'),
  }(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListDeviceOtaTaskByTenantResponse = {
  headers: map[string]string(name='headers'),
  body: ListDeviceOtaTaskByTenantResponseBody(name='body'),
}

async function listDeviceOtaTaskByTenantWithOptions(request: ListDeviceOtaTaskByTenantRequest, runtime: Util.RuntimeOptions): ListDeviceOtaTaskByTenantResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceOtaTaskByTenant',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceOtaTaskByTenant(request: ListDeviceOtaTaskByTenantRequest): ListDeviceOtaTaskByTenantResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceOtaTaskByTenantWithOptions(request, runtime);
}

model ListDevicesRequest {
  alias?: string(name='Alias'),
  buildId?: string(name='BuildId'),
  endUserId?: string(name='EndUserId'),
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
  model?: string(name='Model'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  serialNo?: string(name='SerialNo'),
}

model ListDevicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      activeTime?: string(name='ActiveTime'),
      alias?: string(name='Alias'),
      autoType?: string(name='AutoType'),
      bluetooth?: string(name='Bluetooth'),
      buildId?: string(name='BuildId'),
      clientId?: string(name='ClientId'),
      clientType?: string(name='ClientType'),
      endUserList?: [ 
        {
          bindTime?: string(name='BindTime'),
          endUserId?: string(name='EndUserId'),
          id?: long(name='Id'),
          serialNo?: string(name='SerialNo'),
          tenantId?: string(name='TenantId'),
        }
      ](name='EndUserList'),
      etherMac?: string(name='EtherMac'),
      id?: long(name='Id'),
      isActive?: string(name='IsActive'),
      labelList?: [ 
        {
          content?: string(name='Content'),
          gmtCreate?: long(name='GmtCreate'),
          gmtModified?: long(name='GmtModified'),
          labelId?: string(name='LabelId'),
          tenantId?: string(name='TenantId'),
        }
      ](name='LabelList'),
      model?: string(name='Model'),
      orderId?: string(name='OrderId'),
      secureNetworkType?: string(name='SecureNetworkType'),
      serialNo?: string(name='SerialNo'),
      source?: string(name='Source'),
      tenantId?: string(name='TenantId'),
      uuid?: string(name='Uuid'),
      wlan?: string(name='Wlan'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListDevicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDevicesResponseBody(name='body'),
}

async function listDevicesWithOptions(request: ListDevicesRequest, runtime: Util.RuntimeOptions): ListDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alias)) {
    body['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.buildId)) {
    body['BuildId'] = request.buildId;
  }
  if (!Util.isUnset(request.endUserId)) {
    body['EndUserId'] = request.endUserId;
  }
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevices',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevices(request: ListDevicesRequest): ListDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicesWithOptions(request, runtime);
}

model ListFbIssueLabelsResponseBody = {
  code?: string(name='Code'),
  data?: {
    issueLabel?: [ string ](name='IssueLabel'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListFbIssueLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFbIssueLabelsResponseBody(name='body'),
}

async function listFbIssueLabelsWithOptions(runtime: Util.RuntimeOptions): ListFbIssueLabelsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListFbIssueLabels',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFbIssueLabels(): ListFbIssueLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFbIssueLabelsWithOptions(runtime);
}

model ListFbIssueLabelsByLCRequest {
  caller?: string(name='Caller'),
  languageType?: string(name='LanguageType'),
}

model ListFbIssueLabelsByLCResponseBody = {
  code?: string(name='Code'),
  data?: {
    issueLabel?: [ string ](name='IssueLabel'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListFbIssueLabelsByLCResponse = {
  headers: map[string]string(name='headers'),
  body: ListFbIssueLabelsByLCResponseBody(name='body'),
}

async function listFbIssueLabelsByLCWithOptions(request: ListFbIssueLabelsByLCRequest, runtime: Util.RuntimeOptions): ListFbIssueLabelsByLCResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.caller)) {
    body['Caller'] = request.caller;
  }
  if (!Util.isUnset(request.languageType)) {
    body['LanguageType'] = request.languageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFbIssueLabelsByLC',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFbIssueLabelsByLC(request: ListFbIssueLabelsByLCRequest): ListFbIssueLabelsByLCResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFbIssueLabelsByLCWithOptions(request, runtime);
}

model ListLabelsRequest {
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListLabelsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      content?: string(name='Content'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      labelId?: string(name='LabelId'),
      tenantId?: string(name='TenantId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListLabelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLabelsResponseBody(name='body'),
}

async function listLabelsWithOptions(request: ListLabelsRequest, runtime: Util.RuntimeOptions): ListLabelsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListLabels',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLabels(request: ListLabelsRequest): ListLabelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLabelsWithOptions(request, runtime);
}

model ListTenantDeviceOtaInfoRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  taskId?: int32(name='TaskId'),
}

model ListTenantDeviceOtaInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    tenantDeviceOtaInfos?: [ 
      {
        currentVersion?: string(name='CurrentVersion'),
        deviceId?: string(name='DeviceId'),
        model?: string(name='Model'),
      }
    ](name='TenantDeviceOtaInfos'),
  }(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListTenantDeviceOtaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ListTenantDeviceOtaInfoResponseBody(name='body'),
}

async function listTenantDeviceOtaInfoWithOptions(request: ListTenantDeviceOtaInfoRequest, runtime: Util.RuntimeOptions): ListTenantDeviceOtaInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListTenantDeviceOtaInfo',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTenantDeviceOtaInfo(request: ListTenantDeviceOtaInfoRequest): ListTenantDeviceOtaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTenantDeviceOtaInfoWithOptions(request, runtime);
}

model ListUserFbAcIssuesRequest {
  account?: string(name='Account'),
  clientVersion?: string(name='ClientVersion'),
  errorMessage?: string(name='ErrorMessage'),
  instanceId?: string(name='InstanceId'),
  issueId?: string(name='IssueId'),
  label?: string(name='Label'),
  reservedA?: string(name='ReservedA'),
  reservedB?: string(name='ReservedB'),
  userEmail?: string(name='UserEmail'),
}

model ListUserFbAcIssuesResponseBody = {
  code?: string(name='Code'),
  data?: {
    issueDataList?: [ 
      {
        account?: string(name='Account'),
        clientVersion?: string(name='ClientVersion'),
        errorMessage?: string(name='ErrorMessage'),
        fileList?: [ 
          {
            fileName?: string(name='FileName'),
            fileSize?: int32(name='FileSize'),
            fileType?: int32(name='FileType'),
            sessionId?: string(name='SessionId'),
          }
        ](name='FileList'),
        gmtCreated?: string(name='GmtCreated'),
        gmtModified?: string(name='GmtModified'),
        instanceId?: string(name='InstanceId'),
        issueId?: long(name='IssueId'),
        label?: string(name='Label'),
        reservedA?: string(name='ReservedA'),
        reservedB?: string(name='ReservedB'),
        userEmail?: string(name='UserEmail'),
      }
    ](name='IssueDataList'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListUserFbAcIssuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserFbAcIssuesResponseBody(name='body'),
}

async function listUserFbAcIssuesWithOptions(request: ListUserFbAcIssuesRequest, runtime: Util.RuntimeOptions): ListUserFbAcIssuesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.clientVersion)) {
    body['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.errorMessage)) {
    body['ErrorMessage'] = request.errorMessage;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.issueId)) {
    body['IssueId'] = request.issueId;
  }
  if (!Util.isUnset(request.label)) {
    body['Label'] = request.label;
  }
  if (!Util.isUnset(request.reservedA)) {
    body['ReservedA'] = request.reservedA;
  }
  if (!Util.isUnset(request.reservedB)) {
    body['ReservedB'] = request.reservedB;
  }
  if (!Util.isUnset(request.userEmail)) {
    body['UserEmail'] = request.userEmail;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUserFbAcIssues',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserFbAcIssues(request: ListUserFbAcIssuesRequest): ListUserFbAcIssuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserFbAcIssuesWithOptions(request, runtime);
}

model ListUserFbIssuesRequest {
  appId?: string(name='AppId'),
  clientId?: string(name='ClientId'),
  clientModel?: string(name='ClientModel'),
  clientSn?: string(name='ClientSn'),
  customerId?: string(name='CustomerId'),
  description?: string(name='Description'),
  desktopId?: string(name='DesktopId'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  fbType?: int32(name='FbType'),
  issueId?: int32(name='IssueId'),
  issueLabel?: string(name='IssueLabel'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
  title?: string(name='Title'),
  userEmail?: string(name='UserEmail'),
  userId?: string(name='UserId'),
  wasRead?: int32(name='WasRead'),
}

model ListUserFbIssuesResponseBody = {
  code?: string(name='Code'),
  data?: {
    count?: string(name='Count'),
    feedbackIssueData?: [ 
      {
        appId?: string(name='AppId'),
        clientId?: string(name='ClientId'),
        clientModel?: string(name='ClientModel'),
        clientSn?: string(name='ClientSn'),
        customerId?: string(name='CustomerId'),
        description?: string(name='Description'),
        desktopId?: string(name='DesktopId'),
        errorCode?: string(name='ErrorCode'),
        errorMsg?: string(name='ErrorMsg'),
        fbType?: int32(name='FbType'),
        fileList?: [ 
          {
            fileMd5?: string(name='FileMd5'),
            fileName?: string(name='FileName'),
            fileSize?: int32(name='FileSize'),
            fileType?: int32(name='FileType'),
            ossUrl?: string(name='OssUrl'),
          }
        ](name='FileList'),
        gmtCreated?: string(name='GmtCreated'),
        issueId?: int32(name='IssueId'),
        issueLabel?: string(name='IssueLabel'),
        status?: int32(name='Status'),
        title?: string(name='Title'),
        userEmail?: string(name='UserEmail'),
        userId?: string(name='UserId'),
      }
    ](name='FeedbackIssueData'),
  }(name='Data', description='data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: int32(name='TotalCount'),
}

model ListUserFbIssuesResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserFbIssuesResponseBody(name='body'),
}

async function listUserFbIssuesWithOptions(request: ListUserFbIssuesRequest, runtime: Util.RuntimeOptions): ListUserFbIssuesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientModel)) {
    body['ClientModel'] = request.clientModel;
  }
  if (!Util.isUnset(request.clientSn)) {
    body['ClientSn'] = request.clientSn;
  }
  if (!Util.isUnset(request.customerId)) {
    body['CustomerId'] = request.customerId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopId)) {
    body['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.errorCode)) {
    body['ErrorCode'] = request.errorCode;
  }
  if (!Util.isUnset(request.errorMsg)) {
    body['ErrorMsg'] = request.errorMsg;
  }
  if (!Util.isUnset(request.fbType)) {
    body['FbType'] = request.fbType;
  }
  if (!Util.isUnset(request.issueId)) {
    body['IssueId'] = request.issueId;
  }
  if (!Util.isUnset(request.issueLabel)) {
    body['IssueLabel'] = request.issueLabel;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userEmail)) {
    body['UserEmail'] = request.userEmail;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.wasRead)) {
    body['WasRead'] = request.wasRead;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUserFbIssues',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserFbIssues(request: ListUserFbIssuesRequest): ListUserFbIssuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserFbIssuesWithOptions(request, runtime);
}

model ModifyDevicesSecureNetworkTypeRequest {
  allDevices?: long(name='AllDevices'),
  secureNetworkType?: string(name='SecureNetworkType'),
  serialNos?: string(name='SerialNos'),
}

model ModifyDevicesSecureNetworkTypeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyDevicesSecureNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDevicesSecureNetworkTypeResponseBody(name='body'),
}

async function modifyDevicesSecureNetworkTypeWithOptions(request: ModifyDevicesSecureNetworkTypeRequest, runtime: Util.RuntimeOptions): ModifyDevicesSecureNetworkTypeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.allDevices)) {
    body['AllDevices'] = request.allDevices;
  }
  if (!Util.isUnset(request.secureNetworkType)) {
    body['SecureNetworkType'] = request.secureNetworkType;
  }
  if (!Util.isUnset(request.serialNos)) {
    body['SerialNos'] = request.serialNos;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDevicesSecureNetworkType',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDevicesSecureNetworkType(request: ModifyDevicesSecureNetworkTypeRequest): ModifyDevicesSecureNetworkTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDevicesSecureNetworkTypeWithOptions(request, runtime);
}

model ModifySecureNetworkTypeRequest {
  secureNetworkType?: string(name='SecureNetworkType'),
  serialNo?: string(name='SerialNo'),
}

model ModifySecureNetworkTypeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifySecureNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecureNetworkTypeResponseBody(name='body'),
}

async function modifySecureNetworkTypeWithOptions(request: ModifySecureNetworkTypeRequest, runtime: Util.RuntimeOptions): ModifySecureNetworkTypeResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.secureNetworkType)) {
    body['SecureNetworkType'] = request.secureNetworkType;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecureNetworkType',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecureNetworkType(request: ModifySecureNetworkTypeRequest): ModifySecureNetworkTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecureNetworkTypeWithOptions(request, runtime);
}

model RegisterDeviceRequest {
  bluetooth?: string(name='Bluetooth'),
  buildId?: string(name='BuildId'),
  chipId?: string(name='ChipId'),
  clientId?: string(name='ClientId'),
  clientType?: int32(name='ClientType'),
  cpu?: string(name='Cpu'),
  customId?: string(name='CustomId'),
  etherMac?: string(name='EtherMac'),
  memory?: string(name='Memory'),
  model?: string(name='Model'),
  serialNo?: string(name='SerialNo'),
  storage?: string(name='Storage'),
  token?: string(name='Token'),
  wlan?: string(name='Wlan'),
}

model RegisterDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    uuid?: string(name='Uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model RegisterDeviceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterDeviceResponseBody(name='body'),
}

async function registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: Util.RuntimeOptions): RegisterDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.bluetooth)) {
    body['Bluetooth'] = request.bluetooth;
  }
  if (!Util.isUnset(request.buildId)) {
    body['BuildId'] = request.buildId;
  }
  if (!Util.isUnset(request.chipId)) {
    body['ChipId'] = request.chipId;
  }
  if (!Util.isUnset(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    body['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.cpu)) {
    body['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.customId)) {
    body['CustomId'] = request.customId;
  }
  if (!Util.isUnset(request.etherMac)) {
    body['EtherMac'] = request.etherMac;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  if (!Util.isUnset(request.storage)) {
    body['Storage'] = request.storage;
  }
  if (!Util.isUnset(request.token)) {
    body['Token'] = request.token;
  }
  if (!Util.isUnset(request.wlan)) {
    body['Wlan'] = request.wlan;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDevice',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerDevice(request: RegisterDeviceRequest): RegisterDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceWithOptions(request, runtime);
}

model ReportAppOtaInfoRequest {
  baseVersion?: string(name='BaseVersion'),
  clientType?: int32(name='ClientType'),
  clientUid?: string(name='ClientUid'),
  note?: string(name='Note'),
  osType?: string(name='OsType'),
  project?: string(name='Project'),
  status?: int32(name='Status'),
  targetVersion?: string(name='TargetVersion'),
  taskUid?: string(name='TaskUid'),
}

model ReportAppOtaInfoResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReportAppOtaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ReportAppOtaInfoResponseBody(name='body'),
}

async function reportAppOtaInfoWithOptions(request: ReportAppOtaInfoRequest, runtime: Util.RuntimeOptions): ReportAppOtaInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.baseVersion)) {
    query['BaseVersion'] = request.baseVersion;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clientUid)) {
    query['ClientUid'] = request.clientUid;
  }
  if (!Util.isUnset(request.note)) {
    query['Note'] = request.note;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.project)) {
    query['Project'] = request.project;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetVersion)) {
    query['TargetVersion'] = request.targetVersion;
  }
  if (!Util.isUnset(request.taskUid)) {
    query['TaskUid'] = request.taskUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReportAppOtaInfo',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportAppOtaInfo(request: ReportAppOtaInfoRequest): ReportAppOtaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportAppOtaInfoWithOptions(request, runtime);
}

model ReportDeviceOtaInfoRequest {
  baseVersion?: string(name='BaseVersion'),
  deviceId?: string(name='DeviceId'),
  model?: string(name='Model'),
  note?: string(name='Note'),
  status?: int32(name='Status'),
  targetVersion?: string(name='TargetVersion'),
}

model ReportDeviceOtaInfoResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReportDeviceOtaInfoResponse = {
  headers: map[string]string(name='headers'),
  body: ReportDeviceOtaInfoResponseBody(name='body'),
}

async function reportDeviceOtaInfoWithOptions(request: ReportDeviceOtaInfoRequest, runtime: Util.RuntimeOptions): ReportDeviceOtaInfoResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.baseVersion)) {
    body['BaseVersion'] = request.baseVersion;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.note)) {
    body['Note'] = request.note;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.targetVersion)) {
    body['TargetVersion'] = request.targetVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportDeviceOtaInfo',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportDeviceOtaInfo(request: ReportDeviceOtaInfoRequest): ReportDeviceOtaInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportDeviceOtaInfoWithOptions(request, runtime);
}

model ReportUserFbAcIssueRequest {
  account?: string(name='Account'),
  clientVersion?: string(name='ClientVersion'),
  errorMsg?: string(name='ErrorMsg'),
  fileList?: [ 
    {
      fileName?: string(name='FileName'),
      fileSize?: int32(name='FileSize'),
      fileType?: int32(name='FileType'),
      sessionId?: string(name='SessionId'),
    }
  ](name='FileList'),
  instanceId?: string(name='InstanceId'),
  labels?: string(name='Labels'),
  reservedA?: string(name='ReservedA'),
  reservedB?: string(name='ReservedB'),
  userEmail?: string(name='UserEmail'),
}

model ReportUserFbAcIssueShrinkRequest {
  account?: string(name='Account'),
  clientVersion?: string(name='ClientVersion'),
  errorMsg?: string(name='ErrorMsg'),
  fileListShrink?: string(name='FileList'),
  instanceId?: string(name='InstanceId'),
  labels?: string(name='Labels'),
  reservedA?: string(name='ReservedA'),
  reservedB?: string(name='ReservedB'),
  userEmail?: string(name='UserEmail'),
}

model ReportUserFbAcIssueResponseBody = {
  code?: string(name='Code'),
  data?: {
    issueId?: long(name='IssueId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReportUserFbAcIssueResponse = {
  headers: map[string]string(name='headers'),
  body: ReportUserFbAcIssueResponseBody(name='body'),
}

async function reportUserFbAcIssueWithOptions(tmpReq: ReportUserFbAcIssueRequest, runtime: Util.RuntimeOptions): ReportUserFbAcIssueResponse {
  Util.validateModel(tmpReq);
  var request = new ReportUserFbAcIssueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fileList)) {
    request.fileListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileList, 'FileList', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.account)) {
    body['Account'] = request.account;
  }
  if (!Util.isUnset(request.clientVersion)) {
    body['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.errorMsg)) {
    body['ErrorMsg'] = request.errorMsg;
  }
  if (!Util.isUnset(request.fileListShrink)) {
    body['FileList'] = request.fileListShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.labels)) {
    body['Labels'] = request.labels;
  }
  if (!Util.isUnset(request.reservedA)) {
    body['ReservedA'] = request.reservedA;
  }
  if (!Util.isUnset(request.reservedB)) {
    body['ReservedB'] = request.reservedB;
  }
  if (!Util.isUnset(request.userEmail)) {
    body['UserEmail'] = request.userEmail;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportUserFbAcIssue',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportUserFbAcIssue(request: ReportUserFbAcIssueRequest): ReportUserFbAcIssueResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportUserFbAcIssueWithOptions(request, runtime);
}

model ReportUserFbIssueRequest {
  appId?: string(name='AppId'),
  clientId?: string(name='ClientId'),
  clientModel?: string(name='ClientModel'),
  clientOsName?: string(name='ClientOsName'),
  clientSn?: string(name='ClientSn'),
  clientVersion?: string(name='ClientVersion'),
  customerId?: string(name='CustomerId'),
  description?: string(name='Description'),
  desktopId?: string(name='DesktopId'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  fbType?: int32(name='FbType'),
  fileList?: [ 
    {
      fileMd5?: string(name='FileMd5'),
      fileName?: string(name='FileName'),
      fileSize?: int32(name='FileSize'),
      fileType?: int32(name='FileType'),
      ossUrl?: string(name='OssUrl'),
      sessionId?: string(name='SessionId'),
    }
  ](name='FileList'),
  issueLabel?: string(name='IssueLabel'),
  occurTime?: long(name='OccurTime'),
  reservedA?: string(name='ReservedA'),
  reservedB?: string(name='ReservedB'),
  title?: string(name='Title'),
  userEmail?: string(name='UserEmail'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
  workspaceId?: string(name='WorkspaceId'),
}

model ReportUserFbIssueShrinkRequest {
  appId?: string(name='AppId'),
  clientId?: string(name='ClientId'),
  clientModel?: string(name='ClientModel'),
  clientOsName?: string(name='ClientOsName'),
  clientSn?: string(name='ClientSn'),
  clientVersion?: string(name='ClientVersion'),
  customerId?: string(name='CustomerId'),
  description?: string(name='Description'),
  desktopId?: string(name='DesktopId'),
  errorCode?: string(name='ErrorCode'),
  errorMsg?: string(name='ErrorMsg'),
  fbType?: int32(name='FbType'),
  fileListShrink?: string(name='FileList'),
  issueLabel?: string(name='IssueLabel'),
  occurTime?: long(name='OccurTime'),
  reservedA?: string(name='ReservedA'),
  reservedB?: string(name='ReservedB'),
  title?: string(name='Title'),
  userEmail?: string(name='UserEmail'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
  workspaceId?: string(name='WorkspaceId'),
}

model ReportUserFbIssueResponseBody = {
  code?: string(name='Code'),
  data?: {
    issueId?: int32(name='IssueId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ReportUserFbIssueResponse = {
  headers: map[string]string(name='headers'),
  body: ReportUserFbIssueResponseBody(name='body'),
}

async function reportUserFbIssueWithOptions(tmpReq: ReportUserFbIssueRequest, runtime: Util.RuntimeOptions): ReportUserFbIssueResponse {
  Util.validateModel(tmpReq);
  var request = new ReportUserFbIssueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.fileList)) {
    request.fileListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileList, 'FileList', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientId)) {
    body['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientModel)) {
    body['ClientModel'] = request.clientModel;
  }
  if (!Util.isUnset(request.clientOsName)) {
    body['ClientOsName'] = request.clientOsName;
  }
  if (!Util.isUnset(request.clientSn)) {
    body['ClientSn'] = request.clientSn;
  }
  if (!Util.isUnset(request.clientVersion)) {
    body['ClientVersion'] = request.clientVersion;
  }
  if (!Util.isUnset(request.customerId)) {
    body['CustomerId'] = request.customerId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.desktopId)) {
    body['DesktopId'] = request.desktopId;
  }
  if (!Util.isUnset(request.errorCode)) {
    body['ErrorCode'] = request.errorCode;
  }
  if (!Util.isUnset(request.errorMsg)) {
    body['ErrorMsg'] = request.errorMsg;
  }
  if (!Util.isUnset(request.fbType)) {
    body['FbType'] = request.fbType;
  }
  if (!Util.isUnset(request.fileListShrink)) {
    body['FileList'] = request.fileListShrink;
  }
  if (!Util.isUnset(request.issueLabel)) {
    body['IssueLabel'] = request.issueLabel;
  }
  if (!Util.isUnset(request.occurTime)) {
    body['OccurTime'] = request.occurTime;
  }
  if (!Util.isUnset(request.reservedA)) {
    body['ReservedA'] = request.reservedA;
  }
  if (!Util.isUnset(request.reservedB)) {
    body['ReservedB'] = request.reservedB;
  }
  if (!Util.isUnset(request.title)) {
    body['Title'] = request.title;
  }
  if (!Util.isUnset(request.userEmail)) {
    body['UserEmail'] = request.userEmail;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ReportUserFbIssue',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reportUserFbIssue(request: ReportUserFbIssueRequest): ReportUserFbIssueResponse {
  var runtime = new Util.RuntimeOptions{};
  return reportUserFbIssueWithOptions(request, runtime);
}

model SetDeviceOtaAutoStatusRequest {
  status?: string(name='Status'),
}

model SetDeviceOtaAutoStatusResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetDeviceOtaAutoStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDeviceOtaAutoStatusResponseBody(name='body'),
}

async function setDeviceOtaAutoStatusWithOptions(request: SetDeviceOtaAutoStatusRequest, runtime: Util.RuntimeOptions): SetDeviceOtaAutoStatusResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetDeviceOtaAutoStatus',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDeviceOtaAutoStatus(request: SetDeviceOtaAutoStatusRequest): SetDeviceOtaAutoStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeviceOtaAutoStatusWithOptions(request, runtime);
}

model SetDeviceOtaTaskStatusRequest {
  operationStatus?: int32(name='OperationStatus'),
  taskId?: int32(name='TaskId'),
}

model SetDeviceOtaTaskStatusResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model SetDeviceOtaTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: SetDeviceOtaTaskStatusResponseBody(name='body'),
}

async function setDeviceOtaTaskStatusWithOptions(request: SetDeviceOtaTaskStatusRequest, runtime: Util.RuntimeOptions): SetDeviceOtaTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.operationStatus)) {
    body['OperationStatus'] = request.operationStatus;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetDeviceOtaTaskStatus',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDeviceOtaTaskStatus(request: SetDeviceOtaTaskStatusRequest): SetDeviceOtaTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDeviceOtaTaskStatusWithOptions(request, runtime);
}

model UnbindDeviceSeatsRequest {
  serialNoList?: [ string ](name='SerialNoList'),
}

model UnbindDeviceSeatsShrinkRequest {
  serialNoListShrink?: string(name='SerialNoList'),
}

model UnbindDeviceSeatsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UnbindDeviceSeatsResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindDeviceSeatsResponseBody(name='body'),
}

async function unbindDeviceSeatsWithOptions(tmpReq: UnbindDeviceSeatsRequest, runtime: Util.RuntimeOptions): UnbindDeviceSeatsResponse {
  Util.validateModel(tmpReq);
  var request = new UnbindDeviceSeatsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serialNoList)) {
    request.serialNoListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serialNoList, 'SerialNoList', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.serialNoListShrink)) {
    body['SerialNoList'] = request.serialNoListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindDeviceSeats',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindDeviceSeats(request: UnbindDeviceSeatsRequest): UnbindDeviceSeatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindDeviceSeatsWithOptions(request, runtime);
}

model UpdateAliasRequest {
  alias?: string(name='Alias'),
  serialNo?: string(name='SerialNo'),
}

model UpdateAliasResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateAliasResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAliasResponseBody(name='body'),
}

async function updateAliasWithOptions(request: UpdateAliasRequest, runtime: Util.RuntimeOptions): UpdateAliasResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alias)) {
    body['Alias'] = request.alias;
  }
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAlias',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAlias(request: UpdateAliasRequest): UpdateAliasResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAliasWithOptions(request, runtime);
}

model UpdateDeviceBindedEndUserRequest {
  serialNo?: string(name='SerialNo'),
  sourceEndUserIds?: string(name='SourceEndUserIds'),
  targetEndUserIds?: string(name='TargetEndUserIds'),
}

model UpdateDeviceBindedEndUserResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateDeviceBindedEndUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDeviceBindedEndUserResponseBody(name='body'),
}

async function updateDeviceBindedEndUserWithOptions(request: UpdateDeviceBindedEndUserRequest, runtime: Util.RuntimeOptions): UpdateDeviceBindedEndUserResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.serialNo)) {
    body['SerialNo'] = request.serialNo;
  }
  if (!Util.isUnset(request.sourceEndUserIds)) {
    body['SourceEndUserIds'] = request.sourceEndUserIds;
  }
  if (!Util.isUnset(request.targetEndUserIds)) {
    body['TargetEndUserIds'] = request.targetEndUserIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceBindedEndUser',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceBindedEndUser(request: UpdateDeviceBindedEndUserRequest): UpdateDeviceBindedEndUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceBindedEndUserWithOptions(request, runtime);
}

model UpdateLabelRequest {
  labelContent?: string(name='LabelContent'),
  labelId?: string(name='LabelId'),
}

model UpdateLabelResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateLabelResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLabelResponseBody(name='body'),
}

async function updateLabelWithOptions(request: UpdateLabelRequest, runtime: Util.RuntimeOptions): UpdateLabelResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.labelContent)) {
    body['LabelContent'] = request.labelContent;
  }
  if (!Util.isUnset(request.labelId)) {
    body['LabelId'] = request.labelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLabel',
    version = '2021-04-20',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLabel(request: UpdateLabelRequest): UpdateLabelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLabelWithOptions(request, runtime);
}

