/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ververica', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Artifact {
  jarArtifact?: JarArtifact(name='jarArtifact'),
  kind?: string(name='kind'),
  pythonArtifact?: PythonArtifact(name='pythonArtifact'),
  sqlArtifact?: SqlArtifact(name='sqlArtifact'),
}

model AsyncResourcePlanOperationResult {
  message?: string(name='message'),
  plan?: string(name='plan'),
  ticketStatus?: string(name='ticketStatus'),
}

model BasicResourceSetting {
  jobmanagerResourceSettingSpec?: BasicResourceSettingSpec(name='jobmanagerResourceSettingSpec'),
  parallelism?: long(name='parallelism'),
  taskmanagerResourceSettingSpec?: BasicResourceSettingSpec(name='taskmanagerResourceSettingSpec'),
}

model BasicResourceSettingSpec {
  cpu?: double(name='cpu'),
  memory?: string(name='memory'),
}

model BatchResourceSetting {
  basicResourceSetting?: BasicResourceSetting(name='basicResourceSetting'),
  maxSlot?: long(name='maxSlot'),
}

model BriefDeploymentTarget {
  mode?: string(name='mode'),
  name?: string(name='name'),
}

model BriefResourceSetting {
  batchResourceSetting?: BatchResourceSetting(name='batchResourceSetting'),
  flinkConf?: map[string]any(name='flinkConf'),
  streamingResourceSetting?: StreamingResourceSetting(name='streamingResourceSetting'),
}

model Deployment {
  artifact?: Artifact(name='artifact'),
  deploymentHasChanged?: boolean(name='deploymentHasChanged'),
  deploymentId?: string(name='deploymentId'),
  deploymentTarget?: BriefDeploymentTarget(name='deploymentTarget'),
  description?: string(name='description'),
  engineVersion?: string(name='engineVersion'),
  executionMode?: string(name='executionMode'),
  flinkConf?: map[string]any(name='flinkConf'),
  jobSummary?: JobSummary(name='jobSummary'),
  logging?: Logging(name='logging'),
  name?: string(name='name'),
  namespace?: string(name='namespace'),
}

model DeploymentRestoreStrategy {
  allowNonRestoredState?: boolean(name='allowNonRestoredState'),
  jobStartTimeInMs?: long(name='jobStartTimeInMs'),
  kind?: string(name='kind'),
  savepointId?: string(name='savepointId'),
}

model DeploymentTarget {
  name?: string(name='name'),
  namespace?: string(name='namespace'),
}

model EngineVersionMetadata {
  engineVersion?: string(name='engineVersion'),
  features?: EngineVersionSupportedFeatures(name='features'),
  status?: string(name='status'),
}

model EngineVersionMetadataIndex {
  defaultEngineVersion?: string(name='defaultEngineVersion'),
  engineVersionMetadata?: [
    EngineVersionMetadata
  ](name='engineVersionMetadata'),
}

model EngineVersionSupportedFeatures {
  supportNativeSavepoint?: boolean(name='supportNativeSavepoint'),
  useForSqlDeployments?: boolean(name='useForSqlDeployments'),
}

model ExpertResourceSetting {
  jobmanagerResourceSettingSpec?: BasicResourceSettingSpec(name='jobmanagerResourceSettingSpec'),
  resourcePlan?: string(name='resourcePlan'),
}

model JarArtifact {
  additionalDependencies?: [ string ](name='additionalDependencies'),
  entryClass?: string(name='entryClass'),
  jarUri?: string(name='jarUri'),
  mainArgs?: string(name='mainArgs'),
}

model Job {
  artifact?: Artifact(name='artifact'),
  batchResourceSetting?: BatchResourceSetting(name='batchResourceSetting'),
  deploymentId?: string(name='deploymentId'),
  deploymentName?: string(name='deploymentName'),
  endTime?: long(name='endTime'),
  engineVersion?: string(name='engineVersion'),
  executionMode?: string(name='executionMode'),
  flinkConf?: map[string]any(name='flinkConf'),
  jobId?: string(name='jobId'),
  logging?: Logging(name='logging'),
  metric?: JobMetric(name='metric'),
  namespace?: string(name='namespace'),
  restoreStrategy?: DeploymentRestoreStrategy(name='restoreStrategy'),
  sessionClusterName?: string(name='sessionClusterName'),
  startTime?: long(name='startTime'),
  status?: JobStatus(name='status'),
  streamingResourceSetting?: StreamingResourceSetting(name='streamingResourceSetting'),
}

model JobFailure {
  failedAt?: long(name='failedAt'),
  message?: string(name='message'),
  reason?: string(name='reason'),
}

model JobMetric {
  totalCpu?: double(name='totalCpu'),
  totalMemoryByte?: long(name='totalMemoryByte'),
}

model JobStatus {
  currentJobStatus?: string(name='currentJobStatus'),
  failure?: JobFailure(name='failure'),
  running?: JobStatusRunning(name='running'),
}

model JobStatusRunning {
  observedFlinkJobRestarts?: long(name='observedFlinkJobRestarts'),
  observedFlinkJobStatus?: string(name='observedFlinkJobStatus'),
}

model JobSummary {
  cancelled?: int32(name='cancelled'),
  cancelling?: int32(name='cancelling'),
  failed?: int32(name='failed'),
  finished?: int32(name='finished'),
  running?: int32(name='running'),
  starting?: int32(name='starting'),
}

model Log4jLogger {
  loggerLevel?: string(name='loggerLevel'),
  loggerName?: string(name='loggerName'),
}

model LogReservePolicy {
  expirationDays?: long(name='expirationDays'),
  openHistory?: boolean(name='openHistory'),
}

model Logging {
  log4j2ConfigurationTemplate?: string(name='log4j2ConfigurationTemplate'),
  log4jLoggers?: [
    Log4jLogger
  ](name='log4jLoggers'),
  logReservePolicy?: LogReservePolicy(name='logReservePolicy'),
  loggingProfile?: string(name='loggingProfile'),
}

model PythonArtifact {
  additionalDependencies?: [ string ](name='additionalDependencies'),
  additionalPythonArchives?: [ string ](name='additionalPythonArchives'),
  additionalPythonLibraries?: [ string ](name='additionalPythonLibraries'),
  entryModule?: string(name='entryModule'),
  mainArgs?: string(name='mainArgs'),
  pythonArtifactUri?: string(name='pythonArtifactUri'),
}

model Savepoint {
  createdAt?: long(name='createdAt'),
  deploymentId?: string(name='deploymentId'),
  description?: string(name='description'),
  jobId?: string(name='jobId'),
  modifiedAt?: long(name='modifiedAt'),
  namespace?: string(name='namespace'),
  nativeFormat?: boolean(name='nativeFormat'),
  savepointId?: string(name='savepointId'),
  savepointLocation?: string(name='savepointLocation'),
  savepointOrigin?: string(name='savepointOrigin'),
  status?: SavepointStatus(name='status'),
  stopWithDrainEnabled?: boolean(name='stopWithDrainEnabled'),
}

model SavepointFailure {
  failedAt?: long(name='failedAt'),
  message?: string(name='message'),
  reason?: string(name='reason'),
}

model SavepointStatus {
  failure?: SavepointFailure(name='failure'),
  state?: string(name='state'),
}

model SqlArtifact {
  additionalDependencies?: [ string ](name='additionalDependencies'),
  sqlScript?: string(name='sqlScript'),
}

model StartJobRequestBody {
  deploymentId?: string(name='deploymentId'),
  resourceSettingSpec?: BriefResourceSetting(name='resourceSettingSpec'),
  restoreStrategy?: DeploymentRestoreStrategy(name='restoreStrategy'),
}

model StopJobRequestBody {
  stopStrategy?: string(name='stopStrategy'),
}

model StreamingResourceSetting {
  basicResourceSetting?: BasicResourceSetting(name='basicResourceSetting'),
  expertResourceSetting?: ExpertResourceSetting(name='expertResourceSetting'),
  resourceSettingMode?: string(name='resourceSettingMode'),
}

model Variable {
  description?: string(name='description'),
  kind?: string(name='kind'),
  name?: string(name='name'),
  value?: string(name='value'),
}

model CreateDeploymentHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model CreateDeploymentRequest {
  body?: Deployment(name='body'),
}

model CreateDeploymentResponseBody = {
  data?: Deployment(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeploymentResponseBody(name='body'),
}

async function createDeployment(namespace: string, request: CreateDeploymentRequest): CreateDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateDeploymentHeaders{};
  return createDeploymentWithOptions(namespace, request, headers, runtime);
}

async function createDeploymentWithOptions(namespace: string, request: CreateDeploymentRequest, headers: CreateDeploymentHeaders, runtime: Util.RuntimeOptions): CreateDeploymentResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeployment',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSavepointHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model CreateSavepointRequest {
  deploymentId?: string(name='deploymentId'),
  description?: string(name='description'),
  nativeFormat?: boolean(name='nativeFormat'),
}

model CreateSavepointResponseBody = {
  data?: Savepoint(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateSavepointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSavepointResponseBody(name='body'),
}

async function createSavepoint(namespace: string, request: CreateSavepointRequest): CreateSavepointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateSavepointHeaders{};
  return createSavepointWithOptions(namespace, request, headers, runtime);
}

async function createSavepointWithOptions(namespace: string, request: CreateSavepointRequest, headers: CreateSavepointHeaders, runtime: Util.RuntimeOptions): CreateSavepointResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    body['deploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.nativeFormat)) {
    body['nativeFormat'] = request.nativeFormat;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavepoint',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateVariableHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model CreateVariableRequest {
  body?: Variable(name='body'),
}

model CreateVariableResponseBody = {
  data?: Variable(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CreateVariableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVariableResponseBody(name='body'),
}

async function createVariable(namespace: string, request: CreateVariableRequest): CreateVariableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new CreateVariableHeaders{};
  return createVariableWithOptions(namespace, request, headers, runtime);
}

async function createVariableWithOptions(namespace: string, request: CreateVariableRequest, headers: CreateVariableHeaders, runtime: Util.RuntimeOptions): CreateVariableResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVariable',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/variables`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDeploymentHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model DeleteDeploymentResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeploymentResponseBody(name='body'),
}

async function deleteDeployment(namespace: string, deploymentId: string): DeleteDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteDeploymentHeaders{};
  return deleteDeploymentWithOptions(namespace, deploymentId, headers, runtime);
}

async function deleteDeploymentWithOptions(namespace: string, deploymentId: string, headers: DeleteDeploymentHeaders, runtime: Util.RuntimeOptions): DeleteDeploymentResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeployment',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteJobHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model DeleteJobResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJob(namespace: string, jobId: string): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteJobHeaders{};
  return deleteJobWithOptions(namespace, jobId, headers, runtime);
}

async function deleteJobWithOptions(namespace: string, jobId: string, headers: DeleteJobHeaders, runtime: Util.RuntimeOptions): DeleteJobResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSavepointHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model DeleteSavepointResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteSavepointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSavepointResponseBody(name='body'),
}

async function deleteSavepoint(namespace: string, savepointId: string): DeleteSavepointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteSavepointHeaders{};
  return deleteSavepointWithOptions(namespace, savepointId, headers, runtime);
}

async function deleteSavepointWithOptions(namespace: string, savepointId: string, headers: DeleteSavepointHeaders, runtime: Util.RuntimeOptions): DeleteSavepointResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSavepoint',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints/${OpenApiUtil.getEncodeParam(savepointId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteVariableHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model DeleteVariableResponseBody = {
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model DeleteVariableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVariableResponseBody(name='body'),
}

async function deleteVariable(namespace: string, name: string): DeleteVariableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new DeleteVariableHeaders{};
  return deleteVariableWithOptions(namespace, name, headers, runtime);
}

async function deleteVariableWithOptions(namespace: string, name: string, headers: DeleteVariableHeaders, runtime: Util.RuntimeOptions): DeleteVariableResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'DeleteVariable',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/variables/${OpenApiUtil.getEncodeParam(name)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FlinkApiProxyHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model FlinkApiProxyRequest {
  flinkApiPath?: string(name='flinkApiPath'),
  namespace?: string(name='namespace'),
  resourceId?: string(name='resourceId'),
  resourceType?: string(name='resourceType'),
}

model FlinkApiProxyResponseBody = {
  data?: string(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model FlinkApiProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FlinkApiProxyResponseBody(name='body'),
}

async function flinkApiProxy(request: FlinkApiProxyRequest): FlinkApiProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new FlinkApiProxyHeaders{};
  return flinkApiProxyWithOptions(request, headers, runtime);
}

async function flinkApiProxyWithOptions(request: FlinkApiProxyRequest, headers: FlinkApiProxyHeaders, runtime: Util.RuntimeOptions): FlinkApiProxyResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.flinkApiPath)) {
    query['flinkApiPath'] = request.flinkApiPath;
  }
  if (!Util.isUnset(request.namespace)) {
    query['namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['resourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['resourceType'] = request.resourceType;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FlinkApiProxy',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/flink-ui/v2/proxy`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GenerateResourcePlanWithFlinkConfAsyncHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model GenerateResourcePlanWithFlinkConfAsyncRequest {
  body?: map[string]any(name='body'),
}

model GenerateResourcePlanWithFlinkConfAsyncResponseBody = {
  data?: {
    ticketId?: string(name='ticketId'),
  }(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GenerateResourcePlanWithFlinkConfAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateResourcePlanWithFlinkConfAsyncResponseBody(name='body'),
}

async function generateResourcePlanWithFlinkConfAsync(namespace: string, deploymentId: string, request: GenerateResourcePlanWithFlinkConfAsyncRequest): GenerateResourcePlanWithFlinkConfAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GenerateResourcePlanWithFlinkConfAsyncHeaders{};
  return generateResourcePlanWithFlinkConfAsyncWithOptions(namespace, deploymentId, request, headers, runtime);
}

async function generateResourcePlanWithFlinkConfAsyncWithOptions(namespace: string, deploymentId: string, request: GenerateResourcePlanWithFlinkConfAsyncRequest, headers: GenerateResourcePlanWithFlinkConfAsyncHeaders, runtime: Util.RuntimeOptions): GenerateResourcePlanWithFlinkConfAsyncResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GenerateResourcePlanWithFlinkConfAsync',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}/resource-plan%3AasyncGenerate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeploymentHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model GetDeploymentResponseBody = {
  data?: Deployment(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentResponseBody(name='body'),
}

async function getDeployment(namespace: string, deploymentId: string): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetDeploymentHeaders{};
  return getDeploymentWithOptions(namespace, deploymentId, headers, runtime);
}

async function getDeploymentWithOptions(namespace: string, deploymentId: string, headers: GetDeploymentHeaders, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetGenerateResourcePlanResultHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model GetGenerateResourcePlanResultResponseBody = {
  data?: AsyncResourcePlanOperationResult(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetGenerateResourcePlanResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGenerateResourcePlanResultResponseBody(name='body'),
}

async function getGenerateResourcePlanResult(namespace: string, ticketId: string): GetGenerateResourcePlanResultResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetGenerateResourcePlanResultHeaders{};
  return getGenerateResourcePlanResultWithOptions(namespace, ticketId, headers, runtime);
}

async function getGenerateResourcePlanResultWithOptions(namespace: string, ticketId: string, headers: GetGenerateResourcePlanResultHeaders, runtime: Util.RuntimeOptions): GetGenerateResourcePlanResultResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetGenerateResourcePlanResult',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/tickets/${OpenApiUtil.getEncodeParam(ticketId)}/resource-plan%3AasyncGenerate`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetJobHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model GetJobResponseBody = {
  data?: Job(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobResponseBody(name='body'),
}

async function getJob(namespace: string, jobId: string): GetJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetJobHeaders{};
  return getJobWithOptions(namespace, jobId, headers, runtime);
}

async function getJobWithOptions(namespace: string, jobId: string, headers: GetJobHeaders, runtime: Util.RuntimeOptions): GetJobResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetJob',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetSavepointHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model GetSavepointResponseBody = {
  data?: Savepoint(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model GetSavepointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSavepointResponseBody(name='body'),
}

async function getSavepoint(namespace: string, savepointId: string): GetSavepointResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new GetSavepointHeaders{};
  return getSavepointWithOptions(namespace, savepointId, headers, runtime);
}

async function getSavepointWithOptions(namespace: string, savepointId: string, headers: GetSavepointHeaders, runtime: Util.RuntimeOptions): GetSavepointResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'GetSavepoint',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints/${OpenApiUtil.getEncodeParam(savepointId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeploymentTargetsHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListDeploymentTargetsRequest {
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
}

model ListDeploymentTargetsResponseBody = {
  data?: [
    DeploymentTarget
  ](name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalSize?: int32(name='totalSize'),
}

model ListDeploymentTargetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeploymentTargetsResponseBody(name='body'),
}

async function listDeploymentTargets(namespace: string, request: ListDeploymentTargetsRequest): ListDeploymentTargetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListDeploymentTargetsHeaders{};
  return listDeploymentTargetsWithOptions(namespace, request, headers, runtime);
}

async function listDeploymentTargetsWithOptions(namespace: string, request: ListDeploymentTargetsRequest, headers: ListDeploymentTargetsHeaders, runtime: Util.RuntimeOptions): ListDeploymentTargetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeploymentTargets',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployment-targets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeploymentsHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListDeploymentsRequest {
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
}

model ListDeploymentsResponseBody = {
  data?: [
    Deployment
  ](name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalSize?: int32(name='totalSize'),
}

model ListDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeploymentsResponseBody(name='body'),
}

async function listDeployments(namespace: string, request: ListDeploymentsRequest): ListDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListDeploymentsHeaders{};
  return listDeploymentsWithOptions(namespace, request, headers, runtime);
}

async function listDeploymentsWithOptions(namespace: string, request: ListDeploymentsRequest, headers: ListDeploymentsHeaders, runtime: Util.RuntimeOptions): ListDeploymentsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployments',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEngineVersionMetadataHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListEngineVersionMetadataResponseBody = {
  data?: EngineVersionMetadataIndex(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model ListEngineVersionMetadataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEngineVersionMetadataResponseBody(name='body'),
}

async function listEngineVersionMetadata(): ListEngineVersionMetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListEngineVersionMetadataHeaders{};
  return listEngineVersionMetadataWithOptions(headers, runtime);
}

async function listEngineVersionMetadataWithOptions(headers: ListEngineVersionMetadataHeaders, runtime: Util.RuntimeOptions): ListEngineVersionMetadataResponse {
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
  };
  var params = new OpenApi.Params{
    action = 'ListEngineVersionMetadata',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/engine-version-meta.json`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListJobsHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListJobsRequest {
  deploymentId?: string(name='deploymentId'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
}

model ListJobsResponseBody = {
  data?: [
    Job
  ](name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalSize?: int32(name='totalSize'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobs(namespace: string, request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListJobsHeaders{};
  return listJobsWithOptions(namespace, request, headers, runtime);
}

async function listJobsWithOptions(namespace: string, request: ListJobsRequest, headers: ListJobsHeaders, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    query['deploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSavepointsHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListSavepointsRequest {
  deploymentId?: string(name='deploymentId'),
  jobId?: string(name='jobId'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
}

model ListSavepointsResponseBody = {
  data?: [
    Savepoint
  ](name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalSize?: int32(name='totalSize'),
}

model ListSavepointsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSavepointsResponseBody(name='body'),
}

async function listSavepoints(namespace: string, request: ListSavepointsRequest): ListSavepointsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListSavepointsHeaders{};
  return listSavepointsWithOptions(namespace, request, headers, runtime);
}

async function listSavepointsWithOptions(namespace: string, request: ListSavepointsRequest, headers: ListSavepointsHeaders, runtime: Util.RuntimeOptions): ListSavepointsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    query['deploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['jobId'] = request.jobId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSavepoints',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/savepoints`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListVariablesHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model ListVariablesRequest {
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
}

model ListVariablesResponseBody = {
  data?: [
    Variable
  ](name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  pageIndex?: int32(name='pageIndex'),
  pageSize?: int32(name='pageSize'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
  totalSize?: int32(name='totalSize'),
}

model ListVariablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVariablesResponseBody(name='body'),
}

async function listVariables(namespace: string, request: ListVariablesRequest): ListVariablesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new ListVariablesHeaders{};
  return listVariablesWithOptions(namespace, request, headers, runtime);
}

async function listVariablesWithOptions(namespace: string, request: ListVariablesRequest, headers: ListVariablesHeaders, runtime: Util.RuntimeOptions): ListVariablesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pageIndex)) {
    query['pageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVariables',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/variables`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StartJobHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model StartJobRequest {
  body?: StartJobRequestBody(name='body'),
}

model StartJobResponseBody = {
  data?: Job(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StartJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartJobResponseBody(name='body'),
}

async function startJob(namespace: string, request: StartJobRequest): StartJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new StartJobHeaders{};
  return startJobWithOptions(namespace, request, headers, runtime);
}

async function startJobWithOptions(namespace: string, request: StartJobRequest, headers: StartJobHeaders, runtime: Util.RuntimeOptions): StartJobResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'StartJob',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopJobHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model StopJobRequest {
  body?: StopJobRequestBody(name='body'),
}

model StopJobResponseBody = {
  data?: Job(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model StopJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopJobResponseBody(name='body'),
}

async function stopJob(namespace: string, jobId: string, request: StopJobRequest): StopJobResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new StopJobHeaders{};
  return stopJobWithOptions(namespace, jobId, request, headers, runtime);
}

async function stopJobWithOptions(namespace: string, jobId: string, request: StopJobRequest, headers: StopJobHeaders, runtime: Util.RuntimeOptions): StopJobResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'StopJob',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/jobs/${OpenApiUtil.getEncodeParam(jobId)}%3Astop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeploymentHeaders {
  commonHeaders?: map[string]string,
  workspace?: string(name='workspace'),
}

model UpdateDeploymentRequest {
  body?: Deployment(name='body'),
}

model UpdateDeploymentResponseBody = {
  data?: Deployment(name='data'),
  errorCode?: string(name='errorCode'),
  errorMessage?: string(name='errorMessage'),
  httpCode?: int32(name='httpCode'),
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model UpdateDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeploymentResponseBody(name='body'),
}

async function updateDeployment(namespace: string, deploymentId: string, request: UpdateDeploymentRequest): UpdateDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers = new UpdateDeploymentHeaders{};
  return updateDeploymentWithOptions(namespace, deploymentId, request, headers, runtime);
}

async function updateDeploymentWithOptions(namespace: string, deploymentId: string, request: UpdateDeploymentRequest, headers: UpdateDeploymentHeaders, runtime: Util.RuntimeOptions): UpdateDeploymentResponse {
  Util.validateModel(request);
  var realHeaders : map[string]string = {};
  if (!Util.isUnset(headers.commonHeaders)) {
    realHeaders = headers.commonHeaders;
  }
  if (!Util.isUnset(headers.workspace)) {
    realHeaders['workspace'] = Util.toJSONString(headers.workspace);
  }
  var req = new OpenApi.OpenApiRequest{ 
    headers = realHeaders,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeployment',
    version = '2022-07-18',
    protocol = 'HTTPS',
    pathname = `/api/v2/namespaces/${OpenApiUtil.getEncodeParam(namespace)}/deployments/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

