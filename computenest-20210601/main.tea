/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('computenest', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ContinueDeployServiceInstanceRequest {
  clientToken?: string(name='ClientToken'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
}

model ContinueDeployServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ContinueDeployServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ContinueDeployServiceInstanceResponseBody(name='body'),
}

async function continueDeployServiceInstanceWithOptions(request: ContinueDeployServiceInstanceRequest, runtime: Util.RuntimeOptions): ContinueDeployServiceInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDeployServiceInstance',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function continueDeployServiceInstance(request: ContinueDeployServiceInstanceRequest): ContinueDeployServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return continueDeployServiceInstanceWithOptions(request, runtime);
}

model CreateServiceInstanceRequest {
  clientToken?: string(name='ClientToken'),
  contactGroup?: string(name='ContactGroup'),
  dryRun?: boolean(name='DryRun'),
  enableInstanceOps?: boolean(name='EnableInstanceOps'),
  name?: string(name='Name'),
  operationMetadata?: {
    endTime?: string(name='EndTime'),
    resources?: string(name='Resources'),
    serviceInstanceId?: string(name='ServiceInstanceId'),
    startTime?: string(name='StartTime'),
  }(name='OperationMetadata'),
  parameters?: map[string]any(name='Parameters'),
  payType?: long(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceId?: string(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
  specificationCode?: string(name='SpecificationCode'),
  specificationName?: string(name='SpecificationName'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  templateName?: string(name='TemplateName'),
  trialType?: string(name='TrialType'),
}

model CreateServiceInstanceShrinkRequest {
  clientToken?: string(name='ClientToken'),
  contactGroup?: string(name='ContactGroup'),
  dryRun?: boolean(name='DryRun'),
  enableInstanceOps?: boolean(name='EnableInstanceOps'),
  name?: string(name='Name'),
  operationMetadata?: {
    endTime?: string(name='EndTime'),
    resources?: string(name='Resources'),
    serviceInstanceId?: string(name='ServiceInstanceId'),
    startTime?: string(name='StartTime'),
  }(name='OperationMetadata'),
  parametersShrink?: string(name='Parameters'),
  payType?: long(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  serviceId?: string(name='ServiceId'),
  serviceVersion?: string(name='ServiceVersion'),
  specificationCode?: string(name='SpecificationCode'),
  specificationName?: string(name='SpecificationName'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  templateName?: string(name='TemplateName'),
  trialType?: string(name='TrialType'),
}

model CreateServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  status?: string(name='Status'),
}

model CreateServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceInstanceResponseBody(name='body'),
}

async function createServiceInstanceWithOptions(tmpReq: CreateServiceInstanceRequest, runtime: Util.RuntimeOptions): CreateServiceInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateServiceInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.parameters)) {
    request.parametersShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.parameters, 'Parameters', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.contactGroup)) {
    query['ContactGroup'] = request.contactGroup;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.enableInstanceOps)) {
    query['EnableInstanceOps'] = request.enableInstanceOps;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.operationMetadata)) {
    query['OperationMetadata'] = request.operationMetadata;
  }
  if (!Util.isUnset(request.parametersShrink)) {
    query['Parameters'] = request.parametersShrink;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['ServiceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceVersion)) {
    query['ServiceVersion'] = request.serviceVersion;
  }
  if (!Util.isUnset(request.specificationCode)) {
    query['SpecificationCode'] = request.specificationCode;
  }
  if (!Util.isUnset(request.specificationName)) {
    query['SpecificationName'] = request.specificationName;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.templateName)) {
    query['TemplateName'] = request.templateName;
  }
  if (!Util.isUnset(request.trialType)) {
    query['TrialType'] = request.trialType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceInstance',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceInstance(request: CreateServiceInstanceRequest): CreateServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceInstanceWithOptions(request, runtime);
}

model DeleteServiceInstancesRequest {
  clientToken?: string(name='ClientToken'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: [ string ](name='ServiceInstanceId'),
}

model DeleteServiceInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstancesWithOptions(request: DeleteServiceInstancesRequest, runtime: Util.RuntimeOptions): DeleteServiceInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteServiceInstances',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteServiceInstances(request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteServiceInstancesWithOptions(request, runtime);
}

model GetServiceInstanceRequest {
  regionId?: string(name='RegionId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
}

model GetServiceInstanceResponseBody = {
  createTime?: string(name='CreateTime'),
  enableInstanceOps?: boolean(name='EnableInstanceOps'),
  endTime?: string(name='EndTime'),
  isOperated?: boolean(name='IsOperated'),
  licenseEndTime?: string(name='LicenseEndTime'),
  name?: string(name='Name'),
  networkConfig?: {
    endpointId?: string(name='EndpointId'),
    privateVpcConnections?: [ 
      {
        endpointId?: string(name='EndpointId'),
        privateZoneId?: string(name='PrivateZoneId'),
      }
    ](name='PrivateVpcConnections'),
    privateZoneId?: string(name='PrivateZoneId'),
    reversePrivateVpcConnections?: [ 
      {
        endpointId?: string(name='EndpointId'),
      }
    ](name='ReversePrivateVpcConnections'),
  }(name='NetworkConfig'),
  operatedServiceInstanceId?: string(name='OperatedServiceInstanceId'),
  operationEndTime?: string(name='OperationEndTime'),
  operationStartTime?: string(name='OperationStartTime'),
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  payType?: string(name='PayType'),
  progress?: long(name='Progress'),
  requestId?: string(name='RequestId'),
  resources?: string(name='Resources'),
  service?: {
    deployMetadata?: string(name='DeployMetadata'),
    deployType?: string(name='DeployType'),
    publishTime?: string(name='PublishTime'),
    serviceDocUrl?: string(name='ServiceDocUrl'),
    serviceId?: string(name='ServiceId'),
    serviceInfos?: [ 
      {
        image?: string(name='Image'),
        locale?: string(name='Locale'),
        name?: string(name='Name'),
        shortDescription?: string(name='ShortDescription'),
      }
    ](name='ServiceInfos'),
    serviceProductUrl?: string(name='ServiceProductUrl'),
    serviceType?: string(name='ServiceType'),
    status?: string(name='Status'),
    supplierName?: string(name='SupplierName'),
    supplierUrl?: string(name='SupplierUrl'),
    upgradableServiceVersions?: [ string ](name='UpgradableServiceVersions'),
    upgradeMetadata?: string(name='UpgradeMetadata'),
    version?: string(name='Version'),
    versionName?: string(name='VersionName'),
  }(name='Service'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  serviceType?: string(name='ServiceType'),
  source?: string(name='Source'),
  status?: string(name='Status'),
  statusDetail?: string(name='StatusDetail'),
  supplierUid?: long(name='SupplierUid'),
  tags?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tags'),
  templateName?: string(name='TemplateName'),
  updateTime?: string(name='UpdateTime'),
  userId?: long(name='UserId'),
}

model GetServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetServiceInstanceResponseBody(name='body'),
}

async function getServiceInstanceWithOptions(request: GetServiceInstanceRequest, runtime: Util.RuntimeOptions): GetServiceInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetServiceInstance',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getServiceInstance(request: GetServiceInstanceRequest): GetServiceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getServiceInstanceWithOptions(request, runtime);
}

model ListServiceInstanceLogsRequest {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
}

model ListServiceInstanceLogsResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstancesLogs?: [ 
    {
      content?: string(name='Content'),
      logType?: string(name='LogType'),
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      source?: string(name='Source'),
      status?: string(name='Status'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ServiceInstancesLogs'),
}

model ListServiceInstanceLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstanceLogsResponseBody(name='body'),
}

async function listServiceInstanceLogsWithOptions(request: ListServiceInstanceLogsRequest, runtime: Util.RuntimeOptions): ListServiceInstanceLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstanceLogs',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstanceLogs(request: ListServiceInstanceLogsRequest): ListServiceInstanceLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceInstanceLogsWithOptions(request, runtime);
}

model ListServiceInstanceResourcesRequest {
  expireTimeEnd?: string(name='ExpireTimeEnd'),
  expireTimeStart?: string(name='ExpireTimeStart'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  payType?: string(name='PayType'),
  resourceARN?: [ string ](name='ResourceARN'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListServiceInstanceResourcesResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resources?: [ 
    {
      createTime?: string(name='CreateTime'),
      expireTime?: string(name='ExpireTime'),
      payType?: string(name='PayType'),
      productCode?: string(name='ProductCode'),
      productType?: string(name='ProductType'),
      renewStatus?: string(name='RenewStatus'),
      renewalPeriod?: int32(name='RenewalPeriod'),
      renewalPeriodUnit?: string(name='RenewalPeriodUnit'),
      resourceARN?: string(name='ResourceARN'),
    }
  ](name='Resources'),
}

model ListServiceInstanceResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstanceResourcesResponseBody(name='body'),
}

async function listServiceInstanceResourcesWithOptions(request: ListServiceInstanceResourcesRequest, runtime: Util.RuntimeOptions): ListServiceInstanceResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expireTimeEnd)) {
    query['ExpireTimeEnd'] = request.expireTimeEnd;
  }
  if (!Util.isUnset(request.expireTimeStart)) {
    query['ExpireTimeStart'] = request.expireTimeStart;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.resourceARN)) {
    query['ResourceARN'] = request.resourceARN;
  }
  if (!Util.isUnset(request.serviceInstanceId)) {
    query['ServiceInstanceId'] = request.serviceInstanceId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstanceResources',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstanceResources(request: ListServiceInstanceResourcesRequest): ListServiceInstanceResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceInstanceResourcesWithOptions(request, runtime);
}

model ListServiceInstancesRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListServiceInstancesResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstances?: [ 
    {
      createTime?: string(name='CreateTime'),
      enableInstanceOps?: boolean(name='EnableInstanceOps'),
      endTime?: string(name='EndTime'),
      marketInstanceId?: string(name='MarketInstanceId'),
      name?: string(name='Name'),
      operatedServiceInstanceId?: string(name='OperatedServiceInstanceId'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      outputs?: string(name='Outputs'),
      parameters?: string(name='Parameters'),
      payType?: string(name='PayType'),
      progress?: long(name='Progress'),
      resources?: string(name='Resources'),
      service?: {
        deployType?: string(name='DeployType'),
        publishTime?: string(name='PublishTime'),
        serviceId?: string(name='ServiceId'),
        serviceInfos?: [ 
          {
            image?: string(name='Image'),
            locale?: string(name='Locale'),
            name?: string(name='Name'),
            shortDescription?: string(name='ShortDescription'),
          }
        ](name='ServiceInfos'),
        serviceType?: string(name='ServiceType'),
        status?: string(name='Status'),
        supplierName?: string(name='SupplierName'),
        supplierUrl?: string(name='SupplierUrl'),
        version?: string(name='Version'),
        versionName?: string(name='VersionName'),
      }(name='Service'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      serviceType?: string(name='ServiceType'),
      source?: string(name='Source'),
      status?: string(name='Status'),
      statusDetail?: string(name='StatusDetail'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      templateName?: string(name='TemplateName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ServiceInstances'),
  totalCount?: long(name='TotalCount'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstancesWithOptions(request: ListServiceInstancesRequest, runtime: Util.RuntimeOptions): ListServiceInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceInstances',
    version = '2021-06-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceInstances(request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listServiceInstancesWithOptions(request, runtime);
}

