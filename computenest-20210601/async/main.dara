/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'ComputeNest';
  @version = '2021-06-01';
  @endpointRule = 'regional';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model ContinueDeployServiceInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceInstanceId: string(name='ServiceInstanceId', position='Query'),
}

model ContinueDeployServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ContinueDeployServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ContinueDeployServiceInstanceResponseBody(name='body'),
}

async function continueDeployServiceInstance(request: ContinueDeployServiceInstanceRequest): ContinueDeployServiceInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ContinueDeployServiceInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  enableInstanceOps?: boolean(name='EnableInstanceOps', position='Query'),
  operationMetadata?: {
    endTime?: string(name='EndTime'),
    resources?: string(name='Resources'),
    serviceInstanceId?: string(name='ServiceInstanceId'),
    startTime?: string(name='StartTime'),
  }(name='OperationMetadata', position='Query'),
  parameters?: map[string]any(name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model CreateServiceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  status?: string(name='Status'),
}

model CreateServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceInstanceResponseBody(name='body'),
}

async function createServiceInstance(request: CreateServiceInstanceRequest): CreateServiceInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteServiceInstancesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceInstanceId?: [ string ](name='ServiceInstanceId', position='Query'),
}

model DeleteServiceInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteServiceInstancesResponseBody(name='body'),
}

async function deleteServiceInstances(request: DeleteServiceInstancesRequest): DeleteServiceInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteServiceInstances', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceInstanceRequest {
  regionId: string(name='RegionId', position='Query'),
  serviceInstanceId: string(name='ServiceInstanceId', position='Query'),
}

model GetServiceInstanceResponseBody = {
  createTime?: string(name='CreateTime'),
  enableInstanceOps?: boolean(name='EnableInstanceOps'),
  isOperated?: boolean(name='IsOperated'),
  operatedServiceInstanceId?: string(name='OperatedServiceInstanceId'),
  operationEndTime?: string(name='OperationEndTime'),
  operationStartTime?: string(name='OperationStartTime'),
  outputs?: string(name='Outputs'),
  parameters?: string(name='Parameters'),
  progress?: long(name='Progress'),
  requestId?: string(name='RequestId'),
  resources?: string(name='Resources'),
  service?: {
    deployMetadata?: string(name='DeployMetadata'),
    deployType?: string(name='DeployType'),
    publishTime?: string(name='PublishTime'),
    serviceId?: string(name='ServiceId'),
    serviceInfos?: [ 
      {
        image?: string(name='Image'),
        locale?: string(name='Locale'),
        name?: string(name='Name'),
        shortDescription?: string(name='ShortDescription'),
      }
    ](name='ServiceInfos'),
    serviceType?: string(name='ServiceType'),
    status?: string(name='Status'),
    supplierName?: string(name='SupplierName'),
    supplierUrl?: string(name='SupplierUrl'),
    version?: string(name='Version'),
  }(name='Service'),
  serviceInstanceId?: string(name='ServiceInstanceId'),
  status?: string(name='Status'),
  statusDetail?: string(name='StatusDetail'),
  templateName?: string(name='TemplateName'),
  updateTime?: string(name='UpdateTime'),
}

model GetServiceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceInstanceResponseBody(name='body'),
}

async function getServiceInstance(request: GetServiceInstanceRequest): GetServiceInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceInstance', 'POST', '/', 'json', false, 'json', request);
}

model GetServiceProvisionsRequest {
  regionId: string(name='RegionId', position='Query'),
  serviceId: string(name='ServiceId', position='Query'),
  serviceVersion?: string(name='ServiceVersion', position='Query'),
  templateName?: string(name='TemplateName', position='Query'),
}

model GetServiceProvisionsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  serviceProvisions?: [ 
    {
      autoEnableService?: boolean(name='AutoEnableService'),
      enableURL?: string(name='EnableURL'),
      roleProvision?: {
        authorizationURL?: string(name='AuthorizationURL'),
        roles?: [ 
          {
            created?: boolean(name='Created'),
            function?: string(name='Function'),
            roleName?: string(name='RoleName'),
          }
        ](name='Roles'),
      }(name='RoleProvision'),
      serviceName?: string(name='ServiceName'),
      status?: string(name='Status'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='ServiceProvisions'),
}

model GetServiceProvisionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetServiceProvisionsResponseBody(name='body'),
}

async function getServiceProvisions(request: GetServiceProvisionsRequest): GetServiceProvisionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetServiceProvisions', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceInstanceLogsRequest {
  maxResults: string(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  serviceInstanceId: string(name='ServiceInstanceId', position='Query'),
}

model ListServiceInstanceLogsResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstancesLogs?: [ 
    {
      content?: string(name='Content'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      source?: string(name='Source'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='ServiceInstancesLogs'),
}

model ListServiceInstanceLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceInstanceLogsResponseBody(name='body'),
}

async function listServiceInstanceLogs(request: ListServiceInstanceLogsRequest): ListServiceInstanceLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceInstanceLogs', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceInstanceResourcesRequest {
  maxResults: string(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  resourceARN?: [ string ](name='ResourceARN', position='Query'),
  serviceInstanceId: string(name='ServiceInstanceId', position='Query'),
}

model ListServiceInstanceResourcesResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  resources?: [ 
    {
      resourceARN?: string(name='ResourceARN'),
    }
  ](name='Resources'),
}

model ListServiceInstanceResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceInstanceResourcesResponseBody(name='body'),
}

async function listServiceInstanceResources(request: ListServiceInstanceResourcesRequest): ListServiceInstanceResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceInstanceResources', 'POST', '/', 'json', false, 'json', request);
}

model ListServiceInstancesRequest {
  filter?: [ 
    {
      name?: string(name='Name'),
      value?: [ string ](name='Value'),
    }
  ](name='Filter', position='Query'),
  maxResults?: string(name='MaxResults', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  requestTag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='RequestTag', position='Query'),
}

model ListServiceInstancesResponseBody = {
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  serviceInstances?: [ 
    {
      createTime?: string(name='CreateTime'),
      enableInstanceOps?: boolean(name='EnableInstanceOps'),
      operatedServiceInstanceId?: string(name='OperatedServiceInstanceId'),
      operationEndTime?: string(name='OperationEndTime'),
      operationStartTime?: string(name='OperationStartTime'),
      outputs?: string(name='Outputs'),
      parameters?: string(name='Parameters'),
      progress?: long(name='Progress'),
      resources?: string(name='Resources'),
      service?: {
        deployType?: string(name='DeployType'),
        publishTime?: string(name='PublishTime'),
        serviceId?: string(name='ServiceId'),
        serviceInfos?: [ 
          {
            image?: string(name='Image'),
            locale?: string(name='Locale'),
            name?: string(name='Name'),
            shortDescription?: string(name='ShortDescription'),
          }
        ](name='ServiceInfos'),
        serviceType?: string(name='ServiceType'),
        status?: string(name='Status'),
        supplierName?: string(name='SupplierName'),
        supplierUrl?: string(name='SupplierUrl'),
        version?: string(name='Version'),
      }(name='Service'),
      serviceInstanceId?: string(name='ServiceInstanceId'),
      status?: string(name='Status'),
      statusDetail?: string(name='StatusDetail'),
      templateName?: string(name='TemplateName'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ServiceInstances'),
  totalCount?: long(name='TotalCount'),
}

model ListServiceInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListServiceInstancesResponseBody(name='body'),
}

async function listServiceInstances(request: ListServiceInstancesRequest): ListServiceInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListServiceInstances', 'POST', '/', 'json', false, 'json', request);
}

