/**
 *
 */
import Util;
import OpenApi;

import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('ims', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddUserToGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AddUserToGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

model BindMFADeviceRequest {
  serialNumber?: string(name='SerialNumber'),
  userPrincipalName?: string(name='UserPrincipalName'),
  authenticationCode1?: string(name='AuthenticationCode1'),
  authenticationCode2?: string(name='AuthenticationCode2'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model BindMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: BindMFADeviceResponseBody(name='body'),
}

async function bindMFADeviceWithOptions(request: BindMFADeviceRequest, runtime: Util.RuntimeOptions): BindMFADeviceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('BindMFADevice', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMFADeviceWithOptions(request, runtime);
}

model ChangePasswordRequest {
  oldPassword?: string(name='OldPassword'),
  newPassword?: string(name='NewPassword'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ChangePasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ChangePassword', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model CreateAccessKeyRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model CreateAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
  accessKey?: {
    status?: string(name='Status'),
    accessKeySecret?: string(name='AccessKeySecret'),
    accessKeyId?: string(name='AccessKeyId'),
    createDate?: string(name='CreateDate'),
  }(name='AccessKey'),
}

model CreateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessKeyResponseBody(name='body'),
}

async function createAccessKeyWithOptions(request: CreateAccessKeyRequest, runtime: Util.RuntimeOptions): CreateAccessKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAccessKey', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessKeyWithOptions(request, runtime);
}

model CreateApplicationRequest {
  displayName?: string(name='DisplayName'),
  appPrincipalName?: string(name='AppPrincipalName'),
  appType?: string(name='AppType'),
  redirectUris?: string(name='RedirectUris'),
  secretRequired?: boolean(name='SecretRequired'),
  accessTokenValidity?: int32(name='AccessTokenValidity'),
  refreshTokenValidity?: int32(name='RefreshTokenValidity'),
  predefinedScopes?: string(name='PredefinedScopes'),
  isMultiTenant?: boolean(name='IsMultiTenant'),
  akProxySuffix?: string(name='AkProxySuffix'),
  appName?: string(name='AppName'),
}

model CreateApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  application?: {
    displayName?: string(name='DisplayName'),
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    accountId?: string(name='AccountId'),
    createDate?: string(name='CreateDate'),
    appName?: string(name='AppName'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    updateDate?: string(name='UpdateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    appId?: string(name='AppId'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    appType?: string(name='AppType'),
  }(name='Application'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateApplication', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateAppSecretRequest {
  appId?: string(name='AppId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model CreateAppSecretResponseBody = {
  requestId?: string(name='RequestId'),
  appSecret?: {
    appSecretValue?: string(name='AppSecretValue'),
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
}

model CreateAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppSecretResponseBody(name='body'),
}

async function createAppSecretWithOptions(request: CreateAppSecretRequest, runtime: Util.RuntimeOptions): CreateAppSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateAppSecret', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createAppSecret(request: CreateAppSecretRequest): CreateAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppSecretWithOptions(request, runtime);
}

model CreateGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  displayName?: string(name='DisplayName'),
  comments?: string(name='Comments'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
}

model CreateGroupResponseBody = {
  group?: {
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    updateDate?: string(name='UpdateDate'),
    groupName?: string(name='GroupName'),
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

model CreateLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired'),
  generateRandomPassword?: boolean(name='GenerateRandomPassword'),
  status?: string(name='Status'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model CreateLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
  loginProfile?: {
    userPrincipalName?: string(name='UserPrincipalName'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    MFABindRequired?: boolean(name='MFABindRequired'),
  }(name='LoginProfile'),
}

model CreateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoginProfileResponseBody(name='body'),
}

async function createLoginProfileWithOptions(request: CreateLoginProfileRequest, runtime: Util.RuntimeOptions): CreateLoginProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateLoginProfile', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoginProfileWithOptions(request, runtime);
}

model CreateSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
  SAMLMetadataDocument?: string(name='SAMLMetadataDocument'),
  description?: string(name='Description'),
  akProxySuffix?: string(name='AkProxySuffix'),
  encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
}

model CreateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    updateDate?: string(name='UpdateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    createDate?: string(name='CreateDate'),
    arn?: string(name='Arn'),
  }(name='SAMLProvider'),
}

model CreateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSAMLProviderResponseBody(name='body'),
}

async function createSAMLProviderWithOptions(request: CreateSAMLProviderRequest, runtime: Util.RuntimeOptions): CreateSAMLProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateSAMLProvider', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createSAMLProvider(request: CreateSAMLProviderRequest): CreateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSAMLProviderWithOptions(request, runtime);
}

model CreateUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  displayName?: string(name='DisplayName'),
  mobilePhone?: string(name='MobilePhone'),
  email?: string(name='Email'),
  comments?: string(name='Comments'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model CreateUserResponseBody = {
  user?: {
    displayName?: string(name='DisplayName'),
    userPrincipalName?: string(name='UserPrincipalName'),
    email?: string(name='Email'),
    updateDate?: string(name='UpdateDate'),
    mobilePhone?: string(name='MobilePhone'),
    userId?: string(name='UserId'),
    comments?: string(name='Comments'),
    lastLoginDate?: string(name='LastLoginDate'),
    createDate?: string(name='CreateDate'),
  }(name='User'),
  requestId?: string(name='RequestId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateUser', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateVirtualMFADeviceRequest {
  virtualMFADeviceName?: string(name='VirtualMFADeviceName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model CreateVirtualMFADeviceResponseBody = {
  virtualMFADevice?: {
    serialNumber?: string(name='SerialNumber'),
    QRCodePNG?: string(name='QRCodePNG'),
    base32StringSeed?: string(name='Base32StringSeed'),
  }(name='VirtualMFADevice'),
  requestId?: string(name='RequestId'),
}

model CreateVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualMFADeviceResponseBody(name='body'),
}

async function createVirtualMFADeviceWithOptions(request: CreateVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): CreateVirtualMFADeviceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateVirtualMFADevice', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualMFADeviceWithOptions(request, runtime);
}

model DeleteAccessKeyRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessKeyResponseBody(name='body'),
}

async function deleteAccessKeyWithOptions(request: DeleteAccessKeyRequest, runtime: Util.RuntimeOptions): DeleteAccessKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAccessKey', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessKeyWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteApplication', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteAppSecretRequest {
  appId?: string(name='AppId'),
  appSecretId?: string(name='AppSecretId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteAppSecretResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAppSecretResponseBody(name='body'),
}

async function deleteAppSecretWithOptions(request: DeleteAppSecretRequest, runtime: Util.RuntimeOptions): DeleteAppSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteAppSecret', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteAppSecret(request: DeleteAppSecretRequest): DeleteAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppSecretWithOptions(request, runtime);
}

model DeleteGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoginProfileResponseBody(name='body'),
}

async function deleteLoginProfileWithOptions(request: DeleteLoginProfileRequest, runtime: Util.RuntimeOptions): DeleteLoginProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteLoginProfile', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginProfileWithOptions(request, runtime);
}

model DeleteSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSAMLProviderResponseBody(name='body'),
}

async function deleteSAMLProviderWithOptions(request: DeleteSAMLProviderRequest, runtime: Util.RuntimeOptions): DeleteSAMLProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteSAMLProvider', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteSAMLProvider(request: DeleteSAMLProviderRequest): DeleteSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSAMLProviderWithOptions(request, runtime);
}

model DeleteUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteUser', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest {
  serialNumber?: string(name='SerialNumber'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteVirtualMFADevice', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model DisableVirtualMFARequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model DisableVirtualMFAResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVirtualMFAResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVirtualMFAResponseBody(name='body'),
}

async function disableVirtualMFAWithOptions(request: DisableVirtualMFARequest, runtime: Util.RuntimeOptions): DisableVirtualMFAResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DisableVirtualMFA', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function disableVirtualMFA(request: DisableVirtualMFARequest): DisableVirtualMFAResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVirtualMFAWithOptions(request, runtime);
}

model GenerateCredentialReportRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GenerateCredentialReportResponseBody = {
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model GenerateCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateCredentialReportResponseBody(name='body'),
}

async function generateCredentialReportWithOptions(request: GenerateCredentialReportRequest, runtime: Util.RuntimeOptions): GenerateCredentialReportResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GenerateCredentialReport', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function generateCredentialReport(request: GenerateCredentialReportRequest): GenerateCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateCredentialReportWithOptions(request, runtime);
}

model GetAccessKeyLastUsedRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetAccessKeyLastUsedResponseBody = {
  accessKeyLastUsed?: {
    lastUsedDate?: string(name='LastUsedDate'),
  }(name='AccessKeyLastUsed'),
  requestId?: string(name='RequestId'),
}

model GetAccessKeyLastUsedResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccessKeyLastUsedResponseBody(name='body'),
}

async function getAccessKeyLastUsedWithOptions(request: GetAccessKeyLastUsedRequest, runtime: Util.RuntimeOptions): GetAccessKeyLastUsedResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAccessKeyLastUsed', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessKeyLastUsedWithOptions(request, runtime);
}

model GetAccountMFAInfoRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetAccountMFAInfoResponseBody = {
  requestId?: string(name='RequestId'),
  isMFAEnable?: boolean(name='IsMFAEnable'),
}

model GetAccountMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountMFAInfoResponseBody(name='body'),
}

async function getAccountMFAInfoWithOptions(request: GetAccountMFAInfoRequest, runtime: Util.RuntimeOptions): GetAccountMFAInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAccountMFAInfo', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAccountMFAInfo(request: GetAccountMFAInfoRequest): GetAccountMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountMFAInfoWithOptions(request, runtime);
}

model GetAccountSecurityPracticeReportRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetAccountSecurityPracticeReportResponseBody = {
  requestId?: string(name='RequestId'),
  accountSecurityPracticeInfo?: {
    accountSecurityPracticeUserInfo?: {
      unusedAkNum?: int32(name='UnusedAkNum'),
      subUserWithUnusedAccessKey?: int32(name='SubUserWithUnusedAccessKey'),
      rootWithAccessKey?: int32(name='RootWithAccessKey'),
      subUser?: int32(name='SubUser'),
      bindMfa?: boolean(name='BindMfa'),
      oldAkNum?: int32(name='OldAkNum'),
      subUserPwdLevel?: string(name='SubUserPwdLevel'),
      subUserWithOldAccessKey?: int32(name='SubUserWithOldAccessKey'),
      subUserBindMfa?: int32(name='SubUserBindMfa'),
    }(name='AccountSecurityPracticeUserInfo'),
    score?: int32(name='Score'),
  }(name='AccountSecurityPracticeInfo'),
}

model GetAccountSecurityPracticeReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSecurityPracticeReportResponseBody(name='body'),
}

async function getAccountSecurityPracticeReportWithOptions(request: GetAccountSecurityPracticeReportRequest, runtime: Util.RuntimeOptions): GetAccountSecurityPracticeReportResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAccountSecurityPracticeReport', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAccountSecurityPracticeReport(request: GetAccountSecurityPracticeReportRequest): GetAccountSecurityPracticeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSecurityPracticeReportWithOptions(request, runtime);
}

model GetAccountSummaryRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetAccountSummaryResponseBody = {
  requestId?: string(name='RequestId'),
  summaryMap?: {
    MFADevices?: int32(name='MFADevices'),
    accessKeysPerUserQuota?: int32(name='AccessKeysPerUserQuota'),
    attachedPoliciesPerGroupQuota?: int32(name='AttachedPoliciesPerGroupQuota'),
    attachedSystemPoliciesPerRoleQuota?: int32(name='AttachedSystemPoliciesPerRoleQuota'),
    attachedPoliciesPerRoleQuota?: int32(name='AttachedPoliciesPerRoleQuota'),
    groupsPerUserQuota?: int32(name='GroupsPerUserQuota'),
    roles?: int32(name='Roles'),
    policySizeQuota?: int32(name='PolicySizeQuota'),
    attachedSystemPoliciesPerGroupQuota?: int32(name='AttachedSystemPoliciesPerGroupQuota'),
    attachedSystemPoliciesPerUserQuota?: int32(name='AttachedSystemPoliciesPerUserQuota'),
    attachedPoliciesPerUserQuota?: int32(name='AttachedPoliciesPerUserQuota'),
    groupsQuota?: int32(name='GroupsQuota'),
    groups?: int32(name='Groups'),
    policiesQuota?: int32(name='PoliciesQuota'),
    virtualMFADevicesQuota?: int32(name='VirtualMFADevicesQuota'),
    versionsPerPolicyQuota?: int32(name='VersionsPerPolicyQuota'),
    rolesQuota?: int32(name='RolesQuota'),
    usersQuota?: int32(name='UsersQuota'),
    policies?: int32(name='Policies'),
    users?: int32(name='Users'),
    MFADevicesInUse?: int32(name='MFADevicesInUse'),
  }(name='SummaryMap'),
}

model GetAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSummaryResponseBody(name='body'),
}

async function getAccountSummaryWithOptions(request: GetAccountSummaryRequest, runtime: Util.RuntimeOptions): GetAccountSummaryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAccountSummary', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAccountSummary(request: GetAccountSummaryRequest): GetAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSummaryWithOptions(request, runtime);
}

model GetApplicationRequest {
  appId?: string(name='AppId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  application?: {
    displayName?: string(name='DisplayName'),
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    accountId?: string(name='AccountId'),
    createDate?: string(name='CreateDate'),
    appName?: string(name='AppName'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    updateDate?: string(name='UpdateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    appId?: string(name='AppId'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    appType?: string(name='AppType'),
  }(name='Application'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetApplication', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model GetAppSecretRequest {
  appId?: string(name='AppId'),
  appSecretId?: string(name='AppSecretId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetAppSecretResponseBody = {
  requestId?: string(name='RequestId'),
  appSecret?: {
    appSecretValue?: string(name='AppSecretValue'),
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
}

model GetAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppSecretResponseBody(name='body'),
}

async function getAppSecretWithOptions(request: GetAppSecretRequest, runtime: Util.RuntimeOptions): GetAppSecretResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAppSecret', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppSecretWithOptions(request, runtime);
}

model GetCredentialReportRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetCredentialReportResponseBody = {
  generatedTime?: string(name='GeneratedTime'),
  requestId?: string(name='RequestId'),
  content?: string(name='Content'),
}

model GetCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetCredentialReportResponseBody(name='body'),
}

async function getCredentialReportWithOptions(request: GetCredentialReportRequest, runtime: Util.RuntimeOptions): GetCredentialReportResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetCredentialReport', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getCredentialReport(request: GetCredentialReportRequest): GetCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCredentialReportWithOptions(request, runtime);
}

model GetDefaultDomainRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultDomainResponseBody(name='body'),
}

async function getDefaultDomainWithOptions(request: GetDefaultDomainRequest, runtime: Util.RuntimeOptions): GetDefaultDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetDefaultDomain', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getDefaultDomain(request: GetDefaultDomainRequest): GetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultDomainWithOptions(request, runtime);
}

model GetGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
}

model GetGroupResponseBody = {
  group?: {
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    updateDate?: string(name='UpdateDate'),
    groupName?: string(name='GroupName'),
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model GetLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
  loginProfile?: {
    status?: string(name='Status'),
    userPrincipalName?: string(name='UserPrincipalName'),
    updateDate?: string(name='UpdateDate'),
    lastLoginTime?: string(name='LastLoginTime'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    MFABindRequired?: boolean(name='MFABindRequired'),
  }(name='LoginProfile'),
}

model GetLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: GetLoginProfileResponseBody(name='body'),
}

async function getLoginProfileWithOptions(request: GetLoginProfileRequest, runtime: Util.RuntimeOptions): GetLoginProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetLoginProfile', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginProfileWithOptions(request, runtime);
}

model GetPasswordPolicyRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetPasswordPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  passwordPolicy?: {
    requireNumbers?: boolean(name='RequireNumbers'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireSymbols?: boolean(name='RequireSymbols'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    hardExpire?: boolean(name='HardExpire'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
  }(name='PasswordPolicy'),
}

model GetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GetPasswordPolicyResponseBody(name='body'),
}

async function getPasswordPolicyWithOptions(request: GetPasswordPolicyRequest, runtime: Util.RuntimeOptions): GetPasswordPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetPasswordPolicy', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getPasswordPolicy(request: GetPasswordPolicyRequest): GetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPasswordPolicyWithOptions(request, runtime);
}

model GetSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    description?: string(name='Description'),
    updateDate?: string(name='UpdateDate'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    createDate?: string(name='CreateDate'),
    encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
    arn?: string(name='Arn'),
  }(name='SAMLProvider'),
}

model GetSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: GetSAMLProviderResponseBody(name='body'),
}

async function getSAMLProviderWithOptions(request: GetSAMLProviderRequest, runtime: Util.RuntimeOptions): GetSAMLProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSAMLProvider', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSAMLProvider(request: GetSAMLProviderRequest): GetSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSAMLProviderWithOptions(request, runtime);
}

model GetSecurityPreferenceRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetSecurityPreferenceResponseBody = {
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
  }(name='SecurityPreference'),
  requestId?: string(name='RequestId'),
}

model GetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecurityPreferenceResponseBody(name='body'),
}

async function getSecurityPreferenceWithOptions(request: GetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): GetSecurityPreferenceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetSecurityPreference', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getSecurityPreference(request: GetSecurityPreferenceRequest): GetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityPreferenceWithOptions(request, runtime);
}

model GetUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetUserResponseBody = {
  user?: {
    displayName?: string(name='DisplayName'),
    userPrincipalName?: string(name='UserPrincipalName'),
    email?: string(name='Email'),
    updateDate?: string(name='UpdateDate'),
    mobilePhone?: string(name='MobilePhone'),
    userId?: string(name='UserId'),
    comments?: string(name='Comments'),
    lastLoginDate?: string(name='LastLoginDate'),
    createDate?: string(name='CreateDate'),
  }(name='User'),
  requestId?: string(name='RequestId'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetUser', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserMFAInfoRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetUserMFAInfoResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
  isMFAEnable?: boolean(name='IsMFAEnable'),
}

model GetUserMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserMFAInfoResponseBody(name='body'),
}

async function getUserMFAInfoWithOptions(request: GetUserMFAInfoRequest, runtime: Util.RuntimeOptions): GetUserMFAInfoResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetUserMFAInfo', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAInfoWithOptions(request, runtime);
}

model GetUserSsoSettingsRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model GetUserSsoSettingsResponseBody = {
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
  requestId?: string(name='RequestId'),
}

model GetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserSsoSettingsResponseBody(name='body'),
}

async function getUserSsoSettingsWithOptions(request: GetUserSsoSettingsRequest, runtime: Util.RuntimeOptions): GetUserSsoSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetUserSsoSettings', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getUserSsoSettings(request: GetUserSsoSettingsRequest): GetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserSsoSettingsWithOptions(request, runtime);
}

model ListAccessKeysRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListAccessKeysResponseBody = {
  accessKeys?: {
    accessKey?: [ 
    {
      status?: string(name='Status'),
      updateDate?: string(name='UpdateDate'),
      accessKeyId?: string(name='AccessKeyId'),
      createDate?: string(name='CreateDate'),
    }
  ](name='AccessKey')
  }(name='AccessKeys'),
  requestId?: string(name='RequestId'),
}

model ListAccessKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccessKeysResponseBody(name='body'),
}

async function listAccessKeysWithOptions(request: ListAccessKeysRequest, runtime: Util.RuntimeOptions): ListAccessKeysResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccessKeys', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessKeysWithOptions(request, runtime);
}

model ListApplicationsRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListApplicationsResponseBody = {
  requestId?: string(name='RequestId'),
  applications?: {
    application?: [ 
    {
      displayName?: string(name='DisplayName'),
      accessTokenValidity?: int32(name='AccessTokenValidity'),
      secretRequired?: boolean(name='SecretRequired'),
      accountId?: string(name='AccountId'),
      createDate?: string(name='CreateDate'),
      appName?: string(name='AppName'),
      redirectUris?: {
        redirectUri?: [ string ](name='RedirectUri')
      }(name='RedirectUris'),
      updateDate?: string(name='UpdateDate'),
      delegatedScope?: {
        predefinedScopes?: {
          predefinedScope?: [ 
          {
            description?: string(name='Description'),
            name?: string(name='Name'),
          }
        ](name='PredefinedScope')
        }(name='PredefinedScopes'),
      }(name='DelegatedScope'),
      appId?: string(name='AppId'),
      refreshTokenValidity?: int32(name='RefreshTokenValidity'),
      isMultiTenant?: boolean(name='IsMultiTenant'),
      appType?: string(name='AppType'),
    }
  ](name='Application')
  }(name='Applications'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(request: ListApplicationsRequest, runtime: Util.RuntimeOptions): ListApplicationsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListApplications', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(request, runtime);
}

model ListAppSecretIdsRequest {
  appId?: string(name='AppId'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListAppSecretIdsResponseBody = {
  appSecrets?: {
    appSecret?: [ 
    {
      appId?: string(name='AppId'),
      appSecretId?: string(name='AppSecretId'),
      createDate?: string(name='CreateDate'),
    }
  ](name='AppSecret')
  }(name='AppSecrets'),
  requestId?: string(name='RequestId'),
}

model ListAppSecretIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppSecretIdsResponseBody(name='body'),
}

async function listAppSecretIdsWithOptions(request: ListAppSecretIdsRequest, runtime: Util.RuntimeOptions): ListAppSecretIdsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAppSecretIds', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAppSecretIds(request: ListAppSecretIdsRequest): ListAppSecretIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppSecretIdsWithOptions(request, runtime);
}

model ListGroupsRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  groups?: {
    group?: [ 
    {
      displayName?: string(name='DisplayName'),
      groupId?: string(name='GroupId'),
      updateDate?: string(name='UpdateDate'),
      groupName?: string(name='GroupName'),
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
    }
  ](name='Group')
  }(name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListGroups', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListGroupsForUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListGroupsForUserResponseBody = {
  requestId?: string(name='RequestId'),
  groups?: {
    group?: [ 
    {
      displayName?: string(name='DisplayName'),
      groupName?: string(name='GroupName'),
      groupId?: string(name='GroupId'),
      comments?: string(name='Comments'),
      joinDate?: string(name='JoinDate'),
    }
  ](name='Group')
  }(name='Groups'),
}

model ListGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsForUserResponseBody(name='body'),
}

async function listGroupsForUserWithOptions(request: ListGroupsForUserRequest, runtime: Util.RuntimeOptions): ListGroupsForUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListGroupsForUser', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsForUserWithOptions(request, runtime);
}

model ListPredefinedScopesRequest {
  akProxySuffix?: string(name='AkProxySuffix'),
  appType?: string(name='AppType'),
}

model ListPredefinedScopesResponseBody = {
  predefinedScopes?: {
    predefinedScope?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
    }
  ](name='PredefinedScope')
  }(name='PredefinedScopes'),
  requestId?: string(name='RequestId'),
}

model ListPredefinedScopesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPredefinedScopesResponseBody(name='body'),
}

async function listPredefinedScopesWithOptions(request: ListPredefinedScopesRequest, runtime: Util.RuntimeOptions): ListPredefinedScopesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListPredefinedScopes', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listPredefinedScopes(request: ListPredefinedScopesRequest): ListPredefinedScopesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPredefinedScopesWithOptions(request, runtime);
}

model ListSAMLProvidersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListSAMLProvidersResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProviders?: {
    SAMLProvider?: [ 
    {
      updateDate?: string(name='UpdateDate'),
      description?: string(name='Description'),
      SAMLProviderName?: string(name='SAMLProviderName'),
      createDate?: string(name='CreateDate'),
      arn?: string(name='Arn'),
    }
  ](name='SAMLProvider')
  }(name='SAMLProviders'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
}

model ListSAMLProvidersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSAMLProvidersResponseBody(name='body'),
}

async function listSAMLProvidersWithOptions(request: ListSAMLProvidersRequest, runtime: Util.RuntimeOptions): ListSAMLProvidersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListSAMLProviders', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listSAMLProviders(request: ListSAMLProvidersRequest): ListSAMLProvidersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSAMLProvidersWithOptions(request, runtime);
}

model ListUserBasicInfosRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListUserBasicInfosResponseBody = {
  requestId?: string(name='RequestId'),
  isTruncated?: boolean(name='IsTruncated'),
  userBasicInfos?: {
    userBasicInfo?: [ 
    {
      userPrincipalName?: string(name='UserPrincipalName'),
      displayName?: string(name='DisplayName'),
      userId?: string(name='UserId'),
    }
  ](name='UserBasicInfo')
  }(name='UserBasicInfos'),
  marker?: string(name='Marker'),
}

model ListUserBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserBasicInfosResponseBody(name='body'),
}

async function listUserBasicInfosWithOptions(request: ListUserBasicInfosRequest, runtime: Util.RuntimeOptions): ListUserBasicInfosResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListUserBasicInfos', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listUserBasicInfos(request: ListUserBasicInfosRequest): ListUserBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserBasicInfosWithOptions(request, runtime);
}

model ListUsersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  users?: {
    user?: [ 
    {
      displayName?: string(name='DisplayName'),
      userPrincipalName?: string(name='UserPrincipalName'),
      email?: string(name='Email'),
      updateDate?: string(name='UpdateDate'),
      mobilePhone?: string(name='MobilePhone'),
      userId?: string(name='UserId'),
      comments?: string(name='Comments'),
      lastLoginDate?: string(name='LastLoginDate'),
      createDate?: string(name='CreateDate'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListUsers', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListUsersForGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUsersForGroupResponseBody = {
  requestId?: string(name='RequestId'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  users?: {
    user?: [ 
    {
      userPrincipalName?: string(name='UserPrincipalName'),
      displayName?: string(name='DisplayName'),
      userId?: string(name='UserId'),
      joinDate?: string(name='JoinDate'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersForGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersForGroupResponseBody(name='body'),
}

async function listUsersForGroupWithOptions(request: ListUsersForGroupRequest, runtime: Util.RuntimeOptions): ListUsersForGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListUsersForGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersForGroupWithOptions(request, runtime);
}

model ListVirtualMFADevicesRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model ListVirtualMFADevicesResponseBody = {
  virtualMFADevices?: {
    virtualMFADevice?: [ 
    {
      serialNumber?: string(name='SerialNumber'),
      user?: {
        userPrincipalName?: string(name='UserPrincipalName'),
        displayName?: string(name='DisplayName'),
        userId?: string(name='UserId'),
      }(name='User'),
      activateDate?: string(name='ActivateDate'),
    }
  ](name='VirtualMFADevice')
  }(name='VirtualMFADevices'),
  requestId?: string(name='RequestId'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
}

model ListVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualMFADevicesResponseBody(name='body'),
}

async function listVirtualMFADevicesWithOptions(request: ListVirtualMFADevicesRequest, runtime: Util.RuntimeOptions): ListVirtualMFADevicesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListVirtualMFADevices', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listVirtualMFADevices(request: ListVirtualMFADevicesRequest): ListVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualMFADevicesWithOptions(request, runtime);
}

model RemoveUserFromGroupRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  groupPrincipalName?: string(name='GroupPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  groupName?: string(name='GroupName'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RemoveUserFromGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model SetDefaultDomainRequest {
  defaultDomainName?: string(name='DefaultDomainName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model SetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model SetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultDomainResponseBody(name='body'),
}

async function setDefaultDomainWithOptions(request: SetDefaultDomainRequest, runtime: Util.RuntimeOptions): SetDefaultDomainResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetDefaultDomain', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setDefaultDomain(request: SetDefaultDomainRequest): SetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultDomainWithOptions(request, runtime);
}

model SetPasswordPolicyRequest {
  minimumPasswordLength?: int32(name='MinimumPasswordLength'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  requireNumbers?: boolean(name='RequireNumbers'),
  requireSymbols?: boolean(name='RequireSymbols'),
  hardExpire?: boolean(name='HardExpire'),
  maxLoginAttemps?: int32(name='MaxLoginAttemps'),
  passwordReusePrevention?: int32(name='PasswordReusePrevention'),
  maxPasswordAge?: int32(name='MaxPasswordAge'),
  minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
  passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model SetPasswordPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  passwordPolicy?: {
    requireNumbers?: boolean(name='RequireNumbers'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireSymbols?: boolean(name='RequireSymbols'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    hardExpire?: boolean(name='HardExpire'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
  }(name='PasswordPolicy'),
}

model SetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetPasswordPolicyResponseBody(name='body'),
}

async function setPasswordPolicyWithOptions(request: SetPasswordPolicyRequest, runtime: Util.RuntimeOptions): SetPasswordPolicyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetPasswordPolicy', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPasswordPolicyWithOptions(request, runtime);
}

model SetSecurityPreferenceRequest {
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
  loginSessionDuration?: int32(name='LoginSessionDuration'),
  loginNetworkMasks?: string(name='LoginNetworkMasks'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model SetSecurityPreferenceResponseBody = {
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
  }(name='SecurityPreference'),
  requestId?: string(name='RequestId'),
}

model SetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  body: SetSecurityPreferenceResponseBody(name='body'),
}

async function setSecurityPreferenceWithOptions(request: SetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): SetSecurityPreferenceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetSecurityPreference', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSecurityPreferenceWithOptions(request, runtime);
}

model SetUserSsoSettingsRequest {
  metadataDocument?: string(name='MetadataDocument'),
  ssoEnabled?: boolean(name='SsoEnabled'),
  auxiliaryDomain?: string(name='AuxiliaryDomain'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model SetUserSsoSettingsResponseBody = {
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
  requestId?: string(name='RequestId'),
}

model SetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: SetUserSsoSettingsResponseBody(name='body'),
}

async function setUserSsoSettingsWithOptions(request: SetUserSsoSettingsRequest, runtime: Util.RuntimeOptions): SetUserSsoSettingsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SetUserSsoSettings', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function setUserSsoSettings(request: SetUserSsoSettingsRequest): SetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setUserSsoSettingsWithOptions(request, runtime);
}

model UnbindMFADeviceRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model UnbindMFADeviceResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model UnbindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindMFADeviceResponseBody(name='body'),
}

async function unbindMFADeviceWithOptions(request: UnbindMFADeviceRequest, runtime: Util.RuntimeOptions): UnbindMFADeviceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UnbindMFADevice', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindMFADeviceWithOptions(request, runtime);
}

model UpdateAccessKeyRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
  status?: string(name='Status'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model UpdateAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAccessKeyResponseBody(name='body'),
}

async function updateAccessKeyWithOptions(request: UpdateAccessKeyRequest, runtime: Util.RuntimeOptions): UpdateAccessKeyResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateAccessKey', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessKeyWithOptions(request, runtime);
}

model UpdateApplicationRequest {
  appId?: string(name='AppId'),
  newDisplayName?: string(name='NewDisplayName'),
  newRedirectUris?: string(name='NewRedirectUris'),
  newPredefinedScopes?: string(name='NewPredefinedScopes'),
  newSecretRequired?: boolean(name='NewSecretRequired'),
  newAccessTokenValidity?: int32(name='NewAccessTokenValidity'),
  newRefreshTokenValidity?: int32(name='NewRefreshTokenValidity'),
  newIsMultiTenant?: boolean(name='NewIsMultiTenant'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model UpdateApplicationResponseBody = {
  requestId?: string(name='RequestId'),
  application?: {
    displayName?: string(name='DisplayName'),
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    accountId?: string(name='AccountId'),
    createDate?: string(name='CreateDate'),
    appName?: string(name='AppName'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    updateDate?: string(name='UpdateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    appId?: string(name='AppId'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    appType?: string(name='AppType'),
  }(name='Application'),
}

model UpdateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationResponseBody(name='body'),
}

async function updateApplicationWithOptions(request: UpdateApplicationRequest, runtime: Util.RuntimeOptions): UpdateApplicationResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateApplication', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationWithOptions(request, runtime);
}

model UpdateGroupRequest {
  groupPrincipalName?: string(name='GroupPrincipalName'),
  newGroupPrincipalName?: string(name='NewGroupPrincipalName'),
  newComments?: string(name='NewComments'),
  newDisplayName?: string(name='NewDisplayName'),
  akProxySuffix?: string(name='AkProxySuffix'),
  newGroupName?: string(name='NewGroupName'),
  groupName?: string(name='GroupName'),
}

model UpdateGroupResponseBody = {
  group?: {
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    updateDate?: string(name='UpdateDate'),
    groupName?: string(name='GroupName'),
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateGroup', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model UpdateLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  MFABindRequired?: boolean(name='MFABindRequired'),
  generateRandomPassword?: boolean(name='GenerateRandomPassword'),
  status?: string(name='Status'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model UpdateLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
  loginProfile?: {
    userPrincipalName?: string(name='UserPrincipalName'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    MFABindRequired?: boolean(name='MFABindRequired'),
  }(name='LoginProfile'),
}

model UpdateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLoginProfileResponseBody(name='body'),
}

async function updateLoginProfileWithOptions(request: UpdateLoginProfileRequest, runtime: Util.RuntimeOptions): UpdateLoginProfileResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateLoginProfile', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoginProfileWithOptions(request, runtime);
}

model UpdateSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
  newSAMLMetadataDocument?: string(name='NewSAMLMetadataDocument'),
  newDescription?: string(name='NewDescription'),
  akProxySuffix?: string(name='AkProxySuffix'),
  newEncodedSAMLMetadataDocument?: string(name='NewEncodedSAMLMetadataDocument'),
}

model UpdateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    updateDate?: string(name='UpdateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    createDate?: string(name='CreateDate'),
    arn?: string(name='Arn'),
  }(name='SAMLProvider'),
}

model UpdateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSAMLProviderResponseBody(name='body'),
}

async function updateSAMLProviderWithOptions(request: UpdateSAMLProviderRequest, runtime: Util.RuntimeOptions): UpdateSAMLProviderResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateSAMLProvider', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateSAMLProvider(request: UpdateSAMLProviderRequest): UpdateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSAMLProviderWithOptions(request, runtime);
}

model UpdateUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
  userId?: string(name='UserId'),
  newUserPrincipalName?: string(name='NewUserPrincipalName'),
  newDisplayName?: string(name='NewDisplayName'),
  newMobilePhone?: string(name='NewMobilePhone'),
  newEmail?: string(name='NewEmail'),
  newComments?: string(name='NewComments'),
  akProxySuffix?: string(name='AkProxySuffix'),
}

model UpdateUserResponseBody = {
  user?: {
    displayName?: string(name='DisplayName'),
    userPrincipalName?: string(name='UserPrincipalName'),
    email?: string(name='Email'),
    updateDate?: string(name='UpdateDate'),
    mobilePhone?: string(name='MobilePhone'),
    userId?: string(name='UserId'),
    comments?: string(name='Comments'),
    lastLoginDate?: string(name='LastLoginDate'),
    createDate?: string(name='CreateDate'),
  }(name='User'),
  requestId?: string(name='RequestId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateUser', '2019-08-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

