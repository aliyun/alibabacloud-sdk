/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('ims', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddClientIdToOIDCProviderRequest {
  clientId?: string(name='ClientId'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model AddClientIdToOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model AddClientIdToOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddClientIdToOIDCProviderResponseBody(name='body'),
}

async function addClientIdToOIDCProviderWithOptions(request: AddClientIdToOIDCProviderRequest, runtime: Util.RuntimeOptions): AddClientIdToOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddClientIdToOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addClientIdToOIDCProvider(request: AddClientIdToOIDCProviderRequest): AddClientIdToOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return addClientIdToOIDCProviderWithOptions(request, runtime);
}

model AddFingerprintToOIDCProviderRequest {
  fingerprint?: string(name='Fingerprint'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model AddFingerprintToOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model AddFingerprintToOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddFingerprintToOIDCProviderResponseBody(name='body'),
}

async function addFingerprintToOIDCProviderWithOptions(request: AddFingerprintToOIDCProviderRequest, runtime: Util.RuntimeOptions): AddFingerprintToOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fingerprint)) {
    query['Fingerprint'] = request.fingerprint;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddFingerprintToOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addFingerprintToOIDCProvider(request: AddFingerprintToOIDCProviderRequest): AddFingerprintToOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return addFingerprintToOIDCProviderWithOptions(request, runtime);
}

model AddUserToGroupRequest {
  groupName?: string(name='GroupName'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroupWithOptions(request: AddUserToGroupRequest, runtime: Util.RuntimeOptions): AddUserToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUserToGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUserToGroupWithOptions(request, runtime);
}

model BindMFADeviceRequest {
  authenticationCode1?: string(name='AuthenticationCode1'),
  authenticationCode2?: string(name='AuthenticationCode2'),
  serialNumber?: string(name='SerialNumber'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model BindMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindMFADeviceResponseBody(name='body'),
}

async function bindMFADeviceWithOptions(request: BindMFADeviceRequest, runtime: Util.RuntimeOptions): BindMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authenticationCode1)) {
    query['AuthenticationCode1'] = request.authenticationCode1;
  }
  if (!Util.isUnset(request.authenticationCode2)) {
    query['AuthenticationCode2'] = request.authenticationCode2;
  }
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BindMFADevice',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindMFADeviceWithOptions(request, runtime);
}

model ChangePasswordRequest {
  newPassword?: string(name='NewPassword'),
  oldPassword?: string(name='OldPassword'),
}

model ChangePasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePasswordWithOptions(request: ChangePasswordRequest, runtime: Util.RuntimeOptions): ChangePasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newPassword)) {
    query['NewPassword'] = request.newPassword;
  }
  if (!Util.isUnset(request.oldPassword)) {
    query['OldPassword'] = request.oldPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangePassword',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return changePasswordWithOptions(request, runtime);
}

model CreateAccessKeyRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model CreateAccessKeyResponseBody = {
  accessKey?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    createDate?: string(name='CreateDate'),
    status?: string(name='Status'),
  }(name='AccessKey'),
  requestId?: string(name='RequestId'),
}

model CreateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccessKeyResponseBody(name='body'),
}

async function createAccessKeyWithOptions(request: CreateAccessKeyRequest, runtime: Util.RuntimeOptions): CreateAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccessKey',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccessKeyWithOptions(request, runtime);
}

model CreateAppSecretRequest {
  appId?: string(name='AppId'),
}

model CreateAppSecretResponseBody = {
  appSecret?: {
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    appSecretValue?: string(name='AppSecretValue'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
  requestId?: string(name='RequestId'),
}

model CreateAppSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppSecretResponseBody(name='body'),
}

async function createAppSecretWithOptions(request: CreateAppSecretRequest, runtime: Util.RuntimeOptions): CreateAppSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppSecret',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppSecret(request: CreateAppSecretRequest): CreateAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppSecretWithOptions(request, runtime);
}

model CreateApplicationRequest {
  accessTokenValidity?: int32(name='AccessTokenValidity'),
  appName?: string(name='AppName'),
  appType?: string(name='AppType'),
  displayName?: string(name='DisplayName'),
  isMultiTenant?: boolean(name='IsMultiTenant'),
  predefinedScopes?: string(name='PredefinedScopes'),
  redirectUris?: string(name='RedirectUris'),
  refreshTokenValidity?: int32(name='RefreshTokenValidity'),
  secretRequired?: boolean(name='SecretRequired'),
}

model CreateApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplicationWithOptions(request: CreateApplicationRequest, runtime: Util.RuntimeOptions): CreateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessTokenValidity)) {
    query['AccessTokenValidity'] = request.accessTokenValidity;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.isMultiTenant)) {
    query['IsMultiTenant'] = request.isMultiTenant;
  }
  if (!Util.isUnset(request.predefinedScopes)) {
    query['PredefinedScopes'] = request.predefinedScopes;
  }
  if (!Util.isUnset(request.redirectUris)) {
    query['RedirectUris'] = request.redirectUris;
  }
  if (!Util.isUnset(request.refreshTokenValidity)) {
    query['RefreshTokenValidity'] = request.refreshTokenValidity;
  }
  if (!Util.isUnset(request.secretRequired)) {
    query['SecretRequired'] = request.secretRequired;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApplication',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createApplicationWithOptions(request, runtime);
}

model CreateGroupRequest {
  comments?: string(name='Comments'),
  displayName?: string(name='DisplayName'),
  groupName?: string(name='GroupName'),
}

model CreateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroupWithOptions(request: CreateGroupRequest, runtime: Util.RuntimeOptions): CreateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGroupWithOptions(request, runtime);
}

model CreateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  status?: string(name='Status'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model CreateLoginProfileResponseBody = {
  loginProfile?: {
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model CreateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLoginProfileResponseBody(name='body'),
}

async function createLoginProfileWithOptions(request: CreateLoginProfileRequest, runtime: Util.RuntimeOptions): CreateLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.MFABindRequired)) {
    query['MFABindRequired'] = request.MFABindRequired;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordResetRequired)) {
    query['PasswordResetRequired'] = request.passwordResetRequired;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLoginProfile',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLoginProfileWithOptions(request, runtime);
}

model CreateOIDCProviderRequest {
  clientIds?: string(name='ClientIds'),
  description?: string(name='Description'),
  fingerprints?: string(name='Fingerprints'),
  issuerUrl?: string(name='IssuerUrl'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model CreateOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model CreateOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOIDCProviderResponseBody(name='body'),
}

async function createOIDCProviderWithOptions(request: CreateOIDCProviderRequest, runtime: Util.RuntimeOptions): CreateOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientIds)) {
    query['ClientIds'] = request.clientIds;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.fingerprints)) {
    query['Fingerprints'] = request.fingerprints;
  }
  if (!Util.isUnset(request.issuerUrl)) {
    query['IssuerUrl'] = request.issuerUrl;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOIDCProvider(request: CreateOIDCProviderRequest): CreateOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOIDCProviderWithOptions(request, runtime);
}

model CreateSAMLProviderRequest {
  description?: string(name='Description'),
  encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
  SAMLProviderName?: string(name='SAMLProviderName'),
}

model CreateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model CreateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSAMLProviderResponseBody(name='body'),
}

async function createSAMLProviderWithOptions(request: CreateSAMLProviderRequest, runtime: Util.RuntimeOptions): CreateSAMLProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encodedSAMLMetadataDocument)) {
    query['EncodedSAMLMetadataDocument'] = request.encodedSAMLMetadataDocument;
  }
  if (!Util.isUnset(request.SAMLProviderName)) {
    query['SAMLProviderName'] = request.SAMLProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSAMLProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSAMLProvider(request: CreateSAMLProviderRequest): CreateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSAMLProviderWithOptions(request, runtime);
}

model CreateUserRequest {
  comments?: string(name='Comments'),
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  mobilePhone?: string(name='MobilePhone'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    provisionType?: string(name='ProvisionType'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comments)) {
    query['Comments'] = request.comments;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.mobilePhone)) {
    query['MobilePhone'] = request.mobilePhone;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateVirtualMFADeviceRequest {
  virtualMFADeviceName?: string(name='VirtualMFADeviceName'),
}

model CreateVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
  virtualMFADevice?: {
    base32StringSeed?: string(name='Base32StringSeed'),
    QRCodePNG?: string(name='QRCodePNG'),
    serialNumber?: string(name='SerialNumber'),
  }(name='VirtualMFADevice'),
}

model CreateVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualMFADeviceResponseBody(name='body'),
}

async function createVirtualMFADeviceWithOptions(request: CreateVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): CreateVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.virtualMFADeviceName)) {
    query['VirtualMFADeviceName'] = request.virtualMFADeviceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualMFADevice',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualMFADeviceWithOptions(request, runtime);
}

model DeleteAccessKeyRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model DeleteAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccessKeyResponseBody(name='body'),
}

async function deleteAccessKeyWithOptions(request: DeleteAccessKeyRequest, runtime: Util.RuntimeOptions): DeleteAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccessKey',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccessKeyWithOptions(request, runtime);
}

model DeleteAppSecretRequest {
  appId?: string(name='AppId'),
  appSecretId?: string(name='AppSecretId'),
}

model DeleteAppSecretResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppSecretResponseBody(name='body'),
}

async function deleteAppSecretWithOptions(request: DeleteAppSecretRequest, runtime: Util.RuntimeOptions): DeleteAppSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appSecretId)) {
    query['AppSecretId'] = request.appSecretId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAppSecret',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAppSecret(request: DeleteAppSecretRequest): DeleteAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppSecretWithOptions(request, runtime);
}

model DeleteApplicationRequest {
  appId?: string(name='AppId'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplicationWithOptions(request: DeleteApplicationRequest, runtime: Util.RuntimeOptions): DeleteApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApplication',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteApplicationWithOptions(request, runtime);
}

model DeleteGroupRequest {
  groupName?: string(name='GroupName'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroupWithOptions(request: DeleteGroupRequest, runtime: Util.RuntimeOptions): DeleteGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGroupWithOptions(request, runtime);
}

model DeleteLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model DeleteLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteLoginProfileResponseBody(name='body'),
}

async function deleteLoginProfileWithOptions(request: DeleteLoginProfileRequest, runtime: Util.RuntimeOptions): DeleteLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteLoginProfile',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteLoginProfileWithOptions(request, runtime);
}

model DeleteOIDCProviderRequest {
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model DeleteOIDCProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOIDCProviderResponseBody(name='body'),
}

async function deleteOIDCProviderWithOptions(request: DeleteOIDCProviderRequest, runtime: Util.RuntimeOptions): DeleteOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOIDCProvider(request: DeleteOIDCProviderRequest): DeleteOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOIDCProviderWithOptions(request, runtime);
}

model DeleteSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
}

model DeleteSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSAMLProviderResponseBody(name='body'),
}

async function deleteSAMLProviderWithOptions(request: DeleteSAMLProviderRequest, runtime: Util.RuntimeOptions): DeleteSAMLProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SAMLProviderName)) {
    query['SAMLProviderName'] = request.SAMLProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSAMLProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSAMLProvider(request: DeleteSAMLProviderRequest): DeleteSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSAMLProviderWithOptions(request, runtime);
}

model DeleteUserRequest {
  userId?: string(name='UserId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteVirtualMFADeviceRequest {
  serialNumber?: string(name='SerialNumber'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADeviceWithOptions(request: DeleteVirtualMFADeviceRequest, runtime: Util.RuntimeOptions): DeleteVirtualMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.serialNumber)) {
    query['SerialNumber'] = request.serialNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualMFADevice',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualMFADeviceWithOptions(request, runtime);
}

model DisableVirtualMFARequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model DisableVirtualMFAResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVirtualMFAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableVirtualMFAResponseBody(name='body'),
}

async function disableVirtualMFAWithOptions(request: DisableVirtualMFARequest, runtime: Util.RuntimeOptions): DisableVirtualMFAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableVirtualMFA',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableVirtualMFA(request: DisableVirtualMFARequest): DisableVirtualMFAResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableVirtualMFAWithOptions(request, runtime);
}

model GenerateCredentialReportResponseBody = {
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model GenerateCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateCredentialReportResponseBody(name='body'),
}

async function generateCredentialReportWithOptions(runtime: Util.RuntimeOptions): GenerateCredentialReportResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GenerateCredentialReport',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateCredentialReport(): GenerateCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateCredentialReportWithOptions(runtime);
}

model GetAccessKeyLastUsedRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model GetAccessKeyLastUsedResponseBody = {
  accessKeyLastUsed?: {
    lastUsedDate?: string(name='LastUsedDate'),
  }(name='AccessKeyLastUsed'),
  requestId?: string(name='RequestId'),
}

model GetAccessKeyLastUsedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccessKeyLastUsedResponseBody(name='body'),
}

async function getAccessKeyLastUsedWithOptions(request: GetAccessKeyLastUsedRequest, runtime: Util.RuntimeOptions): GetAccessKeyLastUsedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccessKeyLastUsed',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccessKeyLastUsedWithOptions(request, runtime);
}

model GetAccountMFAInfoResponseBody = {
  isMFAEnable?: boolean(name='IsMFAEnable'),
  requestId?: string(name='RequestId'),
}

model GetAccountMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountMFAInfoResponseBody(name='body'),
}

async function getAccountMFAInfoWithOptions(runtime: Util.RuntimeOptions): GetAccountMFAInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAccountMFAInfo',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountMFAInfo(): GetAccountMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountMFAInfoWithOptions(runtime);
}

model GetAccountSecurityPracticeReportResponseBody = {
  accountSecurityPracticeInfo?: {
    accountSecurityPracticeUserInfo?: {
      bindMfa?: boolean(name='BindMfa'),
      oldAkNum?: int32(name='OldAkNum'),
      rootWithAccessKey?: int32(name='RootWithAccessKey'),
      subUser?: int32(name='SubUser'),
      subUserBindMfa?: int32(name='SubUserBindMfa'),
      subUserPwdLevel?: string(name='SubUserPwdLevel'),
      subUserWithOldAccessKey?: int32(name='SubUserWithOldAccessKey'),
      subUserWithUnusedAccessKey?: int32(name='SubUserWithUnusedAccessKey'),
      unusedAkNum?: int32(name='UnusedAkNum'),
    }(name='AccountSecurityPracticeUserInfo'),
    score?: int32(name='Score'),
  }(name='AccountSecurityPracticeInfo'),
  requestId?: string(name='RequestId'),
}

model GetAccountSecurityPracticeReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountSecurityPracticeReportResponseBody(name='body'),
}

async function getAccountSecurityPracticeReportWithOptions(runtime: Util.RuntimeOptions): GetAccountSecurityPracticeReportResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAccountSecurityPracticeReport',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountSecurityPracticeReport(): GetAccountSecurityPracticeReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSecurityPracticeReportWithOptions(runtime);
}

model GetAccountSummaryResponseBody = {
  requestId?: string(name='RequestId'),
  summaryMap?: {
    accessKeysPerUserQuota?: int32(name='AccessKeysPerUserQuota'),
    attachedPoliciesPerGroupQuota?: int32(name='AttachedPoliciesPerGroupQuota'),
    attachedPoliciesPerRoleQuota?: int32(name='AttachedPoliciesPerRoleQuota'),
    attachedPoliciesPerUserQuota?: int32(name='AttachedPoliciesPerUserQuota'),
    attachedSystemPoliciesPerGroupQuota?: int32(name='AttachedSystemPoliciesPerGroupQuota'),
    attachedSystemPoliciesPerRoleQuota?: int32(name='AttachedSystemPoliciesPerRoleQuota'),
    attachedSystemPoliciesPerUserQuota?: int32(name='AttachedSystemPoliciesPerUserQuota'),
    groups?: int32(name='Groups'),
    groupsPerUserQuota?: int32(name='GroupsPerUserQuota'),
    groupsQuota?: int32(name='GroupsQuota'),
    MFADevices?: int32(name='MFADevices'),
    MFADevicesInUse?: int32(name='MFADevicesInUse'),
    policies?: int32(name='Policies'),
    policiesQuota?: int32(name='PoliciesQuota'),
    policySizeQuota?: int32(name='PolicySizeQuota'),
    roles?: int32(name='Roles'),
    rolesQuota?: int32(name='RolesQuota'),
    users?: int32(name='Users'),
    usersQuota?: int32(name='UsersQuota'),
    versionsPerPolicyQuota?: int32(name='VersionsPerPolicyQuota'),
    virtualMFADevicesQuota?: int32(name='VirtualMFADevicesQuota'),
  }(name='SummaryMap'),
}

model GetAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountSummaryResponseBody(name='body'),
}

async function getAccountSummaryWithOptions(runtime: Util.RuntimeOptions): GetAccountSummaryResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAccountSummary',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountSummary(): GetAccountSummaryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountSummaryWithOptions(runtime);
}

model GetAppSecretRequest {
  appId?: string(name='AppId'),
  appSecretId?: string(name='AppSecretId'),
}

model GetAppSecretResponseBody = {
  appSecret?: {
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    appSecretValue?: string(name='AppSecretValue'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
  requestId?: string(name='RequestId'),
}

model GetAppSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppSecretResponseBody(name='body'),
}

async function getAppSecretWithOptions(request: GetAppSecretRequest, runtime: Util.RuntimeOptions): GetAppSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appSecretId)) {
    query['AppSecretId'] = request.appSecretId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppSecret',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppSecretWithOptions(request, runtime);
}

model GetApplicationRequest {
  appId?: string(name='AppId'),
}

model GetApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplicationWithOptions(request: GetApplicationRequest, runtime: Util.RuntimeOptions): GetApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApplication',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getApplicationWithOptions(request, runtime);
}

model GetCredentialReportResponseBody = {
  content?: string(name='Content'),
  generatedTime?: string(name='GeneratedTime'),
  requestId?: string(name='RequestId'),
}

model GetCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCredentialReportResponseBody(name='body'),
}

async function getCredentialReportWithOptions(runtime: Util.RuntimeOptions): GetCredentialReportResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCredentialReport',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCredentialReport(): GetCredentialReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCredentialReportWithOptions(runtime);
}

model GetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDefaultDomainResponseBody(name='body'),
}

async function getDefaultDomainWithOptions(runtime: Util.RuntimeOptions): GetDefaultDomainResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetDefaultDomain',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultDomain(): GetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultDomainWithOptions(runtime);
}

model GetGroupRequest {
  groupName?: string(name='GroupName'),
}

model GetGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroupWithOptions(request: GetGroupRequest, runtime: Util.RuntimeOptions): GetGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getGroupWithOptions(request, runtime);
}

model GetLoginProfileRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model GetLoginProfileResponseBody = {
  loginProfile?: {
    lastLoginTime?: string(name='LastLoginTime'),
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model GetLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoginProfileResponseBody(name='body'),
}

async function getLoginProfileWithOptions(request: GetLoginProfileRequest, runtime: Util.RuntimeOptions): GetLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLoginProfile',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLoginProfileWithOptions(request, runtime);
}

model GetOIDCProviderRequest {
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model GetOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model GetOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOIDCProviderResponseBody(name='body'),
}

async function getOIDCProviderWithOptions(request: GetOIDCProviderRequest, runtime: Util.RuntimeOptions): GetOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOIDCProvider(request: GetOIDCProviderRequest): GetOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOIDCProviderWithOptions(request, runtime);
}

model GetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpire?: boolean(name='HardExpire'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model GetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPasswordPolicyResponseBody(name='body'),
}

async function getPasswordPolicyWithOptions(runtime: Util.RuntimeOptions): GetPasswordPolicyResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetPasswordPolicy',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPasswordPolicy(): GetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPasswordPolicyWithOptions(runtime);
}

model GetSAMLProviderRequest {
  SAMLProviderName?: string(name='SAMLProviderName'),
}

model GetSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model GetSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSAMLProviderResponseBody(name='body'),
}

async function getSAMLProviderWithOptions(request: GetSAMLProviderRequest, runtime: Util.RuntimeOptions): GetSAMLProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.SAMLProviderName)) {
    query['SAMLProviderName'] = request.SAMLProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSAMLProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSAMLProvider(request: GetSAMLProviderRequest): GetSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSAMLProviderWithOptions(request, runtime);
}

model GetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      enforceMFAForLogin?: boolean(name='EnforceMFAForLogin'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    personalInfoPreference?: {
      allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk'),
    }(name='PersonalInfoPreference'),
  }(name='SecurityPreference'),
}

model GetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSecurityPreferenceResponseBody(name='body'),
}

async function getSecurityPreferenceWithOptions(runtime: Util.RuntimeOptions): GetSecurityPreferenceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetSecurityPreference',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSecurityPreference(): GetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSecurityPreferenceWithOptions(runtime);
}

model GetUserRequest {
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userId?: string(name='UserId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    provisionType?: string(name='ProvisionType'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserMFAInfoRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model GetUserMFAInfoResponseBody = {
  isMFAEnable?: boolean(name='IsMFAEnable'),
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
    type?: string(name='Type'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model GetUserMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserMFAInfoResponseBody(name='body'),
}

async function getUserMFAInfoWithOptions(request: GetUserMFAInfoRequest, runtime: Util.RuntimeOptions): GetUserMFAInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserMFAInfo',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserMFAInfoWithOptions(request, runtime);
}

model GetUserSsoSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
}

model GetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserSsoSettingsResponseBody(name='body'),
}

async function getUserSsoSettingsWithOptions(runtime: Util.RuntimeOptions): GetUserSsoSettingsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetUserSsoSettings',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserSsoSettings(): GetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserSsoSettingsWithOptions(runtime);
}

model ListAccessKeysRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model ListAccessKeysResponseBody = {
  accessKeys?: {
    accessKey?: [ 
    {
      accessKeyId?: string(name='AccessKeyId'),
      createDate?: string(name='CreateDate'),
      status?: string(name='Status'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='AccessKey')
  }(name='AccessKeys'),
  requestId?: string(name='RequestId'),
}

model ListAccessKeysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessKeysResponseBody(name='body'),
}

async function listAccessKeysWithOptions(request: ListAccessKeysRequest, runtime: Util.RuntimeOptions): ListAccessKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessKeys',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessKeysWithOptions(request, runtime);
}

model ListAppSecretIdsRequest {
  appId?: string(name='AppId'),
}

model ListAppSecretIdsResponseBody = {
  appSecrets?: {
    appSecret?: [ 
    {
      appId?: string(name='AppId'),
      appSecretId?: string(name='AppSecretId'),
      createDate?: string(name='CreateDate'),
    }
  ](name='AppSecret')
  }(name='AppSecrets'),
  requestId?: string(name='RequestId'),
}

model ListAppSecretIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppSecretIdsResponseBody(name='body'),
}

async function listAppSecretIdsWithOptions(request: ListAppSecretIdsRequest, runtime: Util.RuntimeOptions): ListAppSecretIdsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppSecretIds',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppSecretIds(request: ListAppSecretIdsRequest): ListAppSecretIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppSecretIdsWithOptions(request, runtime);
}

model ListApplicationsResponseBody = {
  applications?: {
    application?: [ 
    {
      accessTokenValidity?: int32(name='AccessTokenValidity'),
      accountId?: string(name='AccountId'),
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appType?: string(name='AppType'),
      createDate?: string(name='CreateDate'),
      delegatedScope?: {
        predefinedScopes?: {
          predefinedScope?: [ 
          {
            description?: string(name='Description'),
            name?: string(name='Name'),
          }
        ](name='PredefinedScope')
        }(name='PredefinedScopes'),
      }(name='DelegatedScope'),
      displayName?: string(name='DisplayName'),
      isMultiTenant?: boolean(name='IsMultiTenant'),
      redirectUris?: {
        redirectUri?: [ string ](name='RedirectUri')
      }(name='RedirectUris'),
      refreshTokenValidity?: int32(name='RefreshTokenValidity'),
      secretRequired?: boolean(name='SecretRequired'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Application')
  }(name='Applications'),
  requestId?: string(name='RequestId'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplicationsWithOptions(runtime: Util.RuntimeOptions): ListApplicationsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListApplications',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApplications(): ListApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listApplicationsWithOptions(runtime);
}

model ListGroupsRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListGroupsResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      displayName?: string(name='DisplayName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Group')
  }(name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListGroupsForUserRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model ListGroupsForUserResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      displayName?: string(name='DisplayName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      joinDate?: string(name='JoinDate'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
}

model ListGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsForUserResponseBody(name='body'),
}

async function listGroupsForUserWithOptions(request: ListGroupsForUserRequest, runtime: Util.RuntimeOptions): ListGroupsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroupsForUser',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsForUserWithOptions(request, runtime);
}

model ListOIDCProvidersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListOIDCProvidersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  OIDCProviders?: {
    OIDCProvider?: [ 
    {
      arn?: string(name='Arn'),
      clientIds?: string(name='ClientIds'),
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      fingerprints?: string(name='Fingerprints'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      issuerUrl?: string(name='IssuerUrl'),
      OIDCProviderName?: string(name='OIDCProviderName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='OIDCProvider')
  }(name='OIDCProviders'),
  requestId?: string(name='RequestId'),
}

model ListOIDCProvidersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOIDCProvidersResponseBody(name='body'),
}

async function listOIDCProvidersWithOptions(request: ListOIDCProvidersRequest, runtime: Util.RuntimeOptions): ListOIDCProvidersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOIDCProviders',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOIDCProviders(request: ListOIDCProvidersRequest): ListOIDCProvidersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOIDCProvidersWithOptions(request, runtime);
}

model ListPredefinedScopesRequest {
  appType?: string(name='AppType'),
}

model ListPredefinedScopesResponseBody = {
  predefinedScopes?: {
    predefinedScope?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
    }
  ](name='PredefinedScope')
  }(name='PredefinedScopes'),
  requestId?: string(name='RequestId'),
}

model ListPredefinedScopesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPredefinedScopesResponseBody(name='body'),
}

async function listPredefinedScopesWithOptions(request: ListPredefinedScopesRequest, runtime: Util.RuntimeOptions): ListPredefinedScopesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPredefinedScopes',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPredefinedScopes(request: ListPredefinedScopesRequest): ListPredefinedScopesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPredefinedScopesWithOptions(request, runtime);
}

model ListSAMLProvidersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListSAMLProvidersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  SAMLProviders?: {
    SAMLProvider?: [ 
    {
      arn?: string(name='Arn'),
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      SAMLProviderName?: string(name='SAMLProviderName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='SAMLProvider')
  }(name='SAMLProviders'),
}

model ListSAMLProvidersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSAMLProvidersResponseBody(name='body'),
}

async function listSAMLProvidersWithOptions(request: ListSAMLProvidersRequest, runtime: Util.RuntimeOptions): ListSAMLProvidersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSAMLProviders',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSAMLProviders(request: ListSAMLProvidersRequest): ListSAMLProvidersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSAMLProvidersWithOptions(request, runtime);
}

model ListUserBasicInfosRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUserBasicInfosResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  userBasicInfos?: {
    userBasicInfo?: [ 
    {
      displayName?: string(name='DisplayName'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='UserBasicInfo')
  }(name='UserBasicInfos'),
}

model ListUserBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserBasicInfosResponseBody(name='body'),
}

async function listUserBasicInfosWithOptions(request: ListUserBasicInfosRequest, runtime: Util.RuntimeOptions): ListUserBasicInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserBasicInfos',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserBasicInfos(request: ListUserBasicInfosRequest): ListUserBasicInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserBasicInfosWithOptions(request, runtime);
}

model ListUsersRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUsersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      lastLoginDate?: string(name='LastLoginDate'),
      mobilePhone?: string(name='MobilePhone'),
      provisionType?: string(name='ProvisionType'),
      updateDate?: string(name='UpdateDate'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListUsersForGroupRequest {
  groupName?: string(name='GroupName'),
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListUsersForGroupResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      displayName?: string(name='DisplayName'),
      joinDate?: string(name='JoinDate'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersForGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersForGroupResponseBody(name='body'),
}

async function listUsersForGroupWithOptions(request: ListUsersForGroupRequest, runtime: Util.RuntimeOptions): ListUsersForGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsersForGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersForGroupWithOptions(request, runtime);
}

model ListVirtualMFADevicesRequest {
  marker?: string(name='Marker'),
  maxItems?: int32(name='MaxItems'),
}

model ListVirtualMFADevicesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  virtualMFADevices?: {
    virtualMFADevice?: [ 
    {
      activateDate?: string(name='ActivateDate'),
      serialNumber?: string(name='SerialNumber'),
      user?: {
        displayName?: string(name='DisplayName'),
        userId?: string(name='UserId'),
        userPrincipalName?: string(name='UserPrincipalName'),
      }(name='User'),
    }
  ](name='VirtualMFADevice')
  }(name='VirtualMFADevices'),
}

model ListVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVirtualMFADevicesResponseBody(name='body'),
}

async function listVirtualMFADevicesWithOptions(request: ListVirtualMFADevicesRequest, runtime: Util.RuntimeOptions): ListVirtualMFADevicesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.maxItems)) {
    query['MaxItems'] = request.maxItems;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVirtualMFADevices',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVirtualMFADevices(request: ListVirtualMFADevicesRequest): ListVirtualMFADevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVirtualMFADevicesWithOptions(request, runtime);
}

model RemoveClientIdFromOIDCProviderRequest {
  clientId?: string(name='ClientId'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model RemoveClientIdFromOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model RemoveClientIdFromOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveClientIdFromOIDCProviderResponseBody(name='body'),
}

async function removeClientIdFromOIDCProviderWithOptions(request: RemoveClientIdFromOIDCProviderRequest, runtime: Util.RuntimeOptions): RemoveClientIdFromOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveClientIdFromOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeClientIdFromOIDCProvider(request: RemoveClientIdFromOIDCProviderRequest): RemoveClientIdFromOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeClientIdFromOIDCProviderWithOptions(request, runtime);
}

model RemoveFingerprintFromOIDCProviderRequest {
  fingerprint?: string(name='Fingerprint'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model RemoveFingerprintFromOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model RemoveFingerprintFromOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveFingerprintFromOIDCProviderResponseBody(name='body'),
}

async function removeFingerprintFromOIDCProviderWithOptions(request: RemoveFingerprintFromOIDCProviderRequest, runtime: Util.RuntimeOptions): RemoveFingerprintFromOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fingerprint)) {
    query['Fingerprint'] = request.fingerprint;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveFingerprintFromOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeFingerprintFromOIDCProvider(request: RemoveFingerprintFromOIDCProviderRequest): RemoveFingerprintFromOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeFingerprintFromOIDCProviderWithOptions(request, runtime);
}

model RemoveUserFromGroupRequest {
  groupName?: string(name='GroupName'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroupWithOptions(request: RemoveUserFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUserFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUserFromGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUserFromGroupWithOptions(request, runtime);
}

model SetDefaultDomainRequest {
  defaultDomainName?: string(name='DefaultDomainName'),
}

model SetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model SetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetDefaultDomainResponseBody(name='body'),
}

async function setDefaultDomainWithOptions(request: SetDefaultDomainRequest, runtime: Util.RuntimeOptions): SetDefaultDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.defaultDomainName)) {
    query['DefaultDomainName'] = request.defaultDomainName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetDefaultDomain',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setDefaultDomain(request: SetDefaultDomainRequest): SetDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setDefaultDomainWithOptions(request, runtime);
}

model SetPasswordPolicyRequest {
  hardExpire?: boolean(name='HardExpire'),
  maxLoginAttemps?: int32(name='MaxLoginAttemps'),
  maxPasswordAge?: int32(name='MaxPasswordAge'),
  minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
  minimumPasswordLength?: int32(name='MinimumPasswordLength'),
  passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
  passwordReusePrevention?: int32(name='PasswordReusePrevention'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
  requireNumbers?: boolean(name='RequireNumbers'),
  requireSymbols?: boolean(name='RequireSymbols'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
}

model SetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpire?: boolean(name='HardExpire'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model SetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetPasswordPolicyResponseBody(name='body'),
}

async function setPasswordPolicyWithOptions(request: SetPasswordPolicyRequest, runtime: Util.RuntimeOptions): SetPasswordPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hardExpire)) {
    query['HardExpire'] = request.hardExpire;
  }
  if (!Util.isUnset(request.maxLoginAttemps)) {
    query['MaxLoginAttemps'] = request.maxLoginAttemps;
  }
  if (!Util.isUnset(request.maxPasswordAge)) {
    query['MaxPasswordAge'] = request.maxPasswordAge;
  }
  if (!Util.isUnset(request.minimumPasswordDifferentCharacter)) {
    query['MinimumPasswordDifferentCharacter'] = request.minimumPasswordDifferentCharacter;
  }
  if (!Util.isUnset(request.minimumPasswordLength)) {
    query['MinimumPasswordLength'] = request.minimumPasswordLength;
  }
  if (!Util.isUnset(request.passwordNotContainUserName)) {
    query['PasswordNotContainUserName'] = request.passwordNotContainUserName;
  }
  if (!Util.isUnset(request.passwordReusePrevention)) {
    query['PasswordReusePrevention'] = request.passwordReusePrevention;
  }
  if (!Util.isUnset(request.requireLowercaseCharacters)) {
    query['RequireLowercaseCharacters'] = request.requireLowercaseCharacters;
  }
  if (!Util.isUnset(request.requireNumbers)) {
    query['RequireNumbers'] = request.requireNumbers;
  }
  if (!Util.isUnset(request.requireSymbols)) {
    query['RequireSymbols'] = request.requireSymbols;
  }
  if (!Util.isUnset(request.requireUppercaseCharacters)) {
    query['RequireUppercaseCharacters'] = request.requireUppercaseCharacters;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetPasswordPolicy',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return setPasswordPolicyWithOptions(request, runtime);
}

model SetSecurityPreferenceRequest {
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
  allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk'),
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
  enforceMFAForLogin?: boolean(name='EnforceMFAForLogin'),
  loginNetworkMasks?: string(name='LoginNetworkMasks'),
  loginSessionDuration?: int32(name='LoginSessionDuration'),
}

model SetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      enforceMFAForLogin?: boolean(name='EnforceMFAForLogin'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    personalInfoPreference?: {
      allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk'),
    }(name='PersonalInfoPreference'),
  }(name='SecurityPreference'),
}

model SetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetSecurityPreferenceResponseBody(name='body'),
}

async function setSecurityPreferenceWithOptions(request: SetSecurityPreferenceRequest, runtime: Util.RuntimeOptions): SetSecurityPreferenceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allowUserToChangePassword)) {
    query['AllowUserToChangePassword'] = request.allowUserToChangePassword;
  }
  if (!Util.isUnset(request.allowUserToManageAccessKeys)) {
    query['AllowUserToManageAccessKeys'] = request.allowUserToManageAccessKeys;
  }
  if (!Util.isUnset(request.allowUserToManageMFADevices)) {
    query['AllowUserToManageMFADevices'] = request.allowUserToManageMFADevices;
  }
  if (!Util.isUnset(request.allowUserToManagePersonalDingTalk)) {
    query['AllowUserToManagePersonalDingTalk'] = request.allowUserToManagePersonalDingTalk;
  }
  if (!Util.isUnset(request.enableSaveMFATicket)) {
    query['EnableSaveMFATicket'] = request.enableSaveMFATicket;
  }
  if (!Util.isUnset(request.enforceMFAForLogin)) {
    query['EnforceMFAForLogin'] = request.enforceMFAForLogin;
  }
  if (!Util.isUnset(request.loginNetworkMasks)) {
    query['LoginNetworkMasks'] = request.loginNetworkMasks;
  }
  if (!Util.isUnset(request.loginSessionDuration)) {
    query['LoginSessionDuration'] = request.loginSessionDuration;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetSecurityPreference',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return setSecurityPreferenceWithOptions(request, runtime);
}

model SetUserSsoSettingsRequest {
  auxiliaryDomain?: string(name='AuxiliaryDomain'),
  metadataDocument?: string(name='MetadataDocument'),
  ssoEnabled?: boolean(name='SsoEnabled'),
}

model SetUserSsoSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
}

model SetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetUserSsoSettingsResponseBody(name='body'),
}

async function setUserSsoSettingsWithOptions(request: SetUserSsoSettingsRequest, runtime: Util.RuntimeOptions): SetUserSsoSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.auxiliaryDomain)) {
    query['AuxiliaryDomain'] = request.auxiliaryDomain;
  }
  if (!Util.isUnset(request.metadataDocument)) {
    query['MetadataDocument'] = request.metadataDocument;
  }
  if (!Util.isUnset(request.ssoEnabled)) {
    query['SsoEnabled'] = request.ssoEnabled;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetUserSsoSettings',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setUserSsoSettings(request: SetUserSsoSettingsRequest): SetUserSsoSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return setUserSsoSettingsWithOptions(request, runtime);
}

model UnbindMFADeviceRequest {
  userPrincipalName?: string(name='UserPrincipalName'),
}

model UnbindMFADeviceResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model UnbindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindMFADeviceResponseBody(name='body'),
}

async function unbindMFADeviceWithOptions(request: UnbindMFADeviceRequest, runtime: Util.RuntimeOptions): UnbindMFADeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnbindMFADevice',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindMFADeviceWithOptions(request, runtime);
}

model UpdateAccessKeyRequest {
  status?: string(name='Status'),
  userAccessKeyId?: string(name='UserAccessKeyId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model UpdateAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAccessKeyResponseBody(name='body'),
}

async function updateAccessKeyWithOptions(request: UpdateAccessKeyRequest, runtime: Util.RuntimeOptions): UpdateAccessKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userAccessKeyId)) {
    query['UserAccessKeyId'] = request.userAccessKeyId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAccessKey',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAccessKeyWithOptions(request, runtime);
}

model UpdateApplicationRequest {
  appId?: string(name='AppId'),
  newAccessTokenValidity?: int32(name='NewAccessTokenValidity'),
  newDisplayName?: string(name='NewDisplayName'),
  newIsMultiTenant?: boolean(name='NewIsMultiTenant'),
  newPredefinedScopes?: string(name='NewPredefinedScopes'),
  newRedirectUris?: string(name='NewRedirectUris'),
  newRefreshTokenValidity?: int32(name='NewRefreshTokenValidity'),
  newSecretRequired?: boolean(name='NewSecretRequired'),
}

model UpdateApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateApplicationResponseBody(name='body'),
}

async function updateApplicationWithOptions(request: UpdateApplicationRequest, runtime: Util.RuntimeOptions): UpdateApplicationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.newAccessTokenValidity)) {
    query['NewAccessTokenValidity'] = request.newAccessTokenValidity;
  }
  if (!Util.isUnset(request.newDisplayName)) {
    query['NewDisplayName'] = request.newDisplayName;
  }
  if (!Util.isUnset(request.newIsMultiTenant)) {
    query['NewIsMultiTenant'] = request.newIsMultiTenant;
  }
  if (!Util.isUnset(request.newPredefinedScopes)) {
    query['NewPredefinedScopes'] = request.newPredefinedScopes;
  }
  if (!Util.isUnset(request.newRedirectUris)) {
    query['NewRedirectUris'] = request.newRedirectUris;
  }
  if (!Util.isUnset(request.newRefreshTokenValidity)) {
    query['NewRefreshTokenValidity'] = request.newRefreshTokenValidity;
  }
  if (!Util.isUnset(request.newSecretRequired)) {
    query['NewSecretRequired'] = request.newSecretRequired;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApplication',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateApplicationWithOptions(request, runtime);
}

model UpdateGroupRequest {
  groupName?: string(name='GroupName'),
  newComments?: string(name='NewComments'),
  newDisplayName?: string(name='NewDisplayName'),
  newGroupName?: string(name='NewGroupName'),
}

model UpdateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroupWithOptions(request: UpdateGroupRequest, runtime: Util.RuntimeOptions): UpdateGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupName)) {
    query['GroupName'] = request.groupName;
  }
  if (!Util.isUnset(request.newComments)) {
    query['NewComments'] = request.newComments;
  }
  if (!Util.isUnset(request.newDisplayName)) {
    query['NewDisplayName'] = request.newDisplayName;
  }
  if (!Util.isUnset(request.newGroupName)) {
    query['NewGroupName'] = request.newGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateGroup',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateGroupWithOptions(request, runtime);
}

model UpdateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired'),
  password?: string(name='Password'),
  passwordResetRequired?: boolean(name='PasswordResetRequired'),
  status?: string(name='Status'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model UpdateLoginProfileResponseBody = {
  loginProfile?: {
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model UpdateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLoginProfileResponseBody(name='body'),
}

async function updateLoginProfileWithOptions(request: UpdateLoginProfileRequest, runtime: Util.RuntimeOptions): UpdateLoginProfileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.MFABindRequired)) {
    query['MFABindRequired'] = request.MFABindRequired;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.passwordResetRequired)) {
    query['PasswordResetRequired'] = request.passwordResetRequired;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLoginProfile',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateLoginProfileWithOptions(request, runtime);
}

model UpdateOIDCProviderRequest {
  clientIds?: string(name='ClientIds'),
  newDescription?: string(name='NewDescription'),
  OIDCProviderName?: string(name='OIDCProviderName'),
}

model UpdateOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model UpdateOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOIDCProviderResponseBody(name='body'),
}

async function updateOIDCProviderWithOptions(request: UpdateOIDCProviderRequest, runtime: Util.RuntimeOptions): UpdateOIDCProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientIds)) {
    query['ClientIds'] = request.clientIds;
  }
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.OIDCProviderName)) {
    query['OIDCProviderName'] = request.OIDCProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOIDCProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOIDCProvider(request: UpdateOIDCProviderRequest): UpdateOIDCProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOIDCProviderWithOptions(request, runtime);
}

model UpdateSAMLProviderRequest {
  newDescription?: string(name='NewDescription'),
  newEncodedSAMLMetadataDocument?: string(name='NewEncodedSAMLMetadataDocument'),
  SAMLProviderName?: string(name='SAMLProviderName'),
}

model UpdateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model UpdateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSAMLProviderResponseBody(name='body'),
}

async function updateSAMLProviderWithOptions(request: UpdateSAMLProviderRequest, runtime: Util.RuntimeOptions): UpdateSAMLProviderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newDescription)) {
    query['NewDescription'] = request.newDescription;
  }
  if (!Util.isUnset(request.newEncodedSAMLMetadataDocument)) {
    query['NewEncodedSAMLMetadataDocument'] = request.newEncodedSAMLMetadataDocument;
  }
  if (!Util.isUnset(request.SAMLProviderName)) {
    query['SAMLProviderName'] = request.SAMLProviderName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSAMLProvider',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSAMLProvider(request: UpdateSAMLProviderRequest): UpdateSAMLProviderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSAMLProviderWithOptions(request, runtime);
}

model UpdateUserRequest {
  newComments?: string(name='NewComments'),
  newDisplayName?: string(name='NewDisplayName'),
  newEmail?: string(name='NewEmail'),
  newMobilePhone?: string(name='NewMobilePhone'),
  newUserPrincipalName?: string(name='NewUserPrincipalName'),
  userId?: string(name='UserId'),
  userPrincipalName?: string(name='UserPrincipalName'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    provisionType?: string(name='ProvisionType'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.newComments)) {
    query['NewComments'] = request.newComments;
  }
  if (!Util.isUnset(request.newDisplayName)) {
    query['NewDisplayName'] = request.newDisplayName;
  }
  if (!Util.isUnset(request.newEmail)) {
    query['NewEmail'] = request.newEmail;
  }
  if (!Util.isUnset(request.newMobilePhone)) {
    query['NewMobilePhone'] = request.newMobilePhone;
  }
  if (!Util.isUnset(request.newUserPrincipalName)) {
    query['NewUserPrincipalName'] = request.newUserPrincipalName;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userPrincipalName)) {
    query['UserPrincipalName'] = request.userPrincipalName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2019-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

