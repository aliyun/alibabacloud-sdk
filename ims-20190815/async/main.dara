/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Ims';
  @version = '2019-08-15';
  @endpointRule = 'central';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddClientIdToOIDCProviderRequest {
  clientId?: string(name='ClientId', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model AddClientIdToOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model AddClientIdToOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: AddClientIdToOIDCProviderResponseBody(name='body'),
}

async function addClientIdToOIDCProvider(request: AddClientIdToOIDCProviderRequest): AddClientIdToOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddClientIdToOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model AddFingerprintToOIDCProviderRequest {
  fingerprint?: string(name='Fingerprint', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model AddFingerprintToOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model AddFingerprintToOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: AddFingerprintToOIDCProviderResponseBody(name='body'),
}

async function addFingerprintToOIDCProvider(request: AddFingerprintToOIDCProviderRequest): AddFingerprintToOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddFingerprintToOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model AddUserToGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model AddUserToGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddUserToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUserToGroupResponseBody(name='body'),
}

async function addUserToGroup(request: AddUserToGroupRequest): AddUserToGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddUserToGroup', 'POST', '/', 'json', false, 'json', request);
}

model BindMFADeviceRequest {
  authenticationCode1?: string(name='AuthenticationCode1', position='Query'),
  authenticationCode2?: string(name='AuthenticationCode2', position='Query'),
  serialNumber?: string(name='SerialNumber', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model BindMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model BindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: BindMFADeviceResponseBody(name='body'),
}

async function bindMFADevice(request: BindMFADeviceRequest): BindMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model ChangePasswordRequest {
  newPassword: string(name='NewPassword', position='Query'),
  oldPassword: string(name='OldPassword', position='Query'),
}

model ChangePasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ChangePasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ChangePasswordResponseBody(name='body'),
}

async function changePassword(request: ChangePasswordRequest): ChangePasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangePassword', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccessKeyRequest {
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model CreateAccessKeyResponseBody = {
  accessKey?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    createDate?: string(name='CreateDate'),
    status?: string(name='Status'),
  }(name='AccessKey'),
  requestId?: string(name='RequestId'),
}

model CreateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessKeyResponseBody(name='body'),
}

async function createAccessKey(request: CreateAccessKeyRequest): CreateAccessKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessKey', 'POST', '/', 'json', false, 'json', request);
}

model CreateAppSecretRequest {
  appId: string(name='AppId', position='Query'),
}

model CreateAppSecretResponseBody = {
  appSecret?: {
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    appSecretValue?: string(name='AppSecretValue'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
  requestId?: string(name='RequestId'),
}

model CreateAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppSecretResponseBody(name='body'),
}

async function createAppSecret(request: CreateAppSecretRequest): CreateAppSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAppSecret', 'POST', '/', 'json', false, 'json', request);
}

model CreateApplicationRequest {
  accessTokenValidity?: int32(name='AccessTokenValidity', position='Query'),
  appName?: string(name='AppName', position='Query'),
  appType: string(name='AppType', position='Query'),
  displayName: string(name='DisplayName', position='Query'),
  isMultiTenant?: boolean(name='IsMultiTenant', position='Query'),
  predefinedScopes?: string(name='PredefinedScopes', position='Query'),
  redirectUris?: string(name='RedirectUris', position='Query'),
  refreshTokenValidity?: int32(name='RefreshTokenValidity', position='Query'),
  secretRequired?: boolean(name='SecretRequired', position='Query'),
}

model CreateApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model CreateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateApplicationResponseBody(name='body'),
}

async function createApplication(request: CreateApplicationRequest): CreateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApplication', 'POST', '/', 'json', false, 'json', request);
}

model CreateGroupRequest {
  comments?: string(name='Comments', position='Query'),
  displayName?: string(name='DisplayName', position='Query'),
  groupName?: string(name='GroupName', position='Query'),
}

model CreateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model CreateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGroupResponseBody(name='body'),
}

async function createGroup(request: CreateGroupRequest): CreateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordResetRequired?: boolean(name='PasswordResetRequired', position='Query'),
  status?: string(name='Status', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model CreateLoginProfileResponseBody = {
  loginProfile?: {
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model CreateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLoginProfileResponseBody(name='body'),
}

async function createLoginProfile(request: CreateLoginProfileRequest): CreateLoginProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLoginProfile', 'POST', '/', 'json', false, 'json', request);
}

model CreateOIDCProviderRequest {
  clientIds?: string(name='ClientIds', position='Query'),
  description?: string(name='Description', position='Query'),
  fingerprints?: string(name='Fingerprints', position='Query'),
  issuerUrl?: string(name='IssuerUrl', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model CreateOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model CreateOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOIDCProviderResponseBody(name='body'),
}

async function createOIDCProvider(request: CreateOIDCProviderRequest): CreateOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model CreateSAMLProviderRequest {
  description?: string(name='Description', position='Query'),
  encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument', position='Query'),
  SAMLProviderName: string(name='SAMLProviderName', position='Query'),
}

model CreateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model CreateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSAMLProviderResponseBody(name='body'),
}

async function createSAMLProvider(request: CreateSAMLProviderRequest): CreateSAMLProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSAMLProvider', 'POST', '/', 'json', false, 'json', request);
}

model CreateUserRequest {
  comments?: string(name='Comments', position='Query'),
  displayName: string(name='DisplayName', position='Query'),
  email?: string(name='Email', position='Query'),
  mobilePhone?: string(name='MobilePhone', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateUser', 'POST', '/', 'json', false, 'json', request);
}

model CreateVirtualMFADeviceRequest {
  virtualMFADeviceName: string(name='VirtualMFADeviceName', position='Query'),
}

model CreateVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
  virtualMFADevice?: {
    base32StringSeed?: string(name='Base32StringSeed'),
    QRCodePNG?: string(name='QRCodePNG'),
    serialNumber?: string(name='SerialNumber'),
  }(name='VirtualMFADevice'),
}

model CreateVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVirtualMFADeviceResponseBody(name='body'),
}

async function createVirtualMFADevice(request: CreateVirtualMFADeviceRequest): CreateVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessKeyRequest {
  userAccessKeyId: string(name='UserAccessKeyId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model DeleteAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessKeyResponseBody(name='body'),
}

async function deleteAccessKey(request: DeleteAccessKeyRequest): DeleteAccessKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessKey', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAppSecretRequest {
  appId: string(name='AppId', position='Query'),
  appSecretId: string(name='AppSecretId', position='Query'),
}

model DeleteAppSecretResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAppSecretResponseBody(name='body'),
}

async function deleteAppSecret(request: DeleteAppSecretRequest): DeleteAppSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAppSecret', 'POST', '/', 'json', false, 'json', request);
}

model DeleteApplicationRequest {
  appId: string(name='AppId', position='Query'),
}

model DeleteApplicationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteApplicationResponseBody(name='body'),
}

async function deleteApplication(request: DeleteApplicationRequest): DeleteApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApplication', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
}

model DeleteGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGroupResponseBody(name='body'),
}

async function deleteGroup(request: DeleteGroupRequest): DeleteGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLoginProfileRequest {
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model DeleteLoginProfileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLoginProfileResponseBody(name='body'),
}

async function deleteLoginProfile(request: DeleteLoginProfileRequest): DeleteLoginProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLoginProfile', 'POST', '/', 'json', false, 'json', request);
}

model DeleteOIDCProviderRequest {
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model DeleteOIDCProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteOIDCProviderResponseBody(name='body'),
}

async function deleteOIDCProvider(request: DeleteOIDCProviderRequest): DeleteOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSAMLProviderRequest {
  SAMLProviderName: string(name='SAMLProviderName', position='Query'),
}

model DeleteSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSAMLProviderResponseBody(name='body'),
}

async function deleteSAMLProvider(request: DeleteSAMLProviderRequest): DeleteSAMLProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSAMLProvider', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserRequest {
  userId?: string(name='UserId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUser', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualMFADeviceRequest {
  serialNumber: string(name='SerialNumber', position='Query'),
}

model DeleteVirtualMFADeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVirtualMFADeviceResponseBody(name='body'),
}

async function deleteVirtualMFADevice(request: DeleteVirtualMFADeviceRequest): DeleteVirtualMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model DisableVirtualMFARequest {
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model DisableVirtualMFAResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableVirtualMFAResponse = {
  headers: map[string]string(name='headers'),
  body: DisableVirtualMFAResponseBody(name='body'),
}

async function disableVirtualMFA(request: DisableVirtualMFARequest): DisableVirtualMFAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableVirtualMFA', 'POST', '/', 'json', false, 'json', request);
}

model GenerateCredentialReportRequest {
}

model GenerateCredentialReportResponseBody = {
  requestId?: string(name='RequestId'),
  state?: string(name='State'),
}

model GenerateCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateCredentialReportResponseBody(name='body'),
}

async function generateCredentialReport(request: GenerateCredentialReportRequest): GenerateCredentialReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateCredentialReport', 'POST', '/', 'json', false, 'json', request);
}

model GetAccessKeyLastUsedRequest {
  userAccessKeyId: string(name='UserAccessKeyId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model GetAccessKeyLastUsedResponseBody = {
  accessKeyLastUsed?: {
    lastUsedDate?: string(name='LastUsedDate'),
  }(name='AccessKeyLastUsed'),
  requestId?: string(name='RequestId'),
}

model GetAccessKeyLastUsedResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccessKeyLastUsedResponseBody(name='body'),
}

async function getAccessKeyLastUsed(request: GetAccessKeyLastUsedRequest): GetAccessKeyLastUsedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccessKeyLastUsed', 'POST', '/', 'json', false, 'json', request);
}

model GetAccountMFAInfoRequest {
}

model GetAccountMFAInfoResponseBody = {
  isMFAEnable?: boolean(name='IsMFAEnable'),
  requestId?: string(name='RequestId'),
}

model GetAccountMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountMFAInfoResponseBody(name='body'),
}

async function getAccountMFAInfo(request: GetAccountMFAInfoRequest): GetAccountMFAInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccountMFAInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetAccountSecurityPracticeReportRequest {
}

model GetAccountSecurityPracticeReportResponseBody = {
  accountSecurityPracticeInfo?: {
    accountSecurityPracticeUserInfo?: {
      bindMfa?: boolean(name='BindMfa'),
      oldAkNum?: int32(name='OldAkNum'),
      rootWithAccessKey?: int32(name='RootWithAccessKey'),
      subUser?: int32(name='SubUser'),
      subUserBindMfa?: int32(name='SubUserBindMfa'),
      subUserPwdLevel?: string(name='SubUserPwdLevel'),
      subUserWithOldAccessKey?: int32(name='SubUserWithOldAccessKey'),
      subUserWithUnusedAccessKey?: int32(name='SubUserWithUnusedAccessKey'),
      unusedAkNum?: int32(name='UnusedAkNum'),
    }(name='AccountSecurityPracticeUserInfo'),
    score?: int32(name='Score'),
  }(name='AccountSecurityPracticeInfo'),
  requestId?: string(name='RequestId'),
}

model GetAccountSecurityPracticeReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSecurityPracticeReportResponseBody(name='body'),
}

async function getAccountSecurityPracticeReport(request: GetAccountSecurityPracticeReportRequest): GetAccountSecurityPracticeReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccountSecurityPracticeReport', 'POST', '/', 'json', false, 'json', request);
}

model GetAccountSummaryRequest {
}

model GetAccountSummaryResponseBody = {
  requestId?: string(name='RequestId'),
  summaryMap?: {
    accessKeysPerUserQuota?: int32(name='AccessKeysPerUserQuota'),
    attachedPoliciesPerGroupQuota?: int32(name='AttachedPoliciesPerGroupQuota'),
    attachedPoliciesPerRoleQuota?: int32(name='AttachedPoliciesPerRoleQuota'),
    attachedPoliciesPerUserQuota?: int32(name='AttachedPoliciesPerUserQuota'),
    attachedSystemPoliciesPerGroupQuota?: int32(name='AttachedSystemPoliciesPerGroupQuota'),
    attachedSystemPoliciesPerRoleQuota?: int32(name='AttachedSystemPoliciesPerRoleQuota'),
    attachedSystemPoliciesPerUserQuota?: int32(name='AttachedSystemPoliciesPerUserQuota'),
    groups?: int32(name='Groups'),
    groupsPerUserQuota?: int32(name='GroupsPerUserQuota'),
    groupsQuota?: int32(name='GroupsQuota'),
    MFADevices?: int32(name='MFADevices'),
    MFADevicesInUse?: int32(name='MFADevicesInUse'),
    policies?: int32(name='Policies'),
    policiesQuota?: int32(name='PoliciesQuota'),
    policySizeQuota?: int32(name='PolicySizeQuota'),
    roles?: int32(name='Roles'),
    rolesQuota?: int32(name='RolesQuota'),
    users?: int32(name='Users'),
    usersQuota?: int32(name='UsersQuota'),
    versionsPerPolicyQuota?: int32(name='VersionsPerPolicyQuota'),
    virtualMFADevicesQuota?: int32(name='VirtualMFADevicesQuota'),
  }(name='SummaryMap'),
}

model GetAccountSummaryResponse = {
  headers: map[string]string(name='headers'),
  body: GetAccountSummaryResponseBody(name='body'),
}

async function getAccountSummary(request: GetAccountSummaryRequest): GetAccountSummaryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAccountSummary', 'POST', '/', 'json', false, 'json', request);
}

model GetAppSecretRequest {
  appId: string(name='AppId', position='Query'),
  appSecretId: string(name='AppSecretId', position='Query'),
}

model GetAppSecretResponseBody = {
  appSecret?: {
    appId?: string(name='AppId'),
    appSecretId?: string(name='AppSecretId'),
    appSecretValue?: string(name='AppSecretValue'),
    createDate?: string(name='CreateDate'),
  }(name='AppSecret'),
  requestId?: string(name='RequestId'),
}

model GetAppSecretResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppSecretResponseBody(name='body'),
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppSecret', 'POST', '/', 'json', false, 'json', request);
}

model GetApplicationRequest {
  appId: string(name='AppId', position='Query'),
}

model GetApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model GetApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetApplicationResponseBody(name='body'),
}

async function getApplication(request: GetApplicationRequest): GetApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApplication', 'POST', '/', 'json', false, 'json', request);
}

model GetCredentialReportRequest {
}

model GetCredentialReportResponseBody = {
  content?: string(name='Content'),
  generatedTime?: string(name='GeneratedTime'),
  requestId?: string(name='RequestId'),
}

model GetCredentialReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetCredentialReportResponseBody(name='body'),
}

async function getCredentialReport(request: GetCredentialReportRequest): GetCredentialReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCredentialReport', 'POST', '/', 'json', false, 'json', request);
}

model GetDefaultDomainRequest {
}

model GetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model GetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  body: GetDefaultDomainResponseBody(name='body'),
}

async function getDefaultDomain(request: GetDefaultDomainRequest): GetDefaultDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDefaultDomain', 'POST', '/', 'json', false, 'json', request);
}

model GetGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
}

model GetGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model GetGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetGroupResponseBody(name='body'),
}

async function getGroup(request: GetGroupRequest): GetGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetLoginProfileRequest {
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model GetLoginProfileResponseBody = {
  loginProfile?: {
    lastLoginTime?: string(name='LastLoginTime'),
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model GetLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: GetLoginProfileResponseBody(name='body'),
}

async function getLoginProfile(request: GetLoginProfileRequest): GetLoginProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLoginProfile', 'POST', '/', 'json', false, 'json', request);
}

model GetOIDCProviderRequest {
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model GetOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model GetOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: GetOIDCProviderResponseBody(name='body'),
}

async function getOIDCProvider(request: GetOIDCProviderRequest): GetOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model GetPasswordPolicyRequest {
}

model GetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpire?: boolean(name='HardExpire'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model GetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GetPasswordPolicyResponseBody(name='body'),
}

async function getPasswordPolicy(request: GetPasswordPolicyRequest): GetPasswordPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPasswordPolicy', 'POST', '/', 'json', false, 'json', request);
}

model GetSAMLProviderRequest {
  SAMLProviderName: string(name='SAMLProviderName', position='Query'),
}

model GetSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    encodedSAMLMetadataDocument?: string(name='EncodedSAMLMetadataDocument'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model GetSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: GetSAMLProviderResponseBody(name='body'),
}

async function getSAMLProvider(request: GetSAMLProviderRequest): GetSAMLProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSAMLProvider', 'POST', '/', 'json', false, 'json', request);
}

model GetSecurityPreferenceRequest {
}

model GetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      enforceMFAForLogin?: boolean(name='EnforceMFAForLogin'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    personalInfoPreference?: {
      allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk'),
    }(name='PersonalInfoPreference'),
    verificationPreference?: {
      verificationTypes?: [ string ](name='VerificationTypes'),
    }(name='VerificationPreference'),
  }(name='SecurityPreference'),
}

model GetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  body: GetSecurityPreferenceResponseBody(name='body'),
}

async function getSecurityPreference(request: GetSecurityPreferenceRequest): GetSecurityPreferenceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSecurityPreference', 'POST', '/', 'json', false, 'json', request);
}

model GetUserRequest {
  userAccessKeyId?: string(name='UserAccessKeyId', position='Query'),
  userId?: string(name='UserId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserResponseBody(name='body'),
}

async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUser', 'POST', '/', 'json', false, 'json', request);
}

model GetUserMFAInfoRequest {
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model GetUserMFAInfoResponseBody = {
  isMFAEnable?: boolean(name='IsMFAEnable'),
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
    type?: string(name='Type'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model GetUserMFAInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserMFAInfoResponseBody(name='body'),
}

async function getUserMFAInfo(request: GetUserMFAInfoRequest): GetUserMFAInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserMFAInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetUserSsoSettingsRequest {
}

model GetUserSsoSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
}

model GetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserSsoSettingsResponseBody(name='body'),
}

async function getUserSsoSettings(request: GetUserSsoSettingsRequest): GetUserSsoSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserSsoSettings', 'POST', '/', 'json', false, 'json', request);
}

model ListAccessKeysRequest {
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model ListAccessKeysResponseBody = {
  accessKeys?: {
    accessKey?: [ 
    {
      accessKeyId?: string(name='AccessKeyId'),
      createDate?: string(name='CreateDate'),
      status?: string(name='Status'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='AccessKey')
  }(name='AccessKeys'),
  requestId?: string(name='RequestId'),
}

model ListAccessKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccessKeysResponseBody(name='body'),
}

async function listAccessKeys(request: ListAccessKeysRequest): ListAccessKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAccessKeys', 'POST', '/', 'json', false, 'json', request);
}

model ListAppSecretIdsRequest {
  appId: string(name='AppId', position='Query'),
}

model ListAppSecretIdsResponseBody = {
  appSecrets?: {
    appSecret?: [ 
    {
      appId?: string(name='AppId'),
      appSecretId?: string(name='AppSecretId'),
      createDate?: string(name='CreateDate'),
    }
  ](name='AppSecret')
  }(name='AppSecrets'),
  requestId?: string(name='RequestId'),
}

model ListAppSecretIdsResponse = {
  headers: map[string]string(name='headers'),
  body: ListAppSecretIdsResponseBody(name='body'),
}

async function listAppSecretIds(request: ListAppSecretIdsRequest): ListAppSecretIdsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppSecretIds', 'POST', '/', 'json', false, 'json', request);
}

model ListApplicationsRequest {
}

model ListApplicationsResponseBody = {
  applications?: {
    application?: [ 
    {
      accessTokenValidity?: int32(name='AccessTokenValidity'),
      accountId?: string(name='AccountId'),
      appId?: string(name='AppId'),
      appName?: string(name='AppName'),
      appType?: string(name='AppType'),
      createDate?: string(name='CreateDate'),
      delegatedScope?: {
        predefinedScopes?: {
          predefinedScope?: [ 
          {
            description?: string(name='Description'),
            name?: string(name='Name'),
          }
        ](name='PredefinedScope')
        }(name='PredefinedScopes'),
      }(name='DelegatedScope'),
      displayName?: string(name='DisplayName'),
      isMultiTenant?: boolean(name='IsMultiTenant'),
      redirectUris?: {
        redirectUri?: [ string ](name='RedirectUri')
      }(name='RedirectUris'),
      refreshTokenValidity?: int32(name='RefreshTokenValidity'),
      secretRequired?: boolean(name='SecretRequired'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Application')
  }(name='Applications'),
  requestId?: string(name='RequestId'),
}

model ListApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListApplicationsResponseBody(name='body'),
}

async function listApplications(request: ListApplicationsRequest): ListApplicationsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApplications', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupsRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListGroupsResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      displayName?: string(name='DisplayName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='Group')
  }(name='Groups'),
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupsForUserRequest {
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model ListGroupsForUserResponseBody = {
  groups?: {
    group?: [ 
    {
      comments?: string(name='Comments'),
      displayName?: string(name='DisplayName'),
      groupId?: string(name='GroupId'),
      groupName?: string(name='GroupName'),
      joinDate?: string(name='JoinDate'),
    }
  ](name='Group')
  }(name='Groups'),
  requestId?: string(name='RequestId'),
}

model ListGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsForUserResponseBody(name='body'),
}

async function listGroupsForUser(request: ListGroupsForUserRequest): ListGroupsForUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroupsForUser', 'POST', '/', 'json', false, 'json', request);
}

model ListOIDCProvidersRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListOIDCProvidersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  OIDCProviders?: {
    OIDCProvider?: [ 
    {
      arn?: string(name='Arn'),
      clientIds?: string(name='ClientIds'),
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      fingerprints?: string(name='Fingerprints'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      issuerUrl?: string(name='IssuerUrl'),
      OIDCProviderName?: string(name='OIDCProviderName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='OIDCProvider')
  }(name='OIDCProviders'),
  requestId?: string(name='RequestId'),
}

model ListOIDCProvidersResponse = {
  headers: map[string]string(name='headers'),
  body: ListOIDCProvidersResponseBody(name='body'),
}

async function listOIDCProviders(request: ListOIDCProvidersRequest): ListOIDCProvidersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOIDCProviders', 'POST', '/', 'json', false, 'json', request);
}

model ListPredefinedScopesRequest {
  appType?: string(name='AppType', position='Query'),
}

model ListPredefinedScopesResponseBody = {
  predefinedScopes?: {
    predefinedScope?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
    }
  ](name='PredefinedScope')
  }(name='PredefinedScopes'),
  requestId?: string(name='RequestId'),
}

model ListPredefinedScopesResponse = {
  headers: map[string]string(name='headers'),
  body: ListPredefinedScopesResponseBody(name='body'),
}

async function listPredefinedScopes(request: ListPredefinedScopesRequest): ListPredefinedScopesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPredefinedScopes', 'POST', '/', 'json', false, 'json', request);
}

model ListSAMLProvidersRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListSAMLProvidersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  SAMLProviders?: {
    SAMLProvider?: [ 
    {
      arn?: string(name='Arn'),
      createDate?: string(name='CreateDate'),
      description?: string(name='Description'),
      SAMLProviderName?: string(name='SAMLProviderName'),
      updateDate?: string(name='UpdateDate'),
    }
  ](name='SAMLProvider')
  }(name='SAMLProviders'),
}

model ListSAMLProvidersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSAMLProvidersResponseBody(name='body'),
}

async function listSAMLProviders(request: ListSAMLProvidersRequest): ListSAMLProvidersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSAMLProviders', 'POST', '/', 'json', false, 'json', request);
}

model ListUserBasicInfosRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListUserBasicInfosResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  userBasicInfos?: {
    userBasicInfo?: [ 
    {
      displayName?: string(name='DisplayName'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='UserBasicInfo')
  }(name='UserBasicInfos'),
}

model ListUserBasicInfosResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserBasicInfosResponseBody(name='body'),
}

async function listUserBasicInfos(request: ListUserBasicInfosRequest): ListUserBasicInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserBasicInfos', 'POST', '/', 'json', false, 'json', request);
}

model ListUsersRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListUsersResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      comments?: string(name='Comments'),
      createDate?: string(name='CreateDate'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      lastLoginDate?: string(name='LastLoginDate'),
      mobilePhone?: string(name='MobilePhone'),
      updateDate?: string(name='UpdateDate'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListUsersForGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListUsersForGroupResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  users?: {
    user?: [ 
    {
      displayName?: string(name='DisplayName'),
      joinDate?: string(name='JoinDate'),
      userId?: string(name='UserId'),
      userPrincipalName?: string(name='UserPrincipalName'),
    }
  ](name='User')
  }(name='Users'),
}

model ListUsersForGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersForGroupResponseBody(name='body'),
}

async function listUsersForGroup(request: ListUsersForGroupRequest): ListUsersForGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsersForGroup', 'POST', '/', 'json', false, 'json', request);
}

model ListVirtualMFADevicesRequest {
  marker?: string(name='Marker', position='Query'),
  maxItems?: int32(name='MaxItems', position='Query'),
}

model ListVirtualMFADevicesResponseBody = {
  isTruncated?: boolean(name='IsTruncated'),
  marker?: string(name='Marker'),
  requestId?: string(name='RequestId'),
  virtualMFADevices?: {
    virtualMFADevice?: [ 
    {
      activateDate?: string(name='ActivateDate'),
      serialNumber?: string(name='SerialNumber'),
      user?: {
        displayName?: string(name='DisplayName'),
        userId?: string(name='UserId'),
        userPrincipalName?: string(name='UserPrincipalName'),
      }(name='User'),
    }
  ](name='VirtualMFADevice')
  }(name='VirtualMFADevices'),
}

model ListVirtualMFADevicesResponse = {
  headers: map[string]string(name='headers'),
  body: ListVirtualMFADevicesResponseBody(name='body'),
}

async function listVirtualMFADevices(request: ListVirtualMFADevicesRequest): ListVirtualMFADevicesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVirtualMFADevices', 'POST', '/', 'json', false, 'json', request);
}

model RemoveClientIdFromOIDCProviderRequest {
  clientId?: string(name='ClientId', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model RemoveClientIdFromOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model RemoveClientIdFromOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveClientIdFromOIDCProviderResponseBody(name='body'),
}

async function removeClientIdFromOIDCProvider(request: RemoveClientIdFromOIDCProviderRequest): RemoveClientIdFromOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveClientIdFromOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model RemoveFingerprintFromOIDCProviderRequest {
  fingerprint?: string(name='Fingerprint', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model RemoveFingerprintFromOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model RemoveFingerprintFromOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveFingerprintFromOIDCProviderResponseBody(name='body'),
}

async function removeFingerprintFromOIDCProvider(request: RemoveFingerprintFromOIDCProviderRequest): RemoveFingerprintFromOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveFingerprintFromOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model RemoveUserFromGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model RemoveUserFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveUserFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUserFromGroupResponseBody(name='body'),
}

async function removeUserFromGroup(request: RemoveUserFromGroupRequest): RemoveUserFromGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveUserFromGroup', 'POST', '/', 'json', false, 'json', request);
}

model SetDefaultDomainRequest {
  defaultDomainName: string(name='DefaultDomainName', position='Query'),
}

model SetDefaultDomainResponseBody = {
  defaultDomainName?: string(name='DefaultDomainName'),
  requestId?: string(name='RequestId'),
}

model SetDefaultDomainResponse = {
  headers: map[string]string(name='headers'),
  body: SetDefaultDomainResponseBody(name='body'),
}

async function setDefaultDomain(request: SetDefaultDomainRequest): SetDefaultDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDefaultDomain', 'POST', '/', 'json', false, 'json', request);
}

model SetPasswordPolicyRequest {
  hardExpire?: boolean(name='HardExpire', position='Query'),
  maxLoginAttemps?: int32(name='MaxLoginAttemps', position='Query'),
  maxPasswordAge?: int32(name='MaxPasswordAge', position='Query'),
  minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter', position='Query'),
  minimumPasswordLength?: int32(name='MinimumPasswordLength', position='Query'),
  passwordNotContainUserName?: boolean(name='PasswordNotContainUserName', position='Query'),
  passwordReusePrevention?: int32(name='PasswordReusePrevention', position='Query'),
  requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters', position='Query'),
  requireNumbers?: boolean(name='RequireNumbers', position='Query'),
  requireSymbols?: boolean(name='RequireSymbols', position='Query'),
  requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters', position='Query'),
}

model SetPasswordPolicyResponseBody = {
  passwordPolicy?: {
    hardExpire?: boolean(name='HardExpire'),
    maxLoginAttemps?: int32(name='MaxLoginAttemps'),
    maxPasswordAge?: int32(name='MaxPasswordAge'),
    minimumPasswordDifferentCharacter?: int32(name='MinimumPasswordDifferentCharacter'),
    minimumPasswordLength?: int32(name='MinimumPasswordLength'),
    passwordNotContainUserName?: boolean(name='PasswordNotContainUserName'),
    passwordReusePrevention?: int32(name='PasswordReusePrevention'),
    requireLowercaseCharacters?: boolean(name='RequireLowercaseCharacters'),
    requireNumbers?: boolean(name='RequireNumbers'),
    requireSymbols?: boolean(name='RequireSymbols'),
    requireUppercaseCharacters?: boolean(name='RequireUppercaseCharacters'),
  }(name='PasswordPolicy'),
  requestId?: string(name='RequestId'),
}

model SetPasswordPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: SetPasswordPolicyResponseBody(name='body'),
}

async function setPasswordPolicy(request: SetPasswordPolicyRequest): SetPasswordPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetPasswordPolicy', 'POST', '/', 'json', false, 'json', request);
}

model SetSecurityPreferenceRequest {
  allowUserToChangePassword?: boolean(name='AllowUserToChangePassword', position='Query'),
  allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys', position='Query'),
  allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices', position='Query'),
  allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk', position='Query'),
  enableSaveMFATicket?: boolean(name='EnableSaveMFATicket', position='Query'),
  enforceMFAForLogin?: boolean(name='EnforceMFAForLogin', position='Query'),
  loginNetworkMasks?: string(name='LoginNetworkMasks', position='Query'),
  loginSessionDuration?: int32(name='LoginSessionDuration', position='Query'),
  verificationTypes?: [ string ](name='VerificationTypes', position='Query'),
}

model SetSecurityPreferenceResponseBody = {
  requestId?: string(name='RequestId'),
  securityPreference?: {
    accessKeyPreference?: {
      allowUserToManageAccessKeys?: boolean(name='AllowUserToManageAccessKeys'),
    }(name='AccessKeyPreference'),
    loginProfilePreference?: {
      allowUserToChangePassword?: boolean(name='AllowUserToChangePassword'),
      enableSaveMFATicket?: boolean(name='EnableSaveMFATicket'),
      enforceMFAForLogin?: boolean(name='EnforceMFAForLogin'),
      loginNetworkMasks?: string(name='LoginNetworkMasks'),
      loginSessionDuration?: int32(name='LoginSessionDuration'),
    }(name='LoginProfilePreference'),
    MFAPreference?: {
      allowUserToManageMFADevices?: boolean(name='AllowUserToManageMFADevices'),
    }(name='MFAPreference'),
    personalInfoPreference?: {
      allowUserToManagePersonalDingTalk?: boolean(name='AllowUserToManagePersonalDingTalk'),
    }(name='PersonalInfoPreference'),
    verificationPreference?: {
      verificationTypes?: [ string ](name='VerificationTypes'),
    }(name='VerificationPreference'),
  }(name='SecurityPreference'),
}

model SetSecurityPreferenceResponse = {
  headers: map[string]string(name='headers'),
  body: SetSecurityPreferenceResponseBody(name='body'),
}

async function setSecurityPreference(request: SetSecurityPreferenceRequest): SetSecurityPreferenceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSecurityPreference', 'POST', '/', 'json', false, 'json', request);
}

model SetUserSsoSettingsRequest {
  auxiliaryDomain?: string(name='AuxiliaryDomain', position='Query'),
  metadataDocument?: string(name='MetadataDocument', position='Query'),
  ssoEnabled?: boolean(name='SsoEnabled', position='Query'),
}

model SetUserSsoSettingsResponseBody = {
  requestId?: string(name='RequestId'),
  userSsoSettings?: {
    auxiliaryDomain?: string(name='AuxiliaryDomain'),
    metadataDocument?: string(name='MetadataDocument'),
    ssoEnabled?: boolean(name='SsoEnabled'),
  }(name='UserSsoSettings'),
}

model SetUserSsoSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: SetUserSsoSettingsResponseBody(name='body'),
}

async function setUserSsoSettings(request: SetUserSsoSettingsRequest): SetUserSsoSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetUserSsoSettings', 'POST', '/', 'json', false, 'json', request);
}

model UnbindMFADeviceRequest {
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model UnbindMFADeviceResponseBody = {
  MFADevice?: {
    serialNumber?: string(name='SerialNumber'),
  }(name='MFADevice'),
  requestId?: string(name='RequestId'),
}

model UnbindMFADeviceResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindMFADeviceResponseBody(name='body'),
}

async function unbindMFADevice(request: UnbindMFADeviceRequest): UnbindMFADeviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindMFADevice', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAccessKeyRequest {
  status: string(name='Status', position='Query'),
  userAccessKeyId: string(name='UserAccessKeyId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model UpdateAccessKeyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateAccessKeyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAccessKeyResponseBody(name='body'),
}

async function updateAccessKey(request: UpdateAccessKeyRequest): UpdateAccessKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAccessKey', 'POST', '/', 'json', false, 'json', request);
}

model UpdateApplicationRequest {
  appId: string(name='AppId', position='Query'),
  newAccessTokenValidity?: int32(name='NewAccessTokenValidity', position='Query'),
  newDisplayName?: string(name='NewDisplayName', position='Query'),
  newIsMultiTenant?: boolean(name='NewIsMultiTenant', position='Query'),
  newPredefinedScopes?: string(name='NewPredefinedScopes', position='Query'),
  newRedirectUris?: string(name='NewRedirectUris', position='Query'),
  newRefreshTokenValidity?: int32(name='NewRefreshTokenValidity', position='Query'),
  newSecretRequired?: boolean(name='NewSecretRequired', position='Query'),
}

model UpdateApplicationResponseBody = {
  application?: {
    accessTokenValidity?: int32(name='AccessTokenValidity'),
    accountId?: string(name='AccountId'),
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appType?: string(name='AppType'),
    createDate?: string(name='CreateDate'),
    delegatedScope?: {
      predefinedScopes?: {
        predefinedScope?: [ 
        {
          description?: string(name='Description'),
          name?: string(name='Name'),
        }
      ](name='PredefinedScope')
      }(name='PredefinedScopes'),
    }(name='DelegatedScope'),
    displayName?: string(name='DisplayName'),
    isMultiTenant?: boolean(name='IsMultiTenant'),
    redirectUris?: {
      redirectUri?: [ string ](name='RedirectUri')
    }(name='RedirectUris'),
    refreshTokenValidity?: int32(name='RefreshTokenValidity'),
    secretRequired?: boolean(name='SecretRequired'),
    updateDate?: string(name='UpdateDate'),
  }(name='Application'),
  requestId?: string(name='RequestId'),
}

model UpdateApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateApplicationResponseBody(name='body'),
}

async function updateApplication(request: UpdateApplicationRequest): UpdateApplicationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateApplication', 'POST', '/', 'json', false, 'json', request);
}

model UpdateGroupRequest {
  groupName?: string(name='GroupName', position='Query'),
  newComments?: string(name='NewComments', position='Query'),
  newDisplayName?: string(name='NewDisplayName', position='Query'),
  newGroupName?: string(name='NewGroupName', position='Query'),
}

model UpdateGroupResponseBody = {
  group?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    groupId?: string(name='GroupId'),
    groupName?: string(name='GroupName'),
    updateDate?: string(name='UpdateDate'),
  }(name='Group'),
  requestId?: string(name='RequestId'),
}

model UpdateGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateGroupResponseBody(name='body'),
}

async function updateGroup(request: UpdateGroupRequest): UpdateGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLoginProfileRequest {
  MFABindRequired?: boolean(name='MFABindRequired', position='Query'),
  password?: string(name='Password', position='Query'),
  passwordResetRequired?: boolean(name='PasswordResetRequired', position='Query'),
  status?: string(name='Status', position='Query'),
  userPrincipalName: string(name='UserPrincipalName', position='Query'),
}

model UpdateLoginProfileResponseBody = {
  loginProfile?: {
    MFABindRequired?: boolean(name='MFABindRequired'),
    passwordResetRequired?: boolean(name='PasswordResetRequired'),
    status?: string(name='Status'),
    updateDate?: string(name='UpdateDate'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='LoginProfile'),
  requestId?: string(name='RequestId'),
}

model UpdateLoginProfileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateLoginProfileResponseBody(name='body'),
}

async function updateLoginProfile(request: UpdateLoginProfileRequest): UpdateLoginProfileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLoginProfile', 'POST', '/', 'json', false, 'json', request);
}

model UpdateOIDCProviderRequest {
  clientIds?: string(name='ClientIds', position='Query'),
  newDescription?: string(name='NewDescription', position='Query'),
  OIDCProviderName?: string(name='OIDCProviderName', position='Query'),
}

model UpdateOIDCProviderResponseBody = {
  OIDCProvider?: {
    arn?: string(name='Arn'),
    clientIds?: string(name='ClientIds'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    fingerprints?: string(name='Fingerprints'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    issuerUrl?: string(name='IssuerUrl'),
    OIDCProviderName?: string(name='OIDCProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='OIDCProvider'),
  requestId?: string(name='RequestId'),
}

model UpdateOIDCProviderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateOIDCProviderResponseBody(name='body'),
}

async function updateOIDCProvider(request: UpdateOIDCProviderRequest): UpdateOIDCProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateOIDCProvider', 'POST', '/', 'json', false, 'json', request);
}

model UpdateSAMLProviderRequest {
  newDescription?: string(name='NewDescription', position='Query'),
  newEncodedSAMLMetadataDocument?: string(name='NewEncodedSAMLMetadataDocument', position='Query'),
  SAMLProviderName: string(name='SAMLProviderName', position='Query'),
}

model UpdateSAMLProviderResponseBody = {
  requestId?: string(name='RequestId'),
  SAMLProvider?: {
    arn?: string(name='Arn'),
    createDate?: string(name='CreateDate'),
    description?: string(name='Description'),
    SAMLProviderName?: string(name='SAMLProviderName'),
    updateDate?: string(name='UpdateDate'),
  }(name='SAMLProvider'),
}

model UpdateSAMLProviderResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSAMLProviderResponseBody(name='body'),
}

async function updateSAMLProvider(request: UpdateSAMLProviderRequest): UpdateSAMLProviderResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSAMLProvider', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserRequest {
  newComments?: string(name='NewComments', position='Query'),
  newDisplayName?: string(name='NewDisplayName', position='Query'),
  newEmail?: string(name='NewEmail', position='Query'),
  newMobilePhone?: string(name='NewMobilePhone', position='Query'),
  newUserPrincipalName?: string(name='NewUserPrincipalName', position='Query'),
  userId?: string(name='UserId', position='Query'),
  userPrincipalName?: string(name='UserPrincipalName', position='Query'),
}

model UpdateUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comments?: string(name='Comments'),
    createDate?: string(name='CreateDate'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    lastLoginDate?: string(name='LastLoginDate'),
    mobilePhone?: string(name='MobilePhone'),
    updateDate?: string(name='UpdateDate'),
    userId?: string(name='UserId'),
    userPrincipalName?: string(name='UserPrincipalName'),
  }(name='User'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUser', 'POST', '/', 'json', false, 'json', request);
}

