/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ecd', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AppDownloadEventRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model AppDownloadEventResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AppDownloadEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppDownloadEventResponseBody(name='body'),
}

async function appDownloadEventWithOptions(request: AppDownloadEventRequest, runtime: Util.RuntimeOptions): AppDownloadEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppDownloadEvent',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appDownloadEvent(request: AppDownloadEventRequest): AppDownloadEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return appDownloadEventWithOptions(request, runtime);
}

model AppInstallEventRequest {
  appId?: long(name='AppId'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model AppInstallEventResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AppInstallEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AppInstallEventResponseBody(name='body'),
}

async function appInstallEventWithOptions(request: AppInstallEventRequest, runtime: Util.RuntimeOptions): AppInstallEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AppInstallEvent',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function appInstallEvent(request: AppInstallEventRequest): AppInstallEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return appInstallEventWithOptions(request, runtime);
}

model ApplyStsTokenRequest {
  appVersion?: string(name='AppVersion'),
  appVersionCode?: long(name='AppVersionCode'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model ApplyStsTokenResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    expiration?: string(name='Expiration'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ApplyStsTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyStsTokenResponseBody(name='body'),
}

async function applyStsTokenWithOptions(request: ApplyStsTokenRequest, runtime: Util.RuntimeOptions): ApplyStsTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionCode)) {
    query['AppVersionCode'] = request.appVersionCode;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyStsToken',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyStsToken(request: ApplyStsTokenRequest): ApplyStsTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyStsTokenWithOptions(request, runtime);
}

model AuthorizeAppRequest {
  appId?: long(name='AppId'),
  orderId?: long(name='OrderId'),
  regionId?: string(name='RegionId'),
  subscribeId?: long(name='SubscribeId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model AuthorizeAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AuthorizeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuthorizeAppResponseBody(name='body'),
}

async function authorizeAppWithOptions(request: AuthorizeAppRequest, runtime: Util.RuntimeOptions): AuthorizeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.subscribeId)) {
    query['SubscribeId'] = request.subscribeId;
  }
  if (!Util.isUnset(request.userList)) {
    query['UserList'] = request.userList;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AuthorizeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function authorizeApp(request: AuthorizeAppRequest): AuthorizeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return authorizeAppWithOptions(request, runtime);
}

model AutoInstallAppRequest {
  appId?: int32(name='AppId'),
  distributeType?: string(name='DistributeType'),
  language?: string(name='Language'),
  silenceInfo?: {
    silenceDeleteParam?: string(name='SilenceDeleteParam'),
    silenceInstallParam?: string(name='SilenceInstallParam'),
  }(name='SilenceInfo'),
  tenantId?: long(name='TenantId'),
  userList?: [ 
    {
      isDistribute?: boolean(name='IsDistribute'),
      name?: string(name='Name'),
      orderId?: long(name='OrderId'),
      subscribeId?: long(name='SubscribeId'),
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userType?: string(name='UserType'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model AutoInstallAppShrinkRequest {
  appId?: int32(name='AppId'),
  distributeType?: string(name='DistributeType'),
  language?: string(name='Language'),
  silenceInfoShrink?: string(name='SilenceInfo'),
  tenantId?: long(name='TenantId'),
  userListShrink?: string(name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model AutoInstallAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AutoInstallAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AutoInstallAppResponseBody(name='body'),
}

async function autoInstallAppWithOptions(tmpReq: AutoInstallAppRequest, runtime: Util.RuntimeOptions): AutoInstallAppResponse {
  Util.validateModel(tmpReq);
  var request = new AutoInstallAppShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.silenceInfo)) {
    request.silenceInfoShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.silenceInfo, 'SilenceInfo', 'json');
  }
  if (!Util.isUnset(tmpReq.userList)) {
    request.userListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userList, 'UserList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.silenceInfoShrink)) {
    body['SilenceInfo'] = request.silenceInfoShrink;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userListShrink)) {
    body['UserList'] = request.userListShrink;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    body['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AutoInstallApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function autoInstallApp(request: AutoInstallAppRequest): AutoInstallAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return autoInstallAppWithOptions(request, runtime);
}

model BatchDeleteAppsRequest {
  appIds?: map[string]any(name='AppIds'),
}

model BatchDeleteAppsShrinkRequest {
  appIdsShrink?: string(name='AppIds'),
}

model BatchDeleteAppsResponseBody = {
  code?: string(name='Code'),
  data?: {
    failAppList?: [ 
      {
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='FailAppList'),
    isSuccess?: boolean(name='IsSuccess'),
    successAppList?: [ 
      {
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='SuccessAppList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteAppsResponseBody(name='body'),
}

async function batchDeleteAppsWithOptions(tmpReq: BatchDeleteAppsRequest, runtime: Util.RuntimeOptions): BatchDeleteAppsResponse {
  Util.validateModel(tmpReq);
  var request = new BatchDeleteAppsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appIds)) {
    request.appIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appIds, 'AppIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appIdsShrink)) {
    query['AppIds'] = request.appIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteApps',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteApps(request: BatchDeleteAppsRequest): BatchDeleteAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteAppsWithOptions(request, runtime);
}

model BatchDistributeAppsRequest {
  appIds?: map[string]any(name='AppIds'),
  autoInstallApps?: [ 
    {
      appId?: long(name='AppId'),
      silenceDeleteParam?: string(name='SilenceDeleteParam'),
      silenceInstallParam?: string(name='SilenceInstallParam'),
    }
  ](name='AutoInstallApps'),
  distributeType?: string(name='DistributeType'),
  language?: string(name='Language'),
  orderId?: long(name='OrderId'),
  requestType?: string(name='RequestType'),
  subscribeId?: long(name='SubscribeId'),
  tenantId?: long(name='TenantId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model BatchDistributeAppsShrinkRequest {
  appIdsShrink?: string(name='AppIds'),
  autoInstallApps?: [ 
    {
      appId?: long(name='AppId'),
      silenceDeleteParam?: string(name='SilenceDeleteParam'),
      silenceInstallParam?: string(name='SilenceInstallParam'),
    }
  ](name='AutoInstallApps'),
  distributeType?: string(name='DistributeType'),
  language?: string(name='Language'),
  orderId?: long(name='OrderId'),
  requestType?: string(name='RequestType'),
  subscribeId?: long(name='SubscribeId'),
  tenantId?: long(name='TenantId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model BatchDistributeAppsResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDistributeAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDistributeAppsResponseBody(name='body'),
}

async function batchDistributeAppsWithOptions(tmpReq: BatchDistributeAppsRequest, runtime: Util.RuntimeOptions): BatchDistributeAppsResponse {
  Util.validateModel(tmpReq);
  var request = new BatchDistributeAppsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appIds)) {
    request.appIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appIds, 'AppIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appIdsShrink)) {
    query['AppIds'] = request.appIdsShrink;
  }
  if (!Util.isUnset(request.autoInstallApps)) {
    query['AutoInstallApps'] = request.autoInstallApps;
  }
  if (!Util.isUnset(request.userList)) {
    query['UserList'] = request.userList;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.orderId)) {
    body['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.requestType)) {
    body['RequestType'] = request.requestType;
  }
  if (!Util.isUnset(request.subscribeId)) {
    body['SubscribeId'] = request.subscribeId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    body['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDistributeApps',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDistributeApps(request: BatchDistributeAppsRequest): BatchDistributeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDistributeAppsWithOptions(request, runtime);
}

model BatchSubscribeAppsRequest {
  appIds?: map[string]any(name='AppIds'),
  autoInstallApps?: [ 
    {
      appId?: long(name='AppId'),
      silenceDeleteParam?: string(name='SilenceDeleteParam'),
      silenceInstallParam?: string(name='SilenceInstallParam'),
    }
  ](name='AutoInstallApps'),
  distributeType?: string(name='DistributeType'),
  forceInstallType?: string(name='ForceInstallType'),
  language?: string(name='Language'),
  requestType?: string(name='RequestType'),
}

model BatchSubscribeAppsShrinkRequest {
  appIdsShrink?: string(name='AppIds'),
  autoInstallApps?: [ 
    {
      appId?: long(name='AppId'),
      silenceDeleteParam?: string(name='SilenceDeleteParam'),
      silenceInstallParam?: string(name='SilenceInstallParam'),
    }
  ](name='AutoInstallApps'),
  distributeType?: string(name='DistributeType'),
  forceInstallType?: string(name='ForceInstallType'),
  language?: string(name='Language'),
  requestType?: string(name='RequestType'),
}

model BatchSubscribeAppsResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchSubscribeAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchSubscribeAppsResponseBody(name='body'),
}

async function batchSubscribeAppsWithOptions(tmpReq: BatchSubscribeAppsRequest, runtime: Util.RuntimeOptions): BatchSubscribeAppsResponse {
  Util.validateModel(tmpReq);
  var request = new BatchSubscribeAppsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appIds)) {
    request.appIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appIds, 'AppIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.appIdsShrink)) {
    query['AppIds'] = request.appIdsShrink;
  }
  if (!Util.isUnset(request.autoInstallApps)) {
    query['AutoInstallApps'] = request.autoInstallApps;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.forceInstallType)) {
    body['ForceInstallType'] = request.forceInstallType;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.requestType)) {
    body['RequestType'] = request.requestType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchSubscribeApps',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchSubscribeApps(request: BatchSubscribeAppsRequest): BatchSubscribeAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchSubscribeAppsWithOptions(request, runtime);
}

model ChangeAppshowRequest {
  isShow?: int32(name='IsShow'),
}

model ChangeAppshowResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ChangeAppshowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeAppshowResponseBody(name='body'),
}

async function changeAppshowWithOptions(request: ChangeAppshowRequest, runtime: Util.RuntimeOptions): ChangeAppshowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.isShow)) {
    query['IsShow'] = request.isShow;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeAppshow',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeAppshow(request: ChangeAppshowRequest): ChangeAppshowResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeAppshowWithOptions(request, runtime);
}

model CheckUpgradeRequest {
  appVersion?: string(name='AppVersion'),
  appVersionCode?: string(name='AppVersionCode'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model CheckUpgradeResponseBody = {
  code?: string(name='Code'),
  data?: {
    comments?: string(name='Comments'),
    forceUpgrade?: boolean(name='ForceUpgrade'),
    size?: string(name='Size'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CheckUpgradeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckUpgradeResponseBody(name='body'),
}

async function checkUpgradeWithOptions(request: CheckUpgradeRequest, runtime: Util.RuntimeOptions): CheckUpgradeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionCode)) {
    query['AppVersionCode'] = request.appVersionCode;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckUpgrade',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkUpgrade(request: CheckUpgradeRequest): CheckUpgradeResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkUpgradeWithOptions(request, runtime);
}

model ClientOnOpenEventRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model ClientOnOpenEventResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ClientOnOpenEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ClientOnOpenEventResponseBody(name='body'),
}

async function clientOnOpenEventWithOptions(request: ClientOnOpenEventRequest, runtime: Util.RuntimeOptions): ClientOnOpenEventResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ClientOnOpenEvent',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function clientOnOpenEvent(request: ClientOnOpenEventRequest): ClientOnOpenEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return clientOnOpenEventWithOptions(request, runtime);
}

model CompleteAppRequest {
  fileName?: string(name='FileName'),
}

model CompleteAppResponseBody = {
  code?: string(name='Code'),
  filePath?: string(name='FilePath'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  size?: long(name='Size'),
}

model CompleteAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteAppResponseBody(name='body'),
}

async function completeAppWithOptions(request: CompleteAppRequest, runtime: Util.RuntimeOptions): CompleteAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeApp(request: CompleteAppRequest): CompleteAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeAppWithOptions(request, runtime);
}

model CompleteIconRequest {
  fileName?: string(name='FileName'),
}

model CompleteIconResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  size?: long(name='Size'),
  url?: string(name='Url'),
}

model CompleteIconResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteIconResponseBody(name='body'),
}

async function completeIconWithOptions(request: CompleteIconRequest, runtime: Util.RuntimeOptions): CompleteIconResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CompleteIcon',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeIcon(request: CompleteIconRequest): CompleteIconResponse {
  var runtime = new Util.RuntimeOptions{};
  return completeIconWithOptions(request, runtime);
}

model CreateAppVersionRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
  appVersionName?: string(name='AppVersionName'),
  copyrightName?: string(name='CopyrightName'),
  copyrightPath?: string(name='CopyrightPath'),
  copyrightRealName?: string(name='CopyrightRealName'),
  executeFile?: string(name='ExecuteFile'),
  executeFileAddress?: string(name='ExecuteFileAddress'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  startParam?: string(name='StartParam'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model CreateAppVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppVersionResponseBody(name='body'),
}

async function createAppVersionWithOptions(request: CreateAppVersionRequest, runtime: Util.RuntimeOptions): CreateAppVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionName)) {
    body['AppVersionName'] = request.appVersionName;
  }
  if (!Util.isUnset(request.copyrightName)) {
    body['CopyrightName'] = request.copyrightName;
  }
  if (!Util.isUnset(request.copyrightPath)) {
    body['CopyrightPath'] = request.copyrightPath;
  }
  if (!Util.isUnset(request.copyrightRealName)) {
    body['CopyrightRealName'] = request.copyrightRealName;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.executeFileAddress)) {
    body['ExecuteFileAddress'] = request.executeFileAddress;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.silenceFlag)) {
    body['SilenceFlag'] = request.silenceFlag;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  if (!Util.isUnset(request.startParam)) {
    body['StartParam'] = request.startParam;
  }
  if (!Util.isUnset(request.wamFileName)) {
    body['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    body['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    body['WamFileRealName'] = request.wamFileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppVersion',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppVersion(request: CreateAppVersionRequest): CreateAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppVersionWithOptions(request, runtime);
}

model CreateIsvAppRequest {
  appDownloadUrl?: string(name='AppDownloadUrl'),
  appRegInfo?: string(name='AppRegInfo'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  cateId?: int32(name='CateId'),
  certFileName?: string(name='CertFileName'),
  certFilePath?: string(name='CertFilePath'),
  certFileRealName?: string(name='CertFileRealName'),
  copyrightName?: string(name='CopyrightName'),
  copyrightPath?: string(name='CopyrightPath'),
  copyrightRealName?: string(name='CopyrightRealName'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  email?: string(name='Email'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  licenseName?: string(name='LicenseName'),
  licensePath?: string(name='LicensePath'),
  licenseRealName?: string(name='LicenseRealName'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  phone?: string(name='Phone'),
  publishType?: int32(name='PublishType'),
  regionId?: string(name='RegionId'),
  searchTag?: string(name='SearchTag'),
  silenceDeleteParam?: string(name='SilenceDeleteParam'),
  silenceParam?: string(name='SilenceParam'),
}

model CreateIsvAppResponseBody = {
  appId?: int32(name='AppId'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateIsvAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateIsvAppResponseBody(name='body'),
}

async function createIsvAppWithOptions(request: CreateIsvAppRequest, runtime: Util.RuntimeOptions): CreateIsvAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appDownloadUrl)) {
    body['AppDownloadUrl'] = request.appDownloadUrl;
  }
  if (!Util.isUnset(request.appRegInfo)) {
    body['AppRegInfo'] = request.appRegInfo;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.applicationLink)) {
    body['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.applicationType)) {
    body['ApplicationType'] = request.applicationType;
  }
  if (!Util.isUnset(request.cateId)) {
    body['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.certFileName)) {
    body['CertFileName'] = request.certFileName;
  }
  if (!Util.isUnset(request.certFilePath)) {
    body['CertFilePath'] = request.certFilePath;
  }
  if (!Util.isUnset(request.certFileRealName)) {
    body['CertFileRealName'] = request.certFileRealName;
  }
  if (!Util.isUnset(request.copyrightName)) {
    body['CopyrightName'] = request.copyrightName;
  }
  if (!Util.isUnset(request.copyrightPath)) {
    body['CopyrightPath'] = request.copyrightPath;
  }
  if (!Util.isUnset(request.copyrightRealName)) {
    body['CopyrightRealName'] = request.copyrightRealName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.developer)) {
    body['Developer'] = request.developer;
  }
  if (!Util.isUnset(request.email)) {
    body['Email'] = request.email;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.licenseName)) {
    body['LicenseName'] = request.licenseName;
  }
  if (!Util.isUnset(request.licensePath)) {
    body['LicensePath'] = request.licensePath;
  }
  if (!Util.isUnset(request.licenseRealName)) {
    body['LicenseRealName'] = request.licenseRealName;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.searchTag)) {
    body['SearchTag'] = request.searchTag;
  }
  if (!Util.isUnset(request.silenceDeleteParam)) {
    body['SilenceDeleteParam'] = request.silenceDeleteParam;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateIsvApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createIsvApp(request: CreateIsvAppRequest): CreateIsvAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createIsvAppWithOptions(request, runtime);
}

model CreateOrderRequest {
  amount?: long(name='Amount'),
  buyerId?: long(name='BuyerId'),
  itemId?: long(name='ItemId'),
}

model CreateOrderResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOrderResponseBody(name='body'),
}

async function createOrderWithOptions(request: CreateOrderRequest, runtime: Util.RuntimeOptions): CreateOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.buyerId)) {
    query['BuyerId'] = request.buyerId;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOrder',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOrder(request: CreateOrderRequest): CreateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOrderWithOptions(request, runtime);
}

model CreateTenantAppRequest {
  appTag?: [ string ](name='AppTag'),
  appVersion?: string(name='AppVersion'),
  appVersionName?: string(name='AppVersionName'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: int32(name='CateId'),
  cateType?: int32(name='CateType'),
  controlParam?: string(name='ControlParam'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  executeFileAddress?: string(name='ExecuteFileAddress'),
  fileName?: string(name='FileName'),
  fileOpenWay?: [ string ](name='FileOpenWay'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  OS?: string(name='OS'),
  ossAppUrl?: string(name='OssAppUrl'),
  searchTag?: string(name='SearchTag'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  size?: long(name='Size'),
  sourceType?: string(name='SourceType'),
  startParam?: string(name='StartParam'),
  subAppType?: string(name='SubAppType'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model CreateTenantAppShrinkRequest {
  appTagShrink?: string(name='AppTag'),
  appVersion?: string(name='AppVersion'),
  appVersionName?: string(name='AppVersionName'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: int32(name='CateId'),
  cateType?: int32(name='CateType'),
  controlParam?: string(name='ControlParam'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  executeFileAddress?: string(name='ExecuteFileAddress'),
  fileName?: string(name='FileName'),
  fileOpenWayShrink?: string(name='FileOpenWay'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  OS?: string(name='OS'),
  ossAppUrl?: string(name='OssAppUrl'),
  searchTag?: string(name='SearchTag'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  size?: long(name='Size'),
  sourceType?: string(name='SourceType'),
  startParam?: string(name='StartParam'),
  subAppType?: string(name='SubAppType'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model CreateTenantAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    appId?: int32(name='AppId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateTenantAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTenantAppResponseBody(name='body'),
}

async function createTenantAppWithOptions(tmpReq: CreateTenantAppRequest, runtime: Util.RuntimeOptions): CreateTenantAppResponse {
  Util.validateModel(tmpReq);
  var request = new CreateTenantAppShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appTag)) {
    request.appTagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appTag, 'AppTag', 'json');
  }
  if (!Util.isUnset(tmpReq.fileOpenWay)) {
    request.fileOpenWayShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.fileOpenWay, 'FileOpenWay', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTagShrink)) {
    body['AppTag'] = request.appTagShrink;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionName)) {
    body['AppVersionName'] = request.appVersionName;
  }
  if (!Util.isUnset(request.applicationLink)) {
    body['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.applicationType)) {
    body['ApplicationType'] = request.applicationType;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.cateId)) {
    body['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.cateType)) {
    body['CateType'] = request.cateType;
  }
  if (!Util.isUnset(request.controlParam)) {
    body['ControlParam'] = request.controlParam;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.developer)) {
    body['Developer'] = request.developer;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.executeFileAddress)) {
    body['ExecuteFileAddress'] = request.executeFileAddress;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.fileOpenWayShrink)) {
    body['FileOpenWay'] = request.fileOpenWayShrink;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.isFree)) {
    body['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.licenceType)) {
    body['LicenceType'] = request.licenceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.OS)) {
    body['OS'] = request.OS;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.searchTag)) {
    body['SearchTag'] = request.searchTag;
  }
  if (!Util.isUnset(request.silenceFlag)) {
    body['SilenceFlag'] = request.silenceFlag;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.sourceType)) {
    body['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.startParam)) {
    body['StartParam'] = request.startParam;
  }
  if (!Util.isUnset(request.subAppType)) {
    body['SubAppType'] = request.subAppType;
  }
  if (!Util.isUnset(request.wamFileName)) {
    body['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    body['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    body['WamFileRealName'] = request.wamFileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTenantApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTenantApp(request: CreateTenantAppRequest): CreateTenantAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTenantAppWithOptions(request, runtime);
}

model DeleteAppVersionRequest {
  id?: long(name='Id'),
}

model DeleteAppVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppVersionResponseBody(name='body'),
}

async function deleteAppVersionWithOptions(request: DeleteAppVersionRequest, runtime: Util.RuntimeOptions): DeleteAppVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.id)) {
    query['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAppVersion',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAppVersion(request: DeleteAppVersionRequest): DeleteAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppVersionWithOptions(request, runtime);
}

model DeleteAuthorizationUserRequest {
  appId?: long(name='AppId'),
  orderId?: long(name='OrderId'),
  regionId?: string(name='RegionId'),
  subscribeId?: long(name='SubscribeId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: int32(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model DeleteAuthorizationUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAuthorizationUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAuthorizationUserResponseBody(name='body'),
}

async function deleteAuthorizationUserWithOptions(request: DeleteAuthorizationUserRequest, runtime: Util.RuntimeOptions): DeleteAuthorizationUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.subscribeId)) {
    query['SubscribeId'] = request.subscribeId;
  }
  if (!Util.isUnset(request.userList)) {
    query['UserList'] = request.userList;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAuthorizationUser',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAuthorizationUser(request: DeleteAuthorizationUserRequest): DeleteAuthorizationUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAuthorizationUserWithOptions(request, runtime);
}

model DeleteDistributeUserRequest {
  appId?: long(name='AppId'),
  orderId?: long(name='OrderId'),
  regionId?: string(name='RegionId'),
  subscribeId?: long(name='SubscribeId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: int32(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model DeleteDistributeUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDistributeUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDistributeUserResponseBody(name='body'),
}

async function deleteDistributeUserWithOptions(request: DeleteDistributeUserRequest, runtime: Util.RuntimeOptions): DeleteDistributeUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.subscribeId)) {
    query['SubscribeId'] = request.subscribeId;
  }
  if (!Util.isUnset(request.userList)) {
    query['UserList'] = request.userList;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDistributeUser',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDistributeUser(request: DeleteDistributeUserRequest): DeleteDistributeUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDistributeUserWithOptions(request, runtime);
}

model DeleteIsvAppRequest {
  appId?: long(name='AppId'),
  appVersion?: string(name='AppVersion'),
}

model DeleteIsvAppResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteIsvAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIsvAppResponseBody(name='body'),
}

async function deleteIsvAppWithOptions(request: DeleteIsvAppRequest, runtime: Util.RuntimeOptions): DeleteIsvAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIsvApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIsvApp(request: DeleteIsvAppRequest): DeleteIsvAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIsvAppWithOptions(request, runtime);
}

model DeleteTenantAppRequest {
  appId?: long(name='AppId'),
  regionId?: string(name='RegionId'),
}

model DeleteTenantAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteTenantAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteTenantAppResponseBody(name='body'),
}

async function deleteTenantAppWithOptions(request: DeleteTenantAppRequest, runtime: Util.RuntimeOptions): DeleteTenantAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTenantApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTenantApp(request: DeleteTenantAppRequest): DeleteTenantAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTenantAppWithOptions(request, runtime);
}

model DescribeAppRequest {
  appId?: long(name='AppId'),
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model DescribeAppResponseBody = {
  app?: {
    cateName?: string(name='CateName'),
    description?: string(name='Description'),
    developer?: string(name='Developer'),
    fileRealName?: string(name='FileRealName'),
    iconUrl?: string(name='IconUrl'),
    id?: int32(name='Id'),
    name?: string(name='Name'),
    osType?: string(name='OsType'),
    publishDate?: string(name='PublishDate'),
    sandboxMode?: boolean(name='SandboxMode'),
    silenceFlag?: boolean(name='SilenceFlag'),
    silenceParam?: string(name='SilenceParam'),
    size?: long(name='Size'),
    sourceType?: string(name='SourceType'),
    status?: int32(name='Status'),
    version?: string(name='Version'),
  }(name='App'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppResponseBody(name='body'),
}

async function describeAppWithOptions(request: DescribeAppRequest, runtime: Util.RuntimeOptions): DescribeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeApp(request: DescribeAppRequest): DescribeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppWithOptions(request, runtime);
}

model DescribeAppDownloadInfoRequest {
  appId?: long(name='AppId'),
  appMode?: long(name='AppMode'),
  appVersion?: string(name='AppVersion'),
  appVersionCode?: long(name='AppVersionCode'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model DescribeAppDownloadInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    file?: string(name='File'),
    realFileName?: string(name='RealFileName'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeAppDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAppDownloadInfoResponseBody(name='body'),
}

async function describeAppDownloadInfoWithOptions(request: DescribeAppDownloadInfoRequest, runtime: Util.RuntimeOptions): DescribeAppDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appMode)) {
    query['AppMode'] = request.appMode;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionCode)) {
    query['AppVersionCode'] = request.appVersionCode;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAppDownloadInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAppDownloadInfo(request: DescribeAppDownloadInfoRequest): DescribeAppDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAppDownloadInfoWithOptions(request, runtime);
}

model DescribeUnpackagedAppDownloadInfoRequest {
  appId?: long(name='AppId'),
  appVersion?: string(name='AppVersion'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model DescribeUnpackagedAppDownloadInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    file?: string(name='File'),
    realFileName?: string(name='RealFileName'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeUnpackagedAppDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUnpackagedAppDownloadInfoResponseBody(name='body'),
}

async function describeUnpackagedAppDownloadInfoWithOptions(request: DescribeUnpackagedAppDownloadInfoRequest, runtime: Util.RuntimeOptions): DescribeUnpackagedAppDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUnpackagedAppDownloadInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUnpackagedAppDownloadInfo(request: DescribeUnpackagedAppDownloadInfoRequest): DescribeUnpackagedAppDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUnpackagedAppDownloadInfoWithOptions(request, runtime);
}

model DescribeUpgradeDownloadInfoRequest {
  appVersion?: string(name='AppVersion'),
  appVersionCode?: int32(name='AppVersionCode'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model DescribeUpgradeDownloadInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    comments?: string(name='Comments'),
    downloadInfo?: {
      accessKeyId?: string(name='AccessKeyId'),
      accessKeySecret?: string(name='AccessKeySecret'),
      bucket?: string(name='Bucket'),
      endpoint?: string(name='Endpoint'),
      file?: string(name='File'),
      realFileName?: string(name='RealFileName'),
      securityToken?: string(name='SecurityToken'),
    }(name='DownloadInfo'),
    forceUpgrade?: boolean(name='ForceUpgrade'),
    size?: string(name='Size'),
    version?: string(name='Version'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeUpgradeDownloadInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeDownloadInfoResponseBody(name='body'),
}

async function describeUpgradeDownloadInfoWithOptions(request: DescribeUpgradeDownloadInfoRequest, runtime: Util.RuntimeOptions): DescribeUpgradeDownloadInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.appVersionCode)) {
    query['AppVersionCode'] = request.appVersionCode;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeDownloadInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'Anonymous',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUpgradeDownloadInfo(request: DescribeUpgradeDownloadInfoRequest): DescribeUpgradeDownloadInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeDownloadInfoWithOptions(request, runtime);
}

model DescribeVisibleAppsRequest {
  appVersion?: string(name='AppVersion'),
  catalogId?: long(name='CatalogId'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  osType?: string(name='OsType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model DescribeVisibleAppsResponseBody = {
  apps?: [ 
    {
      cateName?: string(name='CateName'),
      description?: string(name='Description'),
      developer?: string(name='Developer'),
      fileRealName?: string(name='FileRealName'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      publishDate?: string(name='PublishDate'),
      sandboxMode?: boolean(name='SandboxMode'),
      size?: long(name='Size'),
      sourceType?: string(name='SourceType'),
      status?: int32(name='Status'),
      version?: string(name='Version'),
    }
  ](name='Apps'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeVisibleAppsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVisibleAppsResponseBody(name='body'),
}

async function describeVisibleAppsWithOptions(request: DescribeVisibleAppsRequest, runtime: Util.RuntimeOptions): DescribeVisibleAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVisibleApps',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVisibleApps(request: DescribeVisibleAppsRequest): DescribeVisibleAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVisibleAppsWithOptions(request, runtime);
}

model DistributeAppRequest {
  appId?: int32(name='AppId'),
  autoInstallFlag?: boolean(name='AutoInstallFlag'),
  distributeType?: string(name='DistributeType'),
  language?: string(name='Language'),
  orderId?: long(name='OrderId'),
  requestType?: string(name='RequestType'),
  subscribeId?: long(name='SubscribeId'),
  tenantId?: long(name='TenantId'),
  userList?: [ 
    {
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userName?: string(name='UserName'),
    }
  ](name='UserList'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model DistributeAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DistributeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DistributeAppResponseBody(name='body'),
}

async function distributeAppWithOptions(request: DistributeAppRequest, runtime: Util.RuntimeOptions): DistributeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userList)) {
    query['UserList'] = request.userList;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoInstallFlag)) {
    body['AutoInstallFlag'] = request.autoInstallFlag;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.orderId)) {
    body['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.requestType)) {
    body['RequestType'] = request.requestType;
  }
  if (!Util.isUnset(request.subscribeId)) {
    body['SubscribeId'] = request.subscribeId;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  if (!Util.isUnset(request.userType)) {
    body['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    body['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DistributeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function distributeApp(request: DistributeAppRequest): DistributeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return distributeAppWithOptions(request, runtime);
}

model GetAdminStsCredentialRequest {
  fileType?: int32(name='FileType'),
  isManual?: boolean(name='IsManual'),
}

model GetAdminStsCredentialResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    accessPath?: string(name='AccessPath'),
    bucketName?: string(name='BucketName'),
    expiration?: string(name='Expiration'),
    filePath?: string(name='FilePath'),
    ossPoint?: string(name='OssPoint'),
    ossPointInternal?: string(name='OssPointInternal'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model GetAdminStsCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAdminStsCredentialResponseBody(name='body'),
}

async function getAdminStsCredentialWithOptions(request: GetAdminStsCredentialRequest, runtime: Util.RuntimeOptions): GetAdminStsCredentialResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.isManual)) {
    body['IsManual'] = request.isManual;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAdminStsCredential',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAdminStsCredential(request: GetAdminStsCredentialRequest): GetAdminStsCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAdminStsCredentialWithOptions(request, runtime);
}

model GetAppDownloadUrlRequest {
  appId?: long(name='AppId'),
  sourceRegion?: string(name='SourceRegion'),
}

model GetAppDownloadUrlResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetAppDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppDownloadUrlResponseBody(name='body'),
}

async function getAppDownloadUrlWithOptions(request: GetAppDownloadUrlRequest, runtime: Util.RuntimeOptions): GetAppDownloadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppDownloadUrl',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppDownloadUrl(request: GetAppDownloadUrlRequest): GetAppDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppDownloadUrlWithOptions(request, runtime);
}

model GetAppStreamAgreementStatusResponseBody = {
  code?: string(name='Code'),
  data?: int32(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppStreamAgreementStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppStreamAgreementStatusResponseBody(name='body'),
}

async function getAppStreamAgreementStatusWithOptions(runtime: Util.RuntimeOptions): GetAppStreamAgreementStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAppStreamAgreementStatus',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppStreamAgreementStatus(): GetAppStreamAgreementStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppStreamAgreementStatusWithOptions(runtime);
}

model GetAppshowRequest {
  isShow?: int32(name='IsShow'),
}

model GetAppshowResponseBody = {
  code?: string(name='Code'),
  data?: {
    id?: int32(name='Id'),
    isShow?: int32(name='IsShow'),
    tenantId?: long(name='TenantId'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAppshowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppshowResponseBody(name='body'),
}

async function getAppshowWithOptions(request: GetAppshowRequest, runtime: Util.RuntimeOptions): GetAppshowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.isShow)) {
    body['IsShow'] = request.isShow;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetAppshow',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppshow(request: GetAppshowRequest): GetAppshowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppshowWithOptions(request, runtime);
}

model GetCertRequest {
  appId?: long(name='AppId'),
  regionId?: string(name='RegionId'),
}

model GetCertResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetCertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCertResponseBody(name='body'),
}

async function getCertWithOptions(request: GetCertRequest, runtime: Util.RuntimeOptions): GetCertResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetCert',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCert(request: GetCertRequest): GetCertResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertWithOptions(request, runtime);
}

model GetCertTemplateRequest {
  regionId?: string(name='RegionId'),
}

model GetCertTemplateResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetCertTemplateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCertTemplateResponseBody(name='body'),
}

async function getCertTemplateWithOptions(request: GetCertTemplateRequest, runtime: Util.RuntimeOptions): GetCertTemplateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetCertTemplate',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCertTemplate(request: GetCertTemplateRequest): GetCertTemplateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCertTemplateWithOptions(request, runtime);
}

model GetIconDownloadUrlRequest {
  appId?: long(name='AppId'),
  sourceRegion?: string(name='SourceRegion'),
}

model GetIconDownloadUrlResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetIconDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIconDownloadUrlResponseBody(name='body'),
}

async function getIconDownloadUrlWithOptions(request: GetIconDownloadUrlRequest, runtime: Util.RuntimeOptions): GetIconDownloadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetIconDownloadUrl',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIconDownloadUrl(request: GetIconDownloadUrlRequest): GetIconDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIconDownloadUrlWithOptions(request, runtime);
}

model GetIsvAppUploadCredentialResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    accessPath?: string(name='AccessPath'),
    bucketName?: string(name='BucketName'),
    expiration?: string(name='Expiration'),
    filePath?: string(name='FilePath'),
    ossPoint?: string(name='OssPoint'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetIsvAppUploadCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIsvAppUploadCredentialResponseBody(name='body'),
}

async function getIsvAppUploadCredentialWithOptions(runtime: Util.RuntimeOptions): GetIsvAppUploadCredentialResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetIsvAppUploadCredential',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIsvAppUploadCredential(): GetIsvAppUploadCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIsvAppUploadCredentialWithOptions(runtime);
}

model GetIsvCertStatusResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: int32(name='Status'),
}

model GetIsvCertStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIsvCertStatusResponseBody(name='body'),
}

async function getIsvCertStatusWithOptions(runtime: Util.RuntimeOptions): GetIsvCertStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetIsvCertStatus',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIsvCertStatus(): GetIsvCertStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIsvCertStatusWithOptions(runtime);
}

model GetIsvCertUploadCredentialResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    expiration?: string(name='Expiration'),
    filePath?: string(name='FilePath'),
    ossPoint?: string(name='OssPoint'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetIsvCertUploadCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIsvCertUploadCredentialResponseBody(name='body'),
}

async function getIsvCertUploadCredentialWithOptions(runtime: Util.RuntimeOptions): GetIsvCertUploadCredentialResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetIsvCertUploadCredential',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIsvCertUploadCredential(): GetIsvCertUploadCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIsvCertUploadCredentialWithOptions(runtime);
}

model GetIsvCopyrightUploadCredentialResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    filePath?: string(name='FilePath'),
    ossPoint?: string(name='OssPoint'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetIsvCopyrightUploadCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetIsvCopyrightUploadCredentialResponseBody(name='body'),
}

async function getIsvCopyrightUploadCredentialWithOptions(runtime: Util.RuntimeOptions): GetIsvCopyrightUploadCredentialResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetIsvCopyrightUploadCredential',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getIsvCopyrightUploadCredential(): GetIsvCopyrightUploadCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getIsvCopyrightUploadCredentialWithOptions(runtime);
}

model GetMarketAppDownloadUrlRequest {
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
}

model GetMarketAppDownloadUrlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model GetMarketAppDownloadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMarketAppDownloadUrlResponseBody(name='body'),
}

async function getMarketAppDownloadUrlWithOptions(request: GetMarketAppDownloadUrlRequest, runtime: Util.RuntimeOptions): GetMarketAppDownloadUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMarketAppDownloadUrl',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMarketAppDownloadUrl(request: GetMarketAppDownloadUrlRequest): GetMarketAppDownloadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMarketAppDownloadUrlWithOptions(request, runtime);
}

model GetStsCredentialRequest {
  fileType?: string(name='FileType'),
}

model GetStsCredentialResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucketName?: string(name='BucketName'),
    filePath?: string(name='FilePath'),
    ossPoint?: string(name='OssPoint'),
    stsToken?: string(name='StsToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetStsCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStsCredentialResponseBody(name='body'),
}

async function getStsCredentialWithOptions(request: GetStsCredentialRequest, runtime: Util.RuntimeOptions): GetStsCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileType)) {
    query['FileType'] = request.fileType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStsCredential',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStsCredential(request: GetStsCredentialRequest): GetStsCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStsCredentialWithOptions(request, runtime);
}

model GetTenantAppRequest {
  appId?: long(name='AppId'),
  language?: string(name='Language'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model GetTenantAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    appRegInfo?: string(name='AppRegInfo'),
    cateId?: long(name='CateId'),
    cateName?: string(name='CateName'),
    description?: string(name='Description'),
    detail?: string(name='Detail'),
    developer?: string(name='Developer'),
    discountPrice?: long(name='DiscountPrice'),
    distributeType?: string(name='DistributeType'),
    executeFile?: string(name='ExecuteFile'),
    fileName?: string(name='FileName'),
    filePath?: string(name='FilePath'),
    fileRealName?: string(name='FileRealName'),
    hasCert?: boolean(name='HasCert'),
    iconUrl?: string(name='IconUrl'),
    id?: long(name='Id'),
    isFree?: string(name='IsFree'),
    licenseType?: string(name='LicenseType'),
    manageCateEnName?: string(name='ManageCateEnName'),
    manageCateId?: int32(name='ManageCateId'),
    manageCateName?: string(name='ManageCateName'),
    name?: string(name='Name'),
    originAppType?: string(name='OriginAppType'),
    originalPrice?: long(name='OriginalPrice'),
    ossAppUrl?: string(name='OssAppUrl'),
    price?: string(name='Price'),
    publishDate?: string(name='PublishDate'),
    publishType?: string(name='PublishType'),
    searchTag?: string(name='SearchTag'),
    silenceDeleteFlag?: long(name='SilenceDeleteFlag'),
    silenceDeleteParam?: string(name='SilenceDeleteParam'),
    silenceFlag?: long(name='SilenceFlag'),
    silenceParam?: string(name='SilenceParam'),
    sourceType?: string(name='SourceType'),
    status?: string(name='Status'),
    version?: string(name='Version'),
    webUrl?: string(name='WebUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetTenantAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTenantAppResponseBody(name='body'),
}

async function getTenantAppWithOptions(request: GetTenantAppRequest, runtime: Util.RuntimeOptions): GetTenantAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTenantApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTenantApp(request: GetTenantAppRequest): GetTenantAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTenantAppWithOptions(request, runtime);
}

model GetUploadAppWamPackageInfoRequest {
  appVersion?: string(name='AppVersion'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model GetUploadAppWamPackageInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    accessKeySecret?: string(name='AccessKeySecret'),
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    file?: string(name='File'),
    ossPointInternal?: string(name='OssPointInternal'),
    realFileName?: string(name='RealFileName'),
    securityToken?: string(name='SecurityToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetUploadAppWamPackageInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUploadAppWamPackageInfoResponseBody(name='body'),
}

async function getUploadAppWamPackageInfoWithOptions(request: GetUploadAppWamPackageInfoRequest, runtime: Util.RuntimeOptions): GetUploadAppWamPackageInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUploadAppWamPackageInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUploadAppWamPackageInfo(request: GetUploadAppWamPackageInfoRequest): GetUploadAppWamPackageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUploadAppWamPackageInfoWithOptions(request, runtime);
}

model IsIsvNeedEnterResponseBody = {
  code?: string(name='Code'),
  isNeed?: boolean(name='IsNeed'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model IsIsvNeedEnterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: IsIsvNeedEnterResponseBody(name='body'),
}

async function isIsvNeedEnterWithOptions(runtime: Util.RuntimeOptions): IsIsvNeedEnterResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'IsIsvNeedEnter',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function isIsvNeedEnter(): IsIsvNeedEnterResponse {
  var runtime = new Util.RuntimeOptions{};
  return isIsvNeedEnterWithOptions(runtime);
}

model ListAdWorkspaceRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListAdWorkspaceResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adDomain?: string(name='AdDomain'),
      adName?: string(name='AdName'),
      adRegionId?: string(name='AdRegionId'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAdWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAdWorkspaceResponseBody(name='body'),
}

async function listAdWorkspaceWithOptions(request: ListAdWorkspaceRequest, runtime: Util.RuntimeOptions): ListAdWorkspaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAdWorkspace',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAdWorkspace(request: ListAdWorkspaceRequest): ListAdWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAdWorkspaceWithOptions(request, runtime);
}

model ListAllAppCategoryRequest {
  language?: string(name='Language'),
}

model ListAllAppCategoryResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      icon?: string(name='Icon'),
      iconUrlInternal?: string(name='IconUrlInternal'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      PId?: int32(name='PId'),
      rank?: int32(name='Rank'),
      status?: string(name='Status'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListAllAppCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAllAppCategoryResponseBody(name='body'),
}

async function listAllAppCategoryWithOptions(request: ListAllAppCategoryRequest, runtime: Util.RuntimeOptions): ListAllAppCategoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAllAppCategory',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAllAppCategory(request: ListAllAppCategoryRequest): ListAllAppCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAllAppCategoryWithOptions(request, runtime);
}

model ListAppCatalogRequest {
  appVersion?: string(name='AppVersion'),
  channel?: string(name='Channel'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model ListAppCatalogResponseBody = {
  catalogs?: [ 
    {
      icon?: string(name='Icon'),
      iconFocusUrl?: string(name='IconFocusUrl'),
      iconNormalUrl?: string(name='IconNormalUrl'),
      id?: long(name='Id'),
      name?: string(name='Name'),
    }
  ](name='Catalogs'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListAppCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppCatalogResponseBody(name='body'),
}

async function listAppCatalogWithOptions(request: ListAppCatalogRequest, runtime: Util.RuntimeOptions): ListAppCatalogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.channel)) {
    query['Channel'] = request.channel;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppCatalog',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppCatalog(request: ListAppCatalogRequest): ListAppCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppCatalogWithOptions(request, runtime);
}

model ListAppOpenTypeRequest {
  name?: string(name='Name'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAppOpenTypeResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: string(name='AppId'),
      fileType?: string(name='FileType'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListAppOpenTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppOpenTypeResponseBody(name='body'),
}

async function listAppOpenTypeWithOptions(request: ListAppOpenTypeRequest, runtime: Util.RuntimeOptions): ListAppOpenTypeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAppOpenType',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppOpenType(request: ListAppOpenTypeRequest): ListAppOpenTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppOpenTypeWithOptions(request, runtime);
}

model ListAppVersionRequest {
  appId?: int32(name='AppId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListAppVersionResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adapterMode?: string(name='AdapterMode'),
      adapterUid?: string(name='AdapterUid'),
      appCateId?: int32(name='AppCateId'),
      appCateName?: string(name='AppCateName'),
      appDescription?: string(name='AppDescription'),
      appIconUrl?: string(name='AppIconUrl'),
      appId?: int32(name='AppId'),
      appName?: string(name='AppName'),
      appRegInfo?: string(name='AppRegInfo'),
      appSize?: long(name='AppSize'),
      appVersion?: string(name='AppVersion'),
      copyrightDownloadUrl?: string(name='CopyrightDownloadUrl'),
      copyrightName?: string(name='CopyrightName'),
      copyrightPath?: string(name='CopyrightPath'),
      copyrightRealName?: string(name='CopyrightRealName'),
      createTime?: string(name='CreateTime'),
      developer?: string(name='Developer'),
      executeFile?: string(name='ExecuteFile'),
      extInfo?: string(name='ExtInfo'),
      fileDownloadUrl?: string(name='FileDownloadUrl'),
      fileName?: string(name='FileName'),
      filePath?: string(name='FilePath'),
      fileRealName?: string(name='FileRealName'),
      id?: int32(name='Id'),
      isvId?: long(name='IsvId'),
      originAppType?: string(name='OriginAppType'),
      ossAppUrl?: string(name='OssAppUrl'),
      processInstId?: string(name='ProcessInstId'),
      publishType?: int32(name='PublishType'),
      remark?: string(name='Remark'),
      status?: int32(name='Status'),
      updateTime?: string(name='UpdateTime'),
      versionName?: string(name='VersionName'),
      versionUid?: string(name='VersionUid'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAppVersionResponseBody(name='body'),
}

async function listAppVersionWithOptions(request: ListAppVersionRequest, runtime: Util.RuntimeOptions): ListAppVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAppVersion',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppVersion(request: ListAppVersionRequest): ListAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppVersionWithOptions(request, runtime);
}

model ListAuthorizationAllUserRequest {
  adRegionId?: string(name='AdRegionId'),
  appId?: long(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  userRegionId?: string(name='UserRegionId'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model ListAuthorizationAllUserResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  userList?: [ 
    {
      isDistributeUser?: boolean(name='IsDistributeUser'),
      name?: string(name='Name'),
      orderId?: long(name='OrderId'),
      subscribeId?: long(name='SubscribeId'),
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userType?: string(name='UserType'),
    }
  ](name='UserList'),
}

model ListAuthorizationAllUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthorizationAllUserResponseBody(name='body'),
}

async function listAuthorizationAllUserWithOptions(request: ListAuthorizationAllUserRequest, runtime: Util.RuntimeOptions): ListAuthorizationAllUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adRegionId)) {
    query['AdRegionId'] = request.adRegionId;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userRegionId)) {
    query['UserRegionId'] = request.userRegionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthorizationAllUser',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAuthorizationAllUser(request: ListAuthorizationAllUserRequest): ListAuthorizationAllUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuthorizationAllUserWithOptions(request, runtime);
}

model ListAuthorizationAppRequest {
  cateId?: long(name='CateId'),
  isFree?: string(name='IsFree'),
  keyName?: string(name='KeyName'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  sourceType?: string(name='SourceType'),
}

model ListAuthorizationAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      developer?: string(name='Developer'),
      discountPrice?: long(name='DiscountPrice'),
      iconUrl?: string(name='IconUrl'),
      id?: long(name='Id'),
      isFree?: string(name='IsFree'),
      labels?: string(name='Labels'),
      name?: string(name='Name'),
      originalPrice?: long(name='OriginalPrice'),
      paymentType?: long(name='PaymentType'),
      publishDate?: string(name='PublishDate'),
      sourceType?: string(name='SourceType'),
      subscribeCount?: long(name='SubscribeCount'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAuthorizationAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthorizationAppResponseBody(name='body'),
}

async function listAuthorizationAppWithOptions(request: ListAuthorizationAppRequest, runtime: Util.RuntimeOptions): ListAuthorizationAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.isFree)) {
    query['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.keyName)) {
    query['KeyName'] = request.keyName;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthorizationApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAuthorizationApp(request: ListAuthorizationAppRequest): ListAuthorizationAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuthorizationAppWithOptions(request, runtime);
}

model ListAuthorizationInfoRequest {
  appId?: long(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListAuthorizationInfoResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      distributeCount?: long(name='DistributeCount'),
      distributeLimit?: long(name='DistributeLimit'),
      expireTime?: string(name='ExpireTime'),
      id?: long(name='Id'),
      orderId?: long(name='OrderId'),
      startTime?: string(name='StartTime'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListAuthorizationInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAuthorizationInfoResponseBody(name='body'),
}

async function listAuthorizationInfoWithOptions(request: ListAuthorizationInfoRequest, runtime: Util.RuntimeOptions): ListAuthorizationInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAuthorizationInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAuthorizationInfo(request: ListAuthorizationInfoRequest): ListAuthorizationInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAuthorizationInfoWithOptions(request, runtime);
}

model ListDistributeAllUserRequest {
  adRegionId?: string(name='AdRegionId'),
  appId?: long(name='AppId'),
  keyName?: string(name='KeyName'),
  nextToken?: string(name='NextToken'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  userRegionId?: string(name='UserRegionId'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model ListDistributeAllUserResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  userList?: [ 
    {
      isDistributeUser?: boolean(name='IsDistributeUser'),
      name?: string(name='Name'),
      orderId?: long(name='OrderId'),
      subscribeId?: long(name='SubscribeId'),
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userType?: string(name='UserType'),
    }
  ](name='UserList'),
}

model ListDistributeAllUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDistributeAllUserResponseBody(name='body'),
}

async function listDistributeAllUserWithOptions(request: ListDistributeAllUserRequest, runtime: Util.RuntimeOptions): ListDistributeAllUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adRegionId)) {
    query['AdRegionId'] = request.adRegionId;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.keyName)) {
    query['KeyName'] = request.keyName;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userRegionId)) {
    query['UserRegionId'] = request.userRegionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDistributeAllUser',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDistributeAllUser(request: ListDistributeAllUserRequest): ListDistributeAllUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDistributeAllUserWithOptions(request, runtime);
}

model ListDistributeAppRequest {
  cateId?: long(name='CateId'),
  isFree?: string(name='IsFree'),
  keyName?: string(name='KeyName'),
  language?: string(name='Language'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  sourceType?: string(name='SourceType'),
}

model ListDistributeAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      developer?: string(name='Developer'),
      discountPrice?: long(name='DiscountPrice'),
      iconUrl?: string(name='IconUrl'),
      id?: long(name='Id'),
      isFree?: string(name='IsFree'),
      labels?: string(name='Labels'),
      name?: string(name='Name'),
      originAppType?: string(name='OriginAppType'),
      originalPrice?: long(name='OriginalPrice'),
      paymentType?: long(name='PaymentType'),
      publishDate?: string(name='PublishDate'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      version?: string(name='Version'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListDistributeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDistributeAppResponseBody(name='body'),
}

async function listDistributeAppWithOptions(request: ListDistributeAppRequest, runtime: Util.RuntimeOptions): ListDistributeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.isFree)) {
    query['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.keyName)) {
    query['KeyName'] = request.keyName;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDistributeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDistributeApp(request: ListDistributeAppRequest): ListDistributeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDistributeAppWithOptions(request, runtime);
}

model ListDistributeUserByAppRequest {
  appId?: long(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model ListDistributeUserByAppResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  userList?: [ 
    {
      isDistributeUser?: boolean(name='IsDistributeUser'),
      name?: string(name='Name'),
      orderId?: long(name='OrderId'),
      subscribeId?: long(name='SubscribeId'),
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userType?: string(name='UserType'),
    }
  ](name='UserList'),
}

model ListDistributeUserByAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDistributeUserByAppResponseBody(name='body'),
}

async function listDistributeUserByAppWithOptions(request: ListDistributeUserByAppRequest, runtime: Util.RuntimeOptions): ListDistributeUserByAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDistributeUserByApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDistributeUserByApp(request: ListDistributeUserByAppRequest): ListDistributeUserByAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDistributeUserByAppWithOptions(request, runtime);
}

model ListImageAppRequest {
  appName?: string(name='AppName'),
  appUid?: string(name='AppUid'),
  imageUid?: string(name='ImageUid'),
}

model ListImageAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appTag?: [ string ](name='AppTag'),
      appUid?: string(name='AppUid'),
      gmtCreate?: string(name='GmtCreate'),
      iconUrl?: string(name='IconUrl'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      status?: string(name='Status'),
      version?: string(name='Version'),
      versionName?: string(name='VersionName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListImageAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListImageAppResponseBody(name='body'),
}

async function listImageAppWithOptions(request: ListImageAppRequest, runtime: Util.RuntimeOptions): ListImageAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appUid)) {
    query['AppUid'] = request.appUid;
  }
  if (!Util.isUnset(request.imageUid)) {
    query['ImageUid'] = request.imageUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListImageApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listImageApp(request: ListImageAppRequest): ListImageAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listImageAppWithOptions(request, runtime);
}

model ListIsvAppRequest {
  appName?: string(name='AppName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListIsvAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appRegInfo?: string(name='AppRegInfo'),
      auditStatus?: int32(name='AuditStatus'),
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      createDate?: string(name='CreateDate'),
      developer?: string(name='Developer'),
      hasCert?: string(name='HasCert'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      manageCateEnName?: string(name='ManageCateEnName'),
      manageCateId?: string(name='ManageCateId'),
      manageCateName?: string(name='ManageCateName'),
      name?: string(name='Name'),
      originAppType?: string(name='OriginAppType'),
      status?: int32(name='Status'),
      updateDate?: string(name='UpdateDate'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListIsvAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIsvAppResponseBody(name='body'),
}

async function listIsvAppWithOptions(request: ListIsvAppRequest, runtime: Util.RuntimeOptions): ListIsvAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIsvApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIsvApp(request: ListIsvAppRequest): ListIsvAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIsvAppWithOptions(request, runtime);
}

model ListIsvAppAuditsRequest {
  appId?: int32(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListIsvAppAuditsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appCateId?: int32(name='AppCateId'),
      appIconUrl?: string(name='AppIconUrl'),
      appId?: int32(name='AppId'),
      appName?: string(name='AppName'),
      appRegInfo?: string(name='AppRegInfo'),
      appVersion?: string(name='AppVersion'),
      copyrightDownloadUrl?: string(name='CopyrightDownloadUrl'),
      createDate?: string(name='CreateDate'),
      developer?: string(name='Developer'),
      extInfo?: string(name='ExtInfo'),
      fileDownloadUrl?: string(name='FileDownloadUrl'),
      fileName?: string(name='FileName'),
      filePath?: string(name='FilePath'),
      fileRealName?: string(name='FileRealName'),
      id?: int32(name='Id'),
      originAppType?: string(name='OriginAppType'),
      publishType?: int32(name='PublishType'),
      remark?: string(name='Remark'),
      status?: int32(name='Status'),
      updateDate?: string(name='UpdateDate'),
      webUrl?: string(name='WebUrl'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListIsvAppAuditsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIsvAppAuditsResponseBody(name='body'),
}

async function listIsvAppAuditsWithOptions(request: ListIsvAppAuditsRequest, runtime: Util.RuntimeOptions): ListIsvAppAuditsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIsvAppAudits',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIsvAppAudits(request: ListIsvAppAuditsRequest): ListIsvAppAuditsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIsvAppAuditsWithOptions(request, runtime);
}

model ListMyAppRequest {
  appVersion?: string(name='AppVersion'),
  catalogId?: long(name='CatalogId'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  osType?: string(name='OsType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model ListMyAppResponseBody = {
  apps?: [ 
    {
      cateName?: string(name='CateName'),
      description?: string(name='Description'),
      developer?: string(name='Developer'),
      fileRealName?: string(name='FileRealName'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      publishDate?: string(name='PublishDate'),
      size?: long(name='Size'),
      sourceType?: string(name='SourceType'),
      version?: string(name='Version'),
    }
  ](name='Apps'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListMyAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMyAppResponseBody(name='body'),
}

async function listMyAppWithOptions(request: ListMyAppRequest, runtime: Util.RuntimeOptions): ListMyAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMyApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMyApp(request: ListMyAppRequest): ListMyAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMyAppWithOptions(request, runtime);
}

model ListSubscribeAppRequest {
  cateId?: long(name='CateId'),
  isFree?: string(name='IsFree'),
  keyName?: string(name='KeyName'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  sourceType?: string(name='SourceType'),
}

model ListSubscribeAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cateId?: long(name='CateId'),
      cateName?: string(name='CateName'),
      developer?: string(name='Developer'),
      discountPrice?: long(name='DiscountPrice'),
      iconUrl?: string(name='IconUrl'),
      id?: long(name='Id'),
      isFree?: string(name='IsFree'),
      labels?: string(name='Labels'),
      name?: string(name='Name'),
      originalPrice?: long(name='OriginalPrice'),
      paymentType?: long(name='PaymentType'),
      publishDate?: string(name='PublishDate'),
      sourceType?: string(name='SourceType'),
      subscribeCount?: long(name='SubscribeCount'),
      version?: string(name='Version'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListSubscribeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscribeAppResponseBody(name='body'),
}

async function listSubscribeAppWithOptions(request: ListSubscribeAppRequest, runtime: Util.RuntimeOptions): ListSubscribeAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.isFree)) {
    query['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.keyName)) {
    query['KeyName'] = request.keyName;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscribeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscribeApp(request: ListSubscribeAppRequest): ListSubscribeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubscribeAppWithOptions(request, runtime);
}

model ListSubscribeInfoRequest {
  appId?: long(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListSubscribeInfoResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appId?: int32(name='AppId'),
      distributeCount?: int32(name='DistributeCount'),
      distributeLimit?: int32(name='DistributeLimit'),
      distributeType?: string(name='DistributeType'),
      expireTime?: string(name='ExpireTime'),
      id?: int32(name='Id'),
      installMode?: string(name='InstallMode'),
      orderId?: long(name='OrderId'),
      startTime?: string(name='StartTime'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListSubscribeInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscribeInfoResponseBody(name='body'),
}

async function listSubscribeInfoWithOptions(request: ListSubscribeInfoRequest, runtime: Util.RuntimeOptions): ListSubscribeInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSubscribeInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscribeInfo(request: ListSubscribeInfoRequest): ListSubscribeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSubscribeInfoWithOptions(request, runtime);
}

model ListTenantAppRequest {
  appUid?: string(name='AppUid'),
  auditStatus?: int32(name='AuditStatus'),
  bizType?: string(name='BizType'),
  cateId?: int32(name='CateId'),
  cateIdList?: string(name='CateIdList'),
  distributeTypeList?: string(name='DistributeTypeList'),
  isFree?: string(name='IsFree'),
  isFreeList?: string(name='IsFreeList'),
  keyName?: string(name='KeyName'),
  language?: string(name='Language'),
  oderBy?: string(name='OderBy'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceType?: string(name='SourceType'),
  sourceTypeList?: string(name='SourceTypeList'),
  status?: string(name='Status'),
}

model ListTenantAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adminTag?: [ string ](name='AdminTag'),
      appAdminTag?: string(name='AppAdminTag'),
      appRegInfo?: string(name='AppRegInfo'),
      appTag?: [ string ](name='AppTag'),
      appUid?: string(name='AppUid'),
      autoInstallFlag?: boolean(name='AutoInstallFlag'),
      autoInstallType?: string(name='AutoInstallType'),
      cateId?: int32(name='CateId'),
      cateName?: string(name='CateName'),
      clusterUid?: string(name='ClusterUid'),
      description?: string(name='Description'),
      developer?: string(name='Developer'),
      discountPrice?: double(name='DiscountPrice'),
      distributeType?: string(name='DistributeType'),
      expireTime?: string(name='ExpireTime'),
      extend?: string(name='Extend'),
      fileName?: string(name='FileName'),
      filePath?: string(name='FilePath'),
      fileRealName?: string(name='FileRealName'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      hasCert?: boolean(name='HasCert'),
      iconUrl?: string(name='IconUrl'),
      iconUrlInternal?: string(name='IconUrlInternal'),
      id?: int32(name='Id'),
      install?: boolean(name='Install'),
      isFree?: string(name='IsFree'),
      isGame?: boolean(name='IsGame'),
      isWhiteList?: int32(name='IsWhiteList'),
      itemCode?: string(name='ItemCode'),
      labels?: string(name='Labels'),
      licenseType?: string(name='LicenseType'),
      manageCateEnName?: string(name='ManageCateEnName'),
      manageCateId?: int32(name='ManageCateId'),
      manageCateName?: string(name='ManageCateName'),
      name?: string(name='Name'),
      originAppType?: string(name='OriginAppType'),
      originalPrice?: double(name='OriginalPrice'),
      osType?: string(name='OsType'),
      ownerOs?: string(name='OwnerOs'),
      paymentType?: int32(name='PaymentType'),
      price?: string(name='Price'),
      priority?: int32(name='Priority'),
      publishDate?: string(name='PublishDate'),
      publishType?: string(name='PublishType'),
      searchTag?: string(name='SearchTag'),
      silenceDeleteFlag?: int32(name='SilenceDeleteFlag'),
      silenceDeleteParam?: string(name='SilenceDeleteParam'),
      silenceFlag?: int32(name='SilenceFlag'),
      silenceParam?: string(name='SilenceParam'),
      size?: long(name='Size'),
      sourceType?: string(name='SourceType'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      subSourceType?: string(name='SubSourceType'),
      subscribeCount?: long(name='SubscribeCount'),
      supplierId?: long(name='SupplierId'),
      userTag?: [ string ](name='UserTag'),
      version?: string(name='Version'),
      versionName?: string(name='VersionName'),
      wamFileName?: string(name='WamFileName'),
      wamFilePath?: string(name='WamFilePath'),
      wamFileRealName?: string(name='WamFileRealName'),
      wamFileSize?: long(name='WamFileSize'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListTenantAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTenantAppResponseBody(name='body'),
}

async function listTenantAppWithOptions(request: ListTenantAppRequest, runtime: Util.RuntimeOptions): ListTenantAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appUid)) {
    query['AppUid'] = request.appUid;
  }
  if (!Util.isUnset(request.auditStatus)) {
    query['AuditStatus'] = request.auditStatus;
  }
  if (!Util.isUnset(request.bizType)) {
    query['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.cateIdList)) {
    query['CateIdList'] = request.cateIdList;
  }
  if (!Util.isUnset(request.distributeTypeList)) {
    query['DistributeTypeList'] = request.distributeTypeList;
  }
  if (!Util.isUnset(request.isFree)) {
    query['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.isFreeList)) {
    query['IsFreeList'] = request.isFreeList;
  }
  if (!Util.isUnset(request.keyName)) {
    query['KeyName'] = request.keyName;
  }
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.oderBy)) {
    query['OderBy'] = request.oderBy;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.sourceTypeList)) {
    query['SourceTypeList'] = request.sourceTypeList;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTenantApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTenantApp(request: ListTenantAppRequest): ListTenantAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTenantAppWithOptions(request, runtime);
}

model ListTenantAppCategoryRequest {
  language?: string(name='Language'),
  PId?: long(name='PId'),
  regionId?: string(name='RegionId'),
}

model ListTenantAppCategoryResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      clientCateEnName?: string(name='ClientCateEnName'),
      clientCateName?: string(name='ClientCateName'),
      icon?: string(name='Icon'),
      iconUrlInternal?: string(name='IconUrlInternal'),
      id?: long(name='Id'),
      name?: string(name='Name'),
      PId?: long(name='PId'),
      rank?: long(name='Rank'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListTenantAppCategoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTenantAppCategoryResponseBody(name='body'),
}

async function listTenantAppCategoryWithOptions(request: ListTenantAppCategoryRequest, runtime: Util.RuntimeOptions): ListTenantAppCategoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.language)) {
    query['Language'] = request.language;
  }
  if (!Util.isUnset(request.PId)) {
    query['PId'] = request.PId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTenantAppCategory',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTenantAppCategory(request: ListTenantAppCategoryRequest): ListTenantAppCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTenantAppCategoryWithOptions(request, runtime);
}

model ListUnpackagedAppRequest {
  appVersion?: string(name='AppVersion'),
  catalogId?: long(name='CatalogId'),
  instanceId?: string(name='InstanceId'),
  keyword?: string(name='Keyword'),
  osType?: string(name='OsType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
}

model ListUnpackagedAppResponseBody = {
  apps?: [ 
    {
      appId?: int32(name='AppId'),
      cateName?: string(name='CateName'),
      description?: string(name='Description'),
      developer?: string(name='Developer'),
      fileRealName?: string(name='FileRealName'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      publishDate?: string(name='PublishDate'),
      size?: long(name='Size'),
      sourceType?: string(name='SourceType'),
      status?: string(name='Status'),
      version?: string(name='Version'),
    }
  ](name='Apps'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListUnpackagedAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUnpackagedAppResponseBody(name='body'),
}

async function listUnpackagedAppWithOptions(request: ListUnpackagedAppRequest, runtime: Util.RuntimeOptions): ListUnpackagedAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.catalogId)) {
    query['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUnpackagedApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUnpackagedApp(request: ListUnpackagedAppRequest): ListUnpackagedAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUnpackagedAppWithOptions(request, runtime);
}

model ListUpdateImageAppRequest {
  appName?: string(name='AppName'),
  appUid?: string(name='AppUid'),
  imageUid?: string(name='ImageUid'),
}

model ListUpdateImageAppResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adaptorUid?: string(name='AdaptorUid'),
      appTag?: [ string ](name='AppTag'),
      appUid?: string(name='AppUid'),
      gmtCreate?: string(name='GmtCreate'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      osType?: string(name='OsType'),
      status?: string(name='Status'),
      version?: string(name='Version'),
      versionName?: string(name='VersionName'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListUpdateImageAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUpdateImageAppResponseBody(name='body'),
}

async function listUpdateImageAppWithOptions(request: ListUpdateImageAppRequest, runtime: Util.RuntimeOptions): ListUpdateImageAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appUid)) {
    body['AppUid'] = request.appUid;
  }
  if (!Util.isUnset(request.imageUid)) {
    body['ImageUid'] = request.imageUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUpdateImageApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUpdateImageApp(request: ListUpdateImageAppRequest): ListUpdateImageAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUpdateImageAppWithOptions(request, runtime);
}

model ListVersionAppInfoRequest {
  appTag?: string(name='AppTag'),
  appUid?: string(name='AppUid'),
  name?: string(name='Name'),
  os?: string(name='Os'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  status?: int32(name='Status'),
}

model ListVersionAppInfoResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      adaptorUid?: string(name='AdaptorUid'),
      appTag?: [ string ](name='AppTag'),
      appUid?: string(name='AppUid'),
      cateId?: int32(name='CateId'),
      gmtCreate?: string(name='GmtCreate'),
      iconUrl?: string(name='IconUrl'),
      id?: int32(name='Id'),
      name?: string(name='Name'),
      ownerOs?: string(name='OwnerOs'),
      size?: long(name='Size'),
      status?: string(name='Status'),
      version?: string(name='Version'),
      versionName?: string(name='VersionName'),
    }
  ](name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model ListVersionAppInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListVersionAppInfoResponseBody(name='body'),
}

async function listVersionAppInfoWithOptions(request: ListVersionAppInfoRequest, runtime: Util.RuntimeOptions): ListVersionAppInfoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appTag)) {
    body['AppTag'] = request.appTag;
  }
  if (!Util.isUnset(request.appUid)) {
    body['AppUid'] = request.appUid;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.os)) {
    body['Os'] = request.os;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListVersionAppInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listVersionAppInfo(request: ListVersionAppInfoRequest): ListVersionAppInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVersionAppInfoWithOptions(request, runtime);
}

model QueryIsvAppAuditRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
}

model QueryIsvAppAuditResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCateId?: int32(name='AppCateId'),
    appIconUrl?: string(name='AppIconUrl'),
    appId?: int32(name='AppId'),
    appName?: string(name='AppName'),
    appVersion?: string(name='AppVersion'),
    copyrightDownloadUrl?: string(name='CopyrightDownloadUrl'),
    copyrightName?: string(name='CopyrightName'),
    copyrightPath?: string(name='CopyrightPath'),
    copyrightRealName?: string(name='CopyrightRealName'),
    createDate?: string(name='CreateDate'),
    developer?: string(name='Developer'),
    extInfo?: string(name='ExtInfo'),
    fileDownloadUrl?: string(name='FileDownloadUrl'),
    fileName?: string(name='FileName'),
    filePath?: string(name='FilePath'),
    fileRealName?: string(name='FileRealName'),
    originAppType?: string(name='OriginAppType'),
    publishType?: int32(name='PublishType'),
    remark?: string(name='Remark'),
    status?: int32(name='Status'),
    updateDate?: string(name='UpdateDate'),
    webUrl?: string(name='WebUrl'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model QueryIsvAppAuditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryIsvAppAuditResponseBody(name='body'),
}

async function queryIsvAppAuditWithOptions(request: QueryIsvAppAuditRequest, runtime: Util.RuntimeOptions): QueryIsvAppAuditResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryIsvAppAudit',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryIsvAppAudit(request: QueryIsvAppAuditRequest): QueryIsvAppAuditResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryIsvAppAuditWithOptions(request, runtime);
}

model QueryItemsRequest {
  appId?: long(name='AppId'),
  cateId?: long(name='CateId'),
  itemId?: long(name='ItemId'),
  itemName?: string(name='ItemName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  paymentType?: long(name='PaymentType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sellerId?: long(name='SellerId'),
  status?: long(name='Status'),
}

model QueryItemsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      appDTO?: {
        cateName?: string(name='CateName'),
        developer?: string(name='Developer'),
        iconUrl?: string(name='IconUrl'),
        licenseType?: long(name='LicenseType'),
        modifyDate?: string(name='ModifyDate'),
        name?: string(name='Name'),
        publishDate?: string(name='PublishDate'),
        sourceType?: string(name='SourceType'),
        version?: string(name='Version'),
      }(name='AppDTO'),
      appId?: long(name='AppId'),
      cateId?: long(name='CateId'),
      id?: long(name='Id'),
      itemCode?: string(name='ItemCode'),
      itemName?: string(name='ItemName'),
      labels?: string(name='Labels'),
      paymentType?: long(name='PaymentType'),
      picUrl?: string(name='PicUrl'),
      price?: string(name='Price'),
      rawPrice?: string(name='RawPrice'),
      sellerId?: long(name='SellerId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model QueryItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryItemsResponseBody(name='body'),
}

async function queryItemsWithOptions(request: QueryItemsRequest, runtime: Util.RuntimeOptions): QueryItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.itemName)) {
    query['ItemName'] = request.itemName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paymentType)) {
    query['PaymentType'] = request.paymentType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.sellerId)) {
    query['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryItems',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryItems(request: QueryItemsRequest): QueryItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryItemsWithOptions(request, runtime);
}

model QueryOrdersRequest {
  buyerId?: long(name='BuyerId'),
  itemId?: long(name='ItemId'),
  orderName?: string(name='OrderName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  sellerId?: long(name='SellerId'),
  status?: long(name='Status'),
}

model QueryOrdersResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      amount?: long(name='Amount'),
      appDTO?: {
        developer?: string(name='Developer'),
        gmtModified?: long(name='GmtModified'),
        licenseType?: long(name='LicenseType'),
        name?: string(name='Name'),
        version?: string(name='Version'),
      }(name='AppDTO'),
      gmtCreate?: long(name='GmtCreate'),
      gmtModified?: long(name='GmtModified'),
      id?: long(name='Id'),
      orderName?: string(name='OrderName'),
      orderTime?: string(name='OrderTime'),
      outDateTime?: long(name='OutDateTime'),
      paymentTime?: string(name='PaymentTime'),
      price?: string(name='Price'),
      rawPrice?: string(name='RawPrice'),
      status?: long(name='Status'),
      orderId?: string(name='orderId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model QueryOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrdersResponseBody(name='body'),
}

async function queryOrdersWithOptions(request: QueryOrdersRequest, runtime: Util.RuntimeOptions): QueryOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.buyerId)) {
    query['BuyerId'] = request.buyerId;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  if (!Util.isUnset(request.orderName)) {
    query['OrderName'] = request.orderName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.sellerId)) {
    query['SellerId'] = request.sellerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrders',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrders(request: QueryOrdersRequest): QueryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrdersWithOptions(request, runtime);
}

model SetAppStreamAgreementStatusResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetAppStreamAgreementStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAppStreamAgreementStatusResponseBody(name='body'),
}

async function setAppStreamAgreementStatusWithOptions(runtime: Util.RuntimeOptions): SetAppStreamAgreementStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'SetAppStreamAgreementStatus',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAppStreamAgreementStatus(): SetAppStreamAgreementStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAppStreamAgreementStatusWithOptions(runtime);
}

model SubscribeAppRequest {
  appId?: int32(name='AppId'),
  autoDeleteFlag?: boolean(name='AutoDeleteFlag'),
  autoInstallFlag?: boolean(name='AutoInstallFlag'),
  distributeType?: string(name='DistributeType'),
  forceInstallType?: string(name='ForceInstallType'),
  language?: string(name='Language'),
  requestType?: string(name='RequestType'),
  silenceDeleteParam?: string(name='SilenceDeleteParam'),
  silenceInstallParam?: string(name='SilenceInstallParam'),
}

model SubscribeAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubscribeAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubscribeAppResponseBody(name='body'),
}

async function subscribeAppWithOptions(request: SubscribeAppRequest, runtime: Util.RuntimeOptions): SubscribeAppResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.autoDeleteFlag)) {
    body['AutoDeleteFlag'] = request.autoDeleteFlag;
  }
  if (!Util.isUnset(request.autoInstallFlag)) {
    body['AutoInstallFlag'] = request.autoInstallFlag;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.forceInstallType)) {
    body['ForceInstallType'] = request.forceInstallType;
  }
  if (!Util.isUnset(request.language)) {
    body['Language'] = request.language;
  }
  if (!Util.isUnset(request.requestType)) {
    body['RequestType'] = request.requestType;
  }
  if (!Util.isUnset(request.silenceDeleteParam)) {
    body['SilenceDeleteParam'] = request.silenceDeleteParam;
  }
  if (!Util.isUnset(request.silenceInstallParam)) {
    body['SilenceInstallParam'] = request.silenceInstallParam;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SubscribeApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function subscribeApp(request: SubscribeAppRequest): SubscribeAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return subscribeAppWithOptions(request, runtime);
}

model UpdateAppMetaRequest {
  appId?: long(name='AppId'),
  appRegInfo?: string(name='AppRegInfo'),
  appTag?: [ string ](name='AppTag'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: long(name='CateId'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  publishType?: int32(name='PublishType'),
  regionId?: string(name='RegionId'),
  silenceFlag?: long(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model UpdateAppMetaShrinkRequest {
  appId?: long(name='AppId'),
  appRegInfo?: string(name='AppRegInfo'),
  appTagShrink?: string(name='AppTag'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: long(name='CateId'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  publishType?: int32(name='PublishType'),
  regionId?: string(name='RegionId'),
  silenceFlag?: long(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model UpdateAppMetaResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateAppMetaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppMetaResponseBody(name='body'),
}

async function updateAppMetaWithOptions(tmpReq: UpdateAppMetaRequest, runtime: Util.RuntimeOptions): UpdateAppMetaResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAppMetaShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appTag)) {
    request.appTagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appTag, 'AppTag', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appRegInfo)) {
    body['AppRegInfo'] = request.appRegInfo;
  }
  if (!Util.isUnset(request.appTagShrink)) {
    body['AppTag'] = request.appTagShrink;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.applicationLink)) {
    body['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.applicationType)) {
    body['ApplicationType'] = request.applicationType;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.cateId)) {
    body['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.developer)) {
    body['Developer'] = request.developer;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.isFree)) {
    body['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.licenceType)) {
    body['LicenceType'] = request.licenceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.publishType)) {
    body['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.silenceFlag)) {
    body['SilenceFlag'] = request.silenceFlag;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  if (!Util.isUnset(request.wamFileName)) {
    body['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    body['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    body['WamFileRealName'] = request.wamFileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppMeta',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppMeta(request: UpdateAppMetaRequest): UpdateAppMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppMetaWithOptions(request, runtime);
}

model UpdateAppParamRequest {
  appInstallParam?: string(name='AppInstallParam'),
  appInstallPath?: string(name='AppInstallPath'),
  appStreamStartParam?: string(name='AppStreamStartParam'),
  appUid?: string(name='AppUid'),
  versionAdaptParam?: string(name='VersionAdaptParam'),
}

model UpdateAppParamResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAppParamResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppParamResponseBody(name='body'),
}

async function updateAppParamWithOptions(request: UpdateAppParamRequest, runtime: Util.RuntimeOptions): UpdateAppParamResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appInstallParam)) {
    body['AppInstallParam'] = request.appInstallParam;
  }
  if (!Util.isUnset(request.appInstallPath)) {
    body['AppInstallPath'] = request.appInstallPath;
  }
  if (!Util.isUnset(request.appStreamStartParam)) {
    body['AppStreamStartParam'] = request.appStreamStartParam;
  }
  if (!Util.isUnset(request.appUid)) {
    body['AppUid'] = request.appUid;
  }
  if (!Util.isUnset(request.versionAdaptParam)) {
    body['VersionAdaptParam'] = request.versionAdaptParam;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppParam',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppParam(request: UpdateAppParamRequest): UpdateAppParamResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppParamWithOptions(request, runtime);
}

model UpdateAppVersionRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  executeFile?: string(name='ExecuteFile'),
  executeFileAddress?: string(name='ExecuteFileAddress'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  mock?: boolean(name='Mock'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  startParam?: string(name='StartParam'),
  versionId?: long(name='VersionId'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model UpdateAppVersionResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateAppVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppVersionResponseBody(name='body'),
}

async function updateAppVersionWithOptions(request: UpdateAppVersionRequest, runtime: Util.RuntimeOptions): UpdateAppVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.applicationLink)) {
    body['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.executeFileAddress)) {
    body['ExecuteFileAddress'] = request.executeFileAddress;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.mock)) {
    body['Mock'] = request.mock;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.silenceFlag)) {
    body['SilenceFlag'] = request.silenceFlag;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  if (!Util.isUnset(request.startParam)) {
    body['StartParam'] = request.startParam;
  }
  if (!Util.isUnset(request.versionId)) {
    body['VersionId'] = request.versionId;
  }
  if (!Util.isUnset(request.wamFileName)) {
    body['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    body['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    body['WamFileRealName'] = request.wamFileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppVersion',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppVersion(request: UpdateAppVersionRequest): UpdateAppVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppVersionWithOptions(request, runtime);
}

model UpdateAppWamPackageInfoRequest {
  appId?: int32(name='AppId'),
  appVersion?: string(name='AppVersion'),
  instanceId?: string(name='InstanceId'),
  osType?: string(name='OsType'),
  privateKey?: string(name='PrivateKey'),
  region?: string(name='Region'),
  systemVersion?: string(name='SystemVersion'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
  wamFileSize?: int32(name='WamFileSize'),
}

model UpdateAppWamPackageInfoResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateAppWamPackageInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppWamPackageInfoResponseBody(name='body'),
}

async function updateAppWamPackageInfoWithOptions(request: UpdateAppWamPackageInfoRequest, runtime: Util.RuntimeOptions): UpdateAppWamPackageInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osType)) {
    query['OsType'] = request.osType;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.systemVersion)) {
    query['SystemVersion'] = request.systemVersion;
  }
  if (!Util.isUnset(request.wamFileName)) {
    query['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    query['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    query['WamFileRealName'] = request.wamFileRealName;
  }
  if (!Util.isUnset(request.wamFileSize)) {
    query['WamFileSize'] = request.wamFileSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppWamPackageInfo',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppWamPackageInfo(request: UpdateAppWamPackageInfoRequest): UpdateAppWamPackageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppWamPackageInfoWithOptions(request, runtime);
}

model UpdateIsvAppRequest {
  appDownloadUrl?: string(name='AppDownloadUrl'),
  appId?: long(name='AppId'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  cateId?: int32(name='CateId'),
  copyrightName?: string(name='CopyrightName'),
  copyrightPath?: string(name='CopyrightPath'),
  copyrightRealName?: string(name='CopyrightRealName'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  name?: string(name='Name'),
  newVersion?: string(name='NewVersion'),
  ossAppUrl?: string(name='OssAppUrl'),
  publishType?: int32(name='PublishType'),
  versionId?: int32(name='VersionId'),
}

model UpdateIsvAppResponseBody = {
  code?: string(name='Code'),
  isSuccess?: boolean(name='IsSuccess'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateIsvAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateIsvAppResponseBody(name='body'),
}

async function updateIsvAppWithOptions(request: UpdateIsvAppRequest, runtime: Util.RuntimeOptions): UpdateIsvAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appDownloadUrl)) {
    query['AppDownloadUrl'] = request.appDownloadUrl;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.applicationLink)) {
    query['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.cateId)) {
    query['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.copyrightName)) {
    query['CopyrightName'] = request.copyrightName;
  }
  if (!Util.isUnset(request.copyrightPath)) {
    query['CopyrightPath'] = request.copyrightPath;
  }
  if (!Util.isUnset(request.copyrightRealName)) {
    query['CopyrightRealName'] = request.copyrightRealName;
  }
  if (!Util.isUnset(request.detail)) {
    query['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.developer)) {
    query['Developer'] = request.developer;
  }
  if (!Util.isUnset(request.executeFile)) {
    query['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    query['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    query['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.iconUrl)) {
    query['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.newVersion)) {
    query['NewVersion'] = request.newVersion;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    query['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.publishType)) {
    query['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.versionId)) {
    query['VersionId'] = request.versionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateIsvApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateIsvApp(request: UpdateIsvAppRequest): UpdateIsvAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateIsvAppWithOptions(request, runtime);
}

model UpdateOrderRequest {
  orderId?: string(name='OrderId'),
  status?: long(name='Status'),
}

model UpdateOrderResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model UpdateOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOrderResponseBody(name='body'),
}

async function updateOrderWithOptions(request: UpdateOrderRequest, runtime: Util.RuntimeOptions): UpdateOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOrder',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOrder(request: UpdateOrderRequest): UpdateOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOrderWithOptions(request, runtime);
}

model UpdateSilenceRequest {
  appId?: int32(name='AppId'),
  silenceDeleteFlag?: int32(name='SilenceDeleteFlag'),
  silenceDeleteParam?: string(name='SilenceDeleteParam'),
  silenceInstallFlag?: int32(name='SilenceInstallFlag'),
  silenceInstallParam?: string(name='SilenceInstallParam'),
}

model UpdateSilenceResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateSilenceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSilenceResponseBody(name='body'),
}

async function updateSilenceWithOptions(request: UpdateSilenceRequest, runtime: Util.RuntimeOptions): UpdateSilenceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.silenceDeleteFlag)) {
    body['SilenceDeleteFlag'] = request.silenceDeleteFlag;
  }
  if (!Util.isUnset(request.silenceDeleteParam)) {
    body['SilenceDeleteParam'] = request.silenceDeleteParam;
  }
  if (!Util.isUnset(request.silenceInstallFlag)) {
    body['SilenceInstallFlag'] = request.silenceInstallFlag;
  }
  if (!Util.isUnset(request.silenceInstallParam)) {
    body['SilenceInstallParam'] = request.silenceInstallParam;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSilence',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSilence(request: UpdateSilenceRequest): UpdateSilenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSilenceWithOptions(request, runtime);
}

model UpdateTenantAppRequest {
  appId?: int32(name='AppId'),
  appTag?: [ string ](name='AppTag'),
  appTag1?: string(name='AppTag1'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: int32(name='CateId'),
  cateType?: int32(name='CateType'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  searchTag?: string(name='SearchTag'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model UpdateTenantAppShrinkRequest {
  appId?: int32(name='AppId'),
  appTagShrink?: string(name='AppTag'),
  appTag1?: string(name='AppTag1'),
  appVersion?: string(name='AppVersion'),
  applicationLink?: string(name='ApplicationLink'),
  applicationType?: string(name='ApplicationType'),
  bizType?: string(name='BizType'),
  cateId?: int32(name='CateId'),
  cateType?: int32(name='CateType'),
  description?: string(name='Description'),
  detail?: string(name='Detail'),
  developer?: string(name='Developer'),
  distributeType?: string(name='DistributeType'),
  executeFile?: string(name='ExecuteFile'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileRealName?: string(name='FileRealName'),
  iconUrl?: string(name='IconUrl'),
  isFree?: string(name='IsFree'),
  licenceType?: string(name='LicenceType'),
  name?: string(name='Name'),
  ossAppUrl?: string(name='OssAppUrl'),
  searchTag?: string(name='SearchTag'),
  silenceFlag?: int32(name='SilenceFlag'),
  silenceParam?: string(name='SilenceParam'),
  wamFileName?: string(name='WamFileName'),
  wamFilePath?: string(name='WamFilePath'),
  wamFileRealName?: string(name='WamFileRealName'),
}

model UpdateTenantAppResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
  }(name='Data'),
  httpStatusCode?: int32(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateTenantAppResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateTenantAppResponseBody(name='body'),
}

async function updateTenantAppWithOptions(tmpReq: UpdateTenantAppRequest, runtime: Util.RuntimeOptions): UpdateTenantAppResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateTenantAppShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.appTag)) {
    request.appTagShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.appTag, 'AppTag', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appTagShrink)) {
    body['AppTag'] = request.appTagShrink;
  }
  if (!Util.isUnset(request.appTag1)) {
    body['AppTag1'] = request.appTag1;
  }
  if (!Util.isUnset(request.appVersion)) {
    body['AppVersion'] = request.appVersion;
  }
  if (!Util.isUnset(request.applicationLink)) {
    body['ApplicationLink'] = request.applicationLink;
  }
  if (!Util.isUnset(request.applicationType)) {
    body['ApplicationType'] = request.applicationType;
  }
  if (!Util.isUnset(request.bizType)) {
    body['BizType'] = request.bizType;
  }
  if (!Util.isUnset(request.cateId)) {
    body['CateId'] = request.cateId;
  }
  if (!Util.isUnset(request.cateType)) {
    body['CateType'] = request.cateType;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.developer)) {
    body['Developer'] = request.developer;
  }
  if (!Util.isUnset(request.distributeType)) {
    body['DistributeType'] = request.distributeType;
  }
  if (!Util.isUnset(request.executeFile)) {
    body['ExecuteFile'] = request.executeFile;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileRealName)) {
    body['FileRealName'] = request.fileRealName;
  }
  if (!Util.isUnset(request.iconUrl)) {
    body['IconUrl'] = request.iconUrl;
  }
  if (!Util.isUnset(request.isFree)) {
    body['IsFree'] = request.isFree;
  }
  if (!Util.isUnset(request.licenceType)) {
    body['LicenceType'] = request.licenceType;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.ossAppUrl)) {
    body['OssAppUrl'] = request.ossAppUrl;
  }
  if (!Util.isUnset(request.searchTag)) {
    body['SearchTag'] = request.searchTag;
  }
  if (!Util.isUnset(request.silenceFlag)) {
    body['SilenceFlag'] = request.silenceFlag;
  }
  if (!Util.isUnset(request.silenceParam)) {
    body['SilenceParam'] = request.silenceParam;
  }
  if (!Util.isUnset(request.wamFileName)) {
    body['WamFileName'] = request.wamFileName;
  }
  if (!Util.isUnset(request.wamFilePath)) {
    body['WamFilePath'] = request.wamFilePath;
  }
  if (!Util.isUnset(request.wamFileRealName)) {
    body['WamFileRealName'] = request.wamFileRealName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTenantApp',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTenantApp(request: UpdateTenantAppRequest): UpdateTenantAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTenantAppWithOptions(request, runtime);
}

model UserListRequest {
  adRegionId?: string(name='AdRegionId'),
  appId?: long(name='AppId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  userRegionId?: string(name='UserRegionId'),
  userType?: string(name='UserType'),
  workspaceName?: string(name='WorkspaceName'),
}

model UserListResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  userList?: [ 
    {
      isDistribute?: boolean(name='IsDistribute'),
      name?: string(name='Name'),
      userEmail?: string(name='UserEmail'),
      userId?: long(name='UserId'),
      userType?: string(name='UserType'),
    }
  ](name='UserList'),
}

model UserListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UserListResponseBody(name='body'),
}

async function userListWithOptions(request: UserListRequest, runtime: Util.RuntimeOptions): UserListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adRegionId)) {
    query['AdRegionId'] = request.adRegionId;
  }
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userRegionId)) {
    query['UserRegionId'] = request.userRegionId;
  }
  if (!Util.isUnset(request.userType)) {
    query['UserType'] = request.userType;
  }
  if (!Util.isUnset(request.workspaceName)) {
    query['WorkspaceName'] = request.workspaceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UserList',
    version = '2021-06-02',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function userList(request: UserListRequest): UserListResponse {
  var runtime = new Util.RuntimeOptions{};
  return userListWithOptions(request, runtime);
}

