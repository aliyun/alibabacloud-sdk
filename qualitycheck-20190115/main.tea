/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
@endpointMap = {
    cn-hangzhou = 'qualitycheck.cn-hangzhou.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('qualitycheck', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AddBusinessCategoryRequest {
  jsonStr?: string(name='JsonStr'),
}

model AddBusinessCategoryResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddBusinessCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddBusinessCategoryResponseBody(name='body'),
}

async function addBusinessCategoryWithOptions(request: AddBusinessCategoryRequest, runtime: Util.RuntimeOptions): AddBusinessCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddBusinessCategory',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addBusinessCategory(request: AddBusinessCategoryRequest): AddBusinessCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addBusinessCategoryWithOptions(request, runtime);
}

model AddRuleCategoryRequest {
  jsonStr?: string(name='JsonStr'),
}

model AddRuleCategoryResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    select?: boolean(name='Select'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddRuleCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: AddRuleCategoryResponseBody(name='body'),
}

async function addRuleCategoryWithOptions(request: AddRuleCategoryRequest, runtime: Util.RuntimeOptions): AddRuleCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddRuleCategory',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addRuleCategory(request: AddRuleCategoryRequest): AddRuleCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return addRuleCategoryWithOptions(request, runtime);
}

model AddThesaurusForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model AddThesaurusForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddThesaurusForApiResponse = {
  headers: map[string]string(name='headers'),
  body: AddThesaurusForApiResponseBody(name='body'),
}

async function addThesaurusForApiWithOptions(request: AddThesaurusForApiRequest, runtime: Util.RuntimeOptions): AddThesaurusForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddThesaurusForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addThesaurusForApi(request: AddThesaurusForApiRequest): AddThesaurusForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return addThesaurusForApiWithOptions(request, runtime);
}

model AddUploadDataSetRequest {
  jsonStr?: string(name='JsonStr'),
}

model AddUploadDataSetResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AddUploadDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: AddUploadDataSetResponseBody(name='body'),
}

async function addUploadDataSetWithOptions(request: AddUploadDataSetRequest, runtime: Util.RuntimeOptions): AddUploadDataSetResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AddUploadDataSet',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUploadDataSet(request: AddUploadDataSetRequest): AddUploadDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUploadDataSetWithOptions(request, runtime);
}

model AssignReviewerRequest {
  jsonStr?: string(name='JsonStr'),
}

model AssignReviewerResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model AssignReviewerResponse = {
  headers: map[string]string(name='headers'),
  body: AssignReviewerResponseBody(name='body'),
}

async function assignReviewerWithOptions(request: AssignReviewerRequest, runtime: Util.RuntimeOptions): AssignReviewerResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'AssignReviewer',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function assignReviewer(request: AssignReviewerRequest): AssignReviewerResponse {
  var runtime = new Util.RuntimeOptions{};
  return assignReviewerWithOptions(request, runtime);
}

model ConfigDataSetRequest {
  jsonStr?: string(name='JsonStr'),
}

model ConfigDataSetResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleInfo?: {
      conditions?: {
        conditionBasicInfo?: [ 
        {
          checkRange?: {
            range?: {
              from?: int32(name='From'),
              to?: int32(name='To'),
            }(name='Range'),
            anchor?: {
              cid?: string(name='Cid'),
              hitTime?: int32(name='HitTime'),
              location?: string(name='Location'),
            }(name='Anchor'),
            role?: string(name='Role'),
            roleId?: int32(name='RoleId'),
          }(name='CheckRange'),
          cid?: string(name='Cid'),
          operators?: {
            operatorBasicInfo?: [ 
            {
              type?: string(name='Type'),
              oid?: string(name='Oid'),
              param?: {
                keywords?: {
                  keywords?: [ string ](name='Keywords')
                }(name='Keywords'),
                inSentence?: boolean(name='InSentence'),
              }(name='Param'),
            }
          ](name='OperatorBasicInfo')
          }(name='Operators'),
          lambda?: string(name='Lambda'),
        }
      ](name='ConditionBasicInfo')
      }(name='Conditions'),
      rules?: {
        ruleBasicInfo?: [ 
        {
          externalProperty?: int32(name='ExternalProperty'),
          lambda?: string(name='Lambda'),
          rid?: string(name='Rid'),
        }
      ](name='RuleBasicInfo')
      }(name='Rules'),
    }(name='RuleInfo'),
    channelType?: int32(name='ChannelType'),
    setId?: long(name='SetId'),
    roleConfigStatus?: int32(name='RoleConfigStatus'),
    judgeType?: int32(name='JudgeType'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ConfigDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigDataSetResponseBody(name='body'),
}

async function configDataSetWithOptions(request: ConfigDataSetRequest, runtime: Util.RuntimeOptions): ConfigDataSetResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ConfigDataSet',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configDataSet(request: ConfigDataSetRequest): ConfigDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return configDataSetWithOptions(request, runtime);
}

model CreateAsrVocabRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateAsrVocabResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateAsrVocabResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAsrVocabResponseBody(name='body'),
}

async function createAsrVocabWithOptions(request: CreateAsrVocabRequest, runtime: Util.RuntimeOptions): CreateAsrVocabResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateAsrVocab',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAsrVocab(request: CreateAsrVocabRequest): CreateAsrVocabResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAsrVocabWithOptions(request, runtime);
}

model CreateRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRuleResponseBody(name='body'),
}

async function createRuleWithOptions(request: CreateRuleRequest, runtime: Util.RuntimeOptions): CreateRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRule(request: CreateRuleRequest): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRuleWithOptions(request, runtime);
}

model CreateSkillGroupConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateSkillGroupConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateSkillGroupConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSkillGroupConfigResponseBody(name='body'),
}

async function createSkillGroupConfigWithOptions(request: CreateSkillGroupConfigRequest, runtime: Util.RuntimeOptions): CreateSkillGroupConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateSkillGroupConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSkillGroupConfig(request: CreateSkillGroupConfigRequest): CreateSkillGroupConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSkillGroupConfigWithOptions(request, runtime);
}

model CreateTaskAssignRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateTaskAssignRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateTaskAssignRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTaskAssignRuleResponseBody(name='body'),
}

async function createTaskAssignRuleWithOptions(request: CreateTaskAssignRuleRequest, runtime: Util.RuntimeOptions): CreateTaskAssignRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateTaskAssignRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTaskAssignRule(request: CreateTaskAssignRuleRequest): CreateTaskAssignRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskAssignRuleWithOptions(request, runtime);
}

model CreateUserRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateUserResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateWarningConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model CreateWarningConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model CreateWarningConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWarningConfigResponseBody(name='body'),
}

async function createWarningConfigWithOptions(request: CreateWarningConfigRequest, runtime: Util.RuntimeOptions): CreateWarningConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateWarningConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWarningConfig(request: CreateWarningConfigRequest): CreateWarningConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWarningConfigWithOptions(request, runtime);
}

model DeleteAsrVocabRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteAsrVocabResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteAsrVocabResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAsrVocabResponseBody(name='body'),
}

async function deleteAsrVocabWithOptions(request: DeleteAsrVocabRequest, runtime: Util.RuntimeOptions): DeleteAsrVocabResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAsrVocab',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAsrVocab(request: DeleteAsrVocabRequest): DeleteAsrVocabResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAsrVocabWithOptions(request, runtime);
}

model DeleteBusinessCategoryRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteBusinessCategoryResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteBusinessCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBusinessCategoryResponseBody(name='body'),
}

async function deleteBusinessCategoryWithOptions(request: DeleteBusinessCategoryRequest, runtime: Util.RuntimeOptions): DeleteBusinessCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBusinessCategory',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBusinessCategory(request: DeleteBusinessCategoryRequest): DeleteBusinessCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBusinessCategoryWithOptions(request, runtime);
}

model DeleteCustomizationConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteCustomizationConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteCustomizationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCustomizationConfigResponseBody(name='body'),
}

async function deleteCustomizationConfigWithOptions(request: DeleteCustomizationConfigRequest, runtime: Util.RuntimeOptions): DeleteCustomizationConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCustomizationConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCustomizationConfig(request: DeleteCustomizationConfigRequest): DeleteCustomizationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCustomizationConfigWithOptions(request, runtime);
}

model DeleteDataSetRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteDataSetResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataSetResponseBody(name='body'),
}

async function deleteDataSetWithOptions(request: DeleteDataSetRequest, runtime: Util.RuntimeOptions): DeleteDataSetResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSet',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataSet(request: DeleteDataSetRequest): DeleteDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSetWithOptions(request, runtime);
}

model DeletePrecisionTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeletePrecisionTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeletePrecisionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeletePrecisionTaskResponseBody(name='body'),
}

async function deletePrecisionTaskWithOptions(request: DeletePrecisionTaskRequest, runtime: Util.RuntimeOptions): DeletePrecisionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeletePrecisionTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePrecisionTask(request: DeletePrecisionTaskRequest): DeletePrecisionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePrecisionTaskWithOptions(request, runtime);
}

model DeleteScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteScoreForApiResponseBody(name='body'),
}

async function deleteScoreForApiWithOptions(request: DeleteScoreForApiRequest, runtime: Util.RuntimeOptions): DeleteScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteScoreForApi(request: DeleteScoreForApiRequest): DeleteScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteScoreForApiWithOptions(request, runtime);
}

model DeleteSkillGroupConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteSkillGroupConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteSkillGroupConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSkillGroupConfigResponseBody(name='body'),
}

async function deleteSkillGroupConfigWithOptions(request: DeleteSkillGroupConfigRequest, runtime: Util.RuntimeOptions): DeleteSkillGroupConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSkillGroupConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSkillGroupConfig(request: DeleteSkillGroupConfigRequest): DeleteSkillGroupConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSkillGroupConfigWithOptions(request, runtime);
}

model DeleteSubScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteSubScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteSubScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSubScoreForApiResponseBody(name='body'),
}

async function deleteSubScoreForApiWithOptions(request: DeleteSubScoreForApiRequest, runtime: Util.RuntimeOptions): DeleteSubScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSubScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSubScoreForApi(request: DeleteSubScoreForApiRequest): DeleteSubScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSubScoreForApiWithOptions(request, runtime);
}

model DeleteTaskAssignRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteTaskAssignRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteTaskAssignRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteTaskAssignRuleResponseBody(name='body'),
}

async function deleteTaskAssignRuleWithOptions(request: DeleteTaskAssignRuleRequest, runtime: Util.RuntimeOptions): DeleteTaskAssignRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteTaskAssignRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteTaskAssignRule(request: DeleteTaskAssignRuleRequest): DeleteTaskAssignRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteTaskAssignRuleWithOptions(request, runtime);
}

model DeleteUserRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteUserResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteWarningConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model DeleteWarningConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DeleteWarningConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWarningConfigResponseBody(name='body'),
}

async function deleteWarningConfigWithOptions(request: DeleteWarningConfigRequest, runtime: Util.RuntimeOptions): DeleteWarningConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWarningConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWarningConfig(request: DeleteWarningConfigRequest): DeleteWarningConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWarningConfigWithOptions(request, runtime);
}

model DelRuleCategoryRequest {
  jsonStr?: string(name='JsonStr'),
}

model DelRuleCategoryResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    select?: boolean(name='Select'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DelRuleCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: DelRuleCategoryResponseBody(name='body'),
}

async function delRuleCategoryWithOptions(request: DelRuleCategoryRequest, runtime: Util.RuntimeOptions): DelRuleCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DelRuleCategory',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delRuleCategory(request: DelRuleCategoryRequest): DelRuleCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return delRuleCategoryWithOptions(request, runtime);
}

model DelThesaurusForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model DelThesaurusForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model DelThesaurusForApiResponse = {
  headers: map[string]string(name='headers'),
  body: DelThesaurusForApiResponseBody(name='body'),
}

async function delThesaurusForApiWithOptions(request: DelThesaurusForApiRequest, runtime: Util.RuntimeOptions): DelThesaurusForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DelThesaurusForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function delThesaurusForApi(request: DelThesaurusForApiRequest): DelThesaurusForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return delThesaurusForApiWithOptions(request, runtime);
}

model EditThesaurusForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model EditThesaurusForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: long(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model EditThesaurusForApiResponse = {
  headers: map[string]string(name='headers'),
  body: EditThesaurusForApiResponseBody(name='body'),
}

async function editThesaurusForApiWithOptions(request: EditThesaurusForApiRequest, runtime: Util.RuntimeOptions): EditThesaurusForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'EditThesaurusForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function editThesaurusForApi(request: EditThesaurusForApiRequest): EditThesaurusForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return editThesaurusForApiWithOptions(request, runtime);
}

model GetAsrVocabRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetAsrVocabResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    words?: {
      word?: [ 
      {
        weight?: int32(name='Weight'),
        word?: string(name='Word'),
      }
    ](name='Word')
    }(name='Words'),
    name?: string(name='Name'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetAsrVocabResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsrVocabResponseBody(name='body'),
}

async function getAsrVocabWithOptions(request: GetAsrVocabRequest, runtime: Util.RuntimeOptions): GetAsrVocabResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetAsrVocab',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAsrVocab(request: GetAsrVocabRequest): GetAsrVocabResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAsrVocabWithOptions(request, runtime);
}

model GetBusinessCategoryListRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetBusinessCategoryListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    businessCategoryBasicInfo?: [ 
    {
      businessName?: string(name='BusinessName'),
      serviceType?: int32(name='ServiceType'),
      bid?: int32(name='Bid'),
    }
  ](name='BusinessCategoryBasicInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetBusinessCategoryListResponse = {
  headers: map[string]string(name='headers'),
  body: GetBusinessCategoryListResponseBody(name='body'),
}

async function getBusinessCategoryListWithOptions(request: GetBusinessCategoryListRequest, runtime: Util.RuntimeOptions): GetBusinessCategoryListResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetBusinessCategoryList',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBusinessCategoryList(request: GetBusinessCategoryListRequest): GetBusinessCategoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBusinessCategoryListWithOptions(request, runtime);
}

model GetCustomizationConfigListRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetCustomizationConfigListResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    modelCustomizationDataSetPo?: [ 
    {
      taskType?: int32(name='TaskType'),
      createTime?: string(name='CreateTime'),
      modelStatus?: int32(name='ModelStatus'),
      modelName?: string(name='ModelName'),
      modelId?: long(name='ModelId'),
      modeCustomizationId?: string(name='ModeCustomizationId'),
    }
  ](name='ModelCustomizationDataSetPo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetCustomizationConfigListResponse = {
  headers: map[string]string(name='headers'),
  body: GetCustomizationConfigListResponseBody(name='body'),
}

async function getCustomizationConfigListWithOptions(request: GetCustomizationConfigListRequest, runtime: Util.RuntimeOptions): GetCustomizationConfigListResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetCustomizationConfigList',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomizationConfigList(request: GetCustomizationConfigListRequest): GetCustomizationConfigListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomizationConfigListWithOptions(request, runtime);
}

model GetHitResultRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetHitResultResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    resultInfo?: [ 
    {
      ruleName?: string(name='RuleName'),
      rid?: long(name='Rid'),
    }
  ](name='ResultInfo')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetHitResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetHitResultResponseBody(name='body'),
}

async function getHitResultWithOptions(request: GetHitResultRequest, runtime: Util.RuntimeOptions): GetHitResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetHitResult',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHitResult(request: GetHitResultRequest): GetHitResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHitResultWithOptions(request, runtime);
}

model GetNextResultToVerifyRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetNextResultToVerifyResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    audioScheme?: string(name='AudioScheme'),
    status?: int32(name='Status'),
    index?: int32(name='Index'),
    audioURL?: string(name='AudioURL'),
    updateTime?: string(name='UpdateTime'),
    incorrectWords?: int32(name='IncorrectWords'),
    verifiedCount?: int32(name='VerifiedCount'),
    verified?: boolean(name='Verified'),
    fileName?: string(name='FileName'),
    totalCount?: int32(name='TotalCount'),
    precision?: float(name='Precision'),
    fileId?: string(name='FileId'),
    dialogues?: {
      dialogue?: [ 
      {
        deltas?: {
          delta?: [ 
          {
            type?: string(name='Type'),
            source?: {
              line?: {
                line?: [ string ](name='Line')
              }(name='Line'),
              position?: int32(name='Position'),
            }(name='Source'),
            target?: {
              line?: {
                line?: [ string ](name='Line')
              }(name='Line'),
              position?: int32(name='Position'),
            }(name='Target'),
          }
        ](name='Delta')
        }(name='Deltas'),
        words?: string(name='Words'),
        identity?: string(name='Identity'),
        incorrectWords?: int32(name='IncorrectWords'),
        beginTime?: string(name='BeginTime'),
        sourceWords?: string(name='SourceWords'),
        end?: long(name='End'),
        speechRate?: int32(name='SpeechRate'),
        sourceRole?: string(name='SourceRole'),
        hourMinSec?: string(name='HourMinSec'),
        begin?: long(name='Begin'),
        emotionValue?: int32(name='EmotionValue'),
        role?: string(name='Role'),
        silenceDuration?: int32(name='SilenceDuration'),
      }
    ](name='Dialogue')
    }(name='Dialogues'),
    duration?: int32(name='Duration'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetNextResultToVerifyResponse = {
  headers: map[string]string(name='headers'),
  body: GetNextResultToVerifyResponseBody(name='body'),
}

async function getNextResultToVerifyWithOptions(request: GetNextResultToVerifyRequest, runtime: Util.RuntimeOptions): GetNextResultToVerifyResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetNextResultToVerify',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getNextResultToVerify(request: GetNextResultToVerifyRequest): GetNextResultToVerifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getNextResultToVerifyWithOptions(request, runtime);
}

model GetPrecisionTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetPrecisionTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: int32(name='Status'),
    updateTime?: string(name='UpdateTime'),
    incorrectWords?: int32(name='IncorrectWords'),
    dataSetId?: long(name='DataSetId'),
    verifiedCount?: int32(name='VerifiedCount'),
    totalCount?: int32(name='TotalCount'),
    source?: int32(name='Source'),
    precisions?: {
      precision?: [ 
      {
        status?: int32(name='Status'),
        modelName?: string(name='ModelName'),
        taskId?: string(name='TaskId'),
        precision?: float(name='Precision'),
        modelId?: long(name='ModelId'),
      }
    ](name='Precision')
    }(name='Precisions'),
    duration?: int32(name='Duration'),
    dataSetName?: string(name='DataSetName'),
    name?: string(name='Name'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetPrecisionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetPrecisionTaskResponseBody(name='body'),
}

async function getPrecisionTaskWithOptions(request: GetPrecisionTaskRequest, runtime: Util.RuntimeOptions): GetPrecisionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetPrecisionTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPrecisionTask(request: GetPrecisionTaskRequest): GetPrecisionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPrecisionTaskWithOptions(request, runtime);
}

model GetResultRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetResultResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    resultInfo?: [ 
    {
      status?: int32(name='Status'),
      assignmentTime?: string(name='AssignmentTime'),
      lastDataId?: string(name='LastDataId'),
      errorMessage?: string(name='ErrorMessage'),
      reviewStatus?: int32(name='ReviewStatus'),
      createTime?: string(name='CreateTime'),
      reviewer?: string(name='Reviewer'),
      taskName?: string(name='TaskName'),
      reviewTimeLong?: string(name='ReviewTimeLong'),
      score?: int32(name='Score'),
      reviewResult?: int32(name='ReviewResult'),
      agent?: {
        name?: string(name='Name'),
        skillGroup?: string(name='SkillGroup'),
        id?: string(name='Id'),
      }(name='Agent'),
      createTimeLong?: string(name='CreateTimeLong'),
      asrResult?: {
        asrResult?: [ 
        {
          words?: string(name='Words'),
          begin?: long(name='Begin'),
          emotionValue?: int32(name='EmotionValue'),
          end?: long(name='End'),
          speechRate?: int32(name='SpeechRate'),
          role?: string(name='Role'),
        }
      ](name='AsrResult')
      }(name='AsrResult'),
      reviewTime?: string(name='ReviewTime'),
      hitScore?: {
        hitScore?: [ 
        {
          scoreName?: string(name='ScoreName'),
          scoreNumber?: string(name='ScoreNumber'),
          scoreId?: string(name='ScoreId'),
          ruleId?: string(name='RuleId'),
        }
      ](name='HitScore')
      }(name='HitScore'),
      comments?: string(name='Comments'),
      hitResult?: {
        hitResult?: [ 
        {
          type?: string(name='Type'),
          hits?: {
            hit?: [ 
            {
              phrase?: {
                words?: string(name='Words'),
                begin?: long(name='Begin'),
                emotionValue?: int32(name='EmotionValue'),
                end?: int32(name='End'),
                role?: string(name='Role'),
              }(name='Phrase'),
              keyWords?: {
                keyWord?: [ 
                {
                  from?: int32(name='From'),
                  val?: string(name='Val'),
                  cid?: string(name='Cid'),
                  to?: int32(name='To'),
                }
              ](name='KeyWord')
              }(name='KeyWords'),
              cid?: {
                cid?: [ string ](name='Cid')
              }(name='Cid'),
            }
          ](name='Hit')
          }(name='Hits'),
          reviewResult?: int32(name='ReviewResult'),
          name?: string(name='Name'),
          rid?: string(name='Rid'),
        }
      ](name='HitResult')
      }(name='HitResult'),
      recording?: {
        remark13?: string(name='Remark13'),
        callee?: string(name='Callee'),
        dialogueSize?: int32(name='DialogueSize'),
        primaryId?: string(name='PrimaryId'),
        remark12?: string(name='Remark12'),
        remark1?: string(name='Remark1'),
        remark7?: string(name='Remark7'),
        remark8?: string(name='Remark8'),
        remark2?: string(name='Remark2'),
        callId?: string(name='CallId'),
        remark9?: string(name='Remark9'),
        name?: string(name='Name'),
        remark6?: string(name='Remark6'),
        remark10?: string(name='Remark10'),
        remark3?: string(name='Remark3'),
        business?: string(name='Business'),
        url?: string(name='Url'),
        remark11?: string(name='Remark11'),
        remark4?: string(name='Remark4'),
        callType?: int32(name='CallType'),
        caller?: string(name='Caller'),
        duration?: long(name='Duration'),
        dataSetName?: string(name='DataSetName'),
        remark5?: long(name='Remark5'),
        id?: string(name='Id'),
        callTime?: string(name='CallTime'),
      }(name='Recording'),
      taskId?: string(name='TaskId'),
      reviewType?: int32(name='ReviewType'),
      resolver?: string(name='Resolver'),
    }
  ](name='ResultInfo')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  resultCountId?: string(name='ResultCountId'),
}

model GetResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetResultResponseBody(name='body'),
}

async function getResultWithOptions(request: GetResultRequest, runtime: Util.RuntimeOptions): GetResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetResult',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResult(request: GetResultRequest): GetResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResultWithOptions(request, runtime);
}

model GetResultCallbackRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetResultCallbackResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetResultCallbackResponse = {
  headers: map[string]string(name='headers'),
  body: GetResultCallbackResponseBody(name='body'),
}

async function getResultCallbackWithOptions(request: GetResultCallbackRequest, runtime: Util.RuntimeOptions): GetResultCallbackResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetResultCallback',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResultCallback(request: GetResultCallbackRequest): GetResultCallbackResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResultCallbackWithOptions(request, runtime);
}

model GetResultToReviewRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetResultToReviewResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    audioScheme?: string(name='AudioScheme'),
    audioURL?: string(name='AudioURL'),
    reviewHistoryList?: {
      reviewHistory?: [ 
      {
        type?: int32(name='Type'),
        operatorName?: string(name='OperatorName'),
        timeStr?: string(name='TimeStr'),
        score?: int32(name='Score'),
        reviewResult?: int32(name='ReviewResult'),
        complainResult?: int32(name='ComplainResult'),
        oldScore?: int32(name='OldScore'),
      }
    ](name='ReviewHistory')
    }(name='ReviewHistoryList'),
    hitRuleReviewInfoList?: {
      hitRuleReviewInfo?: [ 
      {
        conditionHitInfoList?: {
          conditionHitInfo?: [ 
          {
            phrase?: {
              words?: string(name='Words'),
              begin?: long(name='Begin'),
              identity?: string(name='Identity'),
              pid?: int32(name='Pid'),
              emotionValue?: int32(name='EmotionValue'),
              end?: long(name='End'),
              role?: string(name='Role'),
            }(name='Phrase'),
            keyWords?: {
              keyWord?: [ 
              {
                from?: int32(name='From'),
                val?: string(name='Val'),
                pid?: int32(name='Pid'),
                tid?: string(name='Tid'),
                cid?: string(name='Cid'),
                to?: int32(name='To'),
              }
            ](name='KeyWord')
            }(name='KeyWords'),
            cid?: {
              cid?: [ string ](name='Cid')
            }(name='Cid'),
          }
        ](name='ConditionHitInfo')
        }(name='ConditionHitInfoList'),
        scoreSubId?: long(name='ScoreSubId'),
        reviewInfo?: {
          reviewTime?: string(name='ReviewTime'),
          reviewer?: string(name='Reviewer'),
          reviewResult?: int32(name='ReviewResult'),
          hitId?: string(name='HitId'),
          rid?: long(name='Rid'),
        }(name='ReviewInfo'),
        ruleName?: string(name='RuleName'),
        rid?: long(name='Rid'),
        scoreSubName?: string(name='ScoreSubName'),
        scoreNum?: int32(name='ScoreNum'),
        autoReview?: int32(name='AutoReview'),
        complainHistories?: {
          complainHistories?: [ 
          {
            operatorName?: string(name='OperatorName'),
            comments?: string(name='Comments'),
            operator?: long(name='Operator'),
            operationTime?: string(name='OperationTime'),
            operationType?: int32(name='OperationType'),
          }
        ](name='ComplainHistories')
        }(name='ComplainHistories'),
        complainable?: boolean(name='Complainable'),
        scoreId?: long(name='ScoreId'),
      }
    ](name='HitRuleReviewInfo')
    }(name='HitRuleReviewInfoList'),
    totalScore?: int32(name='TotalScore'),
    fileId?: string(name='FileId'),
    manualScoreInfoList?: {
      manualScoreInfo?: [ 
      {
        scoreSubName?: string(name='ScoreSubName'),
        scoreNum?: int32(name='ScoreNum'),
        scoreSubId?: long(name='ScoreSubId'),
        complainHistories?: {
          complainHistories?: [ 
          {
            operatorName?: string(name='OperatorName'),
            comments?: string(name='Comments'),
            operator?: long(name='Operator'),
            operationTime?: string(name='OperationTime'),
            operationType?: int32(name='OperationType'),
          }
        ](name='ComplainHistories')
        }(name='ComplainHistories'),
        complainable?: boolean(name='Complainable'),
        scoreId?: long(name='ScoreId'),
      }
    ](name='ManualScoreInfo')
    }(name='ManualScoreInfoList'),
    fileMergeName?: string(name='FileMergeName'),
    comments?: string(name='Comments'),
    dialogues?: {
      dialogue?: [ 
      {
        words?: string(name='Words'),
        identity?: string(name='Identity'),
        begin?: long(name='Begin'),
        beginTime?: string(name='BeginTime'),
        emotionValue?: int32(name='EmotionValue'),
        end?: long(name='End'),
        speechRate?: int32(name='SpeechRate'),
        role?: string(name='Role'),
        silenceDuration?: int32(name='SilenceDuration'),
        hourMinSec?: string(name='HourMinSec'),
      }
    ](name='Dialogue')
    }(name='Dialogues'),
    vid?: string(name='Vid'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetResultToReviewResponse = {
  headers: map[string]string(name='headers'),
  body: GetResultToReviewResponseBody(name='body'),
}

async function getResultToReviewWithOptions(request: GetResultToReviewRequest, runtime: Util.RuntimeOptions): GetResultToReviewResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetResultToReview',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResultToReview(request: GetResultToReviewRequest): GetResultToReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResultToReviewWithOptions(request, runtime);
}

model GetReviewInfoRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetReviewInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    audioURL?: string(name='AudioURL'),
    hitNumber?: int32(name='HitNumber'),
    nextVid?: string(name='NextVid'),
    preVid?: string(name='PreVid'),
    isAudio?: boolean(name='IsAudio'),
    hitRuleReviewInfoList?: {
      hitRuleReviewInfo?: [ 
      {
        ruleScoreType?: int32(name='RuleScoreType'),
        conditionHitInfoList?: {
          conditionHitInfo?: [ 
          {
            phrase?: {
              words?: string(name='Words'),
              begin?: long(name='Begin'),
              identity?: string(name='Identity'),
              pid?: int32(name='Pid'),
              emotionValue?: int32(name='EmotionValue'),
              end?: long(name='End'),
              role?: string(name='Role'),
            }(name='Phrase'),
            keyWords?: {
              keyWord?: [ 
              {
                from?: int32(name='From'),
                val?: string(name='Val'),
                tid?: string(name='Tid'),
                pid?: int32(name='Pid'),
                to?: int32(name='To'),
              }
            ](name='KeyWord')
            }(name='KeyWords'),
            cid?: {
              cid?: [ string ](name='Cid')
            }(name='Cid'),
          }
        ](name='ConditionHitInfo')
        }(name='ConditionHitInfoList'),
        ruleType?: int32(name='RuleType'),
        autoReview?: int32(name='AutoReview'),
        scoreSubId?: long(name='ScoreSubId'),
        reviewInfo?: {
          hitId?: string(name='HitId'),
          rid?: long(name='Rid'),
        }(name='ReviewInfo'),
        totalNumber?: int32(name='TotalNumber'),
        scoreId?: long(name='ScoreId'),
        rid?: long(name='Rid'),
        ruleName?: string(name='RuleName'),
      }
    ](name='HitRuleReviewInfo')
    }(name='HitRuleReviewInfoList'),
    audio?: boolean(name='Audio'),
    asrWordsCount?: int32(name='AsrWordsCount'),
    totalScore?: int32(name='TotalScore'),
    businessType?: int32(name='BusinessType'),
    manualScoreMappingList?: {
      manualScoreMappingList?: [ string ](name='ManualScoreMappingList')
    }(name='ManualScoreMappingList'),
    fileMergeName?: string(name='FileMergeName'),
    isDeleted?: boolean(name='IsDeleted'),
    dialogues?: {
      dialogue?: [ 
      {
        words?: string(name='Words'),
        identity?: string(name='Identity'),
        begin?: long(name='Begin'),
        beginTime?: string(name='BeginTime'),
        emotionValue?: int32(name='EmotionValue'),
        end?: long(name='End'),
        speechRate?: int32(name='SpeechRate'),
        role?: string(name='Role'),
        silenceDuration?: int32(name='SilenceDuration'),
        hourMinSec?: string(name='HourMinSec'),
      }
    ](name='Dialogue')
    }(name='Dialogues'),
    deleted?: boolean(name='Deleted'),
    handScoreInfoList?: {
      scorePo?: [ 
      {
        scoreInfos?: {
          scoreParam?: [ 
          {
            scoreSubName?: string(name='ScoreSubName'),
            scoreNum?: int32(name='ScoreNum'),
            scoreSubId?: long(name='ScoreSubId'),
            scoreType?: int32(name='ScoreType'),
            hit?: int32(name='Hit'),
          }
        ](name='ScoreParam')
        }(name='ScoreInfos'),
        scoreName?: string(name='ScoreName'),
        scoreId?: long(name='ScoreId'),
      }
    ](name='ScorePo')
    }(name='HandScoreInfoList'),
    vid?: string(name='Vid'),
    reviewNumber?: int32(name='ReviewNumber'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetReviewInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetReviewInfoResponseBody(name='body'),
}

async function getReviewInfoWithOptions(request: GetReviewInfoRequest, runtime: Util.RuntimeOptions): GetReviewInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetReviewInfo',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getReviewInfo(request: GetReviewInfoRequest): GetReviewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getReviewInfoWithOptions(request, runtime);
}

model GetRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    rules?: {
      ruleInfo?: [ 
      {
        type?: int32(name='Type'),
        status?: int32(name='Status'),
        businessCategoryNameList?: {
          businessCategoryNameList?: [ string ](name='BusinessCategoryNameList')
        }(name='BusinessCategoryNameList'),
        isOnline?: int32(name='IsOnline'),
        scoreSubId?: int32(name='ScoreSubId'),
        createEmpid?: string(name='CreateEmpid'),
        createTime?: string(name='CreateTime'),
        lastUpdateEmpid?: string(name='LastUpdateEmpid'),
        isDelete?: int32(name='IsDelete'),
        rid?: string(name='Rid'),
        endTime?: string(name='EndTime'),
        ruleScoreType?: int32(name='RuleScoreType'),
        weight?: string(name='Weight'),
        startTime?: string(name='StartTime'),
        ruleLambda?: string(name='RuleLambda'),
        scoreSubName?: string(name='ScoreSubName'),
        autoReview?: int32(name='AutoReview'),
        comments?: string(name='Comments'),
        lastUpdateTime?: string(name='LastUpdateTime'),
        scoreName?: string(name='ScoreName'),
        name?: string(name='Name'),
        scoreId?: int32(name='ScoreId'),
      }
    ](name='RuleInfo')
    }(name='Rules'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetRuleResponse = {
  headers: map[string]string(name='headers'),
  body: GetRuleResponseBody(name='body'),
}

async function getRuleWithOptions(request: GetRuleRequest, runtime: Util.RuntimeOptions): GetRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRule(request: GetRuleRequest): GetRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleWithOptions(request, runtime);
}

model GetRuleCategoryRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetRuleCategoryResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ruleCountInfo?: [ 
    {
      type?: int32(name='Type'),
      select?: boolean(name='Select'),
      typeName?: string(name='TypeName'),
    }
  ](name='RuleCountInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetRuleCategoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetRuleCategoryResponseBody(name='body'),
}

async function getRuleCategoryWithOptions(request: GetRuleCategoryRequest, runtime: Util.RuntimeOptions): GetRuleCategoryResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRuleCategory',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRuleCategory(request: GetRuleCategoryRequest): GetRuleCategoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleCategoryWithOptions(request, runtime);
}

model GetRuleDetailRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetRuleDetailResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  data?: {
    conditions?: {
      conditionBasicInfo?: [ 
      {
        conditionInfoCid?: string(name='ConditionInfoCid'),
        operLambda?: string(name='OperLambda'),
        operators?: {
          operatorBasicInfo?: [ 
          {
            oid?: string(name='Oid'),
            type?: string(name='Type'),
            operName?: string(name='OperName'),
            param?: {
              regex?: string(name='Regex'),
              phrase?: string(name='Phrase'),
              interval?: int32(name='Interval'),
              threshold?: float(name='Threshold'),
              inSentence?: boolean(name='InSentence'),
              target?: int32(name='Target'),
              fromEnd?: boolean(name='FromEnd'),
              differentRole?: boolean(name='DifferentRole'),
              targetRole?: string(name='TargetRole'),
              score?: int32(name='Score'),
              contextChatMatch?: boolean(name='ContextChatMatch'),
              keywordMatchSize?: int32(name='KeywordMatchSize'),
              average?: boolean(name='Average'),
              velocityInMint?: int32(name='VelocityInMint'),
              minWordSize?: int32(name='MinWordSize'),
              keywordExtension?: boolean(name='KeywordExtension'),
              hitTime?: int32(name='HitTime'),
              from?: int32(name='From'),
              beginType?: string(name='BeginType'),
              compareOperator?: string(name='CompareOperator'),
              checkType?: int32(name='CheckType'),
              maxEmotionChangeValue?: int32(name='MaxEmotionChangeValue'),
              operKeyWords?: {
                operKeyWord?: [ string ](name='OperKeyWord')
              }(name='OperKeyWords'),
              references?: {
                reference?: [ string ](name='Reference')
              }(name='References'),
              similarlySentences?: {
                similarlySentence?: [ string ](name='SimilarlySentence')
              }(name='SimilarlySentences'),
              excludes?: {
                excludes?: [ string ](name='Excludes')
              }(name='Excludes'),
            }(name='Param'),
          }
        ](name='OperatorBasicInfo')
        }(name='Operators'),
        checkRange?: {
          role?: string(name='Role'),
          absolute?: boolean(name='Absolute'),
          anchor?: {
            anchorCid?: string(name='AnchorCid'),
            location?: string(name='Location'),
            hitTime?: int32(name='HitTime'),
          }(name='Anchor'),
          range?: {
            from?: int32(name='From'),
            to?: int32(name='To'),
          }(name='Range'),
        }(name='CheckRange'),
      }
    ](name='ConditionBasicInfo')
    }(name='Conditions'),
    rules?: {
      ruleBasicInfo?: [ 
      {
        rid?: string(name='Rid'),
        ruleLambda?: string(name='RuleLambda'),
        triggers?: {
          trigger?: [ string ](name='Trigger')
        }(name='Triggers'),
        businessCategories?: {
          businessCategoryBasicInfo?: [ 
          {
            bid?: int32(name='Bid'),
            serviceType?: int32(name='ServiceType'),
            businessName?: string(name='BusinessName'),
          }
        ](name='BusinessCategoryBasicInfo')
        }(name='BusinessCategories'),
      }
    ](name='RuleBasicInfo')
    }(name='Rules'),
  }(name='Data'),
}

model GetRuleDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetRuleDetailResponseBody(name='body'),
}

async function getRuleDetailWithOptions(request: GetRuleDetailRequest, runtime: Util.RuntimeOptions): GetRuleDetailResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRuleDetail',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRuleDetail(request: GetRuleDetailRequest): GetRuleDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleDetailWithOptions(request, runtime);
}

model GetRuleDimensionRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetRuleDimensionResponseBody = {
  compSubTaskCount?: int32(name='CompSubTaskCount'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  reviewStatus?: int32(name='ReviewStatus'),
  dataSize?: int32(name='DataSize'),
  data?: {
    ruleCountInfo?: [ 
    {
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      preReviewNumber?: int32(name='PreReviewNumber'),
      hitNumber?: int32(name='HitNumber'),
      select?: boolean(name='Select'),
      createEmpid?: string(name='CreateEmpid'),
      createTime?: string(name='CreateTime'),
      lastUpdateEmpid?: string(name='LastUpdateEmpid'),
      realViolationNumber?: int32(name='RealViolationNumber'),
      isDelete?: int32(name='IsDelete'),
      hitRate?: float(name='HitRate'),
      rid?: string(name='Rid'),
      checkNumber?: int32(name='CheckNumber'),
      typeName?: string(name='TypeName'),
      lastUpdateTime?: string(name='LastUpdateTime'),
      name?: string(name='Name'),
      hitRealViolationRate?: float(name='HitRealViolationRate'),
      reviewNumber?: int32(name='ReviewNumber'),
    }
  ](name='RuleCountInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  totalSubTaskCount?: int32(name='TotalSubTaskCount'),
}

model GetRuleDimensionResponse = {
  headers: map[string]string(name='headers'),
  body: GetRuleDimensionResponseBody(name='body'),
}

async function getRuleDimensionWithOptions(request: GetRuleDimensionRequest, runtime: Util.RuntimeOptions): GetRuleDimensionResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetRuleDimension',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRuleDimension(request: GetRuleDimensionRequest): GetRuleDimensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRuleDimensionWithOptions(request, runtime);
}

model GetScoreInfoRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetScoreInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    scorePo?: [ 
    {
      scoreInfos?: {
        scoreParam?: [ 
        {
          scoreSubName?: string(name='ScoreSubName'),
          scoreNum?: int32(name='ScoreNum'),
          scoreSubId?: int32(name='ScoreSubId'),
          scoreType?: int32(name='ScoreType'),
        }
      ](name='ScoreParam')
      }(name='ScoreInfos'),
      scoreName?: string(name='ScoreName'),
      scoreId?: int32(name='ScoreId'),
    }
  ](name='ScorePo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetScoreInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetScoreInfoResponseBody(name='body'),
}

async function getScoreInfoWithOptions(request: GetScoreInfoRequest, runtime: Util.RuntimeOptions): GetScoreInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetScoreInfo',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScoreInfo(request: GetScoreInfoRequest): GetScoreInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScoreInfoWithOptions(request, runtime);
}

model GetSkillGroupConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetSkillGroupConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    status?: int32(name='Status'),
    type?: int32(name='Type'),
    allRuleList?: {
      ruleNameInfo?: [ 
      {
        ruleName?: string(name='RuleName'),
        rid?: long(name='Rid'),
      }
    ](name='RuleNameInfo')
    }(name='AllRuleList'),
    updateTime?: string(name='UpdateTime'),
    allContentQualityCheck?: int32(name='AllContentQualityCheck'),
    createTime?: string(name='CreateTime'),
    skillGroupId?: string(name='SkillGroupId'),
    instanceId?: string(name='InstanceId'),
    vocabId?: long(name='VocabId'),
    skillGroupFrom?: int32(name='SkillGroupFrom'),
    rid?: string(name='Rid'),
    skillGroupName?: string(name='SkillGroupName'),
    ruleList?: {
      ruleNameInfo?: [ 
      {
        ruleName?: string(name='RuleName'),
        rid?: long(name='Rid'),
      }
    ](name='RuleNameInfo')
    }(name='RuleList'),
    modelName?: string(name='ModelName'),
    allRids?: string(name='AllRids'),
    name?: string(name='Name'),
    modelId?: long(name='ModelId'),
    id?: long(name='Id'),
    qualityCheckType?: int32(name='QualityCheckType'),
    vocabName?: string(name='VocabName'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetSkillGroupConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetSkillGroupConfigResponseBody(name='body'),
}

async function getSkillGroupConfigWithOptions(request: GetSkillGroupConfigRequest, runtime: Util.RuntimeOptions): GetSkillGroupConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetSkillGroupConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSkillGroupConfig(request: GetSkillGroupConfigRequest): GetSkillGroupConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSkillGroupConfigWithOptions(request, runtime);
}

model GetSyncResultRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetSyncResultResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      status?: int32(name='Status'),
      errorMessage?: string(name='ErrorMessage'),
      reviewer?: string(name='Reviewer'),
      createTime?: string(name='CreateTime'),
      reviewStatus?: int32(name='ReviewStatus'),
      taskName?: string(name='TaskName'),
      reviewResult?: int32(name='ReviewResult'),
      score?: int32(name='Score'),
      agent?: {
        name?: string(name='Name'),
        skillGroup?: string(name='SkillGroup'),
        id?: string(name='Id'),
      }(name='Agent'),
      asrResult?: [ 
        {
          words?: string(name='Words'),
          begin?: long(name='Begin'),
          emotionValue?: int32(name='EmotionValue'),
          end?: long(name='End'),
          speechRate?: int32(name='SpeechRate'),
          role?: string(name='Role'),
          silenceDuration?: int32(name='SilenceDuration'),
        }
      ](name='AsrResult'),
      hitResult?: [ 
        {
          type?: string(name='Type'),
          hits?: [ 
            {
              phrase?: {
                words?: string(name='Words'),
                begin?: long(name='Begin'),
                emotionValue?: int32(name='EmotionValue'),
                end?: int32(name='End'),
                speechRate?: int32(name='SpeechRate'),
                role?: string(name='Role'),
                silenceDuration?: int32(name='SilenceDuration'),
              }(name='Phrase'),
              keyWords?: [ 
                {
                  from?: int32(name='From'),
                  val?: string(name='Val'),
                  cid?: string(name='Cid'),
                  to?: int32(name='To'),
                }
              ](name='KeyWords'),
              cid?: [ string ](name='Cid'),
            }
          ](name='Hits'),
          reviewResult?: int32(name='ReviewResult'),
          name?: string(name='Name'),
          rid?: string(name='Rid'),
        }
      ](name='HitResult'),
      comments?: string(name='Comments'),
      recording?: {
        callee?: string(name='Callee'),
        business?: string(name='Business'),
        remark3?: string(name='Remark3'),
        url?: string(name='Url'),
        primaryId?: string(name='PrimaryId'),
        remark1?: string(name='Remark1'),
        callType?: int32(name='CallType'),
        remark2?: string(name='Remark2'),
        caller?: string(name='Caller'),
        callId?: string(name='CallId'),
        duration?: long(name='Duration'),
        dataSetName?: string(name='DataSetName'),
        name?: string(name='Name'),
        id?: string(name='Id'),
        callTime?: string(name='CallTime'),
      }(name='Recording'),
      taskId?: string(name='TaskId'),
      resolver?: string(name='Resolver'),
    }
  ](name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  resultCountId?: string(name='ResultCountId'),
}

model GetSyncResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetSyncResultResponseBody(name='body'),
}

async function getSyncResultWithOptions(request: GetSyncResultRequest, runtime: Util.RuntimeOptions): GetSyncResultResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetSyncResult',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSyncResult(request: GetSyncResultRequest): GetSyncResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSyncResultWithOptions(request, runtime);
}

model GetTaskFileResultListRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetTaskFileResultListResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  dataSize?: int32(name='DataSize'),
  data?: {
    taskResultReviewInfo?: [ 
    {
      status?: int32(name='Status'),
      hitNumber?: int32(name='HitNumber'),
      dataType?: int32(name='DataType'),
      nextVid?: string(name='NextVid'),
      hitRule?: boolean(name='HitRule'),
      preVid?: string(name='PreVid'),
      isHitRule?: boolean(name='IsHitRule'),
      realViolationNumber?: int32(name='RealViolationNumber'),
      reviewAccuracyRate?: float(name='ReviewAccuracyRate'),
      fileName?: string(name='FileName'),
      totalScore?: int32(name='TotalScore'),
      checkNumber?: int32(name='CheckNumber'),
      fileMergeName?: string(name='FileMergeName'),
      bucketName?: string(name='BucketName'),
      handTaskFile?: boolean(name='HandTaskFile'),
      hitRuleSet?: {
        hitRuleSet?: [ string ](name='HitRuleSet')
      }(name='HitRuleSet'),
      taskId?: string(name='TaskId'),
      vid?: string(name='Vid'),
    }
  ](name='TaskResultReviewInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetTaskFileResultListResponse = {
  headers: map[string]string(name='headers'),
  body: GetTaskFileResultListResponseBody(name='body'),
}

async function getTaskFileResultListWithOptions(request: GetTaskFileResultListRequest, runtime: Util.RuntimeOptions): GetTaskFileResultListResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskFileResultList',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskFileResultList(request: GetTaskFileResultListRequest): GetTaskFileResultListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskFileResultListWithOptions(request, runtime);
}

model GetTaskRuleListRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetTaskRuleListResponseBody = {
  compSubTaskCount?: int32(name='CompSubTaskCount'),
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  reviewStatus?: int32(name='ReviewStatus'),
  dataSize?: int32(name='DataSize'),
  data?: {
    ruleCountInfo?: [ 
    {
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      preReviewNumber?: int32(name='PreReviewNumber'),
      hitNumber?: int32(name='HitNumber'),
      select?: boolean(name='Select'),
      createEmpid?: string(name='CreateEmpid'),
      createTime?: long(name='CreateTime'),
      lastUpdateEmpid?: string(name='LastUpdateEmpid'),
      realViolationNumber?: int32(name='RealViolationNumber'),
      isDelete?: int32(name='IsDelete'),
      hitRate?: float(name='HitRate'),
      rid?: string(name='Rid'),
      checkNumber?: int32(name='CheckNumber'),
      typeName?: string(name='TypeName'),
      lastUpdateTime?: long(name='LastUpdateTime'),
      name?: string(name='Name'),
      hitRealViolationRate?: float(name='HitRealViolationRate'),
      reviewNumber?: int32(name='ReviewNumber'),
    }
  ](name='RuleCountInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
  totalSubTaskCount?: int32(name='TotalSubTaskCount'),
}

model GetTaskRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: GetTaskRuleListResponseBody(name='body'),
}

async function getTaskRuleListWithOptions(request: GetTaskRuleListRequest, runtime: Util.RuntimeOptions): GetTaskRuleListResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskRuleList',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTaskRuleList(request: GetTaskRuleListRequest): GetTaskRuleListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskRuleListWithOptions(request, runtime);
}

model GetThesaurusBySynonymForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model GetThesaurusBySynonymForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    thesaurusPo?: [ 
    {
      business?: string(name='Business'),
      synonymList?: {
        synonymList?: [ string ](name='SynonymList')
      }(name='SynonymList'),
      id?: long(name='Id'),
    }
  ](name='ThesaurusPo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetThesaurusBySynonymForApiResponse = {
  headers: map[string]string(name='headers'),
  body: GetThesaurusBySynonymForApiResponseBody(name='body'),
}

async function getThesaurusBySynonymForApiWithOptions(request: GetThesaurusBySynonymForApiRequest, runtime: Util.RuntimeOptions): GetThesaurusBySynonymForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'GetThesaurusBySynonymForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getThesaurusBySynonymForApi(request: GetThesaurusBySynonymForApiRequest): GetThesaurusBySynonymForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return getThesaurusBySynonymForApiWithOptions(request, runtime);
}

model HandleComplaintRequest {
  jsonStr?: string(name='JsonStr'),
}

model HandleComplaintResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model HandleComplaintResponse = {
  headers: map[string]string(name='headers'),
  body: HandleComplaintResponseBody(name='body'),
}

async function handleComplaintWithOptions(request: HandleComplaintRequest, runtime: Util.RuntimeOptions): HandleComplaintResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'HandleComplaint',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function handleComplaint(request: HandleComplaintRequest): HandleComplaintResponse {
  var runtime = new Util.RuntimeOptions{};
  return handleComplaintWithOptions(request, runtime);
}

model InsertScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model InsertScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    scoreName?: string(name='ScoreName'),
    scoreId?: long(name='ScoreId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model InsertScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: InsertScoreForApiResponseBody(name='body'),
}

async function insertScoreForApiWithOptions(request: InsertScoreForApiRequest, runtime: Util.RuntimeOptions): InsertScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'InsertScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertScoreForApi(request: InsertScoreForApiRequest): InsertScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertScoreForApiWithOptions(request, runtime);
}

model InsertSubScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model InsertSubScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    scoreSubName?: string(name='ScoreSubName'),
    scoreSubId?: long(name='ScoreSubId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model InsertSubScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: InsertSubScoreForApiResponseBody(name='body'),
}

async function insertSubScoreForApiWithOptions(request: InsertSubScoreForApiRequest, runtime: Util.RuntimeOptions): InsertSubScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'InsertSubScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function insertSubScoreForApi(request: InsertSubScoreForApiRequest): InsertSubScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return insertSubScoreForApiWithOptions(request, runtime);
}

model InvalidRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model InvalidRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: boolean(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model InvalidRuleResponse = {
  headers: map[string]string(name='headers'),
  body: InvalidRuleResponseBody(name='body'),
}

async function invalidRuleWithOptions(request: InvalidRuleRequest, runtime: Util.RuntimeOptions): InvalidRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'InvalidRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invalidRule(request: InvalidRuleRequest): InvalidRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return invalidRuleWithOptions(request, runtime);
}

model ListAsrVocabRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListAsrVocabResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    asrVocab?: [ 
    {
      vocabularyId?: string(name='VocabularyId'),
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      id?: string(name='Id'),
    }
  ](name='AsrVocab')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListAsrVocabResponse = {
  headers: map[string]string(name='headers'),
  body: ListAsrVocabResponseBody(name='body'),
}

async function listAsrVocabWithOptions(request: ListAsrVocabRequest, runtime: Util.RuntimeOptions): ListAsrVocabResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListAsrVocab',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAsrVocab(request: ListAsrVocabRequest): ListAsrVocabResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAsrVocabWithOptions(request, runtime);
}

model ListDataSetTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListDataSetTaskResponseBody = {
  totalCount?: int32(name='TotalCount'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  currentPage?: int32(name='CurrentPage'),
  dataSize?: int32(name='DataSize'),
  data?: {
    pageTaskInfo?: [ 
    {
      status?: int32(name='Status'),
      isTaskComplete?: boolean(name='IsTaskComplete'),
      ruleNameInfoList?: {
        ruleNameInfo?: [ 
        {
          ruleName?: string(name='RuleName'),
          rid?: int32(name='Rid'),
        }
      ](name='RuleNameInfo')
      }(name='RuleNameInfoList'),
      scheduleRatio?: float(name='ScheduleRatio'),
      taskComplete?: boolean(name='TaskComplete'),
      dataSets?: {
        dataSets?: [ string ](name='dataSets')
      }(name='DataSets'),
      dataSetSize?: int32(name='DataSetSize'),
      ruleSize?: int32(name='RuleSize'),
      jobName?: string(name='JobName'),
      taskId?: string(name='TaskId'),
    }
  ](name='PageTaskInfo')
  }(name='Data'),
  isAllcomplete?: int32(name='IsAllcomplete'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListDataSetTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSetTaskResponseBody(name='body'),
}

async function listDataSetTaskWithOptions(request: ListDataSetTaskRequest, runtime: Util.RuntimeOptions): ListDataSetTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListDataSetTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDataSetTask(request: ListDataSetTaskRequest): ListDataSetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDataSetTaskWithOptions(request, runtime);
}

model ListHotWordsTasksRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListHotWordsTasksResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    hotWordsTaskPo?: [ 
    {
      type?: int32(name='Type'),
      status?: int32(name='Status'),
      taskConfigId?: long(name='TaskConfigId'),
      message?: string(name='Message'),
      lastExecutionTime?: string(name='LastExecutionTime'),
      timeUnit?: int32(name='TimeUnit'),
      wordsParam?: {
        excludes?: string(name='Excludes'),
        includes?: string(name='Includes'),
        extraConfigId?: long(name='ExtraConfigId'),
      }(name='WordsParam'),
      endTime?: string(name='EndTime'),
      timeInterval?: int32(name='TimeInterval'),
      startTime?: string(name='StartTime'),
      instanceStatus?: int32(name='InstanceStatus'),
      name?: string(name='Name'),
      dialogueParam?: {
        endTime?: string(name='EndTime'),
        dialogueId?: long(name='DialogueId'),
        endIndex?: int32(name='EndIndex'),
        startTime?: string(name='StartTime'),
        sourceType?: int32(name='SourceType'),
        startIndex?: int32(name='StartIndex'),
        role?: int32(name='Role'),
        dataSetIds?: string(name='DataSetIds'),
      }(name='DialogueParam'),
    }
  ](name='HotWordsTaskPo')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListHotWordsTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListHotWordsTasksResponseBody(name='body'),
}

async function listHotWordsTasksWithOptions(request: ListHotWordsTasksRequest, runtime: Util.RuntimeOptions): ListHotWordsTasksResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListHotWordsTasks',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHotWordsTasks(request: ListHotWordsTasksRequest): ListHotWordsTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHotWordsTasksWithOptions(request, runtime);
}

model ListPrecisionTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListPrecisionTaskResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    precisionTask?: [ 
    {
      status?: int32(name='Status'),
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      incorrectWords?: int32(name='IncorrectWords'),
      dataSetId?: long(name='DataSetId'),
      verifiedCount?: int32(name='VerifiedCount'),
      totalCount?: int32(name='TotalCount'),
      source?: int32(name='Source'),
      precisions?: {
        precision?: [ 
        {
          status?: int32(name='Status'),
          createTime?: string(name='CreateTime'),
          modelName?: string(name='ModelName'),
          taskId?: string(name='TaskId'),
          modelId?: long(name='ModelId'),
          precision?: float(name='Precision'),
        }
      ](name='Precision')
      }(name='Precisions'),
      duration?: int32(name='Duration'),
      dataSetName?: string(name='DataSetName'),
      name?: string(name='Name'),
      taskId?: string(name='TaskId'),
    }
  ](name='PrecisionTask')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListPrecisionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListPrecisionTaskResponseBody(name='body'),
}

async function listPrecisionTaskWithOptions(request: ListPrecisionTaskRequest, runtime: Util.RuntimeOptions): ListPrecisionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListPrecisionTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrecisionTask(request: ListPrecisionTaskRequest): ListPrecisionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPrecisionTaskWithOptions(request, runtime);
}

model ListRolesRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListRolesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    role?: [ 
    {
      displayName?: string(name='DisplayName'),
      updateTime?: string(name='UpdateTime'),
      createTime?: string(name='CreateTime'),
      name?: string(name='Name'),
      id?: long(name='Id'),
      level?: int32(name='Level'),
    }
  ](name='Role')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRolesResponseBody(name='body'),
}

async function listRolesWithOptions(request: ListRolesRequest, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRolesWithOptions(request, runtime);
}

model ListRulesRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListRulesResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: [ 
    {
      type?: int32(name='Type'),
      ruleType?: int32(name='RuleType'),
      businessCategoryNameList?: [ string ](name='BusinessCategoryNameList'),
      createTime?: string(name='CreateTime'),
      comments?: string(name='Comments'),
      typeName?: string(name='TypeName'),
      name?: string(name='Name'),
      rid?: long(name='Rid'),
    }
  ](name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRulesResponseBody(name='body'),
}

async function listRulesWithOptions(request: ListRulesRequest, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRules(request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRulesWithOptions(request, runtime);
}

model ListSkillGroupConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListSkillGroupConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    skillGroupConfig?: [ 
    {
      status?: int32(name='Status'),
      type?: int32(name='Type'),
      allRuleList?: {
        ruleNameInfo?: [ 
        {
          ruleName?: string(name='RuleName'),
          rid?: long(name='Rid'),
        }
      ](name='RuleNameInfo')
      }(name='AllRuleList'),
      updateTime?: string(name='UpdateTime'),
      allContentQualityCheck?: int32(name='AllContentQualityCheck'),
      createTime?: string(name='CreateTime'),
      skillGroupId?: string(name='SkillGroupId'),
      screenSwitch?: boolean(name='ScreenSwitch'),
      instanceId?: string(name='InstanceId'),
      vocabId?: long(name='VocabId'),
      skillGroupFrom?: int32(name='SkillGroupFrom'),
      rid?: string(name='Rid'),
      skillGroupName?: string(name='SkillGroupName'),
      ruleList?: {
        ruleNameInfo?: [ 
        {
          ruleName?: string(name='RuleName'),
          rid?: long(name='Rid'),
        }
      ](name='RuleNameInfo')
      }(name='RuleList'),
      modelName?: string(name='ModelName'),
      allRids?: string(name='AllRids'),
      name?: string(name='Name'),
      modelId?: long(name='ModelId'),
      id?: long(name='Id'),
      skillGroupScreens?: {
        skillGroupScreen?: [ 
        {
          value?: string(name='Value'),
          dataType?: int32(name='DataType'),
          symbol?: int32(name='Symbol'),
          name?: string(name='Name'),
        }
      ](name='SkillGroupScreen')
      }(name='SkillGroupScreens'),
      qualityCheckType?: int32(name='QualityCheckType'),
      vocabName?: string(name='VocabName'),
    }
  ](name='SkillGroupConfig')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListSkillGroupConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListSkillGroupConfigResponseBody(name='body'),
}

async function listSkillGroupConfigWithOptions(request: ListSkillGroupConfigRequest, runtime: Util.RuntimeOptions): ListSkillGroupConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListSkillGroupConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSkillGroupConfig(request: ListSkillGroupConfigRequest): ListSkillGroupConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSkillGroupConfigWithOptions(request, runtime);
}

model ListTaskAssignRulesRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListTaskAssignRulesResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    taskAssignRuleInfo?: [ 
    {
      skillGroupsStr?: string(name='SkillGroupsStr'),
      updateTime?: string(name='UpdateTime'),
      durationMax?: int32(name='DurationMax'),
      createTime?: string(name='CreateTime'),
      priority?: int32(name='Priority'),
      agentsStr?: string(name='AgentsStr'),
      durationMin?: int32(name='DurationMin'),
      rules?: {
        ruleBasicInfo?: [ 
        {
          name?: string(name='Name'),
          rid?: string(name='Rid'),
        }
      ](name='RuleBasicInfo')
      }(name='Rules'),
      ruleId?: long(name='RuleId'),
      skillGroups?: {
        skillGroup?: [ 
        {
          skillId?: string(name='SkillId'),
          skillName?: string(name='SkillName'),
        }
      ](name='SkillGroup')
      }(name='SkillGroups'),
      agents?: {
        agent?: [ 
        {
          agentId?: string(name='AgentId'),
          agentName?: string(name='AgentName'),
        }
      ](name='Agent')
      }(name='Agents'),
      callType?: int32(name='CallType'),
      enabled?: int32(name='Enabled'),
      reviewers?: {
        reviewer?: [ 
        {
          reviewerName?: string(name='ReviewerName'),
          reviewerId?: string(name='ReviewerId'),
        }
      ](name='Reviewer')
      }(name='Reviewers'),
    }
  ](name='TaskAssignRuleInfo')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListTaskAssignRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTaskAssignRulesResponseBody(name='body'),
}

async function listTaskAssignRulesWithOptions(request: ListTaskAssignRulesRequest, runtime: Util.RuntimeOptions): ListTaskAssignRulesResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListTaskAssignRules',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTaskAssignRules(request: ListTaskAssignRulesRequest): ListTaskAssignRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTaskAssignRulesWithOptions(request, runtime);
}

model ListUsersRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
  data?: {
    user?: [ 
    {
      displayName?: string(name='DisplayName'),
      updateTime?: string(name='UpdateTime'),
      description?: string(name='Description'),
      createTime?: string(name='CreateTime'),
      loginUserType?: int32(name='LoginUserType'),
      aliUid?: string(name='AliUid'),
      roleName?: string(name='RoleName'),
      userName?: string(name='UserName'),
      id?: long(name='Id'),
    }
  ](name='User')
  }(name='Data'),
  count?: int32(name='Count'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ListWarningConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model ListWarningConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    warningConfigInfo?: [ 
    {
      status?: int32(name='Status'),
      configName?: string(name='ConfigName'),
      updateTime?: string(name='UpdateTime'),
      configId?: long(name='ConfigId'),
      ridList?: {
        ridList?: [ string ](name='RidList')
      }(name='RidList'),
      createTime?: string(name='CreateTime'),
      channels?: {
        channel?: [ 
        {
          type?: int32(name='Type'),
          url?: string(name='Url'),
        }
      ](name='Channel')
      }(name='Channels'),
      ruleList?: {
        warningRule?: [ 
        {
          ruleName?: string(name='RuleName'),
          rid?: long(name='Rid'),
        }
      ](name='WarningRule')
      }(name='RuleList'),
    }
  ](name='WarningConfigInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListWarningConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListWarningConfigResponseBody(name='body'),
}

async function listWarningConfigWithOptions(request: ListWarningConfigRequest, runtime: Util.RuntimeOptions): ListWarningConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListWarningConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWarningConfig(request: ListWarningConfigRequest): ListWarningConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWarningConfigWithOptions(request, runtime);
}

model RemoveAndGetTaskRulesRequest {
  jsonStr?: string(name='JsonStr'),
}

model RemoveAndGetTaskRulesResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model RemoveAndGetTaskRulesResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveAndGetTaskRulesResponseBody(name='body'),
}

async function removeAndGetTaskRulesWithOptions(request: RemoveAndGetTaskRulesRequest, runtime: Util.RuntimeOptions): RemoveAndGetTaskRulesResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAndGetTaskRules',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeAndGetTaskRules(request: RemoveAndGetTaskRulesRequest): RemoveAndGetTaskRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeAndGetTaskRulesWithOptions(request, runtime);
}

model RestartAsrTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model RestartAsrTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    restartResult?: [ 
    {
      data?: string(name='Data'),
      success?: boolean(name='Success'),
      message?: string(name='Message'),
    }
  ](name='RestartResult')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model RestartAsrTaskResponse = {
  headers: map[string]string(name='headers'),
  body: RestartAsrTaskResponseBody(name='body'),
}

async function restartAsrTaskWithOptions(request: RestartAsrTaskRequest, runtime: Util.RuntimeOptions): RestartAsrTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RestartAsrTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartAsrTask(request: RestartAsrTaskRequest): RestartAsrTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartAsrTaskWithOptions(request, runtime);
}

model ReviewSingleResultByIdRequest {
  jsonStr?: string(name='JsonStr'),
}

model ReviewSingleResultByIdResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    audioURL?: string(name='AudioURL'),
    hitNumber?: int32(name='HitNumber'),
    nextVid?: string(name='NextVid'),
    preVid?: string(name='PreVid'),
    isAudio?: boolean(name='IsAudio'),
    hitRuleReviewInfoList?: {
      hitRuleReviewInfo?: [ 
      {
        ruleScoreType?: int32(name='RuleScoreType'),
        conditionHitInfoList?: {
          conditionHitInfo?: [ 
          {
            phrase?: {
              words?: string(name='Words'),
              begin?: long(name='Begin'),
              identity?: string(name='Identity'),
              pid?: int32(name='Pid'),
              emotionValue?: int32(name='EmotionValue'),
              end?: long(name='End'),
              role?: string(name='Role'),
            }(name='Phrase'),
            keyWords?: {
              keyWord?: [ 
              {
                from?: int32(name='From'),
                val?: string(name='Val'),
                tid?: string(name='Tid'),
                pid?: int32(name='Pid'),
                to?: int32(name='To'),
              }
            ](name='KeyWord')
            }(name='KeyWords'),
            cid?: {
              cid?: [ string ](name='Cid')
            }(name='Cid'),
          }
        ](name='ConditionHitInfo')
        }(name='ConditionHitInfoList'),
        ruleType?: int32(name='RuleType'),
        autoReview?: int32(name='AutoReview'),
        scoreSubId?: long(name='ScoreSubId'),
        comments?: string(name='Comments'),
        reviewInfo?: {
          hitId?: string(name='HitId'),
          rid?: long(name='Rid'),
        }(name='ReviewInfo'),
        totalNumber?: int32(name='TotalNumber'),
        scoreId?: long(name='ScoreId'),
        ruleName?: string(name='RuleName'),
        rid?: long(name='Rid'),
      }
    ](name='HitRuleReviewInfo')
    }(name='HitRuleReviewInfoList'),
    audio?: boolean(name='Audio'),
    asrWordsCount?: int32(name='AsrWordsCount'),
    totalScore?: int32(name='TotalScore'),
    businessType?: int32(name='BusinessType'),
    manualScoreMappingList?: {
      manualScoreMappingList?: [ string ](name='ManualScoreMappingList')
    }(name='ManualScoreMappingList'),
    fileMergeName?: string(name='FileMergeName'),
    isDeleted?: boolean(name='IsDeleted'),
    dialogues?: {
      dialogue?: [ 
      {
        words?: string(name='Words'),
        identity?: string(name='Identity'),
        begin?: long(name='Begin'),
        beginTime?: long(name='BeginTime'),
        emotionValue?: int32(name='EmotionValue'),
        end?: long(name='End'),
        speechRate?: int32(name='SpeechRate'),
        role?: string(name='Role'),
        silenceDuration?: int32(name='SilenceDuration'),
        hourMinSec?: string(name='HourMinSec'),
      }
    ](name='Dialogue')
    }(name='Dialogues'),
    deleted?: boolean(name='Deleted'),
    handScoreInfoList?: {
      scorePo?: [ 
      {
        scoreInfos?: {
          scoreParam?: [ 
          {
            scoreSubName?: string(name='ScoreSubName'),
            scoreNum?: int32(name='ScoreNum'),
            scoreSubId?: long(name='ScoreSubId'),
            scoreType?: int32(name='ScoreType'),
            hit?: int32(name='Hit'),
          }
        ](name='ScoreParam')
        }(name='ScoreInfos'),
        scoreName?: string(name='ScoreName'),
        scoreId?: long(name='ScoreId'),
      }
    ](name='ScorePo')
    }(name='HandScoreInfoList'),
    vid?: int32(name='Vid'),
    reviewNumber?: int32(name='ReviewNumber'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ReviewSingleResultByIdResponse = {
  headers: map[string]string(name='headers'),
  body: ReviewSingleResultByIdResponseBody(name='body'),
}

async function reviewSingleResultByIdWithOptions(request: ReviewSingleResultByIdRequest, runtime: Util.RuntimeOptions): ReviewSingleResultByIdResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ReviewSingleResultById',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function reviewSingleResultById(request: ReviewSingleResultByIdRequest): ReviewSingleResultByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return reviewSingleResultByIdWithOptions(request, runtime);
}

model SaveConfigDataSetRequest {
  jsonStr?: string(name='JsonStr'),
}

model SaveConfigDataSetResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SaveConfigDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: SaveConfigDataSetResponseBody(name='body'),
}

async function saveConfigDataSetWithOptions(request: SaveConfigDataSetRequest, runtime: Util.RuntimeOptions): SaveConfigDataSetResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SaveConfigDataSet',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveConfigDataSet(request: SaveConfigDataSetRequest): SaveConfigDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveConfigDataSetWithOptions(request, runtime);
}

model SubmitComplaintRequest {
  jsonStr?: string(name='JsonStr'),
}

model SubmitComplaintResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SubmitComplaintResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitComplaintResponseBody(name='body'),
}

async function submitComplaintWithOptions(request: SubmitComplaintRequest, runtime: Util.RuntimeOptions): SubmitComplaintResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitComplaint',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitComplaint(request: SubmitComplaintRequest): SubmitComplaintResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitComplaintWithOptions(request, runtime);
}

model SubmitCustomizationConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model SubmitCustomizationConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    modelStatus?: int32(name='ModelStatus'),
    modelName?: string(name='ModelName'),
    modelId?: long(name='ModelId'),
    modeCustomizationId?: string(name='ModeCustomizationId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SubmitCustomizationConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitCustomizationConfigResponseBody(name='body'),
}

async function submitCustomizationConfigWithOptions(request: SubmitCustomizationConfigRequest, runtime: Util.RuntimeOptions): SubmitCustomizationConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitCustomizationConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitCustomizationConfig(request: SubmitCustomizationConfigRequest): SubmitCustomizationConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitCustomizationConfigWithOptions(request, runtime);
}

model SubmitPrecisionTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model SubmitPrecisionTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SubmitPrecisionTaskResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitPrecisionTaskResponseBody(name='body'),
}

async function submitPrecisionTaskWithOptions(request: SubmitPrecisionTaskRequest, runtime: Util.RuntimeOptions): SubmitPrecisionTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitPrecisionTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitPrecisionTask(request: SubmitPrecisionTaskRequest): SubmitPrecisionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitPrecisionTaskWithOptions(request, runtime);
}

model SubmitQualityCheckTaskRequest {
  jsonStr?: string(name='JsonStr'),
}

model SubmitQualityCheckTaskResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SubmitQualityCheckTaskResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitQualityCheckTaskResponseBody(name='body'),
}

async function submitQualityCheckTaskWithOptions(request: SubmitQualityCheckTaskRequest, runtime: Util.RuntimeOptions): SubmitQualityCheckTaskResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitQualityCheckTask',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitQualityCheckTask(request: SubmitQualityCheckTaskRequest): SubmitQualityCheckTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitQualityCheckTaskWithOptions(request, runtime);
}

model SubmitReviewInfoRequest {
  jsonStr?: string(name='JsonStr'),
}

model SubmitReviewInfoResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SubmitReviewInfoResponse = {
  headers: map[string]string(name='headers'),
  body: SubmitReviewInfoResponseBody(name='body'),
}

async function submitReviewInfoWithOptions(request: SubmitReviewInfoRequest, runtime: Util.RuntimeOptions): SubmitReviewInfoResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SubmitReviewInfo',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function submitReviewInfo(request: SubmitReviewInfoRequest): SubmitReviewInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return submitReviewInfoWithOptions(request, runtime);
}

model SyncQualityCheckRequest {
  jsonStr?: string(name='JsonStr'),
}

model SyncQualityCheckResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    tid?: string(name='Tid'),
    beginTime?: long(name='BeginTime'),
    score?: int32(name='Score'),
    taskId?: string(name='TaskId'),
    rules?: [ 
      {
        hit?: [ 
          {
            phrase?: {
              words?: string(name='Words'),
              identity?: string(name='Identity'),
              begin?: long(name='Begin'),
              emotionValue?: int32(name='EmotionValue'),
              end?: long(name='End'),
              speechRate?: int32(name='SpeechRate'),
              role?: string(name='Role'),
              silenceDuration?: int32(name='SilenceDuration'),
            }(name='Phrase'),
            hitKeyWords?: [ 
              {
                from?: int32(name='From'),
                val?: string(name='Val'),
                cid?: int32(name='Cid'),
                pid?: int32(name='Pid'),
                to?: int32(name='To'),
              }
            ](name='HitKeyWords'),
          }
        ](name='Hit'),
        ruleName?: string(name='RuleName'),
        rid?: string(name='Rid'),
      }
    ](name='Rules'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model SyncQualityCheckResponse = {
  headers: map[string]string(name='headers'),
  body: SyncQualityCheckResponseBody(name='body'),
}

async function syncQualityCheckWithOptions(request: SyncQualityCheckRequest, runtime: Util.RuntimeOptions): SyncQualityCheckResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'SyncQualityCheck',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncQualityCheck(request: SyncQualityCheckRequest): SyncQualityCheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncQualityCheckWithOptions(request, runtime);
}

model TestRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model TestRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    hitRuleReviewInfoList?: {
      hitRuleReviewInfo?: [ 
      {
        conditionHitInfoList?: {
          conditionHitInfo?: [ 
          {
            phrase?: {
              words?: string(name='Words'),
              begin?: long(name='Begin'),
              identity?: string(name='Identity'),
              pid?: int32(name='Pid'),
              emotionValue?: int32(name='EmotionValue'),
              end?: long(name='End'),
              role?: string(name='Role'),
            }(name='Phrase'),
            keyWords?: {
              keyWord?: [ 
              {
                from?: int32(name='From'),
                val?: string(name='Val'),
                tid?: string(name='Tid'),
                pid?: int32(name='Pid'),
                to?: int32(name='To'),
              }
            ](name='KeyWord')
            }(name='KeyWords'),
            cid?: {
              cid?: [ string ](name='cid')
            }(name='Cid'),
          }
        ](name='ConditionHitInfo')
        }(name='ConditionHitInfoList'),
        rid?: long(name='Rid'),
      }
    ](name='HitRuleReviewInfo')
    }(name='HitRuleReviewInfoList'),
    poc?: boolean(name='Poc'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model TestRuleResponse = {
  headers: map[string]string(name='headers'),
  body: TestRuleResponseBody(name='body'),
}

async function testRuleWithOptions(request: TestRuleRequest, runtime: Util.RuntimeOptions): TestRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'TestRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function testRule(request: TestRuleRequest): TestRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return testRuleWithOptions(request, runtime);
}

model UpdateAsrVocabRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateAsrVocabResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateAsrVocabResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAsrVocabResponseBody(name='body'),
}

async function updateAsrVocabWithOptions(request: UpdateAsrVocabRequest, runtime: Util.RuntimeOptions): UpdateAsrVocabResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAsrVocab',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAsrVocab(request: UpdateAsrVocabRequest): UpdateAsrVocabResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAsrVocabWithOptions(request, runtime);
}

model UpdateOnPurchaseSuccessRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateOnPurchaseSuccessResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateOnPurchaseSuccessResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateOnPurchaseSuccessResponseBody(name='body'),
}

async function updateOnPurchaseSuccessWithOptions(request: UpdateOnPurchaseSuccessRequest, runtime: Util.RuntimeOptions): UpdateOnPurchaseSuccessResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOnPurchaseSuccess',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOnPurchaseSuccess(request: UpdateOnPurchaseSuccessRequest): UpdateOnPurchaseSuccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOnPurchaseSuccessWithOptions(request, runtime);
}

model UpdateRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRuleResponseBody(name='body'),
}

async function updateRuleWithOptions(request: UpdateRuleRequest, runtime: Util.RuntimeOptions): UpdateRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRule(request: UpdateRuleRequest): UpdateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateRuleWithOptions(request, runtime);
}

model UpdateScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateScoreForApiResponseBody(name='body'),
}

async function updateScoreForApiWithOptions(request: UpdateScoreForApiRequest, runtime: Util.RuntimeOptions): UpdateScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateScoreForApi(request: UpdateScoreForApiRequest): UpdateScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateScoreForApiWithOptions(request, runtime);
}

model UpdateSkillGroupConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateSkillGroupConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateSkillGroupConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSkillGroupConfigResponseBody(name='body'),
}

async function updateSkillGroupConfigWithOptions(request: UpdateSkillGroupConfigRequest, runtime: Util.RuntimeOptions): UpdateSkillGroupConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSkillGroupConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSkillGroupConfig(request: UpdateSkillGroupConfigRequest): UpdateSkillGroupConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSkillGroupConfigWithOptions(request, runtime);
}

model UpdateSubScoreForApiRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateSubScoreForApiResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateSubScoreForApiResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSubScoreForApiResponseBody(name='body'),
}

async function updateSubScoreForApiWithOptions(request: UpdateSubScoreForApiRequest, runtime: Util.RuntimeOptions): UpdateSubScoreForApiResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSubScoreForApi',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSubScoreForApi(request: UpdateSubScoreForApiRequest): UpdateSubScoreForApiResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSubScoreForApiWithOptions(request, runtime);
}

model UpdateSyncQualityCheckDataRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateSyncQualityCheckDataResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    tid?: string(name='Tid'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateSyncQualityCheckDataResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSyncQualityCheckDataResponseBody(name='body'),
}

async function updateSyncQualityCheckDataWithOptions(request: UpdateSyncQualityCheckDataRequest, runtime: Util.RuntimeOptions): UpdateSyncQualityCheckDataResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSyncQualityCheckData',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSyncQualityCheckData(request: UpdateSyncQualityCheckDataRequest): UpdateSyncQualityCheckDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSyncQualityCheckDataWithOptions(request, runtime);
}

model UpdateTaskAssignRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateTaskAssignRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateTaskAssignRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateTaskAssignRuleResponseBody(name='body'),
}

async function updateTaskAssignRuleWithOptions(request: UpdateTaskAssignRuleRequest, runtime: Util.RuntimeOptions): UpdateTaskAssignRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateTaskAssignRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateTaskAssignRule(request: UpdateTaskAssignRuleRequest): UpdateTaskAssignRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateTaskAssignRuleWithOptions(request, runtime);
}

model UpdateUserRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateUserResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateUserConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateUserConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateUserConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserConfigResponseBody(name='body'),
}

async function updateUserConfigWithOptions(request: UpdateUserConfigRequest, runtime: Util.RuntimeOptions): UpdateUserConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserConfig(request: UpdateUserConfigRequest): UpdateUserConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserConfigWithOptions(request, runtime);
}

model UpdateWarningConfigRequest {
  jsonStr?: string(name='JsonStr'),
}

model UpdateWarningConfigResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UpdateWarningConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWarningConfigResponseBody(name='body'),
}

async function updateWarningConfigWithOptions(request: UpdateWarningConfigRequest, runtime: Util.RuntimeOptions): UpdateWarningConfigResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWarningConfig',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWarningConfig(request: UpdateWarningConfigRequest): UpdateWarningConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWarningConfigWithOptions(request, runtime);
}

model UploadAudioDataRequest {
  jsonStr?: string(name='JsonStr'),
}

model UploadAudioDataResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UploadAudioDataResponse = {
  headers: map[string]string(name='headers'),
  body: UploadAudioDataResponseBody(name='body'),
}

async function uploadAudioDataWithOptions(request: UploadAudioDataRequest, runtime: Util.RuntimeOptions): UploadAudioDataResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UploadAudioData',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadAudioData(request: UploadAudioDataRequest): UploadAudioDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadAudioDataWithOptions(request, runtime);
}

model UploadDataRequest {
  jsonStr?: string(name='JsonStr'),
}

model UploadDataResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UploadDataResponse = {
  headers: map[string]string(name='headers'),
  body: UploadDataResponseBody(name='body'),
}

async function uploadDataWithOptions(request: UploadDataRequest, runtime: Util.RuntimeOptions): UploadDataResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UploadData',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadData(request: UploadDataRequest): UploadDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadDataWithOptions(request, runtime);
}

model UploadDataSyncRequest {
  jsonStr?: string(name='JsonStr'),
}

model UploadDataSyncResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    resultInfo?: [ 
    {
      score?: int32(name='Score'),
      rules?: {
        ruleHitInfo?: [ 
        {
          tid?: string(name='Tid'),
          hit?: {
            conditionHitInfo?: [ 
            {
              phrase?: {
                words?: string(name='Words'),
                identity?: string(name='Identity'),
                begin?: long(name='Begin'),
                beginTime?: string(name='BeginTime'),
                end?: long(name='End'),
                role?: string(name='Role'),
              }(name='Phrase'),
              hitCids?: {
                cidItem?: [ string ](name='CidItem')
              }(name='HitCids'),
              hitKeyWords?: {
                hitKeyWord?: [ 
                {
                  from?: int32(name='From'),
                  val?: string(name='Val'),
                  tid?: string(name='Tid'),
                  pid?: int32(name='Pid'),
                  to?: int32(name='To'),
                }
              ](name='HitKeyWord')
              }(name='HitKeyWords'),
            }
          ](name='ConditionHitInfo')
          }(name='Hit'),
          conditionInfo?: {
            conditionBasicInfo?: [ 
            {
              conditionInfoCid?: string(name='ConditionInfoCid'),
            }
          ](name='ConditionBasicInfo')
          }(name='ConditionInfo'),
          rid?: string(name='Rid'),
        }
      ](name='RuleHitInfo')
      }(name='Rules'),
      handScoreIdList?: {
        handScoreIdList?: [ string ](name='HandScoreIdList')
      }(name='HandScoreIdList'),
    }
  ](name='ResultInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UploadDataSyncResponse = {
  headers: map[string]string(name='headers'),
  body: UploadDataSyncResponseBody(name='body'),
}

async function uploadDataSyncWithOptions(request: UploadDataSyncRequest, runtime: Util.RuntimeOptions): UploadDataSyncResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UploadDataSync',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadDataSync(request: UploadDataSyncRequest): UploadDataSyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadDataSyncWithOptions(request, runtime);
}

model UploadRuleRequest {
  jsonStr?: string(name='JsonStr'),
}

model UploadRuleResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    ridInfo?: [ string ](name='RidInfo')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model UploadRuleResponse = {
  headers: map[string]string(name='headers'),
  body: UploadRuleResponseBody(name='body'),
}

async function uploadRuleWithOptions(request: UploadRuleRequest, runtime: Util.RuntimeOptions): UploadRuleResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UploadRule',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadRule(request: UploadRuleRequest): UploadRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadRuleWithOptions(request, runtime);
}

model VerifyFileRequest {
  jsonStr?: string(name='JsonStr'),
}

model VerifyFileResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: float(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model VerifyFileResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyFileResponseBody(name='body'),
}

async function verifyFileWithOptions(request: VerifyFileRequest, runtime: Util.RuntimeOptions): VerifyFileResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'VerifyFile',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyFile(request: VerifyFileRequest): VerifyFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyFileWithOptions(request, runtime);
}

model VerifySentenceRequest {
  jsonStr?: string(name='JsonStr'),
}

model VerifySentenceResponseBody = {
  sourceRole?: int32(name='SourceRole'),
  incorrectWords?: int32(name='IncorrectWords'),
  requestId?: string(name='RequestId'),
  message?: string(name='Message'),
  targetRole?: int32(name='TargetRole'),
  data?: {
    delta?: [ 
    {
      type?: string(name='Type'),
      source?: {
        line?: {
          line?: [ string ](name='Line')
        }(name='Line'),
        position?: int32(name='Position'),
      }(name='Source'),
      target?: {
        line?: {
          line?: [ string ](name='Line')
        }(name='Line'),
        position?: int32(name='Position'),
      }(name='Target'),
    }
  ](name='Delta')
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model VerifySentenceResponse = {
  headers: map[string]string(name='headers'),
  body: VerifySentenceResponseBody(name='body'),
}

async function verifySentenceWithOptions(request: VerifySentenceRequest, runtime: Util.RuntimeOptions): VerifySentenceResponse {
  Util.validateModel(request);
  var query = {};
  query["JsonStr"] = request.jsonStr;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'VerifySentence',
    version = '2019-01-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifySentence(request: VerifySentenceRequest): VerifySentenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifySentenceWithOptions(request, runtime);
}

