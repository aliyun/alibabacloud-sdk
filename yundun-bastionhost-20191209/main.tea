/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('yundun-bastionhost', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddHostsToGroupRequest {
  hostGroupId?: string(name='HostGroupId'),
  hostIds?: string(name='HostIds'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model AddHostsToGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostGroupId?: string(name='HostGroupId'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model AddHostsToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddHostsToGroupResponseBody(name='body'),
}

async function addHostsToGroupWithOptions(request: AddHostsToGroupRequest, runtime: Util.RuntimeOptions): AddHostsToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.hostIds)) {
    query['HostIds'] = request.hostIds;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddHostsToGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addHostsToGroup(request: AddHostsToGroupRequest): AddHostsToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addHostsToGroupWithOptions(request, runtime);
}

model AddUsersToGroupRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
  userIds?: string(name='UserIds'),
}

model AddUsersToGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model AddUsersToGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AddUsersToGroupResponseBody(name='body'),
}

async function addUsersToGroupWithOptions(request: AddUsersToGroupRequest, runtime: Util.RuntimeOptions): AddUsersToGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddUsersToGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addUsersToGroup(request: AddUsersToGroupRequest): AddUsersToGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return addUsersToGroupWithOptions(request, runtime);
}

model AttachHostAccountsToHostShareKeyRequest {
  hostAccountIds?: string(name='HostAccountIds'),
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model AttachHostAccountsToHostShareKeyResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountId?: string(name='HostAccountId'),
      hostShareKeyId?: string(name='HostShareKeyId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model AttachHostAccountsToHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: AttachHostAccountsToHostShareKeyResponseBody(name='body'),
}

async function attachHostAccountsToHostShareKeyWithOptions(request: AttachHostAccountsToHostShareKeyRequest, runtime: Util.RuntimeOptions): AttachHostAccountsToHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountIds)) {
    query['HostAccountIds'] = request.hostAccountIds;
  }
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachHostAccountsToHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachHostAccountsToHostShareKey(request: AttachHostAccountsToHostShareKeyRequest): AttachHostAccountsToHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachHostAccountsToHostShareKeyWithOptions(request, runtime);
}

model AttachHostAccountsToUserRequest {
  hosts?: string(name='Hosts'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model AttachHostAccountsToUserResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccounts?: [ 
        {
          code?: string(name='Code'),
          hostAccountId?: string(name='HostAccountId'),
          message?: string(name='Message'),
        }
      ](name='HostAccounts'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model AttachHostAccountsToUserResponse = {
  headers: map[string]string(name='headers'),
  body: AttachHostAccountsToUserResponseBody(name='body'),
}

async function attachHostAccountsToUserWithOptions(request: AttachHostAccountsToUserRequest, runtime: Util.RuntimeOptions): AttachHostAccountsToUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hosts)) {
    query['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachHostAccountsToUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachHostAccountsToUser(request: AttachHostAccountsToUserRequest): AttachHostAccountsToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachHostAccountsToUserWithOptions(request, runtime);
}

model AttachHostAccountsToUserGroupRequest {
  hosts?: string(name='Hosts'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model AttachHostAccountsToUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccounts?: [ 
        {
          code?: string(name='Code'),
          hostAccountId?: string(name='HostAccountId'),
          message?: string(name='Message'),
        }
      ](name='HostAccounts'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Results'),
}

model AttachHostAccountsToUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AttachHostAccountsToUserGroupResponseBody(name='body'),
}

async function attachHostAccountsToUserGroupWithOptions(request: AttachHostAccountsToUserGroupRequest, runtime: Util.RuntimeOptions): AttachHostAccountsToUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hosts)) {
    query['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachHostAccountsToUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachHostAccountsToUserGroup(request: AttachHostAccountsToUserGroupRequest): AttachHostAccountsToUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachHostAccountsToUserGroupWithOptions(request, runtime);
}

model AttachHostGroupAccountsToUserRequest {
  hostGroups?: string(name='HostGroups'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model AttachHostGroupAccountsToUserResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountNames?: [ 
        {
          code?: string(name='Code'),
          hostAccountName?: string(name='HostAccountName'),
          message?: string(name='Message'),
        }
      ](name='HostAccountNames'),
      hostGroupId?: string(name='HostGroupId'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model AttachHostGroupAccountsToUserResponse = {
  headers: map[string]string(name='headers'),
  body: AttachHostGroupAccountsToUserResponseBody(name='body'),
}

async function attachHostGroupAccountsToUserWithOptions(request: AttachHostGroupAccountsToUserRequest, runtime: Util.RuntimeOptions): AttachHostGroupAccountsToUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroups)) {
    query['HostGroups'] = request.hostGroups;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachHostGroupAccountsToUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachHostGroupAccountsToUser(request: AttachHostGroupAccountsToUserRequest): AttachHostGroupAccountsToUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachHostGroupAccountsToUserWithOptions(request, runtime);
}

model AttachHostGroupAccountsToUserGroupRequest {
  hostGroups?: string(name='HostGroups'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model AttachHostGroupAccountsToUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountNames?: [ 
        {
          code?: string(name='Code'),
          hostAccountName?: string(name='HostAccountName'),
          message?: string(name='Message'),
        }
      ](name='HostAccountNames'),
      hostGroupId?: string(name='HostGroupId'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Results'),
}

model AttachHostGroupAccountsToUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: AttachHostGroupAccountsToUserGroupResponseBody(name='body'),
}

async function attachHostGroupAccountsToUserGroupWithOptions(request: AttachHostGroupAccountsToUserGroupRequest, runtime: Util.RuntimeOptions): AttachHostGroupAccountsToUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroups)) {
    query['HostGroups'] = request.hostGroups;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AttachHostGroupAccountsToUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachHostGroupAccountsToUserGroup(request: AttachHostGroupAccountsToUserGroupRequest): AttachHostGroupAccountsToUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachHostGroupAccountsToUserGroupWithOptions(request, runtime);
}

model ConfigInstanceSecurityGroupsRequest {
  authorizedSecurityGroups?: [ string ](name='AuthorizedSecurityGroups'),
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  regionId?: string(name='RegionId'),
}

model ConfigInstanceSecurityGroupsResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model ConfigInstanceSecurityGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigInstanceSecurityGroupsResponseBody(name='body'),
}

async function configInstanceSecurityGroupsWithOptions(request: ConfigInstanceSecurityGroupsRequest, runtime: Util.RuntimeOptions): ConfigInstanceSecurityGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.authorizedSecurityGroups)) {
    query['AuthorizedSecurityGroups'] = request.authorizedSecurityGroups;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigInstanceSecurityGroups',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configInstanceSecurityGroups(request: ConfigInstanceSecurityGroupsRequest): ConfigInstanceSecurityGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return configInstanceSecurityGroupsWithOptions(request, runtime);
}

model ConfigInstanceWhiteListRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  whiteList?: [ string ](name='WhiteList'),
}

model ConfigInstanceWhiteListResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model ConfigInstanceWhiteListResponse = {
  headers: map[string]string(name='headers'),
  body: ConfigInstanceWhiteListResponseBody(name='body'),
}

async function configInstanceWhiteListWithOptions(request: ConfigInstanceWhiteListRequest, runtime: Util.RuntimeOptions): ConfigInstanceWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.whiteList)) {
    query['WhiteList'] = request.whiteList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigInstanceWhiteList',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function configInstanceWhiteList(request: ConfigInstanceWhiteListRequest): ConfigInstanceWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return configInstanceWhiteListWithOptions(request, runtime);
}

model CreateHostRequest {
  activeAddressType?: string(name='ActiveAddressType'),
  comment?: string(name='Comment'),
  hostName?: string(name='HostName'),
  hostPrivateAddress?: string(name='HostPrivateAddress'),
  hostPublicAddress?: string(name='HostPublicAddress'),
  instanceId?: string(name='InstanceId'),
  instanceRegionId?: string(name='InstanceRegionId'),
  OSType?: string(name='OSType'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  sourceInstanceId?: string(name='SourceInstanceId'),
}

model CreateHostResponseBody = {
  hostId?: string(name='HostId'),
  requestId?: string(name='RequestId'),
}

model CreateHostResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHostResponseBody(name='body'),
}

async function createHostWithOptions(request: CreateHostRequest, runtime: Util.RuntimeOptions): CreateHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activeAddressType)) {
    query['ActiveAddressType'] = request.activeAddressType;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.hostPrivateAddress)) {
    query['HostPrivateAddress'] = request.hostPrivateAddress;
  }
  if (!Util.isUnset(request.hostPublicAddress)) {
    query['HostPublicAddress'] = request.hostPublicAddress;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceRegionId)) {
    query['InstanceRegionId'] = request.instanceRegionId;
  }
  if (!Util.isUnset(request.OSType)) {
    query['OSType'] = request.OSType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHost',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHost(request: CreateHostRequest): CreateHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostWithOptions(request, runtime);
}

model CreateHostAccountRequest {
  hostAccountName?: string(name='HostAccountName'),
  hostId?: string(name='HostId'),
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  passPhrase?: string(name='PassPhrase'),
  password?: string(name='Password'),
  privateKey?: string(name='PrivateKey'),
  protocolName?: string(name='ProtocolName'),
  regionId?: string(name='RegionId'),
}

model CreateHostAccountResponseBody = {
  hostAccountId?: string(name='HostAccountId'),
  requestId?: string(name='RequestId'),
}

model CreateHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHostAccountResponseBody(name='body'),
}

async function createHostAccountWithOptions(request: CreateHostAccountRequest, runtime: Util.RuntimeOptions): CreateHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountName)) {
    query['HostAccountName'] = request.hostAccountName;
  }
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.passPhrase)) {
    query['PassPhrase'] = request.passPhrase;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.protocolName)) {
    query['ProtocolName'] = request.protocolName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHostAccount',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHostAccount(request: CreateHostAccountRequest): CreateHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostAccountWithOptions(request, runtime);
}

model CreateHostGroupRequest {
  comment?: string(name='Comment'),
  hostGroupName?: string(name='HostGroupName'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model CreateHostGroupResponseBody = {
  hostGroupId?: string(name='HostGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHostGroupResponseBody(name='body'),
}

async function createHostGroupWithOptions(request: CreateHostGroupRequest, runtime: Util.RuntimeOptions): CreateHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.hostGroupName)) {
    query['HostGroupName'] = request.hostGroupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHostGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHostGroup(request: CreateHostGroupRequest): CreateHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostGroupWithOptions(request, runtime);
}

model CreateHostShareKeyRequest {
  hostShareKeyName?: string(name='HostShareKeyName'),
  instanceId?: string(name='InstanceId'),
  passPhrase?: string(name='PassPhrase'),
  privateKey?: string(name='PrivateKey'),
  regionId?: string(name='RegionId'),
}

model CreateHostShareKeyResponseBody = {
  hostShareKeyId?: long(name='HostShareKeyId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateHostShareKeyResponseBody(name='body'),
}

async function createHostShareKeyWithOptions(request: CreateHostShareKeyRequest, runtime: Util.RuntimeOptions): CreateHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostShareKeyName)) {
    query['HostShareKeyName'] = request.hostShareKeyName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.passPhrase)) {
    query['PassPhrase'] = request.passPhrase;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHostShareKey(request: CreateHostShareKeyRequest): CreateHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHostShareKeyWithOptions(request, runtime);
}

model CreateUserRequest {
  comment?: string(name='Comment'),
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  instanceId?: string(name='InstanceId'),
  mobile?: string(name='Mobile'),
  mobileCountryCode?: string(name='MobileCountryCode'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  sourceUserId?: string(name='SourceUserId'),
  userName?: string(name='UserName'),
}

model CreateUserResponseBody = {
  requestId?: string(name='RequestId'),
  userId?: string(name='UserId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.mobileCountryCode)) {
    query['MobileCountryCode'] = request.mobileCountryCode;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceUserId)) {
    query['SourceUserId'] = request.sourceUserId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateUserGroupRequest {
  comment?: string(name='Comment'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupName?: string(name='UserGroupName'),
}

model CreateUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  userGroupId?: string(name='UserGroupId'),
}

model CreateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateUserGroupResponseBody(name='body'),
}

async function createUserGroupWithOptions(request: CreateUserGroupRequest, runtime: Util.RuntimeOptions): CreateUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    query['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserGroup(request: CreateUserGroupRequest): CreateUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserGroupWithOptions(request, runtime);
}

model DeleteHostRequest {
  hostId?: string(name='HostId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHostResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHostResponseBody(name='body'),
}

async function deleteHostWithOptions(request: DeleteHostRequest, runtime: Util.RuntimeOptions): DeleteHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHost',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHost(request: DeleteHostRequest): DeleteHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostWithOptions(request, runtime);
}

model DeleteHostAccountRequest {
  hostAccountId?: string(name='HostAccountId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHostAccountResponseBody(name='body'),
}

async function deleteHostAccountWithOptions(request: DeleteHostAccountRequest, runtime: Util.RuntimeOptions): DeleteHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountId)) {
    query['HostAccountId'] = request.hostAccountId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHostAccount',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHostAccount(request: DeleteHostAccountRequest): DeleteHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostAccountWithOptions(request, runtime);
}

model DeleteHostGroupRequest {
  hostGroupId?: string(name='HostGroupId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHostGroupResponseBody(name='body'),
}

async function deleteHostGroupWithOptions(request: DeleteHostGroupRequest, runtime: Util.RuntimeOptions): DeleteHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHostGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHostGroup(request: DeleteHostGroupRequest): DeleteHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostGroupWithOptions(request, runtime);
}

model DeleteHostShareKeyRequest {
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DeleteHostShareKeyResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteHostShareKeyResponseBody(name='body'),
}

async function deleteHostShareKeyWithOptions(request: DeleteHostShareKeyRequest, runtime: Util.RuntimeOptions): DeleteHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHostShareKey(request: DeleteHostShareKeyRequest): DeleteHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHostShareKeyWithOptions(request, runtime);
}

model DeleteUserRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model DeleteUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteUserGroupRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model DeleteUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserGroupResponseBody(name='body'),
}

async function deleteUserGroupWithOptions(request: DeleteUserGroupRequest, runtime: Util.RuntimeOptions): DeleteUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroup(request: DeleteUserGroupRequest): DeleteUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupWithOptions(request, runtime);
}

model DescribeInstanceAttributeRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DescribeInstanceAttributeResponseBody = {
  instanceAttribute?: {
    authorizedSecurityGroups?: [ string ](name='AuthorizedSecurityGroups'),
    description?: string(name='Description'),
    eniInstanceId?: string(name='EniInstanceId'),
    expireTime?: long(name='ExpireTime'),
    instanceId?: string(name='InstanceId'),
    instanceStatus?: string(name='InstanceStatus'),
    internetEndpoint?: string(name='InternetEndpoint'),
    intranetEndpoint?: string(name='IntranetEndpoint'),
    licenseCode?: string(name='LicenseCode'),
    modifyPasswordModule?: string(name='ModifyPasswordModule'),
    networkProxyModule?: string(name='NetworkProxyModule'),
    ports?: [ 
      {
        customPort?: int32(name='CustomPort'),
        standardPort?: int32(name='StandardPort'),
      }
    ](name='Ports'),
    privateExportIps?: [ string ](name='PrivateExportIps'),
    privateWhiteList?: [ string ](name='PrivateWhiteList'),
    publicExportIps?: [ string ](name='PublicExportIps'),
    publicIps?: [ string ](name='PublicIps'),
    publicNetworkAccess?: boolean(name='PublicNetworkAccess'),
    publicWhiteList?: [ string ](name='PublicWhiteList'),
    regionId?: string(name='RegionId'),
    resourceGroupId?: string(name='ResourceGroupId'),
    securityGroupIds?: [ string ](name='SecurityGroupIds'),
    startTime?: long(name='StartTime'),
    storage?: long(name='Storage'),
    vpcId?: string(name='VpcId'),
    vswitchId?: string(name='VswitchId'),
    webTerminalModule?: string(name='WebTerminalModule'),
  }(name='InstanceAttribute'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAttributeResponseBody(name='body'),
}

async function describeInstanceAttributeWithOptions(request: DescribeInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAttribute',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceAttribute(request: DescribeInstanceAttributeRequest): DescribeInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAttributeWithOptions(request, runtime);
}

model DescribeInstancesRequest {
  instanceId?: [ string ](name='InstanceId'),
  instanceStatus?: string(name='InstanceStatus'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeInstancesResponseBody = {
  instances?: [ 
    {
      description?: string(name='Description'),
      expireTime?: long(name='ExpireTime'),
      imageVersion?: string(name='ImageVersion'),
      instanceId?: string(name='InstanceId'),
      instanceStatus?: string(name='InstanceStatus'),
      internetEndpoint?: string(name='InternetEndpoint'),
      intranetEndpoint?: string(name='IntranetEndpoint'),
      legacy?: boolean(name='Legacy'),
      licenseCode?: string(name='LicenseCode'),
      planCode?: string(name='PlanCode'),
      publicNetworkAccess?: boolean(name='PublicNetworkAccess'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      startTime?: long(name='StartTime'),
      vpcId?: string(name='VpcId'),
      vswitchId?: string(name='VswitchId'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model DescribeInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstancesResponseBody(name='body'),
}

async function describeInstancesWithOptions(request: DescribeInstancesRequest, runtime: Util.RuntimeOptions): DescribeInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceStatus)) {
    query['InstanceStatus'] = request.instanceStatus;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstances',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstances(request: DescribeInstancesRequest): DescribeInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstancesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DetachHostAccountsFromHostShareKeyRequest {
  hostAccountIds?: string(name='HostAccountIds'),
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DetachHostAccountsFromHostShareKeyResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountId?: string(name='HostAccountId'),
      hostShareKeyId?: string(name='HostShareKeyId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model DetachHostAccountsFromHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DetachHostAccountsFromHostShareKeyResponseBody(name='body'),
}

async function detachHostAccountsFromHostShareKeyWithOptions(request: DetachHostAccountsFromHostShareKeyRequest, runtime: Util.RuntimeOptions): DetachHostAccountsFromHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountIds)) {
    query['HostAccountIds'] = request.hostAccountIds;
  }
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachHostAccountsFromHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachHostAccountsFromHostShareKey(request: DetachHostAccountsFromHostShareKeyRequest): DetachHostAccountsFromHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachHostAccountsFromHostShareKeyWithOptions(request, runtime);
}

model DetachHostAccountsFromUserRequest {
  hosts?: string(name='Hosts'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model DetachHostAccountsFromUserResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccounts?: [ 
        {
          code?: string(name='Code'),
          hostAccountId?: string(name='HostAccountId'),
          message?: string(name='Message'),
        }
      ](name='HostAccounts'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model DetachHostAccountsFromUserResponse = {
  headers: map[string]string(name='headers'),
  body: DetachHostAccountsFromUserResponseBody(name='body'),
}

async function detachHostAccountsFromUserWithOptions(request: DetachHostAccountsFromUserRequest, runtime: Util.RuntimeOptions): DetachHostAccountsFromUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hosts)) {
    query['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachHostAccountsFromUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachHostAccountsFromUser(request: DetachHostAccountsFromUserRequest): DetachHostAccountsFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachHostAccountsFromUserWithOptions(request, runtime);
}

model DetachHostAccountsFromUserGroupRequest {
  hosts?: string(name='Hosts'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model DetachHostAccountsFromUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccounts?: [ 
        {
          code?: string(name='Code'),
          hostAccountId?: string(name='HostAccountId'),
          message?: string(name='Message'),
        }
      ](name='HostAccounts'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Results'),
}

model DetachHostAccountsFromUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DetachHostAccountsFromUserGroupResponseBody(name='body'),
}

async function detachHostAccountsFromUserGroupWithOptions(request: DetachHostAccountsFromUserGroupRequest, runtime: Util.RuntimeOptions): DetachHostAccountsFromUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hosts)) {
    query['Hosts'] = request.hosts;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachHostAccountsFromUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachHostAccountsFromUserGroup(request: DetachHostAccountsFromUserGroupRequest): DetachHostAccountsFromUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachHostAccountsFromUserGroupWithOptions(request, runtime);
}

model DetachHostGroupAccountsFromUserRequest {
  hostGroups?: string(name='HostGroups'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model DetachHostGroupAccountsFromUserResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountNames?: [ 
        {
          code?: string(name='Code'),
          hostAccountName?: string(name='HostAccountName'),
          message?: string(name='Message'),
        }
      ](name='HostAccountNames'),
      hostGroupId?: string(name='HostGroupId'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model DetachHostGroupAccountsFromUserResponse = {
  headers: map[string]string(name='headers'),
  body: DetachHostGroupAccountsFromUserResponseBody(name='body'),
}

async function detachHostGroupAccountsFromUserWithOptions(request: DetachHostGroupAccountsFromUserRequest, runtime: Util.RuntimeOptions): DetachHostGroupAccountsFromUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroups)) {
    query['HostGroups'] = request.hostGroups;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachHostGroupAccountsFromUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachHostGroupAccountsFromUser(request: DetachHostGroupAccountsFromUserRequest): DetachHostGroupAccountsFromUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachHostGroupAccountsFromUserWithOptions(request, runtime);
}

model DetachHostGroupAccountsFromUserGroupRequest {
  hostGroups?: string(name='HostGroups'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model DetachHostGroupAccountsFromUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostAccountNames?: [ 
        {
          code?: string(name='Code'),
          hostAccountName?: string(name='HostAccountName'),
          message?: string(name='Message'),
        }
      ](name='HostAccountNames'),
      hostGroupId?: string(name='HostGroupId'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Results'),
}

model DetachHostGroupAccountsFromUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DetachHostGroupAccountsFromUserGroupResponseBody(name='body'),
}

async function detachHostGroupAccountsFromUserGroupWithOptions(request: DetachHostGroupAccountsFromUserGroupRequest, runtime: Util.RuntimeOptions): DetachHostGroupAccountsFromUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroups)) {
    query['HostGroups'] = request.hostGroups;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachHostGroupAccountsFromUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachHostGroupAccountsFromUserGroup(request: DetachHostGroupAccountsFromUserGroupRequest): DetachHostGroupAccountsFromUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachHostGroupAccountsFromUserGroupWithOptions(request, runtime);
}

model DisableInstancePublicAccessRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model DisableInstancePublicAccessResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model DisableInstancePublicAccessResponse = {
  headers: map[string]string(name='headers'),
  body: DisableInstancePublicAccessResponseBody(name='body'),
}

async function disableInstancePublicAccessWithOptions(request: DisableInstancePublicAccessRequest, runtime: Util.RuntimeOptions): DisableInstancePublicAccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableInstancePublicAccess',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableInstancePublicAccess(request: DisableInstancePublicAccessRequest): DisableInstancePublicAccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableInstancePublicAccessWithOptions(request, runtime);
}

model EnableInstancePublicAccessRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model EnableInstancePublicAccessResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model EnableInstancePublicAccessResponse = {
  headers: map[string]string(name='headers'),
  body: EnableInstancePublicAccessResponseBody(name='body'),
}

async function enableInstancePublicAccessWithOptions(request: EnableInstancePublicAccessRequest, runtime: Util.RuntimeOptions): EnableInstancePublicAccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableInstancePublicAccess',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableInstancePublicAccess(request: EnableInstancePublicAccessRequest): EnableInstancePublicAccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableInstancePublicAccessWithOptions(request, runtime);
}

model GetHostRequest {
  hostId?: string(name='HostId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetHostResponseBody = {
  host?: {
    activeAddressType?: string(name='ActiveAddressType'),
    comment?: string(name='Comment'),
    hostId?: string(name='HostId'),
    hostName?: string(name='HostName'),
    hostPrivateAddress?: string(name='HostPrivateAddress'),
    hostPublicAddress?: string(name='HostPublicAddress'),
    OSType?: string(name='OSType'),
    protocols?: [ 
      {
        hostFingerPrint?: string(name='HostFingerPrint'),
        port?: int32(name='Port'),
        protocolName?: string(name='ProtocolName'),
      }
    ](name='Protocols'),
    source?: string(name='Source'),
    sourceInstanceId?: string(name='SourceInstanceId'),
    sourceInstanceState?: string(name='SourceInstanceState'),
  }(name='Host'),
  requestId?: string(name='RequestId'),
}

model GetHostResponse = {
  headers: map[string]string(name='headers'),
  body: GetHostResponseBody(name='body'),
}

async function getHostWithOptions(request: GetHostRequest, runtime: Util.RuntimeOptions): GetHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHost',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHost(request: GetHostRequest): GetHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHostWithOptions(request, runtime);
}

model GetHostAccountRequest {
  hostAccountId?: string(name='HostAccountId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetHostAccountResponseBody = {
  hostAccount?: {
    hasPassword?: boolean(name='HasPassword'),
    hostAccountId?: string(name='HostAccountId'),
    hostAccountName?: string(name='HostAccountName'),
    hostId?: string(name='HostId'),
    hostShareKeyId?: string(name='HostShareKeyId'),
    hostShareKeyName?: string(name='HostShareKeyName'),
    privateKeyFingerprint?: string(name='PrivateKeyFingerprint'),
    protocolName?: string(name='ProtocolName'),
  }(name='HostAccount'),
  requestId?: string(name='RequestId'),
}

model GetHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: GetHostAccountResponseBody(name='body'),
}

async function getHostAccountWithOptions(request: GetHostAccountRequest, runtime: Util.RuntimeOptions): GetHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountId)) {
    query['HostAccountId'] = request.hostAccountId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHostAccount',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHostAccount(request: GetHostAccountRequest): GetHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHostAccountWithOptions(request, runtime);
}

model GetHostGroupRequest {
  hostGroupId?: string(name='HostGroupId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetHostGroupResponseBody = {
  hostGroup?: {
    comment?: string(name='Comment'),
    hostGroupId?: string(name='HostGroupId'),
    hostGroupName?: string(name='HostGroupName'),
  }(name='HostGroup'),
  requestId?: string(name='RequestId'),
}

model GetHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetHostGroupResponseBody(name='body'),
}

async function getHostGroupWithOptions(request: GetHostGroupRequest, runtime: Util.RuntimeOptions): GetHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHostGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHostGroup(request: GetHostGroupRequest): GetHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHostGroupWithOptions(request, runtime);
}

model GetHostShareKeyRequest {
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetHostShareKeyResponseBody = {
  hostShareKey?: {
    hostShareKeyId?: string(name='HostShareKeyId'),
    hostShareKeyName?: string(name='HostShareKeyName'),
    lastModifyKeyAt?: long(name='LastModifyKeyAt'),
    privateKeyFingerPrint?: string(name='PrivateKeyFingerPrint'),
  }(name='HostShareKey'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: GetHostShareKeyResponseBody(name='body'),
}

async function getHostShareKeyWithOptions(request: GetHostShareKeyRequest, runtime: Util.RuntimeOptions): GetHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHostShareKey(request: GetHostShareKeyRequest): GetHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHostShareKeyWithOptions(request, runtime);
}

model GetInstanceADAuthServerRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetInstanceADAuthServerResponseBody = {
  AD?: {
    account?: string(name='Account'),
    baseDN?: string(name='BaseDN'),
    domain?: string(name='Domain'),
    emailMapping?: string(name='EmailMapping'),
    filter?: string(name='Filter'),
    hasPassword?: boolean(name='HasPassword'),
    isSSL?: boolean(name='IsSSL'),
    mobileMapping?: string(name='MobileMapping'),
    nameMapping?: string(name='NameMapping'),
    port?: long(name='Port'),
    server?: string(name='Server'),
    standbyServer?: string(name='StandbyServer'),
  }(name='AD'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetInstanceADAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceADAuthServerResponseBody(name='body'),
}

async function getInstanceADAuthServerWithOptions(request: GetInstanceADAuthServerRequest, runtime: Util.RuntimeOptions): GetInstanceADAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceADAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceADAuthServer(request: GetInstanceADAuthServerRequest): GetInstanceADAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceADAuthServerWithOptions(request, runtime);
}

model GetInstanceLDAPAuthServerRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetInstanceLDAPAuthServerResponseBody = {
  LDAP?: {
    account?: string(name='Account'),
    baseDN?: string(name='BaseDN'),
    emailMapping?: string(name='EmailMapping'),
    filter?: string(name='Filter'),
    hasPassword?: string(name='HasPassword'),
    isSSL?: boolean(name='IsSSL'),
    loginNameMapping?: string(name='LoginNameMapping'),
    mobileMapping?: string(name='MobileMapping'),
    nameMapping?: string(name='NameMapping'),
    port?: long(name='Port'),
    server?: string(name='Server'),
    standbyServer?: string(name='StandbyServer'),
  }(name='LDAP'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetInstanceLDAPAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceLDAPAuthServerResponseBody(name='body'),
}

async function getInstanceLDAPAuthServerWithOptions(request: GetInstanceLDAPAuthServerRequest, runtime: Util.RuntimeOptions): GetInstanceLDAPAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceLDAPAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceLDAPAuthServer(request: GetInstanceLDAPAuthServerRequest): GetInstanceLDAPAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceLDAPAuthServerWithOptions(request, runtime);
}

model GetInstanceTwoFactorRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model GetInstanceTwoFactorResponseBody = {
  config?: {
    dingTalkConfig?: {
      agentId?: string(name='AgentId'),
      appKey?: string(name='AppKey'),
      hasAppSecret?: boolean(name='HasAppSecret'),
    }(name='DingTalkConfig'),
    enableTwoFactor?: boolean(name='EnableTwoFactor'),
    messageLanguage?: string(name='MessageLanguage'),
    skipTwoFactorTime?: long(name='SkipTwoFactorTime'),
    twoFactorMethods?: [ string ](name='TwoFactorMethods'),
  }(name='Config'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetInstanceTwoFactorResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceTwoFactorResponseBody(name='body'),
}

async function getInstanceTwoFactorWithOptions(request: GetInstanceTwoFactorRequest, runtime: Util.RuntimeOptions): GetInstanceTwoFactorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceTwoFactor',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceTwoFactor(request: GetInstanceTwoFactorRequest): GetInstanceTwoFactorResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceTwoFactorWithOptions(request, runtime);
}

model GetInstanceUpgradeInfoRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  regionId?: string(name='RegionId'),
}

model GetInstanceUpgradeInfoResponseBody = {
  instanceUpgradeInfo?: {
    aliUid?: long(name='AliUid'),
    candidatePeriodList?: [ 
      {
        candidateEndTime?: long(name='CandidateEndTime'),
        candidateStartTime?: long(name='CandidateStartTime'),
      }
    ](name='CandidatePeriodList'),
    imageVersion?: string(name='ImageVersion'),
    instanceId?: string(name='InstanceId'),
    invalidPeriodList?: [ 
      {
        invalidEndTime?: long(name='InvalidEndTime'),
        invalidStartTime?: long(name='InvalidStartTime'),
      }
    ](name='InvalidPeriodList'),
    latestStartTime?: long(name='LatestStartTime'),
    operable?: boolean(name='Operable'),
    periodInterval?: int32(name='PeriodInterval'),
    upgradeEndTime?: long(name='UpgradeEndTime'),
    upgradeMode?: string(name='UpgradeMode'),
    upgradeStartTime?: long(name='UpgradeStartTime'),
  }(name='InstanceUpgradeInfo'),
  requestId?: string(name='RequestId'),
}

model GetInstanceUpgradeInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceUpgradeInfoResponseBody(name='body'),
}

async function getInstanceUpgradeInfoWithOptions(request: GetInstanceUpgradeInfoRequest, runtime: Util.RuntimeOptions): GetInstanceUpgradeInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceUpgradeInfo',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceUpgradeInfo(request: GetInstanceUpgradeInfoRequest): GetInstanceUpgradeInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceUpgradeInfoWithOptions(request, runtime);
}

model GetUserRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model GetUserResponseBody = {
  requestId?: string(name='RequestId'),
  user?: {
    comment?: string(name='Comment'),
    displayName?: string(name='DisplayName'),
    email?: string(name='Email'),
    mobile?: string(name='Mobile'),
    mobileCountryCode?: string(name='MobileCountryCode'),
    source?: string(name='Source'),
    sourceUserId?: string(name='SourceUserId'),
    userId?: string(name='UserId'),
    userName?: string(name='UserName'),
    userState?: [ string ](name='UserState'),
  }(name='User'),
}

model GetUserResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model GetUserGroupRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model GetUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
  userGroup?: {
    comment?: string(name='Comment'),
    userGroupId?: string(name='UserGroupId'),
    userGroupName?: string(name='UserGroupName'),
  }(name='UserGroup'),
}

model GetUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetUserGroupResponseBody(name='body'),
}

async function getUserGroupWithOptions(request: GetUserGroupRequest, runtime: Util.RuntimeOptions): GetUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserGroup(request: GetUserGroupRequest): GetUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserGroupWithOptions(request, runtime);
}

model ListHostAccountsRequest {
  hostAccountName?: string(name='HostAccountName'),
  hostId?: string(name='HostId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  protocolName?: string(name='ProtocolName'),
  regionId?: string(name='RegionId'),
}

model ListHostAccountsResponseBody = {
  hostAccounts?: [ 
    {
      hasPassword?: boolean(name='HasPassword'),
      hostAccountId?: string(name='HostAccountId'),
      hostAccountName?: string(name='HostAccountName'),
      hostId?: string(name='HostId'),
      hostShareKeyId?: string(name='HostShareKeyId'),
      hostShareKeyName?: string(name='HostShareKeyName'),
      privateKeyFingerprint?: string(name='PrivateKeyFingerprint'),
      protocolName?: string(name='ProtocolName'),
    }
  ](name='HostAccounts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostAccountsResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostAccountsResponseBody(name='body'),
}

async function listHostAccountsWithOptions(request: ListHostAccountsRequest, runtime: Util.RuntimeOptions): ListHostAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountName)) {
    query['HostAccountName'] = request.hostAccountName;
  }
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.protocolName)) {
    query['ProtocolName'] = request.protocolName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostAccounts',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostAccounts(request: ListHostAccountsRequest): ListHostAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostAccountsWithOptions(request, runtime);
}

model ListHostAccountsForHostShareKeyRequest {
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListHostAccountsForHostShareKeyResponseBody = {
  hostAccounts?: [ 
    {
      hostAccountName?: string(name='HostAccountName'),
      hostId?: string(name='HostId'),
      hostsAccountId?: string(name='HostsAccountId'),
      protocolName?: string(name='ProtocolName'),
    }
  ](name='HostAccounts'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListHostAccountsForHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostAccountsForHostShareKeyResponseBody(name='body'),
}

async function listHostAccountsForHostShareKeyWithOptions(request: ListHostAccountsForHostShareKeyRequest, runtime: Util.RuntimeOptions): ListHostAccountsForHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostAccountsForHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostAccountsForHostShareKey(request: ListHostAccountsForHostShareKeyRequest): ListHostAccountsForHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostAccountsForHostShareKeyWithOptions(request, runtime);
}

model ListHostAccountsForUserRequest {
  hostAccountName?: string(name='HostAccountName'),
  hostId?: string(name='HostId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model ListHostAccountsForUserResponseBody = {
  hostAccounts?: [ 
    {
      hostAccountId?: string(name='HostAccountId'),
      hostAccountName?: string(name='HostAccountName'),
      hostId?: string(name='HostId'),
      isAuthorized?: boolean(name='IsAuthorized'),
      protocolName?: string(name='ProtocolName'),
    }
  ](name='HostAccounts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostAccountsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostAccountsForUserResponseBody(name='body'),
}

async function listHostAccountsForUserWithOptions(request: ListHostAccountsForUserRequest, runtime: Util.RuntimeOptions): ListHostAccountsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountName)) {
    query['HostAccountName'] = request.hostAccountName;
  }
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostAccountsForUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostAccountsForUser(request: ListHostAccountsForUserRequest): ListHostAccountsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostAccountsForUserWithOptions(request, runtime);
}

model ListHostAccountsForUserGroupRequest {
  hostAccountName?: string(name='HostAccountName'),
  hostId?: string(name='HostId'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model ListHostAccountsForUserGroupResponseBody = {
  hostAccounts?: [ 
    {
      hostAccountId?: string(name='HostAccountId'),
      hostAccountName?: string(name='HostAccountName'),
      hostId?: string(name='HostId'),
      isAuthorized?: boolean(name='IsAuthorized'),
      protocolName?: string(name='ProtocolName'),
    }
  ](name='HostAccounts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostAccountsForUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostAccountsForUserGroupResponseBody(name='body'),
}

async function listHostAccountsForUserGroupWithOptions(request: ListHostAccountsForUserGroupRequest, runtime: Util.RuntimeOptions): ListHostAccountsForUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountName)) {
    query['HostAccountName'] = request.hostAccountName;
  }
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostAccountsForUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostAccountsForUserGroup(request: ListHostAccountsForUserGroupRequest): ListHostAccountsForUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostAccountsForUserGroupWithOptions(request, runtime);
}

model ListHostGroupAccountNamesForUserRequest {
  hostGroupId?: string(name='HostGroupId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model ListHostGroupAccountNamesForUserResponseBody = {
  hostAccountNames?: [ string ](name='HostAccountNames'),
  requestId?: string(name='RequestId'),
}

model ListHostGroupAccountNamesForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostGroupAccountNamesForUserResponseBody(name='body'),
}

async function listHostGroupAccountNamesForUserWithOptions(request: ListHostGroupAccountNamesForUserRequest, runtime: Util.RuntimeOptions): ListHostGroupAccountNamesForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroupAccountNamesForUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostGroupAccountNamesForUser(request: ListHostGroupAccountNamesForUserRequest): ListHostGroupAccountNamesForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostGroupAccountNamesForUserWithOptions(request, runtime);
}

model ListHostGroupAccountNamesForUserGroupRequest {
  hostGroupId?: string(name='HostGroupId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model ListHostGroupAccountNamesForUserGroupResponseBody = {
  hostAccountNames?: [ string ](name='HostAccountNames'),
  requestId?: string(name='RequestId'),
}

model ListHostGroupAccountNamesForUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostGroupAccountNamesForUserGroupResponseBody(name='body'),
}

async function listHostGroupAccountNamesForUserGroupWithOptions(request: ListHostGroupAccountNamesForUserGroupRequest, runtime: Util.RuntimeOptions): ListHostGroupAccountNamesForUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroupAccountNamesForUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostGroupAccountNamesForUserGroup(request: ListHostGroupAccountNamesForUserGroupRequest): ListHostGroupAccountNamesForUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostGroupAccountNamesForUserGroupWithOptions(request, runtime);
}

model ListHostGroupsRequest {
  hostGroupName?: string(name='HostGroupName'),
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListHostGroupsResponseBody = {
  hostGroups?: [ 
    {
      comment?: string(name='Comment'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
      memberCount?: int32(name='MemberCount'),
    }
  ](name='HostGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostGroupsResponseBody(name='body'),
}

async function listHostGroupsWithOptions(request: ListHostGroupsRequest, runtime: Util.RuntimeOptions): ListHostGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupName)) {
    query['HostGroupName'] = request.hostGroupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroups',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostGroups(request: ListHostGroupsRequest): ListHostGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostGroupsWithOptions(request, runtime);
}

model ListHostGroupsForUserRequest {
  hostGroupName?: string(name='HostGroupName'),
  instanceId?: string(name='InstanceId'),
  mode?: string(name='Mode'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model ListHostGroupsForUserResponseBody = {
  hostGroups?: [ 
    {
      comment?: string(name='Comment'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
    }
  ](name='HostGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostGroupsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostGroupsForUserResponseBody(name='body'),
}

async function listHostGroupsForUserWithOptions(request: ListHostGroupsForUserRequest, runtime: Util.RuntimeOptions): ListHostGroupsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupName)) {
    query['HostGroupName'] = request.hostGroupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroupsForUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostGroupsForUser(request: ListHostGroupsForUserRequest): ListHostGroupsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostGroupsForUserWithOptions(request, runtime);
}

model ListHostGroupsForUserGroupRequest {
  hostGroupName?: string(name='HostGroupName'),
  instanceId?: string(name='InstanceId'),
  mode?: string(name='Mode'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model ListHostGroupsForUserGroupResponseBody = {
  hostGroups?: [ 
    {
      comment?: string(name='Comment'),
      hostGroupId?: string(name='HostGroupId'),
      hostGroupName?: string(name='HostGroupName'),
    }
  ](name='HostGroups'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostGroupsForUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostGroupsForUserGroupResponseBody(name='body'),
}

async function listHostGroupsForUserGroupWithOptions(request: ListHostGroupsForUserGroupRequest, runtime: Util.RuntimeOptions): ListHostGroupsForUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupName)) {
    query['HostGroupName'] = request.hostGroupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostGroupsForUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostGroupsForUserGroup(request: ListHostGroupsForUserGroupRequest): ListHostGroupsForUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostGroupsForUserGroupWithOptions(request, runtime);
}

model ListHostShareKeysRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
}

model ListHostShareKeysResponseBody = {
  hostShareKeys?: [ 
    {
      hostAccountCount?: long(name='HostAccountCount'),
      hostShareKeyId?: string(name='HostShareKeyId'),
      hostShareKeyName?: string(name='HostShareKeyName'),
      lastModifyKeyAt?: long(name='LastModifyKeyAt'),
      privateKeyFingerPrint?: string(name='PrivateKeyFingerPrint'),
    }
  ](name='HostShareKeys'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListHostShareKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostShareKeysResponseBody(name='body'),
}

async function listHostShareKeysWithOptions(request: ListHostShareKeysRequest, runtime: Util.RuntimeOptions): ListHostShareKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostShareKeys',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostShareKeys(request: ListHostShareKeysRequest): ListHostShareKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostShareKeysWithOptions(request, runtime);
}

model ListHostsRequest {
  hostAddress?: string(name='HostAddress'),
  hostGroupId?: string(name='HostGroupId'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  OSType?: string(name='OSType'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  sourceInstanceId?: string(name='SourceInstanceId'),
  sourceInstanceState?: string(name='SourceInstanceState'),
}

model ListHostsResponseBody = {
  hosts?: [ 
    {
      activeAddressType?: string(name='ActiveAddressType'),
      comment?: string(name='Comment'),
      hostAccountCount?: int32(name='HostAccountCount'),
      hostId?: string(name='HostId'),
      hostName?: string(name='HostName'),
      hostPrivateAddress?: string(name='HostPrivateAddress'),
      hostPublicAddress?: string(name='HostPublicAddress'),
      OSType?: string(name='OSType'),
      source?: string(name='Source'),
      sourceInstanceId?: string(name='SourceInstanceId'),
      sourceInstanceState?: string(name='SourceInstanceState'),
    }
  ](name='Hosts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostsResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostsResponseBody(name='body'),
}

async function listHostsWithOptions(request: ListHostsRequest, runtime: Util.RuntimeOptions): ListHostsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAddress)) {
    query['HostAddress'] = request.hostAddress;
  }
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.OSType)) {
    query['OSType'] = request.OSType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceInstanceId)) {
    query['SourceInstanceId'] = request.sourceInstanceId;
  }
  if (!Util.isUnset(request.sourceInstanceState)) {
    query['SourceInstanceState'] = request.sourceInstanceState;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHosts',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHosts(request: ListHostsRequest): ListHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostsWithOptions(request, runtime);
}

model ListHostsForUserRequest {
  hostAddress?: string(name='HostAddress'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  mode?: string(name='Mode'),
  OSType?: string(name='OSType'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model ListHostsForUserResponseBody = {
  hosts?: [ 
    {
      activeAddressType?: string(name='ActiveAddressType'),
      comment?: string(name='Comment'),
      hostId?: string(name='HostId'),
      hostName?: string(name='HostName'),
      hostPrivateAddress?: string(name='HostPrivateAddress'),
      hostPublicAddress?: string(name='HostPublicAddress'),
      OSType?: string(name='OSType'),
    }
  ](name='Hosts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostsForUserResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostsForUserResponseBody(name='body'),
}

async function listHostsForUserWithOptions(request: ListHostsForUserRequest, runtime: Util.RuntimeOptions): ListHostsForUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAddress)) {
    query['HostAddress'] = request.hostAddress;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.OSType)) {
    query['OSType'] = request.OSType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostsForUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostsForUser(request: ListHostsForUserRequest): ListHostsForUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostsForUserWithOptions(request, runtime);
}

model ListHostsForUserGroupRequest {
  hostAddress?: string(name='HostAddress'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  mode?: string(name='Mode'),
  OSType?: string(name='OSType'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
}

model ListHostsForUserGroupResponseBody = {
  hosts?: [ 
    {
      activeAddressType?: string(name='ActiveAddressType'),
      comment?: string(name='Comment'),
      hostId?: string(name='HostId'),
      hostName?: string(name='HostName'),
      hostPrivateAddress?: string(name='HostPrivateAddress'),
      hostPublicAddress?: string(name='HostPublicAddress'),
      OSType?: string(name='OSType'),
    }
  ](name='Hosts'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListHostsForUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ListHostsForUserGroupResponseBody(name='body'),
}

async function listHostsForUserGroupWithOptions(request: ListHostsForUserGroupRequest, runtime: Util.RuntimeOptions): ListHostsForUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAddress)) {
    query['HostAddress'] = request.hostAddress;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.OSType)) {
    query['OSType'] = request.OSType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListHostsForUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listHostsForUserGroup(request: ListHostsForUserGroupRequest): ListHostsForUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return listHostsForUserGroupWithOptions(request, runtime);
}

model ListTagKeysRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceType?: string(name='ResourceType'),
}

model ListTagKeysResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tagKeys?: [ 
    {
      tagCount?: int32(name='TagCount'),
      tagKey?: string(name='TagKey'),
    }
  ](name='TagKeys'),
  totalCount?: int32(name='TotalCount'),
}

model ListTagKeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagKeysResponseBody(name='body'),
}

async function listTagKeysWithOptions(request: ListTagKeysRequest, runtime: Util.RuntimeOptions): ListTagKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagKeys',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagKeys(request: ListTagKeysRequest): ListTagKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagKeysWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListUserGroupsRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  userGroupName?: string(name='UserGroupName'),
}

model ListUserGroupsResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  userGroups?: [ 
    {
      comment?: string(name='Comment'),
      memberCount?: int32(name='MemberCount'),
      userGroupId?: string(name='UserGroupId'),
      userGroupName?: string(name='UserGroupName'),
    }
  ](name='UserGroups'),
}

model ListUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserGroupsResponseBody(name='body'),
}

async function listUserGroupsWithOptions(request: ListUserGroupsRequest, runtime: Util.RuntimeOptions): ListUserGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    query['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserGroups',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserGroups(request: ListUserGroupsRequest): ListUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserGroupsWithOptions(request, runtime);
}

model ListUsersRequest {
  displayName?: string(name='DisplayName'),
  instanceId?: string(name='InstanceId'),
  mobile?: string(name='Mobile'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  sourceUserId?: string(name='SourceUserId'),
  userGroupId?: string(name='UserGroupId'),
  userName?: string(name='UserName'),
  userState?: string(name='UserState'),
}

model ListUsersResponseBody = {
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  users?: [ 
    {
      comment?: string(name='Comment'),
      displayName?: string(name='DisplayName'),
      email?: string(name='Email'),
      mobile?: string(name='Mobile'),
      mobileCountryCode?: string(name='MobileCountryCode'),
      source?: string(name='Source'),
      sourceUserId?: string(name='SourceUserId'),
      userId?: string(name='UserId'),
      userName?: string(name='UserName'),
      userState?: [ string ](name='UserState'),
    }
  ](name='Users'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(request: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceUserId)) {
    query['SourceUserId'] = request.sourceUserId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.userState)) {
    query['UserState'] = request.userState;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model LockUsersRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userIds?: string(name='UserIds'),
}

model LockUsersResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model LockUsersResponse = {
  headers: map[string]string(name='headers'),
  body: LockUsersResponseBody(name='body'),
}

async function lockUsersWithOptions(request: LockUsersRequest, runtime: Util.RuntimeOptions): LockUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LockUsers',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function lockUsers(request: LockUsersRequest): LockUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return lockUsersWithOptions(request, runtime);
}

model ModifyHostRequest {
  comment?: string(name='Comment'),
  hostId?: string(name='HostId'),
  hostName?: string(name='HostName'),
  hostPrivateAddress?: string(name='HostPrivateAddress'),
  hostPublicAddress?: string(name='HostPublicAddress'),
  instanceId?: string(name='InstanceId'),
  OSType?: string(name='OSType'),
  regionId?: string(name='RegionId'),
}

model ModifyHostResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHostResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostResponseBody(name='body'),
}

async function modifyHostWithOptions(request: ModifyHostRequest, runtime: Util.RuntimeOptions): ModifyHostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.hostId)) {
    query['HostId'] = request.hostId;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.hostPrivateAddress)) {
    query['HostPrivateAddress'] = request.hostPrivateAddress;
  }
  if (!Util.isUnset(request.hostPublicAddress)) {
    query['HostPublicAddress'] = request.hostPublicAddress;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.OSType)) {
    query['OSType'] = request.OSType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHost',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHost(request: ModifyHostRequest): ModifyHostResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostWithOptions(request, runtime);
}

model ModifyHostAccountRequest {
  hostAccountId?: string(name='HostAccountId'),
  hostAccountName?: string(name='HostAccountName'),
  hostShareKeyId?: string(name='HostShareKeyId'),
  instanceId?: string(name='InstanceId'),
  passPhrase?: string(name='PassPhrase'),
  password?: string(name='Password'),
  privateKey?: string(name='PrivateKey'),
  regionId?: string(name='RegionId'),
}

model ModifyHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostAccountResponseBody(name='body'),
}

async function modifyHostAccountWithOptions(request: ModifyHostAccountRequest, runtime: Util.RuntimeOptions): ModifyHostAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostAccountId)) {
    query['HostAccountId'] = request.hostAccountId;
  }
  if (!Util.isUnset(request.hostAccountName)) {
    query['HostAccountName'] = request.hostAccountName;
  }
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.passPhrase)) {
    query['PassPhrase'] = request.passPhrase;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostAccount',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostAccount(request: ModifyHostAccountRequest): ModifyHostAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostAccountWithOptions(request, runtime);
}

model ModifyHostGroupRequest {
  comment?: string(name='Comment'),
  hostGroupId?: string(name='HostGroupId'),
  hostGroupName?: string(name='HostGroupName'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ModifyHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostGroupResponseBody(name='body'),
}

async function modifyHostGroupWithOptions(request: ModifyHostGroupRequest, runtime: Util.RuntimeOptions): ModifyHostGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.hostGroupName)) {
    query['HostGroupName'] = request.hostGroupName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostGroup(request: ModifyHostGroupRequest): ModifyHostGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostGroupWithOptions(request, runtime);
}

model ModifyHostShareKeyRequest {
  hostShareKeyId?: string(name='HostShareKeyId'),
  hostShareKeyName?: string(name='HostShareKeyName'),
  instanceId?: string(name='InstanceId'),
  passPhrase?: string(name='PassPhrase'),
  privateKey?: string(name='PrivateKey'),
  regionId?: string(name='RegionId'),
}

model ModifyHostShareKeyResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyHostShareKeyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostShareKeyResponseBody(name='body'),
}

async function modifyHostShareKeyWithOptions(request: ModifyHostShareKeyRequest, runtime: Util.RuntimeOptions): ModifyHostShareKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostShareKeyId)) {
    query['HostShareKeyId'] = request.hostShareKeyId;
  }
  if (!Util.isUnset(request.hostShareKeyName)) {
    query['HostShareKeyName'] = request.hostShareKeyName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.passPhrase)) {
    query['PassPhrase'] = request.passPhrase;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostShareKey',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostShareKey(request: ModifyHostShareKeyRequest): ModifyHostShareKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostShareKeyWithOptions(request, runtime);
}

model ModifyHostsActiveAddressTypeRequest {
  activeAddressType?: string(name='ActiveAddressType'),
  hostIds?: string(name='HostIds'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ModifyHostsActiveAddressTypeResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model ModifyHostsActiveAddressTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostsActiveAddressTypeResponseBody(name='body'),
}

async function modifyHostsActiveAddressTypeWithOptions(request: ModifyHostsActiveAddressTypeRequest, runtime: Util.RuntimeOptions): ModifyHostsActiveAddressTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.activeAddressType)) {
    query['ActiveAddressType'] = request.activeAddressType;
  }
  if (!Util.isUnset(request.hostIds)) {
    query['HostIds'] = request.hostIds;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostsActiveAddressType',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostsActiveAddressType(request: ModifyHostsActiveAddressTypeRequest): ModifyHostsActiveAddressTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostsActiveAddressTypeWithOptions(request, runtime);
}

model ModifyHostsPortRequest {
  hostIds?: string(name='HostIds'),
  instanceId?: string(name='InstanceId'),
  port?: string(name='Port'),
  protocolName?: string(name='ProtocolName'),
  regionId?: string(name='RegionId'),
}

model ModifyHostsPortResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model ModifyHostsPortResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHostsPortResponseBody(name='body'),
}

async function modifyHostsPortWithOptions(request: ModifyHostsPortRequest, runtime: Util.RuntimeOptions): ModifyHostsPortResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostIds)) {
    query['HostIds'] = request.hostIds;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.protocolName)) {
    query['ProtocolName'] = request.protocolName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHostsPort',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHostsPort(request: ModifyHostsPortRequest): ModifyHostsPortResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHostsPortWithOptions(request, runtime);
}

model ModifyInstanceADAuthServerRequest {
  account?: string(name='Account'),
  baseDN?: string(name='BaseDN'),
  domain?: string(name='Domain'),
  emailMapping?: string(name='EmailMapping'),
  filter?: string(name='Filter'),
  instanceId?: string(name='InstanceId'),
  isSSL?: string(name='IsSSL'),
  mobileMapping?: string(name='MobileMapping'),
  nameMapping?: string(name='NameMapping'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  regionId?: string(name='RegionId'),
  server?: string(name='Server'),
  standbyServer?: string(name='StandbyServer'),
}

model ModifyInstanceADAuthServerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyInstanceADAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceADAuthServerResponseBody(name='body'),
}

async function modifyInstanceADAuthServerWithOptions(request: ModifyInstanceADAuthServerRequest, runtime: Util.RuntimeOptions): ModifyInstanceADAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  if (!Util.isUnset(request.baseDN)) {
    query['BaseDN'] = request.baseDN;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.emailMapping)) {
    query['EmailMapping'] = request.emailMapping;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isSSL)) {
    query['IsSSL'] = request.isSSL;
  }
  if (!Util.isUnset(request.mobileMapping)) {
    query['MobileMapping'] = request.mobileMapping;
  }
  if (!Util.isUnset(request.nameMapping)) {
    query['NameMapping'] = request.nameMapping;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.server)) {
    query['Server'] = request.server;
  }
  if (!Util.isUnset(request.standbyServer)) {
    query['StandbyServer'] = request.standbyServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceADAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceADAuthServer(request: ModifyInstanceADAuthServerRequest): ModifyInstanceADAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceADAuthServerWithOptions(request, runtime);
}

model ModifyInstanceAttributeRequest {
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ModifyInstanceAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAttributeResponseBody(name='body'),
}

async function modifyInstanceAttributeWithOptions(request: ModifyInstanceAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAttribute',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceAttribute(request: ModifyInstanceAttributeRequest): ModifyInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAttributeWithOptions(request, runtime);
}

model ModifyInstanceLDAPAuthServerRequest {
  account?: string(name='Account'),
  baseDN?: string(name='BaseDN'),
  emailMapping?: string(name='EmailMapping'),
  filter?: string(name='Filter'),
  instanceId?: string(name='InstanceId'),
  isSSL?: string(name='IsSSL'),
  loginNameMapping?: string(name='LoginNameMapping'),
  mobileMapping?: string(name='MobileMapping'),
  nameMapping?: string(name='NameMapping'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  regionId?: string(name='RegionId'),
  server?: string(name='Server'),
  standbyServer?: string(name='StandbyServer'),
}

model ModifyInstanceLDAPAuthServerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyInstanceLDAPAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceLDAPAuthServerResponseBody(name='body'),
}

async function modifyInstanceLDAPAuthServerWithOptions(request: ModifyInstanceLDAPAuthServerRequest, runtime: Util.RuntimeOptions): ModifyInstanceLDAPAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  if (!Util.isUnset(request.baseDN)) {
    query['BaseDN'] = request.baseDN;
  }
  if (!Util.isUnset(request.emailMapping)) {
    query['EmailMapping'] = request.emailMapping;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isSSL)) {
    query['IsSSL'] = request.isSSL;
  }
  if (!Util.isUnset(request.loginNameMapping)) {
    query['LoginNameMapping'] = request.loginNameMapping;
  }
  if (!Util.isUnset(request.mobileMapping)) {
    query['MobileMapping'] = request.mobileMapping;
  }
  if (!Util.isUnset(request.nameMapping)) {
    query['NameMapping'] = request.nameMapping;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.server)) {
    query['Server'] = request.server;
  }
  if (!Util.isUnset(request.standbyServer)) {
    query['StandbyServer'] = request.standbyServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceLDAPAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceLDAPAuthServer(request: ModifyInstanceLDAPAuthServerRequest): ModifyInstanceLDAPAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceLDAPAuthServerWithOptions(request, runtime);
}

model ModifyInstanceTwoFactorRequest {
  dingTalkConfig?: string(name='DingTalkConfig'),
  enableTwoFactor?: string(name='EnableTwoFactor'),
  instanceId?: string(name='InstanceId'),
  messageLanguage?: string(name='MessageLanguage'),
  regionId?: string(name='RegionId'),
  skipTwoFactorTime?: string(name='SkipTwoFactorTime'),
  twoFactorMethods?: string(name='TwoFactorMethods'),
}

model ModifyInstanceTwoFactorResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ModifyInstanceTwoFactorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceTwoFactorResponseBody(name='body'),
}

async function modifyInstanceTwoFactorWithOptions(request: ModifyInstanceTwoFactorRequest, runtime: Util.RuntimeOptions): ModifyInstanceTwoFactorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dingTalkConfig)) {
    query['DingTalkConfig'] = request.dingTalkConfig;
  }
  if (!Util.isUnset(request.enableTwoFactor)) {
    query['EnableTwoFactor'] = request.enableTwoFactor;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.messageLanguage)) {
    query['MessageLanguage'] = request.messageLanguage;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.skipTwoFactorTime)) {
    query['SkipTwoFactorTime'] = request.skipTwoFactorTime;
  }
  if (!Util.isUnset(request.twoFactorMethods)) {
    query['TwoFactorMethods'] = request.twoFactorMethods;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceTwoFactor',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceTwoFactor(request: ModifyInstanceTwoFactorRequest): ModifyInstanceTwoFactorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceTwoFactorWithOptions(request, runtime);
}

model ModifyInstanceUpgradePeriodRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  regionId?: string(name='RegionId'),
  upgradeMode?: string(name='UpgradeMode'),
  upgradeStartTime?: string(name='UpgradeStartTime'),
}

model ModifyInstanceUpgradePeriodResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceUpgradePeriodResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceUpgradePeriodResponseBody(name='body'),
}

async function modifyInstanceUpgradePeriodWithOptions(request: ModifyInstanceUpgradePeriodRequest, runtime: Util.RuntimeOptions): ModifyInstanceUpgradePeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.upgradeMode)) {
    query['UpgradeMode'] = request.upgradeMode;
  }
  if (!Util.isUnset(request.upgradeStartTime)) {
    query['UpgradeStartTime'] = request.upgradeStartTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceUpgradePeriod',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceUpgradePeriod(request: ModifyInstanceUpgradePeriodRequest): ModifyInstanceUpgradePeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceUpgradePeriodWithOptions(request, runtime);
}

model ModifyUserRequest {
  comment?: string(name='Comment'),
  displayName?: string(name='DisplayName'),
  email?: string(name='Email'),
  instanceId?: string(name='InstanceId'),
  mobile?: string(name='Mobile'),
  mobileCountryCode?: string(name='MobileCountryCode'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model ModifyUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserResponseBody(name='body'),
}

async function modifyUserWithOptions(request: ModifyUserRequest, runtime: Util.RuntimeOptions): ModifyUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.displayName)) {
    query['DisplayName'] = request.displayName;
  }
  if (!Util.isUnset(request.email)) {
    query['Email'] = request.email;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.mobile)) {
    query['Mobile'] = request.mobile;
  }
  if (!Util.isUnset(request.mobileCountryCode)) {
    query['MobileCountryCode'] = request.mobileCountryCode;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUser',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUser(request: ModifyUserRequest): ModifyUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserWithOptions(request, runtime);
}

model ModifyUserGroupRequest {
  comment?: string(name='Comment'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
  userGroupName?: string(name='UserGroupName'),
}

model ModifyUserGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyUserGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyUserGroupResponseBody(name='body'),
}

async function modifyUserGroupWithOptions(request: ModifyUserGroupRequest, runtime: Util.RuntimeOptions): ModifyUserGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    query['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyUserGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyUserGroup(request: ModifyUserGroupRequest): ModifyUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyUserGroupWithOptions(request, runtime);
}

model MoveResourceGroupRequest {
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model MoveResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model MoveResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: MoveResourceGroupResponseBody(name='body'),
}

async function moveResourceGroupWithOptions(request: MoveResourceGroupRequest, runtime: Util.RuntimeOptions): MoveResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MoveResourceGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function moveResourceGroup(request: MoveResourceGroupRequest): MoveResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return moveResourceGroupWithOptions(request, runtime);
}

model RemoveHostsFromGroupRequest {
  hostGroupId?: string(name='HostGroupId'),
  hostIds?: string(name='HostIds'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model RemoveHostsFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      hostGroupId?: string(name='HostGroupId'),
      hostId?: string(name='HostId'),
      message?: string(name='Message'),
    }
  ](name='Results'),
}

model RemoveHostsFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveHostsFromGroupResponseBody(name='body'),
}

async function removeHostsFromGroupWithOptions(request: RemoveHostsFromGroupRequest, runtime: Util.RuntimeOptions): RemoveHostsFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.hostGroupId)) {
    query['HostGroupId'] = request.hostGroupId;
  }
  if (!Util.isUnset(request.hostIds)) {
    query['HostIds'] = request.hostIds;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveHostsFromGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeHostsFromGroup(request: RemoveHostsFromGroupRequest): RemoveHostsFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeHostsFromGroupWithOptions(request, runtime);
}

model RemoveUsersFromGroupRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userGroupId?: string(name='UserGroupId'),
  userIds?: string(name='UserIds'),
}

model RemoveUsersFromGroupResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      userGroupId?: string(name='UserGroupId'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model RemoveUsersFromGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveUsersFromGroupResponseBody(name='body'),
}

async function removeUsersFromGroupWithOptions(request: RemoveUsersFromGroupRequest, runtime: Util.RuntimeOptions): RemoveUsersFromGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    query['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveUsersFromGroup',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeUsersFromGroup(request: RemoveUsersFromGroupRequest): RemoveUsersFromGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeUsersFromGroupWithOptions(request, runtime);
}

model ResetHostAccountCredentialRequest {
  credentialType?: string(name='CredentialType'),
  hostAccountId?: string(name='HostAccountId'),
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
}

model ResetHostAccountCredentialResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetHostAccountCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: ResetHostAccountCredentialResponseBody(name='body'),
}

async function resetHostAccountCredentialWithOptions(request: ResetHostAccountCredentialRequest, runtime: Util.RuntimeOptions): ResetHostAccountCredentialResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.credentialType)) {
    query['CredentialType'] = request.credentialType;
  }
  if (!Util.isUnset(request.hostAccountId)) {
    query['HostAccountId'] = request.hostAccountId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetHostAccountCredential',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetHostAccountCredential(request: ResetHostAccountCredentialRequest): ResetHostAccountCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetHostAccountCredentialWithOptions(request, runtime);
}

model StartInstanceRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  securityGroupIds?: [ string ](name='SecurityGroupIds'),
  vswitchId?: string(name='VswitchId'),
}

model StartInstanceResponseBody = {
  instanceId?: string(name='InstanceId'),
  requestId?: string(name='RequestId'),
}

model StartInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartInstanceResponseBody(name='body'),
}

async function startInstanceWithOptions(request: StartInstanceRequest, runtime: Util.RuntimeOptions): StartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.securityGroupIds)) {
    query['SecurityGroupIds'] = request.securityGroupIds;
  }
  if (!Util.isUnset(request.vswitchId)) {
    query['VswitchId'] = request.vswitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartInstance',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startInstance(request: StartInstanceRequest): StartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startInstanceWithOptions(request, runtime);
}

model TagResourcesRequest {
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnlockUsersRequest {
  instanceId?: string(name='InstanceId'),
  regionId?: string(name='RegionId'),
  userIds?: string(name='UserIds'),
}

model UnlockUsersResponseBody = {
  requestId?: string(name='RequestId'),
  results?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      userId?: string(name='UserId'),
    }
  ](name='Results'),
}

model UnlockUsersResponse = {
  headers: map[string]string(name='headers'),
  body: UnlockUsersResponseBody(name='body'),
}

async function unlockUsersWithOptions(request: UnlockUsersRequest, runtime: Util.RuntimeOptions): UnlockUsersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userIds)) {
    query['UserIds'] = request.userIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnlockUsers',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unlockUsers(request: UnlockUsersRequest): UnlockUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return unlockUsersWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpgradeInstanceImageVersionRequest {
  instanceId?: string(name='InstanceId'),
  lang?: string(name='Lang'),
  regionId?: string(name='RegionId'),
}

model UpgradeInstanceImageVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeInstanceImageVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeInstanceImageVersionResponseBody(name='body'),
}

async function upgradeInstanceImageVersionWithOptions(request: UpgradeInstanceImageVersionRequest, runtime: Util.RuntimeOptions): UpgradeInstanceImageVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.lang)) {
    query['Lang'] = request.lang;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeInstanceImageVersion',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeInstanceImageVersion(request: UpgradeInstanceImageVersionRequest): UpgradeInstanceImageVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeInstanceImageVersionWithOptions(request, runtime);
}

model VerifyInstanceADAuthServerRequest {
  account?: string(name='Account'),
  baseDN?: string(name='BaseDN'),
  domain?: string(name='Domain'),
  filter?: string(name='Filter'),
  instanceId?: string(name='InstanceId'),
  isSSL?: string(name='IsSSL'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  regionId?: string(name='RegionId'),
  server?: string(name='Server'),
  standbyServer?: string(name='StandbyServer'),
}

model VerifyInstanceADAuthServerResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model VerifyInstanceADAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyInstanceADAuthServerResponseBody(name='body'),
}

async function verifyInstanceADAuthServerWithOptions(request: VerifyInstanceADAuthServerRequest, runtime: Util.RuntimeOptions): VerifyInstanceADAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  if (!Util.isUnset(request.baseDN)) {
    query['BaseDN'] = request.baseDN;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isSSL)) {
    query['IsSSL'] = request.isSSL;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.server)) {
    query['Server'] = request.server;
  }
  if (!Util.isUnset(request.standbyServer)) {
    query['StandbyServer'] = request.standbyServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyInstanceADAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyInstanceADAuthServer(request: VerifyInstanceADAuthServerRequest): VerifyInstanceADAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyInstanceADAuthServerWithOptions(request, runtime);
}

model VerifyInstanceLDAPAuthServerRequest {
  account?: string(name='Account'),
  baseDN?: string(name='BaseDN'),
  filter?: string(name='Filter'),
  instanceId?: string(name='InstanceId'),
  isSSL?: string(name='IsSSL'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  regionId?: string(name='RegionId'),
  server?: string(name='Server'),
  standbyServer?: string(name='StandbyServer'),
}

model VerifyInstanceLDAPAuthServerResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyInstanceLDAPAuthServerResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyInstanceLDAPAuthServerResponseBody(name='body'),
}

async function verifyInstanceLDAPAuthServerWithOptions(request: VerifyInstanceLDAPAuthServerRequest, runtime: Util.RuntimeOptions): VerifyInstanceLDAPAuthServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.account)) {
    query['Account'] = request.account;
  }
  if (!Util.isUnset(request.baseDN)) {
    query['BaseDN'] = request.baseDN;
  }
  if (!Util.isUnset(request.filter)) {
    query['Filter'] = request.filter;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.isSSL)) {
    query['IsSSL'] = request.isSSL;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.server)) {
    query['Server'] = request.server;
  }
  if (!Util.isUnset(request.standbyServer)) {
    query['StandbyServer'] = request.standbyServer;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'VerifyInstanceLDAPAuthServer',
    version = '2019-12-09',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyInstanceLDAPAuthServer(request: VerifyInstanceLDAPAuthServerRequest): VerifyInstanceLDAPAuthServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyInstanceLDAPAuthServerWithOptions(request, runtime);
}

