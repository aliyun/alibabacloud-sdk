/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-hangzhou = 'business.aliyuncs.com',
    cn-shanghai = 'business.aliyuncs.com',
    ap-southeast-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-northeast-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-northeast-2 = 'business.ap-southeast-1.aliyuncs.com',
    ap-northeast-2-pop = 'business.ap-southeast-1.aliyuncs.com',
    ap-south-1 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-2 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-3 = 'business.ap-southeast-1.aliyuncs.com',
    ap-southeast-5 = 'business.ap-southeast-1.aliyuncs.com',
    cn-beijing = 'business.aliyuncs.com',
    cn-beijing-finance-1 = 'business.aliyuncs.com',
    cn-beijing-finance-pop = 'business.aliyuncs.com',
    cn-beijing-gov-1 = 'business.aliyuncs.com',
    cn-beijing-nu16-b01 = 'business.aliyuncs.com',
    cn-chengdu = 'business.aliyuncs.com',
    cn-edge-1 = 'business.aliyuncs.com',
    cn-fujian = 'business.aliyuncs.com',
    cn-haidian-cm12-c01 = 'business.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'business.aliyuncs.com',
    cn-hangzhou-finance = 'business.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'business.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'business.aliyuncs.com',
    cn-hangzhou-test-306 = 'business.aliyuncs.com',
    cn-hongkong = 'business.aliyuncs.com',
    cn-hongkong-finance-pop = 'business.aliyuncs.com',
    cn-huhehaote = 'business.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'business.aliyuncs.com',
    cn-north-2-gov-1 = 'business.aliyuncs.com',
    cn-qingdao = 'business.aliyuncs.com',
    cn-qingdao-nebula = 'business.aliyuncs.com',
    cn-shanghai-et15-b01 = 'business.aliyuncs.com',
    cn-shanghai-et2-b01 = 'business.aliyuncs.com',
    cn-shanghai-finance-1 = 'business.aliyuncs.com',
    cn-shanghai-inner = 'business.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'business.aliyuncs.com',
    cn-shenzhen = 'business.aliyuncs.com',
    cn-shenzhen-finance-1 = 'business.aliyuncs.com',
    cn-shenzhen-inner = 'business.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'business.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'business.aliyuncs.com',
    cn-wuhan = 'business.aliyuncs.com',
    cn-wulanchabu = 'business.aliyuncs.com',
    cn-yushanfang = 'business.aliyuncs.com',
    cn-zhangbei = 'business.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'business.aliyuncs.com',
    cn-zhangjiakou = 'business.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'business.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'business.aliyuncs.com',
    eu-central-1 = 'business.ap-southeast-1.aliyuncs.com',
    eu-west-1 = 'business.ap-southeast-1.aliyuncs.com',
    eu-west-1-oxs = 'business.ap-southeast-1.aliyuncs.com',
    me-east-1 = 'business.ap-southeast-1.aliyuncs.com',
    rus-west-1-pop = 'business.ap-southeast-1.aliyuncs.com',
    us-east-1 = 'business.ap-southeast-1.aliyuncs.com',
    us-west-1 = 'business.ap-southeast-1.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('bssopenapi', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddAccountRelationRequest {
  childNick?: string(name='ChildNick'),
  childUserId?: long(name='ChildUserId'),
  parentUserId?: long(name='ParentUserId'),
  permissionCodes?: [ string ](name='PermissionCodes'),
  relationType?: string(name='RelationType'),
  requestId?: string(name='RequestId'),
  roleCodes?: [ string ](name='RoleCodes'),
}

model AddAccountRelationResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    relationId?: long(name='RelationId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddAccountRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAccountRelationResponseBody(name='body'),
}

async function addAccountRelationWithOptions(request: AddAccountRelationRequest, runtime: Util.RuntimeOptions): AddAccountRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.childNick)) {
    query['ChildNick'] = request.childNick;
  }
  if (!Util.isUnset(request.childUserId)) {
    query['ChildUserId'] = request.childUserId;
  }
  if (!Util.isUnset(request.parentUserId)) {
    query['ParentUserId'] = request.parentUserId;
  }
  if (!Util.isUnset(request.permissionCodes)) {
    query['PermissionCodes'] = request.permissionCodes;
  }
  if (!Util.isUnset(request.relationType)) {
    query['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.roleCodes)) {
    query['RoleCodes'] = request.roleCodes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddAccountRelation',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAccountRelation(request: AddAccountRelationRequest): AddAccountRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAccountRelationWithOptions(request, runtime);
}

model AllocateCostUnitResourceRequest {
  fromUnitId?: long(name='FromUnitId'),
  fromUnitUserId?: long(name='FromUnitUserId'),
  resourceInstanceList?: [ 
    {
      apportionCode?: string(name='ApportionCode'),
      commodityCode?: string(name='CommodityCode'),
      resourceId?: string(name='ResourceId'),
      resourceUserId?: long(name='ResourceUserId'),
    }
  ](name='ResourceInstanceList'),
  toUnitId?: long(name='ToUnitId'),
  toUnitUserId?: long(name='ToUnitUserId'),
}

model AllocateCostUnitResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
    toUnitId?: long(name='ToUnitId'),
    toUnitUserId?: long(name='ToUnitUserId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AllocateCostUnitResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateCostUnitResourceResponseBody(name='body'),
}

async function allocateCostUnitResourceWithOptions(request: AllocateCostUnitResourceRequest, runtime: Util.RuntimeOptions): AllocateCostUnitResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fromUnitId)) {
    query['FromUnitId'] = request.fromUnitId;
  }
  if (!Util.isUnset(request.fromUnitUserId)) {
    query['FromUnitUserId'] = request.fromUnitUserId;
  }
  if (!Util.isUnset(request.resourceInstanceList)) {
    query['ResourceInstanceList'] = request.resourceInstanceList;
  }
  if (!Util.isUnset(request.toUnitId)) {
    query['ToUnitId'] = request.toUnitId;
  }
  if (!Util.isUnset(request.toUnitUserId)) {
    query['ToUnitUserId'] = request.toUnitUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateCostUnitResource',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateCostUnitResource(request: AllocateCostUnitResourceRequest): AllocateCostUnitResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateCostUnitResourceWithOptions(request, runtime);
}

model ApplyInvoiceRequest {
  addressId?: long(name='AddressId'),
  applyUserNick?: string(name='ApplyUserNick'),
  customerId?: long(name='CustomerId'),
  invoiceAmount?: long(name='InvoiceAmount'),
  invoiceByAmount?: boolean(name='InvoiceByAmount'),
  invoicingType?: int32(name='InvoicingType'),
  ownerId?: long(name='OwnerId'),
  processWay?: int32(name='ProcessWay'),
  selectedIds?: [ long ](name='SelectedIds'),
  userRemark?: string(name='UserRemark'),
}

model ApplyInvoiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    invoiceApplyId?: long(name='InvoiceApplyId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ApplyInvoiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyInvoiceResponseBody(name='body'),
}

async function applyInvoiceWithOptions(request: ApplyInvoiceRequest, runtime: Util.RuntimeOptions): ApplyInvoiceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.addressId)) {
    query['AddressId'] = request.addressId;
  }
  if (!Util.isUnset(request.applyUserNick)) {
    query['ApplyUserNick'] = request.applyUserNick;
  }
  if (!Util.isUnset(request.customerId)) {
    query['CustomerId'] = request.customerId;
  }
  if (!Util.isUnset(request.invoiceAmount)) {
    query['InvoiceAmount'] = request.invoiceAmount;
  }
  if (!Util.isUnset(request.invoiceByAmount)) {
    query['InvoiceByAmount'] = request.invoiceByAmount;
  }
  if (!Util.isUnset(request.invoicingType)) {
    query['InvoicingType'] = request.invoicingType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.processWay)) {
    query['ProcessWay'] = request.processWay;
  }
  if (!Util.isUnset(request.selectedIds)) {
    query['SelectedIds'] = request.selectedIds;
  }
  if (!Util.isUnset(request.userRemark)) {
    query['UserRemark'] = request.userRemark;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyInvoice',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyInvoice(request: ApplyInvoiceRequest): ApplyInvoiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyInvoiceWithOptions(request, runtime);
}

model CancelOrderRequest {
  orderId?: string(name='OrderId'),
  ownerId?: long(name='OwnerId'),
}

model CancelOrderResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelOrderResponseBody(name='body'),
}

async function cancelOrderWithOptions(request: CancelOrderRequest, runtime: Util.RuntimeOptions): CancelOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelOrder',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelOrder(request: CancelOrderRequest): CancelOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelOrderWithOptions(request, runtime);
}

model ChangeResellerConsumeAmountRequest {
  adjustType?: string(name='AdjustType'),
  amount?: string(name='Amount'),
  businessType?: string(name='BusinessType'),
  currency?: string(name='Currency'),
  extendMap?: string(name='ExtendMap'),
  outBizId?: string(name='OutBizId'),
  ownerId?: long(name='OwnerId'),
  source?: string(name='Source'),
}

model ChangeResellerConsumeAmountResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeResellerConsumeAmountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResellerConsumeAmountResponseBody(name='body'),
}

async function changeResellerConsumeAmountWithOptions(request: ChangeResellerConsumeAmountRequest, runtime: Util.RuntimeOptions): ChangeResellerConsumeAmountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.adjustType)) {
    query['AdjustType'] = request.adjustType;
  }
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.currency)) {
    query['Currency'] = request.currency;
  }
  if (!Util.isUnset(request.extendMap)) {
    query['ExtendMap'] = request.extendMap;
  }
  if (!Util.isUnset(request.outBizId)) {
    query['OutBizId'] = request.outBizId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResellerConsumeAmount',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResellerConsumeAmount(request: ChangeResellerConsumeAmountRequest): ChangeResellerConsumeAmountResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResellerConsumeAmountWithOptions(request, runtime);
}

model ConfirmRelationRequest {
  childUserId?: long(name='ChildUserId'),
  confirmCode?: string(name='ConfirmCode'),
  parentUserId?: long(name='ParentUserId'),
  permissionCodes?: [ string ](name='PermissionCodes'),
  relationId?: long(name='RelationId'),
  relationType?: string(name='RelationType'),
  requestId?: string(name='RequestId'),
}

model ConfirmRelationResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfirmRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmRelationResponseBody(name='body'),
}

async function confirmRelationWithOptions(request: ConfirmRelationRequest, runtime: Util.RuntimeOptions): ConfirmRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.childUserId)) {
    query['ChildUserId'] = request.childUserId;
  }
  if (!Util.isUnset(request.confirmCode)) {
    query['ConfirmCode'] = request.confirmCode;
  }
  if (!Util.isUnset(request.parentUserId)) {
    query['ParentUserId'] = request.parentUserId;
  }
  if (!Util.isUnset(request.permissionCodes)) {
    query['PermissionCodes'] = request.permissionCodes;
  }
  if (!Util.isUnset(request.relationId)) {
    query['RelationId'] = request.relationId;
  }
  if (!Util.isUnset(request.relationType)) {
    query['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmRelation',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmRelation(request: ConfirmRelationRequest): ConfirmRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmRelationWithOptions(request, runtime);
}

model ConvertChargeTypeRequest {
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model ConvertChargeTypeResponseBody = {
  code?: string(name='Code'),
  data?: {
    orderId?: string(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConvertChargeTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConvertChargeTypeResponseBody(name='body'),
}

async function convertChargeTypeWithOptions(request: ConvertChargeTypeRequest, runtime: Util.RuntimeOptions): ConvertChargeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConvertChargeType',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function convertChargeType(request: ConvertChargeTypeRequest): ConvertChargeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return convertChargeTypeWithOptions(request, runtime);
}

model CreateAgAccountRequest {
  accountAttr?: string(name='AccountAttr'),
  cityName?: string(name='CityName'),
  enterpriseName?: string(name='EnterpriseName'),
  firstName?: string(name='FirstName'),
  lastName?: string(name='LastName'),
  loginEmail?: string(name='LoginEmail'),
  nationCode?: string(name='NationCode'),
  postcode?: string(name='Postcode'),
  provinceName?: string(name='ProvinceName'),
}

model CreateAgAccountResponseBody = {
  agRelationDto?: {
    mpk?: string(name='Mpk'),
    pk?: string(name='Pk'),
    ramAdminRoleName?: string(name='RamAdminRoleName'),
    type?: string(name='Type'),
  }(name='AgRelationDto'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAgAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAgAccountResponseBody(name='body'),
}

async function createAgAccountWithOptions(request: CreateAgAccountRequest, runtime: Util.RuntimeOptions): CreateAgAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountAttr)) {
    query['AccountAttr'] = request.accountAttr;
  }
  if (!Util.isUnset(request.cityName)) {
    query['CityName'] = request.cityName;
  }
  if (!Util.isUnset(request.enterpriseName)) {
    query['EnterpriseName'] = request.enterpriseName;
  }
  if (!Util.isUnset(request.firstName)) {
    query['FirstName'] = request.firstName;
  }
  if (!Util.isUnset(request.lastName)) {
    query['LastName'] = request.lastName;
  }
  if (!Util.isUnset(request.loginEmail)) {
    query['LoginEmail'] = request.loginEmail;
  }
  if (!Util.isUnset(request.nationCode)) {
    query['NationCode'] = request.nationCode;
  }
  if (!Util.isUnset(request.postcode)) {
    query['Postcode'] = request.postcode;
  }
  if (!Util.isUnset(request.provinceName)) {
    query['ProvinceName'] = request.provinceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAgAccount',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAgAccount(request: CreateAgAccountRequest): CreateAgAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAgAccountWithOptions(request, runtime);
}

model CreateCostUnitRequest {
  unitEntityList?: [ 
    {
      ownerUid?: long(name='OwnerUid'),
      parentUnitId?: long(name='ParentUnitId'),
      unitName?: string(name='UnitName'),
    }
  ](name='UnitEntityList'),
}

model CreateCostUnitResponseBody = {
  code?: string(name='Code'),
  data?: {
    costUnitDtoList?: [ 
      {
        ownerUid?: long(name='OwnerUid'),
        parentUnitId?: long(name='ParentUnitId'),
        unitId?: long(name='UnitId'),
        unitName?: string(name='UnitName'),
      }
    ](name='CostUnitDtoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCostUnitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCostUnitResponseBody(name='body'),
}

async function createCostUnitWithOptions(request: CreateCostUnitRequest, runtime: Util.RuntimeOptions): CreateCostUnitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.unitEntityList)) {
    query['UnitEntityList'] = request.unitEntityList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCostUnit',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCostUnit(request: CreateCostUnitRequest): CreateCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCostUnitWithOptions(request, runtime);
}

model CreateInstanceRequest {
  clientToken?: string(name='ClientToken'),
  logistics?: string(name='Logistics'),
  ownerId?: long(name='OwnerId'),
  parameter?: [ 
    {
      code?: string(name='Code'),
      value?: string(name='Value'),
    }
  ](name='Parameter'),
  period?: int32(name='Period'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  renewPeriod?: int32(name='RenewPeriod'),
  renewalStatus?: string(name='RenewalStatus'),
  subscriptionType?: string(name='SubscriptionType'),
}

model CreateInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    instanceId?: string(name='InstanceId'),
    orderId?: string(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstanceWithOptions(request: CreateInstanceRequest, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.logistics)) {
    query['Logistics'] = request.logistics;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameter)) {
    query['Parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.renewPeriod)) {
    query['RenewPeriod'] = request.renewPeriod;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstance(request: CreateInstanceRequest): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceWithOptions(request, runtime);
}

model CreateResellerUserQuotaRequest {
  amount?: string(name='Amount'),
  currency?: string(name='Currency'),
  outBizId?: string(name='OutBizId'),
  ownerId?: long(name='OwnerId'),
}

model CreateResellerUserQuotaResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateResellerUserQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResellerUserQuotaResponseBody(name='body'),
}

async function createResellerUserQuotaWithOptions(request: CreateResellerUserQuotaRequest, runtime: Util.RuntimeOptions): CreateResellerUserQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.currency)) {
    query['Currency'] = request.currency;
  }
  if (!Util.isUnset(request.outBizId)) {
    query['OutBizId'] = request.outBizId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateResellerUserQuota',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResellerUserQuota(request: CreateResellerUserQuotaRequest): CreateResellerUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResellerUserQuotaWithOptions(request, runtime);
}

model CreateResourcePackageRequest {
  duration?: int32(name='Duration'),
  effectiveDate?: string(name='EffectiveDate'),
  ownerId?: long(name='OwnerId'),
  packageType?: string(name='PackageType'),
  pricingCycle?: string(name='PricingCycle'),
  productCode?: string(name='ProductCode'),
  specification?: string(name='Specification'),
}

model CreateResourcePackageResponseBody = {
  code?: string(name='Code'),
  data?: {
    instanceId?: string(name='InstanceId'),
    orderId?: long(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourcePackageResponseBody(name='body'),
}

async function createResourcePackageWithOptions(request: CreateResourcePackageRequest, runtime: Util.RuntimeOptions): CreateResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.effectiveDate)) {
    query['EffectiveDate'] = request.effectiveDate;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourcePackage',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourcePackage(request: CreateResourcePackageRequest): CreateResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourcePackageWithOptions(request, runtime);
}

model CreateSavingsPlansInstanceRequest {
  commodityCode?: string(name='CommodityCode'),
  duration?: string(name='Duration'),
  effectiveDate?: string(name='EffectiveDate'),
  payMode?: string(name='PayMode'),
  poolValue?: string(name='PoolValue'),
  pricingCycle?: string(name='PricingCycle'),
  region?: string(name='Region'),
  specType?: string(name='SpecType'),
  specification?: string(name='Specification'),
  type?: string(name='Type'),
}

model CreateSavingsPlansInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    orderId?: long(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSavingsPlansInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSavingsPlansInstanceResponseBody(name='body'),
}

async function createSavingsPlansInstanceWithOptions(request: CreateSavingsPlansInstanceRequest, runtime: Util.RuntimeOptions): CreateSavingsPlansInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.effectiveDate)) {
    query['EffectiveDate'] = request.effectiveDate;
  }
  if (!Util.isUnset(request.payMode)) {
    query['PayMode'] = request.payMode;
  }
  if (!Util.isUnset(request.poolValue)) {
    query['PoolValue'] = request.poolValue;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.specType)) {
    query['SpecType'] = request.specType;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSavingsPlansInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSavingsPlansInstance(request: CreateSavingsPlansInstanceRequest): CreateSavingsPlansInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSavingsPlansInstanceWithOptions(request, runtime);
}

model DeleteCostUnitRequest {
  ownerUid?: long(name='OwnerUid'),
  unitId?: long(name='UnitId'),
}

model DeleteCostUnitResponseBody = {
  code?: string(name='Code'),
  data?: {
    isSuccess?: boolean(name='IsSuccess'),
    ownerUid?: long(name='OwnerUid'),
    unitId?: long(name='UnitId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteCostUnitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCostUnitResponseBody(name='body'),
}

async function deleteCostUnitWithOptions(request: DeleteCostUnitRequest, runtime: Util.RuntimeOptions): DeleteCostUnitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerUid)) {
    query['OwnerUid'] = request.ownerUid;
  }
  if (!Util.isUnset(request.unitId)) {
    query['UnitId'] = request.unitId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCostUnit',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCostUnit(request: DeleteCostUnitRequest): DeleteCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCostUnitWithOptions(request, runtime);
}

model DescribeInstanceBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  billingDate?: string(name='BillingDate'),
  granularity?: string(name='Granularity'),
  instanceID?: string(name='InstanceID'),
  isBillingItem?: boolean(name='IsBillingItem'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model DescribeInstanceBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        billAccountID?: string(name='BillAccountID'),
        billAccountName?: string(name='BillAccountName'),
        billingDate?: string(name='BillingDate'),
        billingItem?: string(name='BillingItem'),
        billingItemCode?: string(name='BillingItemCode'),
        billingType?: string(name='BillingType'),
        bizType?: string(name='BizType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        costUnit?: string(name='CostUnit'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        deductedByResourcePackage?: string(name='DeductedByResourcePackage'),
        instanceConfig?: string(name='InstanceConfig'),
        instanceID?: string(name='InstanceID'),
        instanceSpec?: string(name='InstanceSpec'),
        internetIP?: string(name='InternetIP'),
        intranetIP?: string(name='IntranetIP'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        itemName?: string(name='ItemName'),
        listPrice?: string(name='ListPrice'),
        listPriceUnit?: string(name='ListPriceUnit'),
        nickName?: string(name='NickName'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        servicePeriod?: string(name='ServicePeriod'),
        servicePeriodUnit?: string(name='ServicePeriodUnit'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        usage?: string(name='Usage'),
        usageUnit?: string(name='UsageUnit'),
        zone?: string(name='Zone'),
      }
    ](name='Items'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeInstanceBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceBillResponseBody(name='body'),
}

async function describeInstanceBillWithOptions(request: DescribeInstanceBillRequest, runtime: Util.RuntimeOptions): DescribeInstanceBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.billingDate)) {
    query['BillingDate'] = request.billingDate;
  }
  if (!Util.isUnset(request.granularity)) {
    query['Granularity'] = request.granularity;
  }
  if (!Util.isUnset(request.instanceID)) {
    query['InstanceID'] = request.instanceID;
  }
  if (!Util.isUnset(request.isBillingItem)) {
    query['IsBillingItem'] = request.isBillingItem;
  }
  if (!Util.isUnset(request.isHideZeroCharge)) {
    query['IsHideZeroCharge'] = request.isHideZeroCharge;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceBill(request: DescribeInstanceBillRequest): DescribeInstanceBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceBillWithOptions(request, runtime);
}

model DescribePricingModuleRequest {
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model DescribePricingModuleResponseBody = {
  code?: string(name='Code'),
  data?: {
    attributeList?: {
      attribute?: [ 
      {
        code?: string(name='Code'),
        name?: string(name='Name'),
        unit?: string(name='Unit'),
        values?: {
          attributeValue?: [ 
          {
            name?: string(name='Name'),
            remark?: string(name='Remark'),
            type?: string(name='Type'),
            value?: string(name='Value'),
          }
        ](name='AttributeValue')
        }(name='Values'),
      }
    ](name='Attribute')
    }(name='AttributeList'),
    moduleList?: {
      module?: [ 
      {
        configList?: {
          configList?: [ string ](name='ConfigList')
        }(name='ConfigList'),
        currency?: string(name='Currency'),
        moduleCode?: string(name='ModuleCode'),
        moduleName?: string(name='ModuleName'),
        priceType?: string(name='PriceType'),
      }
    ](name='Module')
    }(name='ModuleList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribePricingModuleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePricingModuleResponseBody(name='body'),
}

async function describePricingModuleWithOptions(request: DescribePricingModuleRequest, runtime: Util.RuntimeOptions): DescribePricingModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePricingModule',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePricingModule(request: DescribePricingModuleRequest): DescribePricingModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePricingModuleWithOptions(request, runtime);
}

model DescribeResourceCoverageDetailRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  periodType?: string(name='PeriodType'),
  resourceType?: string(name='ResourceType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeResourceCoverageDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        capacityUnit?: string(name='CapacityUnit'),
        commodityCode?: string(name='CommodityCode'),
        commodityName?: string(name='CommodityName'),
        coveragePercentage?: float(name='CoveragePercentage'),
        currency?: string(name='Currency'),
        deductQuantity?: float(name='DeductQuantity'),
        endTime?: string(name='EndTime'),
        instanceId?: string(name='InstanceId'),
        instanceSpec?: string(name='InstanceSpec'),
        paymentAmount?: float(name='PaymentAmount'),
        productCode?: string(name='ProductCode'),
        productName?: string(name='ProductName'),
        region?: string(name='Region'),
        regionNo?: string(name='RegionNo'),
        startTime?: string(name='StartTime'),
        totalQuantity?: float(name='TotalQuantity'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
        zone?: string(name='Zone'),
        zoneName?: string(name='ZoneName'),
      }
    ](name='Items'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceCoverageDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceCoverageDetailResponseBody(name='body'),
}

async function describeResourceCoverageDetailWithOptions(request: DescribeResourceCoverageDetailRequest, runtime: Util.RuntimeOptions): DescribeResourceCoverageDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceCoverageDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceCoverageDetail(request: DescribeResourceCoverageDetailRequest): DescribeResourceCoverageDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceCoverageDetailWithOptions(request, runtime);
}

model DescribeResourceCoverageTotalRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  periodType?: string(name='PeriodType'),
  resourceType?: string(name='ResourceType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeResourceCoverageTotalResponseBody = {
  code?: string(name='Code'),
  data?: {
    periodCoverage?: [ 
      {
        coveragePercentage?: float(name='CoveragePercentage'),
        period?: string(name='Period'),
      }
    ](name='PeriodCoverage'),
    totalCoverage?: {
      capacityUnit?: string(name='CapacityUnit'),
      coveragePercentage?: float(name='CoveragePercentage'),
      deductQuantity?: float(name='DeductQuantity'),
      totalQuantity?: float(name='TotalQuantity'),
    }(name='TotalCoverage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceCoverageTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceCoverageTotalResponseBody(name='body'),
}

async function describeResourceCoverageTotalWithOptions(request: DescribeResourceCoverageTotalRequest, runtime: Util.RuntimeOptions): DescribeResourceCoverageTotalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceCoverageTotal',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceCoverageTotal(request: DescribeResourceCoverageTotalRequest): DescribeResourceCoverageTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceCoverageTotalWithOptions(request, runtime);
}

model DescribeResourcePackageProductRequest {
  productCode?: string(name='ProductCode'),
}

model DescribeResourcePackageProductResponseBody = {
  code?: string(name='Code'),
  data?: {
    resourcePackages?: {
      resourcePackage?: [ 
      {
        name?: string(name='Name'),
        packageTypes?: {
          packageType?: [ 
          {
            code?: string(name='Code'),
            name?: string(name='Name'),
            properties?: {
              property?: [ 
              {
                name?: string(name='Name'),
                value?: string(name='Value'),
              }
            ](name='Property')
            }(name='Properties'),
            specifications?: {
              specification?: [ 
              {
                availableDurations?: {
                  availableDuration?: [ 
                  {
                    name?: string(name='Name'),
                    unit?: string(name='Unit'),
                    value?: int32(name='Value'),
                  }
                ](name='AvailableDuration')
                }(name='AvailableDurations'),
                name?: string(name='Name'),
                value?: string(name='Value'),
              }
            ](name='Specification')
            }(name='Specifications'),
          }
        ](name='PackageType')
        }(name='PackageTypes'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
      }
    ](name='ResourcePackage')
    }(name='ResourcePackages'),
  }(name='Data'),
  message?: string(name='Message'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourcePackageProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourcePackageProductResponseBody(name='body'),
}

async function describeResourcePackageProductWithOptions(request: DescribeResourcePackageProductRequest, runtime: Util.RuntimeOptions): DescribeResourcePackageProductResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourcePackageProduct',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourcePackageProduct(request: DescribeResourcePackageProductRequest): DescribeResourcePackageProductResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourcePackageProductWithOptions(request, runtime);
}

model DescribeResourceUsageDetailRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  periodType?: string(name='PeriodType'),
  resourceType?: string(name='ResourceType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeResourceUsageDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        capacityUnit?: string(name='CapacityUnit'),
        currency?: string(name='Currency'),
        deductQuantity?: float(name='DeductQuantity'),
        endTime?: string(name='EndTime'),
        imageType?: string(name='ImageType'),
        instanceSpec?: string(name='InstanceSpec'),
        postpaidCost?: string(name='PostpaidCost'),
        potentialSavedCost?: string(name='PotentialSavedCost'),
        quantity?: long(name='Quantity'),
        region?: string(name='Region'),
        regionNo?: string(name='RegionNo'),
        reservationCost?: string(name='ReservationCost'),
        resourceInstanceId?: string(name='ResourceInstanceId'),
        savedCost?: string(name='SavedCost'),
        startTime?: string(name='StartTime'),
        status?: string(name='Status'),
        statusName?: string(name='StatusName'),
        totalQuantity?: float(name='TotalQuantity'),
        usagePercentage?: float(name='UsagePercentage'),
        userId?: string(name='UserId'),
        userName?: string(name='UserName'),
        zone?: string(name='Zone'),
        zoneName?: string(name='ZoneName'),
      }
    ](name='Items'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceUsageDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceUsageDetailResponseBody(name='body'),
}

async function describeResourceUsageDetailWithOptions(request: DescribeResourceUsageDetailRequest, runtime: Util.RuntimeOptions): DescribeResourceUsageDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceUsageDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceUsageDetail(request: DescribeResourceUsageDetailRequest): DescribeResourceUsageDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceUsageDetailWithOptions(request, runtime);
}

model DescribeResourceUsageTotalRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  periodType?: string(name='PeriodType'),
  resourceType?: string(name='ResourceType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeResourceUsageTotalResponseBody = {
  code?: string(name='Code'),
  data?: {
    periodCoverage?: [ 
      {
        period?: string(name='Period'),
        usagePercentage?: float(name='UsagePercentage'),
      }
    ](name='PeriodCoverage'),
    totalUsage?: {
      postpaidCost?: float(name='PostpaidCost'),
      potentialSavedCost?: float(name='PotentialSavedCost'),
      reservationCost?: float(name='ReservationCost'),
      savedCost?: float(name='SavedCost'),
      usagePercentage?: float(name='UsagePercentage'),
    }(name='TotalUsage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceUsageTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceUsageTotalResponseBody(name='body'),
}

async function describeResourceUsageTotalWithOptions(request: DescribeResourceUsageTotalRequest, runtime: Util.RuntimeOptions): DescribeResourceUsageTotalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceUsageTotal',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceUsageTotal(request: DescribeResourceUsageTotalRequest): DescribeResourceUsageTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceUsageTotalWithOptions(request, runtime);
}

model DescribeSavingsPlansCoverageDetailRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  maxResults?: int32(name='MaxResults'),
  periodType?: string(name='PeriodType'),
  startPeriod?: string(name='StartPeriod'),
  token?: string(name='Token'),
}

model DescribeSavingsPlansCoverageDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        coveragePercentage?: float(name='CoveragePercentage'),
        currency?: string(name='Currency'),
        deductAmount?: float(name='DeductAmount'),
        endPeriod?: string(name='EndPeriod'),
        instanceId?: string(name='InstanceId'),
        instanceSpec?: string(name='InstanceSpec'),
        postpaidCost?: float(name='PostpaidCost'),
        region?: string(name='Region'),
        startPeriod?: string(name='StartPeriod'),
        totalAmount?: float(name='TotalAmount'),
        userId?: long(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='Items'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSavingsPlansCoverageDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSavingsPlansCoverageDetailResponseBody(name='body'),
}

async function describeSavingsPlansCoverageDetailWithOptions(request: DescribeSavingsPlansCoverageDetailRequest, runtime: Util.RuntimeOptions): DescribeSavingsPlansCoverageDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSavingsPlansCoverageDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSavingsPlansCoverageDetail(request: DescribeSavingsPlansCoverageDetailRequest): DescribeSavingsPlansCoverageDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSavingsPlansCoverageDetailWithOptions(request, runtime);
}

model DescribeSavingsPlansCoverageTotalRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  periodType?: string(name='PeriodType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeSavingsPlansCoverageTotalResponseBody = {
  code?: string(name='Code'),
  data?: {
    periodCoverage?: [ 
      {
        percentage?: float(name='Percentage'),
        period?: string(name='Period'),
      }
    ](name='PeriodCoverage'),
    totalCoverage?: {
      coveragePercentage?: float(name='CoveragePercentage'),
      deductAmount?: float(name='DeductAmount'),
    }(name='TotalCoverage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSavingsPlansCoverageTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSavingsPlansCoverageTotalResponseBody(name='body'),
}

async function describeSavingsPlansCoverageTotalWithOptions(request: DescribeSavingsPlansCoverageTotalRequest, runtime: Util.RuntimeOptions): DescribeSavingsPlansCoverageTotalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSavingsPlansCoverageTotal',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSavingsPlansCoverageTotal(request: DescribeSavingsPlansCoverageTotalRequest): DescribeSavingsPlansCoverageTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSavingsPlansCoverageTotalWithOptions(request, runtime);
}

model DescribeSavingsPlansUsageDetailRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  maxResults?: int32(name='MaxResults'),
  periodType?: string(name='PeriodType'),
  startPeriod?: string(name='StartPeriod'),
  token?: string(name='Token'),
}

model DescribeSavingsPlansUsageDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        currency?: string(name='Currency'),
        deductValue?: float(name='DeductValue'),
        endPeriod?: string(name='EndPeriod'),
        instanceId?: string(name='InstanceId'),
        poolValue?: float(name='PoolValue'),
        postpaidCost?: float(name='PostpaidCost'),
        savedCost?: float(name='SavedCost'),
        startPeriod?: string(name='StartPeriod'),
        status?: string(name='Status'),
        type?: string(name='Type'),
        usagePercentage?: float(name='UsagePercentage'),
        userId?: long(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='Items'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSavingsPlansUsageDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSavingsPlansUsageDetailResponseBody(name='body'),
}

async function describeSavingsPlansUsageDetailWithOptions(request: DescribeSavingsPlansUsageDetailRequest, runtime: Util.RuntimeOptions): DescribeSavingsPlansUsageDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSavingsPlansUsageDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSavingsPlansUsageDetail(request: DescribeSavingsPlansUsageDetailRequest): DescribeSavingsPlansUsageDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSavingsPlansUsageDetailWithOptions(request, runtime);
}

model DescribeSavingsPlansUsageTotalRequest {
  billOwnerId?: long(name='BillOwnerId'),
  endPeriod?: string(name='EndPeriod'),
  periodType?: string(name='PeriodType'),
  startPeriod?: string(name='StartPeriod'),
}

model DescribeSavingsPlansUsageTotalResponseBody = {
  code?: string(name='Code'),
  data?: {
    periodCoverage?: [ 
      {
        percentage?: float(name='Percentage'),
        period?: string(name='Period'),
      }
    ](name='PeriodCoverage'),
    totalUsage?: {
      poolValue?: float(name='PoolValue'),
      postpaidCost?: float(name='PostpaidCost'),
      savedCost?: float(name='SavedCost'),
      usagePercentage?: float(name='UsagePercentage'),
    }(name='TotalUsage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSavingsPlansUsageTotalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSavingsPlansUsageTotalResponseBody(name='body'),
}

async function describeSavingsPlansUsageTotalWithOptions(request: DescribeSavingsPlansUsageTotalRequest, runtime: Util.RuntimeOptions): DescribeSavingsPlansUsageTotalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.endPeriod)) {
    query['EndPeriod'] = request.endPeriod;
  }
  if (!Util.isUnset(request.periodType)) {
    query['PeriodType'] = request.periodType;
  }
  if (!Util.isUnset(request.startPeriod)) {
    query['StartPeriod'] = request.startPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSavingsPlansUsageTotal',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSavingsPlansUsageTotal(request: DescribeSavingsPlansUsageTotalRequest): DescribeSavingsPlansUsageTotalResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSavingsPlansUsageTotalWithOptions(request, runtime);
}

model DescribeSplitItemBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  billingDate?: string(name='BillingDate'),
  granularity?: string(name='Granularity'),
  instanceID?: string(name='InstanceID'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  splitItemID?: string(name='SplitItemID'),
  subscriptionType?: string(name='SubscriptionType'),
  tagFilter?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValues?: [ string ](name='TagValues'),
    }
  ](name='TagFilter'),
}

model DescribeSplitItemBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        billAccountID?: string(name='BillAccountID'),
        billAccountName?: string(name='BillAccountName'),
        billingDate?: string(name='BillingDate'),
        billingItem?: string(name='BillingItem'),
        billingItemCode?: string(name='BillingItemCode'),
        billingType?: string(name='BillingType'),
        bizType?: string(name='BizType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        costUnit?: string(name='CostUnit'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        deductedByResourcePackage?: string(name='DeductedByResourcePackage'),
        instanceConfig?: string(name='InstanceConfig'),
        instanceID?: string(name='InstanceID'),
        instanceSpec?: string(name='InstanceSpec'),
        internetIP?: string(name='InternetIP'),
        intranetIP?: string(name='IntranetIP'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        itemName?: string(name='ItemName'),
        listPrice?: string(name='ListPrice'),
        listPriceUnit?: string(name='ListPriceUnit'),
        nickName?: string(name='NickName'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        servicePeriod?: string(name='ServicePeriod'),
        servicePeriodUnit?: string(name='ServicePeriodUnit'),
        splitAccountID?: string(name='SplitAccountID'),
        splitAccountName?: string(name='SplitAccountName'),
        splitBillingCycle?: string(name='SplitBillingCycle'),
        splitBillingDate?: string(name='SplitBillingDate'),
        splitCommodityCode?: string(name='SplitCommodityCode'),
        splitItemID?: string(name='SplitItemID'),
        splitItemName?: string(name='SplitItemName'),
        splitProductDetail?: string(name='SplitProductDetail'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        usage?: string(name='Usage'),
        usageUnit?: string(name='UsageUnit'),
        zone?: string(name='Zone'),
      }
    ](name='Items'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeSplitItemBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSplitItemBillResponseBody(name='body'),
}

async function describeSplitItemBillWithOptions(request: DescribeSplitItemBillRequest, runtime: Util.RuntimeOptions): DescribeSplitItemBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.billingDate)) {
    query['BillingDate'] = request.billingDate;
  }
  if (!Util.isUnset(request.granularity)) {
    query['Granularity'] = request.granularity;
  }
  if (!Util.isUnset(request.instanceID)) {
    query['InstanceID'] = request.instanceID;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.splitItemID)) {
    query['SplitItemID'] = request.splitItemID;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  if (!Util.isUnset(request.tagFilter)) {
    query['TagFilter'] = request.tagFilter;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSplitItemBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSplitItemBill(request: DescribeSplitItemBillRequest): DescribeSplitItemBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSplitItemBillWithOptions(request, runtime);
}

model EnableBillGenerationRequest {
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
}

model EnableBillGenerationResponseBody = {
  code?: string(name='Code'),
  data?: {
    boolean?: boolean(name='Boolean'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableBillGenerationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableBillGenerationResponseBody(name='body'),
}

async function enableBillGenerationWithOptions(request: EnableBillGenerationRequest, runtime: Util.RuntimeOptions): EnableBillGenerationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableBillGeneration',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableBillGeneration(request: EnableBillGenerationRequest): EnableBillGenerationResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBillGenerationWithOptions(request, runtime);
}

model GetAccountRelationRequest {
  relationId?: long(name='RelationId'),
  requestId?: string(name='RequestId'),
}

model GetAccountRelationResponseBody = {
  code?: string(name='Code'),
  data?: {
    childUserId?: long(name='ChildUserId'),
    endTime?: long(name='EndTime'),
    gmtModified?: long(name='GmtModified'),
    id?: long(name='Id'),
    parentUserId?: long(name='ParentUserId'),
    startTime?: long(name='StartTime'),
    status?: string(name='Status'),
    type?: string(name='Type'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAccountRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAccountRelationResponseBody(name='body'),
}

async function getAccountRelationWithOptions(request: GetAccountRelationRequest, runtime: Util.RuntimeOptions): GetAccountRelationResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAccountRelation',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAccountRelation(request: GetAccountRelationRequest): GetAccountRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAccountRelationWithOptions(request, runtime);
}

model GetCustomerAccountInfoRequest {
  ownerId?: long(name='OwnerId'),
}

model GetCustomerAccountInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountType?: string(name='AccountType'),
    creditLimitStatus?: string(name='CreditLimitStatus'),
    hostingStatus?: string(name='HostingStatus'),
    isCertified?: boolean(name='IsCertified'),
    loginEmail?: string(name='LoginEmail'),
    mpk?: long(name='Mpk'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCustomerAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomerAccountInfoResponseBody(name='body'),
}

async function getCustomerAccountInfoWithOptions(request: GetCustomerAccountInfoRequest, runtime: Util.RuntimeOptions): GetCustomerAccountInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCustomerAccountInfo',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomerAccountInfo(request: GetCustomerAccountInfoRequest): GetCustomerAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerAccountInfoWithOptions(request, runtime);
}

model GetCustomerListResponseBody = {
  code?: string(name='Code'),
  data?: {
    uidList?: [ string ](name='UidList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCustomerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCustomerListResponseBody(name='body'),
}

async function getCustomerListWithOptions(runtime: Util.RuntimeOptions): GetCustomerListResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCustomerList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCustomerList(): GetCustomerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCustomerListWithOptions(runtime);
}

model GetOrderDetailRequest {
  orderId?: string(name='OrderId'),
  ownerId?: long(name='OwnerId'),
}

model GetOrderDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostName?: string(name='HostName'),
    orderList?: {
      order?: [ 
      {
        afterTaxAmount?: string(name='AfterTaxAmount'),
        commodityCode?: string(name='CommodityCode'),
        config?: string(name='Config'),
        createTime?: string(name='CreateTime'),
        currency?: string(name='Currency'),
        instanceIDs?: string(name='InstanceIDs'),
        operator?: string(name='Operator'),
        orderId?: string(name='OrderId'),
        orderSubType?: string(name='OrderSubType'),
        orderType?: string(name='OrderType'),
        originalConfig?: string(name='OriginalConfig'),
        paymentCurrency?: string(name='PaymentCurrency'),
        paymentStatus?: string(name='PaymentStatus'),
        paymentTime?: string(name='PaymentTime'),
        pretaxAmount?: string(name='PretaxAmount'),
        pretaxAmountLocal?: string(name='PretaxAmountLocal'),
        pretaxGrossAmount?: string(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        quantity?: string(name='Quantity'),
        region?: string(name='Region'),
        relatedOrderId?: string(name='RelatedOrderId'),
        subOrderId?: string(name='SubOrderId'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: string(name='Tax'),
        usageEndTime?: string(name='UsageEndTime'),
        usageStartTime?: string(name='UsageStartTime'),
      }
    ](name='Order')
    }(name='OrderList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetOrderDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOrderDetailResponseBody(name='body'),
}

async function getOrderDetailWithOptions(request: GetOrderDetailRequest, runtime: Util.RuntimeOptions): GetOrderDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOrderDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOrderDetail(request: GetOrderDetailRequest): GetOrderDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOrderDetailWithOptions(request, runtime);
}

model GetPayAsYouGoPriceRequest {
  moduleList?: [ 
    {
      config?: string(name='Config'),
      moduleCode?: string(name='ModuleCode'),
      priceType?: string(name='PriceType'),
    }
  ](name='ModuleList'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  region?: string(name='Region'),
  subscriptionType?: string(name='SubscriptionType'),
}

model GetPayAsYouGoPriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currency?: string(name='Currency'),
    moduleDetails?: {
      moduleDetail?: [ 
      {
        costAfterDiscount?: float(name='CostAfterDiscount'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        moduleCode?: string(name='ModuleCode'),
        originalCost?: float(name='OriginalCost'),
        unitPrice?: float(name='UnitPrice'),
      }
    ](name='ModuleDetail')
    }(name='ModuleDetails'),
    promotionDetails?: {
      promotionDetail?: [ 
      {
        promotionDesc?: string(name='PromotionDesc'),
        promotionId?: long(name='PromotionId'),
        promotionName?: string(name='PromotionName'),
      }
    ](name='PromotionDetail')
    }(name='PromotionDetails'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetPayAsYouGoPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPayAsYouGoPriceResponseBody(name='body'),
}

async function getPayAsYouGoPriceWithOptions(request: GetPayAsYouGoPriceRequest, runtime: Util.RuntimeOptions): GetPayAsYouGoPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleList)) {
    query['ModuleList'] = request.moduleList;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPayAsYouGoPrice',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPayAsYouGoPrice(request: GetPayAsYouGoPriceRequest): GetPayAsYouGoPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPayAsYouGoPriceWithOptions(request, runtime);
}

model GetResourcePackagePriceRequest {
  duration?: int32(name='Duration'),
  effectiveDate?: string(name='EffectiveDate'),
  instanceId?: string(name='InstanceId'),
  orderType?: string(name='OrderType'),
  ownerId?: long(name='OwnerId'),
  packageType?: string(name='PackageType'),
  pricingCycle?: string(name='PricingCycle'),
  productCode?: string(name='ProductCode'),
  specification?: string(name='Specification'),
}

model GetResourcePackagePriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    promotions?: {
      promotion?: [ 
      {
        id?: long(name='Id'),
        name?: string(name='Name'),
      }
    ](name='Promotion')
    }(name='Promotions'),
    tradePrice?: float(name='TradePrice'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetResourcePackagePriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetResourcePackagePriceResponseBody(name='body'),
}

async function getResourcePackagePriceWithOptions(request: GetResourcePackagePriceRequest, runtime: Util.RuntimeOptions): GetResourcePackagePriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.effectiveDate)) {
    query['EffectiveDate'] = request.effectiveDate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.packageType)) {
    query['PackageType'] = request.packageType;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourcePackagePrice',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourcePackagePrice(request: GetResourcePackagePriceRequest): GetResourcePackagePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourcePackagePriceWithOptions(request, runtime);
}

model GetSubscriptionPriceRequest {
  instanceId?: string(name='InstanceId'),
  moduleList?: [ 
    {
      config?: string(name='Config'),
      moduleCode?: string(name='ModuleCode'),
      moduleStatus?: int32(name='ModuleStatus'),
      tag?: string(name='Tag'),
    }
  ](name='ModuleList'),
  orderType?: string(name='OrderType'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  quantity?: int32(name='Quantity'),
  region?: string(name='Region'),
  servicePeriodQuantity?: int32(name='ServicePeriodQuantity'),
  servicePeriodUnit?: string(name='ServicePeriodUnit'),
  subscriptionType?: string(name='SubscriptionType'),
}

model GetSubscriptionPriceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    moduleDetails?: {
      moduleDetail?: [ 
      {
        costAfterDiscount?: float(name='CostAfterDiscount'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        moduleCode?: string(name='ModuleCode'),
        originalCost?: float(name='OriginalCost'),
        unitPrice?: float(name='UnitPrice'),
      }
    ](name='ModuleDetail')
    }(name='ModuleDetails'),
    originalPrice?: float(name='OriginalPrice'),
    promotionDetails?: {
      promotionDetail?: [ 
      {
        promotionDesc?: string(name='PromotionDesc'),
        promotionId?: long(name='PromotionId'),
        promotionName?: string(name='PromotionName'),
      }
    ](name='PromotionDetail')
    }(name='PromotionDetails'),
    quantity?: int32(name='Quantity'),
    tradePrice?: float(name='TradePrice'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSubscriptionPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSubscriptionPriceResponseBody(name='body'),
}

async function getSubscriptionPriceWithOptions(request: GetSubscriptionPriceRequest, runtime: Util.RuntimeOptions): GetSubscriptionPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.moduleList)) {
    query['ModuleList'] = request.moduleList;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.servicePeriodQuantity)) {
    query['ServicePeriodQuantity'] = request.servicePeriodQuantity;
  }
  if (!Util.isUnset(request.servicePeriodUnit)) {
    query['ServicePeriodUnit'] = request.servicePeriodUnit;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSubscriptionPrice',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSubscriptionPrice(request: GetSubscriptionPriceRequest): GetSubscriptionPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSubscriptionPriceWithOptions(request, runtime);
}

model InquiryPriceRefundInstanceRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
}

model InquiryPriceRefundInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    currency?: string(name='Currency'),
    hostId?: string(name='HostId'),
    instanceId?: string(name='InstanceId'),
    refundAmount?: double(name='RefundAmount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InquiryPriceRefundInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InquiryPriceRefundInstanceResponseBody(name='body'),
}

async function inquiryPriceRefundInstanceWithOptions(request: InquiryPriceRefundInstanceRequest, runtime: Util.RuntimeOptions): InquiryPriceRefundInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InquiryPriceRefundInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function inquiryPriceRefundInstance(request: InquiryPriceRefundInstanceRequest): InquiryPriceRefundInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return inquiryPriceRefundInstanceWithOptions(request, runtime);
}

model ModifyAccountRelationRequest {
  childNick?: string(name='ChildNick'),
  childUserId?: long(name='ChildUserId'),
  parentUserId?: long(name='ParentUserId'),
  permissionCodes?: [ string ](name='PermissionCodes'),
  relationId?: long(name='RelationId'),
  relationOperation?: string(name='RelationOperation'),
  relationType?: string(name='RelationType'),
  requestId?: string(name='RequestId'),
  roleCodes?: [ string ](name='RoleCodes'),
}

model ModifyAccountRelationResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyAccountRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccountRelationResponseBody(name='body'),
}

async function modifyAccountRelationWithOptions(request: ModifyAccountRelationRequest, runtime: Util.RuntimeOptions): ModifyAccountRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.childNick)) {
    query['ChildNick'] = request.childNick;
  }
  if (!Util.isUnset(request.childUserId)) {
    query['ChildUserId'] = request.childUserId;
  }
  if (!Util.isUnset(request.parentUserId)) {
    query['ParentUserId'] = request.parentUserId;
  }
  if (!Util.isUnset(request.permissionCodes)) {
    query['PermissionCodes'] = request.permissionCodes;
  }
  if (!Util.isUnset(request.relationId)) {
    query['RelationId'] = request.relationId;
  }
  if (!Util.isUnset(request.relationOperation)) {
    query['RelationOperation'] = request.relationOperation;
  }
  if (!Util.isUnset(request.relationType)) {
    query['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.roleCodes)) {
    query['RoleCodes'] = request.roleCodes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountRelation',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccountRelation(request: ModifyAccountRelationRequest): ModifyAccountRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountRelationWithOptions(request, runtime);
}

model ModifyCostUnitRequest {
  unitEntityList?: [ 
    {
      newUnitName?: string(name='NewUnitName'),
      ownerUid?: long(name='OwnerUid'),
      unitId?: long(name='UnitId'),
    }
  ](name='UnitEntityList'),
}

model ModifyCostUnitResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      isSuccess?: boolean(name='IsSuccess'),
      ownerUid?: long(name='OwnerUid'),
      unitId?: long(name='UnitId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyCostUnitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCostUnitResponseBody(name='body'),
}

async function modifyCostUnitWithOptions(request: ModifyCostUnitRequest, runtime: Util.RuntimeOptions): ModifyCostUnitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.unitEntityList)) {
    query['UnitEntityList'] = request.unitEntityList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCostUnit',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCostUnit(request: ModifyCostUnitRequest): ModifyCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCostUnitWithOptions(request, runtime);
}

model ModifyInstanceRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  modifyType?: string(name='ModifyType'),
  ownerId?: long(name='OwnerId'),
  parameter?: [ 
    {
      code?: string(name='Code'),
      value?: string(name='Value'),
    }
  ](name='Parameter'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model ModifyInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    orderId?: string(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceResponseBody(name='body'),
}

async function modifyInstanceWithOptions(request: ModifyInstanceRequest, runtime: Util.RuntimeOptions): ModifyInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.modifyType)) {
    query['ModifyType'] = request.modifyType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameter)) {
    query['Parameter'] = request.parameter;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstance(request: ModifyInstanceRequest): ModifyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceWithOptions(request, runtime);
}

model QueryAccountBalanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    availableAmount?: string(name='AvailableAmount'),
    availableCashAmount?: string(name='AvailableCashAmount'),
    creditAmount?: string(name='CreditAmount'),
    currency?: string(name='Currency'),
    mybankCreditAmount?: string(name='MybankCreditAmount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAccountBalanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAccountBalanceResponseBody(name='body'),
}

async function queryAccountBalanceWithOptions(runtime: Util.RuntimeOptions): QueryAccountBalanceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryAccountBalance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAccountBalance(): QueryAccountBalanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountBalanceWithOptions(runtime);
}

model QueryAccountBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  billingDate?: string(name='BillingDate'),
  granularity?: string(name='Granularity'),
  isGroupByProduct?: boolean(name='IsGroupByProduct'),
  ownerID?: long(name='OwnerID'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
}

model QueryAccountBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        billAccountID?: string(name='BillAccountID'),
        billAccountName?: string(name='BillAccountName'),
        billingDate?: string(name='BillingDate'),
        bizType?: string(name='BizType'),
        cashAmount?: float(name='CashAmount'),
        costUnit?: string(name='CostUnit'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        ownerName?: string(name='OwnerName'),
        paymentAmount?: float(name='PaymentAmount'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productName?: string(name='ProductName'),
        subscriptionType?: string(name='SubscriptionType'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAccountBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAccountBillResponseBody(name='body'),
}

async function queryAccountBillWithOptions(request: QueryAccountBillRequest, runtime: Util.RuntimeOptions): QueryAccountBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.billingDate)) {
    query['BillingDate'] = request.billingDate;
  }
  if (!Util.isUnset(request.granularity)) {
    query['Granularity'] = request.granularity;
  }
  if (!Util.isUnset(request.isGroupByProduct)) {
    query['IsGroupByProduct'] = request.isGroupByProduct;
  }
  if (!Util.isUnset(request.ownerID)) {
    query['OwnerID'] = request.ownerID;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccountBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAccountBill(request: QueryAccountBillRequest): QueryAccountBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountBillWithOptions(request, runtime);
}

model QueryAccountTransactionDetailsRequest {
  createTimeEnd?: string(name='CreateTimeEnd'),
  createTimeStart?: string(name='CreateTimeStart'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  recordID?: string(name='RecordID'),
  transactionChannel?: string(name='TransactionChannel'),
  transactionChannelSN?: string(name='TransactionChannelSN'),
  transactionNumber?: string(name='TransactionNumber'),
  transactionType?: string(name='TransactionType'),
}

model QueryAccountTransactionDetailsResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountName?: string(name='AccountName'),
    accountTransactionsList?: {
      accountTransactionsList?: [ 
      {
        amount?: string(name='Amount'),
        balance?: string(name='Balance'),
        billingCycle?: string(name='BillingCycle'),
        fundType?: string(name='FundType'),
        recordID?: string(name='RecordID'),
        remarks?: string(name='Remarks'),
        transactionAccount?: string(name='TransactionAccount'),
        transactionChannel?: string(name='TransactionChannel'),
        transactionChannelSN?: string(name='TransactionChannelSN'),
        transactionFlow?: string(name='TransactionFlow'),
        transactionNumber?: string(name='TransactionNumber'),
        transactionTime?: string(name='TransactionTime'),
        transactionType?: string(name='TransactionType'),
      }
    ](name='AccountTransactionsList')
    }(name='AccountTransactionsList'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAccountTransactionDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAccountTransactionDetailsResponseBody(name='body'),
}

async function queryAccountTransactionDetailsWithOptions(request: QueryAccountTransactionDetailsRequest, runtime: Util.RuntimeOptions): QueryAccountTransactionDetailsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeEnd)) {
    query['CreateTimeEnd'] = request.createTimeEnd;
  }
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.recordID)) {
    query['RecordID'] = request.recordID;
  }
  if (!Util.isUnset(request.transactionChannel)) {
    query['TransactionChannel'] = request.transactionChannel;
  }
  if (!Util.isUnset(request.transactionChannelSN)) {
    query['TransactionChannelSN'] = request.transactionChannelSN;
  }
  if (!Util.isUnset(request.transactionNumber)) {
    query['TransactionNumber'] = request.transactionNumber;
  }
  if (!Util.isUnset(request.transactionType)) {
    query['TransactionType'] = request.transactionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccountTransactionDetails',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAccountTransactionDetails(request: QueryAccountTransactionDetailsRequest): QueryAccountTransactionDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountTransactionDetailsWithOptions(request, runtime);
}

model QueryAccountTransactionsRequest {
  createTimeEnd?: string(name='CreateTimeEnd'),
  createTimeStart?: string(name='CreateTimeStart'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  recordID?: string(name='RecordID'),
  transactionChannel?: string(name='TransactionChannel'),
  transactionChannelSN?: string(name='TransactionChannelSN'),
  transactionFlow?: string(name='TransactionFlow'),
  transactionNumber?: string(name='TransactionNumber'),
  transactionType?: string(name='TransactionType'),
}

model QueryAccountTransactionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountName?: string(name='AccountName'),
    accountTransactionsList?: {
      accountTransactionsList?: [ 
      {
        amount?: string(name='Amount'),
        balance?: string(name='Balance'),
        billingCycle?: string(name='BillingCycle'),
        fundType?: string(name='FundType'),
        recordID?: string(name='RecordID'),
        remarks?: string(name='Remarks'),
        transactionAccount?: string(name='TransactionAccount'),
        transactionChannel?: string(name='TransactionChannel'),
        transactionChannelSN?: string(name='TransactionChannelSN'),
        transactionFlow?: string(name='TransactionFlow'),
        transactionNumber?: string(name='TransactionNumber'),
        transactionTime?: string(name='TransactionTime'),
        transactionType?: string(name='TransactionType'),
      }
    ](name='AccountTransactionsList')
    }(name='AccountTransactionsList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAccountTransactionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAccountTransactionsResponseBody(name='body'),
}

async function queryAccountTransactionsWithOptions(request: QueryAccountTransactionsRequest, runtime: Util.RuntimeOptions): QueryAccountTransactionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeEnd)) {
    query['CreateTimeEnd'] = request.createTimeEnd;
  }
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recordID)) {
    query['RecordID'] = request.recordID;
  }
  if (!Util.isUnset(request.transactionChannel)) {
    query['TransactionChannel'] = request.transactionChannel;
  }
  if (!Util.isUnset(request.transactionChannelSN)) {
    query['TransactionChannelSN'] = request.transactionChannelSN;
  }
  if (!Util.isUnset(request.transactionFlow)) {
    query['TransactionFlow'] = request.transactionFlow;
  }
  if (!Util.isUnset(request.transactionNumber)) {
    query['TransactionNumber'] = request.transactionNumber;
  }
  if (!Util.isUnset(request.transactionType)) {
    query['TransactionType'] = request.transactionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAccountTransactions',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAccountTransactions(request: QueryAccountTransactionsRequest): QueryAccountTransactionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAccountTransactionsWithOptions(request, runtime);
}

model QueryAvailableInstancesRequest {
  createTimeEnd?: string(name='CreateTimeEnd'),
  createTimeStart?: string(name='CreateTimeStart'),
  endTimeEnd?: string(name='EndTimeEnd'),
  endTimeStart?: string(name='EndTimeStart'),
  instanceIDs?: string(name='InstanceIDs'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  region?: string(name='Region'),
  renewStatus?: string(name='RenewStatus'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryAvailableInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    instanceList?: [ 
      {
        createTime?: string(name='CreateTime'),
        endTime?: string(name='EndTime'),
        expectedReleaseTime?: string(name='ExpectedReleaseTime'),
        instanceID?: string(name='InstanceID'),
        ownerId?: long(name='OwnerId'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        releaseTime?: string(name='ReleaseTime'),
        renewStatus?: string(name='RenewStatus'),
        renewalDuration?: int32(name='RenewalDuration'),
        renewalDurationUnit?: string(name='RenewalDurationUnit'),
        seller?: string(name='Seller'),
        sellerId?: long(name='SellerId'),
        status?: string(name='Status'),
        stopTime?: string(name='StopTime'),
        subStatus?: string(name='SubStatus'),
        subscriptionType?: string(name='SubscriptionType'),
      }
    ](name='InstanceList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryAvailableInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryAvailableInstancesResponseBody(name='body'),
}

async function queryAvailableInstancesWithOptions(request: QueryAvailableInstancesRequest, runtime: Util.RuntimeOptions): QueryAvailableInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeEnd)) {
    query['CreateTimeEnd'] = request.createTimeEnd;
  }
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.endTimeEnd)) {
    query['EndTimeEnd'] = request.endTimeEnd;
  }
  if (!Util.isUnset(request.endTimeStart)) {
    query['EndTimeStart'] = request.endTimeStart;
  }
  if (!Util.isUnset(request.instanceIDs)) {
    query['InstanceIDs'] = request.instanceIDs;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.renewStatus)) {
    query['RenewStatus'] = request.renewStatus;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryAvailableInstances',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryAvailableInstances(request: QueryAvailableInstancesRequest): QueryAvailableInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryAvailableInstancesWithOptions(request, runtime);
}

model QueryBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  isDisplayLocalCurrency?: boolean(name='IsDisplayLocalCurrency'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
  type?: string(name='Type'),
}

model QueryBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        afterTaxAmount?: float(name='AfterTaxAmount'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        paymentTime?: string(name='PaymentTime'),
        paymentTransactionID?: string(name='PaymentTransactionID'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        recordID?: string(name='RecordID'),
        roundDownDiscount?: string(name='RoundDownDiscount'),
        status?: string(name='Status'),
        subOrderId?: string(name='SubOrderId'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: float(name='Tax'),
        usageEndTime?: string(name='UsageEndTime'),
        usageStartTime?: string(name='UsageStartTime'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBillResponseBody(name='body'),
}

async function queryBillWithOptions(request: QueryBillRequest, runtime: Util.RuntimeOptions): QueryBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.isDisplayLocalCurrency)) {
    query['IsDisplayLocalCurrency'] = request.isDisplayLocalCurrency;
  }
  if (!Util.isUnset(request.isHideZeroCharge)) {
    query['IsHideZeroCharge'] = request.isHideZeroCharge;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBill(request: QueryBillRequest): QueryBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillWithOptions(request, runtime);
}

model QueryBillOverviewRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryBillOverviewResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        afterTaxAmount?: float(name='AfterTaxAmount'),
        billAccountID?: string(name='BillAccountID'),
        billAccountName?: string(name='BillAccountName'),
        bizType?: string(name='BizType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        roundDownDiscount?: string(name='RoundDownDiscount'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: float(name='Tax'),
      }
    ](name='Item')
    }(name='Items'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryBillOverviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBillOverviewResponseBody(name='body'),
}

async function queryBillOverviewWithOptions(request: QueryBillOverviewRequest, runtime: Util.RuntimeOptions): QueryBillOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryBillOverview',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBillOverview(request: QueryBillOverviewRequest): QueryBillOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillOverviewWithOptions(request, runtime);
}

model QueryBillToOSSSubscriptionResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    items?: {
      item?: [ 
      {
        bucketOwnerId?: long(name='BucketOwnerId'),
        bucketPath?: string(name='BucketPath'),
        subscribeBucket?: string(name='SubscribeBucket'),
        subscribeLanguage?: string(name='SubscribeLanguage'),
        subscribeTime?: string(name='SubscribeTime'),
        subscribeType?: string(name='SubscribeType'),
      }
    ](name='Item')
    }(name='Items'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryBillToOSSSubscriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryBillToOSSSubscriptionResponseBody(name='body'),
}

async function queryBillToOSSSubscriptionWithOptions(runtime: Util.RuntimeOptions): QueryBillToOSSSubscriptionResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'QueryBillToOSSSubscription',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryBillToOSSSubscription(): QueryBillToOSSSubscriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryBillToOSSSubscriptionWithOptions(runtime);
}

model QueryCashCouponsRequest {
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
}

model QueryCashCouponsResponseBody = {
  code?: string(name='Code'),
  data?: {
    cashCoupon?: [ 
    {
      applicableProducts?: string(name='ApplicableProducts'),
      applicableScenarios?: string(name='ApplicableScenarios'),
      balance?: string(name='Balance'),
      cashCouponId?: long(name='CashCouponId'),
      cashCouponNo?: string(name='CashCouponNo'),
      effectiveTime?: string(name='EffectiveTime'),
      expiryTime?: string(name='ExpiryTime'),
      grantedTime?: string(name='GrantedTime'),
      nominalValue?: string(name='NominalValue'),
      status?: string(name='Status'),
    }
  ](name='CashCoupon')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCashCouponsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCashCouponsResponseBody(name='body'),
}

async function queryCashCouponsWithOptions(request: QueryCashCouponsRequest, runtime: Util.RuntimeOptions): QueryCashCouponsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.effectiveOrNot)) {
    query['EffectiveOrNot'] = request.effectiveOrNot;
  }
  if (!Util.isUnset(request.expiryTimeEnd)) {
    query['ExpiryTimeEnd'] = request.expiryTimeEnd;
  }
  if (!Util.isUnset(request.expiryTimeStart)) {
    query['ExpiryTimeStart'] = request.expiryTimeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCashCoupons',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCashCoupons(request: QueryCashCouponsRequest): QueryCashCouponsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCashCouponsWithOptions(request, runtime);
}

model QueryCostUnitRequest {
  ownerUid?: long(name='OwnerUid'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  parentUnitId?: long(name='ParentUnitId'),
}

model QueryCostUnitResponseBody = {
  code?: string(name='Code'),
  data?: {
    costUnitDtoList?: [ 
      {
        ownerUid?: long(name='OwnerUid'),
        parentUnitId?: long(name='ParentUnitId'),
        unitId?: long(name='UnitId'),
        unitName?: string(name='UnitName'),
      }
    ](name='CostUnitDtoList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCostUnitResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCostUnitResponseBody(name='body'),
}

async function queryCostUnitWithOptions(request: QueryCostUnitRequest, runtime: Util.RuntimeOptions): QueryCostUnitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerUid)) {
    query['OwnerUid'] = request.ownerUid;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentUnitId)) {
    query['ParentUnitId'] = request.parentUnitId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCostUnit',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCostUnit(request: QueryCostUnitRequest): QueryCostUnitResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCostUnitWithOptions(request, runtime);
}

model QueryCostUnitResourceRequest {
  ownerUid?: long(name='OwnerUid'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  unitId?: long(name='UnitId'),
}

model QueryCostUnitResourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    costUnit?: {
      ownerUid?: long(name='OwnerUid'),
      parentUnitId?: long(name='ParentUnitId'),
      unitId?: long(name='UnitId'),
      unitName?: string(name='UnitName'),
    }(name='CostUnit'),
    costUnitStatisInfo?: {
      resourceCount?: long(name='ResourceCount'),
      resourceGroupCount?: long(name='ResourceGroupCount'),
      subUnitCount?: long(name='SubUnitCount'),
      totalResourceCount?: long(name='TotalResourceCount'),
      totalResourceGroupCount?: long(name='TotalResourceGroupCount'),
      totalUserCount?: long(name='TotalUserCount'),
      userCount?: long(name='UserCount'),
    }(name='CostUnitStatisInfo'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    resourceInstanceDtoList?: [ 
      {
        apportionCode?: string(name='ApportionCode'),
        apportionName?: string(name='ApportionName'),
        commodityCode?: string(name='CommodityCode'),
        commodityName?: string(name='CommodityName'),
        relatedResources?: string(name='RelatedResources'),
        resourceGroup?: string(name='ResourceGroup'),
        resourceId?: string(name='ResourceId'),
        resourceNick?: string(name='ResourceNick'),
        resourceStatus?: string(name='ResourceStatus'),
        resourceTag?: string(name='ResourceTag'),
        resourceType?: string(name='ResourceType'),
        resourceUserId?: long(name='ResourceUserId'),
        resourceUserName?: string(name='ResourceUserName'),
      }
    ](name='ResourceInstanceDtoList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCostUnitResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCostUnitResourceResponseBody(name='body'),
}

async function queryCostUnitResourceWithOptions(request: QueryCostUnitResourceRequest, runtime: Util.RuntimeOptions): QueryCostUnitResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerUid)) {
    query['OwnerUid'] = request.ownerUid;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.unitId)) {
    query['UnitId'] = request.unitId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCostUnitResource',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCostUnitResource(request: QueryCostUnitResourceRequest): QueryCostUnitResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCostUnitResourceWithOptions(request, runtime);
}

model QueryCustomerAddressListRequest {
  ownerId?: long(name='OwnerId'),
}

model QueryCustomerAddressListResponseBody = {
  code?: string(name='Code'),
  data?: {
    customerInvoiceAddressList?: {
      customerInvoiceAddress?: [ 
      {
        addressee?: string(name='Addressee'),
        bizType?: string(name='BizType'),
        city?: string(name='City'),
        county?: string(name='County'),
        deliveryAddress?: string(name='DeliveryAddress'),
        id?: long(name='Id'),
        phone?: string(name='Phone'),
        postalCode?: string(name='PostalCode'),
        province?: string(name='Province'),
        street?: string(name='Street'),
        userId?: long(name='UserId'),
        userNick?: string(name='UserNick'),
      }
    ](name='CustomerInvoiceAddress')
    }(name='CustomerInvoiceAddressList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryCustomerAddressListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryCustomerAddressListResponseBody(name='body'),
}

async function queryCustomerAddressListWithOptions(request: QueryCustomerAddressListRequest, runtime: Util.RuntimeOptions): QueryCustomerAddressListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryCustomerAddressList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryCustomerAddressList(request: QueryCustomerAddressListRequest): QueryCustomerAddressListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryCustomerAddressListWithOptions(request, runtime);
}

model QueryDPUtilizationDetailRequest {
  commodityCode?: string(name='CommodityCode'),
  deductedInstanceId?: string(name='DeductedInstanceId'),
  endTime?: string(name='EndTime'),
  includeShare?: boolean(name='IncludeShare'),
  instanceId?: string(name='InstanceId'),
  instanceSpec?: string(name='InstanceSpec'),
  lastToken?: string(name='LastToken'),
  limit?: int32(name='Limit'),
  prodCode?: string(name='ProdCode'),
  startTime?: string(name='StartTime'),
}

model QueryDPUtilizationDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    detailList?: {
      detailList?: [ 
      {
        deductDate?: string(name='DeductDate'),
        deductFactorTotal?: float(name='DeductFactorTotal'),
        deductHours?: float(name='DeductHours'),
        deductMeasure?: float(name='DeductMeasure'),
        deductQuantity?: float(name='DeductQuantity'),
        deductedCommodityCode?: string(name='DeductedCommodityCode'),
        deductedInstanceId?: string(name='DeductedInstanceId'),
        deductedProductDetail?: string(name='DeductedProductDetail'),
        instanceId?: string(name='InstanceId'),
        instanceSpec?: string(name='InstanceSpec'),
        region?: string(name='Region'),
        resCode?: string(name='ResCode'),
        shareUid?: long(name='ShareUid'),
        uid?: long(name='Uid'),
      }
    ](name='DetailList')
    }(name='DetailList'),
    nextToken?: string(name='NextToken'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryDPUtilizationDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDPUtilizationDetailResponseBody(name='body'),
}

async function queryDPUtilizationDetailWithOptions(request: QueryDPUtilizationDetailRequest, runtime: Util.RuntimeOptions): QueryDPUtilizationDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.deductedInstanceId)) {
    query['DeductedInstanceId'] = request.deductedInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.includeShare)) {
    query['IncludeShare'] = request.includeShare;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceSpec)) {
    query['InstanceSpec'] = request.instanceSpec;
  }
  if (!Util.isUnset(request.lastToken)) {
    query['LastToken'] = request.lastToken;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.prodCode)) {
    query['ProdCode'] = request.prodCode;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDPUtilizationDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDPUtilizationDetail(request: QueryDPUtilizationDetailRequest): QueryDPUtilizationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDPUtilizationDetailWithOptions(request, runtime);
}

model QueryEvaluateListRequest {
  billCycle?: string(name='BillCycle'),
  bizTypeList?: [ string ](name='BizTypeList'),
  endAmount?: long(name='EndAmount'),
  endBizTime?: string(name='EndBizTime'),
  endSearchTime?: string(name='EndSearchTime'),
  outBizId?: string(name='OutBizId'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  sortType?: int32(name='SortType'),
  startAmount?: long(name='StartAmount'),
  startBizTime?: string(name='StartBizTime'),
  startSearchTime?: string(name='StartSearchTime'),
  type?: int32(name='Type'),
}

model QueryEvaluateListResponseBody = {
  code?: string(name='Code'),
  data?: {
    evaluateList?: {
      evaluate?: [ 
      {
        billCycle?: string(name='BillCycle'),
        billId?: long(name='BillId'),
        bizTime?: string(name='BizTime'),
        bizType?: string(name='BizType'),
        canInvoiceAmount?: long(name='CanInvoiceAmount'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        invoicedAmount?: long(name='InvoicedAmount'),
        itemId?: long(name='ItemId'),
        name?: string(name='Name'),
        offsetAcceptAmount?: long(name='OffsetAcceptAmount'),
        offsetCostAmount?: long(name='OffsetCostAmount'),
        opId?: string(name='OpId'),
        originalAmount?: long(name='OriginalAmount'),
        outBizId?: string(name='OutBizId'),
        presentAmount?: long(name='PresentAmount'),
        status?: int32(name='Status'),
        type?: int32(name='Type'),
        userId?: long(name='UserId'),
        userNick?: string(name='UserNick'),
      }
    ](name='Evaluate')
    }(name='EvaluateList'),
    hostId?: string(name='HostId'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    totalInvoiceAmount?: long(name='TotalInvoiceAmount'),
    totalUnAppliedInvoiceAmount?: long(name='TotalUnAppliedInvoiceAmount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryEvaluateListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryEvaluateListResponseBody(name='body'),
}

async function queryEvaluateListWithOptions(request: QueryEvaluateListRequest, runtime: Util.RuntimeOptions): QueryEvaluateListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billCycle)) {
    query['BillCycle'] = request.billCycle;
  }
  if (!Util.isUnset(request.bizTypeList)) {
    query['BizTypeList'] = request.bizTypeList;
  }
  if (!Util.isUnset(request.endAmount)) {
    query['EndAmount'] = request.endAmount;
  }
  if (!Util.isUnset(request.endBizTime)) {
    query['EndBizTime'] = request.endBizTime;
  }
  if (!Util.isUnset(request.endSearchTime)) {
    query['EndSearchTime'] = request.endSearchTime;
  }
  if (!Util.isUnset(request.outBizId)) {
    query['OutBizId'] = request.outBizId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortType)) {
    query['SortType'] = request.sortType;
  }
  if (!Util.isUnset(request.startAmount)) {
    query['StartAmount'] = request.startAmount;
  }
  if (!Util.isUnset(request.startBizTime)) {
    query['StartBizTime'] = request.startBizTime;
  }
  if (!Util.isUnset(request.startSearchTime)) {
    query['StartSearchTime'] = request.startSearchTime;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryEvaluateList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryEvaluateList(request: QueryEvaluateListRequest): QueryEvaluateListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryEvaluateListWithOptions(request, runtime);
}

model QueryFinancialAccountInfoRequest {
  userId?: long(name='UserId'),
}

model QueryFinancialAccountInfoResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountType?: string(name='AccountType'),
    isFinancialAccount?: boolean(name='IsFinancialAccount'),
    memberGroupId?: long(name='MemberGroupId'),
    memberGroupName?: string(name='MemberGroupName'),
    memberNickName?: string(name='MemberNickName'),
    userName?: string(name='UserName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryFinancialAccountInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryFinancialAccountInfoResponseBody(name='body'),
}

async function queryFinancialAccountInfoWithOptions(request: QueryFinancialAccountInfoRequest, runtime: Util.RuntimeOptions): QueryFinancialAccountInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryFinancialAccountInfo',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryFinancialAccountInfo(request: QueryFinancialAccountInfoRequest): QueryFinancialAccountInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryFinancialAccountInfoWithOptions(request, runtime);
}

model QueryInstanceBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  billingDate?: string(name='BillingDate'),
  granularity?: string(name='Granularity'),
  isBillingItem?: boolean(name='IsBillingItem'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryInstanceBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        billingDate?: string(name='BillingDate'),
        billingItem?: string(name='BillingItem'),
        billingType?: string(name='BillingType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        costUnit?: string(name='CostUnit'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        deductedByResourcePackage?: string(name='DeductedByResourcePackage'),
        instanceConfig?: string(name='InstanceConfig'),
        instanceID?: string(name='InstanceID'),
        instanceSpec?: string(name='InstanceSpec'),
        internetIP?: string(name='InternetIP'),
        intranetIP?: string(name='IntranetIP'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        listPrice?: string(name='ListPrice'),
        listPriceUnit?: string(name='ListPriceUnit'),
        nickName?: string(name='NickName'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        servicePeriod?: string(name='ServicePeriod'),
        servicePeriodUnit?: string(name='ServicePeriodUnit'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        usage?: string(name='Usage'),
        usageUnit?: string(name='UsageUnit'),
        zone?: string(name='Zone'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryInstanceBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryInstanceBillResponseBody(name='body'),
}

async function queryInstanceBillWithOptions(request: QueryInstanceBillRequest, runtime: Util.RuntimeOptions): QueryInstanceBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.billingDate)) {
    query['BillingDate'] = request.billingDate;
  }
  if (!Util.isUnset(request.granularity)) {
    query['Granularity'] = request.granularity;
  }
  if (!Util.isUnset(request.isBillingItem)) {
    query['IsBillingItem'] = request.isBillingItem;
  }
  if (!Util.isUnset(request.isHideZeroCharge)) {
    query['IsHideZeroCharge'] = request.isHideZeroCharge;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInstanceBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInstanceBill(request: QueryInstanceBillRequest): QueryInstanceBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInstanceBillWithOptions(request, runtime);
}

model QueryInstanceByTagRequest {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model QueryInstanceByTagResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag'),
    }
  ](name='TagResource'),
}

model QueryInstanceByTagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryInstanceByTagResponseBody(name='body'),
}

async function queryInstanceByTagWithOptions(request: QueryInstanceByTagRequest, runtime: Util.RuntimeOptions): QueryInstanceByTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInstanceByTag',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInstanceByTag(request: QueryInstanceByTagRequest): QueryInstanceByTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInstanceByTagWithOptions(request, runtime);
}

model QueryInstanceGaapCostRequest {
  billingCycle?: string(name='BillingCycle'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryInstanceGaapCostResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    modules?: {
      module?: [ 
      {
        accountingUnit?: string(name='AccountingUnit'),
        billType?: string(name='BillType'),
        billingCycle?: string(name='BillingCycle'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: string(name='DeductedByCashCoupons'),
        deductedByCoupons?: string(name='DeductedByCoupons'),
        deductedByPrepaidCard?: string(name='DeductedByPrepaidCard'),
        gaapDeductedByCashCoupons?: string(name='GaapDeductedByCashCoupons'),
        gaapDeductedByCoupons?: string(name='GaapDeductedByCoupons'),
        gaapDeductedByPrepaidCard?: string(name='GaapDeductedByPrepaidCard'),
        gaapPaymentAmount?: string(name='GaapPaymentAmount'),
        gaapPretaxAmount?: string(name='GaapPretaxAmount'),
        gaapPretaxAmountLocal?: string(name='GaapPretaxAmountLocal'),
        gaapPretaxGrossAmount?: string(name='GaapPretaxGrossAmount'),
        gaapPricingDiscount?: string(name='GaapPricingDiscount'),
        instanceID?: string(name='InstanceID'),
        monthGaapDeductedByCashCoupons?: string(name='MonthGaapDeductedByCashCoupons'),
        monthGaapDeductedByCoupons?: string(name='MonthGaapDeductedByCoupons'),
        monthGaapDeductedByPrepaidCard?: string(name='MonthGaapDeductedByPrepaidCard'),
        monthGaapPaymentAmount?: string(name='MonthGaapPaymentAmount'),
        monthGaapPretaxAmount?: string(name='MonthGaapPretaxAmount'),
        monthGaapPretaxAmountLocal?: string(name='MonthGaapPretaxAmountLocal'),
        monthGaapPretaxGrossAmount?: string(name='MonthGaapPretaxGrossAmount'),
        monthGaapPricingDiscount?: string(name='MonthGaapPricingDiscount'),
        orderId?: string(name='OrderId'),
        orderType?: string(name='OrderType'),
        ownerID?: string(name='OwnerID'),
        payTime?: string(name='PayTime'),
        payerAccount?: string(name='PayerAccount'),
        paymentAmount?: string(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        pretaxAmount?: string(name='PretaxAmount'),
        pretaxAmountLocal?: string(name='PretaxAmountLocal'),
        pretaxGrossAmount?: string(name='PretaxGrossAmount'),
        pricingDiscount?: string(name='PricingDiscount'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        subOrderId?: string(name='SubOrderId'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        unallocatedDeductedByCashCoupons?: string(name='UnallocatedDeductedByCashCoupons'),
        unallocatedDeductedByCoupons?: string(name='UnallocatedDeductedByCoupons'),
        unallocatedDeductedByPrepaidCard?: string(name='UnallocatedDeductedByPrepaidCard'),
        unallocatedPaymentAmount?: string(name='UnallocatedPaymentAmount'),
        unallocatedPretaxAmount?: string(name='UnallocatedPretaxAmount'),
        unallocatedPretaxAmountLocal?: string(name='UnallocatedPretaxAmountLocal'),
        unallocatedPretaxGrossAmount?: string(name='UnallocatedPretaxGrossAmount'),
        unallocatedPricingDiscount?: string(name='UnallocatedPricingDiscount'),
        usageEndDate?: string(name='UsageEndDate'),
        usageStartDate?: string(name='UsageStartDate'),
      }
    ](name='Module')
    }(name='Modules'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryInstanceGaapCostResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryInstanceGaapCostResponseBody(name='body'),
}

async function queryInstanceGaapCostWithOptions(request: QueryInstanceGaapCostRequest, runtime: Util.RuntimeOptions): QueryInstanceGaapCostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInstanceGaapCost',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInstanceGaapCost(request: QueryInstanceGaapCostRequest): QueryInstanceGaapCostResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInstanceGaapCostWithOptions(request, runtime);
}

model QueryInvoicingCustomerListRequest {
  ownerId?: long(name='OwnerId'),
}

model QueryInvoicingCustomerListResponseBody = {
  code?: string(name='Code'),
  data?: {
    customerInvoiceList?: {
      customerInvoice?: [ 
      {
        adjustType?: long(name='AdjustType'),
        bank?: string(name='Bank'),
        bankNo?: string(name='BankNo'),
        customerType?: long(name='CustomerType'),
        defaultRemark?: string(name='DefaultRemark'),
        endCycle?: long(name='EndCycle'),
        gmtCreate?: string(name='GmtCreate'),
        id?: long(name='Id'),
        invoiceTitle?: string(name='InvoiceTitle'),
        issueType?: long(name='IssueType'),
        operatingLicenseAddress?: string(name='OperatingLicenseAddress'),
        operatingLicensePhone?: string(name='OperatingLicensePhone'),
        registerNo?: string(name='RegisterNo'),
        startCycle?: long(name='StartCycle'),
        status?: long(name='Status'),
        taxationLicense?: string(name='TaxationLicense'),
        taxpayerType?: long(name='TaxpayerType'),
        titleChangeInstructions?: string(name='TitleChangeInstructions'),
        type?: long(name='Type'),
        userId?: long(name='UserId'),
        userNick?: string(name='UserNick'),
      }
    ](name='CustomerInvoice')
    }(name='CustomerInvoiceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryInvoicingCustomerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryInvoicingCustomerListResponseBody(name='body'),
}

async function queryInvoicingCustomerListWithOptions(request: QueryInvoicingCustomerListRequest, runtime: Util.RuntimeOptions): QueryInvoicingCustomerListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryInvoicingCustomerList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryInvoicingCustomerList(request: QueryInvoicingCustomerListRequest): QueryInvoicingCustomerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryInvoicingCustomerListWithOptions(request, runtime);
}

model QueryMonthlyBillRequest {
  billingCycle?: string(name='BillingCycle'),
}

model QueryMonthlyBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        afterTaxAmount?: float(name='AfterTaxAmount'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        outstandingAmount?: float(name='OutstandingAmount'),
        paymentAmount?: float(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        solutionCode?: string(name='SolutionCode'),
        solutionName?: string(name='SolutionName'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: float(name='Tax'),
      }
    ](name='Item')
    }(name='Items'),
    newInvoiceAmount?: float(name='NewInvoiceAmount'),
    outstandingAmount?: float(name='OutstandingAmount'),
    totalOutstandingAmount?: float(name='TotalOutstandingAmount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonthlyBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMonthlyBillResponseBody(name='body'),
}

async function queryMonthlyBillWithOptions(request: QueryMonthlyBillRequest, runtime: Util.RuntimeOptions): QueryMonthlyBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonthlyBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonthlyBill(request: QueryMonthlyBillRequest): QueryMonthlyBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonthlyBillWithOptions(request, runtime);
}

model QueryMonthlyInstanceConsumptionRequest {
  billingCycle?: string(name='BillingCycle'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryMonthlyInstanceConsumptionResponseBody = {
  code?: string(name='Code'),
  data?: {
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        afterTaxAmount?: float(name='AfterTaxAmount'),
        currency?: string(name='Currency'),
        discountAmount?: float(name='DiscountAmount'),
        instanceID?: string(name='InstanceID'),
        ownerID?: string(name='OwnerID'),
        payerAccount?: string(name='PayerAccount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        tax?: float(name='Tax'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMonthlyInstanceConsumptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryMonthlyInstanceConsumptionResponseBody(name='body'),
}

async function queryMonthlyInstanceConsumptionWithOptions(request: QueryMonthlyInstanceConsumptionRequest, runtime: Util.RuntimeOptions): QueryMonthlyInstanceConsumptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMonthlyInstanceConsumption',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryMonthlyInstanceConsumption(request: QueryMonthlyInstanceConsumptionRequest): QueryMonthlyInstanceConsumptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMonthlyInstanceConsumptionWithOptions(request, runtime);
}

model QueryOrdersRequest {
  createTimeEnd?: string(name='CreateTimeEnd'),
  createTimeStart?: string(name='CreateTimeStart'),
  orderType?: string(name='OrderType'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  paymentStatus?: string(name='PaymentStatus'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QueryOrdersResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostName?: string(name='HostName'),
    orderList?: {
      order?: [ 
      {
        afterTaxAmount?: string(name='AfterTaxAmount'),
        commodityCode?: string(name='CommodityCode'),
        createTime?: string(name='CreateTime'),
        currency?: string(name='Currency'),
        orderId?: string(name='OrderId'),
        orderType?: string(name='OrderType'),
        paymentCurrency?: string(name='PaymentCurrency'),
        paymentStatus?: string(name='PaymentStatus'),
        paymentTime?: string(name='PaymentTime'),
        pretaxAmount?: string(name='PretaxAmount'),
        pretaxAmountLocal?: string(name='PretaxAmountLocal'),
        pretaxGrossAmount?: string(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        relatedOrderId?: string(name='RelatedOrderId'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: string(name='Tax'),
      }
    ](name='Order')
    }(name='OrderList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryOrdersResponseBody(name='body'),
}

async function queryOrdersWithOptions(request: QueryOrdersRequest, runtime: Util.RuntimeOptions): QueryOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTimeEnd)) {
    query['CreateTimeEnd'] = request.createTimeEnd;
  }
  if (!Util.isUnset(request.createTimeStart)) {
    query['CreateTimeStart'] = request.createTimeStart;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.paymentStatus)) {
    query['PaymentStatus'] = request.paymentStatus;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryOrders',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryOrders(request: QueryOrdersRequest): QueryOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryOrdersWithOptions(request, runtime);
}

model QueryPermissionListRequest {
  relationId?: long(name='RelationId'),
}

model QueryPermissionListResponseBody = {
  code?: string(name='Code'),
  data?: {
    endTime?: string(name='EndTime'),
    masterId?: long(name='MasterId'),
    memberId?: long(name='MemberId'),
    permissionList?: [ 
      {
        endTime?: string(name='EndTime'),
        permissionCode?: string(name='PermissionCode'),
        permissionName?: string(name='PermissionName'),
        startTime?: string(name='StartTime'),
      }
    ](name='PermissionList'),
    relationType?: string(name='RelationType'),
    setupTime?: string(name='SetupTime'),
    startTime?: string(name='StartTime'),
    state?: string(name='State'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPermissionListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPermissionListResponseBody(name='body'),
}

async function queryPermissionListWithOptions(request: QueryPermissionListRequest, runtime: Util.RuntimeOptions): QueryPermissionListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.relationId)) {
    query['RelationId'] = request.relationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPermissionList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPermissionList(request: QueryPermissionListRequest): QueryPermissionListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPermissionListWithOptions(request, runtime);
}

model QueryPrepaidCardsRequest {
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
}

model QueryPrepaidCardsResponseBody = {
  code?: string(name='Code'),
  data?: {
    prepaidCard?: [ 
    {
      applicableProducts?: string(name='ApplicableProducts'),
      applicableScenarios?: string(name='ApplicableScenarios'),
      balance?: string(name='Balance'),
      effectiveTime?: string(name='EffectiveTime'),
      expiryTime?: string(name='ExpiryTime'),
      grantedTime?: string(name='GrantedTime'),
      nominalValue?: string(name='NominalValue'),
      prepaidCardId?: long(name='PrepaidCardId'),
      prepaidCardNo?: string(name='PrepaidCardNo'),
      status?: string(name='Status'),
    }
  ](name='PrepaidCard')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryPrepaidCardsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryPrepaidCardsResponseBody(name='body'),
}

async function queryPrepaidCardsWithOptions(request: QueryPrepaidCardsRequest, runtime: Util.RuntimeOptions): QueryPrepaidCardsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.effectiveOrNot)) {
    query['EffectiveOrNot'] = request.effectiveOrNot;
  }
  if (!Util.isUnset(request.expiryTimeEnd)) {
    query['ExpiryTimeEnd'] = request.expiryTimeEnd;
  }
  if (!Util.isUnset(request.expiryTimeStart)) {
    query['ExpiryTimeStart'] = request.expiryTimeStart;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryPrepaidCards',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryPrepaidCards(request: QueryPrepaidCardsRequest): QueryPrepaidCardsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryPrepaidCardsWithOptions(request, runtime);
}

model QueryProductListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  queryTotalCount?: boolean(name='QueryTotalCount'),
}

model QueryProductListResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    productList?: {
      product?: [ 
      {
        productCode?: string(name='ProductCode'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        subscriptionType?: string(name='SubscriptionType'),
      }
    ](name='Product')
    }(name='ProductList'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryProductListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryProductListResponseBody(name='body'),
}

async function queryProductListWithOptions(request: QueryProductListRequest, runtime: Util.RuntimeOptions): QueryProductListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryTotalCount)) {
    query['QueryTotalCount'] = request.queryTotalCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryProductList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryProductList(request: QueryProductListRequest): QueryProductListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryProductListWithOptions(request, runtime);
}

model QueryRIUtilizationDetailRequest {
  deductedInstanceId?: string(name='DeductedInstanceId'),
  endTime?: string(name='EndTime'),
  instanceSpec?: string(name='InstanceSpec'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  RICommodityCode?: string(name='RICommodityCode'),
  RIInstanceId?: string(name='RIInstanceId'),
  startTime?: string(name='StartTime'),
}

model QueryRIUtilizationDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    detailList?: {
      detailList?: [ 
      {
        deductDate?: string(name='DeductDate'),
        deductFactorTotal?: float(name='DeductFactorTotal'),
        deductHours?: string(name='DeductHours'),
        deductQuantity?: float(name='DeductQuantity'),
        deductedCommodityCode?: string(name='DeductedCommodityCode'),
        deductedInstanceId?: string(name='DeductedInstanceId'),
        deductedProductDetail?: string(name='DeductedProductDetail'),
        instanceSpec?: string(name='InstanceSpec'),
        RIInstanceId?: string(name='RIInstanceId'),
      }
    ](name='DetailList')
    }(name='DetailList'),
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRIUtilizationDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRIUtilizationDetailResponseBody(name='body'),
}

async function queryRIUtilizationDetailWithOptions(request: QueryRIUtilizationDetailRequest, runtime: Util.RuntimeOptions): QueryRIUtilizationDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deductedInstanceId)) {
    query['DeductedInstanceId'] = request.deductedInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceSpec)) {
    query['InstanceSpec'] = request.instanceSpec;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.RICommodityCode)) {
    query['RICommodityCode'] = request.RICommodityCode;
  }
  if (!Util.isUnset(request.RIInstanceId)) {
    query['RIInstanceId'] = request.RIInstanceId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRIUtilizationDetail',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRIUtilizationDetail(request: QueryRIUtilizationDetailRequest): QueryRIUtilizationDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRIUtilizationDetailWithOptions(request, runtime);
}

model QueryRedeemRequest {
  effectiveOrNot?: boolean(name='EffectiveOrNot'),
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model QueryRedeemResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    redeem?: {
      redeem?: [ 
      {
        applicableProducts?: string(name='ApplicableProducts'),
        balance?: string(name='Balance'),
        effectiveTime?: string(name='EffectiveTime'),
        expiryTime?: string(name='ExpiryTime'),
        grantedTime?: string(name='GrantedTime'),
        nominalValue?: string(name='NominalValue'),
        redeemId?: string(name='RedeemId'),
        redeemNo?: string(name='RedeemNo'),
        specification?: string(name='Specification'),
        status?: string(name='Status'),
      }
    ](name='Redeem')
    }(name='Redeem'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRedeemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRedeemResponseBody(name='body'),
}

async function queryRedeemWithOptions(request: QueryRedeemRequest, runtime: Util.RuntimeOptions): QueryRedeemResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRedeem',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRedeem(request: QueryRedeemRequest): QueryRedeemResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRedeemWithOptions(request, runtime);
}

model QueryRelationListRequest {
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  statusList?: [ string ](name='StatusList'),
  userId?: long(name='UserId'),
}

model QueryRelationListResponseBody = {
  code?: string(name='Code'),
  data?: {
    financialRelationInfoList?: [ 
      {
        accountId?: long(name='AccountId'),
        accountName?: string(name='AccountName'),
        accountNickName?: string(name='AccountNickName'),
        accountType?: string(name='AccountType'),
        endTime?: string(name='EndTime'),
        relationId?: long(name='RelationId'),
        relationType?: string(name='RelationType'),
        setupTime?: string(name='SetupTime'),
        startTime?: string(name='StartTime'),
        state?: string(name='State'),
      }
    ](name='FinancialRelationInfoList'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryRelationListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryRelationListResponseBody(name='body'),
}

async function queryRelationListWithOptions(request: QueryRelationListRequest, runtime: Util.RuntimeOptions): QueryRelationListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.statusList)) {
    query['StatusList'] = request.statusList;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRelationList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryRelationList(request: QueryRelationListRequest): QueryRelationListResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryRelationListWithOptions(request, runtime);
}

model QueryResellerAvailableQuotaRequest {
  itemCodes?: string(name='ItemCodes'),
  ownerId?: long(name='OwnerId'),
}

model QueryResellerAvailableQuotaResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryResellerAvailableQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryResellerAvailableQuotaResponseBody(name='body'),
}

async function queryResellerAvailableQuotaWithOptions(request: QueryResellerAvailableQuotaRequest, runtime: Util.RuntimeOptions): QueryResellerAvailableQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.itemCodes)) {
    query['ItemCodes'] = request.itemCodes;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryResellerAvailableQuota',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryResellerAvailableQuota(request: QueryResellerAvailableQuotaRequest): QueryResellerAvailableQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryResellerAvailableQuotaWithOptions(request, runtime);
}

model QueryResourcePackageInstancesRequest {
  expiryTimeEnd?: string(name='ExpiryTimeEnd'),
  expiryTimeStart?: string(name='ExpiryTimeStart'),
  includePartner?: boolean(name='IncludePartner'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
}

model QueryResourcePackageInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    instances?: {
      instance?: [ 
      {
        applicableProducts?: {
          product?: [ string ](name='Product')
        }(name='ApplicableProducts'),
        commodityCode?: string(name='CommodityCode'),
        deductType?: string(name='DeductType'),
        effectiveTime?: string(name='EffectiveTime'),
        expiryTime?: string(name='ExpiryTime'),
        instanceId?: string(name='InstanceId'),
        packageType?: string(name='PackageType'),
        region?: string(name='Region'),
        remainingAmount?: string(name='RemainingAmount'),
        remainingAmountUnit?: string(name='RemainingAmountUnit'),
        remark?: string(name='Remark'),
        status?: string(name='Status'),
        totalAmount?: string(name='TotalAmount'),
        totalAmountUnit?: string(name='TotalAmountUnit'),
      }
    ](name='Instance')
    }(name='Instances'),
    pageNum?: string(name='PageNum'),
    pageSize?: string(name='PageSize'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: int32(name='Total'),
}

model QueryResourcePackageInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryResourcePackageInstancesResponseBody(name='body'),
}

async function queryResourcePackageInstancesWithOptions(request: QueryResourcePackageInstancesRequest, runtime: Util.RuntimeOptions): QueryResourcePackageInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expiryTimeEnd)) {
    query['ExpiryTimeEnd'] = request.expiryTimeEnd;
  }
  if (!Util.isUnset(request.expiryTimeStart)) {
    query['ExpiryTimeStart'] = request.expiryTimeStart;
  }
  if (!Util.isUnset(request.includePartner)) {
    query['IncludePartner'] = request.includePartner;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryResourcePackageInstances',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryResourcePackageInstances(request: QueryResourcePackageInstancesRequest): QueryResourcePackageInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryResourcePackageInstancesWithOptions(request, runtime);
}

model QuerySavingsPlansDeductLogRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  instanceType?: string(name='InstanceType'),
  locale?: string(name='Locale'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model QuerySavingsPlansDeductLogResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        billModule?: string(name='BillModule'),
        deductCommodity?: string(name='DeductCommodity'),
        deductFee?: string(name='DeductFee'),
        deductInstanceId?: string(name='DeductInstanceId'),
        deductRate?: string(name='DeductRate'),
        discountRate?: string(name='DiscountRate'),
        endTime?: string(name='EndTime'),
        instanceId?: string(name='InstanceId'),
        ownerId?: long(name='OwnerId'),
        savingsType?: string(name='SavingsType'),
        startTime?: string(name='StartTime'),
        userId?: long(name='UserId'),
      }
    ](name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySavingsPlansDeductLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySavingsPlansDeductLogResponseBody(name='body'),
}

async function querySavingsPlansDeductLogWithOptions(request: QuerySavingsPlansDeductLogRequest, runtime: Util.RuntimeOptions): QuerySavingsPlansDeductLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.locale)) {
    query['Locale'] = request.locale;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySavingsPlansDeductLog',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySavingsPlansDeductLog(request: QuerySavingsPlansDeductLogRequest): QuerySavingsPlansDeductLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySavingsPlansDeductLogWithOptions(request, runtime);
}

model QuerySavingsPlansInstanceRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  locale?: string(name='Locale'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model QuerySavingsPlansInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    items?: [ 
      {
        allocationStatus?: string(name='AllocationStatus'),
        currency?: string(name='Currency'),
        cycle?: string(name='Cycle'),
        endTime?: string(name='EndTime'),
        endTimestamp?: long(name='EndTimestamp'),
        instanceFamily?: string(name='InstanceFamily'),
        instanceId?: string(name='InstanceId'),
        lastBillTotalUsage?: string(name='LastBillTotalUsage'),
        lastBillUtilization?: string(name='LastBillUtilization'),
        payMode?: string(name='PayMode'),
        poolValue?: string(name='PoolValue'),
        prepayFee?: string(name='PrepayFee'),
        region?: string(name='Region'),
        savingsType?: string(name='SavingsType'),
        startTime?: string(name='StartTime'),
        startTimestamp?: long(name='StartTimestamp'),
        status?: string(name='Status'),
        tags?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='Tags'),
        totalSave?: string(name='TotalSave'),
        utilization?: string(name='Utilization'),
      }
    ](name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySavingsPlansInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySavingsPlansInstanceResponseBody(name='body'),
}

async function querySavingsPlansInstanceWithOptions(request: QuerySavingsPlansInstanceRequest, runtime: Util.RuntimeOptions): QuerySavingsPlansInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.locale)) {
    query['Locale'] = request.locale;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySavingsPlansInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySavingsPlansInstance(request: QuerySavingsPlansInstanceRequest): QuerySavingsPlansInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySavingsPlansInstanceWithOptions(request, runtime);
}

model QuerySettleBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  isDisplayLocalCurrency?: boolean(name='IsDisplayLocalCurrency'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  recordID?: string(name='RecordID'),
  subscriptionType?: string(name='SubscriptionType'),
  type?: string(name='Type'),
}

model QuerySettleBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        afterTaxAmount?: float(name='AfterTaxAmount'),
        billAccountID?: string(name='BillAccountID'),
        billAccountName?: string(name='BillAccountName'),
        bizType?: string(name='BizType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        paymentTime?: string(name='PaymentTime'),
        paymentTransactionID?: string(name='PaymentTransactionID'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        recordID?: string(name='RecordID'),
        roundDownDiscount?: string(name='RoundDownDiscount'),
        status?: string(name='Status'),
        subOrderId?: string(name='SubOrderId'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: float(name='Tax'),
        usageEndTime?: string(name='UsageEndTime'),
        usageStartTime?: string(name='UsageStartTime'),
      }
    ](name='Item')
    }(name='Items'),
    maxResults?: int32(name='MaxResults'),
    nextToken?: string(name='NextToken'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySettleBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySettleBillResponseBody(name='body'),
}

async function querySettleBillWithOptions(request: QuerySettleBillRequest, runtime: Util.RuntimeOptions): QuerySettleBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.isDisplayLocalCurrency)) {
    query['IsDisplayLocalCurrency'] = request.isDisplayLocalCurrency;
  }
  if (!Util.isUnset(request.isHideZeroCharge)) {
    query['IsHideZeroCharge'] = request.isHideZeroCharge;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.recordID)) {
    query['RecordID'] = request.recordID;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySettleBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySettleBill(request: QuerySettleBillRequest): QuerySettleBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySettleBillWithOptions(request, runtime);
}

model QuerySettlementBillRequest {
  billingCycle?: string(name='BillingCycle'),
  endTime?: string(name='EndTime'),
  isHideZeroCharge?: boolean(name='IsHideZeroCharge'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  startTime?: string(name='StartTime'),
  subscriptionType?: string(name='SubscriptionType'),
  type?: string(name='Type'),
}

model QuerySettlementBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        accountDiscount?: float(name='AccountDiscount'),
        afterTaxAmount?: float(name='AfterTaxAmount'),
        billID?: string(name='BillID'),
        chargeDiscount?: float(name='ChargeDiscount'),
        clearedTime?: string(name='ClearedTime'),
        config?: string(name='Config'),
        createTime?: string(name='CreateTime'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        invoiceNo?: string(name='InvoiceNo'),
        item?: string(name='Item'),
        linkedCustomerOrderID?: string(name='LinkedCustomerOrderID'),
        mybankPaymentAmount?: float(name='MybankPaymentAmount'),
        orderID?: string(name='OrderID'),
        orderType?: string(name='OrderType'),
        originalOrderID?: string(name='OriginalOrderID'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        payerAccount?: string(name='PayerAccount'),
        paymentAmount?: float(name='PaymentAmount'),
        paymentCurrency?: string(name='PaymentCurrency'),
        paymentTime?: string(name='PaymentTime'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxAmountLocal?: float(name='PretaxAmountLocal'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        previousBillingCycleBalance?: float(name='PreviousBillingCycleBalance'),
        productCode?: string(name='ProductCode'),
        productType?: string(name='ProductType'),
        promotion?: string(name='Promotion'),
        quantity?: string(name='Quantity'),
        recordID?: string(name='RecordID'),
        region?: string(name='Region'),
        seller?: string(name='Seller'),
        solutionID?: string(name='SolutionID'),
        solutionName?: string(name='SolutionName'),
        status?: string(name='Status'),
        suborderID?: string(name='SuborderID'),
        subscriptionType?: string(name='SubscriptionType'),
        tax?: float(name='Tax'),
        usageEndTime?: string(name='UsageEndTime'),
        usageStartTime?: string(name='UsageStartTime'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySettlementBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySettlementBillResponseBody(name='body'),
}

async function querySettlementBillWithOptions(request: QuerySettlementBillRequest, runtime: Util.RuntimeOptions): QuerySettlementBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.isHideZeroCharge)) {
    query['IsHideZeroCharge'] = request.isHideZeroCharge;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySettlementBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySettlementBill(request: QuerySettlementBillRequest): QuerySettlementBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySettlementBillWithOptions(request, runtime);
}

model QuerySkuPriceListRequest {
  commodityCode?: string(name='CommodityCode'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  priceEntityCode?: string(name='PriceEntityCode'),
  priceFactorConditionMap?: map[string] [ string ](name='PriceFactorConditionMap'),
}

model QuerySkuPriceListShrinkRequest {
  commodityCode?: string(name='CommodityCode'),
  nextPageToken?: string(name='NextPageToken'),
  pageSize?: int32(name='PageSize'),
  priceEntityCode?: string(name='PriceEntityCode'),
  priceFactorConditionMapShrink?: string(name='PriceFactorConditionMap'),
}

model QuerySkuPriceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    skuPricePage?: {
      nextPageToken?: string(name='NextPageToken'),
      skuPriceList?: [ 
        {
          cskuPriceList?: [ 
            {
              cskuCode?: string(name='CskuCode'),
              currency?: string(name='Currency'),
              price?: string(name='Price'),
              priceMode?: string(name='PriceMode'),
              priceType?: string(name='PriceType'),
              priceUnit?: string(name='PriceUnit'),
              rangeList?: [ 
                {
                  factorCode?: string(name='FactorCode'),
                  max?: string(name='Max'),
                  min?: string(name='Min'),
                  type?: string(name='Type'),
                }
              ](name='RangeList'),
              usageUnit?: string(name='UsageUnit'),
            }
          ](name='CskuPriceList'),
          skuCode?: string(name='SkuCode'),
          skuFactorMap?: map[string]string(name='SkuFactorMap'),
        }
      ](name='SkuPriceList'),
      totalCount?: int32(name='TotalCount'),
    }(name='SkuPricePage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySkuPriceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySkuPriceListResponseBody(name='body'),
}

async function querySkuPriceListWithOptions(tmpReq: QuerySkuPriceListRequest, runtime: Util.RuntimeOptions): QuerySkuPriceListResponse {
  Util.validateModel(tmpReq);
  var request = new QuerySkuPriceListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.priceFactorConditionMap)) {
    request.priceFactorConditionMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.priceFactorConditionMap, 'PriceFactorConditionMap', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySkuPriceList',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySkuPriceList(request: QuerySkuPriceListRequest): QuerySkuPriceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySkuPriceListWithOptions(request, runtime);
}

model QuerySplitItemBillRequest {
  billOwnerId?: long(name='BillOwnerId'),
  billingCycle?: string(name='BillingCycle'),
  ownerId?: long(name='OwnerId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  subscriptionType?: string(name='SubscriptionType'),
}

model QuerySplitItemBillResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountID?: string(name='AccountID'),
    accountName?: string(name='AccountName'),
    billingCycle?: string(name='BillingCycle'),
    items?: {
      item?: [ 
      {
        adjustAmount?: float(name='AdjustAmount'),
        billingDate?: string(name='BillingDate'),
        billingItem?: string(name='BillingItem'),
        billingType?: string(name='BillingType'),
        cashAmount?: float(name='CashAmount'),
        commodityCode?: string(name='CommodityCode'),
        costUnit?: string(name='CostUnit'),
        currency?: string(name='Currency'),
        deductedByCashCoupons?: float(name='DeductedByCashCoupons'),
        deductedByCoupons?: float(name='DeductedByCoupons'),
        deductedByPrepaidCard?: float(name='DeductedByPrepaidCard'),
        deductedByResourcePackage?: string(name='DeductedByResourcePackage'),
        instanceConfig?: string(name='InstanceConfig'),
        instanceID?: string(name='InstanceID'),
        instanceSpec?: string(name='InstanceSpec'),
        internetIP?: string(name='InternetIP'),
        intranetIP?: string(name='IntranetIP'),
        invoiceDiscount?: float(name='InvoiceDiscount'),
        item?: string(name='Item'),
        listPrice?: string(name='ListPrice'),
        listPriceUnit?: string(name='ListPriceUnit'),
        nickName?: string(name='NickName'),
        outstandingAmount?: float(name='OutstandingAmount'),
        ownerID?: string(name='OwnerID'),
        paymentAmount?: float(name='PaymentAmount'),
        pipCode?: string(name='PipCode'),
        pretaxAmount?: float(name='PretaxAmount'),
        pretaxGrossAmount?: float(name='PretaxGrossAmount'),
        productCode?: string(name='ProductCode'),
        productDetail?: string(name='ProductDetail'),
        productName?: string(name='ProductName'),
        productType?: string(name='ProductType'),
        region?: string(name='Region'),
        resourceGroup?: string(name='ResourceGroup'),
        servicePeriod?: string(name='ServicePeriod'),
        servicePeriodUnit?: string(name='ServicePeriodUnit'),
        splitAccountID?: string(name='SplitAccountID'),
        splitAccountName?: string(name='SplitAccountName'),
        splitBillingCycle?: string(name='SplitBillingCycle'),
        splitCommodityCode?: string(name='SplitCommodityCode'),
        splitItemID?: string(name='SplitItemID'),
        splitItemName?: string(name='SplitItemName'),
        splitProductDetail?: string(name='SplitProductDetail'),
        subscriptionType?: string(name='SubscriptionType'),
        tag?: string(name='Tag'),
        usage?: string(name='Usage'),
        usageUnit?: string(name='UsageUnit'),
        zone?: string(name='Zone'),
      }
    ](name='Item')
    }(name='Items'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySplitItemBillResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySplitItemBillResponseBody(name='body'),
}

async function querySplitItemBillWithOptions(request: QuerySplitItemBillRequest, runtime: Util.RuntimeOptions): QuerySplitItemBillResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.billOwnerId)) {
    query['BillOwnerId'] = request.billOwnerId;
  }
  if (!Util.isUnset(request.billingCycle)) {
    query['BillingCycle'] = request.billingCycle;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySplitItemBill',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySplitItemBill(request: QuerySplitItemBillRequest): QuerySplitItemBillResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySplitItemBillWithOptions(request, runtime);
}

model QueryUserOmsDataRequest {
  dataType?: string(name='DataType'),
  endTime?: string(name='EndTime'),
  marker?: string(name='Marker'),
  ownerId?: long(name='OwnerId'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  table?: string(name='Table'),
}

model QueryUserOmsDataResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    marker?: string(name='Marker'),
    omsData?: [  map[string]any ](name='OmsData'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryUserOmsDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryUserOmsDataResponseBody(name='body'),
}

async function queryUserOmsDataWithOptions(request: QueryUserOmsDataRequest, runtime: Util.RuntimeOptions): QueryUserOmsDataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dataType)) {
    query['DataType'] = request.dataType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.marker)) {
    query['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.table)) {
    query['Table'] = request.table;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryUserOmsData',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryUserOmsData(request: QueryUserOmsDataRequest): QueryUserOmsDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryUserOmsDataWithOptions(request, runtime);
}

model RefundInstanceRequest {
  clientToken?: string(name='ClientToken'),
  immediatelyRelease?: string(name='ImmediatelyRelease'),
  instanceId?: string(name='InstanceId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
}

model RefundInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    orderId?: long(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RefundInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefundInstanceResponseBody(name='body'),
}

async function refundInstanceWithOptions(request: RefundInstanceRequest, runtime: Util.RuntimeOptions): RefundInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.immediatelyRelease)) {
    query['ImmediatelyRelease'] = request.immediatelyRelease;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RefundInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refundInstance(request: RefundInstanceRequest): RefundInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return refundInstanceWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  instanceIds?: string(name='InstanceIds'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  region?: string(name='Region'),
  renewStatus?: string(name='RenewStatus'),
  subscriptionType?: string(name='SubscriptionType'),
}

model ReleaseInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
    releaseResult?: boolean(name='ReleaseResult'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseInstanceResponseBody(name='body'),
}

async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.renewStatus)) {
    query['RenewStatus'] = request.renewStatus;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model RelieveAccountRelationRequest {
  childUserId?: long(name='ChildUserId'),
  parentUserId?: long(name='ParentUserId'),
  relationId?: long(name='RelationId'),
  relationType?: string(name='RelationType'),
  requestId?: string(name='RequestId'),
}

model RelieveAccountRelationResponseBody = {
  code?: string(name='Code'),
  data?: {
    hostId?: string(name='HostId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RelieveAccountRelationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RelieveAccountRelationResponseBody(name='body'),
}

async function relieveAccountRelationWithOptions(request: RelieveAccountRelationRequest, runtime: Util.RuntimeOptions): RelieveAccountRelationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.childUserId)) {
    query['ChildUserId'] = request.childUserId;
  }
  if (!Util.isUnset(request.parentUserId)) {
    query['ParentUserId'] = request.parentUserId;
  }
  if (!Util.isUnset(request.relationId)) {
    query['RelationId'] = request.relationId;
  }
  if (!Util.isUnset(request.relationType)) {
    query['RelationType'] = request.relationType;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RelieveAccountRelation',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function relieveAccountRelation(request: RelieveAccountRelationRequest): RelieveAccountRelationResponse {
  var runtime = new Util.RuntimeOptions{};
  return relieveAccountRelationWithOptions(request, runtime);
}

model RenewInstanceRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  renewPeriod?: int32(name='RenewPeriod'),
}

model RenewInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    orderId?: string(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.renewPeriod)) {
    query['RenewPeriod'] = request.renewPeriod;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model RenewResourcePackageRequest {
  duration?: int32(name='Duration'),
  effectiveDate?: string(name='EffectiveDate'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  pricingCycle?: string(name='PricingCycle'),
}

model RenewResourcePackageResponseBody = {
  code?: string(name='Code'),
  data?: {
    instanceId?: string(name='InstanceId'),
    orderId?: long(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RenewResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewResourcePackageResponseBody(name='body'),
}

async function renewResourcePackageWithOptions(request: RenewResourcePackageRequest, runtime: Util.RuntimeOptions): RenewResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.effectiveDate)) {
    query['EffectiveDate'] = request.effectiveDate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pricingCycle)) {
    query['PricingCycle'] = request.pricingCycle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewResourcePackage',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewResourcePackage(request: RenewResourcePackageRequest): RenewResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewResourcePackageWithOptions(request, runtime);
}

model SaveUserCreditRequest {
  avoidExpiration?: boolean(name='AvoidExpiration'),
  avoidNotification?: boolean(name='AvoidNotification'),
  avoidPrepaidExpiration?: boolean(name='AvoidPrepaidExpiration'),
  avoidPrepaidNotification?: boolean(name='AvoidPrepaidNotification'),
  creditType?: string(name='CreditType'),
  creditValue?: string(name='CreditValue'),
  description?: string(name='Description'),
  operator?: string(name='Operator'),
}

model SaveUserCreditResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveUserCreditResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveUserCreditResponseBody(name='body'),
}

async function saveUserCreditWithOptions(request: SaveUserCreditRequest, runtime: Util.RuntimeOptions): SaveUserCreditResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.avoidExpiration)) {
    query['AvoidExpiration'] = request.avoidExpiration;
  }
  if (!Util.isUnset(request.avoidNotification)) {
    query['AvoidNotification'] = request.avoidNotification;
  }
  if (!Util.isUnset(request.avoidPrepaidExpiration)) {
    query['AvoidPrepaidExpiration'] = request.avoidPrepaidExpiration;
  }
  if (!Util.isUnset(request.avoidPrepaidNotification)) {
    query['AvoidPrepaidNotification'] = request.avoidPrepaidNotification;
  }
  if (!Util.isUnset(request.creditType)) {
    query['CreditType'] = request.creditType;
  }
  if (!Util.isUnset(request.creditValue)) {
    query['CreditValue'] = request.creditValue;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SaveUserCredit',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveUserCredit(request: SaveUserCreditRequest): SaveUserCreditResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveUserCreditWithOptions(request, runtime);
}

model SetAllExpirationDayRequest {
  ownerId?: long(name='OwnerId'),
  unifyExpireDay?: string(name='UnifyExpireDay'),
}

model SetAllExpirationDayResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetAllExpirationDayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAllExpirationDayResponseBody(name='body'),
}

async function setAllExpirationDayWithOptions(request: SetAllExpirationDayRequest, runtime: Util.RuntimeOptions): SetAllExpirationDayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.unifyExpireDay)) {
    query['UnifyExpireDay'] = request.unifyExpireDay;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetAllExpirationDay',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAllExpirationDay(request: SetAllExpirationDayRequest): SetAllExpirationDayResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAllExpirationDayWithOptions(request, runtime);
}

model SetCreditLabelActionRequest {
  actionType?: string(name='ActionType'),
  clearCycle?: string(name='ClearCycle'),
  creditAmount?: string(name='CreditAmount'),
  currencyCode?: string(name='CurrencyCode'),
  dailyCycle?: string(name='DailyCycle'),
  description?: string(name='Description'),
  isNeedAddSettleLabel?: string(name='IsNeedAddSettleLabel'),
  isNeedAdjustCreditAccount?: string(name='IsNeedAdjustCreditAccount'),
  isNeedSaveNotifyRule?: string(name='IsNeedSaveNotifyRule'),
  isNeedSetCreditAmount?: string(name='IsNeedSetCreditAmount'),
  needNotice?: boolean(name='NeedNotice'),
  newCreateMode?: boolean(name='NewCreateMode'),
  operator?: string(name='Operator'),
  requestId?: string(name='RequestId'),
  siteCode?: string(name='SiteCode'),
  source?: string(name='Source'),
  uid?: string(name='Uid'),
}

model SetCreditLabelActionResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetCreditLabelActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetCreditLabelActionResponseBody(name='body'),
}

async function setCreditLabelActionWithOptions(request: SetCreditLabelActionRequest, runtime: Util.RuntimeOptions): SetCreditLabelActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.clearCycle)) {
    query['ClearCycle'] = request.clearCycle;
  }
  if (!Util.isUnset(request.creditAmount)) {
    query['CreditAmount'] = request.creditAmount;
  }
  if (!Util.isUnset(request.currencyCode)) {
    query['CurrencyCode'] = request.currencyCode;
  }
  if (!Util.isUnset(request.dailyCycle)) {
    query['DailyCycle'] = request.dailyCycle;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.isNeedAddSettleLabel)) {
    query['IsNeedAddSettleLabel'] = request.isNeedAddSettleLabel;
  }
  if (!Util.isUnset(request.isNeedAdjustCreditAccount)) {
    query['IsNeedAdjustCreditAccount'] = request.isNeedAdjustCreditAccount;
  }
  if (!Util.isUnset(request.isNeedSaveNotifyRule)) {
    query['IsNeedSaveNotifyRule'] = request.isNeedSaveNotifyRule;
  }
  if (!Util.isUnset(request.isNeedSetCreditAmount)) {
    query['IsNeedSetCreditAmount'] = request.isNeedSetCreditAmount;
  }
  if (!Util.isUnset(request.needNotice)) {
    query['NeedNotice'] = request.needNotice;
  }
  if (!Util.isUnset(request.newCreateMode)) {
    query['NewCreateMode'] = request.newCreateMode;
  }
  if (!Util.isUnset(request.operator)) {
    query['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.requestId)) {
    query['RequestId'] = request.requestId;
  }
  if (!Util.isUnset(request.siteCode)) {
    query['SiteCode'] = request.siteCode;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetCreditLabelAction',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setCreditLabelAction(request: SetCreditLabelActionRequest): SetCreditLabelActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return setCreditLabelActionWithOptions(request, runtime);
}

model SetRenewalRequest {
  instanceIDs?: string(name='InstanceIDs'),
  ownerId?: long(name='OwnerId'),
  productCode?: string(name='ProductCode'),
  productType?: string(name='ProductType'),
  renewalPeriod?: int32(name='RenewalPeriod'),
  renewalPeriodUnit?: string(name='RenewalPeriodUnit'),
  renewalStatus?: string(name='RenewalStatus'),
  subscriptionType?: string(name='SubscriptionType'),
}

model SetRenewalResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetRenewalResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetRenewalResponseBody(name='body'),
}

async function setRenewalWithOptions(request: SetRenewalRequest, runtime: Util.RuntimeOptions): SetRenewalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceIDs)) {
    query['InstanceIDs'] = request.instanceIDs;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.productCode)) {
    query['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.productType)) {
    query['ProductType'] = request.productType;
  }
  if (!Util.isUnset(request.renewalPeriod)) {
    query['RenewalPeriod'] = request.renewalPeriod;
  }
  if (!Util.isUnset(request.renewalPeriodUnit)) {
    query['RenewalPeriodUnit'] = request.renewalPeriodUnit;
  }
  if (!Util.isUnset(request.renewalStatus)) {
    query['RenewalStatus'] = request.renewalStatus;
  }
  if (!Util.isUnset(request.subscriptionType)) {
    query['SubscriptionType'] = request.subscriptionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetRenewal',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setRenewal(request: SetRenewalRequest): SetRenewalResponse {
  var runtime = new Util.RuntimeOptions{};
  return setRenewalWithOptions(request, runtime);
}

model SetResellerUserAlarmThresholdRequest {
  alarmThresholds?: string(name='AlarmThresholds'),
  alarmType?: string(name='AlarmType'),
  ownerId?: long(name='OwnerId'),
}

model SetResellerUserAlarmThresholdResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetResellerUserAlarmThresholdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetResellerUserAlarmThresholdResponseBody(name='body'),
}

async function setResellerUserAlarmThresholdWithOptions(request: SetResellerUserAlarmThresholdRequest, runtime: Util.RuntimeOptions): SetResellerUserAlarmThresholdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alarmThresholds)) {
    query['AlarmThresholds'] = request.alarmThresholds;
  }
  if (!Util.isUnset(request.alarmType)) {
    query['AlarmType'] = request.alarmType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetResellerUserAlarmThreshold',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setResellerUserAlarmThreshold(request: SetResellerUserAlarmThresholdRequest): SetResellerUserAlarmThresholdResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserAlarmThresholdWithOptions(request, runtime);
}

model SetResellerUserQuotaRequest {
  amount?: string(name='Amount'),
  currency?: string(name='Currency'),
  outBizId?: string(name='OutBizId'),
  ownerId?: long(name='OwnerId'),
}

model SetResellerUserQuotaResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetResellerUserQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetResellerUserQuotaResponseBody(name='body'),
}

async function setResellerUserQuotaWithOptions(request: SetResellerUserQuotaRequest, runtime: Util.RuntimeOptions): SetResellerUserQuotaResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.currency)) {
    query['Currency'] = request.currency;
  }
  if (!Util.isUnset(request.outBizId)) {
    query['OutBizId'] = request.outBizId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetResellerUserQuota',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setResellerUserQuota(request: SetResellerUserQuotaRequest): SetResellerUserQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserQuotaWithOptions(request, runtime);
}

model SetResellerUserStatusRequest {
  businessType?: string(name='BusinessType'),
  ownerId?: string(name='OwnerId'),
  status?: string(name='Status'),
}

model SetResellerUserStatusResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetResellerUserStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetResellerUserStatusResponseBody(name='body'),
}

async function setResellerUserStatusWithOptions(request: SetResellerUserStatusRequest, runtime: Util.RuntimeOptions): SetResellerUserStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessType)) {
    query['BusinessType'] = request.businessType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetResellerUserStatus',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setResellerUserStatus(request: SetResellerUserStatusRequest): SetResellerUserStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return setResellerUserStatusWithOptions(request, runtime);
}

model SubscribeBillToOSSRequest {
  beginBillingCycle?: string(name='BeginBillingCycle'),
  bucketOwnerId?: long(name='BucketOwnerId'),
  bucketPath?: string(name='BucketPath'),
  multAccountRelSubscribe?: string(name='MultAccountRelSubscribe'),
  subscribeBucket?: string(name='SubscribeBucket'),
  subscribeType?: string(name='SubscribeType'),
}

model SubscribeBillToOSSResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SubscribeBillToOSSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubscribeBillToOSSResponseBody(name='body'),
}

async function subscribeBillToOSSWithOptions(request: SubscribeBillToOSSRequest, runtime: Util.RuntimeOptions): SubscribeBillToOSSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginBillingCycle)) {
    query['BeginBillingCycle'] = request.beginBillingCycle;
  }
  if (!Util.isUnset(request.bucketOwnerId)) {
    query['BucketOwnerId'] = request.bucketOwnerId;
  }
  if (!Util.isUnset(request.bucketPath)) {
    query['BucketPath'] = request.bucketPath;
  }
  if (!Util.isUnset(request.multAccountRelSubscribe)) {
    query['MultAccountRelSubscribe'] = request.multAccountRelSubscribe;
  }
  if (!Util.isUnset(request.subscribeBucket)) {
    query['SubscribeBucket'] = request.subscribeBucket;
  }
  if (!Util.isUnset(request.subscribeType)) {
    query['SubscribeType'] = request.subscribeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SubscribeBillToOSS',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function subscribeBillToOSS(request: SubscribeBillToOSSRequest): SubscribeBillToOSSResponse {
  var runtime = new Util.RuntimeOptions{};
  return subscribeBillToOSSWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UnsubscribeBillToOSSRequest {
  multAccountRelSubscribe?: string(name='MultAccountRelSubscribe'),
  subscribeType?: string(name='SubscribeType'),
}

model UnsubscribeBillToOSSResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnsubscribeBillToOSSResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnsubscribeBillToOSSResponseBody(name='body'),
}

async function unsubscribeBillToOSSWithOptions(request: UnsubscribeBillToOSSRequest, runtime: Util.RuntimeOptions): UnsubscribeBillToOSSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.multAccountRelSubscribe)) {
    query['MultAccountRelSubscribe'] = request.multAccountRelSubscribe;
  }
  if (!Util.isUnset(request.subscribeType)) {
    query['SubscribeType'] = request.subscribeType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnsubscribeBillToOSS',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unsubscribeBillToOSS(request: UnsubscribeBillToOSSRequest): UnsubscribeBillToOSSResponse {
  var runtime = new Util.RuntimeOptions{};
  return unsubscribeBillToOSSWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  resourceId?: [ string ](name='ResourceId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpgradeResourcePackageRequest {
  effectiveDate?: string(name='EffectiveDate'),
  instanceId?: string(name='InstanceId'),
  ownerId?: long(name='OwnerId'),
  specification?: string(name='Specification'),
}

model UpgradeResourcePackageResponseBody = {
  code?: string(name='Code'),
  data?: {
    instanceId?: string(name='InstanceId'),
    orderId?: long(name='OrderId'),
  }(name='Data'),
  message?: string(name='Message'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeResourcePackageResponseBody(name='body'),
}

async function upgradeResourcePackageWithOptions(request: UpgradeResourcePackageRequest, runtime: Util.RuntimeOptions): UpgradeResourcePackageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.effectiveDate)) {
    query['EffectiveDate'] = request.effectiveDate;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.specification)) {
    query['Specification'] = request.specification;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeResourcePackage',
    version = '2017-12-14',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeResourcePackage(request: UpgradeResourcePackageRequest): UpgradeResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeResourcePackageWithOptions(request, runtime);
}

