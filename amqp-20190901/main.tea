/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('amqp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model BindRequest {
  argument?: string(name='Argument'),
  bindingKey?: string(name='BindingKey'),
  bindingType?: int32(name='BindingType', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  dstName?: string(name='DstName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  srcName?: string(name='SrcName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model BindResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindResponseBody(name='body'),
}

/**
 * @summary 路由绑定
 *
 * @param request BindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BindResponse
 */
async function bindWithOptions(request: BindRequest, runtime: Util.RuntimeOptions): BindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.argument)) {
    query['Argument'] = request.argument;
  }
  if (!Util.isUnset(request.bindingKey)) {
    query['BindingKey'] = request.bindingKey;
  }
  if (!Util.isUnset(request.bindingType)) {
    query['BindingType'] = request.bindingType;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.dstName)) {
    query['DstName'] = request.dstName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.srcName)) {
    query['SrcName'] = request.srcName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Bind',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 路由绑定
 *
 * @param request BindRequest
 * @return BindResponse
 */
async function bind(request: BindRequest): BindResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindWithOptions(request, runtime);
}

model CancelUserSettingRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
}

model CancelUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelUserSettingResponseBody(name='body'),
}

/**
 * @summary 删除用户配置
 *
 * @param request CancelUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelUserSettingResponse
 */
async function cancelUserSettingWithOptions(request: CancelUserSettingRequest, runtime: Util.RuntimeOptions): CancelUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelUserSetting',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除用户配置
 *
 * @param request CancelUserSettingRequest
 * @return CancelUserSettingResponse
 */
async function cancelUserSetting(request: CancelUserSettingRequest): CancelUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelUserSettingWithOptions(request, runtime);
}

model ConfigureUserSettingRequest {
  bucketName?: string(name='BucketName'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  logstore?: string(name='Logstore'),
  projectName?: string(name='ProjectName'),
  putType?: string(name='PutType', description='This parameter is required.'),
}

model ConfigureUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfigureUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigureUserSettingResponseBody(name='body'),
}

/**
 * @summary 新增用户配置
 *
 * @param request ConfigureUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConfigureUserSettingResponse
 */
async function configureUserSettingWithOptions(request: ConfigureUserSettingRequest, runtime: Util.RuntimeOptions): ConfigureUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.logstore)) {
    query['Logstore'] = request.logstore;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  if (!Util.isUnset(request.putType)) {
    query['PutType'] = request.putType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConfigureUserSetting',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 新增用户配置
 *
 * @param request ConfigureUserSettingRequest
 * @return ConfigureUserSettingResponse
 */
async function configureUserSetting(request: ConfigureUserSettingRequest): ConfigureUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return configureUserSettingWithOptions(request, runtime);
}

model ConsoleClearPretendStatusRequest {
  consoleSessionId?: string(name='ConsoleSessionId', description='This parameter is required.'),
}

model ConsoleClearPretendStatusResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConsoleClearPretendStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConsoleClearPretendStatusResponseBody(name='body'),
}

/**
 * @summary 清除售后视角状态
 *
 * @param request ConsoleClearPretendStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConsoleClearPretendStatusResponse
 */
async function consoleClearPretendStatusWithOptions(request: ConsoleClearPretendStatusRequest, runtime: Util.RuntimeOptions): ConsoleClearPretendStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConsoleClearPretendStatus',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 清除售后视角状态
 *
 * @param request ConsoleClearPretendStatusRequest
 * @return ConsoleClearPretendStatusResponse
 */
async function consoleClearPretendStatus(request: ConsoleClearPretendStatusRequest): ConsoleClearPretendStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return consoleClearPretendStatusWithOptions(request, runtime);
}

model ConsoleSavePretendStatusRequest {
  consoleSessionId?: string(name='ConsoleSessionId', description='This parameter is required.'),
  key?: string(name='Key', description='This parameter is required.'),
  type?: int32(name='Type', description='This parameter is required.'),
}

model ConsoleSavePretendStatusResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConsoleSavePretendStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConsoleSavePretendStatusResponseBody(name='body'),
}

/**
 * @summary 保存售后视角状态
 *
 * @param request ConsoleSavePretendStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ConsoleSavePretendStatusResponse
 */
async function consoleSavePretendStatusWithOptions(request: ConsoleSavePretendStatusRequest, runtime: Util.RuntimeOptions): ConsoleSavePretendStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ConsoleSavePretendStatus',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 保存售后视角状态
 *
 * @param request ConsoleSavePretendStatusRequest
 * @return ConsoleSavePretendStatusResponse
 */
async function consoleSavePretendStatus(request: ConsoleSavePretendStatusRequest): ConsoleSavePretendStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return consoleSavePretendStatusWithOptions(request, runtime);
}

model CreateCloudMonitorSLRRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model CreateCloudMonitorSLRResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCloudMonitorSLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudMonitorSLRResponseBody(name='body'),
}

/**
 * @summary 创建云监控相关角色
 *
 * @param request CreateCloudMonitorSLRRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateCloudMonitorSLRResponse
 */
async function createCloudMonitorSLRWithOptions(request: CreateCloudMonitorSLRRequest, runtime: Util.RuntimeOptions): CreateCloudMonitorSLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudMonitorSLR',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建云监控相关角色
 *
 * @param request CreateCloudMonitorSLRRequest
 * @return CreateCloudMonitorSLRResponse
 */
async function createCloudMonitorSLR(request: CreateCloudMonitorSLRRequest): CreateCloudMonitorSLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudMonitorSLRWithOptions(request, runtime);
}

model CreateExchangeRequest {
  alternateExchange?: string(name='AlternateExchange'),
  autoDelete?: boolean(name='AutoDelete'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeName?: string(name='ExchangeName', description='This parameter is required.'),
  exchangeType?: int32(name='ExchangeType', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  internal?: boolean(name='Internal'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
  XDelayedType?: string(name='XDelayedType'),
  XHashHeader?: string(name='XHashHeader'),
}

model CreateExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExchangeResponseBody(name='body'),
}

/**
 * @summary 创建Exchange
 *
 * @param request CreateExchangeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateExchangeResponse
 */
async function createExchangeWithOptions(request: CreateExchangeRequest, runtime: Util.RuntimeOptions): CreateExchangeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alternateExchange)) {
    query['AlternateExchange'] = request.alternateExchange;
  }
  if (!Util.isUnset(request.autoDelete)) {
    query['AutoDelete'] = request.autoDelete;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.exchangeName)) {
    query['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.exchangeType)) {
    query['ExchangeType'] = request.exchangeType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.internal)) {
    query['Internal'] = request.internal;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  if (!Util.isUnset(request.XDelayedType)) {
    query['XDelayedType'] = request.XDelayedType;
  }
  if (!Util.isUnset(request.XHashHeader)) {
    query['XHashHeader'] = request.XHashHeader;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateExchange',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Exchange
 *
 * @param request CreateExchangeRequest
 * @return CreateExchangeResponse
 */
async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExchangeWithOptions(request, runtime);
}

model CreateLogDeliverySLRRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model CreateLogDeliverySLRResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLogDeliverySLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLogDeliverySLRResponseBody(name='body'),
}

/**
 * @summary 创建日志相关角色
 *
 * @param request CreateLogDeliverySLRRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLogDeliverySLRResponse
 */
async function createLogDeliverySLRWithOptions(request: CreateLogDeliverySLRRequest, runtime: Util.RuntimeOptions): CreateLogDeliverySLRResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLogDeliverySLR',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建日志相关角色
 *
 * @param request CreateLogDeliverySLRRequest
 * @return CreateLogDeliverySLRResponse
 */
async function createLogDeliverySLR(request: CreateLogDeliverySLRRequest): CreateLogDeliverySLRResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLogDeliverySLRWithOptions(request, runtime);
}

model CreateQueueRequest {
  autoDelete?: boolean(name='AutoDelete'),
  autoExpire?: long(name='AutoExpire'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  deadLetterExchange?: string(name='DeadLetterExchange'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey'),
  exclusive?: boolean(name='Exclusive'),
  instanceId?: string(name='InstanceId'),
  maxLength?: long(name='MaxLength'),
  maximunPrioty?: long(name='MaximunPrioty'),
  messageTTL?: long(name='MessageTTL'),
  ordered?: boolean(name='Ordered'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  retryInherit?: boolean(name='RetryInherit'),
  retryInterval?: int32(name='RetryInterval'),
  retryTimes?: int32(name='RetryTimes'),
  singleActiveConsumer?: boolean(name='SingleActiveConsumer'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model CreateQueueResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

/**
 * @summary 创建队列
 *
 * @param request CreateQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateQueueResponse
 */
async function createQueueWithOptions(request: CreateQueueRequest, runtime: Util.RuntimeOptions): CreateQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoDelete)) {
    query['AutoDelete'] = request.autoDelete;
  }
  if (!Util.isUnset(request.autoExpire)) {
    query['AutoExpire'] = request.autoExpire;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.deadLetterExchange)) {
    query['DeadLetterExchange'] = request.deadLetterExchange;
  }
  if (!Util.isUnset(request.deadLetterRoutingKey)) {
    query['DeadLetterRoutingKey'] = request.deadLetterRoutingKey;
  }
  if (!Util.isUnset(request.exclusive)) {
    query['Exclusive'] = request.exclusive;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxLength)) {
    query['MaxLength'] = request.maxLength;
  }
  if (!Util.isUnset(request.maximunPrioty)) {
    query['MaximunPrioty'] = request.maximunPrioty;
  }
  if (!Util.isUnset(request.messageTTL)) {
    query['MessageTTL'] = request.messageTTL;
  }
  if (!Util.isUnset(request.ordered)) {
    query['Ordered'] = request.ordered;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.retryInherit)) {
    query['RetryInherit'] = request.retryInherit;
  }
  if (!Util.isUnset(request.retryInterval)) {
    query['RetryInterval'] = request.retryInterval;
  }
  if (!Util.isUnset(request.retryTimes)) {
    query['RetryTimes'] = request.retryTimes;
  }
  if (!Util.isUnset(request.singleActiveConsumer)) {
    query['SingleActiveConsumer'] = request.singleActiveConsumer;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建队列
 *
 * @param request CreateQueueRequest
 * @return CreateQueueResponse
 */
async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQueueWithOptions(request, runtime);
}

model CreateVhostRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model CreateVhostResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVhostResponseBody(name='body'),
}

/**
 * @summary 创建Vhost
 *
 * @param request CreateVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateVhostResponse
 */
async function createVhostWithOptions(request: CreateVhostRequest, runtime: Util.RuntimeOptions): CreateVhostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVhost',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 创建Vhost
 *
 * @param request CreateVhostRequest
 * @return CreateVhostResponse
 */
async function createVhost(request: CreateVhostRequest): CreateVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVhostWithOptions(request, runtime);
}

model DashboardCheckServiceStatusRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model DashboardCheckServiceStatusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DashboardCheckServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DashboardCheckServiceStatusResponseBody(name='body'),
}

/**
 * @summary prometheus Dashboard 检查相关服务开通状态
 *
 * @param request DashboardCheckServiceStatusRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DashboardCheckServiceStatusResponse
 */
async function dashboardCheckServiceStatusWithOptions(request: DashboardCheckServiceStatusRequest, runtime: Util.RuntimeOptions): DashboardCheckServiceStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DashboardCheckServiceStatus',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary prometheus Dashboard 检查相关服务开通状态
 *
 * @param request DashboardCheckServiceStatusRequest
 * @return DashboardCheckServiceStatusResponse
 */
async function dashboardCheckServiceStatus(request: DashboardCheckServiceStatusRequest): DashboardCheckServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return dashboardCheckServiceStatusWithOptions(request, runtime);
}

model DashboardListRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  dashboardName?: string(name='DashboardName', description='This parameter is required.'),
}

model DashboardListResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DashboardListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DashboardListResponseBody(name='body'),
}

/**
 * @summary 获取 arms grafana 大盘 http url
 *
 * @param request DashboardListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DashboardListResponse
 */
async function dashboardListWithOptions(request: DashboardListRequest, runtime: Util.RuntimeOptions): DashboardListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.dashboardName)) {
    query['DashboardName'] = request.dashboardName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DashboardList',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取 arms grafana 大盘 http url
 *
 * @param request DashboardListRequest
 * @return DashboardListResponse
 */
async function dashboardList(request: DashboardListRequest): DashboardListResponse {
  var runtime = new Util.RuntimeOptions{};
  return dashboardListWithOptions(request, runtime);
}

model DeleteExchangeRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeName?: string(name='ExchangeName'),
  exchangeNames?: map[string]any(name='ExchangeNames'),
  instanceId?: string(name='InstanceId'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model DeleteExchangeShrinkRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeName?: string(name='ExchangeName'),
  exchangeNamesShrink?: string(name='ExchangeNames'),
  instanceId?: string(name='InstanceId'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model DeleteExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExchangeResponseBody(name='body'),
}

/**
 * @summary 删除Exchange
 *
 * @param tmpReq DeleteExchangeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteExchangeResponse
 */
async function deleteExchangeWithOptions(tmpReq: DeleteExchangeRequest, runtime: Util.RuntimeOptions): DeleteExchangeResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteExchangeShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.exchangeNames)) {
    request.exchangeNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.exchangeNames, 'ExchangeNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.collina)) {
    query['Collina'] = request.collina;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.exchangeName)) {
    query['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.exchangeNamesShrink)) {
    query['ExchangeNames'] = request.exchangeNamesShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.umidToken)) {
    query['UmidToken'] = request.umidToken;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteExchange',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除Exchange
 *
 * @param request DeleteExchangeRequest
 * @return DeleteExchangeResponse
 */
async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteExchangeWithOptions(request, runtime);
}

model DeleteInstanceRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
}

model DeleteInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceResponseBody(name='body'),
}

/**
 * @summary 删除实例
 *
 * @param request DeleteInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteInstanceResponse
 */
async function deleteInstanceWithOptions(request: DeleteInstanceRequest, runtime: Util.RuntimeOptions): DeleteInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除实例
 *
 * @param request DeleteInstanceRequest
 * @return DeleteInstanceResponse
 */
async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInstanceWithOptions(request, runtime);
}

model DeleteQueueRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  queueNames?: map[string]any(name='QueueNames'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model DeleteQueueShrinkRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  queueNamesShrink?: string(name='QueueNames'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model DeleteQueueResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueueResponseBody(name='body'),
}

/**
 * @summary 删除队列
 *
 * @param tmpReq DeleteQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteQueueResponse
 */
async function deleteQueueWithOptions(tmpReq: DeleteQueueRequest, runtime: Util.RuntimeOptions): DeleteQueueResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.collina)) {
    query['Collina'] = request.collina;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  if (!Util.isUnset(request.umidToken)) {
    query['UmidToken'] = request.umidToken;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除队列
 *
 * @param request DeleteQueueRequest
 * @return DeleteQueueResponse
 */
async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQueueWithOptions(request, runtime);
}

model DeleteStaticAccountRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  createTimeStamp?: long(name='CreateTimeStamp', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  userName?: string(name='UserName', description='This parameter is required.'),
}

model DeleteStaticAccountResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteStaticAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStaticAccountResponseBody(name='body'),
}

/**
 * @summary 删除静态账户
 *
 * @param request DeleteStaticAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteStaticAccountResponse
 */
async function deleteStaticAccountWithOptions(request: DeleteStaticAccountRequest, runtime: Util.RuntimeOptions): DeleteStaticAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.createTimeStamp)) {
    query['CreateTimeStamp'] = request.createTimeStamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteStaticAccount',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除静态账户
 *
 * @param request DeleteStaticAccountRequest
 * @return DeleteStaticAccountResponse
 */
async function deleteStaticAccount(request: DeleteStaticAccountRequest): DeleteStaticAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStaticAccountWithOptions(request, runtime);
}

model DeleteVhostRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  vhostName?: string(name='VhostName'),
  vhostNames?: map[string]any(name='VhostNames'),
}

model DeleteVhostShrinkRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  vhostName?: string(name='VhostName'),
  vhostNamesShrink?: string(name='VhostNames'),
}

model DeleteVhostResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVhostResponseBody(name='body'),
}

/**
 * @summary 删除Vhost
 *
 * @param tmpReq DeleteVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteVhostResponse
 */
async function deleteVhostWithOptions(tmpReq: DeleteVhostRequest, runtime: Util.RuntimeOptions): DeleteVhostResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteVhostShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.vhostNames)) {
    request.vhostNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vhostNames, 'VhostNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  if (!Util.isUnset(request.vhostNamesShrink)) {
    query['VhostNames'] = request.vhostNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVhost',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 删除Vhost
 *
 * @param request DeleteVhostRequest
 * @return DeleteVhostResponse
 */
async function deleteVhost(request: DeleteVhostRequest): DeleteVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVhostWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    regions?: [ 
    {
      regionCnName?: string(name='RegionCnName'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Regions')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model ExportRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  exportType?: int32(name='ExportType', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  vhostName?: string(name='VhostName'),
}

model ExportResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportResponseBody(name='body'),
}

/**
 * @summary 导出元数据
 *
 * @param request ExportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExportResponse
 */
async function exportWithOptions(request: ExportRequest, runtime: Util.RuntimeOptions): ExportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.exportType)) {
    query['ExportType'] = request.exportType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Export',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 导出元数据
 *
 * @param request ExportRequest
 * @return ExportResponse
 */
async function export(request: ExportRequest): ExportResponse {
  var runtime = new Util.RuntimeOptions{};
  return exportWithOptions(request, runtime);
}

model FetchStaticAccountRequest {
  accountAccessKey?: string(name='AccountAccessKey', description='This parameter is required.', example='yourAccessKeyID'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  createTimeStamp?: long(name='CreateTimeStamp', description='This parameter is required.', example='1671175303522'),
  instanceId?: string(name='InstanceId', description='This parameter is required.', example='amqp-xxx'),
  remark?: string(name='Remark', example='备注示例'),
  SKey?: string(name='SKey', description='This parameter is required.', example='22c2d7d1769cb53c5a6d9213248e2de524******'),
  secretSign?: string(name='SecretSign', description='This parameter is required.', example='4c1a6367ce4c4255e9617326f9133ac635******'),
  userName?: string(name='UserName', description='This parameter is required.', example='Mjo****************'),
}

model FetchStaticAccountResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accessKey?: string(name='AccessKey', example='yourAccessKeyID'),
    createTimeStamp?: long(name='CreateTimeStamp', example='1671175303522'),
    instanceId?: string(name='InstanceId', example='amqp-cn-*********'),
    masterUId?: long(name='MasterUId', example='1565***********01'),
    password?: string(name='Password', example='OUYwQzM2QjZBRkUxNDRFM***************MzZCNzdDQzoxNjcxNDMwMzkyODI1'),
    remark?: string(name='Remark', example='备注示例'),
    userName?: string(name='UserName', example='MjphbXFwLWNuLXVxbTJ6cjc2djAwMzpMVEFJNX*******ZNMWVSWnRFSjZ2Zm8='),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FetchStaticAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FetchStaticAccountResponseBody(name='body'),
}

/**
 * @summary 更新静态账户
 *
 * @param request FetchStaticAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return FetchStaticAccountResponse
 */
async function fetchStaticAccountWithOptions(request: FetchStaticAccountRequest, runtime: Util.RuntimeOptions): FetchStaticAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountAccessKey)) {
    query['AccountAccessKey'] = request.accountAccessKey;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.createTimeStamp)) {
    query['CreateTimeStamp'] = request.createTimeStamp;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.remark)) {
    query['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.SKey)) {
    query['SKey'] = request.SKey;
  }
  if (!Util.isUnset(request.secretSign)) {
    query['SecretSign'] = request.secretSign;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'FetchStaticAccount',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新静态账户
 *
 * @param request FetchStaticAccountRequest
 * @return FetchStaticAccountResponse
 */
async function fetchStaticAccount(request: FetchStaticAccountRequest): FetchStaticAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return fetchStaticAccountWithOptions(request, runtime);
}

model GetAckInfoByIntervalRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  intervalSec?: int32(name='IntervalSec', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetAckInfoByIntervalResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        action?: string(name='Action'),
        channelId?: string(name='ChannelId'),
        connectionId?: string(name='ConnectionId'),
        deliveryTag?: long(name='DeliveryTag'),
        queueName?: string(name='QueueName'),
        rocketMqMsgId?: string(name='RocketMqMsgId'),
        rt?: int32(name='Rt'),
        timeStamp?: string(name='TimeStamp'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAckInfoByIntervalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAckInfoByIntervalResponseBody(name='body'),
}

/**
 * @summary 根据耗时查询ack信息
 *
 * @param request GetAckInfoByIntervalRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAckInfoByIntervalResponse
 */
async function getAckInfoByIntervalWithOptions(request: GetAckInfoByIntervalRequest, runtime: Util.RuntimeOptions): GetAckInfoByIntervalResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.intervalSec)) {
    query['IntervalSec'] = request.intervalSec;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAckInfoByInterval',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据耗时查询ack信息
 *
 * @param request GetAckInfoByIntervalRequest
 * @return GetAckInfoByIntervalResponse
 */
async function getAckInfoByInterval(request: GetAckInfoByIntervalRequest): GetAckInfoByIntervalResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAckInfoByIntervalWithOptions(request, runtime);
}

model GetAckInfoOfMessageRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  consumeStatus?: string(name='ConsumeStatus', description='This parameter is required.'),
  deliveryTag?: string(name='DeliveryTag', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  msgId?: string(name='MsgId', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  timeStamp?: string(name='TimeStamp', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetAckInfoOfMessageResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      ackErrorInfo?: string(name='AckErrorInfo'),
      ackResult?: string(name='AckResult'),
      action?: string(name='Action'),
      code?: string(name='Code'),
      property?: map[string]any(name='Property'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAckInfoOfMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAckInfoOfMessageResponseBody(name='body'),
}

/**
 * @summary 获取一个PushMessage（PullMessage）对应的Ack行为
 *
 * @param request GetAckInfoOfMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAckInfoOfMessageResponse
 */
async function getAckInfoOfMessageWithOptions(request: GetAckInfoOfMessageRequest, runtime: Util.RuntimeOptions): GetAckInfoOfMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.consumeStatus)) {
    query['ConsumeStatus'] = request.consumeStatus;
  }
  if (!Util.isUnset(request.deliveryTag)) {
    query['DeliveryTag'] = request.deliveryTag;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.timeStamp)) {
    query['TimeStamp'] = request.timeStamp;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAckInfoOfMessage',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取一个PushMessage（PullMessage）对应的Ack行为
 *
 * @param request GetAckInfoOfMessageRequest
 * @return GetAckInfoOfMessageResponse
 */
async function getAckInfoOfMessage(request: GetAckInfoOfMessageRequest): GetAckInfoOfMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAckInfoOfMessageWithOptions(request, runtime);
}

model GetBindingCountRequest {
  bindingType?: int32(name='BindingType', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  resourceName?: string(name='ResourceName', description='This parameter is required.'),
  upstream?: boolean(name='Upstream', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetBindingCountResponseBody = {
  code?: int32(name='Code'),
  data?: int32(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBindingCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBindingCountResponseBody(name='body'),
}

/**
 * @summary 获取绑定数量
 *
 * @param request GetBindingCountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBindingCountResponse
 */
async function getBindingCountWithOptions(request: GetBindingCountRequest, runtime: Util.RuntimeOptions): GetBindingCountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindingType)) {
    query['BindingType'] = request.bindingType;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.upstream)) {
    query['Upstream'] = request.upstream;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBindingCount',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取绑定数量
 *
 * @param request GetBindingCountRequest
 * @return GetBindingCountResponse
 */
async function getBindingCount(request: GetBindingCountRequest): GetBindingCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBindingCountWithOptions(request, runtime);
}

model GetBindingErrorByTaskIdRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
}

model GetBindingErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      bindingErrorDO?: [ 
      {
        destination?: string(name='Destination'),
        destinationType?: string(name='DestinationType'),
        errorMessage?: string(name='ErrorMessage'),
        routingKey?: string(name='RoutingKey'),
        src?: string(name='Src'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='BindingErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBindingErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBindingErrorByTaskIdResponseBody(name='body'),
}

/**
 * @summary 获取绑定错误
 *
 * @param request GetBindingErrorByTaskIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetBindingErrorByTaskIdResponse
 */
async function getBindingErrorByTaskIdWithOptions(request: GetBindingErrorByTaskIdRequest, runtime: Util.RuntimeOptions): GetBindingErrorByTaskIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetBindingErrorByTaskId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取绑定错误
 *
 * @param request GetBindingErrorByTaskIdRequest
 * @return GetBindingErrorByTaskIdResponse
 */
async function getBindingErrorByTaskId(request: GetBindingErrorByTaskIdRequest): GetBindingErrorByTaskIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBindingErrorByTaskIdWithOptions(request, runtime);
}

model GetCommonBuyUrlRequest {
  actionType?: string(name='ActionType', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
}

model GetCommonBuyUrlResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCommonBuyUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommonBuyUrlResponseBody(name='body'),
}

/**
 * @param request GetCommonBuyUrlRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetCommonBuyUrlResponse
 */
async function getCommonBuyUrlWithOptions(request: GetCommonBuyUrlRequest, runtime: Util.RuntimeOptions): GetCommonBuyUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCommonBuyUrl',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @param request GetCommonBuyUrlRequest
 * @return GetCommonBuyUrlResponse
 */
async function getCommonBuyUrl(request: GetCommonBuyUrlRequest): GetCommonBuyUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCommonBuyUrlWithOptions(request, runtime);
}

model GetConsumeTraceByQueueAndRocketMqMsgIdRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  msgId?: string(name='MsgId', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetConsumeTraceByQueueAndRocketMqMsgIdResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      autoAckTag?: string(name='AutoAckTag'),
      clientAddress?: string(name='ClientAddress'),
      code?: string(name='Code'),
      consumeType?: string(name='ConsumeType'),
      consumerTag?: string(name='ConsumerTag'),
      currentStatus?: string(name='CurrentStatus'),
      deliveryErrorInfo?: string(name='DeliveryErrorInfo'),
      deliveryTag?: string(name='DeliveryTag'),
      dlqQueueMsgIdMap?: map[string]any(name='DlqQueueMsgIdMap'),
      reason?: string(name='Reason'),
      showAckIcon?: boolean(name='ShowAckIcon'),
      timeStamp?: string(name='TimeStamp'),
      userId?: string(name='UserId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConsumeTraceByQueueAndRocketMqMsgIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsumeTraceByQueueAndRocketMqMsgIdResponseBody(name='body'),
}

/**
 * @summary 通过rocketMqMsgId查询消息消费轨迹
 *
 * @param request GetConsumeTraceByQueueAndRocketMqMsgIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetConsumeTraceByQueueAndRocketMqMsgIdResponse
 */
async function getConsumeTraceByQueueAndRocketMqMsgIdWithOptions(request: GetConsumeTraceByQueueAndRocketMqMsgIdRequest, runtime: Util.RuntimeOptions): GetConsumeTraceByQueueAndRocketMqMsgIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConsumeTraceByQueueAndRocketMqMsgId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 通过rocketMqMsgId查询消息消费轨迹
 *
 * @param request GetConsumeTraceByQueueAndRocketMqMsgIdRequest
 * @return GetConsumeTraceByQueueAndRocketMqMsgIdResponse
 */
async function getConsumeTraceByQueueAndRocketMqMsgId(request: GetConsumeTraceByQueueAndRocketMqMsgIdRequest): GetConsumeTraceByQueueAndRocketMqMsgIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConsumeTraceByQueueAndRocketMqMsgIdWithOptions(request, runtime);
}

model GetExchangeErrorByTaskIdRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
}

model GetExchangeErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      exchangeErrorDO?: [ 
      {
        errorMessage?: int32(name='ErrorMessage'),
        exchangeName?: string(name='ExchangeName'),
        exchangeType?: string(name='ExchangeType'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='ExchangeErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetExchangeErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExchangeErrorByTaskIdResponseBody(name='body'),
}

/**
 * @summary 获取Exchange错误
 *
 * @param request GetExchangeErrorByTaskIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExchangeErrorByTaskIdResponse
 */
async function getExchangeErrorByTaskIdWithOptions(request: GetExchangeErrorByTaskIdRequest, runtime: Util.RuntimeOptions): GetExchangeErrorByTaskIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExchangeErrorByTaskId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Exchange错误
 *
 * @param request GetExchangeErrorByTaskIdRequest
 * @return GetExchangeErrorByTaskIdResponse
 */
async function getExchangeErrorByTaskId(request: GetExchangeErrorByTaskIdRequest): GetExchangeErrorByTaskIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExchangeErrorByTaskIdWithOptions(request, runtime);
}

model GetExchangeRateRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeNames?: map[string]any(name='ExchangeNames', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetExchangeRateShrinkRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeNamesShrink?: string(name='ExchangeNames', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetExchangeRateResponseBody = {
  code?: int32(name='Code'),
  data?: {
    exchangeQuotaVO?: [ 
    {
      exchangeName?: string(name='ExchangeName'),
      inQps?: long(name='InQps'),
      instanceId?: string(name='InstanceId'),
      outQps?: long(name='OutQps'),
      vhostName?: string(name='VhostName'),
    }
  ](name='ExchangeQuotaVO')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetExchangeRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExchangeRateResponseBody(name='body'),
}

/**
 * @summary 获取Exchange Rate
 *
 * @param tmpReq GetExchangeRateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetExchangeRateResponse
 */
async function getExchangeRateWithOptions(tmpReq: GetExchangeRateRequest, runtime: Util.RuntimeOptions): GetExchangeRateResponse {
  Util.validateModel(tmpReq);
  var request = new GetExchangeRateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.exchangeNames)) {
    request.exchangeNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.exchangeNames, 'ExchangeNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.exchangeNamesShrink)) {
    query['ExchangeNames'] = request.exchangeNamesShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetExchangeRate',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Exchange Rate
 *
 * @param request GetExchangeRateRequest
 * @return GetExchangeRateResponse
 */
async function getExchangeRate(request: GetExchangeRateRequest): GetExchangeRateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getExchangeRateWithOptions(request, runtime);
}

model GetMsgIdListByQueueRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetMsgIdListByQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ string ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMsgIdListByQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMsgIdListByQueueResponseBody(name='body'),
}

/**
 * @summary 通过queueName查询一段时间内的消息id列表
 *
 * @param request GetMsgIdListByQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetMsgIdListByQueueResponse
 */
async function getMsgIdListByQueueWithOptions(request: GetMsgIdListByQueueRequest, runtime: Util.RuntimeOptions): GetMsgIdListByQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMsgIdListByQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 通过queueName查询一段时间内的消息id列表
 *
 * @param request GetMsgIdListByQueueRequest
 * @return GetMsgIdListByQueueResponse
 */
async function getMsgIdListByQueue(request: GetMsgIdListByQueueRequest): GetMsgIdListByQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMsgIdListByQueueWithOptions(request, runtime);
}

model GetQueueConsumersRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetQueueConsumersResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        clientAddress?: string(name='ClientAddress'),
        consumerTag?: string(name='ConsumerTag'),
        gmtCreate?: long(name='GmtCreate'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueConsumersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueConsumersResponseBody(name='body'),
}

/**
 * @summary GetQueueConsumers
 *
 * @param request GetQueueConsumersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueueConsumersResponse
 */
async function getQueueConsumersWithOptions(request: GetQueueConsumersRequest, runtime: Util.RuntimeOptions): GetQueueConsumersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueConsumers',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary GetQueueConsumers
 *
 * @param request GetQueueConsumersRequest
 * @return GetQueueConsumersResponse
 */
async function getQueueConsumers(request: GetQueueConsumersRequest): GetQueueConsumersResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueConsumersWithOptions(request, runtime);
}

model GetQueueErrorByTaskIdRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
}

model GetQueueErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      queueErrorDO?: [ 
      {
        autoDelete?: boolean(name='AutoDelete'),
        durable?: boolean(name='Durable'),
        errorMessage?: int32(name='ErrorMessage'),
        queueName?: string(name='QueueName'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='QueueErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueErrorByTaskIdResponseBody(name='body'),
}

/**
 * @summary 获取队列错误
 *
 * @param request GetQueueErrorByTaskIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueueErrorByTaskIdResponse
 */
async function getQueueErrorByTaskIdWithOptions(request: GetQueueErrorByTaskIdRequest, runtime: Util.RuntimeOptions): GetQueueErrorByTaskIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueErrorByTaskId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取队列错误
 *
 * @param request GetQueueErrorByTaskIdRequest
 * @return GetQueueErrorByTaskIdResponse
 */
async function getQueueErrorByTaskId(request: GetQueueErrorByTaskIdRequest): GetQueueErrorByTaskIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueErrorByTaskIdWithOptions(request, runtime);
}

model GetQueueRateRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  queueNames?: map[string]any(name='QueueNames', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetQueueRateShrinkRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  queueNamesShrink?: string(name='QueueNames', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetQueueRateResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      inQps?: long(name='InQps'),
      instanceId?: string(name='InstanceId'),
      outQps?: long(name='OutQps'),
      queueName?: string(name='QueueName'),
      vhostName?: string(name='VhostName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueRateResponseBody(name='body'),
}

/**
 * @summary 获取Queue Rate
 *
 * @param tmpReq GetQueueRateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetQueueRateResponse
 */
async function getQueueRateWithOptions(tmpReq: GetQueueRateRequest, runtime: Util.RuntimeOptions): GetQueueRateResponse {
  Util.validateModel(tmpReq);
  var request = new GetQueueRateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetQueueRate',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Queue Rate
 *
 * @param request GetQueueRateRequest
 * @return GetQueueRateResponse
 */
async function getQueueRate(request: GetQueueRateRequest): GetQueueRateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQueueRateWithOptions(request, runtime);
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagRequest {
  channelId?: string(name='ChannelId', description='This parameter is required.'),
  clientToken?: string(name='ClientToken'),
  connectionId?: string(name='ConnectionId', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  deliveryTag?: long(name='DeliveryTag', description='This parameter is required.'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: string(name='Code'),
    delay?: string(name='Delay'),
    exchange?: string(name='Exchange'),
    expiration?: string(name='Expiration'),
    messageId?: string(name='MessageId'),
    queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
    remoteAddress?: string(name='RemoteAddress'),
    routingKey?: string(name='RoutingKey'),
    sendErrorInfo?: string(name='SendErrorInfo'),
    timeStamp?: string(name='TimeStamp'),
    userId?: string(name='UserId'),
    vhost?: string(name='Vhost'),
    XDelay?: string(name='XDelay'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByConnectionAndChannelAndDeliveryTagResponseBody(name='body'),
}

/**
 * @summary 根据connectionId,channelId,deliveryTag查询SendMessage
 *
 * @param request GetSendTraceByConnectionAndChannelAndDeliveryTagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSendTraceByConnectionAndChannelAndDeliveryTagResponse
 */
async function getSendTraceByConnectionAndChannelAndDeliveryTagWithOptions(request: GetSendTraceByConnectionAndChannelAndDeliveryTagRequest, runtime: Util.RuntimeOptions): GetSendTraceByConnectionAndChannelAndDeliveryTagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.channelId)) {
    query['ChannelId'] = request.channelId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionId)) {
    query['ConnectionId'] = request.connectionId;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.deliveryTag)) {
    query['DeliveryTag'] = request.deliveryTag;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSendTraceByConnectionAndChannelAndDeliveryTag',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据connectionId,channelId,deliveryTag查询SendMessage
 *
 * @param request GetSendTraceByConnectionAndChannelAndDeliveryTagRequest
 * @return GetSendTraceByConnectionAndChannelAndDeliveryTagResponse
 */
async function getSendTraceByConnectionAndChannelAndDeliveryTag(request: GetSendTraceByConnectionAndChannelAndDeliveryTagRequest): GetSendTraceByConnectionAndChannelAndDeliveryTagResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSendTraceByConnectionAndChannelAndDeliveryTagWithOptions(request, runtime);
}

model GetSendTraceByMsgIdRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  msgId?: string(name='MsgId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName'),
  startTime?: long(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetSendTraceByMsgIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        code?: string(name='Code'),
        exchange?: string(name='Exchange'),
        instanceId?: string(name='InstanceId'),
        messageBodyLength?: string(name='MessageBodyLength'),
        messagePropertiesMap?: map[string]any(name='MessagePropertiesMap'),
        queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
        remoteAddress?: string(name='RemoteAddress'),
        routingKey?: string(name='RoutingKey'),
        sendErrorInfo?: string(name='SendErrorInfo'),
        timeStamp?: string(name='TimeStamp'),
        userId?: string(name='UserId'),
        vhost?: string(name='Vhost'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByMsgIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByMsgIdResponseBody(name='body'),
}

/**
 * @summary 通过用户msgId查询消息发送轨迹
 *
 * @param request GetSendTraceByMsgIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSendTraceByMsgIdResponse
 */
async function getSendTraceByMsgIdWithOptions(request: GetSendTraceByMsgIdRequest, runtime: Util.RuntimeOptions): GetSendTraceByMsgIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.msgId)) {
    query['MsgId'] = request.msgId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSendTraceByMsgId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 通过用户msgId查询消息发送轨迹
 *
 * @param request GetSendTraceByMsgIdRequest
 * @return GetSendTraceByMsgIdResponse
 */
async function getSendTraceByMsgId(request: GetSendTraceByMsgIdRequest): GetSendTraceByMsgIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSendTraceByMsgIdWithOptions(request, runtime);
}

model GetSendTraceByQueueRequest {
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetSendTraceByQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        code?: string(name='Code'),
        exchange?: string(name='Exchange'),
        messageBodyLength?: string(name='MessageBodyLength'),
        messageId?: string(name='MessageId'),
        messagePropertiesMap?: map[string]any(name='MessagePropertiesMap'),
        queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
        remoteAddress?: string(name='RemoteAddress'),
        routingKey?: string(name='RoutingKey'),
        sendErrorInfo?: string(name='SendErrorInfo'),
        timeStamp?: string(name='TimeStamp'),
        userId?: string(name='UserId'),
        vhost?: string(name='Vhost'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByQueueResponseBody(name='body'),
}

/**
 * @summary 根据queue 查询SendMessage
 *
 * @param request GetSendTraceByQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetSendTraceByQueueResponse
 */
async function getSendTraceByQueueWithOptions(request: GetSendTraceByQueueRequest, runtime: Util.RuntimeOptions): GetSendTraceByQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSendTraceByQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据queue 查询SendMessage
 *
 * @param request GetSendTraceByQueueRequest
 * @return GetSendTraceByQueueResponse
 */
async function getSendTraceByQueue(request: GetSendTraceByQueueRequest): GetSendTraceByQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSendTraceByQueueWithOptions(request, runtime);
}

model GetStatisticsByVhostRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model GetStatisticsByVhostResponseBody = {
  code?: int32(name='Code'),
  data?: {
    connectionStatistics?: [ 
    {
      accessKey?: string(name='AccessKey'),
      channelNum?: int32(name='ChannelNum'),
      channelStatisticsList?: {
        channelStatistics?: [ 
        {
          ackQps?: float(name='AckQps'),
          confirmQps?: float(name='ConfirmQps'),
          deliverQps?: float(name='DeliverQps'),
          getQps?: float(name='GetQps'),
          prefetch?: int32(name='Prefetch'),
          publishQps?: float(name='PublishQps'),
          state?: int32(name='State'),
          unacked?: int32(name='Unacked'),
          unconfirmed?: int32(name='Unconfirmed'),
        }
      ](name='ChannelStatistics')
      }(name='ChannelStatisticsList'),
      connectionName?: string(name='ConnectionName'),
      deliverQps?: float(name='DeliverQps'),
      protocol?: string(name='Protocol'),
      publishQps?: float(name='PublishQps'),
      remoteAddress?: string(name='RemoteAddress'),
      securityTransport?: boolean(name='SecurityTransport'),
      state?: int32(name='State'),
    }
  ](name='ConnectionStatistics')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetStatisticsByVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStatisticsByVhostResponseBody(name='body'),
}

/**
 * @summary GetStatisticsByVhost
 *
 * @param request GetStatisticsByVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetStatisticsByVhostResponse
 */
async function getStatisticsByVhostWithOptions(request: GetStatisticsByVhostRequest, runtime: Util.RuntimeOptions): GetStatisticsByVhostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStatisticsByVhost',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary GetStatisticsByVhost
 *
 * @param request GetStatisticsByVhostRequest
 * @return GetStatisticsByVhostResponse
 */
async function getStatisticsByVhost(request: GetStatisticsByVhostRequest): GetStatisticsByVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return getStatisticsByVhostWithOptions(request, runtime);
}

model GetTaskByUidRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
}

model GetTaskByUidResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      importDefinitionTaskDO?: [ 
      {
        bindingNum?: int32(name='BindingNum'),
        exchangeNum?: int32(name='ExchangeNum'),
        gmtCreate?: string(name='GmtCreate'),
        id?: long(name='Id'),
        importType?: int32(name='ImportType'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        queueNum?: int32(name='QueueNum'),
        status?: int32(name='Status'),
        userId?: long(name='UserId'),
        vhostName?: string(name='VhostName'),
        vhostNum?: int32(name='VhostNum'),
      }
    ](name='ImportDefinitionTaskDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTaskByUidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskByUidResponseBody(name='body'),
}

/**
 * @summary 获取任务
 *
 * @param request GetTaskByUidRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTaskByUidResponse
 */
async function getTaskByUidWithOptions(request: GetTaskByUidRequest, runtime: Util.RuntimeOptions): GetTaskByUidResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTaskByUid',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取任务
 *
 * @param request GetTaskByUidRequest
 * @return GetTaskByUidResponse
 */
async function getTaskByUid(request: GetTaskByUidRequest): GetTaskByUidResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskByUidWithOptions(request, runtime);
}

model GetTpsByTimeRequest {
  api?: string(name='Api'),
  clientToken?: string(name='ClientToken'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  endTime?: int32(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  queueName?: string(name='QueueName'),
  startTime?: int32(name='StartTime', description='This parameter is required.'),
  vhostName?: string(name='VhostName'),
}

model GetTpsByTimeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    endTime?: string(name='EndTime'),
    maxTps?: int32(name='MaxTps'),
    startTime?: long(name='StartTime'),
    tpsList?: [ int32 ](name='tpsList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTpsByTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTpsByTimeResponseBody(name='body'),
}

/**
 * @summary 查询一段时间内某个实例或是vhost或是queue的tps
 *
 * @param request GetTpsByTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetTpsByTimeResponse
 */
async function getTpsByTimeWithOptions(request: GetTpsByTimeRequest, runtime: Util.RuntimeOptions): GetTpsByTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.api)) {
    query['Api'] = request.api;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTpsByTime',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 查询一段时间内某个实例或是vhost或是queue的tps
 *
 * @param request GetTpsByTimeRequest
 * @return GetTpsByTimeResponse
 */
async function getTpsByTime(request: GetTpsByTimeRequest): GetTpsByTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTpsByTimeWithOptions(request, runtime);
}

model GetUserSettingRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
}

model GetUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: {
    logstore?: string(name='Logstore'),
    regionId?: string(name='RegionId'),
    userId?: long(name='UserId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserSettingResponseBody(name='body'),
}

/**
 * @summary 获取用户配置
 *
 * @param request GetUserSettingRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetUserSettingResponse
 */
async function getUserSettingWithOptions(request: GetUserSettingRequest, runtime: Util.RuntimeOptions): GetUserSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUserSetting',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取用户配置
 *
 * @param request GetUserSettingRequest
 * @return GetUserSettingResponse
 */
async function getUserSetting(request: GetUserSettingRequest): GetUserSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserSettingWithOptions(request, runtime);
}

model GetVhostErrorByTaskIdRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  taskId?: long(name='TaskId', description='This parameter is required.'),
}

model GetVhostErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      vhostErrorDO?: [ 
      {
        errorMessage?: int32(name='ErrorMessage'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='VhostErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVhostErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVhostErrorByTaskIdResponseBody(name='body'),
}

/**
 * @summary 获取Vhost错误
 *
 * @param request GetVhostErrorByTaskIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVhostErrorByTaskIdResponse
 */
async function getVhostErrorByTaskIdWithOptions(request: GetVhostErrorByTaskIdRequest, runtime: Util.RuntimeOptions): GetVhostErrorByTaskIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVhostErrorByTaskId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Vhost错误
 *
 * @param request GetVhostErrorByTaskIdRequest
 * @return GetVhostErrorByTaskIdResponse
 */
async function getVhostErrorByTaskId(request: GetVhostErrorByTaskIdRequest): GetVhostErrorByTaskIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVhostErrorByTaskIdWithOptions(request, runtime);
}

model GetVhostRateRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  vhostNames?: map[string]any(name='VhostNames', description='This parameter is required.'),
}

model GetVhostRateShrinkRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  vhostNamesShrink?: string(name='VhostNames', description='This parameter is required.'),
}

model GetVhostRateResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      channelNum?: int32(name='ChannelNum'),
      connectionNum?: int32(name='ConnectionNum'),
      inQps?: long(name='InQps'),
      outQps?: long(name='OutQps'),
      vhostName?: string(name='VhostName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVhostRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVhostRateResponseBody(name='body'),
}

/**
 * @summary 获取Vhost Rate
 *
 * @param tmpReq GetVhostRateRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetVhostRateResponse
 */
async function getVhostRateWithOptions(tmpReq: GetVhostRateRequest, runtime: Util.RuntimeOptions): GetVhostRateResponse {
  Util.validateModel(tmpReq);
  var request = new GetVhostRateShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.vhostNames)) {
    request.vhostNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vhostNames, 'VhostNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostNamesShrink)) {
    query['VhostNames'] = request.vhostNamesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetVhostRate',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Vhost Rate
 *
 * @param request GetVhostRateRequest
 * @return GetVhostRateResponse
 */
async function getVhostRate(request: GetVhostRateRequest): GetVhostRateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVhostRateWithOptions(request, runtime);
}

model ImportDefinitionAsynchronousRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  importType?: int32(name='ImportType', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  instanceName?: string(name='InstanceName', description='This parameter is required.'),
  ossUrl?: string(name='OssUrl', description='This parameter is required.'),
  vhostName?: string(name='VhostName'),
}

model ImportDefinitionAsynchronousResponseBody = {
  code?: int32(name='Code'),
  data?: {
    result?: boolean(name='Result'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportDefinitionAsynchronousResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportDefinitionAsynchronousResponseBody(name='body'),
}

/**
 * @summary 异步导入元数据
 *
 * @param request ImportDefinitionAsynchronousRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ImportDefinitionAsynchronousResponse
 */
async function importDefinitionAsynchronousWithOptions(request: ImportDefinitionAsynchronousRequest, runtime: Util.RuntimeOptions): ImportDefinitionAsynchronousResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.importType)) {
    query['ImportType'] = request.importType;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.ossUrl)) {
    query['OssUrl'] = request.ossUrl;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportDefinitionAsynchronous',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 异步导入元数据
 *
 * @param request ImportDefinitionAsynchronousRequest
 * @return ImportDefinitionAsynchronousResponse
 */
async function importDefinitionAsynchronous(request: ImportDefinitionAsynchronousRequest): ImportDefinitionAsynchronousResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDefinitionAsynchronousWithOptions(request, runtime);
}

model InstancePreivewRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  tags?: string(name='Tags'),
}

model InstancePreivewResponseBody = {
  code?: int32(name='Code'),
  data?: {
    exchangeNum?: int32(name='ExchangeNum'),
    instanceNum?: int32(name='InstanceNum'),
    instances?: {
      instancesVO?: [ 
      {
        autoRenew?: boolean(name='AutoRenew'),
        ceaseStatus?: boolean(name='CeaseStatus'),
        classicEndpoint?: string(name='ClassicEndpoint'),
        enableDlqTtl?: boolean(name='EnableDlqTtl'),
        encrypted?: boolean(name='Encrypted'),
        expire?: long(name='Expire'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        invisibleTime?: int32(name='InvisibleTime'),
        kmsKeyId?: string(name='KmsKeyId'),
        maxBindingCount?: int32(name='MaxBindingCount'),
        maxConnectionChannelCount?: int32(name='MaxConnectionChannelCount'),
        maxConnectionCount?: int32(name='MaxConnectionCount'),
        maxConsumeRetryTime?: int32(name='MaxConsumeRetryTime'),
        maxEIPTPS?: int32(name='MaxEIPTPS'),
        maxExchangeCount?: int32(name='MaxExchangeCount'),
        maxMsgBodyByte?: int32(name='MaxMsgBodyByte'),
        maxMsgDelayHour?: int32(name='MaxMsgDelayHour'),
        maxMsgTraceTime?: int32(name='MaxMsgTraceTime'),
        maxQueue?: int32(name='MaxQueue'),
        maxQueueConsumerCount?: int32(name='MaxQueueConsumerCount'),
        maxRetryInterval?: int32(name='MaxRetryInterval'),
        maxRetryTimes?: int32(name='MaxRetryTimes'),
        maxTPS?: int32(name='MaxTPS'),
        maxVhost?: int32(name='MaxVhost'),
        orderCreate?: long(name='OrderCreate'),
        orderType?: string(name='OrderType'),
        privateEndpoint?: string(name='PrivateEndpoint'),
        publicEndpoint?: string(name='PublicEndpoint'),
        resourceGroupId?: string(name='ResourceGroupId'),
        serverlessRate?: double(name='ServerlessRate'),
        serverlessSwitch?: boolean(name='ServerlessSwitch'),
        status?: string(name='Status'),
        storageSize?: int32(name='StorageSize'),
        supportEIP?: boolean(name='SupportEIP'),
        supportMsgTrace?: boolean(name='SupportMsgTrace'),
        supportOpenSourceAuth?: boolean(name='SupportOpenSourceAuth'),
        tags?: {
          tagsVO?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='TagsVO')
        }(name='Tags'),
        usedQueue?: int32(name='UsedQueue'),
        usedVhost?: int32(name='UsedVhost'),
        version?: int32(name='Version'),
      }
    ](name='InstancesVO')
    }(name='Instances'),
    queueNum?: int32(name='QueueNum'),
    vhostNum?: int32(name='VhostNum'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstancePreivewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstancePreivewResponseBody(name='body'),
}

/**
 * @summary 获取实例列表
 *
 * @param request InstancePreivewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return InstancePreivewResponse
 */
async function instancePreivewWithOptions(request: InstancePreivewRequest, runtime: Util.RuntimeOptions): InstancePreivewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstancePreivew',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实例列表
 *
 * @param request InstancePreivewRequest
 * @return InstancePreivewResponse
 */
async function instancePreivew(request: InstancePreivewRequest): InstancePreivewResponse {
  var runtime = new Util.RuntimeOptions{};
  return instancePreivewWithOptions(request, runtime);
}

model ListExchangeRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  exchangeNamePrefix?: string(name='ExchangeNamePrefix'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model ListExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      exchangVO?: [ 
      {
        attributes?: string(name='Attributes'),
        autoDelete?: boolean(name='AutoDelete'),
        canDelete?: boolean(name='CanDelete'),
        createTime?: long(name='CreateTime'),
        exchangeType?: int32(name='ExchangeType'),
        internal?: boolean(name='Internal'),
        name?: string(name='Name'),
        vhostName?: string(name='VhostName'),
      }
    ](name='ExchangVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeResponseBody(name='body'),
}

/**
 * @summary 获取Exchange列表
 *
 * @param request ListExchangeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExchangeResponse
 */
async function listExchangeWithOptions(request: ListExchangeRequest, runtime: Util.RuntimeOptions): ListExchangeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exchangeNamePrefix)) {
    query['ExchangeNamePrefix'] = request.exchangeNamePrefix;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExchange',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Exchange列表
 *
 * @param request ListExchangeRequest
 * @return ListExchangeResponse
 */
async function listExchange(request: ListExchangeRequest): ListExchangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangeWithOptions(request, runtime);
}

model ListExchangeDownstreamBindingsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  exchangeName?: string(name='ExchangeName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model ListExchangeDownstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: int32(name='BindingType'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeDownstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeDownstreamBindingsResponseBody(name='body'),
}

/**
 * @summary 获取Exchange下游列表
 *
 * @param request ListExchangeDownstreamBindingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExchangeDownstreamBindingsResponse
 */
async function listExchangeDownstreamBindingsWithOptions(request: ListExchangeDownstreamBindingsRequest, runtime: Util.RuntimeOptions): ListExchangeDownstreamBindingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exchangeName)) {
    query['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExchangeDownstreamBindings',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Exchange下游列表
 *
 * @param request ListExchangeDownstreamBindingsRequest
 * @return ListExchangeDownstreamBindingsResponse
 */
async function listExchangeDownstreamBindings(request: ListExchangeDownstreamBindingsRequest): ListExchangeDownstreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangeDownstreamBindingsWithOptions(request, runtime);
}

model ListExchangeUpstreamBindingsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  exchangeName?: string(name='ExchangeName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model ListExchangeUpstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindType?: int32(name='BindType'),
        bindingKey?: string(name='BindingKey'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeUpstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeUpstreamBindingsResponseBody(name='body'),
}

/**
 * @summary 获取Exchange上游绑定列表
 *
 * @param request ListExchangeUpstreamBindingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListExchangeUpstreamBindingsResponse
 */
async function listExchangeUpstreamBindingsWithOptions(request: ListExchangeUpstreamBindingsRequest, runtime: Util.RuntimeOptions): ListExchangeUpstreamBindingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.exchangeName)) {
    query['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListExchangeUpstreamBindings',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Exchange上游绑定列表
 *
 * @param request ListExchangeUpstreamBindingsRequest
 * @return ListExchangeUpstreamBindingsResponse
 */
async function listExchangeUpstreamBindings(request: ListExchangeUpstreamBindingsRequest): ListExchangeUpstreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExchangeUpstreamBindingsWithOptions(request, runtime);
}

model ListInstanceRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model ListInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    instances?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      classicEndpoint?: string(name='ClassicEndpoint'),
      expire?: long(name='Expire'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceType?: string(name='InstanceType'),
      maxEIPTPS?: int32(name='MaxEIPTPS'),
      maxQueue?: int32(name='MaxQueue'),
      maxTPS?: int32(name='MaxTPS'),
      maxVhost?: int32(name='MaxVhost'),
      orderCreate?: long(name='OrderCreate'),
      orderType?: string(name='OrderType'),
      privateEndpoint?: string(name='PrivateEndpoint'),
      publicEndpoint?: string(name='PublicEndpoint'),
      status?: string(name='Status'),
      storageSize?: int32(name='StorageSize'),
      supportEIP?: boolean(name='SupportEIP'),
      tags?: {
        tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='tags')
      }(name='Tags'),
    }
  ](name='Instances')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceResponseBody(name='body'),
}

/**
 * @summary 获取实例列表
 *
 * @param request ListInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceResponse
 */
async function listInstanceWithOptions(request: ListInstanceRequest, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实例列表
 *
 * @param request ListInstanceRequest
 * @return ListInstanceResponse
 */
async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceWithOptions(request, runtime);
}

model ListInstanceAlarmRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model ListInstanceAlarmResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      commodityInstanceAlarmVO?: [ 
      {
        alarmVO?: {
          alarmCount?: int32(name='AlarmCount'),
          alarmDetails?: {
            alarmDetail?: [ 
            {
              alertState?: string(name='AlertState'),
              comparisonOperator?: string(name='ComparisonOperator'),
              contactGroups?: string(name='ContactGroups'),
              dimensions?: string(name='Dimensions'),
              effectiveInterval?: string(name='EffectiveInterval'),
              enableState?: boolean(name='EnableState'),
              groupId?: string(name='GroupId'),
              groupName?: string(name='GroupName'),
              mailSubject?: string(name='MailSubject'),
              metricName?: string(name='MetricName'),
              namespace?: string(name='Namespace'),
              noEffectiveInterval?: string(name='NoEffectiveInterval'),
              period?: string(name='Period'),
              resources?: string(name='Resources'),
              ruleId?: string(name='RuleId'),
              ruleName?: string(name='RuleName'),
              silenceTime?: string(name='SilenceTime'),
              statistics?: string(name='Statistics'),
              threshold?: string(name='Threshold'),
              times?: string(name='Times'),
              webhook?: string(name='Webhook'),
            }
          ](name='AlarmDetail')
          }(name='AlarmDetails'),
          hasConfigAlarm?: boolean(name='HasConfigAlarm'),
        }(name='AlarmVO'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
      }
    ](name='CommodityInstanceAlarmVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceAlarmResponseBody(name='body'),
}

/**
 * @summary 获取实例告警
 *
 * @param request ListInstanceAlarmRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListInstanceAlarmResponse
 */
async function listInstanceAlarmWithOptions(request: ListInstanceAlarmRequest, runtime: Util.RuntimeOptions): ListInstanceAlarmResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceAlarm',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取实例告警
 *
 * @param request ListInstanceAlarmRequest
 * @return ListInstanceAlarmResponse
 */
async function listInstanceAlarm(request: ListInstanceAlarmRequest): ListInstanceAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstanceAlarmWithOptions(request, runtime);
}

model ListLogstoreRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  projectName?: string(name='ProjectName', description='This parameter is required.'),
}

model ListLogstoreResponseBody = {
  code?: int32(name='Code'),
  data?: {
    logstores?: [ string ](name='Logstores')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListLogstoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogstoreResponseBody(name='body'),
}

/**
 * @summary 获取日志Logstore
 *
 * @param request ListLogstoreRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLogstoreResponse
 */
async function listLogstoreWithOptions(request: ListLogstoreRequest, runtime: Util.RuntimeOptions): ListLogstoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.projectName)) {
    query['ProjectName'] = request.projectName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogstore',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取日志Logstore
 *
 * @param request ListLogstoreRequest
 * @return ListLogstoreResponse
 */
async function listLogstore(request: ListLogstoreRequest): ListLogstoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogstoreWithOptions(request, runtime);
}

model ListProjectRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model ListProjectResponseBody = {
  code?: int32(name='Code'),
  data?: {
    projects?: [ string ](name='Projects')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectResponseBody(name='body'),
}

/**
 * @summary 获取日志Project
 *
 * @param request ListProjectRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListProjectResponse
 */
async function listProjectWithOptions(request: ListProjectRequest, runtime: Util.RuntimeOptions): ListProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProject',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取日志Project
 *
 * @param request ListProjectRequest
 * @return ListProjectResponse
 */
async function listProject(request: ListProjectRequest): ListProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProjectWithOptions(request, runtime);
}

model ListQueueRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueNamePrefix?: string(name='QueueNamePrefix'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model ListQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      queueVO?: [ 
      {
        accumulationCount?: long(name='AccumulationCount'),
        attributes?: map[string]any(name='Attributes'),
        autoDelete?: boolean(name='AutoDelete'),
        canDelete?: boolean(name='CanDelete'),
        createTime?: long(name='CreateTime'),
        durable?: boolean(name='Durable'),
        exclusive?: boolean(name='Exclusive'),
        lastConsumeTime?: long(name='LastConsumeTime'),
        name?: string(name='Name'),
        vhostName?: string(name='VhostName'),
      }
    ](name='QueueVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueResponseBody(name='body'),
}

/**
 * @summary 获取队列列表
 *
 * @param request ListQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueueResponse
 */
async function listQueueWithOptions(request: ListQueueRequest, runtime: Util.RuntimeOptions): ListQueueResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueNamePrefix)) {
    query['QueueNamePrefix'] = request.queueNamePrefix;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取队列列表
 *
 * @param request ListQueueRequest
 * @return ListQueueResponse
 */
async function listQueue(request: ListQueueRequest): ListQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueWithOptions(request, runtime);
}

model ListQueueUpstreamBindingsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model ListQueueUpstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: int32(name='BindingType'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQueueUpstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueUpstreamBindingsResponseBody(name='body'),
}

/**
 * @summary 获取队列上游绑定列表
 *
 * @param request ListQueueUpstreamBindingsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListQueueUpstreamBindingsResponse
 */
async function listQueueUpstreamBindingsWithOptions(request: ListQueueUpstreamBindingsRequest, runtime: Util.RuntimeOptions): ListQueueUpstreamBindingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListQueueUpstreamBindings',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取队列上游绑定列表
 *
 * @param request ListQueueUpstreamBindingsRequest
 * @return ListQueueUpstreamBindingsResponse
 */
async function listQueueUpstreamBindings(request: ListQueueUpstreamBindingsRequest): ListQueueUpstreamBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQueueUpstreamBindingsWithOptions(request, runtime);
}

model ListStaticAccountsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
}

model ListStaticAccountsResponseBody = {
  code?: int32(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListStaticAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStaticAccountsResponseBody(name='body'),
}

/**
 * @summary 获取静态账户列表
 *
 * @param request ListStaticAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListStaticAccountsResponse
 */
async function listStaticAccountsWithOptions(request: ListStaticAccountsRequest, runtime: Util.RuntimeOptions): ListStaticAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListStaticAccounts',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取静态账户列表
 *
 * @param request ListStaticAccountsRequest
 * @return ListStaticAccountsResponse
 */
async function listStaticAccounts(request: ListStaticAccountsRequest): ListStaticAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listStaticAccountsWithOptions(request, runtime);
}

model ListVhostRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  vhostNamePrefix?: string(name='VhostNamePrefix'),
}

model ListVhostResponseBody = {
  code?: int32(name='Code'),
  data?: {
    vhosts?: [ 
    {
      channelNum?: int32(name='ChannelNum'),
      connectionNum?: int32(name='ConnectionNum'),
      name?: string(name='Name'),
    }
  ](name='Vhosts')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVhostResponseBody(name='body'),
}

/**
 * @summary 获取Vhost列表
 *
 * @param request ListVhostRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListVhostResponse
 */
async function listVhostWithOptions(request: ListVhostRequest, runtime: Util.RuntimeOptions): ListVhostResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.vhostNamePrefix)) {
    query['VhostNamePrefix'] = request.vhostNamePrefix;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListVhost',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取Vhost列表
 *
 * @param request ListVhostRequest
 * @return ListVhostResponse
 */
async function listVhost(request: ListVhostRequest): ListVhostResponse {
  var runtime = new Util.RuntimeOptions{};
  return listVhostWithOptions(request, runtime);
}

model MetadataRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
}

model MetadataResponseBody = {
  code?: int32(name='Code'),
  data?: {
    endpoint?: string(name='Endpoint'),
    hasPretendPermission?: boolean(name='HasPretendPermission'),
    internalEndpoint?: string(name='InternalEndpoint'),
    pretendUserId?: string(name='PretendUserId'),
    userStatus?: int32(name='UserStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MetadataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MetadataResponseBody(name='body'),
}

/**
 * @summary 获取元数据
 *
 * @param request MetadataRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return MetadataResponse
 */
async function metadataWithOptions(request: MetadataRequest, runtime: Util.RuntimeOptions): MetadataResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Metadata',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 获取元数据
 *
 * @param request MetadataRequest
 * @return MetadataResponse
 */
async function metadata(request: MetadataRequest): MetadataResponse {
  var runtime = new Util.RuntimeOptions{};
  return metadataWithOptions(request, runtime);
}

model PurgeQueueRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  queueNames?: map[string]any(name='QueueNames'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model PurgeQueueShrinkRequest {
  collina?: string(name='Collina'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  queueName?: string(name='QueueName'),
  queueNamesShrink?: string(name='QueueNames'),
  umidToken?: string(name='UmidToken'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model PurgeQueueResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PurgeQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PurgeQueueResponseBody(name='body'),
}

/**
 * @summary 清空队列
 *
 * @param tmpReq PurgeQueueRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return PurgeQueueResponse
 */
async function purgeQueueWithOptions(tmpReq: PurgeQueueRequest, runtime: Util.RuntimeOptions): PurgeQueueResponse {
  Util.validateModel(tmpReq);
  var request = new PurgeQueueShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.queueNames)) {
    request.queueNamesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.queueNames, 'QueueNames', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.collina)) {
    query['Collina'] = request.collina;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.queueNamesShrink)) {
    query['QueueNames'] = request.queueNamesShrink;
  }
  if (!Util.isUnset(request.umidToken)) {
    query['UmidToken'] = request.umidToken;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PurgeQueue',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 清空队列
 *
 * @param request PurgeQueueRequest
 * @return PurgeQueueResponse
 */
async function purgeQueue(request: PurgeQueueRequest): PurgeQueueResponse {
  var runtime = new Util.RuntimeOptions{};
  return purgeQueueWithOptions(request, runtime);
}

model QueryMessageByMessageIdRequest {
  beginTime?: long(name='BeginTime'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  messageId?: string(name='MessageId', description='This parameter is required.'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model QueryMessageByMessageIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        appId?: string(name='AppId'),
        body?: string(name='Body'),
        clusterId?: string(name='ClusterId'),
        contentEncoding?: string(name='ContentEncoding'),
        contentType?: string(name='ContentType'),
        correlationId?: string(name='CorrelationId'),
        deliveryMode?: int32(name='DeliveryMode'),
        exchangeName?: string(name='ExchangeName'),
        expiration?: string(name='Expiration'),
        headers?: string(name='Headers'),
        immediate?: boolean(name='Immediate'),
        mandatory?: boolean(name='Mandatory'),
        messageId?: string(name='MessageId'),
        priority?: int32(name='Priority'),
        processToken?: string(name='ProcessToken'),
        reconsumeTimes?: int32(name='ReconsumeTimes'),
        replyTo?: string(name='ReplyTo'),
        routingKey?: string(name='RoutingKey'),
        storeTimestamp?: long(name='StoreTimestamp'),
        timestamp?: long(name='Timestamp'),
        type?: string(name='Type'),
        userId?: string(name='UserId'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMessageByMessageIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageByMessageIdResponseBody(name='body'),
}

/**
 * @summary 根据Message Id查询消息
 *
 * @param request QueryMessageByMessageIdRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMessageByMessageIdResponse
 */
async function queryMessageByMessageIdWithOptions(request: QueryMessageByMessageIdRequest, runtime: Util.RuntimeOptions): QueryMessageByMessageIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMessageByMessageId',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据Message Id查询消息
 *
 * @param request QueryMessageByMessageIdRequest
 * @return QueryMessageByMessageIdResponse
 */
async function queryMessageByMessageId(request: QueryMessageByMessageIdRequest): QueryMessageByMessageIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMessageByMessageIdWithOptions(request, runtime);
}

model QueryMessageByQueueNameRequest {
  beginTime?: long(name='BeginTime', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  currentPage?: int32(name='CurrentPage', description='This parameter is required.'),
  endTime?: long(name='EndTime', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  pageSize?: int32(name='PageSize', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  taskId?: string(name='TaskId'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model QueryMessageByQueueNameResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      amqpMessageVO?: [ 
      {
        appId?: string(name='AppId'),
        body?: string(name='Body'),
        clusterId?: string(name='ClusterId'),
        contentEncoding?: string(name='ContentEncoding'),
        contentType?: string(name='ContentType'),
        correlationId?: string(name='CorrelationId'),
        deliveryMode?: int32(name='DeliveryMode'),
        exchangeName?: string(name='ExchangeName'),
        expiration?: string(name='Expiration'),
        headers?: string(name='Headers'),
        immediate?: boolean(name='Immediate'),
        mandatory?: boolean(name='Mandatory'),
        messageId?: string(name='MessageId'),
        priority?: int32(name='Priority'),
        processToken?: string(name='ProcessToken'),
        reconsumeTimes?: int32(name='ReconsumeTimes'),
        replyTo?: string(name='ReplyTo'),
        routingKey?: string(name='RoutingKey'),
        storeTimestamp?: long(name='StoreTimestamp'),
        timestamp?: long(name='Timestamp'),
        type?: string(name='Type'),
        userId?: string(name='UserId'),
      }
    ](name='AmqpMessageVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMessageByQueueNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageByQueueNameResponseBody(name='body'),
}

/**
 * @summary 根据队列查询消息
 *
 * @param request QueryMessageByQueueNameRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return QueryMessageByQueueNameResponse
 */
async function queryMessageByQueueNameWithOptions(request: QueryMessageByQueueNameRequest, runtime: Util.RuntimeOptions): QueryMessageByQueueNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.beginTime)) {
    query['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryMessageByQueueName',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 根据队列查询消息
 *
 * @param request QueryMessageByQueueNameRequest
 * @return QueryMessageByQueueNameResponse
 */
async function queryMessageByQueueName(request: QueryMessageByQueueNameRequest): QueryMessageByQueueNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMessageByQueueNameWithOptions(request, runtime);
}

model ReleaseInstanceRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
}

model ReleaseInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseInstanceResponseBody(name='body'),
}

/**
 * @summary 实例释放
 *
 * @param request ReleaseInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseInstanceResponse
 */
async function releaseInstanceWithOptions(request: ReleaseInstanceRequest, runtime: Util.RuntimeOptions): ReleaseInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 实例释放
 *
 * @param request ReleaseInstanceRequest
 * @return ReleaseInstanceResponse
 */
async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceWithOptions(request, runtime);
}

model SendMessageRequest {
  body?: string(name='Body', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  exchangeName?: string(name='ExchangeName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  messageId?: string(name='MessageId', description='This parameter is required.'),
  props?: string(name='Props'),
  routingKey?: string(name='RoutingKey', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model SendMessageResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SendMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageResponseBody(name='body'),
}

/**
 * @summary 发送消息
 *
 * @param request SendMessageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendMessageResponse
 */
async function sendMessageWithOptions(request: SendMessageRequest, runtime: Util.RuntimeOptions): SendMessageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.body)) {
    query['Body'] = request.body;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.exchangeName)) {
    query['ExchangeName'] = request.exchangeName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.props)) {
    query['Props'] = request.props;
  }
  if (!Util.isUnset(request.routingKey)) {
    query['RoutingKey'] = request.routingKey;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendMessage',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 发送消息
 *
 * @param request SendMessageRequest
 * @return SendMessageResponse
 */
async function sendMessage(request: SendMessageRequest): SendMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageWithOptions(request, runtime);
}

model SendMessageCopyRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  processToken?: string(name='ProcessToken', description='This parameter is required.'),
  queueName?: string(name='QueueName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model SendMessageCopyResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendMessageCopyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageCopyResponseBody(name='body'),
}

/**
 * @summary 发送消息
 *
 * @param request SendMessageCopyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SendMessageCopyResponse
 */
async function sendMessageCopyWithOptions(request: SendMessageCopyRequest, runtime: Util.RuntimeOptions): SendMessageCopyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.processToken)) {
    query['ProcessToken'] = request.processToken;
  }
  if (!Util.isUnset(request.queueName)) {
    query['QueueName'] = request.queueName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SendMessageCopy',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 发送消息
 *
 * @param request SendMessageCopyRequest
 * @return SendMessageCopyResponse
 */
async function sendMessageCopy(request: SendMessageCopyRequest): SendMessageCopyResponse {
  var runtime = new Util.RuntimeOptions{};
  return sendMessageCopyWithOptions(request, runtime);
}

model UnbindRequest {
  bindingKey?: string(name='BindingKey'),
  bindingType?: int32(name='BindingType', description='This parameter is required.'),
  consoleSessionId?: string(name='ConsoleSessionId'),
  dstName?: string(name='DstName', description='This parameter is required.'),
  instanceId?: string(name='InstanceId'),
  srcName?: string(name='SrcName', description='This parameter is required.'),
  vhostName?: string(name='VhostName', description='This parameter is required.'),
}

model UnbindResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindResponseBody(name='body'),
}

/**
 * @summary 取消绑定
 *
 * @param request UnbindRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UnbindResponse
 */
async function unbindWithOptions(request: UnbindRequest, runtime: Util.RuntimeOptions): UnbindResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bindingKey)) {
    query['BindingKey'] = request.bindingKey;
  }
  if (!Util.isUnset(request.bindingType)) {
    query['BindingType'] = request.bindingType;
  }
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.dstName)) {
    query['DstName'] = request.dstName;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.srcName)) {
    query['SrcName'] = request.srcName;
  }
  if (!Util.isUnset(request.vhostName)) {
    query['VhostName'] = request.vhostName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Unbind',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 取消绑定
 *
 * @param request UnbindRequest
 * @return UnbindResponse
 */
async function unbind(request: UnbindRequest): UnbindResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindWithOptions(request, runtime);
}

model UpdateInstanceRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  instanceName?: string(name='InstanceName', description='This parameter is required.'),
}

model UpdateInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceResponseBody(name='body'),
}

/**
 * @summary 更新实例
 *
 * @param request UpdateInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceResponse
 */
async function updateInstanceWithOptions(request: UpdateInstanceRequest, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新实例
 *
 * @param request UpdateInstanceRequest
 * @return UpdateInstanceResponse
 */
async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceWithOptions(request, runtime);
}

model UpdateInstanceRetryStrategyRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId'),
  retryInterval?: int32(name='RetryInterval'),
  retryTimes?: int32(name='RetryTimes'),
}

model UpdateInstanceRetryStrategyResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceRetryStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceRetryStrategyResponseBody(name='body'),
}

/**
 * @summary 修改实例的重试策略
 *
 * @param request UpdateInstanceRetryStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateInstanceRetryStrategyResponse
 */
async function updateInstanceRetryStrategyWithOptions(request: UpdateInstanceRetryStrategyRequest, runtime: Util.RuntimeOptions): UpdateInstanceRetryStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.retryInterval)) {
    query['RetryInterval'] = request.retryInterval;
  }
  if (!Util.isUnset(request.retryTimes)) {
    query['RetryTimes'] = request.retryTimes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstanceRetryStrategy',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 修改实例的重试策略
 *
 * @param request UpdateInstanceRetryStrategyRequest
 * @return UpdateInstanceRetryStrategyResponse
 */
async function updateInstanceRetryStrategy(request: UpdateInstanceRetryStrategyRequest): UpdateInstanceRetryStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceRetryStrategyWithOptions(request, runtime);
}

model UpdateServerlessSwitchRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
  serverlessSwitch?: boolean(name='ServerlessSwitch', description='This parameter is required.'),
}

model UpdateServerlessSwitchResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateServerlessSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServerlessSwitchResponseBody(name='body'),
}

/**
 * @summary 更新serverless开关
 *
 * @param request UpdateServerlessSwitchRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateServerlessSwitchResponse
 */
async function updateServerlessSwitchWithOptions(request: UpdateServerlessSwitchRequest, runtime: Util.RuntimeOptions): UpdateServerlessSwitchResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.serverlessSwitch)) {
    query['ServerlessSwitch'] = request.serverlessSwitch;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServerlessSwitch',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 更新serverless开关
 *
 * @param request UpdateServerlessSwitchRequest
 * @return UpdateServerlessSwitchResponse
 */
async function updateServerlessSwitch(request: UpdateServerlessSwitchRequest): UpdateServerlessSwitchResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServerlessSwitchWithOptions(request, runtime);
}

model UpgradeLimitsRequest {
  consoleSessionId?: string(name='ConsoleSessionId'),
  instanceId?: string(name='InstanceId', description='This parameter is required.'),
}

model UpgradeLimitsResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeLimitsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeLimitsResponseBody(name='body'),
}

/**
 * @summary 升级实例配额
 *
 * @param request UpgradeLimitsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeLimitsResponse
 */
async function upgradeLimitsWithOptions(request: UpgradeLimitsRequest, runtime: Util.RuntimeOptions): UpgradeLimitsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleSessionId)) {
    query['ConsoleSessionId'] = request.consoleSessionId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeLimits',
    version = '2019-09-01',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary 升级实例配额
 *
 * @param request UpgradeLimitsRequest
 * @return UpgradeLimitsResponse
 */
async function upgradeLimits(request: UpgradeLimitsRequest): UpgradeLimitsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeLimitsWithOptions(request, runtime);
}

