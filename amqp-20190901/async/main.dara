/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'amqp';
  @version = '2019-09-01';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model BindRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  argument?: string(name='Argument', position='Query'),
  bindingKey?: string(name='BindingKey', position='Query'),
  bindingType: int32(name='BindingType', description='This parameter is required.', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  dstName: string(name='DstName', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  srcName: string(name='SrcName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model BindResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BindResponseBody(name='body'),
}

/**
  * @param request  the request parameters of Bind  BindRequest
  * @return BindResponse
 */
async function bind(request: BindRequest): BindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Bind', 'POST', '/', 'json', false, 'json', request);
}

model CancelUserSettingRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
}

model CancelUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelUserSettingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CancelUserSetting  CancelUserSettingRequest
  * @return CancelUserSettingResponse
 */
async function cancelUserSetting(request: CancelUserSettingRequest): CancelUserSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelUserSetting', 'POST', '/', 'json', false, 'json', request);
}

model ConfigureUserSettingRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  bucketName?: string(name='BucketName', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  logstore?: string(name='Logstore', position='Query'),
  projectName?: string(name='ProjectName', position='Query'),
  putType: string(name='PutType', description='This parameter is required.', position='Query'),
}

model ConfigureUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConfigureUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConfigureUserSettingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ConfigureUserSetting  ConfigureUserSettingRequest
  * @return ConfigureUserSettingResponse
 */
async function configureUserSetting(request: ConfigureUserSettingRequest): ConfigureUserSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConfigureUserSetting', 'POST', '/', 'json', false, 'json', request);
}

model ConsoleClearPretendStatusRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId: string(name='ConsoleSessionId', description='This parameter is required.', position='Query'),
}

model ConsoleClearPretendStatusResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConsoleClearPretendStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConsoleClearPretendStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ConsoleClearPretendStatus  ConsoleClearPretendStatusRequest
  * @return ConsoleClearPretendStatusResponse
 */
async function consoleClearPretendStatus(request: ConsoleClearPretendStatusRequest): ConsoleClearPretendStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConsoleClearPretendStatus', 'GET', '/', 'json', false, 'json', request);
}

model ConsoleSavePretendStatusRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId: string(name='ConsoleSessionId', description='This parameter is required.', position='Query'),
  key: string(name='Key', description='This parameter is required.', position='Query'),
  type: int32(name='Type', description='This parameter is required.', position='Query'),
}

model ConsoleSavePretendStatusResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ConsoleSavePretendStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ConsoleSavePretendStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ConsoleSavePretendStatus  ConsoleSavePretendStatusRequest
  * @return ConsoleSavePretendStatusResponse
 */
async function consoleSavePretendStatus(request: ConsoleSavePretendStatusRequest): ConsoleSavePretendStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ConsoleSavePretendStatus', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudMonitorSLRRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model CreateCloudMonitorSLRResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCloudMonitorSLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCloudMonitorSLRResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateCloudMonitorSLR  CreateCloudMonitorSLRRequest
  * @return CreateCloudMonitorSLRResponse
 */
async function createCloudMonitorSLR(request: CreateCloudMonitorSLRRequest): CreateCloudMonitorSLRResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudMonitorSLR', 'POST', '/', 'json', false, 'json', request);
}

model CreateExchangeRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  alternateExchange?: string(name='AlternateExchange', position='Query'),
  autoDelete?: boolean(name='AutoDelete', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  exchangeName: string(name='ExchangeName', description='This parameter is required.', position='Query'),
  exchangeType: int32(name='ExchangeType', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  internal?: boolean(name='Internal', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
  xDelayedType?: string(name='XDelayedType', position='Query'),
  xHashHeader?: string(name='XHashHeader', position='Query'),
}

model CreateExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateExchangeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateExchange  CreateExchangeRequest
  * @return CreateExchangeResponse
 */
async function createExchange(request: CreateExchangeRequest): CreateExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateExchange', 'POST', '/', 'json', false, 'json', request);
}

model CreateLogDeliverySLRRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model CreateLogDeliverySLRResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLogDeliverySLRResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLogDeliverySLRResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateLogDeliverySLR  CreateLogDeliverySLRRequest
  * @return CreateLogDeliverySLRResponse
 */
async function createLogDeliverySLR(request: CreateLogDeliverySLRRequest): CreateLogDeliverySLRResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLogDeliverySLR', 'POST', '/', 'json', false, 'json', request);
}

model CreateQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  autoDelete?: boolean(name='AutoDelete', position='Query'),
  autoExpire?: long(name='AutoExpire', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  deadLetterExchange?: string(name='DeadLetterExchange', position='Query'),
  deadLetterRoutingKey?: string(name='DeadLetterRoutingKey', position='Query'),
  exclusive?: boolean(name='Exclusive', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  maxLength?: long(name='MaxLength', position='Query'),
  maximunPrioty?: long(name='MaximunPrioty', position='Query'),
  messageTTL?: long(name='MessageTTL', position='Query'),
  ordered?: boolean(name='Ordered', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  retryInherit?: boolean(name='RetryInherit', position='Query'),
  retryInterval?: int32(name='RetryInterval', position='Query'),
  retryTimes?: int32(name='RetryTimes', position='Query'),
  singleActiveConsumer?: boolean(name='SingleActiveConsumer', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model CreateQueueResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateQueue  CreateQueueRequest
  * @return CreateQueueResponse
 */
async function createQueue(request: CreateQueueRequest): CreateQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateQueue', 'POST', '/', 'json', false, 'json', request);
}

model CreateVhostRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model CreateVhostResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateVhost  CreateVhostRequest
  * @return CreateVhostResponse
 */
async function createVhost(request: CreateVhostRequest): CreateVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVhost', 'POST', '/', 'json', false, 'json', request);
}

model DashboardCheckServiceStatusRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model DashboardCheckServiceStatusResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DashboardCheckServiceStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DashboardCheckServiceStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DashboardCheckServiceStatus  DashboardCheckServiceStatusRequest
  * @return DashboardCheckServiceStatusResponse
 */
async function dashboardCheckServiceStatus(request: DashboardCheckServiceStatusRequest): DashboardCheckServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DashboardCheckServiceStatus', 'POST', '/', 'json', false, 'json', request);
}

model DashboardListRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  dashboardName: string(name='DashboardName', description='This parameter is required.', position='Query'),
}

model DashboardListResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DashboardListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DashboardListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DashboardList  DashboardListRequest
  * @return DashboardListResponse
 */
async function dashboardList(request: DashboardListRequest): DashboardListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DashboardList', 'POST', '/', 'json', false, 'json', request);
}

model DeleteExchangeRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  collina?: string(name='Collina', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  exchangeName?: string(name='ExchangeName', position='Query'),
  exchangeNames?: map[string]any(name='ExchangeNames', shrink='json', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  umidToken?: string(name='UmidToken', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model DeleteExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteExchangeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteExchange  DeleteExchangeRequest
  * @return DeleteExchangeResponse
 */
async function deleteExchange(request: DeleteExchangeRequest): DeleteExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteExchange', 'POST', '/', 'json', false, 'json', request);
}

model DeleteInstanceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
}

model DeleteInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteInstance  DeleteInstanceRequest
  * @return DeleteInstanceResponse
 */
async function deleteInstance(request: DeleteInstanceRequest): DeleteInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  collina?: string(name='Collina', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  queueName?: string(name='QueueName', position='Query'),
  queueNames?: map[string]any(name='QueueNames', shrink='json', position='Query'),
  umidToken?: string(name='UmidToken', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model DeleteQueueResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteQueue  DeleteQueueRequest
  * @return DeleteQueueResponse
 */
async function deleteQueue(request: DeleteQueueRequest): DeleteQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteQueue', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStaticAccountRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  createTimeStamp: long(name='CreateTimeStamp', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  userName: string(name='UserName', description='This parameter is required.', position='Query'),
}

model DeleteStaticAccountResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteStaticAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStaticAccountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteStaticAccount  DeleteStaticAccountRequest
  * @return DeleteStaticAccountResponse
 */
async function deleteStaticAccount(request: DeleteStaticAccountRequest): DeleteStaticAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStaticAccount', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVhostRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  vhostName?: string(name='VhostName', position='Query'),
  vhostNames?: map[string]any(name='VhostNames', shrink='json', position='Query'),
}

model DeleteVhostResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DeleteVhost  DeleteVhostRequest
  * @return DeleteVhostResponse
 */
async function deleteVhost(request: DeleteVhostRequest): DeleteVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVhost', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    regions?: [ 
    {
      regionCnName?: string(name='RegionCnName'),
      regionId?: string(name='RegionId'),
      regionName?: string(name='RegionName'),
    }
  ](name='Regions')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRegions  DescribeRegionsRequest
  * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model ExportRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  exportType: int32(name='ExportType', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  vhostName?: string(name='VhostName', position='Query'),
}

model ExportResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExportResponseBody(name='body'),
}

/**
  * @param request  the request parameters of Export  ExportRequest
  * @return ExportResponse
 */
async function export(request: ExportRequest): ExportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Export', 'POST', '/', 'json', false, 'json', request);
}

model FetchStaticAccountRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  accountAccessKey: string(name='AccountAccessKey', description='This parameter is required.', example='yourAccessKeyID', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  createTimeStamp: long(name='CreateTimeStamp', description='This parameter is required.', example='1671175303522', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', example='amqp-xxx', position='Query'),
  remark?: string(name='Remark', example='备注示例', position='Query'),
  sKey: string(name='SKey', description='This parameter is required.', example='22c2d7d1769cb53c5a6d9213248e2de524******', position='Query'),
  secretSign: string(name='SecretSign', description='This parameter is required.', example='4c1a6367ce4c4255e9617326f9133ac635******', position='Query'),
  userName: string(name='UserName', description='This parameter is required.', example='Mjo****************', position='Query'),
}

model FetchStaticAccountResponseBody = {
  code?: int32(name='Code'),
  data?: {
    accessKey?: string(name='AccessKey', example='yourAccessKeyID'),
    createTimeStamp?: long(name='CreateTimeStamp', example='1671175303522'),
    instanceId?: string(name='InstanceId', example='amqp-cn-*********'),
    masterUId?: long(name='MasterUId', example='1565***********01'),
    password?: string(name='Password', example='OUYwQzM2QjZBRkUxNDRFM***************MzZCNzdDQzoxNjcxNDMwMzkyODI1'),
    remark?: string(name='Remark', example='备注示例'),
    userName?: string(name='UserName', example='MjphbXFwLWNuLXVxbTJ6cjc2djAwMzpMVEFJNX*******ZNMWVSWnRFSjZ2Zm8='),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model FetchStaticAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: FetchStaticAccountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of FetchStaticAccount  FetchStaticAccountRequest
  * @return FetchStaticAccountResponse
 */
async function fetchStaticAccount(request: FetchStaticAccountRequest): FetchStaticAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'FetchStaticAccount', 'POST', '/', 'json', false, 'json', request);
}

model GetAckInfoByIntervalRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  endTime: int32(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  intervalSec: int32(name='IntervalSec', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  startTime: int32(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetAckInfoByIntervalResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        action?: string(name='Action'),
        channelId?: string(name='ChannelId'),
        connectionId?: string(name='ConnectionId'),
        deliveryTag?: long(name='DeliveryTag'),
        queueName?: string(name='QueueName'),
        rocketMqMsgId?: string(name='RocketMqMsgId'),
        rt?: int32(name='Rt'),
        timeStamp?: string(name='TimeStamp'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAckInfoByIntervalResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAckInfoByIntervalResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAckInfoByInterval  GetAckInfoByIntervalRequest
  * @return GetAckInfoByIntervalResponse
 */
async function getAckInfoByInterval(request: GetAckInfoByIntervalRequest): GetAckInfoByIntervalResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAckInfoByInterval', 'POST', '/', 'json', false, 'json', request);
}

model GetAckInfoOfMessageRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  consumeStatus: string(name='ConsumeStatus', description='This parameter is required.', position='Query'),
  deliveryTag: string(name='DeliveryTag', description='This parameter is required.', position='Query'),
  endTime: long(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  msgId: string(name='MsgId', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  startTime: long(name='StartTime', description='This parameter is required.', position='Query'),
  timeStamp: string(name='TimeStamp', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetAckInfoOfMessageResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      ackErrorInfo?: string(name='AckErrorInfo'),
      ackResult?: string(name='AckResult'),
      action?: string(name='Action'),
      code?: string(name='Code'),
      property?: map[string]any(name='Property'),
      timeStamp?: string(name='TimeStamp'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetAckInfoOfMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAckInfoOfMessageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetAckInfoOfMessage  GetAckInfoOfMessageRequest
  * @return GetAckInfoOfMessageResponse
 */
async function getAckInfoOfMessage(request: GetAckInfoOfMessageRequest): GetAckInfoOfMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAckInfoOfMessage', 'POST', '/', 'json', false, 'json', request);
}

model GetBindingCountRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  bindingType: int32(name='BindingType', description='This parameter is required.', minimum=0, maximum=1, position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  resourceName: string(name='ResourceName', description='This parameter is required.', position='Query'),
  upstream: boolean(name='Upstream', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetBindingCountResponseBody = {
  code?: int32(name='Code'),
  data?: int32(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBindingCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBindingCountResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetBindingCount  GetBindingCountRequest
  * @return GetBindingCountResponse
 */
async function getBindingCount(request: GetBindingCountRequest): GetBindingCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBindingCount', 'POST', '/', 'json', false, 'json', request);
}

model GetBindingErrorByTaskIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Query'),
}

model GetBindingErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      bindingErrorDO?: [ 
      {
        destination?: string(name='Destination'),
        destinationType?: string(name='DestinationType'),
        errorMessage?: string(name='ErrorMessage'),
        routingKey?: string(name='RoutingKey'),
        src?: string(name='Src'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='BindingErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetBindingErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetBindingErrorByTaskIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetBindingErrorByTaskId  GetBindingErrorByTaskIdRequest
  * @return GetBindingErrorByTaskIdResponse
 */
async function getBindingErrorByTaskId(request: GetBindingErrorByTaskIdRequest): GetBindingErrorByTaskIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetBindingErrorByTaskId', 'POST', '/', 'json', false, 'json', request);
}

model GetCommonBuyUrlRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  actionType: string(name='ActionType', description='This parameter is required.', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
}

model GetCommonBuyUrlResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetCommonBuyUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommonBuyUrlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetCommonBuyUrl  GetCommonBuyUrlRequest
  * @return GetCommonBuyUrlResponse
 */
async function getCommonBuyUrl(request: GetCommonBuyUrlRequest): GetCommonBuyUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCommonBuyUrl', 'POST', '/', 'json', false, 'json', request);
}

model GetConsumeTraceByQueueAndRocketMqMsgIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  endTime: long(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  msgId: string(name='MsgId', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  startTime: long(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetConsumeTraceByQueueAndRocketMqMsgIdResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      autoAckTag?: string(name='AutoAckTag'),
      clientAddress?: string(name='ClientAddress'),
      code?: string(name='Code'),
      consumeType?: string(name='ConsumeType'),
      consumerTag?: string(name='ConsumerTag'),
      currentStatus?: string(name='CurrentStatus'),
      deliveryErrorInfo?: string(name='DeliveryErrorInfo'),
      deliveryTag?: string(name='DeliveryTag'),
      dlqQueueMsgIdMap?: map[string]any(name='DlqQueueMsgIdMap'),
      reason?: string(name='Reason'),
      showAckIcon?: boolean(name='ShowAckIcon'),
      timeStamp?: string(name='TimeStamp'),
      userId?: string(name='UserId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetConsumeTraceByQueueAndRocketMqMsgIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetConsumeTraceByQueueAndRocketMqMsgIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetConsumeTraceByQueueAndRocketMqMsgId  GetConsumeTraceByQueueAndRocketMqMsgIdRequest
  * @return GetConsumeTraceByQueueAndRocketMqMsgIdResponse
 */
async function getConsumeTraceByQueueAndRocketMqMsgId(request: GetConsumeTraceByQueueAndRocketMqMsgIdRequest): GetConsumeTraceByQueueAndRocketMqMsgIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetConsumeTraceByQueueAndRocketMqMsgId', 'POST', '/', 'json', false, 'json', request);
}

model GetExchangeErrorByTaskIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Query'),
}

model GetExchangeErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      exchangeErrorDO?: [ 
      {
        errorMessage?: int32(name='ErrorMessage'),
        exchangeName?: string(name='ExchangeName'),
        exchangeType?: string(name='ExchangeType'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='ExchangeErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetExchangeErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExchangeErrorByTaskIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetExchangeErrorByTaskId  GetExchangeErrorByTaskIdRequest
  * @return GetExchangeErrorByTaskIdResponse
 */
async function getExchangeErrorByTaskId(request: GetExchangeErrorByTaskIdRequest): GetExchangeErrorByTaskIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExchangeErrorByTaskId', 'POST', '/', 'json', false, 'json', request);
}

model GetExchangeRateRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  exchangeNames: map[string]any(name='ExchangeNames', description='This parameter is required.', shrink='json', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetExchangeRateResponseBody = {
  code?: int32(name='Code'),
  data?: {
    exchangeQuotaVO?: [ 
    {
      exchangeName?: string(name='ExchangeName'),
      inQps?: long(name='InQps'),
      instanceId?: string(name='InstanceId'),
      outQps?: long(name='OutQps'),
      vhostName?: string(name='VhostName'),
    }
  ](name='ExchangeQuotaVO')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetExchangeRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetExchangeRateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetExchangeRate  GetExchangeRateRequest
  * @return GetExchangeRateResponse
 */
async function getExchangeRate(request: GetExchangeRateRequest): GetExchangeRateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetExchangeRate', 'POST', '/', 'json', false, 'json', request);
}

model GetMsgIdListByQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  endTime: long(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  startTime: long(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetMsgIdListByQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ string ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetMsgIdListByQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMsgIdListByQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetMsgIdListByQueue  GetMsgIdListByQueueRequest
  * @return GetMsgIdListByQueueResponse
 */
async function getMsgIdListByQueue(request: GetMsgIdListByQueueRequest): GetMsgIdListByQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMsgIdListByQueue', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueConsumersRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage?: int32(name='CurrentPage', minimum=1, maximum=100, position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  pageSize?: int32(name='PageSize', minimum=0, maximum=100, position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetQueueConsumersResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        clientAddress?: string(name='ClientAddress'),
        consumerTag?: string(name='ConsumerTag'),
        gmtCreate?: long(name='GmtCreate'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueConsumersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueConsumersResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQueueConsumers  GetQueueConsumersRequest
  * @return GetQueueConsumersResponse
 */
async function getQueueConsumers(request: GetQueueConsumersRequest): GetQueueConsumersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueConsumers', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueErrorByTaskIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Query'),
}

model GetQueueErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      queueErrorDO?: [ 
      {
        autoDelete?: boolean(name='AutoDelete'),
        durable?: boolean(name='Durable'),
        errorMessage?: int32(name='ErrorMessage'),
        queueName?: string(name='QueueName'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='QueueErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueErrorByTaskIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQueueErrorByTaskId  GetQueueErrorByTaskIdRequest
  * @return GetQueueErrorByTaskIdResponse
 */
async function getQueueErrorByTaskId(request: GetQueueErrorByTaskIdRequest): GetQueueErrorByTaskIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueErrorByTaskId', 'POST', '/', 'json', false, 'json', request);
}

model GetQueueRateRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  queueNames: map[string]any(name='QueueNames', description='This parameter is required.', shrink='json', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetQueueRateResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      inQps?: long(name='InQps'),
      instanceId?: string(name='InstanceId'),
      outQps?: long(name='OutQps'),
      queueName?: string(name='QueueName'),
      vhostName?: string(name='VhostName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetQueueRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetQueueRateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetQueueRate  GetQueueRateRequest
  * @return GetQueueRateResponse
 */
async function getQueueRate(request: GetQueueRateRequest): GetQueueRateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueueRate', 'POST', '/', 'json', false, 'json', request);
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  channelId: string(name='ChannelId', description='This parameter is required.', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionId: string(name='ConnectionId', description='This parameter is required.', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  deliveryTag: long(name='DeliveryTag', description='This parameter is required.', position='Query'),
  endTime: int32(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  startTime: int32(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagResponseBody = {
  code?: int32(name='Code'),
  data?: {
    code?: string(name='Code'),
    delay?: string(name='Delay'),
    exchange?: string(name='Exchange'),
    expiration?: string(name='Expiration'),
    messageId?: string(name='MessageId'),
    queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
    remoteAddress?: string(name='RemoteAddress'),
    routingKey?: string(name='RoutingKey'),
    sendErrorInfo?: string(name='SendErrorInfo'),
    timeStamp?: string(name='TimeStamp'),
    userId?: string(name='UserId'),
    vhost?: string(name='Vhost'),
    xDelay?: string(name='XDelay'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByConnectionAndChannelAndDeliveryTagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByConnectionAndChannelAndDeliveryTagResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSendTraceByConnectionAndChannelAndDeliveryTag  GetSendTraceByConnectionAndChannelAndDeliveryTagRequest
  * @return GetSendTraceByConnectionAndChannelAndDeliveryTagResponse
 */
async function getSendTraceByConnectionAndChannelAndDeliveryTag(request: GetSendTraceByConnectionAndChannelAndDeliveryTagRequest): GetSendTraceByConnectionAndChannelAndDeliveryTagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSendTraceByConnectionAndChannelAndDeliveryTag', 'POST', '/', 'json', false, 'json', request);
}

model GetSendTraceByMsgIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  endTime: long(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  msgId: string(name='MsgId', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  queueName?: string(name='QueueName', position='Query'),
  startTime: long(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetSendTraceByMsgIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        code?: string(name='Code'),
        exchange?: string(name='Exchange'),
        instanceId?: string(name='InstanceId'),
        messageBodyLength?: string(name='MessageBodyLength'),
        messagePropertiesMap?: map[string]any(name='MessagePropertiesMap'),
        queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
        remoteAddress?: string(name='RemoteAddress'),
        routingKey?: string(name='RoutingKey'),
        sendErrorInfo?: string(name='SendErrorInfo'),
        timeStamp?: string(name='TimeStamp'),
        userId?: string(name='UserId'),
        vhost?: string(name='Vhost'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByMsgIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByMsgIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSendTraceByMsgId  GetSendTraceByMsgIdRequest
  * @return GetSendTraceByMsgIdResponse
 */
async function getSendTraceByMsgId(request: GetSendTraceByMsgIdRequest): GetSendTraceByMsgIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSendTraceByMsgId', 'POST', '/', 'json', false, 'json', request);
}

model GetSendTraceByQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  endTime: int32(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  startTime: int32(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetSendTraceByQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        code?: string(name='Code'),
        exchange?: string(name='Exchange'),
        messageBodyLength?: string(name='MessageBodyLength'),
        messageId?: string(name='MessageId'),
        messagePropertiesMap?: map[string]any(name='MessagePropertiesMap'),
        queueMsgIdMap?: map[string]any(name='QueueMsgIdMap'),
        remoteAddress?: string(name='RemoteAddress'),
        routingKey?: string(name='RoutingKey'),
        sendErrorInfo?: string(name='SendErrorInfo'),
        timeStamp?: string(name='TimeStamp'),
        userId?: string(name='UserId'),
        vhost?: string(name='Vhost'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSendTraceByQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetSendTraceByQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetSendTraceByQueue  GetSendTraceByQueueRequest
  * @return GetSendTraceByQueueResponse
 */
async function getSendTraceByQueue(request: GetSendTraceByQueueRequest): GetSendTraceByQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSendTraceByQueue', 'POST', '/', 'json', false, 'json', request);
}

model GetStatisticsByVhostRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model GetStatisticsByVhostResponseBody = {
  code?: int32(name='Code'),
  data?: {
    connectionStatistics?: [ 
    {
      accessKey?: string(name='AccessKey'),
      channelNum?: int32(name='ChannelNum'),
      channelStatisticsList?: {
        channelStatistics?: [ 
        {
          ackQps?: float(name='AckQps'),
          confirmQps?: float(name='ConfirmQps'),
          deliverQps?: float(name='DeliverQps'),
          getQps?: float(name='GetQps'),
          prefetch?: int32(name='Prefetch'),
          publishQps?: float(name='PublishQps'),
          state?: int32(name='State'),
          unacked?: int32(name='Unacked'),
          unconfirmed?: int32(name='Unconfirmed'),
        }
      ](name='ChannelStatistics')
      }(name='ChannelStatisticsList'),
      connectionName?: string(name='ConnectionName'),
      deliverQps?: float(name='DeliverQps'),
      protocol?: string(name='Protocol'),
      publishQps?: float(name='PublishQps'),
      remoteAddress?: string(name='RemoteAddress'),
      securityTransport?: boolean(name='SecurityTransport'),
      state?: int32(name='State'),
    }
  ](name='ConnectionStatistics')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetStatisticsByVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetStatisticsByVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetStatisticsByVhost  GetStatisticsByVhostRequest
  * @return GetStatisticsByVhostResponse
 */
async function getStatisticsByVhost(request: GetStatisticsByVhostRequest): GetStatisticsByVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetStatisticsByVhost', 'POST', '/', 'json', false, 'json', request);
}

model GetTaskByUidRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
}

model GetTaskByUidResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      importDefinitionTaskDO?: [ 
      {
        bindingNum?: int32(name='BindingNum'),
        exchangeNum?: int32(name='ExchangeNum'),
        gmtCreate?: string(name='GmtCreate'),
        id?: long(name='Id'),
        importType?: int32(name='ImportType'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        queueNum?: int32(name='QueueNum'),
        status?: int32(name='Status'),
        userId?: long(name='UserId'),
        vhostName?: string(name='VhostName'),
        vhostNum?: int32(name='VhostNum'),
      }
    ](name='ImportDefinitionTaskDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTaskByUidResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTaskByUidResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTaskByUid  GetTaskByUidRequest
  * @return GetTaskByUidResponse
 */
async function getTaskByUid(request: GetTaskByUidRequest): GetTaskByUidResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTaskByUid', 'POST', '/', 'json', false, 'json', request);
}

model GetTpsByTimeRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  api?: string(name='Api', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  endTime: int32(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  queueName?: string(name='QueueName', position='Query'),
  startTime: int32(name='StartTime', description='This parameter is required.', position='Query'),
  vhostName?: string(name='VhostName', position='Query'),
}

model GetTpsByTimeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    endTime?: string(name='EndTime'),
    maxTps?: int32(name='MaxTps'),
    startTime?: long(name='StartTime'),
    tpsList?: [ int32 ](name='tpsList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetTpsByTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTpsByTimeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTpsByTime  GetTpsByTimeRequest
  * @return GetTpsByTimeResponse
 */
async function getTpsByTime(request: GetTpsByTimeRequest): GetTpsByTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTpsByTime', 'POST', '/', 'json', false, 'json', request);
}

model GetUserSettingRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
}

model GetUserSettingResponseBody = {
  code?: int32(name='Code'),
  data?: {
    logstore?: string(name='Logstore'),
    regionId?: string(name='RegionId'),
    userId?: long(name='UserId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetUserSettingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserSettingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetUserSetting  GetUserSettingRequest
  * @return GetUserSettingResponse
 */
async function getUserSetting(request: GetUserSettingRequest): GetUserSettingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUserSetting', 'POST', '/', 'json', false, 'json', request);
}

model GetVhostErrorByTaskIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  taskId: long(name='TaskId', description='This parameter is required.', position='Query'),
}

model GetVhostErrorByTaskIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      vhostErrorDO?: [ 
      {
        errorMessage?: int32(name='ErrorMessage'),
        taskId?: long(name='TaskId'),
        vhostName?: string(name='VhostName'),
      }
    ](name='VhostErrorDO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVhostErrorByTaskIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVhostErrorByTaskIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetVhostErrorByTaskId  GetVhostErrorByTaskIdRequest
  * @return GetVhostErrorByTaskIdResponse
 */
async function getVhostErrorByTaskId(request: GetVhostErrorByTaskIdRequest): GetVhostErrorByTaskIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVhostErrorByTaskId', 'POST', '/', 'json', false, 'json', request);
}

model GetVhostRateRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  vhostNames: map[string]any(name='VhostNames', description='This parameter is required.', shrink='json', position='Query'),
}

model GetVhostRateResponseBody = {
  code?: int32(name='Code'),
  data?: [ 
    {
      channelNum?: int32(name='ChannelNum'),
      connectionNum?: int32(name='ConnectionNum'),
      inQps?: long(name='InQps'),
      outQps?: long(name='OutQps'),
      vhostName?: string(name='VhostName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetVhostRateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetVhostRateResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetVhostRate  GetVhostRateRequest
  * @return GetVhostRateResponse
 */
async function getVhostRate(request: GetVhostRateRequest): GetVhostRateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetVhostRate', 'POST', '/', 'json', false, 'json', request);
}

model ImportDefinitionAsynchronousRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  importType: int32(name='ImportType', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  instanceName: string(name='InstanceName', description='This parameter is required.', position='Query'),
  ossUrl: string(name='OssUrl', description='This parameter is required.', position='Query'),
  vhostName?: string(name='VhostName', position='Query'),
}

model ImportDefinitionAsynchronousResponseBody = {
  code?: int32(name='Code'),
  data?: {
    result?: boolean(name='Result'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ImportDefinitionAsynchronousResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ImportDefinitionAsynchronousResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ImportDefinitionAsynchronous  ImportDefinitionAsynchronousRequest
  * @return ImportDefinitionAsynchronousResponse
 */
async function importDefinitionAsynchronous(request: ImportDefinitionAsynchronousRequest): ImportDefinitionAsynchronousResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportDefinitionAsynchronous', 'POST', '/', 'json', false, 'json', request);
}

model InstancePreivewRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model InstancePreivewResponseBody = {
  code?: int32(name='Code'),
  data?: {
    exchangeNum?: int32(name='ExchangeNum'),
    instanceNum?: int32(name='InstanceNum'),
    instances?: {
      instancesVO?: [ 
      {
        autoRenew?: boolean(name='AutoRenew'),
        ceaseStatus?: boolean(name='CeaseStatus'),
        classicEndpoint?: string(name='ClassicEndpoint'),
        enableDlqTtl?: boolean(name='EnableDlqTtl'),
        encrypted?: boolean(name='Encrypted'),
        expire?: long(name='Expire'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        invisibleTime?: int32(name='InvisibleTime'),
        kmsKeyId?: string(name='KmsKeyId'),
        maxBindingCount?: int32(name='MaxBindingCount'),
        maxConnectionChannelCount?: int32(name='MaxConnectionChannelCount'),
        maxConnectionCount?: int32(name='MaxConnectionCount'),
        maxConsumeRetryTime?: int32(name='MaxConsumeRetryTime'),
        maxEIPTPS?: int32(name='MaxEIPTPS'),
        maxExchangeCount?: int32(name='MaxExchangeCount'),
        maxMsgBodyByte?: int32(name='MaxMsgBodyByte'),
        maxMsgDelayHour?: int32(name='MaxMsgDelayHour'),
        maxMsgTraceTime?: int32(name='MaxMsgTraceTime'),
        maxQueue?: int32(name='MaxQueue'),
        maxQueueConsumerCount?: int32(name='MaxQueueConsumerCount'),
        maxRetryInterval?: int32(name='MaxRetryInterval'),
        maxRetryTimes?: int32(name='MaxRetryTimes'),
        maxTPS?: int32(name='MaxTPS'),
        maxVhost?: int32(name='MaxVhost'),
        orderCreate?: long(name='OrderCreate'),
        orderType?: string(name='OrderType'),
        privateEndpoint?: string(name='PrivateEndpoint'),
        publicEndpoint?: string(name='PublicEndpoint'),
        resourceGroupId?: string(name='ResourceGroupId'),
        serverlessRate?: double(name='ServerlessRate'),
        serverlessSwitch?: boolean(name='ServerlessSwitch'),
        status?: string(name='Status'),
        storageSize?: int32(name='StorageSize'),
        supportEIP?: boolean(name='SupportEIP'),
        supportMsgTrace?: boolean(name='SupportMsgTrace'),
        supportOpenSourceAuth?: boolean(name='SupportOpenSourceAuth'),
        tags?: {
          tagsVO?: [ 
          {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }
        ](name='TagsVO')
        }(name='Tags'),
        usedQueue?: int32(name='UsedQueue'),
        usedVhost?: int32(name='UsedVhost'),
        version?: int32(name='Version'),
      }
    ](name='InstancesVO')
    }(name='Instances'),
    queueNum?: int32(name='QueueNum'),
    vhostNum?: int32(name='VhostNum'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model InstancePreivewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InstancePreivewResponseBody(name='body'),
}

/**
  * @param request  the request parameters of InstancePreivew  InstancePreivewRequest
  * @return InstancePreivewResponse
 */
async function instancePreivew(request: InstancePreivewRequest): InstancePreivewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstancePreivew', 'POST', '/', 'json', false, 'json', request);
}

model ListExchangeRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, maximum=500, position='Query'),
  exchangeNamePrefix?: string(name='ExchangeNamePrefix', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model ListExchangeResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      exchangVO?: [ 
      {
        attributes?: string(name='Attributes'),
        autoDelete?: boolean(name='AutoDelete'),
        canDelete?: boolean(name='CanDelete'),
        createTime?: long(name='CreateTime'),
        exchangeType?: int32(name='ExchangeType'),
        internal?: boolean(name='Internal'),
        name?: string(name='Name'),
        vhostName?: string(name='VhostName'),
      }
    ](name='ExchangVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListExchange  ListExchangeRequest
  * @return ListExchangeResponse
 */
async function listExchange(request: ListExchangeRequest): ListExchangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchange', 'POST', '/', 'json', false, 'json', request);
}

model ListExchangeDownstreamBindingsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, maximum=500, position='Query'),
  exchangeName: string(name='ExchangeName', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model ListExchangeDownstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: int32(name='BindingType'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeDownstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeDownstreamBindingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListExchangeDownstreamBindings  ListExchangeDownstreamBindingsRequest
  * @return ListExchangeDownstreamBindingsResponse
 */
async function listExchangeDownstreamBindings(request: ListExchangeDownstreamBindingsRequest): ListExchangeDownstreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchangeDownstreamBindings', 'POST', '/', 'json', false, 'json', request);
}

model ListExchangeUpstreamBindingsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  exchangeName: string(name='ExchangeName', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=1, maximum=50, position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model ListExchangeUpstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindType?: int32(name='BindType'),
        bindingKey?: string(name='BindingKey'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListExchangeUpstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListExchangeUpstreamBindingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListExchangeUpstreamBindings  ListExchangeUpstreamBindingsRequest
  * @return ListExchangeUpstreamBindingsResponse
 */
async function listExchangeUpstreamBindings(request: ListExchangeUpstreamBindingsRequest): ListExchangeUpstreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExchangeUpstreamBindings', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model ListInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    instances?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      classicEndpoint?: string(name='ClassicEndpoint'),
      expire?: long(name='Expire'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceType?: string(name='InstanceType'),
      maxEIPTPS?: int32(name='MaxEIPTPS'),
      maxQueue?: int32(name='MaxQueue'),
      maxTPS?: int32(name='MaxTPS'),
      maxVhost?: int32(name='MaxVhost'),
      orderCreate?: long(name='OrderCreate'),
      orderType?: string(name='OrderType'),
      privateEndpoint?: string(name='PrivateEndpoint'),
      publicEndpoint?: string(name='PublicEndpoint'),
      status?: string(name='Status'),
      storageSize?: int32(name='StorageSize'),
      supportEIP?: boolean(name='SupportEIP'),
      tags?: {
        tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='tags')
      }(name='Tags'),
    }
  ](name='Instances')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListInstance  ListInstanceRequest
  * @return ListInstanceResponse
 */
async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstance', 'POST', '/', 'json', false, 'json', request);
}

model ListInstanceAlarmRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model ListInstanceAlarmResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      commodityInstanceAlarmVO?: [ 
      {
        alarmVO?: {
          alarmCount?: int32(name='AlarmCount'),
          alarmDetails?: {
            alarmDetail?: [ 
            {
              alertState?: string(name='AlertState'),
              comparisonOperator?: string(name='ComparisonOperator'),
              contactGroups?: string(name='ContactGroups'),
              dimensions?: string(name='Dimensions'),
              effectiveInterval?: string(name='EffectiveInterval'),
              enableState?: boolean(name='EnableState'),
              groupId?: string(name='GroupId'),
              groupName?: string(name='GroupName'),
              mailSubject?: string(name='MailSubject'),
              metricName?: string(name='MetricName'),
              namespace?: string(name='Namespace'),
              noEffectiveInterval?: string(name='NoEffectiveInterval'),
              period?: string(name='Period'),
              resources?: string(name='Resources'),
              ruleId?: string(name='RuleId'),
              ruleName?: string(name='RuleName'),
              silenceTime?: string(name='SilenceTime'),
              statistics?: string(name='Statistics'),
              threshold?: string(name='Threshold'),
              times?: string(name='Times'),
              webhook?: string(name='Webhook'),
            }
          ](name='AlarmDetail')
          }(name='AlarmDetails'),
          hasConfigAlarm?: boolean(name='HasConfigAlarm'),
        }(name='AlarmVO'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
      }
    ](name='CommodityInstanceAlarmVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstanceAlarmResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListInstanceAlarmResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListInstanceAlarm  ListInstanceAlarmRequest
  * @return ListInstanceAlarmResponse
 */
async function listInstanceAlarm(request: ListInstanceAlarmRequest): ListInstanceAlarmResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListInstanceAlarm', 'POST', '/', 'json', false, 'json', request);
}

model ListLogstoreRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  projectName: string(name='ProjectName', description='This parameter is required.', position='Query'),
}

model ListLogstoreResponseBody = {
  code?: int32(name='Code'),
  data?: {
    logstores?: [ string ](name='Logstores')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListLogstoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLogstoreResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListLogstore  ListLogstoreRequest
  * @return ListLogstoreResponse
 */
async function listLogstore(request: ListLogstoreRequest): ListLogstoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLogstore', 'POST', '/', 'json', false, 'json', request);
}

model ListProjectRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model ListProjectResponseBody = {
  code?: int32(name='Code'),
  data?: {
    projects?: [ string ](name='Projects')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListProjectResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListProjectResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListProject  ListProjectRequest
  * @return ListProjectResponse
 */
async function listProject(request: ListProjectRequest): ListProjectResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListProject', 'POST', '/', 'json', false, 'json', request);
}

model ListQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  queueNamePrefix?: string(name='QueueNamePrefix', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model ListQueueResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      queueVO?: [ 
      {
        accumulationCount?: long(name='AccumulationCount'),
        attributes?: map[string]any(name='Attributes'),
        autoDelete?: boolean(name='AutoDelete'),
        canDelete?: boolean(name='CanDelete'),
        createTime?: long(name='CreateTime'),
        durable?: boolean(name='Durable'),
        exclusive?: boolean(name='Exclusive'),
        lastConsumeTime?: long(name='LastConsumeTime'),
        name?: string(name='Name'),
        vhostName?: string(name='VhostName'),
      }
    ](name='QueueVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListQueue  ListQueueRequest
  * @return ListQueueResponse
 */
async function listQueue(request: ListQueueRequest): ListQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueue', 'POST', '/', 'json', false, 'json', request);
}

model ListQueueUpstreamBindingsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, maximum=500, position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=1, maximum=100, position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model ListQueueUpstreamBindingsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    voList?: {
      bindingVO?: [ 
      {
        argument?: string(name='Argument'),
        bindingKey?: string(name='BindingKey'),
        bindingType?: int32(name='BindingType'),
        dstName?: string(name='DstName'),
        srcName?: string(name='SrcName'),
      }
    ](name='BindingVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListQueueUpstreamBindingsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListQueueUpstreamBindingsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListQueueUpstreamBindings  ListQueueUpstreamBindingsRequest
  * @return ListQueueUpstreamBindingsResponse
 */
async function listQueueUpstreamBindings(request: ListQueueUpstreamBindingsRequest): ListQueueUpstreamBindingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListQueueUpstreamBindings', 'POST', '/', 'json', false, 'json', request);
}

model ListStaticAccountsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
}

model ListStaticAccountsResponseBody = {
  code?: int32(name='Code'),
  data?: map[string]any(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListStaticAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListStaticAccountsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListStaticAccounts  ListStaticAccountsRequest
  * @return ListStaticAccountsResponse
 */
async function listStaticAccounts(request: ListStaticAccountsRequest): ListStaticAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListStaticAccounts', 'POST', '/', 'json', false, 'json', request);
}

model ListVhostRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  vhostNamePrefix?: string(name='VhostNamePrefix', position='Query'),
}

model ListVhostResponseBody = {
  code?: int32(name='Code'),
  data?: {
    vhosts?: [ 
    {
      channelNum?: int32(name='ChannelNum'),
      connectionNum?: int32(name='ConnectionNum'),
      name?: string(name='Name'),
    }
  ](name='Vhosts')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListVhostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListVhostResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListVhost  ListVhostRequest
  * @return ListVhostResponse
 */
async function listVhost(request: ListVhostRequest): ListVhostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListVhost', 'POST', '/', 'json', false, 'json', request);
}

model MetadataRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
}

model MetadataResponseBody = {
  code?: int32(name='Code'),
  data?: {
    endpoint?: string(name='Endpoint'),
    hasPretendPermission?: boolean(name='HasPretendPermission'),
    internalEndpoint?: string(name='InternalEndpoint'),
    pretendUserId?: string(name='PretendUserId'),
    userStatus?: int32(name='UserStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model MetadataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MetadataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of Metadata  MetadataRequest
  * @return MetadataResponse
 */
async function metadata(request: MetadataRequest): MetadataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Metadata', 'POST', '/', 'json', false, 'json', request);
}

model PurgeQueueRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  collina?: string(name='Collina', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  queueName?: string(name='QueueName', position='Query'),
  queueNames?: map[string]any(name='QueueNames', shrink='json', position='Query'),
  umidToken?: string(name='UmidToken', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model PurgeQueueResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model PurgeQueueResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PurgeQueueResponseBody(name='body'),
}

/**
  * @param request  the request parameters of PurgeQueue  PurgeQueueRequest
  * @return PurgeQueueResponse
 */
async function purgeQueue(request: PurgeQueueRequest): PurgeQueueResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurgeQueue', 'POST', '/', 'json', false, 'json', request);
}

model QueryMessageByMessageIdRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  beginTime?: long(name='BeginTime', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage?: int32(name='CurrentPage', position='Query'),
  endTime?: long(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  messageId: string(name='MessageId', description='This parameter is required.', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model QueryMessageByMessageIdResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: int32(name='TotalCount'),
    voList?: [ 
      {
        appId?: string(name='AppId'),
        body?: string(name='Body'),
        clusterId?: string(name='ClusterId'),
        contentEncoding?: string(name='ContentEncoding'),
        contentType?: string(name='ContentType'),
        correlationId?: string(name='CorrelationId'),
        deliveryMode?: int32(name='DeliveryMode'),
        exchangeName?: string(name='ExchangeName'),
        expiration?: string(name='Expiration'),
        headers?: string(name='Headers'),
        immediate?: boolean(name='Immediate'),
        mandatory?: boolean(name='Mandatory'),
        messageId?: string(name='MessageId'),
        priority?: int32(name='Priority'),
        processToken?: string(name='ProcessToken'),
        reconsumeTimes?: int32(name='ReconsumeTimes'),
        replyTo?: string(name='ReplyTo'),
        routingKey?: string(name='RoutingKey'),
        storeTimestamp?: long(name='StoreTimestamp'),
        timestamp?: long(name='Timestamp'),
        type?: string(name='Type'),
        userId?: string(name='UserId'),
      }
    ](name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMessageByMessageIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageByMessageIdResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMessageByMessageId  QueryMessageByMessageIdRequest
  * @return QueryMessageByMessageIdResponse
 */
async function queryMessageByMessageId(request: QueryMessageByMessageIdRequest): QueryMessageByMessageIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMessageByMessageId', 'POST', '/', 'json', false, 'json', request);
}

model QueryMessageByQueueNameRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  beginTime: long(name='BeginTime', description='This parameter is required.', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  currentPage: int32(name='CurrentPage', description='This parameter is required.', minimum=1, position='Query'),
  endTime: long(name='EndTime', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageSize: int32(name='PageSize', description='This parameter is required.', minimum=5, maximum=100, position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model QueryMessageByQueueNameResponseBody = {
  code?: int32(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    pageSize?: int32(name='PageSize'),
    taskId?: string(name='TaskId'),
    totalCount?: long(name='TotalCount'),
    voList?: {
      amqpMessageVO?: [ 
      {
        appId?: string(name='AppId'),
        body?: string(name='Body'),
        clusterId?: string(name='ClusterId'),
        contentEncoding?: string(name='ContentEncoding'),
        contentType?: string(name='ContentType'),
        correlationId?: string(name='CorrelationId'),
        deliveryMode?: int32(name='DeliveryMode'),
        exchangeName?: string(name='ExchangeName'),
        expiration?: string(name='Expiration'),
        headers?: string(name='Headers'),
        immediate?: boolean(name='Immediate'),
        mandatory?: boolean(name='Mandatory'),
        messageId?: string(name='MessageId'),
        priority?: int32(name='Priority'),
        processToken?: string(name='ProcessToken'),
        reconsumeTimes?: int32(name='ReconsumeTimes'),
        replyTo?: string(name='ReplyTo'),
        routingKey?: string(name='RoutingKey'),
        storeTimestamp?: long(name='StoreTimestamp'),
        timestamp?: long(name='Timestamp'),
        type?: string(name='Type'),
        userId?: string(name='UserId'),
      }
    ](name='AmqpMessageVO')
    }(name='VoList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QueryMessageByQueueNameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageByQueueNameResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryMessageByQueueName  QueryMessageByQueueNameRequest
  * @return QueryMessageByQueueNameResponse
 */
async function queryMessageByQueueName(request: QueryMessageByQueueNameRequest): QueryMessageByQueueNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMessageByQueueName', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstanceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
}

model ReleaseInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ReleaseInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ReleaseInstance  ReleaseInstanceRequest
  * @return ReleaseInstanceResponse
 */
async function releaseInstance(request: ReleaseInstanceRequest): ReleaseInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstance', 'POST', '/', 'json', false, 'json', request);
}

model SendMessageRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  body: string(name='Body', description='This parameter is required.', position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  exchangeName: string(name='ExchangeName', description='This parameter is required.', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  messageId: string(name='MessageId', description='This parameter is required.', position='Query'),
  props?: string(name='Props', position='Query'),
  routingKey: string(name='RoutingKey', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model SendMessageResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model SendMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SendMessage  SendMessageRequest
  * @return SendMessageResponse
 */
async function sendMessage(request: SendMessageRequest): SendMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendMessage', 'POST', '/', 'json', false, 'json', request);
}

model SendMessageCopyRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  processToken: string(name='ProcessToken', description='This parameter is required.', position='Query'),
  queueName: string(name='QueueName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model SendMessageCopyResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SendMessageCopyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageCopyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SendMessageCopy  SendMessageCopyRequest
  * @return SendMessageCopyResponse
 */
async function sendMessageCopy(request: SendMessageCopyRequest): SendMessageCopyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendMessageCopy', 'POST', '/', 'json', false, 'json', request);
}

model UnbindRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  bindingKey?: string(name='BindingKey', position='Query'),
  bindingType: int32(name='BindingType', description='This parameter is required.', minimum=0, maximum=1, position='Query'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  dstName: string(name='DstName', description='This parameter is required.', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  srcName: string(name='SrcName', description='This parameter is required.', position='Query'),
  vhostName: string(name='VhostName', description='This parameter is required.', position='Query'),
}

model UnbindResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbindResponseBody(name='body'),
}

/**
  * @param request  the request parameters of Unbind  UnbindRequest
  * @return UnbindResponse
 */
async function unbind(request: UnbindRequest): UnbindResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'Unbind', 'POST', '/', 'json', false, 'json', request);
}

model UpdateInstanceRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  instanceName: string(name='InstanceName', description='This parameter is required.', position='Query'),
}

model UpdateInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateInstance  UpdateInstanceRequest
  * @return UpdateInstanceResponse
 */
async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstance', 'POST', '/', 'json', false, 'json', request);
}

model UpdateInstanceRetryStrategyRequest {
  regionId?: string(name='RegionId', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  retryInterval?: int32(name='RetryInterval', position='Query'),
  retryTimes?: int32(name='RetryTimes', position='Query'),
}

model UpdateInstanceRetryStrategyResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateInstanceRetryStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateInstanceRetryStrategyResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateInstanceRetryStrategy  UpdateInstanceRetryStrategyRequest
  * @return UpdateInstanceRetryStrategyResponse
 */
async function updateInstanceRetryStrategy(request: UpdateInstanceRetryStrategyRequest): UpdateInstanceRetryStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateInstanceRetryStrategy', 'POST', '/', 'json', false, 'json', request);
}

model UpdateServerlessSwitchRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
  serverlessSwitch: boolean(name='ServerlessSwitch', description='This parameter is required.', position='Query'),
}

model UpdateServerlessSwitchResponseBody = {
  code?: int32(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateServerlessSwitchResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateServerlessSwitchResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateServerlessSwitch  UpdateServerlessSwitchRequest
  * @return UpdateServerlessSwitchResponse
 */
async function updateServerlessSwitch(request: UpdateServerlessSwitchRequest): UpdateServerlessSwitchResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServerlessSwitch', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeLimitsRequest {
  regionId?: string(name='RegionId', description='This parameter is required.', position='Host'),
  consoleSessionId?: string(name='ConsoleSessionId', position='Query'),
  instanceId: string(name='InstanceId', description='This parameter is required.', position='Query'),
}

model UpgradeLimitsResponseBody = {
  code?: int32(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpgradeLimitsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeLimitsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpgradeLimits  UpgradeLimitsRequest
  * @return UpgradeLimitsResponse
 */
async function upgradeLimits(request: UpgradeLimitsRequest): UpgradeLimitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeLimits', 'POST', '/', 'json', false, 'json', request);
}

