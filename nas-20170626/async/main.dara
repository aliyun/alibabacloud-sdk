/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'NAS';
  @version = '2017-06-26';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-chengdu = 'nas.aliyuncs.com',
    me-east-1 = 'nas.ap-northeast-1.aliyuncs.com',
    cn-hangzhou-finance = 'nas.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddClientToBlackListRequest {
  clientIP: string(name='ClientIP', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model AddClientToBlackListResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddClientToBlackListResponse = {
  headers: map[string]string(name='headers'),
  body: AddClientToBlackListResponseBody(name='body'),
}

async function addClientToBlackList(request: AddClientToBlackListRequest): AddClientToBlackListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddClientToBlackList', 'POST', '/', 'json', false, 'json', request);
}

model AddTagsRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model AddTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsResponseBody(name='body'),
}

async function addTags(request: AddTagsRequest): AddTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTags', 'POST', '/', 'json', false, 'json', request);
}

model ApplyAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId: string(name='AutoSnapshotPolicyId', position='Query'),
  fileSystemIds: string(name='FileSystemIds', position='Query'),
}

model ApplyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyAutoSnapshotPolicyResponseBody(name='body'),
}

async function applyAutoSnapshotPolicy(request: ApplyAutoSnapshotPolicyRequest): ApplyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ApplyDataFlowAutoRefreshRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', minimum=5, maximum=525600, position='Query'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', position='Query'),
  autoRefreshs: [ 
    {
      refreshPath?: string(name='RefreshPath', minLength=2, maxLength=1024),
    }
  ](name='AutoRefreshs', position='Query'),
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model ApplyDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyDataFlowAutoRefreshResponse = {
  headers: map[string]string(name='headers'),
  body: ApplyDataFlowAutoRefreshResponseBody(name='body'),
}

async function applyDataFlowAutoRefresh(request: ApplyDataFlowAutoRefreshRequest): ApplyDataFlowAutoRefreshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ApplyDataFlowAutoRefresh', 'POST', '/', 'json', false, 'json', request);
}

model CancelAutoSnapshotPolicyRequest {
  fileSystemIds: string(name='FileSystemIds', position='Query'),
}

model CancelAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CancelAutoSnapshotPolicyResponseBody(name='body'),
}

async function cancelAutoSnapshotPolicy(request: CancelAutoSnapshotPolicyRequest): CancelAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model CancelDataFlowAutoRefreshRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  refreshPath?: string(name='RefreshPath', position='Query'),
}

model CancelDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelDataFlowAutoRefreshResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDataFlowAutoRefreshResponseBody(name='body'),
}

async function cancelDataFlowAutoRefresh(request: CancelDataFlowAutoRefreshRequest): CancelDataFlowAutoRefreshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelDataFlowAutoRefresh', 'POST', '/', 'json', false, 'json', request);
}

model CancelDataFlowTaskRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  taskId: string(name='TaskId', position='Query'),
}

model CancelDataFlowTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelDataFlowTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDataFlowTaskResponseBody(name='body'),
}

async function cancelDataFlowTask(request: CancelDataFlowTaskRequest): CancelDataFlowTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelDataFlowTask', 'POST', '/', 'json', false, 'json', request);
}

model CancelDirQuotaRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  path: string(name='Path', position='Query'),
  userId?: string(name='UserId', position='Query'),
  userType: string(name='UserType', position='Query'),
}

model CancelDirQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelDirQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: CancelDirQuotaResponseBody(name='body'),
}

async function cancelDirQuota(request: CancelDirQuotaRequest): CancelDirQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelDirQuota', 'POST', '/', 'json', false, 'json', request);
}

model CancelLifecycleRetrieveJobRequest {
  jobId: string(name='JobId', position='Query'),
}

model CancelLifecycleRetrieveJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelLifecycleRetrieveJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelLifecycleRetrieveJobResponseBody(name='body'),
}

async function cancelLifecycleRetrieveJob(request: CancelLifecycleRetrieveJobRequest): CancelLifecycleRetrieveJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelLifecycleRetrieveJob', 'POST', '/', 'json', false, 'json', request);
}

model CancelRecycleBinJobRequest {
  jobId: string(name='JobId', position='Query'),
}

model CancelRecycleBinJobResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CancelRecycleBinJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelRecycleBinJobResponseBody(name='body'),
}

async function cancelRecycleBinJob(request: CancelRecycleBinJobRequest): CancelRecycleBinJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelRecycleBinJob', 'GET', '/', 'json', false, 'json', request);
}

model CreateAccessGroupRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  accessGroupType: string(name='AccessGroupType', position='Query'),
  description?: string(name='Description', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
}

model CreateAccessGroupResponseBody = {
  accessGroupName?: string(name='AccessGroupName'),
  requestId?: string(name='RequestId'),
}

model CreateAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessGroupResponseBody(name='body'),
}

async function createAccessGroup(request: CreateAccessGroupRequest): CreateAccessGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccessRuleRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  RWAccessType?: string(name='RWAccessType', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  userAccessType?: string(name='UserAccessType', position='Query'),
}

model CreateAccessRuleResponseBody = {
  accessRuleId?: string(name='AccessRuleId'),
  requestId?: string(name='RequestId'),
}

model CreateAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccessRuleResponseBody(name='body'),
}

async function createAccessRule(request: CreateAccessRuleRequest): CreateAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model CreateAutoSnapshotPolicyRequest {
  autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', position='Query'),
  fileSystemType: string(name='FileSystemType', position='Query'),
  repeatWeekdays: string(name='RepeatWeekdays', position='Query'),
  retentionDays?: int32(name='RetentionDays', minimum=-1, maximum=65536, position='Query'),
  timePoints: string(name='TimePoints', position='Query'),
}

model CreateAutoSnapshotPolicyResponseBody = {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
  requestId?: string(name='RequestId'),
}

model CreateAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAutoSnapshotPolicyResponseBody(name='body'),
}

async function createAutoSnapshotPolicy(request: CreateAutoSnapshotPolicyRequest): CreateAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataFlowRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', minimum=5, maximum=525600, position='Query'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', position='Query'),
  autoRefreshs?: [ 
    {
      refreshPath?: string(name='RefreshPath', minLength=2, maxLength=1024),
    }
  ](name='AutoRefreshs', position='Query'),
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  fsetId: string(name='FsetId', position='Query'),
  sourceSecurityType?: string(name='SourceSecurityType', position='Query'),
  sourceStorage: string(name='SourceStorage', minLength=8, maxLength=128, position='Query'),
  throughput: long(name='Throughput', position='Query'),
}

model CreateDataFlowResponseBody = {
  dataFlowId?: string(name='DataFlowId'),
  requestId?: string(name='RequestId'),
}

model CreateDataFlowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataFlowResponseBody(name='body'),
}

async function createDataFlow(request: CreateDataFlowRequest): CreateDataFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataFlow', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataFlowTaskRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dataType?: string(name='DataType', position='Query'),
  directory?: string(name='Directory', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  entryList?: string(name='EntryList', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  srcTaskId?: string(name='SrcTaskId', position='Query'),
  taskAction?: string(name='TaskAction', position='Query'),
}

model CreateDataFlowTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateDataFlowTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataFlowTaskResponseBody(name='body'),
}

async function createDataFlowTask(request: CreateDataFlowTaskRequest): CreateDataFlowTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataFlowTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateFileSystemRequest {
  bandwidth?: long(name='Bandwidth', position='Query'),
  capacity?: long(name='Capacity', position='Query'),
  chargeType?: string(name='ChargeType', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  duration?: int32(name='Duration', position='Query'),
  encryptType?: int32(name='EncryptType', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  kmsKeyId?: string(name='KmsKeyId', position='Query'),
  protocolType: string(name='ProtocolType', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  storageType: string(name='StorageType', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId'),
  requestId?: string(name='RequestId'),
}

model CreateFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFileSystemResponseBody(name='body'),
}

async function createFileSystem(request: CreateFileSystemRequest): CreateFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model CreateFilesetRequest {
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  fileSystemPath: string(name='FileSystemPath', minLength=2, maxLength=1024, position='Query'),
}

model CreateFilesetResponseBody = {
  fsetId?: string(name='FsetId'),
  requestId?: string(name='RequestId'),
}

model CreateFilesetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFilesetResponseBody(name='body'),
}

async function createFileset(request: CreateFilesetRequest): CreateFilesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFileset', 'POST', '/', 'json', false, 'json', request);
}

model CreateLDAPConfigRequest {
  bindDN?: string(name='BindDN', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  searchBase: string(name='SearchBase', position='Query'),
  URI: string(name='URI', position='Query'),
}

model CreateLDAPConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateLDAPConfigResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLDAPConfigResponseBody(name='body'),
}

async function createLDAPConfig(request: CreateLDAPConfigRequest): CreateLDAPConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLDAPConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateLifecyclePolicyRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  lifecyclePolicyName: string(name='LifecyclePolicyName', position='Query'),
  lifecycleRuleName: string(name='LifecycleRuleName', position='Query'),
  path?: string(name='Path', position='Query'),
  paths?: [ string ](name='Paths', position='Query'),
  storageType: string(name='StorageType', position='Query'),
}

model CreateLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateLifecyclePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLifecyclePolicyResponseBody(name='body'),
}

async function createLifecyclePolicy(request: CreateLifecyclePolicyRequest): CreateLifecyclePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLifecyclePolicy', 'POST', '/', 'json', false, 'json', request);
}

model CreateLifecycleRetrieveJobRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  paths: [ string ](name='Paths', position='Query'),
}

model CreateLifecycleRetrieveJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId'),
}

model CreateLifecycleRetrieveJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateLifecycleRetrieveJobResponseBody(name='body'),
}

async function createLifecycleRetrieveJob(request: CreateLifecycleRetrieveJobRequest): CreateLifecycleRetrieveJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLifecycleRetrieveJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateMountTargetRequest {
  accessGroupName?: string(name='AccessGroupName', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  enableIpv6?: boolean(name='EnableIpv6', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  networkType: string(name='NetworkType', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model CreateMountTargetResponseBody = {
  mountTargetDomain?: string(name='MountTargetDomain'),
  mountTargetExtra?: {
    dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain'),
  }(name='MountTargetExtra'),
  requestId?: string(name='RequestId'),
}

model CreateMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMountTargetResponseBody(name='body'),
}

async function createMountTarget(request: CreateMountTargetRequest): CreateMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model CreateRecycleBinDeleteJobRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  fileId: string(name='FileId', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model CreateRecycleBinDeleteJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateRecycleBinDeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRecycleBinDeleteJobResponseBody(name='body'),
}

async function createRecycleBinDeleteJob(request: CreateRecycleBinDeleteJobRequest): CreateRecycleBinDeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRecycleBinDeleteJob', 'GET', '/', 'json', false, 'json', request);
}

model CreateRecycleBinRestoreJobRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  fileId: string(name='FileId', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  targetFileId: string(name='TargetFileId', position='Query'),
}

model CreateRecycleBinRestoreJobResponseBody = {
  jobId?: string(name='JobId'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model CreateRecycleBinRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRecycleBinRestoreJobResponseBody(name='body'),
}

async function createRecycleBinRestoreJob(request: CreateRecycleBinRestoreJobRequest): CreateRecycleBinRestoreJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRecycleBinRestoreJob', 'GET', '/', 'json', false, 'json', request);
}

model CreateSnapshotRequest {
  description?: string(name='Description', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  retentionDays?: int32(name='RetentionDays', minimum=-1, maximum=65536, position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
  snapshotId?: string(name='SnapshotId'),
}

model CreateSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSnapshotResponseBody(name='body'),
}

async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessGroupRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
}

model DeleteAccessGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessGroupResponseBody(name='body'),
}

async function deleteAccessGroup(request: DeleteAccessGroupRequest): DeleteAccessGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccessRuleRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  accessRuleId: string(name='AccessRuleId', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
}

model DeleteAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccessRuleResponseBody(name='body'),
}

async function deleteAccessRule(request: DeleteAccessRuleRequest): DeleteAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId: string(name='AutoSnapshotPolicyId', position='Query'),
}

model DeleteAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAutoSnapshotPolicyResponseBody(name='body'),
}

async function deleteAutoSnapshotPolicy(request: DeleteAutoSnapshotPolicyRequest): DeleteAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataFlowRequest {
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DeleteDataFlowResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDataFlowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataFlowResponseBody(name='body'),
}

async function deleteDataFlow(request: DeleteDataFlowRequest): DeleteDataFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataFlow', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFileSystemRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DeleteFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileSystemResponseBody(name='body'),
}

async function deleteFileSystem(request: DeleteFileSystemRequest): DeleteFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model DeleteFilesetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  fsetId: string(name='FsetId', position='Query'),
}

model DeleteFilesetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFilesetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFilesetResponseBody(name='body'),
}

async function deleteFileset(request: DeleteFilesetRequest): DeleteFilesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFileset', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLDAPConfigRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DeleteLDAPConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteLDAPConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLDAPConfigResponseBody(name='body'),
}

async function deleteLDAPConfig(request: DeleteLDAPConfigRequest): DeleteLDAPConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLDAPConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLifecyclePolicyRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  lifecyclePolicyName: string(name='LifecyclePolicyName', position='Query'),
}

model DeleteLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteLifecyclePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteLifecyclePolicyResponseBody(name='body'),
}

async function deleteLifecyclePolicy(request: DeleteLifecyclePolicyRequest): DeleteLifecyclePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLifecyclePolicy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMountTargetRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain: string(name='MountTargetDomain', position='Query'),
}

model DeleteMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteMountTargetResponseBody(name='body'),
}

async function deleteMountTarget(request: DeleteMountTargetRequest): DeleteMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotRequest {
  snapshotId: string(name='SnapshotId', position='Query'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessGroupsRequest {
  accessGroupName?: string(name='AccessGroupName', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  useUTCDateTime?: boolean(name='UseUTCDateTime', minimum=1, position='Query'),
}

model DescribeAccessGroupsResponseBody = {
  accessGroups?: {
    accessGroup?: [ 
    {
      accessGroupName?: string(name='AccessGroupName'),
      accessGroupType?: string(name='AccessGroupType'),
      description?: string(name='Description'),
      mountTargetCount?: int32(name='MountTargetCount'),
      ruleCount?: int32(name='RuleCount'),
    }
  ](name='AccessGroup')
  }(name='AccessGroups'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessGroupsResponseBody(name='body'),
}

async function describeAccessGroups(request: DescribeAccessGroupsRequest): DescribeAccessGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccessRulesRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  accessRuleId?: string(name='AccessRuleId', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeAccessRulesResponseBody = {
  accessRules?: {
    accessRule?: [ 
    {
      accessRuleId?: string(name='AccessRuleId'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp'),
      priority?: int32(name='Priority'),
      RWAccess?: string(name='RWAccess'),
      sourceCidrIp?: string(name='SourceCidrIp'),
      userAccess?: string(name='UserAccess'),
    }
  ](name='AccessRule')
  }(name='AccessRules'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAccessRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccessRulesResponseBody(name='body'),
}

async function describeAccessRules(request: DescribeAccessRulesRequest): DescribeAccessRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccessRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoSnapshotPoliciesRequest {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', position='Query'),
  fileSystemType: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeAutoSnapshotPoliciesResponseBody = {
  autoSnapshotPolicies?: {
    autoSnapshotPolicy?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName'),
      createTime?: string(name='CreateTime'),
      fileSystemNums?: int32(name='FileSystemNums'),
      regionId?: string(name='RegionId'),
      repeatWeekdays?: string(name='RepeatWeekdays'),
      retentionDays?: int32(name='RetentionDays'),
      status?: string(name='Status'),
      timePoints?: string(name='TimePoints'),
    }
  ](name='AutoSnapshotPolicy')
  }(name='AutoSnapshotPolicies'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoSnapshotPoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoSnapshotPoliciesResponseBody(name='body'),
}

async function describeAutoSnapshotPolicies(request: DescribeAutoSnapshotPoliciesRequest): DescribeAutoSnapshotPoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoSnapshotPolicies', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoSnapshotTasksRequest {
  autoSnapshotPolicyIds?: string(name='AutoSnapshotPolicyIds', position='Query'),
  fileSystemIds?: string(name='FileSystemIds', position='Query'),
  fileSystemType: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeAutoSnapshotTasksResponseBody = {
  autoSnapshotTasks?: {
    autoSnapshotTask?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId'),
      sourceFileSystemId?: string(name='SourceFileSystemId'),
    }
  ](name='AutoSnapshotTask')
  }(name='AutoSnapshotTasks'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeAutoSnapshotTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAutoSnapshotTasksResponseBody(name='body'),
}

async function describeAutoSnapshotTasks(request: DescribeAutoSnapshotTasksRequest): DescribeAutoSnapshotTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoSnapshotTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBlackListClientsRequest {
  clientIP?: string(name='ClientIP', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeBlackListClientsResponseBody = {
  clients?: string(name='Clients'),
  requestId?: string(name='RequestId'),
}

model DescribeBlackListClientsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBlackListClientsResponseBody(name='body'),
}

async function describeBlackListClients(request: DescribeBlackListClientsRequest): DescribeBlackListClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBlackListClients', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataFlowTasksRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model DescribeDataFlowTasksResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  taskInfo?: {
    task?: [ 
    {
      createTime?: string(name='CreateTime'),
      dataFlowId?: string(name='DataFlowId'),
      dataType?: string(name='DataType'),
      endTime?: string(name='EndTime'),
      fileSystemPath?: string(name='FileSystemPath'),
      filesystemId?: string(name='FilesystemId'),
      fsPath?: string(name='FsPath'),
      originator?: string(name='Originator'),
      progress?: long(name='Progress'),
      reportPath?: string(name='ReportPath'),
      sourceStorage?: string(name='SourceStorage'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      taskAction?: string(name='TaskAction'),
      taskId?: string(name='TaskId'),
    }
  ](name='Task')
  }(name='TaskInfo'),
}

model DescribeDataFlowTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataFlowTasksResponseBody(name='body'),
}

async function describeDataFlowTasks(request: DescribeDataFlowTasksRequest): DescribeDataFlowTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataFlowTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataFlowsRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model DescribeDataFlowsResponseBody = {
  dataFlowInfo?: {
    dataFlow?: [ 
    {
      autoRefresh?: {
        autoRefresh?: [ 
        {
          refreshPath?: string(name='RefreshPath'),
        }
      ](name='AutoRefresh')
      }(name='AutoRefresh'),
      autoRefreshInterval?: long(name='AutoRefreshInterval'),
      autoRefreshPolicy?: string(name='AutoRefreshPolicy'),
      createTime?: string(name='CreateTime'),
      dataFlowId?: string(name='DataFlowId'),
      description?: string(name='Description'),
      errorMessage?: string(name='ErrorMessage'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemPath?: string(name='FileSystemPath'),
      fsetDescription?: string(name='FsetDescription'),
      fsetId?: string(name='FsetId'),
      sourceSecurityType?: string(name='SourceSecurityType'),
      sourceStorage?: string(name='SourceStorage'),
      status?: string(name='Status'),
      throughput?: long(name='Throughput'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='DataFlow')
  }(name='DataFlowInfo'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeDataFlowsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataFlowsResponseBody(name='body'),
}

async function describeDataFlows(request: DescribeDataFlowsRequest): DescribeDataFlowsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataFlows', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDirQuotasRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  path?: string(name='Path', position='Query'),
}

model DescribeDirQuotasResponseBody = {
  dirQuotaInfos?: [ 
    {
      dirInode?: string(name='DirInode'),
      path?: string(name='Path'),
      status?: string(name='Status'),
      userQuotaInfos?: [ 
        {
          fileCountLimit?: long(name='FileCountLimit'),
          fileCountReal?: long(name='FileCountReal'),
          quotaType?: string(name='QuotaType'),
          sizeLimit?: long(name='SizeLimit'),
          sizeReal?: long(name='SizeReal'),
          userId?: string(name='UserId'),
          userType?: string(name='UserType'),
        }
      ](name='UserQuotaInfos'),
    }
  ](name='DirQuotaInfos'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDirQuotasResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDirQuotasResponseBody(name='body'),
}

async function describeDirQuotas(request: DescribeDirQuotasRequest): DescribeDirQuotasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDirQuotas', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFileSystemStatisticsRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeFileSystemStatisticsResponseBody = {
  fileSystemStatistics?: {
    fileSystemStatistic?: [ 
    {
      expiredCount?: int32(name='ExpiredCount'),
      expiringCount?: int32(name='ExpiringCount'),
      fileSystemType?: string(name='FileSystemType'),
      meteredSize?: long(name='MeteredSize'),
      totalCount?: int32(name='TotalCount'),
    }
  ](name='FileSystemStatistic')
  }(name='FileSystemStatistics'),
  fileSystems?: {
    fileSystem?: [ 
    {
      capacity?: long(name='Capacity'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      expiredTime?: string(name='ExpiredTime'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemType?: string(name='FileSystemType'),
      meteredIASize?: long(name='MeteredIASize'),
      meteredSize?: long(name='MeteredSize'),
      packages?: {
        package?: [ 
        {
          expiredTime?: string(name='ExpiredTime'),
          packageId?: string(name='PackageId'),
          size?: long(name='Size'),
          startTime?: string(name='StartTime'),
        }
      ](name='Package')
      }(name='Packages'),
      protocolType?: string(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      storageType?: string(name='StorageType'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystem')
  }(name='FileSystems'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeFileSystemStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFileSystemStatisticsResponseBody(name='body'),
}

async function describeFileSystemStatistics(request: DescribeFileSystemStatisticsRequest): DescribeFileSystemStatisticsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFileSystemStatistics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
}

model DescribeFileSystemsResponseBody = {
  fileSystems?: {
    fileSystem?: [ 
    {
      bandwidth?: long(name='Bandwidth'),
      capacity?: long(name='Capacity'),
      chargeType?: string(name='ChargeType'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      encryptType?: int32(name='EncryptType'),
      expiredTime?: string(name='ExpiredTime'),
      fileSystemId?: string(name='FileSystemId'),
      fileSystemType?: string(name='FileSystemType'),
      KMSKeyId?: string(name='KMSKeyId'),
      ldap?: {
        bindDN?: string(name='BindDN'),
        searchBase?: string(name='SearchBase'),
        URI?: string(name='URI'),
      }(name='Ldap'),
      meteredIASize?: long(name='MeteredIASize'),
      meteredSize?: long(name='MeteredSize'),
      mountTargets?: {
        mountTarget?: [ 
        {
          accessGroupName?: string(name='AccessGroupName'),
          clientMasterNodes?: {
            clientMasterNode?: [ 
            {
              defaultPasswd?: string(name='DefaultPasswd'),
              ecsId?: string(name='EcsId'),
              ecsIp?: string(name='EcsIp'),
            }
          ](name='ClientMasterNode')
          }(name='ClientMasterNodes'),
          dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain'),
          mountTargetDomain?: string(name='MountTargetDomain'),
          networkType?: string(name='NetworkType'),
          status?: string(name='Status'),
          tags?: {
            tag?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
            }
          ](name='Tag')
          }(name='Tags'),
          vpcId?: string(name='VpcId'),
          vswId?: string(name='VswId'),
        }
      ](name='MountTarget')
      }(name='MountTargets'),
      packages?: {
        package?: [ 
        {
          expiredTime?: string(name='ExpiredTime'),
          packageId?: string(name='PackageId'),
          packageType?: string(name='PackageType'),
          size?: long(name='Size'),
          startTime?: string(name='StartTime'),
        }
      ](name='Package')
      }(name='Packages'),
      protocolType?: string(name='ProtocolType'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      storageType?: string(name='StorageType'),
      supportedFeatures?: {
        supportedFeature?: [ string ](name='SupportedFeature')
      }(name='SupportedFeatures'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      version?: string(name='Version'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='FileSystem')
  }(name='FileSystems'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeFileSystemsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFileSystemsResponseBody(name='body'),
}

async function describeFileSystems(request: DescribeFileSystemsRequest): DescribeFileSystemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFileSystems', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFilesetsRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  filters?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Filters', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model DescribeFilesetsResponseBody = {
  entries?: {
    entrie?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      fileSystemPath?: string(name='FileSystemPath'),
      fsetId?: string(name='FsetId'),
      status?: string(name='Status'),
      updateTiem?: string(name='UpdateTiem'),
    }
  ](name='Entrie')
  }(name='Entries'),
  fileSystemId?: string(name='FileSystemId'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model DescribeFilesetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFilesetsResponseBody(name='body'),
}

async function describeFilesets(request: DescribeFilesetsRequest): DescribeFilesetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFilesets', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLDAPConfigRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DescribeLDAPConfigResponseBody = {
  ldap?: {
    bindDN?: string(name='BindDN'),
    searchBase?: string(name='SearchBase'),
    URI?: string(name='URI'),
  }(name='Ldap'),
  requestId?: string(name='RequestId'),
}

model DescribeLDAPConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLDAPConfigResponseBody(name='body'),
}

async function describeLDAPConfig(request: DescribeLDAPConfigRequest): DescribeLDAPConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLDAPConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLifecyclePoliciesRequest {
  fileSystemId?: string(name='FileSystemId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeLifecyclePoliciesResponseBody = {
  lifecyclePolicies?: [ 
    {
      createTime?: string(name='CreateTime'),
      fileSystemId?: string(name='FileSystemId'),
      lifecyclePolicyName?: string(name='LifecyclePolicyName'),
      lifecycleRuleName?: string(name='LifecycleRuleName'),
      path?: string(name='Path'),
      paths?: [ string ](name='Paths'),
      storageType?: string(name='StorageType'),
    }
  ](name='LifecyclePolicies'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLifecyclePoliciesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLifecyclePoliciesResponseBody(name='body'),
}

async function describeLifecyclePolicies(request: DescribeLifecyclePoliciesRequest): DescribeLifecyclePoliciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLifecyclePolicies', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLogAnalysisRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeLogAnalysisResponseBody = {
  analyses?: {
    analysis?: [ 
    {
      metaKey?: string(name='MetaKey'),
      metaValue?: {
        logstore?: string(name='Logstore'),
        project?: string(name='Project'),
        region?: string(name='Region'),
        roleArn?: string(name='RoleArn'),
      }(name='MetaValue'),
    }
  ](name='Analysis')
  }(name='Analyses'),
  code?: string(name='Code'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeLogAnalysisResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogAnalysisResponseBody(name='body'),
}

async function describeLogAnalysis(request: DescribeLogAnalysisRequest): DescribeLogAnalysisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLogAnalysis', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMountTargetsRequest {
  dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain?: string(name='MountTargetDomain', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeMountTargetsResponseBody = {
  mountTargets?: {
    mountTarget?: [ 
    {
      accessGroup?: string(name='AccessGroup'),
      clientMasterNodes?: {
        clientMasterNode?: [ 
        {
          defaultPasswd?: string(name='DefaultPasswd'),
          ecsId?: string(name='EcsId'),
          ecsIp?: string(name='EcsIp'),
        }
      ](name='ClientMasterNode')
      }(name='ClientMasterNodes'),
      dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain'),
      mountTargetDomain?: string(name='MountTargetDomain'),
      networkType?: string(name='NetworkType'),
      status?: string(name='Status'),
      vpcId?: string(name='VpcId'),
      vswId?: string(name='VswId'),
    }
  ](name='MountTarget')
  }(name='MountTargets'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeMountTargetsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMountTargetsResponseBody(name='body'),
}

async function describeMountTargets(request: DescribeMountTargetsRequest): DescribeMountTargetsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMountTargets', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMountedClientsRequest {
  clientIP?: string(name='ClientIP', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain: string(name='MountTargetDomain', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeMountedClientsResponseBody = {
  clients?: {
    client?: [ 
    {
      clientIP?: string(name='ClientIP'),
    }
  ](name='Client')
  }(name='Clients'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeMountedClientsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMountedClientsResponseBody(name='body'),
}

async function describeMountedClients(request: DescribeMountedClientsRequest): DescribeMountedClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMountedClients', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  fileSystemType?: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
}

model DescribeRegionsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSmbAclRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DescribeSmbAclResponseBody = {
  acl?: {
    authMethod?: string(name='AuthMethod'),
    enableAnonymousAccess?: boolean(name='EnableAnonymousAccess'),
    enabled?: boolean(name='Enabled'),
    encryptData?: boolean(name='EncryptData'),
    homeDirPath?: string(name='HomeDirPath'),
    rejectUnencryptedAccess?: boolean(name='RejectUnencryptedAccess'),
    superAdminSid?: string(name='SuperAdminSid'),
  }(name='Acl'),
  requestId?: string(name='RequestId'),
}

model DescribeSmbAclResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSmbAclResponseBody(name='body'),
}

async function describeSmbAcl(request: DescribeSmbAclRequest): DescribeSmbAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSmbAcl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSnapshotsRequest {
  fileSystemId?: string(name='FileSystemId', position='Query'),
  fileSystemType: string(name='FileSystemType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  snapshotIds?: string(name='SnapshotIds', position='Query'),
  snapshotName?: string(name='SnapshotName', position='Query'),
  snapshotType?: string(name='SnapshotType', position='Query'),
  status?: string(name='Status', position='Query'),
}

model DescribeSnapshotsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  snapshots?: {
    snapshot?: [ 
    {
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      encryptType?: int32(name='EncryptType'),
      progress?: string(name='Progress'),
      remainTime?: int32(name='RemainTime'),
      retentionDays?: int32(name='RetentionDays'),
      snapshotId?: string(name='SnapshotId'),
      snapshotName?: string(name='SnapshotName'),
      sourceFileSystemId?: string(name='SourceFileSystemId'),
      sourceFileSystemSize?: long(name='SourceFileSystemSize'),
      sourceFileSystemVersion?: string(name='SourceFileSystemVersion'),
      status?: string(name='Status'),
    }
  ](name='Snapshot')
  }(name='Snapshots'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSnapshotsResponseBody(name='body'),
}

async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStoragePackagesRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  useUTCDateTime?: boolean(name='UseUTCDateTime', minimum=1, position='Query'),
}

model DescribeStoragePackagesResponseBody = {
  packages?: {
    package?: [ 
    {
      expiredTime?: string(name='ExpiredTime'),
      fileSystemId?: string(name='FileSystemId'),
      packageId?: string(name='PackageId'),
      size?: long(name='Size'),
      startTime?: string(name='StartTime'),
      status?: string(name='Status'),
      storageType?: string(name='StorageType'),
    }
  ](name='Package')
  }(name='Packages'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeStoragePackagesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStoragePackagesResponseBody(name='body'),
}

async function describeStoragePackages(request: DescribeStoragePackagesRequest): DescribeStoragePackagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStoragePackages', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  fileSystemId?: string(name='FileSystemId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model DescribeTagsResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  tags?: {
    tag?: [ 
    {
      fileSystemIds?: {
        fileSystemId?: [ string ](name='FileSystemId')
      }(name='FileSystemIds'),
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag')
  }(name='Tags'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeZonesRequest {
  fileSystemType?: string(name='FileSystemType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    zone?: [ 
    {
      capacity?: {
        protocol?: [ string ](name='Protocol')
      }(name='Capacity'),
      instanceTypes?: {
        instanceType?: [ 
        {
          protocolType?: string(name='ProtocolType'),
          storageType?: string(name='StorageType'),
        }
      ](name='InstanceType')
      }(name='InstanceTypes'),
      performance?: {
        protocol?: [ string ](name='Protocol')
      }(name='Performance'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Zone')
  }(name='Zones'),
}

model DescribeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeZonesResponseBody(name='body'),
}

async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeZones', 'POST', '/', 'json', false, 'json', request);
}

model DisableAndCleanRecycleBinRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DisableAndCleanRecycleBinResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DisableAndCleanRecycleBinResponse = {
  headers: map[string]string(name='headers'),
  body: DisableAndCleanRecycleBinResponseBody(name='body'),
}

async function disableAndCleanRecycleBin(request: DisableAndCleanRecycleBinRequest): DisableAndCleanRecycleBinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableAndCleanRecycleBin', 'GET', '/', 'json', false, 'json', request);
}

model DisableSmbAclRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DisableSmbAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableSmbAclResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSmbAclResponseBody(name='body'),
}

async function disableSmbAcl(request: DisableSmbAclRequest): DisableSmbAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableSmbAcl', 'POST', '/', 'json', false, 'json', request);
}

model EnableRecycleBinRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  reservedDays?: long(name='ReservedDays', minimum=1, maximum=180, position='Query'),
}

model EnableRecycleBinResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model EnableRecycleBinResponse = {
  headers: map[string]string(name='headers'),
  body: EnableRecycleBinResponseBody(name='body'),
}

async function enableRecycleBin(request: EnableRecycleBinRequest): EnableRecycleBinResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableRecycleBin', 'POST', '/', 'json', false, 'json', request);
}

model EnableSmbAclRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  keytab: string(name='Keytab', position='Query'),
  keytabMd5: string(name='KeytabMd5', position='Query'),
}

model EnableSmbAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableSmbAclResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSmbAclResponseBody(name='body'),
}

async function enableSmbAcl(request: EnableSmbAclRequest): EnableSmbAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableSmbAcl', 'POST', '/', 'json', false, 'json', request);
}

model GetDirectoryOrFilePropertiesRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  path: string(name='Path', position='Query'),
}

model GetDirectoryOrFilePropertiesResponseBody = {
  entry?: {
    ATime?: string(name='ATime'),
    CTime?: string(name='CTime'),
    hasInfrequentAccessFile?: boolean(name='HasInfrequentAccessFile'),
    inode?: string(name='Inode'),
    MTime?: string(name='MTime'),
    name?: string(name='Name'),
    retrieveTime?: string(name='RetrieveTime'),
    size?: long(name='Size'),
    storageType?: string(name='StorageType'),
    type?: string(name='Type'),
  }(name='Entry'),
  requestId?: string(name='RequestId'),
}

model GetDirectoryOrFilePropertiesResponse = {
  headers: map[string]string(name='headers'),
  body: GetDirectoryOrFilePropertiesResponseBody(name='body'),
}

async function getDirectoryOrFileProperties(request: GetDirectoryOrFilePropertiesRequest): GetDirectoryOrFilePropertiesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDirectoryOrFileProperties', 'POST', '/', 'json', false, 'json', request);
}

model GetRecycleBinAttributeRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model GetRecycleBinAttributeResponseBody = {
  recycleBinAttribute?: {
    enableTime?: string(name='EnableTime'),
    reservedDays?: long(name='ReservedDays'),
    size?: long(name='Size'),
    status?: string(name='Status'),
  }(name='RecycleBinAttribute'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model GetRecycleBinAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: GetRecycleBinAttributeResponseBody(name='body'),
}

async function getRecycleBinAttribute(request: GetRecycleBinAttributeRequest): GetRecycleBinAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRecycleBinAttribute', 'GET', '/', 'json', false, 'json', request);
}

model ListDirectoriesAndFilesRequest {
  directoryOnly?: boolean(name='DirectoryOnly', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=128, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  path: string(name='Path', position='Query'),
  storageType: string(name='StorageType', position='Query'),
}

model ListDirectoriesAndFilesResponseBody = {
  entries?: [ 
    {
      atime?: string(name='Atime'),
      ctime?: string(name='Ctime'),
      fileId?: string(name='FileId'),
      hasInfrequentAccessFile?: boolean(name='HasInfrequentAccessFile'),
      inode?: string(name='Inode'),
      mtime?: string(name='Mtime'),
      name?: string(name='Name'),
      retrieveTime?: string(name='RetrieveTime'),
      size?: long(name='Size'),
      storageType?: string(name='StorageType'),
      type?: string(name='Type'),
    }
  ](name='Entries'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
}

model ListDirectoriesAndFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListDirectoriesAndFilesResponseBody(name='body'),
}

async function listDirectoriesAndFiles(request: ListDirectoriesAndFilesRequest): ListDirectoriesAndFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDirectoriesAndFiles', 'POST', '/', 'json', false, 'json', request);
}

model ListLifecycleRetrieveJobsRequest {
  fileSystemId?: string(name='FileSystemId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListLifecycleRetrieveJobsResponseBody = {
  lifecycleRetrieveJobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      discoveredFileCount?: long(name='DiscoveredFileCount'),
      fileSystemId?: string(name='FileSystemId'),
      jobId?: string(name='JobId'),
      paths?: [ string ](name='Paths'),
      retrievedFileCount?: long(name='RetrievedFileCount'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='LifecycleRetrieveJobs'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLifecycleRetrieveJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLifecycleRetrieveJobsResponseBody(name='body'),
}

async function listLifecycleRetrieveJobs(request: ListLifecycleRetrieveJobsRequest): ListLifecycleRetrieveJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLifecycleRetrieveJobs', 'POST', '/', 'json', false, 'json', request);
}

model ListRecentlyRecycledDirectoriesRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=1000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model ListRecentlyRecycledDirectoriesResponseBody = {
  entries?: [ 
    {
      fileId?: string(name='FileId'),
      lastDeleteTime?: string(name='LastDeleteTime'),
      name?: string(name='Name'),
      path?: string(name='Path'),
    }
  ](name='Entries'),
  nextToken?: string(name='NextToken', description='Id of the request'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListRecentlyRecycledDirectoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecentlyRecycledDirectoriesResponseBody(name='body'),
}

async function listRecentlyRecycledDirectories(request: ListRecentlyRecycledDirectoriesRequest): ListRecentlyRecycledDirectoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRecentlyRecycledDirectories', 'GET', '/', 'json', false, 'json', request);
}

model ListRecycleBinJobsRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  jobId?: string(name='JobId', position='Query'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Query'),
  pageSize?: long(name='PageSize', minimum=1, maximum=100, position='Query'),
  status?: string(name='Status', position='Query'),
}

model ListRecycleBinJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime'),
      errorCode?: string(name='ErrorCode'),
      errorMessage?: string(name='ErrorMessage'),
      fileId?: string(name='FileId'),
      fileName?: string(name='FileName'),
      id?: string(name='Id'),
      progress?: string(name='Progress'),
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Jobs'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
}

model ListRecycleBinJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecycleBinJobsResponseBody(name='body'),
}

async function listRecycleBinJobs(request: ListRecycleBinJobsRequest): ListRecycleBinJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRecycleBinJobs', 'GET', '/', 'json', false, 'json', request);
}

model ListRecycledDirectoriesAndFilesRequest {
  fileId: string(name='FileId', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  maxResults?: long(name='MaxResults', minimum=10, maximum=1000, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
}

model ListRecycledDirectoriesAndFilesResponseBody = {
  entries?: [ 
    {
      ATime?: string(name='ATime'),
      CTime?: string(name='CTime'),
      deleteTime?: string(name='DeleteTime'),
      fileId?: string(name='FileId'),
      inode?: string(name='Inode'),
      MTime?: string(name='MTime'),
      name?: string(name='Name'),
      size?: long(name='Size'),
      type?: string(name='Type'),
    }
  ](name='Entries'),
  nextToken?: string(name='NextToken', description='Id of the request'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model ListRecycledDirectoriesAndFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRecycledDirectoriesAndFilesResponseBody(name='body'),
}

async function listRecycledDirectoriesAndFiles(request: ListRecycledDirectoriesAndFilesRequest): ListRecycledDirectoriesAndFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRecycledDirectoriesAndFiles', 'GET', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccessGroupRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  description?: string(name='Description', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
}

model ModifyAccessGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccessGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAccessGroupResponseBody(name='body'),
}

async function modifyAccessGroup(request: ModifyAccessGroupRequest): ModifyAccessGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccessGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccessRuleRequest {
  accessGroupName: string(name='AccessGroupName', position='Query'),
  accessRuleId: string(name='AccessRuleId', position='Query'),
  fileSystemType?: string(name='FileSystemType', position='Query'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', position='Query'),
  priority?: int32(name='Priority', minimum=1, maximum=100, position='Query'),
  RWAccessType?: string(name='RWAccessType', position='Query'),
  sourceCidrIp?: string(name='SourceCidrIp', position='Query'),
  userAccessType?: string(name='UserAccessType', position='Query'),
}

model ModifyAccessRuleResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccessRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAccessRuleResponseBody(name='body'),
}

async function modifyAccessRule(request: ModifyAccessRuleRequest): ModifyAccessRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccessRule', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId: string(name='AutoSnapshotPolicyId', position='Query'),
  autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', position='Query'),
  repeatWeekdays?: string(name='RepeatWeekdays', position='Query'),
  retentionDays?: int32(name='RetentionDays', minimum=-1, maximum=65536, position='Query'),
  timePoints?: string(name='TimePoints', position='Query'),
}

model ModifyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAutoSnapshotPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAutoSnapshotPolicyResponseBody(name='body'),
}

async function modifyAutoSnapshotPolicy(request: ModifyAutoSnapshotPolicyRequest): ModifyAutoSnapshotPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAutoSnapshotPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDataFlowRequest {
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  throughput?: long(name='Throughput', position='Query'),
}

model ModifyDataFlowResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDataFlowResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDataFlowResponseBody(name='body'),
}

async function modifyDataFlow(request: ModifyDataFlowRequest): ModifyDataFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDataFlow', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDataFlowAutoRefreshRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', minimum=5, maximum=525600, position='Query'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model ModifyDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDataFlowAutoRefreshResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDataFlowAutoRefreshResponseBody(name='body'),
}

async function modifyDataFlowAutoRefresh(request: ModifyDataFlowAutoRefreshRequest): ModifyDataFlowAutoRefreshResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDataFlowAutoRefresh', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFileSystemRequest {
  description?: string(name='Description', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model ModifyFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFileSystemResponseBody(name='body'),
}

async function modifyFileSystem(request: ModifyFileSystemRequest): ModifyFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model ModifyFilesetRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  fsetId: string(name='FsetId', position='Query'),
}

model ModifyFilesetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyFilesetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFilesetResponseBody(name='body'),
}

async function modifyFileset(request: ModifyFilesetRequest): ModifyFilesetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyFileset', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLDAPConfigRequest {
  bindDN?: string(name='BindDN', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  searchBase: string(name='SearchBase', position='Query'),
  URI: string(name='URI', position='Query'),
}

model ModifyLDAPConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyLDAPConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLDAPConfigResponseBody(name='body'),
}

async function modifyLDAPConfig(request: ModifyLDAPConfigRequest): ModifyLDAPConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLDAPConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLifecyclePolicyRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  lifecyclePolicyName: string(name='LifecyclePolicyName', position='Query'),
  lifecycleRuleName: string(name='LifecycleRuleName', position='Query'),
  path?: string(name='Path', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
}

model ModifyLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ModifyLifecyclePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyLifecyclePolicyResponseBody(name='body'),
}

async function modifyLifecyclePolicy(request: ModifyLifecyclePolicyRequest): ModifyLifecyclePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLifecyclePolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyMountTargetRequest {
  accessGroupName?: string(name='AccessGroupName', position='Query'),
  dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  mountTargetDomain?: string(name='MountTargetDomain', position='Query'),
  status?: string(name='Status', position='Query'),
}

model ModifyMountTargetResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyMountTargetResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyMountTargetResponseBody(name='body'),
}

async function modifyMountTarget(request: ModifyMountTargetRequest): ModifyMountTargetResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyMountTarget', 'POST', '/', 'json', false, 'json', request);
}

model ModifySmbAclRequest {
  enableAnonymousAccess: boolean(name='EnableAnonymousAccess', position='Query'),
  encryptData: boolean(name='EncryptData', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  homeDirPath?: string(name='HomeDirPath', position='Query'),
  keytab?: string(name='Keytab', position='Query'),
  keytabMd5?: string(name='KeytabMd5', position='Query'),
  rejectUnencryptedAccess: boolean(name='RejectUnencryptedAccess', position='Query'),
  superAdminSid?: string(name='SuperAdminSid', position='Query'),
}

model ModifySmbAclResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySmbAclResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySmbAclResponseBody(name='body'),
}

async function modifySmbAcl(request: ModifySmbAclRequest): ModifySmbAclResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySmbAcl', 'POST', '/', 'json', false, 'json', request);
}

model OpenNASServiceRequest {
}

model OpenNASServiceResponseBody = {
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model OpenNASServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenNASServiceResponseBody(name='body'),
}

async function openNASService(request: OpenNASServiceRequest): OpenNASServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenNASService', 'POST', '/', 'json', false, 'json', request);
}

model RemoveClientFromBlackListRequest {
  clientIP: string(name='ClientIP', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
}

model RemoveClientFromBlackListResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveClientFromBlackListResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveClientFromBlackListResponseBody(name='body'),
}

async function removeClientFromBlackList(request: RemoveClientFromBlackListRequest): RemoveClientFromBlackListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveClientFromBlackList', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTagsRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  tag: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model RemoveTagsResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsResponseBody(name='body'),
}

async function removeTags(request: RemoveTagsRequest): RemoveTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTags', 'POST', '/', 'json', false, 'json', request);
}

model ResetFileSystemRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
}

model ResetFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: ResetFileSystemResponseBody(name='body'),
}

async function resetFileSystem(request: ResetFileSystemRequest): ResetFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model RetryLifecycleRetrieveJobRequest {
  jobId: string(name='JobId', position='Query'),
}

model RetryLifecycleRetrieveJobResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetryLifecycleRetrieveJobResponse = {
  headers: map[string]string(name='headers'),
  body: RetryLifecycleRetrieveJobResponseBody(name='body'),
}

async function retryLifecycleRetrieveJob(request: RetryLifecycleRetrieveJobRequest): RetryLifecycleRetrieveJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryLifecycleRetrieveJob', 'POST', '/', 'json', false, 'json', request);
}

model SetDirQuotaRequest {
  fileCountLimit?: long(name='FileCountLimit', minimum=0, maximum=1000000000, position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
  path: string(name='Path', position='Query'),
  quotaType: string(name='QuotaType', position='Query'),
  sizeLimit?: long(name='SizeLimit', minimum=0, maximum=10000000, position='Query'),
  userId?: string(name='UserId', position='Query'),
  userType: string(name='UserType', position='Query'),
}

model SetDirQuotaResponseBody = {
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetDirQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: SetDirQuotaResponseBody(name='body'),
}

async function setDirQuota(request: SetDirQuotaRequest): SetDirQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetDirQuota', 'POST', '/', 'json', false, 'json', request);
}

model StartDataFlowRequest {
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model StartDataFlowResponseBody = {
  requestId?: string(name='RequestId'),
}

model StartDataFlowResponse = {
  headers: map[string]string(name='headers'),
  body: StartDataFlowResponseBody(name='body'),
}

async function startDataFlow(request: StartDataFlowRequest): StartDataFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDataFlow', 'POST', '/', 'json', false, 'json', request);
}

model StopDataFlowRequest {
  clientToken?: string(name='ClientToken', minLength=1, maxLength=64, position='Query'),
  dataFlowId: string(name='DataFlowId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model StopDataFlowResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDataFlowResponse = {
  headers: map[string]string(name='headers'),
  body: StopDataFlowResponseBody(name='body'),
}

async function stopDataFlow(request: StopDataFlowRequest): StopDataFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDataFlow', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag: [ 
    {
      key: string(name='Key'),
      value: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRecycleBinAttributeRequest {
  fileSystemId: string(name='FileSystemId', position='Query'),
  reservedDays: long(name='ReservedDays', minimum=1, maximum=180, position='Query'),
}

model UpdateRecycleBinAttributeResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model UpdateRecycleBinAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateRecycleBinAttributeResponseBody(name='body'),
}

async function updateRecycleBinAttribute(request: UpdateRecycleBinAttributeRequest): UpdateRecycleBinAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRecycleBinAttribute', 'GET', '/', 'json', false, 'json', request);
}

model UpgradeFileSystemRequest {
  capacity: long(name='Capacity', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model UpgradeFileSystemResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpgradeFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeFileSystemResponseBody(name='body'),
}

async function upgradeFileSystem(request: UpgradeFileSystemRequest): UpgradeFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeFileSystem', 'POST', '/', 'json', false, 'json', request);
}

