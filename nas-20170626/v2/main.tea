/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-hangzhou-finance' = 'nas.cn-hangzhou-dg-a01.aliyuncs.com',
    'ap-northeast-2-pop' = 'nas.aliyuncs.com',
    'ap-southeast-2' = 'nas.aliyuncs.com',
    'cn-beijing-finance-pop' = 'nas.aliyuncs.com',
    'cn-beijing-gov-1' = 'nas.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'nas.aliyuncs.com',
    'cn-edge-1' = 'nas.aliyuncs.com',
    'cn-fujian' = 'nas.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'nas.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'nas.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'nas.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'nas.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'nas.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'nas.aliyuncs.com',
    'cn-hangzhou-test-306' = 'nas.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'nas.aliyuncs.com',
    'cn-qingdao-nebula' = 'nas.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'nas.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'nas.aliyuncs.com',
    'cn-shanghai-inner' = 'nas.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'nas.aliyuncs.com',
    'cn-shenzhen-inner' = 'nas.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'nas.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'nas.aliyuncs.com',
    'cn-wuhan' = 'nas.aliyuncs.com',
    'cn-yushanfang' = 'nas.aliyuncs.com',
    'cn-zhangbei' = 'nas.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'nas.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'nas.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'nas.aliyuncs.com',
    'eu-west-1-oxs' = 'nas.aliyuncs.com',
    'rus-west-1-pop' = 'nas.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('nas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddClientToBlackListRequest {
  clientIP?: string(name='ClientIP', description='The IP address of the client to add.

This parameter is required.', example='192.168.0.0'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

This parameter is required.', example='123e4567-e89b-12d3-a456-426655440000'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-00dfe7963fc6****'),
  regionId?: string(name='RegionId', description='The ID of the region where the file system resides.

This parameter is required.', example='cn-hangzhou'),
}

model AddClientToBlackListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211A5C3'),
}

model AddClientToBlackListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddClientToBlackListResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI AddClientToBlackList is deprecated
 *
 * @summary Adds a client to the blacklist of a Cloud Parallel File Storage (CPFS) file system and revokes the write access from the client. The blacklist serves as an I/O fence.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request AddClientToBlackListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AddClientToBlackListResponse
 */
// Deprecated
@context("addClientToBlackListWithContext")
async function addClientToBlackListWithOptions(request: AddClientToBlackListRequest, runtime: $RuntimeOptions): AddClientToBlackListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientIP)) {
    query['ClientIP'] = request.clientIP;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AddClientToBlackList',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI AddClientToBlackList is deprecated
 *
 * @summary Adds a client to the blacklist of a Cloud Parallel File Storage (CPFS) file system and revokes the write access from the client. The blacklist serves as an I/O fence.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request AddClientToBlackListRequest
 * @return AddClientToBlackListResponse
 */
// Deprecated
async function addClientToBlackList(request: AddClientToBlackListRequest): AddClientToBlackListResponse {
  var runtime = new $RuntimeOptions{};
  return addClientToBlackListWithOptions(request, runtime);
}

model ApplyAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.

This parameter is required.', example='sp-extreme-233e6****'),
  fileSystemIds?: string(name='FileSystemIds', description='The IDs of advanced Extreme NAS file systems.

You can specify a maximum of 100 file system IDs at a time. If you want to apply an automatic snapshot policy to multiple file systems, separate the file system IDs with commas (,).

This parameter is required.', example='extreme-233e6****,extreme -23vbp****,extreme -23vas****'),
}

model ApplyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ApplyAutoSnapshotPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * @summary Applies an automatic snapshot policy to one or more file systems.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 * *   You can apply only one automatic snapshot policy to each file system.
 * *   Each automatic snapshot policy can be applied to multiple file systems.
 * *   If an automatic snapshot policy is applied to a file system, you can call the ApplyAutoSnapshotPolicy operation to change the automatic snapshot policy.
 *
 * @param request ApplyAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyAutoSnapshotPolicyResponse
 */
@context("applyAutoSnapshotPolicyWithContext")
async function applyAutoSnapshotPolicyWithOptions(request: ApplyAutoSnapshotPolicyRequest, runtime: $RuntimeOptions): ApplyAutoSnapshotPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyId)) {
    query['AutoSnapshotPolicyId'] = request.autoSnapshotPolicyId;
  }
  if (!$isNull(request.fileSystemIds)) {
    query['FileSystemIds'] = request.fileSystemIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ApplyAutoSnapshotPolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Applies an automatic snapshot policy to one or more file systems.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 * *   You can apply only one automatic snapshot policy to each file system.
 * *   Each automatic snapshot policy can be applied to multiple file systems.
 * *   If an automatic snapshot policy is applied to a file system, you can call the ApplyAutoSnapshotPolicy operation to change the automatic snapshot policy.
 *
 * @param request ApplyAutoSnapshotPolicyRequest
 * @return ApplyAutoSnapshotPolicyResponse
 */
async function applyAutoSnapshotPolicy(request: ApplyAutoSnapshotPolicyRequest): ApplyAutoSnapshotPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return applyAutoSnapshotPolicyWithOptions(request, runtime);
}

model ApplyDataFlowAutoRefreshRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', description='The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minute.

Valid values: 10 to 525600. Default value: 10.', example='10'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', description='The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy. Valid values:

*   None (default): Updated data in the source storage is not automatically imported into the CPFS file system. You can run a dataflow task to import the updated data from the source storage.
*   ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.', example='None'),
  autoRefreshs?: [ 
    {
      refreshPath?: string(name='RefreshPath', description='The automatic update directory. CPFS automatically checks whether the source data only in the directory is updated and imports the updated data.

Limits:

*   The directory must be 2 to 1,024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).

>  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.

This parameter is required.', example='/prefix1/prefix2/'),
    }
  ](name='AutoRefreshs', description='The automatic update configurations.

This parameter is required.'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
}

model ApplyDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ApplyDataFlowAutoRefreshResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ApplyDataFlowAutoRefreshResponseBody(name='body'),
}

/**
 * @summary Adds AutoRefresh configurations to a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can add AutoRefresh configurations only to the dataflows that are in the `Running` state.
 * *   You can add a maximum of five AutoRefresh configurations to a dataflow.
 * *   It generally takes 2 to 5 minutes to create an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/336901.html) operation to query the dataflow status.
 * *   AutoRefresh depends on the object modification events collected by EventBridge from the source OSS bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
 *     **
 *     **Note** The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
 * *   The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. When you add an AutoRefresh configuration to the prefix for a CPFS dataflow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS data flow.
 * *   After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a data flow task to load the updated data.
 * *   AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS data flow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the data flow status becomes Misconfigured. To resolve these issues, you can increase the data flow specifications or reduce the frequency of triggering the object modification event.
 *
 * @param request ApplyDataFlowAutoRefreshRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ApplyDataFlowAutoRefreshResponse
 */
@context("applyDataFlowAutoRefreshWithContext")
async function applyDataFlowAutoRefreshWithOptions(request: ApplyDataFlowAutoRefreshRequest, runtime: $RuntimeOptions): ApplyDataFlowAutoRefreshResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoRefreshInterval)) {
    query['AutoRefreshInterval'] = request.autoRefreshInterval;
  }
  if (!$isNull(request.autoRefreshPolicy)) {
    query['AutoRefreshPolicy'] = request.autoRefreshPolicy;
  }
  if (!$isNull(request.autoRefreshs)) {
    query['AutoRefreshs'] = request.autoRefreshs;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ApplyDataFlowAutoRefresh',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Adds AutoRefresh configurations to a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can add AutoRefresh configurations only to the dataflows that are in the `Running` state.
 * *   You can add a maximum of five AutoRefresh configurations to a dataflow.
 * *   It generally takes 2 to 5 minutes to create an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/336901.html) operation to query the dataflow status.
 * *   AutoRefresh depends on the object modification events collected by EventBridge from the source OSS bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
 *     **
 *     **Note** The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
 * *   The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. When you add an AutoRefresh configuration to the prefix for a CPFS dataflow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS data flow.
 * *   After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a data flow task to load the updated data.
 * *   AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS data flow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the data flow status becomes Misconfigured. To resolve these issues, you can increase the data flow specifications or reduce the frequency of triggering the object modification event.
 *
 * @param request ApplyDataFlowAutoRefreshRequest
 * @return ApplyDataFlowAutoRefreshResponse
 */
async function applyDataFlowAutoRefresh(request: ApplyDataFlowAutoRefreshRequest): ApplyDataFlowAutoRefreshResponse {
  var runtime = new $RuntimeOptions{};
  return applyDataFlowAutoRefreshWithOptions(request, runtime);
}

model AttachVscToFilesystemsRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  resourceIds?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='bmcpfs-290t15yn4uo8lid****'),
      vscId?: string(name='VscId', description='The ID of the virtual storage channel.', example='vsc-8vb864o3ppwfvh****'),
    }
  ](name='ResourceIds', description='The ID information of the file system and virtual storage channel. Each batch can contain up to 10 IDs.

This parameter is required.'),
}

model AttachVscToFilesystemsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model AttachVscToFilesystemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AttachVscToFilesystemsResponseBody(name='body'),
}

/**
 * @summary Associates the VSC device with the file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request AttachVscToFilesystemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AttachVscToFilesystemsResponse
 */
@context("attachVscToFilesystemsWithContext")
async function attachVscToFilesystemsWithOptions(request: AttachVscToFilesystemsRequest, runtime: $RuntimeOptions): AttachVscToFilesystemsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'AttachVscToFilesystems',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Associates the VSC device with the file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request AttachVscToFilesystemsRequest
 * @return AttachVscToFilesystemsResponse
 */
async function attachVscToFilesystems(request: AttachVscToFilesystemsRequest): AttachVscToFilesystemsResponse {
  var runtime = new $RuntimeOptions{};
  return attachVscToFilesystemsWithOptions(request, runtime);
}

model CancelAutoSnapshotPolicyRequest {
  fileSystemIds?: string(name='FileSystemIds', description='The IDs of file systems.

You can specify a maximum of 100 file system IDs. If you want to remove automatic snapshot policies from multiple file systems, separate the file system IDs with commas (,).

This parameter is required.', example='extreme-233e6****,extreme-23vbp****,extreme-23vas****'),
}

model CancelAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.

Every response returns a unique request ID regardless of whether the request is successful.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DED****'),
}

model CancelAutoSnapshotPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * @summary Removes automatic snapshot policies from one or more file systems.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request CancelAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelAutoSnapshotPolicyResponse
 */
@context("cancelAutoSnapshotPolicyWithContext")
async function cancelAutoSnapshotPolicyWithOptions(request: CancelAutoSnapshotPolicyRequest, runtime: $RuntimeOptions): CancelAutoSnapshotPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemIds)) {
    query['FileSystemIds'] = request.fileSystemIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelAutoSnapshotPolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes automatic snapshot policies from one or more file systems.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request CancelAutoSnapshotPolicyRequest
 * @return CancelAutoSnapshotPolicyResponse
 */
async function cancelAutoSnapshotPolicy(request: CancelAutoSnapshotPolicyRequest): CancelAutoSnapshotPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return cancelAutoSnapshotPolicyWithOptions(request, runtime);
}

model CancelDataFlowAutoRefreshRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowld parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
  refreshPath?: string(name='RefreshPath', description='The directory for which you want to cancel AutoRefresh configurations.

Limits:

*   The directory must be 2 to 1,024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).

>  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.

This parameter is required.', example='/prefix1/prefix2/'),
}

model CancelDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CancelDataFlowAutoRefreshResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelDataFlowAutoRefreshResponseBody(name='body'),
}

/**
 * @summary Cancels the AutoRefresh configuration for a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can cancel AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
 * *   It generally takes 2 to 5 minutes to cancel the AutoRefresh configurations. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the status of the AutoRefresh tasks.
 *
 * @param request CancelDataFlowAutoRefreshRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelDataFlowAutoRefreshResponse
 */
@context("cancelDataFlowAutoRefreshWithContext")
async function cancelDataFlowAutoRefreshWithOptions(request: CancelDataFlowAutoRefreshRequest, runtime: $RuntimeOptions): CancelDataFlowAutoRefreshResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.refreshPath)) {
    query['RefreshPath'] = request.refreshPath;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelDataFlowAutoRefresh',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels the AutoRefresh configuration for a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can cancel AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
 * *   It generally takes 2 to 5 minutes to cancel the AutoRefresh configurations. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the status of the AutoRefresh tasks.
 *
 * @param request CancelDataFlowAutoRefreshRequest
 * @return CancelDataFlowAutoRefreshResponse
 */
async function cancelDataFlowAutoRefresh(request: CancelDataFlowAutoRefreshRequest): CancelDataFlowAutoRefreshResponse {
  var runtime = new $RuntimeOptions{};
  return cancelDataFlowAutoRefreshWithOptions(request, runtime);
}

model CancelDataFlowSubTaskRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the data flow.

This parameter is required.', example='df-194433a5be31****'),
  dataFlowSubTaskId?: string(name='DataFlowSubTaskId', description='The ID of the data streaming task.

This parameter is required.', example='subTaskId-370kyfmyknxcyzw****'),
  dataFlowTaskId?: string(name='DataFlowTaskId', description='The ID of the data flow task.

This parameter is required.', example='task-38aa8e890f45****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no data streaming task is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available File Storage NAS (NAS) resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a data streaming task is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='bmcpfs-370lx1ev9ss27o0****'),
}

model CancelDataFlowSubTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model CancelDataFlowSubTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelDataFlowSubTaskResponseBody(name='body'),
}

/**
 * @summary Cancels a data streaming task.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can cancel a data streaming task only when the task is in the CREATED or RUNNING state.
 * *   Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
 *
 * @param request CancelDataFlowSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelDataFlowSubTaskResponse
 */
@context("cancelDataFlowSubTaskWithContext")
async function cancelDataFlowSubTaskWithOptions(request: CancelDataFlowSubTaskRequest, runtime: $RuntimeOptions): CancelDataFlowSubTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dataFlowSubTaskId)) {
    query['DataFlowSubTaskId'] = request.dataFlowSubTaskId;
  }
  if (!$isNull(request.dataFlowTaskId)) {
    query['DataFlowTaskId'] = request.dataFlowTaskId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelDataFlowSubTask',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels a data streaming task.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can cancel a data streaming task only when the task is in the CREATED or RUNNING state.
 * *   Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
 *
 * @param request CancelDataFlowSubTaskRequest
 * @return CancelDataFlowSubTaskResponse
 */
async function cancelDataFlowSubTask(request: CancelDataFlowSubTaskRequest): CancelDataFlowSubTaskResponse {
  var runtime = new $RuntimeOptions{};
  return cancelDataFlowSubTaskWithOptions(request, runtime);
}

model CancelDataFlowTaskRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. The dry run does not cancel the specified dataflow task or incur fees.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the specified dataflow task is canceled.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='cpfs-099394bd928c****'),
  taskId?: string(name='TaskId', description='The ID of the dataflow task.

This parameter is required.', example='task-38aa8e890f45****'),
}

model CancelDataFlowTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model CancelDataFlowTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelDataFlowTaskResponseBody(name='body'),
}

/**
 * @summary Cancels a batch or streaming task that is in the Pending or Execute state.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can cancel only the data flow tasks that are in the `Pending` and `Executing` states.
 * *   It generally takes 5 to 10 minutes to cancel a data flow task. You can query the task execution status by calling the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation.
 * *   If a data streaming task contains running subtasks, you cannot cancel the streaming task. Otherwise, an InvalidStatus.ResourceMismatch error message is returned.
 *
 * @param request CancelDataFlowTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelDataFlowTaskResponse
 */
@context("cancelDataFlowTaskWithContext")
async function cancelDataFlowTaskWithOptions(request: CancelDataFlowTaskRequest, runtime: $RuntimeOptions): CancelDataFlowTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelDataFlowTask',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels a batch or streaming task that is in the Pending or Execute state.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can cancel only the data flow tasks that are in the `Pending` and `Executing` states.
 * *   It generally takes 5 to 10 minutes to cancel a data flow task. You can query the task execution status by calling the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation.
 * *   If a data streaming task contains running subtasks, you cannot cancel the streaming task. Otherwise, an InvalidStatus.ResourceMismatch error message is returned.
 *
 * @param request CancelDataFlowTaskRequest
 * @return CancelDataFlowTaskResponse
 */
async function cancelDataFlowTask(request: CancelDataFlowTaskRequest): CancelDataFlowTaskResponse {
  var runtime = new $RuntimeOptions{};
  return cancelDataFlowTaskWithOptions(request, runtime);
}

model CancelDirQuotaRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  path?: string(name='Path', description='The absolute path of a directory.

This parameter is required.', example='/data/sub1'),
  userId?: string(name='UserId', description='The UID or GID of a user for whom you want to cancel the directory quota.

This parameter is required and valid only if the UserType parameter is set to Uid or Gid.

Examples:

*   If you want to cancel a quota for a user whose UID is 500, set the UserType parameter to Uid and set the UserId parameter to 500.
*   If you want to cancel a quota for a group whose GID is 100, set the UserType parameter to Gid and set the UserId parameter to 100.', example='500'),
  userType?: string(name='UserType', description='The type of the user.

Valid values:

*   Uid: user ID
*   Gid: user group ID
*   AllUsers: all users

This parameter is required.', example='Uid'),
}

model CancelDirQuotaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5BC5CB97-9F28-42FE-84A4-0CD0DF42****'),
  success?: boolean(name='Success', description='Indicates whether the request is successful.

Valid values:

*   true
*   false', example='true'),
}

model CancelDirQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelDirQuotaResponseBody(name='body'),
}

/**
 * @summary Cancels the directory quota of a file system.
 *
 * @description Only General-purpose file systems support the directory quota feature.
 *
 * @param request CancelDirQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelDirQuotaResponse
 */
@context("cancelDirQuotaWithContext")
async function cancelDirQuotaWithOptions(request: CancelDirQuotaRequest, runtime: $RuntimeOptions): CancelDirQuotaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!$isNull(request.userType)) {
    query['UserType'] = request.userType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelDirQuota',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels the directory quota of a file system.
 *
 * @description Only General-purpose file systems support the directory quota feature.
 *
 * @param request CancelDirQuotaRequest
 * @return CancelDirQuotaResponse
 */
async function cancelDirQuota(request: CancelDirQuotaRequest): CancelDirQuotaResponse {
  var runtime = new $RuntimeOptions{};
  return cancelDirQuotaWithOptions(request, runtime);
}

model CancelFilesetQuotaRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset quota is canceled and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowld parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the fileset quota is canceled.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the CPFS for LINGJUN file system. The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  fsetId?: string(name='FsetId', description='The fileset ID.

This parameter is required.', example='fset-1902718ea0ae****'),
}

model CancelFilesetQuotaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CancelFilesetQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelFilesetQuotaResponseBody(name='body'),
}

/**
 * @summary Cancels the quota set for a fileset.
 *
 * @description Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
 *
 * @param request CancelFilesetQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelFilesetQuotaResponse
 */
@context("cancelFilesetQuotaWithContext")
async function cancelFilesetQuotaWithOptions(request: CancelFilesetQuotaRequest, runtime: $RuntimeOptions): CancelFilesetQuotaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelFilesetQuota',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels the quota set for a fileset.
 *
 * @description Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.7.0 and later support this operation.
 *
 * @param request CancelFilesetQuotaRequest
 * @return CancelFilesetQuotaResponse
 */
async function cancelFilesetQuota(request: CancelFilesetQuotaRequest): CancelFilesetQuotaResponse {
  var runtime = new $RuntimeOptions{};
  return cancelFilesetQuotaWithOptions(request, runtime);
}

model CancelLifecycleRetrieveJobRequest {
  jobId?: string(name='JobId', description='The ID of the data retrieval task.

This parameter is required.', example='lrj-nfstest-ia-160****853-hshvw'),
}

model CancelLifecycleRetrieveJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model CancelLifecycleRetrieveJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelLifecycleRetrieveJobResponseBody(name='body'),
}

/**
 * @summary Cancels a running data retrieval task.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request CancelLifecycleRetrieveJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelLifecycleRetrieveJobResponse
 */
@context("cancelLifecycleRetrieveJobWithContext")
async function cancelLifecycleRetrieveJobWithOptions(request: CancelLifecycleRetrieveJobRequest, runtime: $RuntimeOptions): CancelLifecycleRetrieveJobResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelLifecycleRetrieveJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels a running data retrieval task.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request CancelLifecycleRetrieveJobRequest
 * @return CancelLifecycleRetrieveJobResponse
 */
async function cancelLifecycleRetrieveJob(request: CancelLifecycleRetrieveJobRequest): CancelLifecycleRetrieveJobResponse {
  var runtime = new $RuntimeOptions{};
  return cancelLifecycleRetrieveJobWithOptions(request, runtime);
}

model CancelRecycleBinJobRequest {
  jobId?: string(name='JobId', description='The job ID.

This parameter is required.', example='rb-15****ed-r-1625****2441'),
}

model CancelRecycleBinJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CancelRecycleBinJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelRecycleBinJobResponseBody(name='body'),
}

/**
 * @summary Cancels a running job of the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can cancel only jobs that are in the Running state. You cannot cancel jobs that are in the PartialSuccess, Success, Fail, or Cancelled state.
 * *   If you cancel a running job that permanently deletes files, you cannot restore the files that are already permanently deleted.
 * *   If you cancel a running job that restores files, you can query the restored files from the file system, and query the unrestored files from the recycle bin.
 *
 * @param request CancelRecycleBinJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CancelRecycleBinJobResponse
 */
@context("cancelRecycleBinJobWithContext")
async function cancelRecycleBinJobWithOptions(request: CancelRecycleBinJobRequest, runtime: $RuntimeOptions): CancelRecycleBinJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CancelRecycleBinJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Cancels a running job of the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can cancel only jobs that are in the Running state. You cannot cancel jobs that are in the PartialSuccess, Success, Fail, or Cancelled state.
 * *   If you cancel a running job that permanently deletes files, you cannot restore the files that are already permanently deleted.
 * *   If you cancel a running job that restores files, you can query the restored files from the file system, and query the unrestored files from the recycle bin.
 *
 * @param request CancelRecycleBinJobRequest
 * @return CancelRecycleBinJobResponse
 */
async function cancelRecycleBinJob(request: CancelRecycleBinJobRequest): CancelRecycleBinJobResponse {
  var runtime = new $RuntimeOptions{};
  return cancelRecycleBinJobWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the new resource group.

You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.

This parameter is required.', example='rg-acfmwavnfdf****'),
  regionId?: string(name='RegionId', description='The region ID of the zone.

You can call the [DescribeRegions](https://help.aliyun.com/document_detail/2412111.html) operation to query the latest region list.', example='cn-hangzhou'),
  resourceId?: string(name='ResourceId', description='The resource ID.

This parameter is required.', example='31a8e4****'),
  resourceType?: string(name='ResourceType', description='The resource type.

Set the value to filesystem.

This parameter is required.', example='filesystem'),
}

model ChangeResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model ChangeResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeResourceGroupResponseBody(name='body'),
}

/**
 * @summary Changes the resource group to which a file system belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ChangeResourceGroupResponse
 */
@context("changeResourceGroupWithContext")
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: $RuntimeOptions): ChangeResourceGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.newResourceGroupId)) {
    query['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ChangeResourceGroup',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the resource group to which a file system belongs.
 *
 * @param request ChangeResourceGroupRequest
 * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new $RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateAccessGroupRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

Limits:

*   The name must be 3 to 64 characters in length.
*   The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).
*   The name must be different from the name of the default permission group.

The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.

This parameter is required.', example='vpc-test'),
  accessGroupType?: string(name='AccessGroupType', description='The network type of the permission group. Valid value: **Vpc**.

This parameter is required.', example='Vpc'),
  description?: string(name='Description', description='The description of the permission group.

Limits:

*   By default, the description of a permission group is the same as the name of the permission group. The description must be 2 to 128 characters in length.
*   The name must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain digits, colons (:), underscores (_), and hyphens (-).', example='vpctestaccessgroup'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system.
*   extreme: Extreme NAS file system.', example='standard'),
}

model CreateAccessGroupResponseBody = {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.', example='vpc-test'),
  requestId?: string(name='RequestId', description='The request ID.', example='55C5FFD6-BF99-41BD-9C66-FFF39189F4F8'),
}

model CreateAccessGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccessGroupResponseBody(name='body'),
}

/**
 * @summary Creates a permission group.
 *
 * @param request CreateAccessGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccessGroupResponse
 */
@context("createAccessGroupWithContext")
async function createAccessGroupWithOptions(request: CreateAccessGroupRequest, runtime: $RuntimeOptions): CreateAccessGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.accessGroupType)) {
    query['AccessGroupType'] = request.accessGroupType;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAccessGroup',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a permission group.
 *
 * @param request CreateAccessGroupRequest
 * @return CreateAccessGroupResponse
 */
async function createAccessGroup(request: CreateAccessGroupRequest): CreateAccessGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createAccessGroupWithOptions(request, runtime);
}

model CreateAccessPointRequest {
  accessGroup?: string(name='AccessGroup', description='The name of the permission group.

This parameter is required for a General-purpose File Storage NAS (NAS) file system.

The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.

This parameter is required.', example='DEFAULT_VPC_GROUP_NAME'),
  accessPointName?: string(name='AccessPointName', description='The name of the access point.', example='test'),
  enabledRam?: boolean(name='EnabledRam', description='Specifies whether to enable the RAM policy. Valid values:

*   true: The RAM policy is enabled.
*   false (default): The RAM policy is disabled.

>  After the RAM policy is enabled for access points, no RAM user is allowed to use access points to mount and access data by default. To use access points to mount and access data as a RAM user, you must grant the related access permissions to the RAM user. If the RAM policy is disabled, access points can be anonymously mounted. For more information about how to configure permissions on access points, see [Configure a policy for the access point](https://help.aliyun.com/document_detail/2545998.html).', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  ownerGroupId?: int32(name='OwnerGroupId', description='The ID of the owner group.

This parameter is required if the RootDirectory directory does not exist.', example='1'),
  ownerUserId?: int32(name='OwnerUserId', description='The owner ID.

This parameter is required if the RootDirectory directory does not exist.', example='1'),
  permission?: string(name='Permission', description='The Portable Operating System Interface for UNIX (POSIX) permission. Default value: 0777.

This field takes effect only if you specify the OwnerUserId and OwnerGroupId parameters.', example='0777'),
  posixGroupId?: int32(name='PosixGroupId', description='The ID of the POSIX user group.', example='123'),
  posixSecondaryGroupIds?: string(name='PosixSecondaryGroupIds', description='The secondary user group. Separate multiple user group IDs with commas (,).', example='123,345'),
  posixUserId?: int32(name='PosixUserId', description='The ID of the POSIX user.', example='123'),
  rootDirectory?: string(name='RootDirectory', description='The root directory of the access point. The default value is /. If the directory does not exist, you must also specify the OwnerUserId and OwnerGroupId parameters.', example='/'),
  tag?: [ 
    {
      key?: string(name='Key', example='TestKey'),
      value?: string(name='Value', example='TestValue'),
    }
  ](name='Tag'),
  vpcId?: string(name='VpcId', description='The VPC ID.

This parameter is required.', example='vpc-2zesj9afh3y518k9o****'),
  vswId?: string(name='VswId', description='The vSwitch ID.

This parameter is required.', example='vsw-2zevmwkwyztjuoffg****'),
}

model CreateAccessPointResponseBody = {
  accessPoint?: {
    accessPointDomain?: string(name='AccessPointDomain', description='The domain name of the access point.', example='ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com'),
    accessPointId?: string(name='AccessPointId', description='The ID of the access point.', example='ap-ie15yd****'),
  }(name='AccessPoint', description='The access point.'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateAccessPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccessPointResponseBody(name='body'),
}

/**
 * @summary Creates an access point.
 *
 * @description *   After you call the CreateAccessPoint operation, an access point is not immediately created. Therefore, after you call the CreateAccessPoint operation successfully, call the [DescribeAccessPoints](https://help.aliyun.com/document_detail/2712239.html) or [DescribeAccessPoint](https://help.aliyun.com/document_detail/2712240.html) operation to query the status of the access point. If the status is **Active**, mount the file system. Otherwise, the file system may fail to be mounted.
 * *   Only General-purpose Network File System (NFS) file systems support access points.
 * *   If you want to call the EnabledRam operation to enable a Resource Access Management (RAM) policy, you must configure the corresponding RAM permissions. For more information, see [Manage endpoints](https://help.aliyun.com/document_detail/2545998.html).
 *
 * @param request CreateAccessPointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccessPointResponse
 */
@context("createAccessPointWithContext")
async function createAccessPointWithOptions(request: CreateAccessPointRequest, runtime: $RuntimeOptions): CreateAccessPointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroup)) {
    query['AccessGroup'] = request.accessGroup;
  }
  if (!$isNull(request.accessPointName)) {
    query['AccessPointName'] = request.accessPointName;
  }
  if (!$isNull(request.enabledRam)) {
    query['EnabledRam'] = request.enabledRam;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.ownerGroupId)) {
    query['OwnerGroupId'] = request.ownerGroupId;
  }
  if (!$isNull(request.ownerUserId)) {
    query['OwnerUserId'] = request.ownerUserId;
  }
  if (!$isNull(request.permission)) {
    query['Permission'] = request.permission;
  }
  if (!$isNull(request.posixGroupId)) {
    query['PosixGroupId'] = request.posixGroupId;
  }
  if (!$isNull(request.posixSecondaryGroupIds)) {
    query['PosixSecondaryGroupIds'] = request.posixSecondaryGroupIds;
  }
  if (!$isNull(request.posixUserId)) {
    query['PosixUserId'] = request.posixUserId;
  }
  if (!$isNull(request.rootDirectory)) {
    query['RootDirectory'] = request.rootDirectory;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!$isNull(request.vswId)) {
    query['VswId'] = request.vswId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAccessPoint',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an access point.
 *
 * @description *   After you call the CreateAccessPoint operation, an access point is not immediately created. Therefore, after you call the CreateAccessPoint operation successfully, call the [DescribeAccessPoints](https://help.aliyun.com/document_detail/2712239.html) or [DescribeAccessPoint](https://help.aliyun.com/document_detail/2712240.html) operation to query the status of the access point. If the status is **Active**, mount the file system. Otherwise, the file system may fail to be mounted.
 * *   Only General-purpose Network File System (NFS) file systems support access points.
 * *   If you want to call the EnabledRam operation to enable a Resource Access Management (RAM) policy, you must configure the corresponding RAM permissions. For more information, see [Manage endpoints](https://help.aliyun.com/document_detail/2545998.html).
 *
 * @param request CreateAccessPointRequest
 * @return CreateAccessPointResponse
 */
async function createAccessPoint(request: CreateAccessPointRequest): CreateAccessPointResponse {
  var runtime = new $RuntimeOptions{};
  return createAccessPointWithOptions(request, runtime);
}

model CreateAccessRuleRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

This parameter is required.', example='vpc-test'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system.
*   extreme: Extreme NAS file system.', example='standard'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The IPv6 address or CIDR block of the authorized object.

You must set this parameter to an IPv6 address or CIDR block.

> *   Only Extreme NAS file systems that reside in the Chinese mainland support IPv6. If you specify this parameter, you must enable IPv6 for the file system.
>*   Only permission groups that reside in virtual private clouds (VPCs) support IPv6.
>*   You cannot specify an IPv4 address and an IPv6 address at the same time.', example='2001:250:6000::***'),
  priority?: int32(name='Priority', description='The priority of the rule.

The rule with the highest priority takes effect if multiple rules are attached to the authorized object.

Valid values: 1 to 100. The value 1 indicates the highest priority.', example='1'),
  RWAccessType?: string(name='RWAccessType', description='The access permissions of the authorized object on the file system.

Valid values:

*   RDWR (default): the read and write permissions.
*   RDONLY: the read-only permissions.', example='RDWR'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The IP address or CIDR block of the authorized object.

You must set this parameter to an IP address or CIDR block.

> If the permission group resides in the classic network, you must set this parameter to an IP address.', example='192.0.2.0/16'),
  userAccessType?: string(name='UserAccessType', description='The access permissions for different types of users in the authorized object.

Valid values:

*   no_squash (default): grants root users the permissions to access the file system.
*   root_squash: grants root users the least permissions as the nobody user.
*   all_squash: grants all users the least permissions as the nobody user.

The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.', example='no_squash'),
}

model CreateAccessRuleResponseBody = {
  accessRuleId?: string(name='AccessRuleId', description='The rule ID.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='A323836B-5BC6-45A6-8048-60675C23****'),
}

model CreateAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccessRuleResponseBody(name='body'),
}

/**
 * @summary Creates a rule for a permission group.
 *
 * @param request CreateAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccessRuleResponse
 */
@context("createAccessRuleWithContext")
async function createAccessRuleWithOptions(request: CreateAccessRuleRequest, runtime: $RuntimeOptions): CreateAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.ipv6SourceCidrIp)) {
    query['Ipv6SourceCidrIp'] = request.ipv6SourceCidrIp;
  }
  if (!$isNull(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!$isNull(request.RWAccessType)) {
    query['RWAccessType'] = request.RWAccessType;
  }
  if (!$isNull(request.sourceCidrIp)) {
    query['SourceCidrIp'] = request.sourceCidrIp;
  }
  if (!$isNull(request.userAccessType)) {
    query['UserAccessType'] = request.userAccessType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAccessRule',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a rule for a permission group.
 *
 * @param request CreateAccessRuleRequest
 * @return CreateAccessRuleResponse
 */
async function createAccessRule(request: CreateAccessRuleRequest): CreateAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return createAccessRuleWithOptions(request, runtime);
}

model CreateAutoSnapshotPolicyRequest {
  autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', description='The name of the automatic snapshot policy.

Limits:

*   The name must be 2 to 128 characters in length.
*   The name must start with a letter.
*   The name can contain digits, colons (:), underscores (_), and hyphens (-). It cannot start with `http://` or `https://`.
*   This parameter is empty by default.', example='FinanceJoshua'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid value: extreme, which indicates Extreme NAS file systems.

This parameter is required.', example='extreme'),
  repeatWeekdays?: string(name='RepeatWeekdays', description='The days of a week on which to create automatic snapshots.

Cycle: week.

Valid values: 1 to 7. The values from 1 to 7 indicate the seven days in a week from Monday to Sunday.

If you want to create multiple auto snapshots within a week, you can specify multiple days from Monday to Sunday and separate the days with commas (,). You can specify a maximum of seven days.

This parameter is required.', example='1,2,3'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of auto snapshots.

Unit: days.

Valid values:

*   \\\\-1 (default). Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
*   1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.', example='30'),
  timePoints?: string(name='TimePoints', description='The points in time at which auto snapshots were created.

Unit: hours.

Valid values: 0 to 23. The values from 0 to 23 indicate a total of 24 hours from 00:00 to 23:00. For example, the value 1 indicates 01:00.

If you want to create multiple auto snapshots within a day, you can specify multiple points in time and separate the points in time with commas (,). You can specify a maximum of 24 points in time.

This parameter is required.', example='0,1,23'),
}

model CreateAutoSnapshotPolicyResponseBody = {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', example='sp-extreme-233e6****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model CreateAutoSnapshotPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * @summary Creates an automatic snapshot policy.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   You can create a maximum of 100 automatic snapshot policies in each region for an Alibaba Cloud account.
 * *   If an auto snapshot is being created when the scheduled time for a new auto snapshot arrives, the creation of the new snapshot is skipped. This occurs if the file system stores a large volume of data. For example, you have scheduled auto snapshots to be created at 09:00:00, 10:00:00, 11:00:00, and 12:00:00 for a file system. The system starts to create an auto snapshot at 09:00:00 and does not complete the process until 10:20:00. The process takes 80 minutes because the file system has a large volume of data. In this case, the system does not create an auto snapshot at 10:00:00, but creates an auto snapshot at 11:00:00.
 * *   A maximum of 128 auto snapshots can be created for a file system. If the upper limit is reached, the earliest auto snapshot is deleted. This rule does not apply to manual snapshots.
 * *   If you modify the retention period of an automatic snapshot policy, the modification applies only to subsequent snapshots, but not to the existing snapshots.
 * *   If an auto snapshot is being created for a file system, you cannot create a manual snapshot for the file system. You must wait after the auto snapshot is created.
 * *   You can only apply automatic snapshot policies to a file system that is in the Running state.
 * *   All auto snapshots are named in the `auto_yyyyMMdd_X` format, where: `auto` indicates that the snapshot is created based on an automatic snapshot policy. `yyyyMMdd` indicates the date on which the snapshot is created. `y` indicates the year. `M` indicates the month. `d` indicates the day. `X` indicates the ordinal number of the snapshot on the current day. For example, `auto_20201018_1` indicates the first auto snapshot that was created on October 18, 2020.
 * *   After an automatic snapshot policy is created, you can call the ApplyAutoSnapshotPolicy operation to apply the policy to a file system and call the ModifyAutoSnapshotPolicy operation to modify the policy.
 *
 * @param request CreateAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAutoSnapshotPolicyResponse
 */
@context("createAutoSnapshotPolicyWithContext")
async function createAutoSnapshotPolicyWithOptions(request: CreateAutoSnapshotPolicyRequest, runtime: $RuntimeOptions): CreateAutoSnapshotPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyName)) {
    query['AutoSnapshotPolicyName'] = request.autoSnapshotPolicyName;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.repeatWeekdays)) {
    query['RepeatWeekdays'] = request.repeatWeekdays;
  }
  if (!$isNull(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!$isNull(request.timePoints)) {
    query['TimePoints'] = request.timePoints;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAutoSnapshotPolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an automatic snapshot policy.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   You can create a maximum of 100 automatic snapshot policies in each region for an Alibaba Cloud account.
 * *   If an auto snapshot is being created when the scheduled time for a new auto snapshot arrives, the creation of the new snapshot is skipped. This occurs if the file system stores a large volume of data. For example, you have scheduled auto snapshots to be created at 09:00:00, 10:00:00, 11:00:00, and 12:00:00 for a file system. The system starts to create an auto snapshot at 09:00:00 and does not complete the process until 10:20:00. The process takes 80 minutes because the file system has a large volume of data. In this case, the system does not create an auto snapshot at 10:00:00, but creates an auto snapshot at 11:00:00.
 * *   A maximum of 128 auto snapshots can be created for a file system. If the upper limit is reached, the earliest auto snapshot is deleted. This rule does not apply to manual snapshots.
 * *   If you modify the retention period of an automatic snapshot policy, the modification applies only to subsequent snapshots, but not to the existing snapshots.
 * *   If an auto snapshot is being created for a file system, you cannot create a manual snapshot for the file system. You must wait after the auto snapshot is created.
 * *   You can only apply automatic snapshot policies to a file system that is in the Running state.
 * *   All auto snapshots are named in the `auto_yyyyMMdd_X` format, where: `auto` indicates that the snapshot is created based on an automatic snapshot policy. `yyyyMMdd` indicates the date on which the snapshot is created. `y` indicates the year. `M` indicates the month. `d` indicates the day. `X` indicates the ordinal number of the snapshot on the current day. For example, `auto_20201018_1` indicates the first auto snapshot that was created on October 18, 2020.
 * *   After an automatic snapshot policy is created, you can call the ApplyAutoSnapshotPolicy operation to apply the policy to a file system and call the ModifyAutoSnapshotPolicy operation to modify the policy.
 *
 * @param request CreateAutoSnapshotPolicyRequest
 * @return CreateAutoSnapshotPolicyResponse
 */
async function createAutoSnapshotPolicy(request: CreateAutoSnapshotPolicyRequest): CreateAutoSnapshotPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return createAutoSnapshotPolicyWithOptions(request, runtime);
}

model CreateDataFlowRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', description='The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minutes.

Valid values: 10 to 525600. Default value: 10.

>  This parameter takes effect only for CPFS file systems.', example='10'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', description='The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy.

*   None (default): Updated data in the source storage is not automatically imported into the CPFS file system. You can run a data flow task to import the updated data from the source storage.
*   ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.

>  This parameter takes effect only for CPFS file systems.', example='None'),
  autoRefreshs?: [ 
    {
      refreshPath?: string(name='RefreshPath', description='The automatic update directory. CPFS registers the data update event in the source storage, and automatically checks whether the source data in the directory is updated and imports the updated data.

This parameter is empty by default. Updated data in the source storage is not automatically imported into the CPFS file system. You must import the updated data by running a manual task.

Limits:

*   The directory must be 2 to 1,024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).
*   The directory must be an existing directory in the CPFS file system and must be in a fileset where the data flow is enabled.', example='/prefix1/prefix2/', nullable=true),
    }
  ](name='AutoRefreshs', description='The automatic update configurations.

>  This parameter takes effect only for CPFS file systems.', nullable=false),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.', example='123e4567-e89b-12d3-a456-42665544****'),
  description?: string(name='Description', description='The description of the dataflow.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter but cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='Bucket01 DataFlow'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='cpfs-099394bd928c****'),
  fileSystemPath?: string(name='FileSystemPath', description='The directory in the CPFS for LINGJUN file system. Limits:

*   The directory must start and end with a forward slash (/).
*   The directory must be an existing directory in the CPFS for LINGJUN file system.
*   The directory must be 1 to 1023 characters in length.
*   The directory must be encoded in UTF-8.

>  This parameter is required for CPFS for LINGJUN file systems.', example='/path/'),
  fsetId?: string(name='FsetId', description='The fileset ID.

>  This parameter is required for CPFS file systems.', example='fset-1902718ea0ae****'),
  sourceSecurityType?: string(name='SourceSecurityType', description='The type of security mechanism for the source storage. This parameter must be specified if the source storage is accessed with a security mechanism. Valid values:

*   None (default): The source storage can be accessed without a security mechanism.
*   SSL: The source storage must be accessed with an SSL certificate.', example='SSL', nullable=false),
  sourceStorage?: string(name='SourceStorage', description='The access path of the source storage. Format: `<storage type>://[<account id>:]<path>`.

Parameters:

*   storage type: Only OSS is supported.

*   account id (optional): the UID of the account of the source storage. This parameter is required when you use OSS buckets across accounts.

*   path: the name of the OSS bucket. Limits:

    *   The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
    *   The name can be up to 128 characters in length.
    *   The name must be encoded in UTF-8.

> *   The OSS bucket must be an existing bucket in the region.
> *   Only CPFS for LINGJUN V2.6.0 and later support the account id parameter.

This parameter is required.', example='oss://bucket1'),
  sourceStoragePath?: string(name='SourceStoragePath', description='The access path in the bucket of the source storage. Limits:

*   The path must start and end with a forward slash (/).
*   The path is case-sensitive.
*   The path must be 1 to 1023 characters in length.
*   The path must be encoded in UTF-8.

>  This parameter is required for CPFS for LINGJUN file systems.', example='/prefix/'),
  throughput?: long(name='Throughput', description='The maximum data flow throughput. Unit: MB/s. Valid values:

*   600
*   1200
*   1500

>  The data flow throughput must be less than the I/O throughput of the file system. This parameter is required for CPFS file systems.', example='600'),
}

model CreateDataFlowResponseBody = {
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.', example='df-194433a5be31****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0D****3E'),
}

model CreateDataFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataFlowResponseBody(name='body'),
}

/**
 * @summary Creates a dataflow for a Cloud Parallel File Storage (CPFS) file system and source storage.
 *
 * @description *   Basic operations
 *     *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows.
 *     *   You can create a data flow only when a CPFS or CPFS for Lingjun file system is in the Running state.
 *     *   A maximum of 10 data flows can be created for a CPFS or CPFS for Lingjun file system.
 *     *   It generally takes 2 to 5 minutes to create a data flow. You can call the DescribeDataFlows operation to check whether the data flow has been created.
 * *   Permission
 *     When you create a data flow, CPFS obtains the following two service-linked roles: `AliyunServiceRoleForNasOssDataflow` and `AliyunServiceRoleForNasEventNotification`. For more information, see [CPFS service-linked roles](https://help.aliyun.com/document_detail/185138.html).
 * *   CPFS usage notes
 *     *   Billing
 *         *   If you create a data flow, you are charged for using the data flow throughput. For more information, see [Billing of CPFS](https://help.aliyun.com/document_detail/111858.html).
 *         *   When you configure the AutoRefresh feature for a data flow, CPFS must use EventBridge to collect object modification events from the source Object Storage Service (OSS) bucket. Event fees are incurred. For more information, see [Billing of EventBridge](https://help.aliyun.com/document_detail/163752.html).
 *     *   Data flow specifications
 *         *   The data flow throughput supports the following specifications: 600 MB/s, 1,200 MB/s, and 1,500 MB/s. The data flow throughput is the maximum transmission bandwidth that can be reached when data is imported or exported for a data flow.
 *         *   When you create a data flow, the vSwitch IP addresses used by a CPFS mount target are consumed. Make sure that the vSwitch can provide sufficient IP addresses.
 *         *   Inventory query: If you set the DryRun parameter to true, you can check whether the resources for the data flow whose throughput is changed meet the requirements.
 *     *   Fileset
 *         *   The destination for a data flow is a fileset in the CPFS file system. A fileset is a new directory tree structure (a small file directory) in a CPFS file system. Each fileset independently manages an inode space.
 *         *   When you create a data flow for a CPFS file system, the related fileset must already exist and cannot be nested with other filesets. Only one data flow can be created in a fileset, which corresponds to one source storage.
 *         *   A fileset supports a maximum of one million files. If the number of files imported from an OSS bucket into the fileset exceeds the upper limit, the `no space` error message is returned when you add new files.
 *     **
 *     **Note **If data already exists in the fileset, after you create a data flow, the existing data in the fileset is cleared and replaced with the data synchronized from the OSS bucket.
 *     *   AutoRefresh
 *         *   After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a data flow task to load the updated data.
 *         *   AutoRefresh depends on the object modification events collected by EventBridge from the source OSS bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
 *         *   The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. You can configure a maximum of five AutoRefresh directories for a data flow.
 *         *   AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS data flow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the data flow status becomes `Misconfigured`. To resolve these issues, you can increase the data flow specifications or reduce the frequency of triggering the object modification event.
 *         *   When you add an AutoRefresh configuration to the prefix for a CPFS data flow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS data flow.
 *         **
 *         **Note **The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
 *     *   Source storage
 *         *   The source storage is an OSS bucket. SourceStorage for a data flow must be an OSS bucket.
 *         *   CPFS data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
 *         *   If data flows for multiple CPFS file systems or multiple data flows for the same CPFS file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS file systems to one OSS bucket.
 *         *   Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
 *         **
 *         **Note **Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS cannot access the data in the OSS bucket.
 * *   CPFS for Lingjun usage notes
 *     *   Source storage
 *         *   The source storage is an OSS bucket. SourceStorage for a data flow must be an OSS bucket.
 *         *   CPFS for Lingjun data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
 *         *   If data flows for multiple CPFS for Lingjun file systems or multiple data flows for the same CPFS for Lingjun file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS for Lingjun file systems to one OSS bucket.
 *         *   Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
 *         *   CPFS for Lingjun V2.6.0 and later allow you to create data flows for OSS buckets across accounts.
 *         *   The account id parameter is required only when you use OSS buckets across accounts.
 *         *   To use OSS buckets across accounts, you must first grant permissions to the related accounts. For more information, see [Cross-account authorization on data flows](https://help.aliyun.com/document_detail/2713462.html).
 *             **
 *             **Note **Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS for Lingjun cannot access the data in the OSS bucket.
 *     *   Limits of data flows on file systems
 *         *   You cannot rename a non-empty directory in a path that is associated with a data flow. Otherwise, the Permission Denied error message or an error message indicating that the directory is not empty is returned.
 *         *   Proceed with caution when you use special characters in the names of directories and files. The following characters are supported: letters, digits, exclamation points (!), hyphens (-), underscores (_), periods (.), asterisks (\\*), and parentheses (()).
 *         *   The path can be up to 1,023 characters in length.
 *     *   Limits of data flows on import
 *         *   After a symbolic link is imported to CPFS for Lingjun, the symbolic link is converted into a common data file that contains no symbolic link information.
 *         *   If an OSS bucket has multiple versions, only data of the latest version is used.
 *         *   The name of a file or a subdirectory can be up to 255 bytes in length.
 *     *   Limits of data flows on export
 *         *   After a symbolic link is synchronized to OSS, the file that the symbolic link points to is not synchronized to OSS. In this case, the symbolic link is converted into a common object that contains no data.
 *         *   Hard links can be synchronized to OSS only as common files that contain no link information.
 *         *   After a file of the Socket, Device, or Pipe type is exported to an OSS bucket, the file is converted into a common object that contains no data.
 *         *   The directory path can be up to 1,023 characters in length.
 *
 * @param request CreateDataFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataFlowResponse
 */
@context("createDataFlowWithContext")
async function createDataFlowWithOptions(request: CreateDataFlowRequest, runtime: $RuntimeOptions): CreateDataFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoRefreshInterval)) {
    query['AutoRefreshInterval'] = request.autoRefreshInterval;
  }
  if (!$isNull(request.autoRefreshPolicy)) {
    query['AutoRefreshPolicy'] = request.autoRefreshPolicy;
  }
  if (!$isNull(request.autoRefreshs)) {
    query['AutoRefreshs'] = request.autoRefreshs;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fileSystemPath)) {
    query['FileSystemPath'] = request.fileSystemPath;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  if (!$isNull(request.sourceSecurityType)) {
    query['SourceSecurityType'] = request.sourceSecurityType;
  }
  if (!$isNull(request.sourceStorage)) {
    query['SourceStorage'] = request.sourceStorage;
  }
  if (!$isNull(request.sourceStoragePath)) {
    query['SourceStoragePath'] = request.sourceStoragePath;
  }
  if (!$isNull(request.throughput)) {
    query['Throughput'] = request.throughput;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDataFlow',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a dataflow for a Cloud Parallel File Storage (CPFS) file system and source storage.
 *
 * @description *   Basic operations
 *     *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows.
 *     *   You can create a data flow only when a CPFS or CPFS for Lingjun file system is in the Running state.
 *     *   A maximum of 10 data flows can be created for a CPFS or CPFS for Lingjun file system.
 *     *   It generally takes 2 to 5 minutes to create a data flow. You can call the DescribeDataFlows operation to check whether the data flow has been created.
 * *   Permission
 *     When you create a data flow, CPFS obtains the following two service-linked roles: `AliyunServiceRoleForNasOssDataflow` and `AliyunServiceRoleForNasEventNotification`. For more information, see [CPFS service-linked roles](https://help.aliyun.com/document_detail/185138.html).
 * *   CPFS usage notes
 *     *   Billing
 *         *   If you create a data flow, you are charged for using the data flow throughput. For more information, see [Billing of CPFS](https://help.aliyun.com/document_detail/111858.html).
 *         *   When you configure the AutoRefresh feature for a data flow, CPFS must use EventBridge to collect object modification events from the source Object Storage Service (OSS) bucket. Event fees are incurred. For more information, see [Billing of EventBridge](https://help.aliyun.com/document_detail/163752.html).
 *     *   Data flow specifications
 *         *   The data flow throughput supports the following specifications: 600 MB/s, 1,200 MB/s, and 1,500 MB/s. The data flow throughput is the maximum transmission bandwidth that can be reached when data is imported or exported for a data flow.
 *         *   When you create a data flow, the vSwitch IP addresses used by a CPFS mount target are consumed. Make sure that the vSwitch can provide sufficient IP addresses.
 *         *   Inventory query: If you set the DryRun parameter to true, you can check whether the resources for the data flow whose throughput is changed meet the requirements.
 *     *   Fileset
 *         *   The destination for a data flow is a fileset in the CPFS file system. A fileset is a new directory tree structure (a small file directory) in a CPFS file system. Each fileset independently manages an inode space.
 *         *   When you create a data flow for a CPFS file system, the related fileset must already exist and cannot be nested with other filesets. Only one data flow can be created in a fileset, which corresponds to one source storage.
 *         *   A fileset supports a maximum of one million files. If the number of files imported from an OSS bucket into the fileset exceeds the upper limit, the `no space` error message is returned when you add new files.
 *     **
 *     **Note **If data already exists in the fileset, after you create a data flow, the existing data in the fileset is cleared and replaced with the data synchronized from the OSS bucket.
 *     *   AutoRefresh
 *         *   After AutoRefresh is configured, if the data in the source OSS bucket is updated, the updated metadata is automatically synchronized to the CPFS file system. You can load the updated data when you access files, or run a data flow task to load the updated data.
 *         *   AutoRefresh depends on the object modification events collected by EventBridge from the source OSS bucket. You must first [activate EventBridge](https://help.aliyun.com/document_detail/182246.html).
 *         *   The AutoRefresh configuration applies only to the prefix and is specified by the RefreshPath parameter. You can configure a maximum of five AutoRefresh directories for a data flow.
 *         *   AutoRefreshInterval refers to the interval at which CPFS checks whether data is updated in the prefix of the source OSS bucket. If data is updated, CPFS runs an AutoRefresh task. If the frequency of triggering the object modification event in the source OSS bucket exceeds the processing capability of the CPFS data flow, AutoRefresh tasks are accumulated, metadata updates are delayed, and the data flow status becomes `Misconfigured`. To resolve these issues, you can increase the data flow specifications or reduce the frequency of triggering the object modification event.
 *         *   When you add an AutoRefresh configuration to the prefix for a CPFS data flow, an event bus is created at the user side and an event rule is created for the prefix of the source OSS bucket. When an object is modified in the prefix of the source OSS bucket, an OSS event is generated in the EventBridge console. The event is processed by the CPFS data flow.
 *         **
 *         **Note **The event buses and event rules created for CPFS in the EventBridge console contain the `Create for cpfs auto refresh` description. The event buses and event rules cannot be modified or deleted. Otherwise, AutoRefresh cannot work properly.
 *     *   Source storage
 *         *   The source storage is an OSS bucket. SourceStorage for a data flow must be an OSS bucket.
 *         *   CPFS data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
 *         *   If data flows for multiple CPFS file systems or multiple data flows for the same CPFS file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS file systems to one OSS bucket.
 *         *   Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
 *         **
 *         **Note **Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS cannot access the data in the OSS bucket.
 * *   CPFS for Lingjun usage notes
 *     *   Source storage
 *         *   The source storage is an OSS bucket. SourceStorage for a data flow must be an OSS bucket.
 *         *   CPFS for Lingjun data flows support both encrypted and unencrypted access to OSS. If you select SSL-encrypted access to OSS, make sure that encryption in transit for OSS buckets supports encrypted access.
 *         *   If data flows for multiple CPFS for Lingjun file systems or multiple data flows for the same CPFS for Lingjun file system are stored in the same OSS bucket, you must enable versioning for the OSS bucket to prevent data conflicts caused by data export from multiple CPFS for Lingjun file systems to one OSS bucket.
 *         *   Data flows are not supported for OSS buckets across regions. The OSS bucket must reside in the same region as the CPFS file system.
 *         *   CPFS for Lingjun V2.6.0 and later allow you to create data flows for OSS buckets across accounts.
 *         *   The account id parameter is required only when you use OSS buckets across accounts.
 *         *   To use OSS buckets across accounts, you must first grant permissions to the related accounts. For more information, see [Cross-account authorization on data flows](https://help.aliyun.com/document_detail/2713462.html).
 *             **
 *             **Note **Before you create a data flow, you must configure a tag (key: cpfs-dataflow, value: true) for the source OSS bucket. This way, the created data flow can access the data in the OSS bucket. When a data flow is being used, do not delete or modify the tag. Otherwise, the data flow for CPFS for Lingjun cannot access the data in the OSS bucket.
 *     *   Limits of data flows on file systems
 *         *   You cannot rename a non-empty directory in a path that is associated with a data flow. Otherwise, the Permission Denied error message or an error message indicating that the directory is not empty is returned.
 *         *   Proceed with caution when you use special characters in the names of directories and files. The following characters are supported: letters, digits, exclamation points (!), hyphens (-), underscores (_), periods (.), asterisks (\\*), and parentheses (()).
 *         *   The path can be up to 1,023 characters in length.
 *     *   Limits of data flows on import
 *         *   After a symbolic link is imported to CPFS for Lingjun, the symbolic link is converted into a common data file that contains no symbolic link information.
 *         *   If an OSS bucket has multiple versions, only data of the latest version is used.
 *         *   The name of a file or a subdirectory can be up to 255 bytes in length.
 *     *   Limits of data flows on export
 *         *   After a symbolic link is synchronized to OSS, the file that the symbolic link points to is not synchronized to OSS. In this case, the symbolic link is converted into a common object that contains no data.
 *         *   Hard links can be synchronized to OSS only as common files that contain no link information.
 *         *   After a file of the Socket, Device, or Pipe type is exported to an OSS bucket, the file is converted into a common object that contains no data.
 *         *   The directory path can be up to 1,023 characters in length.
 *
 * @param request CreateDataFlowRequest
 * @return CreateDataFlowResponse
 */
async function createDataFlow(request: CreateDataFlowRequest): CreateDataFlowResponse {
  var runtime = new $RuntimeOptions{};
  return createDataFlowWithOptions(request, runtime);
}

model CreateDataFlowSubTaskRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  condition?: {
    modifyTime?: long(name='ModifyTime', description='The modification time. The value must be a UNIX timestamp. Unit: ns.', example='1725897600000000000'),
    size?: long(name='Size', description='The file size. Unit: bytes.', example='68'),
  }(name='Condition', description='The check conditions. The check must be passed after the following conditions are specified.'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the data flow.

This parameter is required.', example='df-194433a5be31****'),
  dataFlowTaskId?: string(name='DataFlowTaskId', description='The ID of the data flow task.

>  Only the IDs of data streaming tasks are supported.

This parameter is required.', example='task-38aa8e890f45****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no data streaming subtask is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the DataFlowSubTaskId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a data streaming subtask is created.', example='false'),
  dstFilePath?: string(name='DstFilePath', description='The path of the destination file. Limits:

*   The path must be 1 to 1,023 characters in length.
*   The path must be encoded in UTF-8.
*   The path must start with a forward slash (/).
*   The path must end with the file name.

This parameter is required.', example='/mnt/file.png'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='bmcpfs-370lx1ev9ss27o0****'),
  srcFilePath?: string(name='SrcFilePath', description='The path of the source file. Limits:

*   The path must be 1 to 1,023 characters in length.
*   The path must be encoded in UTF-8.
*   The path must start with a forward slash (/).
*   The path must end with the file name.

This parameter is required.', example='/test/file.png'),
}

model CreateDataFlowSubTaskResponseBody = {
  dataFlowSubTaskId?: string(name='DataFlowSubTaskId', description='The ID of the data streaming task.', example='subTaskId-370kyfmyknxcyzw****'),
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211A5C3'),
}

model CreateDataFlowSubTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataFlowSubTaskResponseBody(name='body'),
}

/**
 * @summary Creates a data streaming subtask.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can create subtasks only for a data streaming subtask in the Executing state.
 * *   Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
 * *   When the type of data flow task is streaming, the running status only indicates that a streaming import or export task can be created. It does not indicate that the import or export task is running.
 *
 * @param request CreateDataFlowSubTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataFlowSubTaskResponse
 */
@context("createDataFlowSubTaskWithContext")
async function createDataFlowSubTaskWithOptions(request: CreateDataFlowSubTaskRequest, runtime: $RuntimeOptions): CreateDataFlowSubTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dataFlowTaskId)) {
    query['DataFlowTaskId'] = request.dataFlowTaskId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.dstFilePath)) {
    query['DstFilePath'] = request.dstFilePath;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.srcFilePath)) {
    query['SrcFilePath'] = request.srcFilePath;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDataFlowSubTask',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a data streaming subtask.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   You can create subtasks only for a data streaming subtask in the Executing state.
 * *   Data streaming tasks are executed asynchronously. You can call the DescribeDataFlowSubTasks operation to query the task execution status.
 * *   When the type of data flow task is streaming, the running status only indicates that a streaming import or export task can be created. It does not indicate that the import or export task is running.
 *
 * @param request CreateDataFlowSubTaskRequest
 * @return CreateDataFlowSubTaskResponse
 */
async function createDataFlowSubTask(request: CreateDataFlowSubTaskRequest): CreateDataFlowSubTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createDataFlowSubTaskWithOptions(request, runtime);
}

model CreateDataFlowTaskRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  conflictPolicy?: string(name='ConflictPolicy', description='The conflict policy for files with the same name. Valid value:

*   SKIP_THE_FILE: skips files with the same name.
*   KEEP_LATEST: compares the update time and keeps the latest version.
*   OVERWRITE_EXISTING: forcibly overwrites the existing file.

>  This parameter is required for CPFS for Lingjun file systems.', example='SKIP_THE_FILE'),
  createDirIfNotExist?: boolean(name='CreateDirIfNotExist', description='Specifies whether to automatically create a directory if no directory exists. Valid value:

*   true: automatically creates a directory.
*   false (default): does not automatically create a directory.

> 

*   This parameter is required if the TaskAction parameter is set to Import.

*   Only CPFS for Lingjun V2.6.0 and later support this parameter.', example='false'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dataType?: string(name='DataType', description='The type of data on which operations are performed by the dataflow task.

Valid value:

*   Metadata: the metadata of a file, including the timestamp, ownership, and permission information of the file. If you select Metadata, only the metadata of the file is imported. You can only query the file. When you access the file data, the file is loaded from the source storage as required.
*   Data: the data blocks of a file.
*   MetaAndData: the metadata and data blocks of the file.', example='Metadata'),
  directory?: string(name='Directory', description='The source directory of the data.

Limits:

*   The directory must be 1 to 1,023 characters in length.
*   Must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).
*   Only one directory can be listed at a time.
*   If the TaskAction parameter is set to Export, the directory must be a relative path within the FileSystemPath.
*   If the TaskAction parameter is set to Import, the directory must be a relative path within the SourceStoragePath.
*   If the TaskAction parameter is set to StreamExport, the directory must be a relative path within the FileSystemPath.
*   If the TaskAction parameter is set to StreamImport, the directory must be a relative path within the SourceStoragePath.

>  Only CPFS for Lingjun V2.6.0 and later support StreamImport and StreamExport.', example='/path_in_cpfs/'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no dataflow task is created and no fee is incurred.

Valid value:

*   true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available Apsara File Storage NAS (NAS) resources. Otherwise, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the TaskId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a dataflow task is created.', example='false'),
  dstDirectory?: string(name='DstDirectory', description='The directory mapped to the dataflow task. Limits:

*   The directory must start and end with a forward slash (/). The directory cannot be /../.
*   The directory must be 1 to 1,023 characters in length.
*   Must be encoded in UTF-8.
*   Only one directory can be listed at a time.
*   If the TaskAction parameter is set to Export, the directory must be a relative path within the SourceStoragePath.
*   If the TaskAction parameter is set to Import, the directory must be a relative path within the FileSystemPath.
*   If the TaskAction parameter is set to StreamExport, the directory must be a relative path within the SourceStoragePath.
*   If the TaskAction parameter is set to StreamImport, the directory must be a relative path within the FileSystemPath.

>  Only CPFS for Lingjun V2.6.0 and later support StreamImport and StreamExport.', example='/path_in_cpfs/'),
  entryList?: string(name='EntryList', description='The list of files that are executed by the dataflow task.

Limits:

*   The list must be encoded in UTF-8.
*   The total length of the file list cannot exceed 64 KB.
*   The file list is in JSON format.
*   The path of a single file must be 1 to 1,023 characters in length and must start with a forward slash (/).
*   If the TaskAction parameter is set to Import, each element in the list represents an OSS object name.
*   If the TaskAction parameter is set to Export, each element in the list represents a CPFS file path.', example='["/path_in_cpfs/file1", "/path_in_cpfs/file2"]'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  includes?: string(name='Includes', description='Filters subdirectories and transfers their contents.

> 

*   This parameter takes effect only when the Directory parameter is specified.

*   The path length of a single folder must be 1 to 1023 characters, start and end with a forward slash (/), and the total length must not exceed 3000 characters.

*   Only CPFS for Lingjun supports this parameter.', example='["/test/","/test1/"]'),
  srcTaskId?: string(name='SrcTaskId', description='If you specify SrcTaskId, you must enter the ID of the dataflow task. The system copies the TaskAction, DataType, and EntryList parameters from the destination dataflow task. You do not need to specify them.

>  Streaming dataflow tasks are not supported.', example='task-27aa8e890f45****'),
  taskAction?: string(name='TaskAction', description='Select the type of the dataflow task.

Valid value:

*   Import: imports data stored in the source storage to a CPFS file system.
*   Export: exports specified data from a CPFS file system to the source storage.
*   StreamImport: batch imports the specified data from the source storage to a CPFS file system.
*   StreamExport: batch exports specified data from a CPFS file system to the source storage.
*   Evict: releases the data blocks of a file in a CPFS file system. After the eviction, only the metadata of the file is retained in the CPFS file system. You can still query the file. However, the data blocks of the file are cleared and do not occupy the storage space in the CPFS file system. When you access the file data, the file is loaded from the source storage as required.
*   Inventory: obtains the inventory list managed by a dataflow from the CPFS file system, providing the cache status of inventories in the dataflow.

>  CPFS for Lingjun supports only Import, Export, StreamImport, and StreamExport. Only CPFS for Lingjun V2.6.0 and later support StreamImport and StreamExport.', example='Import'),
  transferFileListPath?: string(name='TransferFileListPath', description='Specify the OSS directory and synchronize data based on the content of the CSV file in the OSS directory. Requirements:

*   Must start and end with a forward slash (/).
*   Case-sensitive.
*   Must be 1 to 1023 characters in length.
*   Must be encoded in UTF-8.

> 

*   TransferFileListPath,Directory, and EntryList are mutually exclusive, and only one of the three can be selected.

*   This parameter is the actual path that exists in OSS. The \\\\*.csv file in the path is stored in OSS.

*   TransferFileListPath only supports Import and Export functions.

*   In the import scenario, the file or directory specified in the CSV file is imported from OSS to CPFS.

*   In the export scenario, the file or directory specified in the CSV file is exported from CPFS to OSS.

*   The CSV file format should include the columns Name and Type. Name refers to the relative path, while Type supports two values: dir and file. If Type is dir, the Name must end with a "/".

*   Only CPFS for Lingjun supports this operation.', example='/test_oss_path/'),
}

model CreateDataFlowTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
  taskId?: string(name='TaskId', description='The ID of the dataflow task.', example='task-38aa8e890f45****'),
}

model CreateDataFlowTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDataFlowTaskResponseBody(name='body'),
}

/**
 * @summary Creates a dataflow task.
 *
 * @description *   CPFS usage notes
 *     *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 *     *   Dataflow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
 *     *   You can create a dataflow task only for a dataflow that is in the Running state.
 *     *   When you manually run a dataflow task, the automatic data update task for the dataflow is interrupted and enters the pending state.
 *     *   When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS file system does not exceed 1,023 characters.
 * *   CPFS for Lingjun usage notes
 *     *   Only CPFS for Lingjun V2.4.0 and later support dataflow. You can view the version information on the file system details page in the console.
 *     *   Dataflow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
 *     *   You can create a dataflow task only for a dataflow that is in the Running state.
 *     *   When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS for Lingjun file system does not exceed 1,023 characters.
 *     *   CPFS for Lingjun supports two types of tasks: batch tasks and streaming tasks. For more information, see [Task types](https://help.aliyun.com/document_detail/2845429.html).
 *
 * @param request CreateDataFlowTaskRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDataFlowTaskResponse
 */
@context("createDataFlowTaskWithContext")
async function createDataFlowTaskWithOptions(request: CreateDataFlowTaskRequest, runtime: $RuntimeOptions): CreateDataFlowTaskResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.conflictPolicy)) {
    query['ConflictPolicy'] = request.conflictPolicy;
  }
  if (!$isNull(request.createDirIfNotExist)) {
    query['CreateDirIfNotExist'] = request.createDirIfNotExist;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dataType)) {
    query['DataType'] = request.dataType;
  }
  if (!$isNull(request.directory)) {
    query['Directory'] = request.directory;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.dstDirectory)) {
    query['DstDirectory'] = request.dstDirectory;
  }
  if (!$isNull(request.entryList)) {
    query['EntryList'] = request.entryList;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.includes)) {
    query['Includes'] = request.includes;
  }
  if (!$isNull(request.srcTaskId)) {
    query['SrcTaskId'] = request.srcTaskId;
  }
  if (!$isNull(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  if (!$isNull(request.transferFileListPath)) {
    query['TransferFileListPath'] = request.transferFileListPath;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDataFlowTask',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a dataflow task.
 *
 * @description *   CPFS usage notes
 *     *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 *     *   Dataflow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
 *     *   You can create a dataflow task only for a dataflow that is in the Running state.
 *     *   When you manually run a dataflow task, the automatic data update task for the dataflow is interrupted and enters the pending state.
 *     *   When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS file system does not exceed 1,023 characters.
 * *   CPFS for Lingjun usage notes
 *     *   Only CPFS for Lingjun V2.4.0 and later support dataflow. You can view the version information on the file system details page in the console.
 *     *   Dataflow tasks are executed asynchronously. You can call the [DescribeDataFlowTasks](https://help.aliyun.com/document_detail/2402275.html) operation to query the task execution status. The task duration depends on the amount of data to be imported and exported. If a large amount of data exists, we recommend that you create multiple tasks.
 *     *   You can create a dataflow task only for a dataflow that is in the Running state.
 *     *   When you create an export task, make sure that the total length of the absolute path of the files to be exported from a CPFS for Lingjun file system does not exceed 1,023 characters.
 *     *   CPFS for Lingjun supports two types of tasks: batch tasks and streaming tasks. For more information, see [Task types](https://help.aliyun.com/document_detail/2845429.html).
 *
 * @param request CreateDataFlowTaskRequest
 * @return CreateDataFlowTaskResponse
 */
async function createDataFlowTask(request: CreateDataFlowTaskRequest): CreateDataFlowTaskResponse {
  var runtime = new $RuntimeOptions{};
  return createDataFlowTaskWithOptions(request, runtime);
}

model CreateDirRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  ownerGroupId?: int32(name='OwnerGroupId', description='The ID of the owner group for the directory. Valid values: 0 to 4294967295.

This parameter is required.', example='123'),
  ownerUserId?: int32(name='OwnerUserId', description='The owner ID for the directory. Valid values: 0 to 4294967295.

This parameter is required.', example='1'),
  permission?: string(name='Permission', description='The Portable Operating System Interface (POSIX) permissions applied to the root directory. The value is a valid octal number, such as 0755.

This parameter is required.', example='0755'),
  recursion?: boolean(name='Recursion', description='Specifies whether to create a multi-level directory. Valid values:

*   true (default): If no multi-level directory exists, directories are created level by level.
*   false: Only the last level of directory is created. An error message is returned because the parent directory does not exist.', example='true'),
  rootDirectory?: string(name='RootDirectory', description='The directory name.

*   The directory must start with a forward slash (/).
*   The directory can contain digits and letters.
*   The directory can contain underscores (_), hyphens (-), and periods (.).
*   The directory cannot contain symbolic links, such as the current directory (.), the upper-level directory (..), and other symbolic links.

> *   If the root directory does not exist, configure the information for directory creation. The system then automatically creates the specified root directory based on your settings.
> *  If the root directory exists, you do not need to configure the information for directory creation. The configurations for directory creation are ignored even if you configure the information.

This parameter is required.', example='test'),
}

model CreateDirResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model CreateDirResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDirResponseBody(name='body'),
}

/**
 * @summary Creates a directory in a file system.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request CreateDirRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDirResponse
 */
@context("createDirWithContext")
async function createDirWithOptions(request: CreateDirRequest, runtime: $RuntimeOptions): CreateDirResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.ownerGroupId)) {
    query['OwnerGroupId'] = request.ownerGroupId;
  }
  if (!$isNull(request.ownerUserId)) {
    query['OwnerUserId'] = request.ownerUserId;
  }
  if (!$isNull(request.permission)) {
    query['Permission'] = request.permission;
  }
  if (!$isNull(request.recursion)) {
    query['Recursion'] = request.recursion;
  }
  if (!$isNull(request.rootDirectory)) {
    query['RootDirectory'] = request.rootDirectory;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateDir',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a directory in a file system.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request CreateDirRequest
 * @return CreateDirResponse
 */
async function createDir(request: CreateDirRequest): CreateDirResponse {
  var runtime = new $RuntimeOptions{};
  return createDirWithOptions(request, runtime);
}

model CreateFileRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  owner?: string(name='Owner', description='The ID of the portable account. The ID must be a 16-digit string. The string can contain digits and lowercase letters.', example='378cc7630f26****'),
  ownerAccessInheritable?: boolean(name='OwnerAccessInheritable', description='Specifies whether to share the directory. Valid values:

*   false (default): does not share the directory.
*   true: shares the directory.

> *   This parameter takes effect only if the Type parameter is set to Directory and the Owner parameter is not empty.
> *   The permissions on a directory can be inherited by the owner. The owner has read and write permissions on the subdirectories and subfiles created in the directory, even if they are created by others.', example='false'),
  path?: string(name='Path', description='The absolute path of the directory or file. The path must start and end with a forward slash (/) and must be 2 to 1024 characters in length.

This parameter is required.', example='/test/'),
  type?: string(name='Type', description='The type of the object. Valid values:

*   File
*   Directory

This parameter is required.', example='File'),
}

model CreateFileResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model CreateFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileResponseBody(name='body'),
}

/**
 * @summary Creates a directory or file.
 *
 * @description *   This operation is only available to some users.
 * *   This operation supports only General-purpose NAS file systems that use the Server Message Block (SMB) protocol and have Resource Access Management (RAM) enabled.
 *
 * @param request CreateFileRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileResponse
 */
@context("createFileWithContext")
async function createFileWithOptions(request: CreateFileRequest, runtime: $RuntimeOptions): CreateFileResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.owner)) {
    query['Owner'] = request.owner;
  }
  if (!$isNull(request.ownerAccessInheritable)) {
    query['OwnerAccessInheritable'] = request.ownerAccessInheritable;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFile',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a directory or file.
 *
 * @description *   This operation is only available to some users.
 * *   This operation supports only General-purpose NAS file systems that use the Server Message Block (SMB) protocol and have Resource Access Management (RAM) enabled.
 *
 * @param request CreateFileRequest
 * @return CreateFileResponse
 */
async function createFile(request: CreateFileRequest): CreateFileResponse {
  var runtime = new $RuntimeOptions{};
  return createFileWithOptions(request, runtime);
}

model CreateFileSystemRequest {
  bandwidth?: long(name='Bandwidth', description='The maximum throughput of the file system.

Unit: MB/s.

Specify a value based on the specifications on the buy page.

[CPFS file system (Pay-as-you-go)](https://common-buy-intl.alibabacloud.com/?spm=5176.nas_overview.0.0.7ea01dbft0dTui\\\\&commodityCode=nas_cpfspost_public_intl#/buy)', example='150'),
  capacity?: long(name='Capacity', description='Specify the capacity of the file system. Unit: GiB. Specify the Capacity parameter when the FileSystemType parameter is set to extreme or cpfs.

Specify a value based on the specifications on the following buy page:

*   [Extreme NAS file system (Pay-as-you-go)](https://common-buy-intl.alibabacloud.com/?commodityCode=nas_extpost_public_intl#/buy)
*   [CPFS file system (Pay-as-you-go)](https://common-buy-intl.alibabacloud.com/?spm=5176.nas_overview.0.0.7ea01dbft0dTui\\\\&commodityCode=nas_cpfspost_public_intl#/buy)', example='100'),
  chargeType?: string(name='ChargeType', description='The billing method.

Valid values:

*   PayAsYouGo (default): pay-as-you-go
*   Subscription', example='PayAsYouGo'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

> If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  description?: string(name='Description', description='The description of the file system.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the precheck, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='true'),
  duration?: int32(name='Duration', description='The subscription duration.

This parameter is valid and required only if the ChargeType parameter is set to Subscription. Unit: months.

If you do not renew a subscription file system when the file system expires, the file system is automatically released.', example='1'),
  encryptType?: int32(name='EncryptType', description='Specifies whether to encrypt data in the file system.

You can use the keys that are managed by Key Management Service (KMS) to encrypt data in a file system. When you read and write the encrypted data, the data is automatically decrypted.

Valid values:

*   0 (default): The data in the file system is not encrypted.
*   1: A NAS-managed key is used to encrypt the data in the file system. This value is valid only if the FileSystemType parameter is set to standard or extreme.
*   2: A KMS-managed key is used to encrypt the data in the file system. This value is valid only if the FileSystemType parameter is set to standard or extreme.

>  *   Extreme NAS file systems: All regions except China East 1 Finance support KMS-managed keys.
> *   General-purpose NAS file systems: All regions support KMS-managed keys.', example='1'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose Apsara File Storage NAS (NAS) file system
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system', example='standard'),
  kmsKeyId?: string(name='KmsKeyId', description='The ID of the KMS key.

This parameter is required only if the EncryptType parameter is set to 2.', example='3c0b3885-2adf-483d-8a65-5e280689****'),
  protocolType?: string(name='ProtocolType', description='Specify the protocol type.

*   If the FileSystemType parameter is set to standard, set the ProtocolType parameter to NFS or SMB.
*   If the FileSystemType parameter is set to extreme, set the ProtocolType parameter to NFS.
*   If the FileSystemType parameter is set to cpfs, set the ProtocolType parameter to cpfs.

This parameter is required.', example='NFS'),
  redundancyType?: string(name='RedundancyType', example='ZRS', nullable=true),
  redundancyVSwitchIds?: [ string ](name='RedundancyVSwitchIds', nullable=true),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.

You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.', example='rg-acfmwavnfdf****'),
  snapshotId?: string(name='SnapshotId', description='The snapshot ID.

This parameter is available only for advanced Extreme NAS file systems.

>  You can create a file system from a snapshot. In this case, the version of the file system is the same as that of the source file system. For example, the source file system of the snapshot uses version 1. To create a file system of version 2, you can create File System A from the snapshot and create File System B of version 2. You can then copy the data and migrate your business from File System A to File System B.', example='s-xxx'),
  storageType?: string(name='StorageType', description='The storage type.

*   If the FileSystemType parameter is set to standard, set the StorageType parameter to Performance, Capacity, or Premium.
*   If the FileSystemType parameter is set to extreme, set the StorageType parameter to standard or advance.
*   If the FileSystemType parameter is set to cpfs, set the StorageType parameter to advance_100 (100 MB/s/TiB baseline) or advance_200 (200 MB/s/TiB baseline).

This parameter is required.', example='Performance'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

Limits:

*   The tag key cannot be null or an empty string.
*   The tag key can be up to 128 characters in length.
*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.', example='nastest', nullable=false),
      value?: string(name='Value', description='The tag value.

Limits:

*   The tag value cannot be null or an empty string.
*   The tag value can be up to 128 characters in length.
*   The tag value cannot contain `http://` or `https://`.', example='testValue', nullable=false),
    }
  ](name='Tag', description='An array of tags.

You can specify up to 20 tags. If you specify multiple tags, each tag key must be unique.'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the cluster.

*   This parameter is required only if you set the FileSystemType parameter to cpfs.
*   This parameter is reserved and not required if you set the FileSystemType parameter to standard or extreme.', example='vsw-2ze37k6jh8ums2fw2****'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

*   This parameter is required only if you set the FileSystemType parameter to cpfs.
*   This parameter is reserved and not required if you set the FileSystemType parameter to standard or extreme.', example='vpc-bp1cbv1ljve4j5hlw****'),
  zoneId?: string(name='ZoneId', description='The ID of the zone.

Each region has multiple isolated locations known as zones. Each zone has its own independent power supply and network.

This parameter is not required if the FileSystemType parameter is set to standard. By default, a random zone is selected based on the protocol type and storage type.

This parameter is required if the FileSystemType parameter is set to extreme or cpfs.

> 

*   An Elastic Compute Service (ECS) instance and a NAS file system that reside in different zones of the same region can access each other.

*   We recommend that you select the zone where the ECS instance resides. This prevents cross-zone latency between the file system and the ECS instance.', example='cn-hangzhou-b'),
}

model CreateFileSystemResponseBody = {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system that is created.', example='1ca404****'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateFileSystemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFileSystemResponseBody(name='body'),
}

/**
 * @summary Creates a file system.
 *
 * @description *   Before you call this operation, you must understand the billing and pricing of Apsara File Storage NAS. For more information, see [Billing](https://help.aliyun.com/document_detail/178365.html) and [Pricing](https://www.aliyun.com/price/product?#/nas/detail).
 * *   Before you create a file system, you must complete real-name verification. For more information, see [Real-name verification](https://help.aliyun.com/document_detail/48263.html).
 * *   When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
 *
 * @param request CreateFileSystemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFileSystemResponse
 */
@context("createFileSystemWithContext")
async function createFileSystemWithOptions(request: CreateFileSystemRequest, runtime: $RuntimeOptions): CreateFileSystemResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.bandwidth)) {
    query['Bandwidth'] = request.bandwidth;
  }
  if (!$isNull(request.capacity)) {
    query['Capacity'] = request.capacity;
  }
  if (!$isNull(request.chargeType)) {
    query['ChargeType'] = request.chargeType;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!$isNull(request.encryptType)) {
    query['EncryptType'] = request.encryptType;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.kmsKeyId)) {
    query['KmsKeyId'] = request.kmsKeyId;
  }
  if (!$isNull(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!$isNull(request.redundancyType)) {
    query['RedundancyType'] = request.redundancyType;
  }
  if (!$isNull(request.redundancyVSwitchIds)) {
    query['RedundancyVSwitchIds'] = request.redundancyVSwitchIds;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!$isNull(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!$isNull(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFileSystem',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a file system.
 *
 * @description *   Before you call this operation, you must understand the billing and pricing of Apsara File Storage NAS. For more information, see [Billing](https://help.aliyun.com/document_detail/178365.html) and [Pricing](https://www.aliyun.com/price/product?#/nas/detail).
 * *   Before you create a file system, you must complete real-name verification. For more information, see [Real-name verification](https://help.aliyun.com/document_detail/48263.html).
 * *   When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
 *
 * @param request CreateFileSystemRequest
 * @return CreateFileSystemResponse
 */
async function createFileSystem(request: CreateFileSystemRequest): CreateFileSystemResponse {
  var runtime = new $RuntimeOptions{};
  return createFileSystemWithOptions(request, runtime);
}

model CreateFilesetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2402263.html) operation.

*   true: enables release protection.
*   false (default): disables release protection.

>  This parameter can protect filesets only against manual releases, but not against automatic releases.', example='false'),
  description?: string(name='Description', description='The description of the fileset.

*   The description must be 2 to 128 characters in length.
*   The name must start with a letter and cannot start with http:// or https://.
*   The description can contain letters, digits, colons (:), underscores (_), periods (.), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is created and no fee is incurred.

Valid value:

*   true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available Apsara File Storage NAS (NAS) resources. Otherwise, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FsetId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a fileset is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  fileSystemPath?: string(name='FileSystemPath', description='The absolute path of the fileset.

*   CPFS path limits.

    *   The parent directory of the path that you specify must be an existing directory in the file system.
    *   The path must be 2 to 1024 characters in length.
    *   The path must start and end with a forward slash (/).

*   Path limit of CPFS for Lingjun

    *   The path must be 2 to 1024 characters in length.
    *   The path must start and end with a forward slash (/).
    *   The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
    *   The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
    *   If the fileset path is a multi-level path, the parent directory must be an existing directory.
    *   Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
    *   The path cannot exceed 990 characters in length.

This parameter is required.', example='/test/'),
  quota?: {
    fileCountLimit?: long(name='FileCountLimit', description='The file quantity quota. Valid values:

*   Minimum value: 100000.
*   Maximum value: 10000000000.', example='10000'),
    sizeLimit?: long(name='SizeLimit', description='The total quota capacity limit. Unit: bytes.

Valid values:

*   Minimum value: 10,737,418,240 (10 GiB).
*   Step size: 1073741824 (1 GiB).', example='10737418240'),
  }(name='Quota', description='The quota information.

>  Only CPFS for Lingjun V2.7.0 and later support this parameter.'),
}

model CreateFilesetResponseBody = {
  fsetId?: string(name='FsetId', description='The fileset ID.', example='fset-1902718ea0ae****'),
  requestId?: string(name='RequestId', description='Request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateFilesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateFilesetResponseBody(name='body'),
}

/**
 * @summary Creates a fileset.
 *
 * @description *   CPFS usage notes
 *     *   Only CPFS V2.2.0 and later support fileset creation. You can view the version information on the file system details page in the console.
 *     *   A maximum of 10 filesets can be created for a CPFS file system.
 *     *   The parent directory must be an existing directory.
 *     *   The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
 *     *   Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset.
 *     *   A fileset supports a maximum of one million files. If the number of files exceeds the upper limit, the `no space` error message is returned when you add new files.
 * *   CPFS for Lingjun usage notes
 *     *   Only CPFS for Lingjun V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
 *     *   A maximum of 500 filesets can be created for a CPFS file system.
 *     *   The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
 *     *   The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
 *     *   If the fileset path is a multi-level path, the parent directory must be an existing directory.
 *     *   Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
 *     *   The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB.
 *     *   A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
 *     *   When you modify a directory quota, you must set the quota capacity or the number of files to be greater than the capacity or file quantity that has been used.
 *     *   The quota statistics have a 15-minute latency. The actual usage takes effect after 15 minutes.
 *
 * @param request CreateFilesetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateFilesetResponse
 */
@context("createFilesetWithContext")
async function createFilesetWithOptions(request: CreateFilesetRequest, runtime: $RuntimeOptions): CreateFilesetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fileSystemPath)) {
    query['FileSystemPath'] = request.fileSystemPath;
  }
  if (!$isNull(request.quota)) {
    query['Quota'] = request.quota;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateFileset',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a fileset.
 *
 * @description *   CPFS usage notes
 *     *   Only CPFS V2.2.0 and later support fileset creation. You can view the version information on the file system details page in the console.
 *     *   A maximum of 10 filesets can be created for a CPFS file system.
 *     *   The parent directory must be an existing directory.
 *     *   The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
 *     *   Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset.
 *     *   A fileset supports a maximum of one million files. If the number of files exceeds the upper limit, the `no space` error message is returned when you add new files.
 * *   CPFS for Lingjun usage notes
 *     *   Only CPFS for Lingjun V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
 *     *   A maximum of 500 filesets can be created for a CPFS file system.
 *     *   The fileset path must be a new path and cannot be an existing path. Fileset paths cannot be renamed and cannot be symbolic links.
 *     *   The maximum depth supported by a fileset path is eight levels. The depth of the root directory / is 0 levels. For example, the fileset path /test/aaa/ccc/ has three levels.
 *     *   If the fileset path is a multi-level path, the parent directory must be an existing directory.
 *     *   Nested filesets are not supported. If a fileset is specified as a parent directory, its subdirectory cannot be a fileset. A fileset path supports only one quota.
 *     *   The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB.
 *     *   A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
 *     *   When you modify a directory quota, you must set the quota capacity or the number of files to be greater than the capacity or file quantity that has been used.
 *     *   The quota statistics have a 15-minute latency. The actual usage takes effect after 15 minutes.
 *
 * @param request CreateFilesetRequest
 * @return CreateFilesetResponse
 */
async function createFileset(request: CreateFilesetRequest): CreateFilesetResponse {
  var runtime = new $RuntimeOptions{};
  return createFilesetWithOptions(request, runtime);
}

model CreateLDAPConfigRequest {
  bindDN?: string(name='BindDN', description='An LDAP entry.', example='cn=alibaba,dc=com'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='109c04****'),
  searchBase?: string(name='SearchBase', description='An LDAP search base.

This parameter is required.', example='dc=example'),
  URI?: string(name='URI', description='An LDAP URI.

This parameter is required.', example='ldap://ldap.example.example'),
}

model CreateLDAPConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5B4511A7-C99E-4071-AA8C-32E2529D****'),
}

model CreateLDAPConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLDAPConfigResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI CreateLDAPConfig is deprecated
 *
 * @summary Creates LDAP configurations.
 *
 * @param request CreateLDAPConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLDAPConfigResponse
 */
// Deprecated
@context("createLDAPConfigWithContext")
async function createLDAPConfigWithOptions(request: CreateLDAPConfigRequest, runtime: $RuntimeOptions): CreateLDAPConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.bindDN)) {
    query['BindDN'] = request.bindDN;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.searchBase)) {
    query['SearchBase'] = request.searchBase;
  }
  if (!$isNull(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLDAPConfig',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI CreateLDAPConfig is deprecated
 *
 * @summary Creates LDAP configurations.
 *
 * @param request CreateLDAPConfigRequest
 * @return CreateLDAPConfigResponse
 */
// Deprecated
async function createLDAPConfig(request: CreateLDAPConfigRequest): CreateLDAPConfigResponse {
  var runtime = new $RuntimeOptions{};
  return createLDAPConfigWithOptions(request, runtime);
}

model CreateLifecyclePolicyRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  lifecyclePolicyName?: string(name='LifecyclePolicyName', description='The name of the lifecycle policy. The name must be 3 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The name must start with a letter.

This parameter is required.', example='lifecyclepolicy_01'),
  lifecycleRuleName?: string(name='LifecycleRuleName', description='The management rule that is associated with the lifecycle policy.

Valid values:

*   DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.', example='DEFAULT_ATIME_14'),
  path?: string(name='Path', description='The absolute path of the directory that is associated with the lifecycle policy.

If you specify this parameter, you can associate the lifecycle policy with only one directory. The path must start with a forward slash (/) and must be a path that exists in the mount target.

> We recommend that you specify the Paths.N parameter so that you can associate the lifecycle policy with multiple directories.', example='/pathway/to/folder'),
  paths?: [ string ](name='Paths', description='The absolute paths of the directories that are associated with the lifecycle policy.

If you specify this parameter, you can associate the lifecycle policy with multiple directories. Each path must start with a forward slash (/) and must be a path that exists in the mount target. Valid values of N: 1 to 10.', example='"/path1", "/path2"'),
  storageType?: string(name='StorageType', description='The storage type of the data that is dumped to the IA storage medium.

Default value: InfrequentAccess (IA).

This parameter is required.', example='InfrequentAccess'),
}

model CreateLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

Valid values:

*   true
*   false', example='true'),
}

model CreateLifecyclePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLifecyclePolicyResponseBody(name='body'),
}

/**
 * @summary Creates a lifecycle policy.
 *
 * @description *   You can create lifecycle policies only for General-purpose NAS file systems.
 * *   You can create up to 20 lifecycle policies in each region within an Alibaba Cloud account.
 *
 * @param request CreateLifecyclePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLifecyclePolicyResponse
 */
@context("createLifecyclePolicyWithContext")
async function createLifecyclePolicyWithOptions(request: CreateLifecyclePolicyRequest, runtime: $RuntimeOptions): CreateLifecyclePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.lifecyclePolicyName)) {
    query['LifecyclePolicyName'] = request.lifecyclePolicyName;
  }
  if (!$isNull(request.lifecycleRuleName)) {
    query['LifecycleRuleName'] = request.lifecycleRuleName;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.paths)) {
    query['Paths'] = request.paths;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLifecyclePolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a lifecycle policy.
 *
 * @description *   You can create lifecycle policies only for General-purpose NAS file systems.
 * *   You can create up to 20 lifecycle policies in each region within an Alibaba Cloud account.
 *
 * @param request CreateLifecyclePolicyRequest
 * @return CreateLifecyclePolicyResponse
 */
async function createLifecyclePolicy(request: CreateLifecyclePolicyRequest): CreateLifecyclePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return createLifecyclePolicyWithOptions(request, runtime);
}

model CreateLifecycleRetrieveJobRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  paths?: [ string ](name='Paths', description='The directories or files that you want to retrieve. You can specify a maximum of 10 paths.

This parameter is required.', example='Paths.1=/pathway/doc1,Paths.2=/pathway/doc2'),
  storageType?: string(name='StorageType', description='The storage class.

*   InfrequentAccess (default): the Infrequent Access (IA) storage class.
*   Archive: the Archive storage class.', example='InfrequentAccess'),
}

model CreateLifecycleRetrieveJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the data retrieval task.', example='lrj-nfstest-ia-160****853-hshvw'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model CreateLifecycleRetrieveJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLifecycleRetrieveJobResponseBody(name='body'),
}

/**
 * @summary Creates a data retrieval task.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can run a maximum of 20 data retrieval tasks in each region within an Alibaba Cloud account.
 *
 * @param request CreateLifecycleRetrieveJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLifecycleRetrieveJobResponse
 */
@context("createLifecycleRetrieveJobWithContext")
async function createLifecycleRetrieveJobWithOptions(request: CreateLifecycleRetrieveJobRequest, runtime: $RuntimeOptions): CreateLifecycleRetrieveJobResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.paths)) {
    query['Paths'] = request.paths;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLifecycleRetrieveJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a data retrieval task.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can run a maximum of 20 data retrieval tasks in each region within an Alibaba Cloud account.
 *
 * @param request CreateLifecycleRetrieveJobRequest
 * @return CreateLifecycleRetrieveJobResponse
 */
async function createLifecycleRetrieveJob(request: CreateLifecycleRetrieveJobRequest): CreateLifecycleRetrieveJobResponse {
  var runtime = new $RuntimeOptions{};
  return createLifecycleRetrieveJobWithOptions(request, runtime);
}

model CreateLogAnalysisRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='174494xxxx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model CreateLogAnalysisResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5B4511A7-C99E-4071-AA8C-32E2529DA963'),
}

model CreateLogAnalysisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLogAnalysisResponseBody(name='body'),
}

/**
 * @summary Dumps the logs of a General-purpose NAS file system to Simple Log Service.
 *
 * @param request CreateLogAnalysisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateLogAnalysisResponse
 */
@context("createLogAnalysisWithContext")
async function createLogAnalysisWithOptions(request: CreateLogAnalysisRequest, runtime: $RuntimeOptions): CreateLogAnalysisResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateLogAnalysis',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Dumps the logs of a General-purpose NAS file system to Simple Log Service.
 *
 * @param request CreateLogAnalysisRequest
 * @return CreateLogAnalysisResponse
 */
async function createLogAnalysis(request: CreateLogAnalysisRequest): CreateLogAnalysisResponse {
  var runtime = new $RuntimeOptions{};
  return createLogAnalysisWithOptions(request, runtime);
}

model CreateMountTargetRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

This parameter is required if you create a mount target for a General-purpose NAS file system or an Extreme NAS file system.

The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.', example='vpc-test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run to check for existing mount targets. This parameter is valid only for CPFS file systems.

If you set this parameter to true, the system checks whether the request parameters are valid and whether the requested resources are available. In this case, no mount target is created and no fee is incurred.

*   true: performs a dry run but does not create a mount target. In the dry run, the system checks the request format, service limits, available CPFS resources, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code `200` is returned. No value is returned for the `MountTargetDomain` parameter.
*   false (default): sends the request. If the request passes the dry run, a mount target is created.', example='false'),
  enableIpv6?: boolean(name='EnableIpv6', description='Specifies whether to create an IPv6 domain name for the mount target.

Valid values:

*   true: An IPv6 domain name is created for the mount target.
*   false (default): No IPv6 domain name is created for the mount target.

> Only Extreme NAS file systems that reside in the Chinese mainland support IPv6. If you want to create an IPv6 domain name for the mount target, you must enable IPv6 for the file system.', example='true'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: 31a8e4\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='174494****'),
  networkType?: string(name='NetworkType', description='The network type of the mount target. Valid value: **Vpc**.

This parameter is required.', example='Vpc'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-bp1fg655nh68xyz9****'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.

This parameter is valid and required if the mount target resides in a VPC. Example: If you set the NetworkType parameter to VPC, you must specify the VSwitchId parameter.', example='vsw-2zevmwkwyztjuoffg****'),
  vpcId?: string(name='VpcId', description='The ID of the VPC.

This parameter is valid and required if the mount target resides in a VPC. Example: If you set the NetworkType parameter to VPC, you must specify the VpcId parameter.', example='vpc-2zesj9afh3y518k9o****'),
}

model CreateMountTargetResponseBody = {
  mountTargetDomain?: string(name='MountTargetDomain', description='The IPv4 domain name of the mount target.', example='174494b666-x****.cn-hangzhou.nas.aliyuncs.com'),
  mountTargetExtra?: {
    dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', description='The dual-stack (IPv4 and IPv6) domain name of the mount target.', example='174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com'),
  }(name='MountTargetExtra', description='The information about the mount target.'),
  requestId?: string(name='RequestId', description='The request ID.', example='70EACC9C-D07A-4A34-ADA4-77506C42****'),
}

model CreateMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMountTargetResponseBody(name='body'),
}

/**
 * @summary Creates a mount target.
 *
 * @description *   After you call the CreateMountTarget operation, a mount target is not immediately created. Therefore, we recommend that you call the DescribeMountTargets operation to query the status of the mount target. If the mount target is in the **Active** state, you can then mount the file system. Otherwise, the file system may fail to be mounted.
 * *   When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
 *
 * @param request CreateMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMountTargetResponse
 */
@context("createMountTargetWithContext")
async function createMountTargetWithOptions(request: CreateMountTargetRequest, runtime: $RuntimeOptions): CreateMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.enableIpv6)) {
    query['EnableIpv6'] = request.enableIpv6;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!$isNull(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!$isNull(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a mount target.
 *
 * @description *   After you call the CreateMountTarget operation, a mount target is not immediately created. Therefore, we recommend that you call the DescribeMountTargets operation to query the status of the mount target. If the mount target is in the **Active** state, you can then mount the file system. Otherwise, the file system may fail to be mounted.
 * *   When you call this operation, a service-linked role of NAS is automatically created. For more information, see [Manage the service-linked roles of NAS](https://help.aliyun.com/document_detail/208530.html).
 *
 * @param request CreateMountTargetRequest
 * @return CreateMountTargetResponse
 */
async function createMountTarget(request: CreateMountTargetRequest): CreateMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return createMountTargetWithOptions(request, runtime);
}

model CreateProtocolMountTargetRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

Default value: DEFAULT_VPC_GROUP_NAME.', example='DEFAULT_VPC_GROUP_NAME'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  description?: string(name='Description', description='The description of the export directory for the protocol service. The **name of the export directory** appears in the console.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter but cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. The dry run checks parameter validity and prerequisites. The dry run does not create an export directory or incur fees.

Valid values:

*   true: performs a dry run. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the ExportId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, an export directory is created.', example='true'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123****'),
  fsetId?: string(name='FsetId', description='The ID of the fileset that you want to export.

Limits:

*   The fileset already exists.
*   You can create only one export directory for a fileset.
*   You can specify either a fileset or a path.', example='fset-123****'),
  path?: string(name='Path', description='The path of the CPFS directory that you want to export.

Limits:

*   The directory already exists in the CPFS file system.
*   You can create only one export directory for a directory.
*   You can specify either a fileset or a path.

Format:

*   The path must be 1 to 1,024 characters in length.
*   The path must be encoded in UTF-8.
*   The path must start and end with a forward slash (/). The root directory is `/`.', example='/'),
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.

This parameter is required.', example='ptc-123****'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the export directory for the protocol service.', example='vsw-123****', nullable=true),
  vSwitchIds?: [ string ](name='VSwitchIds', nullable=true),
  vpcId?: string(name='VpcId', description='The VPC ID of the export directory for the protocol service.', example='vpc-123****', nullable=true),
}

model CreateProtocolMountTargetResponseBody = {
  exportId?: string(name='ExportId', description='The ID of the export directory for the protocol service.', example='exp-123****'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model CreateProtocolMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProtocolMountTargetResponseBody(name='body'),
}

/**
 * @summary Creates an export directory for a protocol service.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Prerequisites
 *     A protocol service is created.
 * *   Others
 *     *   The virtual private cloud (VPC) CIDR block of the export directory for the protocol service cannot overlap with the VPC CIDR block of the file system.
 *     *   The VPC CIDR blocks of multiple export directories of a protocol service cannot overlap.
 *     *   You can create a maximum of 10 export directories for a protocol service.
 *     *   A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
 *
 * @param request CreateProtocolMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProtocolMountTargetResponse
 */
@context("createProtocolMountTargetWithContext")
async function createProtocolMountTargetWithOptions(request: CreateProtocolMountTargetRequest, runtime: $RuntimeOptions): CreateProtocolMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.protocolServiceId)) {
    query['ProtocolServiceId'] = request.protocolServiceId;
  }
  if (!$isNull(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!$isNull(request.vSwitchIds)) {
    query['VSwitchIds'] = request.vSwitchIds;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateProtocolMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an export directory for a protocol service.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Prerequisites
 *     A protocol service is created.
 * *   Others
 *     *   The virtual private cloud (VPC) CIDR block of the export directory for the protocol service cannot overlap with the VPC CIDR block of the file system.
 *     *   The VPC CIDR blocks of multiple export directories of a protocol service cannot overlap.
 *     *   You can create a maximum of 10 export directories for a protocol service.
 *     *   A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
 *
 * @param request CreateProtocolMountTargetRequest
 * @return CreateProtocolMountTargetResponse
 */
async function createProtocolMountTarget(request: CreateProtocolMountTargetRequest): CreateProtocolMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return createProtocolMountTargetWithOptions(request, runtime);
}

model CreateProtocolServiceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  description?: string(name='Description', description='The description of the protocol service. The name of the protocol service appears in the console.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

The dry run checks parameter validity and prerequisites. The dry run does not create a protocol service or incur fees.

Valid values:

*   true: performs only a dry run and does not create the protocol service. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the ProtocolServiceId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a protocol service is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123****'),
  protocolSpec?: string(name='ProtocolSpec', description='The specification of the protocol service.

Set the value to General (default).

Valid values:

*   CL2
*   General
*   CL1

This parameter is required.', example='General'),
  protocolType?: string(name='ProtocolType', description='The protocol type of the protocol service.

Valid value: NFS (default). Only NFSv3 is supported.

This parameter is required.', example='NFS'),
  throughput?: int32(name='Throughput', description='The throughput of the protocol service.

Unit: MB/s.', example='8000'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the protocol service.', example='vsw-123****', nullable=true),
  vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID of the protocol service. The VPC ID of the protocol service must be the same as the VPC ID of the file system.', example='vpc-123****', nullable=true),
}

model CreateProtocolServiceResponseBody = {
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.', example='ptc-123****'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateProtocolServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateProtocolServiceResponseBody(name='body'),
}

/**
 * @summary Creates a protocol service for a Cloud Parallel File Storage (CPFS) file system. The creation takes about 5 to 10 minutes.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.3.0 and later support protocol services. You can query the version information of the file system by calling the [DescribeFileSystems](https://help.aliyun.com/document_detail/163314.html) operation.
 * *   Protocol service types
 *     Protocol services are classified into general-purpose protocol services and cache protocol services. Different from general-purpose protocol services, cache protocol services can cache hot data. If data exists in the cache, the bandwidth of the cache protocol service may exceed the bandwidth of the CPFS file system, reaching the maximum bandwidth specified for the protocol service.
 *     *   General-purpose protocol services: provide NFS access and [directory-level mount targets](https://help.aliyun.com/document_detail/427175.html) for CPFS file systems. You do not need to configure a POSIX client to manage clusters. The compliance package check feature is free of charge.
 *     *   Cache protocol services: provide the server memory cache based on the least recently used (LRU) policy. When data is cached in the memory, CPFS provides higher internal bandwidth. Cache protocol services are divided into Cache L1 and Cache L2 specifications. The differences are the internal bandwidth size and memory cache size.
 *     **
 *     **Note** You are charged for using cache protocol services, which are in invitational preview. For more information about the billing method of cache protocol services, see [Billable items](https://help.aliyun.com/document_detail/111858.html). If you have any feedback or questions, you can join the DingTalk group (group number: 31045006299).
 * *   Protocol Type
 *     Only NFSv3 is supported.
 * *   Others
 *     *   Only one protocol service can be created for a CPFS file system.
 *     *   A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
 *
 * @param request CreateProtocolServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateProtocolServiceResponse
 */
@context("createProtocolServiceWithContext")
async function createProtocolServiceWithOptions(request: CreateProtocolServiceRequest, runtime: $RuntimeOptions): CreateProtocolServiceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.protocolSpec)) {
    query['ProtocolSpec'] = request.protocolSpec;
  }
  if (!$isNull(request.protocolType)) {
    query['ProtocolType'] = request.protocolType;
  }
  if (!$isNull(request.throughput)) {
    query['Throughput'] = request.throughput;
  }
  if (!$isNull(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateProtocolService',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a protocol service for a Cloud Parallel File Storage (CPFS) file system. The creation takes about 5 to 10 minutes.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.3.0 and later support protocol services. You can query the version information of the file system by calling the [DescribeFileSystems](https://help.aliyun.com/document_detail/163314.html) operation.
 * *   Protocol service types
 *     Protocol services are classified into general-purpose protocol services and cache protocol services. Different from general-purpose protocol services, cache protocol services can cache hot data. If data exists in the cache, the bandwidth of the cache protocol service may exceed the bandwidth of the CPFS file system, reaching the maximum bandwidth specified for the protocol service.
 *     *   General-purpose protocol services: provide NFS access and [directory-level mount targets](https://help.aliyun.com/document_detail/427175.html) for CPFS file systems. You do not need to configure a POSIX client to manage clusters. The compliance package check feature is free of charge.
 *     *   Cache protocol services: provide the server memory cache based on the least recently used (LRU) policy. When data is cached in the memory, CPFS provides higher internal bandwidth. Cache protocol services are divided into Cache L1 and Cache L2 specifications. The differences are the internal bandwidth size and memory cache size.
 *     **
 *     **Note** You are charged for using cache protocol services, which are in invitational preview. For more information about the billing method of cache protocol services, see [Billable items](https://help.aliyun.com/document_detail/111858.html). If you have any feedback or questions, you can join the DingTalk group (group number: 31045006299).
 * *   Protocol Type
 *     Only NFSv3 is supported.
 * *   Others
 *     *   Only one protocol service can be created for a CPFS file system.
 *     *   A protocol service can use a maximum of 32 IP addresses that are allocated by a specified vSwitch. Make sure that the vSwitch can provide sufficient IP addresses.
 *
 * @param request CreateProtocolServiceRequest
 * @return CreateProtocolServiceResponse
 */
async function createProtocolService(request: CreateProtocolServiceRequest): CreateProtocolServiceResponse {
  var runtime = new $RuntimeOptions{};
  return createProtocolServiceWithOptions(request, runtime);
}

model CreateRecycleBinDeleteJobRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

> If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  fileId?: string(name='FileId', description='The ID of the file or directory that you want to permanently delete.

You can call the [ListRecycledDirectoriesAndFiles](https://help.aliyun.com/document_detail/2412174.html) operation to query the FileId of the deleted data.

This parameter is required.', example='04***08'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model CreateRecycleBinDeleteJobResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='8C****C54'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateRecycleBinDeleteJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRecycleBinDeleteJobResponseBody(name='body'),
}

/**
 * @summary Creates a job to permanently delete a file or directory from the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   If you permanently delete a directory, the files in the directory are recursively cleared.
 * *   You can run only one job at a time for a single file system to permanently delete the files from the file system. You cannot create a restoration or deletion job when a file or directory is being deleted.
 *
 * @param request CreateRecycleBinDeleteJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRecycleBinDeleteJobResponse
 */
@context("createRecycleBinDeleteJobWithContext")
async function createRecycleBinDeleteJobWithOptions(request: CreateRecycleBinDeleteJobRequest, runtime: $RuntimeOptions): CreateRecycleBinDeleteJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRecycleBinDeleteJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a job to permanently delete a file or directory from the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   If you permanently delete a directory, the files in the directory are recursively cleared.
 * *   You can run only one job at a time for a single file system to permanently delete the files from the file system. You cannot create a restoration or deletion job when a file or directory is being deleted.
 *
 * @param request CreateRecycleBinDeleteJobRequest
 * @return CreateRecycleBinDeleteJobResponse
 */
async function createRecycleBinDeleteJob(request: CreateRecycleBinDeleteJobRequest): CreateRecycleBinDeleteJobResponse {
  var runtime = new $RuntimeOptions{};
  return createRecycleBinDeleteJobWithOptions(request, runtime);
}

model CreateRecycleBinRestoreJobRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

> If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  fileId?: string(name='FileId', description='The ID of the file or directory that you want to restore.

You can call the [ListRecycledDirectoriesAndFiles](https://help.aliyun.com/document_detail/2412174.html) operation to query the FileId of the deleted data.

This parameter is required.', example='04***08'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  targetFileId?: string(name='TargetFileId', description='The ID of the directory to which the file is restored.

*   You can call the [ListRecentlyRecycledDirectories](https://help.aliyun.com/document_detail/2412173.html) operation to query the TargetFileId for recently deleted directories.
*   You can call the [ListDirectoriesAndFiles](https://help.aliyun.com/document_detail/2412163.html) operation to query the TargetFileId for existing directories.

This parameter is required.', example='13***15'),
}

model CreateRecycleBinRestoreJobResponseBody = {
  jobId?: string(name='JobId', description='The job ID.', example='rb-10****491ff-r-162****165400'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model CreateRecycleBinRestoreJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRecycleBinRestoreJobResponseBody(name='body'),
}

/**
 * @summary Restores a file or directory from the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can run only one job at a time for a single file system to restore files to or clear files from the file system. You cannot create a restore or cleanup job when files are being restored from the recycle bin.
 * *   You can restore only one file or directory in a single restore job. If you restore a specified directory, all files in the directory are recursively restored.
 * *   After files are restored, the data of the files is defragmented. When the data is being defragmented, the read performance is slightly degraded.
 *
 * @param request CreateRecycleBinRestoreJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRecycleBinRestoreJobResponse
 */
@context("createRecycleBinRestoreJobWithContext")
async function createRecycleBinRestoreJobWithOptions(request: CreateRecycleBinRestoreJobRequest, runtime: $RuntimeOptions): CreateRecycleBinRestoreJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRecycleBinRestoreJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restores a file or directory from the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can run only one job at a time for a single file system to restore files to or clear files from the file system. You cannot create a restore or cleanup job when files are being restored from the recycle bin.
 * *   You can restore only one file or directory in a single restore job. If you restore a specified directory, all files in the directory are recursively restored.
 * *   After files are restored, the data of the files is defragmented. When the data is being defragmented, the read performance is slightly degraded.
 *
 * @param request CreateRecycleBinRestoreJobRequest
 * @return CreateRecycleBinRestoreJobResponse
 */
async function createRecycleBinRestoreJob(request: CreateRecycleBinRestoreJobRequest): CreateRecycleBinRestoreJobResponse {
  var runtime = new $RuntimeOptions{};
  return createRecycleBinRestoreJobWithOptions(request, runtime);
}

model CreateSnapshotRequest {
  description?: string(name='Description', description='The description of the snapshot.

Limits:

*   The description must be 2 to 256 characters in length.
*   The description cannot start with `http://` or `https://`.
*   This parameter is empty by default.', example='FinanceDepet'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the advanced Extreme NAS file system. The value must start with `extreme-`, for example, `extreme-01dd****`.

This parameter is required.', example='extreme-01dd****'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of the snapshot.

Unit: days.

Valid values:

*   \\\\-1 (default). Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
*   1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.', example='30'),
  snapshotName?: string(name='SnapshotName', description='The snapshot name.

Limits:

*   The name must be 2 to 128 characters in length. The name must start with a letter and cannot start with `http://` or `https://`.
*   The name can contain letters, digits, colons (:), underscores (_), and hyphens (-).
*   The name cannot start with auto because snapshots whose names start with auto are recognized as auto snapshots.', example='FinanceJoshua'),
}

model CreateSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  snapshotId?: string(name='SnapshotId', description='The snapshot ID.', example='s-extreme-snapsho****'),
}

model CreateSnapshotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSnapshotResponseBody(name='body'),
}

/**
 * @summary Creates a snapshot.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   You can create a maximum of 128 snapshots for a file system.
 * *   The compute node on which a file system is mounted must function as expected. Otherwise, you cannot create a snapshot for the file system.
 * *   You can create only one snapshot for a file system at a time.
 * *   If the file system expires when a snapshot is being created, the file system is released and the snapshot is deleted.
 * *   When you create a snapshot for a file system, the I/O performance of the file system may be degraded for a short period of time. We recommend that you create snapshots during off-peak hours.
 * *   A snapshot is a backup of a file system at a specific point in time. After you create a snapshot, incremental data that is generated in the file system will not be synchronized to the snapshot.
 * *   Manually created snapshots will not be deleted until 15 days after the service is suspended due to overdue payments. We recommend that you delete unnecessary snapshots at regular intervals to prevent extra fees incurred by the snapshots.
 *
 * @param request CreateSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSnapshotResponse
 */
@context("createSnapshotWithContext")
async function createSnapshotWithOptions(request: CreateSnapshotRequest, runtime: $RuntimeOptions): CreateSnapshotResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!$isNull(request.snapshotName)) {
    query['SnapshotName'] = request.snapshotName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSnapshot',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a snapshot.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   You can create a maximum of 128 snapshots for a file system.
 * *   The compute node on which a file system is mounted must function as expected. Otherwise, you cannot create a snapshot for the file system.
 * *   You can create only one snapshot for a file system at a time.
 * *   If the file system expires when a snapshot is being created, the file system is released and the snapshot is deleted.
 * *   When you create a snapshot for a file system, the I/O performance of the file system may be degraded for a short period of time. We recommend that you create snapshots during off-peak hours.
 * *   A snapshot is a backup of a file system at a specific point in time. After you create a snapshot, incremental data that is generated in the file system will not be synchronized to the snapshot.
 * *   Manually created snapshots will not be deleted until 15 days after the service is suspended due to overdue payments. We recommend that you delete unnecessary snapshots at regular intervals to prevent extra fees incurred by the snapshots.
 *
 * @param request CreateSnapshotRequest
 * @return CreateSnapshotResponse
 */
async function createSnapshot(request: CreateSnapshotRequest): CreateSnapshotResponse {
  var runtime = new $RuntimeOptions{};
  return createSnapshotWithOptions(request, runtime);
}

model DeleteAccessGroupRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group to be deleted.

This parameter is required.', example='vpc-test'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system
*   extreme: Extreme NAS file system', example='standard'),
}

model DeleteAccessGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model DeleteAccessGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccessGroupResponseBody(name='body'),
}

/**
 * @summary Deletes a permission group.
 *
 * @description The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
 *
 * @param request DeleteAccessGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccessGroupResponse
 */
@context("deleteAccessGroupWithContext")
async function deleteAccessGroupWithOptions(request: DeleteAccessGroupRequest, runtime: $RuntimeOptions): DeleteAccessGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAccessGroup',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a permission group.
 *
 * @description The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
 *
 * @param request DeleteAccessGroupRequest
 * @return DeleteAccessGroupResponse
 */
async function deleteAccessGroup(request: DeleteAccessGroupRequest): DeleteAccessGroupResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAccessGroupWithOptions(request, runtime);
}

model DeleteAccessPointRequest {
  accessPointId?: string(name='AccessPointId', description='The ID of the access point.

This parameter is required.', example='ap-ie15yd****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model DeleteAccessPointResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DeleteAccessPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccessPointResponseBody(name='body'),
}

/**
 * @summary Deletes an access point.
 *
 * @description *   Only General-purpose Network File System (NFS) file systems support access points.
 * *   After an access point is deleted, all I/O operations that are being performed on the directory accessed over the access point are interrupted immediately. Exercise caution when you perform this operation.
 *
 * @param request DeleteAccessPointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccessPointResponse
 */
@context("deleteAccessPointWithContext")
async function deleteAccessPointWithOptions(request: DeleteAccessPointRequest, runtime: $RuntimeOptions): DeleteAccessPointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAccessPoint',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an access point.
 *
 * @description *   Only General-purpose Network File System (NFS) file systems support access points.
 * *   After an access point is deleted, all I/O operations that are being performed on the directory accessed over the access point are interrupted immediately. Exercise caution when you perform this operation.
 *
 * @param request DeleteAccessPointRequest
 * @return DeleteAccessPointResponse
 */
async function deleteAccessPoint(request: DeleteAccessPointRequest): DeleteAccessPointResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAccessPointWithOptions(request, runtime);
}

model DeleteAccessRuleRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

This parameter is required.', example='vpc-test'),
  accessRuleId?: string(name='AccessRuleId', description='The rule ID.

This parameter is required.', example='1'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system.
*   extreme: Extreme NAS file system.', example='standard'),
}

model DeleteAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5B4511A7-C99E-4071-AA8C-32E2529D****'),
}

model DeleteAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccessRuleResponseBody(name='body'),
}

/**
 * @summary Deletes a rule from a permission group.
 *
 * @description Rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
 *
 * @param request DeleteAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccessRuleResponse
 */
@context("deleteAccessRuleWithContext")
async function deleteAccessRuleWithOptions(request: DeleteAccessRuleRequest, runtime: $RuntimeOptions): DeleteAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAccessRule',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a rule from a permission group.
 *
 * @description Rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be deleted.
 *
 * @param request DeleteAccessRuleRequest
 * @return DeleteAccessRuleResponse
 */
async function deleteAccessRule(request: DeleteAccessRuleRequest): DeleteAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAccessRuleWithOptions(request, runtime);
}

model DeleteAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.

You can call the [DescribeAutoSnapshotPolicies](https://help.aliyun.com/document_detail/126583.html) operation to view available automatic snapshot policies.

This parameter is required.', example='sp-extreme-233e6****'),
}

model DeleteAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.

Every response returns a unique request ID regardless of whether the request is successful.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DeleteAutoSnapshotPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes an automatic snapshot policy.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   If you delete an automatic snapshot policy that is applied to a file system, snapshots for the file system are no longer created based on the policy.
 *
 * @param request DeleteAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAutoSnapshotPolicyResponse
 */
@context("deleteAutoSnapshotPolicyWithContext")
async function deleteAutoSnapshotPolicyWithOptions(request: DeleteAutoSnapshotPolicyRequest, runtime: $RuntimeOptions): DeleteAutoSnapshotPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyId)) {
    query['AutoSnapshotPolicyId'] = request.autoSnapshotPolicyId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAutoSnapshotPolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an automatic snapshot policy.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 * *   If you delete an automatic snapshot policy that is applied to a file system, snapshots for the file system are no longer created based on the policy.
 *
 * @param request DeleteAutoSnapshotPolicyRequest
 * @return DeleteAutoSnapshotPolicyResponse
 */
async function deleteAutoSnapshotPolicy(request: DeleteAutoSnapshotPolicyRequest): DeleteAutoSnapshotPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAutoSnapshotPolicyWithOptions(request, runtime);
}

model DeleteDataFlowRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='cpfs-099394bd928c****'),
}

model DeleteDataFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DeleteDataFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDataFlowResponseBody(name='body'),
}

/**
 * @summary Deletes a dataflow.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can delete the data flows that are only in the `Running` or `Stopped` state.
 * *   After a data flow is deleted, the resources related to the data flow are released and cannot be restored. You must create a data flow again if required.
 *
 * @param request DeleteDataFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDataFlowResponse
 */
@context("deleteDataFlowWithContext")
async function deleteDataFlowWithOptions(request: DeleteDataFlowRequest, runtime: $RuntimeOptions): DeleteDataFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteDataFlow',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a dataflow.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can delete the data flows that are only in the `Running` or `Stopped` state.
 * *   After a data flow is deleted, the resources related to the data flow are released and cannot be restored. You must create a data flow again if required.
 *
 * @param request DeleteDataFlowRequest
 * @return DeleteDataFlowResponse
 */
async function deleteDataFlow(request: DeleteDataFlowRequest): DeleteDataFlowResponse {
  var runtime = new $RuntimeOptions{};
  return deleteDataFlowWithOptions(request, runtime);
}

model DeleteFileSystemRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system that you want to delete.

*   Sample ID of a General-purpose NAS file system: 31a8e4\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Cloud Parallel File Storage (CPFS) file systems must start with `cpfs-`, for example, cpfs-00cb6fa094ca\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='1ca404****'),
}

model DeleteFileSystemResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model DeleteFileSystemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFileSystemResponseBody(name='body'),
}

/**
 * @summary Deletes a file system.
 *
 * @description *   Before you delete a file system, you must delete all mount targets of the file system.
 * *   Before you delete a file system, you must make sure that no lifecycle policy is created for the file system.
 * *   After a file system is deleted, the data on the file system cannot be restored. Proceed with caution.
 *
 * @param request DeleteFileSystemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFileSystemResponse
 */
@context("deleteFileSystemWithContext")
async function deleteFileSystemWithOptions(request: DeleteFileSystemRequest, runtime: $RuntimeOptions): DeleteFileSystemResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFileSystem',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a file system.
 *
 * @description *   Before you delete a file system, you must delete all mount targets of the file system.
 * *   Before you delete a file system, you must make sure that no lifecycle policy is created for the file system.
 * *   After a file system is deleted, the data on the file system cannot be restored. Proceed with caution.
 *
 * @param request DeleteFileSystemRequest
 * @return DeleteFileSystemResponse
 */
async function deleteFileSystem(request: DeleteFileSystemRequest): DeleteFileSystemResponse {
  var runtime = new $RuntimeOptions{};
  return deleteFileSystemWithOptions(request, runtime);
}

model DeleteFilesetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is deleted.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the fileset is deleted.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='cpfs-099394bd928c****'),
  fsetId?: string(name='FsetId', description='The fileset ID.

This parameter is required.', example='fset-1902718ea0ae****'),
}

model DeleteFilesetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model DeleteFilesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteFilesetResponseBody(name='body'),
}

/**
 * @summary Deletes a fileset.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation. After you delete a fileset, all data in the fileset is deleted and cannot be restored. Proceed with caution.
 * *   If deletion protection is enabled for the fileset, you must disable deletion protection before you delete the fileset.
 * *   After you delete a fileset of CPFS for Lingjun, the storage space is not immediately released and will be recycled within 24 hours. If you want to release storage space immediately, you can clear the data in the fileset and then delete the fileset. Deleted data cannot be restored. Proceed with caution.
 *
 * @param request DeleteFilesetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteFilesetResponse
 */
@context("deleteFilesetWithContext")
async function deleteFilesetWithOptions(request: DeleteFilesetRequest, runtime: $RuntimeOptions): DeleteFilesetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteFileset',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a fileset.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation. After you delete a fileset, all data in the fileset is deleted and cannot be restored. Proceed with caution.
 * *   If deletion protection is enabled for the fileset, you must disable deletion protection before you delete the fileset.
 * *   After you delete a fileset of CPFS for Lingjun, the storage space is not immediately released and will be recycled within 24 hours. If you want to release storage space immediately, you can clear the data in the fileset and then delete the fileset. Deleted data cannot be restored. Proceed with caution.
 *
 * @param request DeleteFilesetRequest
 * @return DeleteFilesetResponse
 */
async function deleteFileset(request: DeleteFilesetRequest): DeleteFilesetResponse {
  var runtime = new $RuntimeOptions{};
  return deleteFilesetWithOptions(request, runtime);
}

model DeleteLDAPConfigRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404a348'),
}

model DeleteLDAPConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5B4511A7-C99E-4071-AA8C-32E2529DA963'),
}

model DeleteLDAPConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLDAPConfigResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DeleteLDAPConfig is deprecated
 *
 * @summary {"summary1":""}
 *
 * @param request DeleteLDAPConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLDAPConfigResponse
 */
// Deprecated
@context("deleteLDAPConfigWithContext")
async function deleteLDAPConfigWithOptions(request: DeleteLDAPConfigRequest, runtime: $RuntimeOptions): DeleteLDAPConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteLDAPConfig',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI DeleteLDAPConfig is deprecated
 *
 * @summary {"summary1":""}
 *
 * @param request DeleteLDAPConfigRequest
 * @return DeleteLDAPConfigResponse
 */
// Deprecated
async function deleteLDAPConfig(request: DeleteLDAPConfigRequest): DeleteLDAPConfigResponse {
  var runtime = new $RuntimeOptions{};
  return deleteLDAPConfigWithOptions(request, runtime);
}

model DeleteLifecyclePolicyRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  lifecyclePolicyName?: string(name='LifecyclePolicyName', description='The name of the lifecycle policy.

This parameter is required.', example='lifecyclepolicy1'),
}

model DeleteLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

Valid values:

*   true
*   false', example='true'),
}

model DeleteLifecyclePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLifecyclePolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a lifecycle policy.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request DeleteLifecyclePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLifecyclePolicyResponse
 */
@context("deleteLifecyclePolicyWithContext")
async function deleteLifecyclePolicyWithOptions(request: DeleteLifecyclePolicyRequest, runtime: $RuntimeOptions): DeleteLifecyclePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.lifecyclePolicyName)) {
    query['LifecyclePolicyName'] = request.lifecyclePolicyName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteLifecyclePolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a lifecycle policy.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request DeleteLifecyclePolicyRequest
 * @return DeleteLifecyclePolicyResponse
 */
async function deleteLifecyclePolicy(request: DeleteLifecyclePolicyRequest): DeleteLifecyclePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteLifecyclePolicyWithOptions(request, runtime);
}

model DeleteLogAnalysisRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='174494xxxx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteLogAnalysisResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='70EACC9C-D07A-4A34-ADA4-77506C42B023'),
}

model DeleteLogAnalysisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLogAnalysisResponseBody(name='body'),
}

/**
 * @summary Disables log dumping for a General-purpose NAS file system.
 *
 * @param request DeleteLogAnalysisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteLogAnalysisResponse
 */
@context("deleteLogAnalysisWithContext")
async function deleteLogAnalysisWithOptions(request: DeleteLogAnalysisRequest, runtime: $RuntimeOptions): DeleteLogAnalysisResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteLogAnalysis',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables log dumping for a General-purpose NAS file system.
 *
 * @param request DeleteLogAnalysisRequest
 * @return DeleteLogAnalysisResponse
 */
async function deleteLogAnalysis(request: DeleteLogAnalysisRequest): DeleteLogAnalysisResponse {
  var runtime = new $RuntimeOptions{};
  return deleteLogAnalysisWithOptions(request, runtime);
}

model DeleteMountTargetRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: 31a8e4\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='174494****'),
  mountTargetDomain?: string(name='MountTargetDomain', description='The domain name of the mount target.

This parameter is required.', example='174494b666-x****.cn-hangzhou.nas.aliyuncs.com'),
}

model DeleteMountTargetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5BC5CB97-9F28-42FE-84A4-0CD0DF42****'),
}

model DeleteMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMountTargetResponseBody(name='body'),
}

/**
 * @summary Deletes a mount target.
 *
 * @description After you delete a mount target, the mount target cannot be restored. Proceed with caution.
 *
 * @param request DeleteMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteMountTargetResponse
 */
@context("deleteMountTargetWithContext")
async function deleteMountTargetWithOptions(request: DeleteMountTargetRequest, runtime: $RuntimeOptions): DeleteMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.mountTargetDomain)) {
    query['MountTargetDomain'] = request.mountTargetDomain;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a mount target.
 *
 * @description After you delete a mount target, the mount target cannot be restored. Proceed with caution.
 *
 * @param request DeleteMountTargetRequest
 * @return DeleteMountTargetResponse
 */
async function deleteMountTarget(request: DeleteMountTargetRequest): DeleteMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return deleteMountTargetWithOptions(request, runtime);
}

model DeleteProtocolMountTargetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified export directory or incur fees.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the specified export directory is deleted.', example='true'),
  exportId?: string(name='ExportId', description='The ID of the export directory.

This parameter is required.', example='exp-123****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123****'),
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.

This parameter is required.', example='ptc-123****'),
}

model DeleteProtocolMountTargetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DeleteProtocolMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProtocolMountTargetResponseBody(name='body'),
}

/**
 * @summary Deletes an export directory of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
 *
 * @param request DeleteProtocolMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProtocolMountTargetResponse
 */
@context("deleteProtocolMountTargetWithContext")
async function deleteProtocolMountTargetWithOptions(request: DeleteProtocolMountTargetRequest, runtime: $RuntimeOptions): DeleteProtocolMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.protocolServiceId)) {
    query['ProtocolServiceId'] = request.protocolServiceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteProtocolMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes an export directory of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
 *
 * @param request DeleteProtocolMountTargetRequest
 * @return DeleteProtocolMountTargetResponse
 */
async function deleteProtocolMountTarget(request: DeleteProtocolMountTargetRequest): DeleteProtocolMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return deleteProtocolMountTargetWithOptions(request, runtime);
}

model DeleteProtocolServiceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified protocol service.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the specified protocol service is deleted.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123****'),
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.

This parameter is required.', example='ptc-123****'),
}

model DeleteProtocolServiceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DeleteProtocolServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteProtocolServiceResponseBody(name='body'),
}

/**
 * @summary Deletes a protocol service of a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   When you delete a protocol service, the export directories in the protocol service are also deleted.
 *
 * @param request DeleteProtocolServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteProtocolServiceResponse
 */
@context("deleteProtocolServiceWithContext")
async function deleteProtocolServiceWithOptions(request: DeleteProtocolServiceRequest, runtime: $RuntimeOptions): DeleteProtocolServiceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.protocolServiceId)) {
    query['ProtocolServiceId'] = request.protocolServiceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteProtocolService',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a protocol service of a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   When you delete a protocol service, the export directories in the protocol service are also deleted.
 *
 * @param request DeleteProtocolServiceRequest
 * @return DeleteProtocolServiceResponse
 */
async function deleteProtocolService(request: DeleteProtocolServiceRequest): DeleteProtocolServiceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteProtocolServiceWithOptions(request, runtime);
}

model DeleteSnapshotRequest {
  snapshotId?: string(name='SnapshotId', description='The snapshot ID.

This parameter is required.', example='s-extreme-snapsho****'),
}

model DeleteSnapshotResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.

Every response returns a unique request ID regardless of whether the request is successful.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DeleteSnapshotResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSnapshotResponseBody(name='body'),
}

/**
 * @summary Deletes a snapshot or cancels a snapshot that is being created.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DeleteSnapshotRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSnapshotResponse
 */
@context("deleteSnapshotWithContext")
async function deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: $RuntimeOptions): DeleteSnapshotResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSnapshot',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a snapshot or cancels a snapshot that is being created.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DeleteSnapshotRequest
 * @return DeleteSnapshotResponse
 */
async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  var runtime = new $RuntimeOptions{};
  return deleteSnapshotWithOptions(request, runtime);
}

model DescribeAccessGroupsRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

Limits:

*   The name must be 3 to 64 characters in length.
*   The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).', example='DEFAULT_VPC_GROUP_NAME'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose Apsara File Storage NAS (NAS) file system
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system.', example='standard'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of permission groups returned per page.

Valid values: 1 to 100.

Default value: 10.', example='2'),
  useUTCDateTime?: boolean(name='UseUTCDateTime', description='Specifies whether to display the creation time of the permission group in UTC.

Valid values:

*   true (default): The time is displayed in UTC.
*   false: The time is not displayed in UTC.', example='true'),
}

model DescribeAccessGroupsResponseBody = {
  accessGroups?: {
    accessGroup?: [ 
    {
      accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.', example='DEFAULT_VPC_GROUP_NAME'),
      accessGroupType?: string(name='AccessGroupType', description='The network type of the permission group. Valid value: **Vpc**.', example='Vpc'),
      createTime?: string(name='CreateTime', description='The time when the permission group was created.', example='2020-01-05T16:00:00Z'),
      description?: string(name='Description', description='The description of the permission group.', example='This is a test access group.'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose Apsara File Storage NAS (NAS) file system
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system.', example='standard'),
      mountTargetCount?: int32(name='MountTargetCount', description='The number of mount targets to which the permission group is attached.', example='0'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      ruleCount?: int32(name='RuleCount', description='The total number of rules in the permission group.', example='0'),
    }
  ](name='AccessGroup')
  }(name='AccessGroups', description='The queried permission groups.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of permission groups returned per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='2514F97E-FFF0-4A1F-BF04-729CEAC6****'),
  totalCount?: int32(name='TotalCount', description='The total number of permission groups.', example='1'),
}

model DescribeAccessGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessGroupsResponseBody(name='body'),
}

/**
 * @summary Queries permission groups.
 *
 * @param request DescribeAccessGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessGroupsResponse
 */
@context("describeAccessGroupsWithContext")
async function describeAccessGroupsWithOptions(request: DescribeAccessGroupsRequest, runtime: $RuntimeOptions): DescribeAccessGroupsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.useUTCDateTime)) {
    query['UseUTCDateTime'] = request.useUTCDateTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAccessGroups',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries permission groups.
 *
 * @param request DescribeAccessGroupsRequest
 * @return DescribeAccessGroupsResponse
 */
async function describeAccessGroups(request: DescribeAccessGroupsRequest): DescribeAccessGroupsResponse {
  var runtime = new $RuntimeOptions{};
  return describeAccessGroupsWithOptions(request, runtime);
}

model DescribeAccessPointRequest {
  accessPointId?: string(name='AccessPointId', description='The ID of the access point.

This parameter is required.', example='ap-ie15yd****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
}

model DescribeAccessPointResponseBody = {
  accessPoint?: {
    ARN?: string(name='ARN', description='The Alibaba Cloud Resource Name (ARN) of the access point.', example='acs:nas:cn-hangzhou:178321033379****:accesspoint/ap-ie15yd****'),
    accessGroup?: string(name='AccessGroup', description='The name of the permission group.', example='test'),
    accessPointId?: string(name='AccessPointId', description='The ID of the access point.', example='ap-ie15yd****'),
    accessPointName?: string(name='AccessPointName', description='The name of the access point.', example='test'),
    createTime?: string(name='CreateTime', description='The time when the access point was created.', example='1709619668276167'),
    domainName?: string(name='DomainName', description='The domain name of the access point.', example='ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com'),
    enabledRam?: boolean(name='EnabledRam', description='Indicates whether the RAM policy is enabled.', example='false'),
    fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
    modifyTime?: string(name='ModifyTime', description='The time when the access point was modified.', example='1709619668276167'),
    posixUser?: {
      posixGroupId?: int32(name='PosixGroupId', description='The ID of the POSIX user group.', example='12'),
      posixSecondaryGroupIds?: [ int32 ](name='PosixSecondaryGroupIds', description='The IDs of the secondary user groups.'),
      posixUserId?: int32(name='PosixUserId', description='The ID of the POSIX user.', example='123'),
    }(name='PosixUser', description='The POSIX user.'),
    regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    rootPath?: string(name='RootPath', description='The root directory.', example='/'),
    rootPathPermission?: {
      ownerGroupId?: int32(name='OwnerGroupId', description='The ID of the owner group.', example='123'),
      ownerUserId?: int32(name='OwnerUserId', description='The owner ID.', example='1'),
      permission?: string(name='Permission', description='The POSIX permission.', example='0755'),
    }(name='RootPathPermission', description='The permissions to create the root directory.'),
    rootPathStatus?: string(name='RootPathStatus', description='The status of the root directory.

Valid values:

*   0: The rootpath status is unknown.
*   1: The rootpath does not exist and may be deleted.
*   2: The rootpath is normal.', example='2'),
    status?: string(name='Status', description='The status of the access point.

Valid values:

*   Active: The access point is available.
*   Inactive: The access point is unavailable.
*   Pending: The access point is being created.
*   Deleting: The access point is being deleted.', example='Active'),
    tags?: [ 
      {
        key?: string(name='Key', example='TestKey'),
        value?: string(name='Value', example='TestValue'),
      }
    ](name='Tags'),
    vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-2zevmwkwyztjuoffg****'),
    vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

You must select the VPC of the Elastic Compute Service (ECS) instance on which you want to mount the file system.', example='vpc-2zesj9afh3y518k9o****'),
  }(name='AccessPoint', description='The information about the access point.'),
  requestId?: string(name='RequestId', description='The request ID.

This parameter is required.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model DescribeAccessPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessPointResponseBody(name='body'),
}

/**
 * @summary Queries the details of an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request DescribeAccessPointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessPointResponse
 */
@context("describeAccessPointWithContext")
async function describeAccessPointWithOptions(request: DescribeAccessPointRequest, runtime: $RuntimeOptions): DescribeAccessPointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAccessPoint',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request DescribeAccessPointRequest
 * @return DescribeAccessPointResponse
 */
async function describeAccessPoint(request: DescribeAccessPointRequest): DescribeAccessPointResponse {
  var runtime = new $RuntimeOptions{};
  return describeAccessPointWithOptions(request, runtime);
}

model DescribeAccessPointsRequest {
  accessGroup?: string(name='AccessGroup', description='The name of the permission group.

This parameter is required for a General-purpose File Storage NAS (NAS) file system.

The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.', example='DEFAULT_VPC_GROUP_NAME'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='174494****'),
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='MTY4NzcxOTcwMjAzMDk2Nzc0MyM4MDM4****'),
  tag?: [ 
    {
      key?: string(name='Key', example='TestKey'),
      value?: string(name='Value', example='TestValue'),
    }
  ](name='Tag'),
}

model DescribeAccessPointsResponseBody = {
  accessPoints?: [ 
    {
      ARN?: string(name='ARN', description='The Alibaba Cloud Resource Name (ARN) of the access point.', example='acs:nas:cn-hangzhou:178321033379****:accesspoint/ap-ie15yd****'),
      accessGroup?: string(name='AccessGroup', description='The name of the permission group.', example='test'),
      accessPointId?: string(name='AccessPointId', description='The ID of the access point.', example='ap-ie15yd****'),
      accessPointName?: string(name='AccessPointName', description='The name of the access point.', example='test'),
      createTime?: string(name='CreateTime', description='The time when the access point was created.', example='1709619668276167'),
      domainName?: string(name='DomainName', description='The domain name of the access point.', example='ap-ie15ydanoz.001014****-w****.cn-hangzhou.nas.aliyuncs.com'),
      enabledRam?: boolean(name='EnabledRam', description='Indicates whether the Resource Access Management (RAM) policy is enabled.', example='false'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
      modifyTime?: string(name='ModifyTime', description='The time when the access point was modified.', example='1709619668276167'),
      posixUser?: {
        posixGroupId?: int32(name='PosixGroupId', description='The ID of the POSIX user group.', example='12'),
        posixSecondaryGroupIds?: [ int32 ](name='PosixSecondaryGroupIds', description='The IDs of the secondary user groups.'),
        posixUserId?: int32(name='PosixUserId', description='The ID of the POSIX user.', example='123'),
      }(name='PosixUser', description='The Portable Operating System Interface for UNIX (POSIX) user.'),
      rootPath?: string(name='RootPath', description='The root directory.', example='/'),
      rootPathPermission?: {
        ownerGroupId?: long(name='OwnerGroupId', description='The ID of the owner group.', example='12'),
        ownerUserId?: long(name='OwnerUserId', description='The owner ID.', example='1'),
        permission?: string(name='Permission', description='The POSIX permission.', example='0755'),
      }(name='RootPathPermission', description='The permissions on the root directory.'),
      rootPathStatus?: string(name='RootPathStatus', description='The status of the root directory.

Valid values:

*   0: The rootpath status is unknown.
*   1: The rootpath does not exist and may be deleted.
*   2: The rootpath is normal.', example='2'),
      status?: string(name='Status', description='The status of the access point.

Valid values:

*   Active: The access point is available.
*   Inactive: The access point is unavailable.
*   Pending: The access point is being created.
*   Deleting: The access point is being deleted.

>  You can mount a file system only if the access point is in the Active state.', example='Active'),
      tags?: [ 
        {
          key?: string(name='Key', example='TestKey'),
          value?: string(name='Value', example='TestValue'),
        }
      ](name='Tags'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-2zevmwkwyztjuoffg****'),
      vpcId?: string(name='VpcId', description='The VPC ID.', example='vpc-2zesj9afh3y518k9o****'),
    }
  ](name='AccessPoints', description='The information about the access point.'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='MTY4NzcxOTcwMjAzMDk2Nzc0MyM4MDM4****'),
  requestId?: string(name='RequestId', description='The request ID.

This parameter is required.', example='6299428C-3861-435D-AE54-9B330A00****'),
  totalCount?: int32(name='TotalCount', description='The total number of access points.', example='20'),
}

model DescribeAccessPointsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessPointsResponseBody(name='body'),
}

/**
 * @summary Queries the information about an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request DescribeAccessPointsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessPointsResponse
 */
@context("describeAccessPointsWithContext")
async function describeAccessPointsWithOptions(request: DescribeAccessPointsRequest, runtime: $RuntimeOptions): DescribeAccessPointsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroup)) {
    query['AccessGroup'] = request.accessGroup;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAccessPoints',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request DescribeAccessPointsRequest
 * @return DescribeAccessPointsResponse
 */
async function describeAccessPoints(request: DescribeAccessPointsRequest): DescribeAccessPointsResponse {
  var runtime = new $RuntimeOptions{};
  return describeAccessPointsWithOptions(request, runtime);
}

model DescribeAccessRulesRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

This parameter is required.', example='vpc-test'),
  accessRuleId?: string(name='AccessRuleId', description='The rule ID.', example='1'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system.
*   extreme: Extreme NAS file system.', example='standard'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='1'),
}

model DescribeAccessRulesResponseBody = {
  accessRules?: {
    accessRule?: [ 
    {
      accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.', example='test'),
      accessRuleId?: string(name='AccessRuleId', description='The ID of the rule.', example='1'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose File Storage NAS (NAS) file system
*   extreme: Extreme NAS file system', example='standard'),
      ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The IPv6 address or CIDR block of the authorized object.', example='2001:250:6000::***'),
      priority?: int32(name='Priority', description='The priority of the rule.

If multiple rules are attached to the authorized object, the rule with the highest priority takes effect.

Valid values: 1 to 100. The value 1 indicates the highest priority.', example='1'),
      RWAccess?: string(name='RWAccess', description='The access permissions of the authorized object on the file system.

Valid values:

*   RDWR (default): the read and write permissions
*   RDONLY: the read-only permissions', example='RDWR'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      sourceCidrIp?: string(name='SourceCidrIp', description='The IP address or CIDR block of the authorized object.'),
      userAccess?: string(name='UserAccess', description='The access permissions for different types of users in the authorized object.

Valid values:

*   no_squash: allows access from root users to the file system.
*   root_squash: grants root users the least permissions as the nobody user.
*   all_squash: grants all users the least permissions as the nobody user.

The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.', example='no_squash'),
    }
  ](name='AccessRule')
  }(name='AccessRules', description='The rules in the permission group.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='86D89E82-4297-4343-8E1E-A2495B35****'),
  totalCount?: int32(name='TotalCount', description='The total number of rules.', example='1'),
}

model DescribeAccessRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccessRulesResponseBody(name='body'),
}

/**
 * @summary Queries the information about rules in a permission group.
 *
 * @param request DescribeAccessRulesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccessRulesResponse
 */
@context("describeAccessRulesWithContext")
async function describeAccessRulesWithOptions(request: DescribeAccessRulesRequest, runtime: $RuntimeOptions): DescribeAccessRulesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAccessRules',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about rules in a permission group.
 *
 * @param request DescribeAccessRulesRequest
 * @return DescribeAccessRulesResponse
 */
async function describeAccessRules(request: DescribeAccessRulesRequest): DescribeAccessRulesResponse {
  var runtime = new $RuntimeOptions{};
  return describeAccessRulesWithOptions(request, runtime);
}

model DescribeAutoSnapshotPoliciesRequest {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', example='sp-extreme-233e6****'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid value: extreme, which indicates Extreme File Storage NAS (NAS) file systems.', example='extreme'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
}

model DescribeAutoSnapshotPoliciesResponseBody = {
  autoSnapshotPolicies?: {
    autoSnapshotPolicy?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', example='sp-extreme-233e6****'),
      autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', description='The name of the automatic snapshot policy.', example='FinanceJoshua'),
      createTime?: string(name='CreateTime', description='The time when the automatic snapshot policy was created.

The time follows the [ISO8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in the `yyyy-MM-ddTHH:mm:ssZ` format. The time is displayed in UTC.', example='2014-04-21T12:08:52Z'),
      fileSystemNums?: int32(name='FileSystemNums', description='The number of file systems to which the automatic snapshot policy applies.', example='2'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.', example='extreme'),
      regionId?: string(name='RegionId', description='The region ID of the automatic snapshot policy.', example='cn-hangzhou'),
      repeatWeekdays?: string(name='RepeatWeekdays', description='The days of a week on which auto snapshots are created.

Auto snapshots are created on a weekly basis.

Valid values: 1 to 7. The values from 1 to 7 indicate 7 days in a week from Monday to Sunday.', example='1,5'),
      retentionDays?: int32(name='RetentionDays', description='The retention period of auto snapshots.

Unit: days.

Valid values:

*   \\\\-1: Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
*   1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.', example='30'),
      status?: string(name='Status', description='The status of the automatic snapshot policy.

Valid values:

*   Creating: The automatic snapshot policy is being created.
*   Available: The automatic snapshot policy is available.', example='Available'),
      timePoints?: string(name='TimePoints', description='The points in time at which auto snapshots are created.

Unit: hours.

Valid values: `0 to 23`. The values from 0 to 23 indicate a total of 24 hours from `00:00 to 23:00`. For example, 1 indicates 01:00. A maximum of 24 points in time can be returned. Multiple points in time are separated with commas (,).', example='4,19'),
    }
  ](name='AutoSnapshotPolicy')
  }(name='AutoSnapshotPolicies', description='The queried automatic snapshot policies.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  totalCount?: int32(name='TotalCount', description='The total number of automatic snapshot policies.', example='2'),
}

model DescribeAutoSnapshotPoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoSnapshotPoliciesResponseBody(name='body'),
}

/**
 * @summary Queries automatic snapshot policies.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DescribeAutoSnapshotPoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoSnapshotPoliciesResponse
 */
@context("describeAutoSnapshotPoliciesWithContext")
async function describeAutoSnapshotPoliciesWithOptions(request: DescribeAutoSnapshotPoliciesRequest, runtime: $RuntimeOptions): DescribeAutoSnapshotPoliciesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyId)) {
    query['AutoSnapshotPolicyId'] = request.autoSnapshotPolicyId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAutoSnapshotPolicies',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries automatic snapshot policies.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DescribeAutoSnapshotPoliciesRequest
 * @return DescribeAutoSnapshotPoliciesResponse
 */
async function describeAutoSnapshotPolicies(request: DescribeAutoSnapshotPoliciesRequest): DescribeAutoSnapshotPoliciesResponse {
  var runtime = new $RuntimeOptions{};
  return describeAutoSnapshotPoliciesWithOptions(request, runtime);
}

model DescribeAutoSnapshotTasksRequest {
  autoSnapshotPolicyIds?: string(name='AutoSnapshotPolicyIds', description='The IDs of automatic snapshot policies.

You can specify a maximum of 100 policy IDs. If you want to query the tasks of multiple automatic snapshot policies, you must separate the policy IDs with commas (,).', example='sp-extreme-233e6****,sp-extreme-233e6****, sp-extreme-233e6****'),
  fileSystemIds?: string(name='FileSystemIds', description='The ID of the file system.

You can specify a maximum of 100 file system IDs. If you want to query the snapshots of multiple file systems, you must separate the file system IDs with commas (,).', example='extreme-233e6****,extreme -23vbp****,extreme -23vas****'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid value: extreme, which indicates Extreme NAS file systems.

This parameter is required.', example='extreme'),
  pageNumber?: int32(name='PageNumber', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  pageSize?: int32(name='PageSize', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
}

model DescribeAutoSnapshotTasksResponseBody = {
  autoSnapshotTasks?: {
    autoSnapshotTask?: [ 
    {
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', example='sp-extreme-233e6****'),
      sourceFileSystemId?: string(name='SourceFileSystemId', description='The ID of the file system.', example='extreme-233e6****'),
    }
  ](name='AutoSnapshotTask')
  }(name='AutoSnapshotTasks', description='The queried automatic snapshot tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  totalCount?: int32(name='TotalCount', description='The total number of automatic snapshot tasks.', example='9'),
}

model DescribeAutoSnapshotTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoSnapshotTasksResponseBody(name='body'),
}

/**
 * @summary Queries automatic snapshot tasks.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 *
 * @param request DescribeAutoSnapshotTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAutoSnapshotTasksResponse
 */
@context("describeAutoSnapshotTasksWithContext")
async function describeAutoSnapshotTasksWithOptions(request: DescribeAutoSnapshotTasksRequest, runtime: $RuntimeOptions): DescribeAutoSnapshotTasksResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyIds)) {
    query['AutoSnapshotPolicyIds'] = request.autoSnapshotPolicyIds;
  }
  if (!$isNull(request.fileSystemIds)) {
    query['FileSystemIds'] = request.fileSystemIds;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeAutoSnapshotTasks',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries automatic snapshot tasks.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support the snapshot feature.
 *
 * @param request DescribeAutoSnapshotTasksRequest
 * @return DescribeAutoSnapshotTasksResponse
 */
async function describeAutoSnapshotTasks(request: DescribeAutoSnapshotTasksRequest): DescribeAutoSnapshotTasksResponse {
  var runtime = new $RuntimeOptions{};
  return describeAutoSnapshotTasksWithOptions(request, runtime);
}

model DescribeBlackListClientsRequest {
  clientIP?: string(name='ClientIP', description='The IP address of the client.', example='192.168.0.0'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123458****'),
  regionId?: string(name='RegionId', description='The ID of the region where the file system resides.

This parameter is required.', example='cn-hangzhou'),
}

model DescribeBlackListClientsResponseBody = {
  clients?: string(name='Clients', description='The IDs of clients and the status of each client. The parameter value is a JSON string, for example, `{"client1": "EVICTING","client2":"EVICTED"}`.

Available client statuses include:

*   EVICTING: The client is being evicted.
*   EVICTED: The client is evicted.
*   ACCEPTING: The write access to the file system is being granted to the client.
*   ACCEPTABLE: The write access to the file system is granted to the client.', example='{"client1": "EVICTING","client2":"EVICTED"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211A5C3'),
}

model DescribeBlackListClientsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBlackListClientsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeBlackListClients is deprecated
 *
 * @summary Queries the status of clients in the blacklist of a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request DescribeBlackListClientsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBlackListClientsResponse
 */
// Deprecated
@context("describeBlackListClientsWithContext")
async function describeBlackListClientsWithOptions(request: DescribeBlackListClientsRequest, runtime: $RuntimeOptions): DescribeBlackListClientsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientIP)) {
    query['ClientIP'] = request.clientIP;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeBlackListClients',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI DescribeBlackListClients is deprecated
 *
 * @summary Queries the status of clients in the blacklist of a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request DescribeBlackListClientsRequest
 * @return DescribeBlackListClientsResponse
 */
// Deprecated
async function describeBlackListClients(request: DescribeBlackListClientsRequest): DescribeBlackListClientsResponse {
  var runtime = new $RuntimeOptions{};
  return describeBlackListClientsWithOptions(request, runtime);
}

model DescribeDataFlowSubTasksRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='bmcpfs-370lx1ev9ss27o0****'),
  filters?: [ 
    {
      key?: string(name='Key', description='The filter name.

Valid values:

*   DataFlowIds: filters data flow subtasks by data flow ID.
*   DataFlowTaskIds: filters data flow subtasks by data flow task ID.
*   DataFlowSubTaskIds: filters data flow subtasks by data streaming task ID.
*   Status: filters data flow subtasks by status.
*   SrcFilePath: filters data flow subtasks by source file path.
*   DstFilePath: filters data flow subtasks by destination file path.', example='DataFlowSubTaskIds'),
      value?: string(name='Value', description='The filter value. This parameter does not support wildcards.

*   If Key is set to DataFlowIds, set Value to a data flow ID or a part of the data flow ID. You can specify a data flow ID or a group of data flow IDs. You can specify a maximum of 10 data flow IDs. Example: `df-194433a5be31****` or `df-194433a5be31****,df-244433a5be31****`.
*   If Key is set to DataFlowTaskIds, set Value to a data flow task ID or a part of the data flow task ID. You can specify a data flow task ID or a group of data flow task IDs. You can specify a maximum of 10 data flow task IDs. Example:  `task-38aa8e890f45****` or `task-38aa8e890f45****,task-27aa8e890f45****`.
*   If Key is set to DataFlowSubTaskIds, set Value to a data streaming task ID or a part of the data streaming task ID. You can specify a data streaming task ID or a group of data streaming task IDs. You can specify a maximum of 10 data streaming task IDs. Example: ` subTaskId-370kyfmyknxcyzw****  `or `subTaskId-370kyfmyknxcyzw****,subTaskId-280kyfmyknxcyzw****`.
*   If Key is set to Status, set Value to the status of the data flow task. The status can be EXPIRED, CREATED, RUNNING, COMPLETE, CANCELING, FAILED, or CANCELED. Combined query is supported.
*   If Key is set to SrcFilePath, set Value to the path of the source file. The path can be up to 1,023 characters in length.
*   If Key is set to DstFilePath, set Value to the path of the destination file. The path can be up to 1,023 characters in length.', example='subTaskId-370kyfmyknxcyzw****'),
    }
  ](name='Filters', description='The filter that is used to query data streaming tasks.', nullable=false),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

*   Valid values: 20 to 100.
*   Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='iWk0AQAAAAAvY2FzZS8='),
}

model DescribeDataFlowSubTasksResponseBody = {
  dataFlowSubTask?: {
    dataFlowSubTask?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the data streaming task was created.', example='2024-07-01 19:59:29'),
      dataFlowId?: string(name='DataFlowId', description='The ID of the data flow.', example='df-194433a5be31****'),
      dataFlowSubTaskId?: string(name='DataFlowSubTaskId', description='The ID of the data streaming task.', example='subTaskId-370kyfmyknxcyzw****'),
      dataFlowTaskId?: string(name='DataFlowTaskId', description='The ID of the data flow task.', example='task-38aa8e890f45****'),
      dstFilePath?: string(name='DstFilePath', description='The path of the destination file. Limits:

*   The path must be 1 to 1,023 characters in length.
*   The path must be encoded in UTF-8.
*   The path must start with a forward slash (/).
*   The path must end with the file name.', example='/mnt/file.png'),
      endTime?: string(name='EndTime', description='The time when the data streaming task ended.', example='2024-07-04 11:14:22'),
      errorMsg?: string(name='ErrorMsg', description='The error message returned when the task failed.'),
      fileDetail?: {
        checksum?: string(name='Checksum', description='The checksum. Format example: crc64:123456.', example='crc64:850309505450944****'),
        modifyTime?: long(name='ModifyTime', description='The time when the file was modified. The value is a UNIX timestamp. Unit: ns.', example='1721167603'),
        size?: long(name='Size', description='The file size. Unit: bytes.', example='68'),
      }(name='FileDetail', description='The file information.'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='bmcpfs-370lx1ev9ss27o0****'),
      progress?: int32(name='Progress', description='The progress of the data streaming task. Valid values: 0 to 10000.', example='10000'),
      progressStats?: {
        actualBytes?: long(name='ActualBytes', description='The actual amount of data for which the data flow task is complete. Unit: bytes.', example='68'),
        averageSpeed?: long(name='AverageSpeed', description='The average flow velocity. Unit: bytes/s.', example='34'),
        bytesDone?: long(name='BytesDone', description='The amount of data (including skipped data) for which the data flow task is complete. Unit: bytes.', example='68'),
        bytesTotal?: long(name='BytesTotal', description='The amount of data scanned on the source. Unit: bytes.', example='68'),
      }(name='ProgressStats', description='The progress information about data streaming tasks.'),
      srcFilePath?: string(name='SrcFilePath', description='The path of the source file. Limits:

*   The path must be 1 to 1,023 characters in length.
*   The path must be encoded in UTF-8.
*   The path must start with a forward slash (/).
*   The path must end with the file name.', example='/test/file.png'),
      startTime?: string(name='StartTime', description='The time when the data streaming task started.', example='2024-07-03 10:43:16'),
      status?: string(name='Status', description='The status of the data streaming task. Valid values:

*   EXPIRED: The task is terminated.
*   CREATED: The task is created.
*   RUNNING: The task is running.
*   COMPLETE: The task is complete.
*   CANCELING: The task is being canceled.
*   FAILED: The task failed to be executed.
*   CANCELED: The task is canceled.', example='COMPLETE'),
    }
  ](name='DataFlowSubTask')
  }(name='DataFlowSubTask', description='The details about data streaming tasks.'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='pUJaUwAAAABhdGUyNTk1MQ=='),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DescribeDataFlowSubTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataFlowSubTasksResponseBody(name='body'),
}

/**
 * @summary Queries data flow subtasks in batches.
 *
 * @description Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 *
 * @param request DescribeDataFlowSubTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataFlowSubTasksResponse
 */
@context("describeDataFlowSubTasksWithContext")
async function describeDataFlowSubTasksWithOptions(request: DescribeDataFlowSubTasksRequest, runtime: $RuntimeOptions): DescribeDataFlowSubTasksResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDataFlowSubTasks',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries data flow subtasks in batches.
 *
 * @description Only Cloud Parallel File Storage (CPFS) for LINGJUN V2.6.0 and later support this operation. You can view the version information on the file system details page in the console.
 *
 * @param request DescribeDataFlowSubTasksRequest
 * @return DescribeDataFlowSubTasksResponse
 */
async function describeDataFlowSubTasks(request: DescribeDataFlowSubTasksRequest): DescribeDataFlowSubTasksResponse {
  var runtime = new $RuntimeOptions{};
  return describeDataFlowSubTasksWithOptions(request, runtime);
}

model DescribeDataFlowTasksRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*. .

This parameter is required.', example='cpfs-099394bd928c****'),
  filters?: [ 
    {
      key?: string(name='Key', description='The filter name.

Valid value:

*   DataFlowIds: filters dataflow tasks by dataflow ID.
*   TaskIds: filters dataflow tasks by task ID.
*   Originator: filters dataflow tasks by task initiator.
*   TaskActions: filters dataflow tasks by task type.
*   DataTypes: filters dataflow tasks by data type.
*   Status: filters dataflow tasks by dataflow status.
*   CreateTimeBegin: filters dataflow tasks that are created after a specified time.
*   CreateTimeEnd: filters dataflow tasks that are created before a specified time.
*   StartTimeBegin: filters dataflow tasks that are started after a specified time.
*   StartTimeEnd: filters dataflow tasks that are started before a specified time.
*   EndTimeBegin: filters dataflow tasks that are stopped after a specified time.
*   EndTimeEnd: filters dataflow tasks that are stopped before a specified time.', example='DataFlowIds'),
      value?: string(name='Value', description='The value of the filter. This parameter does not support wildcards.

*   If Key is set to DataFlowIds, set Value to a dataflow ID or a part of the dataflow ID. You can specify a dataflow ID or a group of dataflow IDs. You can specify a maximum of 10 dataflow IDs. Example: `df-194433a5be31****` or `df-194433a512a2****,df-234533a5be31****`.
*   If Key is set to TaskId, set Value to a dataflow task ID or a part of the dataflow task ID. You can specify a dataflow task ID or a group of dataflow task IDs. You can specify a maximum of 10 dataflow task IDs. Example: `task-38aa8e890f45****` or `task-38aa8e890f45****,task-29ae8e890f45****`.
*   If Key is set to TaskActions, set Value to the type of dataflow task. The task type can be **Import**, **Export**, **Evict**, **Inventory**, **StreamImport**, or **StreamExport**. Combined query is supported. CPFS for Lingjun supports only the Import, Export, StreamImport, and StreamExport tasks. Only CPFS for Lingjun V2.6.0 and later support the StreamImport and StreamExport tasks.
*   If Key is set to DataTypes, set Value to the data type of the dataflow task. The data type can be MetaAndData, Metadata, or Data. Combined query is supported.
*   If Key is set to Originator, set Value to the initiator of the dataflow task. The initiator can be User or System.
*   If Key is set to Status, set Value to the status of the dataflow task. The status can be Pending, Executing, Failed, Completed, Canceling, or Canceled. Combined query is supported.
*   If Key is set to CreateTimeBegin, set Value to the beginning of the time range to create the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.
*   If Key is set to CreateTimeEnd, set Value to the end of the time range to create the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.
*   If Key is set to StartTimeBegin, set Value to the beginning of the time range to start the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.
*   If Key is set to StartTimeEnd, set Value to the end of the time range to start the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.
*   If Key is set to EndTimeBegin, set Value to the beginning of the time range to stop the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.
*   If Key is set to EndTimeEnd, set Value to the end of the time range to stop the dataflow task. Time format: `yyyy-MM-ddThh:mmZ`.', example='dfid-12345678'),
    }
  ](name='Filters', description='The details about filters.', nullable=false),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100.

Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  withReports?: boolean(name='WithReports', description='Whether to query report information.

*   True (default)
*   False

> 

*   Set it to False to speed up the query.

*   Only CPFS for Lingjun supports this parameter.', example='True'),
}

model DescribeDataFlowTasksResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
  taskInfo?: {
    task?: [ 
    {
      conflictPolicy?: string(name='ConflictPolicy', description='The conflict policy for files with the same name. Valid values:

*   SKIP_THE_FILE: skips files with the same name.
*   KEEP_LATEST: compares the update time and keeps the latest version.
*   OVERWRITE_EXISTING: forcibly overwrites the existing file.', example='KEEP_LATEST'),
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2021-08-04 18:27:35'),
      dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.', example='dfid-194433a5be3****'),
      dataType?: string(name='DataType', description='The type of data on which operations are performed by the dataflow task. The following information is displayed:

*   Metadata: the metadata of a file, including the timestamp, ownership, and permission information of the file. If you select Metadata, only the metadata of the file is imported. You can only query the file. When you access the file data, the file is loaded from the source storage as required.
*   Data: the data blocks of the file.
*   MetaAndData: the metadata and data blocks of the file.

>  CPFS for Lingjun supports only the MetaAndData type.', example='Metadata'),
      directory?: string(name='Directory', description='The directory in which the dataflow task is executed.', example='/path_in_cpfs/'),
      dstDirectory?: string(name='DstDirectory', description='The directory mapped to the dataflow task.', example='/path_in_cpfs/'),
      endTime?: string(name='EndTime', description='The end time of the task.', example='2021-08-04 18:27:35'),
      errorMsg?: string(name='ErrorMsg', description='The cause of the task exception.

>  If this parameter is not returned or the return value is empty, no error occurs.'),
      fileSystemPath?: string(name='FileSystemPath', description='The directory of the fileset in the CPFS file system.

Limits:

*   The directory must be 2 to 1024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).
*   The directory must be a fileset directory in the CPFS file system.

>  Only CPFS supports this parameter.', example='/a/b/c/'),
      filesystemId?: string(name='FilesystemId', description='The ID of the file system.', example='cpfs-099394bd928c****'),
      fsPath?: string(name='FsPath', description='The path of the smart directory.', example='/aa/'),
      includes?: string(name='Includes', description='Filters subdirectories and transfers their contents.

>  Only CPFS for Lingjun supports this operation.', example='["/test/","/test1/"]'),
      originator?: string(name='Originator', description='The initiator of the dataflow task. The following information is displayed:

*   User: The task is initiated by a user.
*   System: The task is automatically initiated by CPFS based on the automatic update interval.

>  Only CPFS supports this parameter.', example='User'),
      progress?: long(name='Progress', description='The progress of the dataflow task. The number of operations that have been performed by the dataflow task.', example='240'),
      progressStats?: {
        actualBytes?: long(name='ActualBytes', description='The actual amount of data for which the dataflow task is complete. Unit: bytes.', example='131092971520'),
        actualFiles?: long(name='ActualFiles', description='The actual number of files for which the dataflow task is complete.', example='3'),
        averageSpeed?: long(name='AverageSpeed', description='The average flow velocity. Unit: bytes/s.', example='342279299'),
        bytesDone?: long(name='BytesDone', description='The amount of data (including skipped data) for which the dataflow task is complete. Unit: bytes.', example='131092971520'),
        bytesTotal?: long(name='BytesTotal', description='The amount of data scanned on the source. Unit: bytes.', example='131092971520'),
        filesDone?: long(name='FilesDone', description='The number of files (including skipped files) for which the dataflow task is complete.', example='3'),
        filesTotal?: long(name='FilesTotal', description='The number of files scanned on the source.', example='3'),
        remainTime?: long(name='RemainTime', description='The estimated remaining execution time. Unit: seconds.', example='437'),
      }(name='ProgressStats', description='The progress of the dataflow task.'),
      reportPath?: string(name='ReportPath', description='The save path of dataflow task reports in the CPFS file system.

*   The task reports for a CPFS file system are generated in the `.dataflow_report` directory of the CPFS file system.
*   CPFS for Lingjun returns an OSS download link for you to download the task reports.', example='/path_in_cpfs/reportfile.cvs', deprecated=true),
      reports?: {
        report?: [ 
        {
          name?: string(name='Name', description='The name of the report.

*   CPFS:

    TotalFilesReport: task reports.

*   CPFS for Lingjun:

    *   FailedFilesReport: failed file reports.
    *   SkippedFilesReport: skipped file reports.
    *   SuccessFilesReport: successful file reports.', example='TotalFilesReport'),
          path?: string(name='Path', description='The report URL.'),
        }
      ](name='Report')
      }(name='Reports', description='The reports.

> 

*   Streaming tasks do not support reports.

*   If the WithReport parameter is set to True, the CPFS for Lingjun report data is returned.

*   Only CPFS for Lingjun supports the WithReport parameter.'),
      sourceStorage?: string(name='SourceStorage', description='The access path of the source storage. Format: `<storage type>://[<account id>:]<path>`.

Among them:

*   storage type: Only Object Storage Service (OSS) is supported.

*   account id: the UID of the account of the source storage.

*   path: the name of the OSS bucket. Limits:

    *   The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
    *   The name can be up to 128 characters in length.
    *   The name must be encoded in UTF-8.

> 

*   The OSS bucket must be an existing bucket in the region.

*   Only CPFS for Lingjun V2.6.0 and later support the account id parameter.', example='oss://bucket1'),
      startTime?: string(name='StartTime', description='The start time of the task.', example='2021-08-04 18:27:35'),
      status?: string(name='Status', description='The status of the dataflow task. The following information is displayed:

*   Pending: The dataflow task has been created and has not started.
*   Executing: The dataflow task is being executed.
*   Failed: The dataflow task failed to be executed. You can view the cause of the failure in the dataflow task report.
*   Completed: The dataflow task is completed. You can check that all the files have been correctly transferred in the dataflow task report.
*   Canceled: The dataflow task is canceled and is not completed.
*   Canceling: The dataflow task is being canceled.', example='Executing'),
      taskAction?: string(name='TaskAction', description='The type of the dataflow task. The following information is displayed:

*   Import: imports data stored in the source storage to a CPFS file system.
*   Export: exports specified data from a CPFS file system to the source storage.
*   StreamImport: imports the specified data from the source storage to a CPFS file system in streaming mode.
*   StreamExport: exports specified data from a CPFS file system to the source storage in streaming mode.
*   Evict: releases the data blocks of a file in a CPFS file system. After the eviction, only the metadata of the file is retained in the CPFS file system. You can still query the file. However, the data blocks of the file are cleared and do not occupy the storage space in the CPFS file system. When you access the file data, the file is loaded from the source storage as required.
*   Inventory: obtains the inventory list managed by a dataflow from the CPFS file system, providing the cache status of inventories in the dataflow.

>  Only CPFS for Lingjun V2.6.0 and later support StreamImport and StreamExport.', example='Import'),
      taskId?: string(name='TaskId', description='The ID of the dataflow task.', example='taskId-12345678'),
      transferFileListPath?: string(name='TransferFileListPath', description='Specify the OSS directory and synchronize data based on the content of the CSV file in the OSS directory.

>  Only CPFS for Lingjun supports this operation.', example='/path_in_cpfs/'),
    }
  ](name='Task')
  }(name='TaskInfo', description='The information about dataflow tasks.'),
}

model DescribeDataFlowTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataFlowTasksResponseBody(name='body'),
}

/**
 * @summary Queries the details of dataflow tasks.
 *
 * @description Only CPFS V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support this operation. You can view the version information on the file system details page in the console.
 *
 * @param request DescribeDataFlowTasksRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataFlowTasksResponse
 */
@context("describeDataFlowTasksWithContext")
async function describeDataFlowTasksWithOptions(request: DescribeDataFlowTasksRequest, runtime: $RuntimeOptions): DescribeDataFlowTasksResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.withReports)) {
    query['WithReports'] = request.withReports;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDataFlowTasks',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of dataflow tasks.
 *
 * @description Only CPFS V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support this operation. You can view the version information on the file system details page in the console.
 *
 * @param request DescribeDataFlowTasksRequest
 * @return DescribeDataFlowTasksResponse
 */
async function describeDataFlowTasks(request: DescribeDataFlowTasksRequest): DescribeDataFlowTasksResponse {
  var runtime = new $RuntimeOptions{};
  return describeDataFlowTasksWithOptions(request, runtime);
}

model DescribeDataFlowsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  filters?: [ 
    {
      key?: string(name='Key', description='The filter name. Valid value:

*   DataFlowIds: filters dataflow tasks by dataflow ID.
*   FsetIds: filters dataflows by fileset ID.
*   FileSystemPath: filters dataflows based on the path of a fileset in a CPFS file system.
*   SourceStorage: filters dataflows based on the access path of the source storage.
*   ThroughputList: filters dataflows based on dataflow throughput.
*   Description: filters dataflows based on the fileset description.
*   Status: filters dataflows based on dataflow status.', example='FsetIds'),
      value?: string(name='Value', description='The value of the filter. This parameter does not support wildcards.

*   If Key is set to DataFlowIds, set Value to a dataflow ID or a part of the dataflow ID. You can specify a dataflow ID or a group of dataflow IDs. You can specify a maximum of 10 dataflow IDs. Example: `df-194433a5be31****` or `df-194433a512a2****,df-234533a5be31****`.
*   If Key is set to FsetIds, set Value to a fileset ID or a part of the fileset ID. You can specify a fileset ID or a group of fileset IDs. You can specify a maximum of 10 fileset IDs. For example, `fset-1902718ea0ae****` or `fset-235718ea0ae****,fset-5122718ea0ae****`.
*   If Key is set to FileSystemPath, set Value to the path or a part of the path of a fileset in a CPFS file system. The value of the parameter must be 1 to 1,024 characters in length.
*   If Key is set to SourceStorage, set Value to the access path or a part of the access path of the source storage. The path can be up to 1,024 characters in length.
*   If Key is set to ThroughputList, set Value to the dataflow throughput. Combined query is supported.
*   If Key is set to Description, set Value to a dataflow description or a part of the dataflow description.
*   If Key is set to Status, set Value to the dataflow status.
*   If Key is set to SourceStoragePath, set Value to the access path or a part of the access path of the source storage. The path can be up to 1,024 characters in length.', example='FsetIds'),
    }
  ](name='Filters', description='The filter that is used to query dataflows.', nullable=true),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
}

model DescribeDataFlowsResponseBody = {
  dataFlowInfo?: {
    dataFlow?: [ 
    {
      autoRefresh?: {
        autoRefresh?: [ 
        {
          refreshPath?: string(name='RefreshPath', description='The automatic update directory. CPFS automatically checks whether the source data only in the directory is updated and imports the updated data.

Limits:

*   The directory must be 2 to 1,024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).

>  The directory must be an existing directory in the CPFS file system and must be in a fileset where the dataflow is enabled.', example='/prefix1/prefix2/'),
        }
      ](name='AutoRefresh')
      }(name='AutoRefresh', description='The details about automatic update policies.

>  Only CPFS supports this parameter.'),
      autoRefreshInterval?: long(name='AutoRefreshInterval', description='The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minutes.

Valid values: 5 to 526600. Default value: 10.

>  Only CPFS supports this parameter.', example='10'),
      autoRefreshPolicy?: string(name='AutoRefreshPolicy', description='The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy. The following information is displayed:

*   None: Updated data in the source storage is not automatically imported into the CPFS file system. You can run a dataflow task to import the updated data from the source storage.
*   ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.

>  Only CPFS is supported.', example='None'),
      createTime?: string(name='CreateTime', description='The time when the fileset was created.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

>  Only CPFS supports this parameter.', example='2021-09-30T10:08:08Z'),
      dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.', example='df-194433a5be31****'),
      description?: string(name='Description', description='The description of the dataflow.

Limits:

*   The name must be 2 to 128 characters in length and
*   start with a letter but cannot start with `http://` or `https://`.
*   The name can contain digits, letters, colons (:), underscores (_), and hyphens (-).', example='test'),
      errorMessage?: string(name='ErrorMessage', description='The error message. Valid values:

*   None (default): The dataflow status is normal.
*   SourceStorageUnreachable: The access path of the source storage is not found.
*   ThroughputTooLow: The dataflow throughput is low.', example='SourceStorageUnreachable'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='cpfs-099394bd928c****'),
      fileSystemPath?: string(name='FileSystemPath', description='The directory of the fileset in the CPFS file system.

Limits:

*   The directory must be 2 to 1024 characters in length.
*   The directory must be encoded in UTF-8.
*   The directory must start and end with a forward slash (/).
*   The directory must be a fileset directory in the CPFS file system.

>  Only CPFS is supported.', example='/a/b/c/'),
      fsetDescription?: string(name='FsetDescription', description='The description of the automatic update.

>  Only CPFS supports this parameter.', example='FsetTest'),
      fsetId?: string(name='FsetId', description='The fileset ID.

>  Only CPFS supports this parameter.', example='fset-1902718ea0ae****'),
      sourceSecurityType?: string(name='SourceSecurityType', description='The type of security mechanism for the source storage. This parameter must be specified if the source storage is accessed with a security mechanism. Valid value:

*   Null (default): The OSS bucket can be accessed without a security mechanism.
*   SSL: The source storage must be accessed with an SSL certificate.', example='SSL'),
      sourceStorage?: string(name='SourceStorage', description='The access path of the source storage. Format: `<storage type>://[<account id>:]<path>`.

Among them:

*   storage type: Only OSS is supported.

*   account id: The UID of the account of the source storage.

*   path: The name of the OSS bucket.

    *   The name can contain only lowercase letters, digits, and hyphens (-). The name must start and end with a lowercase letter or digit.
    *   The name must be 8 to 128 characters in length.
    *   Must be encoded in UTF-8.
    *   The name cannot start with http:// or https://.

> 

*   The OSS bucket must be an existing bucket in the region.

*   Only CPFS for Lingjun V2.6.0 and later support the account id parameter.', example='oss://bucket1'),
      sourceStoragePath?: string(name='SourceStoragePath', description='The access path in the bucket of the source storage.

>  Only CPFS for Lingjun supports this parameter.', example='/prefix/'),
      status?: string(name='Status', description='The dataflow status. The following information is displayed:

*   Starting: The dataflow is being created or enabled.
*   Running: The dataflow has been created and is running properly.
*   Updating: The dataflow is being modified. For example, the dataflow throughput is increased and the automatic update interval is modified.
*   Deleting: The dataflow is being deleted.
*   Stopping: The dataflow is being disabled.
*   Stopped: The dataflow has been disabled.
*   Misconfigured: The dataflow configuration is abnormal. For example, the source storage is inaccessible, and the automatic update cannot be completed due to low dataflow throughput.', example='Running'),
      throughput?: long(name='Throughput', description='The maximum dataflow throughput. Unit: MB/s. Valid value:

*   600
*   1200
*   1500

> 

*   The dataflow throughput must be less than the I/O throughput of the file system.

*   Only CPFS supports this parameter.', example='600'),
      updateTime?: string(name='UpdateTime', description='The time when the fileset was last updated.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

>  Only CPFS supports this parameter.', example='2021-09-30T10:08:08Z'),
    }
  ](name='DataFlow')
  }(name='DataFlowInfo', description='The dataflow details.'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model DescribeDataFlowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDataFlowsResponseBody(name='body'),
}

/**
 * @summary Queries the dataflows of a CPFS file system.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   In Filters, FsetIds, DataFlowlds, SourceStorage, ThroughputList, and Status support exact match only. FileSystemPath, Description, and SourceStoragePath support fuzzy match.
 * *   Combined query is supported.
 *
 * @param request DescribeDataFlowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDataFlowsResponse
 */
@context("describeDataFlowsWithContext")
async function describeDataFlowsWithOptions(request: DescribeDataFlowsRequest, runtime: $RuntimeOptions): DescribeDataFlowsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDataFlows',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the dataflows of a CPFS file system.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   In Filters, FsetIds, DataFlowlds, SourceStorage, ThroughputList, and Status support exact match only. FileSystemPath, Description, and SourceStoragePath support fuzzy match.
 * *   Combined query is supported.
 *
 * @param request DescribeDataFlowsRequest
 * @return DescribeDataFlowsResponse
 */
async function describeDataFlows(request: DescribeDataFlowsRequest): DescribeDataFlowsResponse {
  var runtime = new $RuntimeOptions{};
  return describeDataFlowsWithOptions(request, runtime);
}

model DescribeDirQuotasRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.

Valid values: 1 to 100.', example='1'),
  path?: string(name='Path', description='The absolute path of a directory.

If you do not specify this parameter, all directories for which quotas are created are returned.', example='/data/sub1'),
}

model DescribeDirQuotasResponseBody = {
  dirQuotaInfos?: [ 
    {
      dirInode?: string(name='DirInode', description='The inode number of the directory.', example='1123'),
      path?: string(name='Path', description='The absolute path of a directory.', example='/data/sub1'),
      status?: string(name='Status', description='The status of the quota created for the directory. Valid values: Initializing and Normal. The Initializing state indicates that the quota is being created. The Normal state indicates that the quota is created.', example='Normal'),
      userQuotaInfos?: [ 
        {
          fileCountLimit?: long(name='FileCountLimit', description='The maximum number of files that a user can create in the directory.', example='10000'),
          fileCountReal?: long(name='FileCountReal', description='The total number of files that a user has created in the directory.', example='5100'),
          quotaType?: string(name='QuotaType', description='The type of the quota. Valid values: Accounting and Enforcement.', example='Accounting'),
          sizeLimit?: long(name='SizeLimit', description='The maximum size of files that a user can create in the directory. Unit: GiB.', example='1024'),
          sizeReal?: long(name='SizeReal', description='The total size of files that a user has created in the directory. Unit: GiB.', example='800'),
          sizeRealInByte?: long(name='SizeRealInByte', description='The total size of files that a user has created in the directory. Unit: bytes.', example='858995833870'),
          userId?: string(name='UserId', description='The ID of the user that you specify to create a quota for the directory. The value depends on the value of the UserType parameter. Valid values: Uid and Gid.', example='500'),
          userType?: string(name='UserType', description='The type of user. Valid values: Uid, Gid, and AllUsers.

*   If Uid or Gid is returned, a value is returned for UserId.
*   If AllUsers is returned, UserId is empty.', example='Uid'),
        }
      ](name='UserQuotaInfos', description='The information about quotas for all users.'),
    }
  ](name='DirQuotaInfos', description='The queried directory quotas.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='5BC5CB97-9F28-42FE-84A4-0CD0DF42****'),
  totalCount?: int32(name='TotalCount', description='The total number of directories.', example='1'),
}

model DescribeDirQuotasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDirQuotasResponseBody(name='body'),
}

/**
 * @summary Queries the directory quotas of a file system.
 *
 * @description Only General-purpose NAS file systems support the directory quota feature.
 *
 * @param request DescribeDirQuotasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDirQuotasResponse
 */
@context("describeDirQuotasWithContext")
async function describeDirQuotasWithOptions(request: DescribeDirQuotasRequest, runtime: $RuntimeOptions): DescribeDirQuotasResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeDirQuotas',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the directory quotas of a file system.
 *
 * @description Only General-purpose NAS file systems support the directory quota feature.
 *
 * @param request DescribeDirQuotasRequest
 * @return DescribeDirQuotasResponse
 */
async function describeDirQuotas(request: DescribeDirQuotasRequest): DescribeDirQuotasResponse {
  var runtime = new $RuntimeOptions{};
  return describeDirQuotasWithOptions(request, runtime);
}

model DescribeFileSystemStatisticsRequest {
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
}

model DescribeFileSystemStatisticsResponseBody = {
  fileSystemStatistics?: {
    fileSystemStatistic?: [ 
    {
      expiredCount?: int32(name='ExpiredCount', description='The number of expired file systems.', example='1'),
      expiringCount?: int32(name='ExpiringCount', description='The number of expiring file systems.

File systems whose expiration time is less than or equal to seven days away from the current time are counted.', example='1'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.', example='standard'),
      meteredSize?: long(name='MeteredSize', description='The storage usage of the file system.

The value of this parameter is the maximum storage usage of the file system over the last hour.

Unit: bytes.', example='1611'),
      totalCount?: int32(name='TotalCount', description='The number of file systems of the current type.', example='10'),
    }
  ](name='FileSystemStatistic')
  }(name='FileSystemStatistics', description='The statistics of file systems.'),
  fileSystems?: {
    fileSystem?: [ 
    {
      capacity?: long(name='Capacity', description='The capacity of the file system.

Unit: GiB.', example='1'),
      chargeType?: string(name='ChargeType', description='The billing method.

Valid values:

*   Subscription: The subscription billing method is used.
*   PayAsYouGo: The pay-as-you-go billing method is used.
*   Package: A storage plan is attached to the file system.', example='PayAsYouGo'),
      createTime?: string(name='CreateTime', description='The time when the NAS file system was created.', example='2017-05-27T15:43:06CST'),
      description?: string(name='Description', description='The description of the file system.', example='31a8e48eda'),
      expiredTime?: string(name='ExpiredTime', description='The time when the file system expires.', example='2017-08-27T15:43:06CST'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='109c04****'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose NAS file system
*   extreme: Extreme NAS file system
*   cpfs: CPFS file system', example='standard'),
      meteredIASize?: long(name='MeteredIASize', description='The storage usage of the Infrequent Access (IA) storage medium.

Unit: bytes.', example='362832'),
      meteredSize?: long(name='MeteredSize', description='The storage usage of the file system.

The value of this parameter is the maximum storage usage of the file system over the last hour. Unit: bytes.', example='1611661312'),
      packages?: {
        package?: [ 
        {
          expiredTime?: string(name='ExpiredTime', description='The end time of the validity period for the storage plan.', example='2020-01-05T16:00:00Z'),
          packageId?: string(name='PackageId', description='The ID of the storage plan.', example='naspackage-0be9c4b624-37****'),
          size?: long(name='Size', description='The capacity of the storage plan.', example='107374182400'),
          startTime?: string(name='StartTime', description='The start time of the validity period for the storage plan.', example='2019-12-05T01:40:56Z'),
        }
      ](name='Package')
      }(name='Packages', description='The information about storage plans.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system.

Valid values:

*   NFS: Network File System (NFS)
*   SMB: Server Message Block (SMB)
*   cpfs: the protocol type supported by the CPFS file system', example='NFS'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      status?: string(name='Status', description='The status of the file system.

This parameter is returned for Extreme NAS file systems and Cloud Parallel File Storage (CPFS) file systems. Valid values:

*   Pending: The file system is being created or modified.
*   Running: The file system is available. Before you create a mount target for the file system, make sure that the file system is in the Running state.
*   Stopped: The file system is unavailable.
*   Extending: The file system is being scaled out.
*   Stopping: The file system is being disabled.
*   Deleting: The file system is being deleted.', example='Pending'),
      storageType?: string(name='StorageType', description='The storage type.

Valid values:

*   Valid values for General-purpose NAS file systems: Capacity and Performance.
*   Valid values for Extreme NAS file systems: standard and advance.
*   Valid values for CPFS file systems: advance_100 (100 MB/s/TiB baseline) and advance_200 (200 MB/s/TiB baseline).', example='Performance'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
    }
  ](name='FileSystem')
  }(name='FileSystems', description='The queried file systems.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='9F088138-FD73-4B68-95CC-DFAD4D85****'),
  totalCount?: int32(name='TotalCount', description='The total number of file system entries.', example='100'),
}

model DescribeFileSystemStatisticsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFileSystemStatisticsResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI DescribeFileSystemStatistics is deprecated, please use NAS::2017-06-26::DescribeResourceStatistics instead.
 *
 * @summary Queries the statistics of file systems that are owned by the current account.
 *
 * @param request DescribeFileSystemStatisticsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFileSystemStatisticsResponse
 */
// Deprecated
@context("describeFileSystemStatisticsWithContext")
async function describeFileSystemStatisticsWithOptions(request: DescribeFileSystemStatisticsRequest, runtime: $RuntimeOptions): DescribeFileSystemStatisticsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeFileSystemStatistics',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI DescribeFileSystemStatistics is deprecated, please use NAS::2017-06-26::DescribeResourceStatistics instead.
 *
 * @summary Queries the statistics of file systems that are owned by the current account.
 *
 * @param request DescribeFileSystemStatisticsRequest
 * @return DescribeFileSystemStatisticsResponse
 */
// Deprecated
async function describeFileSystemStatistics(request: DescribeFileSystemStatisticsRequest): DescribeFileSystemStatisticsResponse {
  var runtime = new $RuntimeOptions{};
  return describeFileSystemStatisticsWithOptions(request, runtime);
}

model DescribeFileSystemsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: 31a8e4\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Extreme NAS file systems must start with extreme-, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS file systems must start with cpfs-. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.', example='31a8e4****'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   all (default): All types.
*   standard: General-purpose NAS file system.
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system.

>  Separate multiple data types with commas (,).', example='standard'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.

You can log on to the [Resource Management console](https://resourcemanager.console.aliyun.com/resource-groups?) to view resource group IDs.', example='rg-acfmwavnfdf****'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

Limits:

*   Valid values of N: 1 to 20.
*   The tag key can be up to 128 characters in length.
*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.', example='test'),
      value?: string(name='Value', description='The tag value.

Limits:

*   Valid values of N: 1 to 20.
*   The tag value can be up to 128 characters in length.
*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or `https://`.', example='test-value'),
    }
  ](name='Tag', description='The details about the tags.'),
  vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).

If you want to mount the file system on an Elastic Compute Service (ECS) instance, the file system and the ECS instance must reside in the same VPC.', example='vpc-bp1sevsgtqvk5gxbl****'),
}

model DescribeFileSystemsResponseBody = {
  fileSystems?: {
    fileSystem?: [ 
    {
      accessPointCount?: string(name='AccessPointCount', description='Number of access points.', example='1'),
      autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.', example='sp-extreme-233e6****'),
      bandwidth?: long(name='Bandwidth', description='The bandwidth of the file system.

Unit: MB/s. This parameter is unavailable for General-purpose NAS file systems.', example='150'),
      capacity?: long(name='Capacity', description='The capacity of the file system.

Unit: GiB.', example='100'),
      chargeType?: string(name='ChargeType', description='The billing method.

Valid values:

*   Subscription
*   PayAsYouGo
*   Package: storage plan', example='PayAsYouGo'),
      createTime?: string(name='CreateTime', description='The time when the file system was created.', example='2020-01-05T16:00:00Z'),
      description?: string(name='Description', description='The description of the file system.', example='test'),
      encryptType?: int32(name='EncryptType', description='Indicates whether the data in the file system is encrypted.

Valid values:

*   0: The data in the file system is not encrypted.
*   1: A NAS-managed key is used to encrypt the data in the file system.
*   2: A KMS-managed key is used to encrypt the data in the file system.', example='1'),
      expiredTime?: string(name='ExpiredTime', description='The time when the file system expires.', example='2020-01-05T16:00:00Z'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='109c04****'),
      fileSystemType?: string(name='FileSystemType', description='The file system type.

The following information is displayed:

*   standard: General-purpose NAS file system.
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system.', example='standard'),
      KMSKeyId?: string(name='KMSKeyId', description='The ID of the key that is managed by Key Management Service (KMS).', example='0e478b7a-4262-4802-b8cb-00d3fb40****'),
      ldap?: {
        bindDN?: string(name='BindDN', description='An LDAP entry.', example='cn=alibaba,dc=com'),
        searchBase?: string(name='SearchBase', description='An LDAP search base.', example='dc=example'),
        URI?: string(name='URI', description='An LDAP URI.', example='ldap://ldap.example.example'),
      }(name='Ldap', description='The Lightweight Directory Access Protocol (LDAP) configurations.

This parameter is available only for CPFS file systems.'),
      meteredArchiveSize?: long(name='MeteredArchiveSize', description='Archive storage usage.

Unit: Byte.', example='1611661312'),
      meteredIASize?: long(name='MeteredIASize', description='The storage usage of the Infrequent Access (IA) storage medium.

Unit: bytes.', example='362832'),
      meteredSize?: long(name='MeteredSize', description='The storage usage of the file system.

The value of this parameter is the maximum storage usage of the file system over the last hour. Unit: bytes.', example='1611661312'),
      mountTargets?: {
        mountTarget?: [ 
        {
          accessGroupName?: string(name='AccessGroupName', description='The name of the permission group that is attached to the mount target.', example='test-001'),
          clientMasterNodes?: {
            clientMasterNode?: [ 
            {
              defaultPasswd?: string(name='DefaultPasswd', description='The default logon password of the ECS instance on the client management node.', example='123456'),
              ecsId?: string(name='EcsId', description='The ID of the ECS instance on the client management node.', example='i-hp3i3odi5ory1buo****'),
              ecsIp?: string(name='EcsIp', description='The IP address of the ECS instance on the client management node.', example='192.168.1.0'),
            }
          ](name='ClientMasterNode')
          }(name='ClientMasterNodes', description='The information about client management nodes.

This parameter is available only for CPFS file systems.'),
          dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', description='The dual-stack (IPv4 and IPv6) domain name of the mount target.
> Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.', example='174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com'),
          mountTargetDomain?: string(name='MountTargetDomain', description='The domain name of the mount target.', example='109c042666-w****.cn-hangzhou.nas.aliyuncs.com'),
          networkType?: string(name='NetworkType', description='The network type. Valid value: vpc.', example='vpc'),
          status?: string(name='Status', description='The status of the mount target.

Valid values:

*   Active
*   Inactive
*   Pending
*   Deleting
*   Hibernating
*   Hibernated', example='Active'),
          tags?: {
            tag?: [ 
            {
              key?: string(name='Key', description='The tag key.', example='test'),
              value?: string(name='Value', description='The tag value.', example='test-value'),
            }
          ](name='Tag')
          }(name='Tags', description='The tags that are attached to the mount target.'),
          vpcId?: string(name='VpcId', description='The ID of the VPC.', example='vpc-bp1sevsgtqvk5gxbl****'),
          vswId?: string(name='VswId', description='The ID of the vSwitch.', example='vsw-bp1omfzsszekkvaxn****'),
        }
      ](name='MountTarget')
      }(name='MountTargets', description='The queried mount targets.'),
      options?: {
        enableOplock?: boolean(name='EnableOplock', description='Specifies whether to enable the oplock feature. Valid values:

*   true: enables the feature.
*   false: disables the feature.

>  Only Server Message Block (SMB) file systems support this feature.', example='true'),
      }(name='Options', description='The options.'),
      packages?: {
        package?: [ 
        {
          expiredTime?: string(name='ExpiredTime', description='The end time of the validity period for the storage plan.', example='2020-01-05T16:00:00Z'),
          packageId?: string(name='PackageId', description='The ID of the storage plan.', example='naspackage-0be9c4b624-37****'),
          packageType?: string(name='PackageType', description='The type of the storage plan.

Valid values:

*   ssd: The storage plan for Performance NAS file systems.
*   hybrid: The storage plan for Capacity NAS file systems.', example='hybrid'),
          size?: long(name='Size', description='The capacity of the storage plan. Unit: bytes.', example='107374182400'),
          startTime?: string(name='StartTime', description='The start time of the validity period for the storage plan.', example='2019-12-05T01:40:56Z'),
        }
      ](name='Package')
      }(name='Packages', description='The information about storage plans.'),
      protocolType?: string(name='ProtocolType', description='The protocol type of the file system.

The following information is displayed:

*   NFS: Network File System.
*   SMB: Server Message Block.
*   cpfs: The protocol type supported by the CPFS file system.', example='NFS'),
      quorumVswId?: string(name='QuorumVswId', description='The vSwitch ID.', example='vsw-2ze37k6jh8ums2fw2****'),
      redundancyType?: string(name='RedundancyType', example='LRS'),
      redundancyVSwitchIds?: {
        redundancyVSwitchId?: [ string ](name='RedundancyVSwitchId')
      }(name='RedundancyVSwitchIds'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmwavnfdf****'),
      status?: string(name='Status', description='The status of the file system. Valid values:
- Pending: The file system is being created or modified.
- Running: The file system is available. Before you create a mount target for the file system, make sure that the file system is in the Running state.
- Stopped: The file system is unavailable.
- Extending: The file system is being scaled up.
- Stopping: The file system is being stopped.
- Deleting: The file system is being deleted.', example='Pending'),
      storageType?: string(name='StorageType', description='The type of the storage.

The following information is displayed:

*   Valid values for General-purpose NAS file systems: Capacity, Performance, and Premium
*   Valid values for Extreme NAS file systems: standard and advance
*   Valid values for Cloud Parallel File Storage (CPFS) file systems: advance_100 (100 MB/s/TiB baseline) and advance_200 (200 MB/s/TiB baseline)', example='Performance'),
      supportedFeatures?: {
        supportedFeature?: [ string ](name='SupportedFeature')
      }(name='SupportedFeatures', description='The features that are supported by the file system.'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='test'),
          value?: string(name='Value', description='The tag value.', example='test-value'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags that are attached to the file system.'),
      version?: string(name='Version', description='The version number of the file system.

This parameter is available only for Extreme NAS file systems and CPFS file systems.', example='2.3.4'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-bp1cbv1ljve4j5hlw****'),
      vscTarget?: string(name='VscTarget', description='>  This parameter is not publicly available.', example='cpfs-370y1tv921vpuj4****-000001.cn-wulanchabu.cpfs.aliyuncs.com'),
      vswIds?: {
        vswId?: [ string ](name='VswId')
      }(name='VswIds', description='The information about vSwitch.'),
      zoneId?: string(name='ZoneId', description='The ID of the zone where the file system resides.', example='cn-hangzhou-b'),
    }
  ](name='FileSystem')
  }(name='FileSystems', description='The file system list.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='035B3A3A-E514-4B41-B906-5D906CFB****'),
  totalCount?: int32(name='TotalCount', description='The total number of file systems.', example='1'),
}

model DescribeFileSystemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFileSystemsResponseBody(name='body'),
}

/**
 * @summary Queries file systems.
 *
 * @param request DescribeFileSystemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFileSystemsResponse
 */
@context("describeFileSystemsWithContext")
async function describeFileSystemsWithOptions(request: DescribeFileSystemsRequest, runtime: $RuntimeOptions): DescribeFileSystemsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!$isNull(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeFileSystems',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries file systems.
 *
 * @param request DescribeFileSystemsRequest
 * @return DescribeFileSystemsResponse
 */
async function describeFileSystems(request: DescribeFileSystemsRequest): DescribeFileSystemsResponse {
  var runtime = new $RuntimeOptions{};
  return describeFileSystemsWithOptions(request, runtime);
}

model DescribeFilesetsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  filters?: [ 
    {
      key?: string(name='Key', description='The filter name. Valid values:

*   FsetIds: filters filesets by fileset ID.
*   FileSystemPath: filters filesets based on the path of a fileset in a CPFS file system.
*   Description: filters filesets based on the fileset description.
*   QuotaExists: filters filesets based on whether quotas exist.

>  Only CPFS for LINGJUN V2.7.0 and later support the QuotaExists parameter.', example='FsetIds'),
      value?: string(name='Value', description='The filter value. This parameter does not support wildcards.

*   If Key is set to FsetIds, set Value to a fileset ID or a part of the fileset ID. You can specify a fileset ID or a group of fileset IDs. You can specify a maximum of 10 fileset IDs. Example: `fset-1902718ea0ae****` or `fset-1902718ea0ae****,fset-3212718ea0ae****`.
*   If Key is set to FileSystemPath, set Value to the path or a part of the path of a fileset in a CPFS file system. The value must be 2 to 1024 characters in length. The value must be encoded in UTF-8.
*   If Key is set to Description, set Value to a fileset description or a part of the fileset description.
*   If Key is set to QuotaExists, set Value to true or false. If you do not specify the parameter, all filesets are returned.', example='fset-1902718ea0ae****,fset-3212718ea0ae****'),
    }
  ](name='Filters', description='The filter that is used to query filesets.'),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  orderByField?: string(name='OrderByField', description='The condition by which the results are sorted. Valid values:

*   FileCountLimit: the file quantity quota
*   SizeLimit: the capacity quota
*   FileCountUsage: the usage of the file quantity quota
*   SpaceUsage: the capacity usage', example='FileCountLimit'),
  sortOrder?: string(name='SortOrder', description='The order in which you want to sort the results. Valid values:

*   asc (default): ascending order
*   desc: descending order

>  This parameter takes effect only if you specify the OrderByField parameter.', example='asc'),
}

model DescribeFilesetsResponseBody = {
  entries?: {
    entrie?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the fileset was created.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.', example='2021-09-30T10:08:08Z'),
      deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2402263.html) operation. Valid values:

*   true: enables release protection.
*   false: disables release protection.

> This parameter can protect filesets only against manual releases, but not against automatic releases.', example='true'),
      description?: string(name='Description', description='The fileset description.', example='test'),
      fileCountUsage?: long(name='FileCountUsage', description='The usage of the file quantity.

>  Only CPFS for LINGJUN V2.7.0 and later support this parameter.', example='1024'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.', example='bmcpfs-290w65p03ok64ya****'),
      fileSystemPath?: string(name='FileSystemPath', description='The fileset path.', example='pathtoroot/fset'),
      fsetId?: string(name='FsetId', description='The fileset ID.', example='fset-1902718ea0ae****'),
      quota?: {
        fileCountLimit?: long(name='FileCountLimit', description='The file quantity quota. Valid values:

*   Minimum value: 10000.
*   Maximum value: 10000000000.', example='10000'),
        sizeLimit?: long(name='SizeLimit', description='The capacity quota. Unit: bytes.

*   Minimum value: 10737418240 (10 GiB).
*   Step size: 1073741824 (1 GiB).', example='10737418240'),
      }(name='Quota', description='The quota information.

>  Only CPFS for Lingjun V2.7.0 and later support this parameter.'),
      spaceUsage?: long(name='SpaceUsage', description='The capacity usage. Unit: bytes.

>  Only CPFS for LINGJUN V2.7.0 and later support this parameter.', example='1024'),
      status?: string(name='Status', description='The fileset status. Valid values:

*   CREATING: The fileset is being created.
*   CREATED: The fileset has been created and is running properly.
*   RELEASING: The fileset is being released.
*   RELEASED: The fileset has been deleted.', example='CREATED'),
      updateTime?: string(name='UpdateTime', description='The time when the fileset was last updated.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.', example='2021-09-30T10:08:08Z'),
    }
  ](name='Entrie')
  }(name='Entries', description='The fileset information.'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.', example='bmcpfs-290w65p03ok64ya****', deprecated=true),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model DescribeFilesetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFilesetsResponseBody(name='body'),
}

/**
 * @summary Queries the information about created filesets.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   In Filters, FsetIds supports exact match only. FileSystemPath and Description support fuzzy match.
 * *   Combined query is supported.
 *
 * @param request DescribeFilesetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFilesetsResponse
 */
@context("describeFilesetsWithContext")
async function describeFilesetsWithOptions(request: DescribeFilesetsRequest, runtime: $RuntimeOptions): DescribeFilesetsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.orderByField)) {
    query['OrderByField'] = request.orderByField;
  }
  if (!$isNull(request.sortOrder)) {
    query['SortOrder'] = request.sortOrder;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeFilesets',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about created filesets.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation. You can view the version information on the file system details page in the console.
 * *   In Filters, FsetIds supports exact match only. FileSystemPath and Description support fuzzy match.
 * *   Combined query is supported.
 *
 * @param request DescribeFilesetsRequest
 * @return DescribeFilesetsResponse
 */
async function describeFilesets(request: DescribeFilesetsRequest): DescribeFilesetsResponse {
  var runtime = new $RuntimeOptions{};
  return describeFilesetsWithOptions(request, runtime);
}

model DescribeFilesystemsVscAttachInfoRequest {
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='Query token, which is the NextToken value returned from the previous API call.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  resourceIds?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='bmcpfs-290t15yn4uo8lid****'),
      vscId?: string(name='VscId', description='The ID of the virtual storage channel.', example='vsc-8vb864o3ppwfvh****'),
    }
  ](name='ResourceIds', description='The ID information of the file system and virtual storage channel. Each batch can contain up to 10 IDs.

This parameter is required.'),
}

model DescribeFilesystemsVscAttachInfoResponseBody = {
  maxResults?: int32(name='MaxResults', description='The number of directories to return for each query.

Valid values: 10 to 1000.

Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='Query token, which is the NextToken value returned from the previous API call.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  totalCount?: int32(name='TotalCount', description='The total number of associated information.', example='1'),
  vscAttachInfo?: {
    vscAttachInfo?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='bmcpfs-290t15yn4uo8lid****'),
      status?: string(name='Status', description='The association status of the file system and virtual channel. Valid values:

*   Attaching: The association is being made.
*   Attached: The association is complete.
*   Detaching: The association is being canceled.
*   Detached: The association is canceled.
*   Failed: The association failed.', example='Attached'),
      vscId?: string(name='VscId', description='The ID of the virtual storage channel.', example='vsc-8vb864o3ppwfvh****'),
    }
  ](name='VscAttachInfo')
  }(name='VscAttachInfo', description='A collection of file system and virtual channel association data.'),
}

model DescribeFilesystemsVscAttachInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeFilesystemsVscAttachInfoResponseBody(name='body'),
}

/**
 * @summary Queries information about virtual storage channels associated with a file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request DescribeFilesystemsVscAttachInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeFilesystemsVscAttachInfoResponse
 */
@context("describeFilesystemsVscAttachInfoWithContext")
async function describeFilesystemsVscAttachInfoWithOptions(request: DescribeFilesystemsVscAttachInfoRequest, runtime: $RuntimeOptions): DescribeFilesystemsVscAttachInfoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeFilesystemsVscAttachInfo',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about virtual storage channels associated with a file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request DescribeFilesystemsVscAttachInfoRequest
 * @return DescribeFilesystemsVscAttachInfoResponse
 */
async function describeFilesystemsVscAttachInfo(request: DescribeFilesystemsVscAttachInfoRequest): DescribeFilesystemsVscAttachInfoResponse {
  var runtime = new $RuntimeOptions{};
  return describeFilesystemsVscAttachInfoWithOptions(request, runtime);
}

model DescribeLifecyclePoliciesRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
  lifecyclePolicyName?: string(name='LifecyclePolicyName', description='The name of the lifecycle policy. The name must meet the following conventions:

The name must be 3 to 64 characters in length and must start with a letter. It can contain letters, digits, underscores (_), and hyphens (-).', example='lifecyclepolicy_01'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  storageType?: string(name='StorageType', description='The storage class.

*   InfrequentAccess: the Infrequent Access (IA) storage class.
*   Archive: the Archive storage class.

>  If the StorageType parameter is not specified, data retrieval tasks of all types are returned.', example='InfrequentAccess', nullable=true),
}

model DescribeLifecyclePoliciesResponseBody = {
  lifecyclePolicies?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the lifecycle policy was created.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.', example='2019-10-30T10:08:08Z'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
      lifecyclePolicyName?: string(name='LifecyclePolicyName', description='The name of the lifecycle policy.', example='lifecyclepolicy_01'),
      lifecycleRuleName?: string(name='LifecycleRuleName', description='The management rule that is associated with the lifecycle policy.

Valid values:

*   DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.', example='DEFAULT_ATIME_14'),
      path?: string(name='Path', description='The absolute path of a directory with which the lifecycle policy is associated.', example='/pathway/to/folder'),
      paths?: [ string ](name='Paths', description='The absolute paths to multiple directories associated with the lifecycle policy.'),
      storageType?: string(name='StorageType', description='The storage type of the data that is dumped to the IA storage medium.

Default value: InfrequentAccess (IA).', example='InfrequentAccess'),
    }
  ](name='LifecyclePolicies', description='The queried lifecycle policies.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  totalCount?: int32(name='TotalCount', description='The total number of lifecycle policies.', example='10'),
}

model DescribeLifecyclePoliciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLifecyclePoliciesResponseBody(name='body'),
}

/**
 * @summary Queries lifecycle policies.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request DescribeLifecyclePoliciesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLifecyclePoliciesResponse
 */
@context("describeLifecyclePoliciesWithContext")
async function describeLifecyclePoliciesWithOptions(request: DescribeLifecyclePoliciesRequest, runtime: $RuntimeOptions): DescribeLifecyclePoliciesResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeLifecyclePolicies',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries lifecycle policies.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request DescribeLifecyclePoliciesRequest
 * @return DescribeLifecyclePoliciesResponse
 */
async function describeLifecyclePolicies(request: DescribeLifecyclePoliciesRequest): DescribeLifecyclePoliciesResponse {
  var runtime = new $RuntimeOptions{};
  return describeLifecyclePoliciesWithOptions(request, runtime);
}

model DescribeLogAnalysisRequest {
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard: General-purpose NAS file system
*   extreme: Extreme NAS file system
*   all (default): all types', example='all'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 10.', example='1'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DescribeLogAnalysisResponseBody = {
  analyses?: {
    analysis?: [ 
    {
      metaKey?: string(name='MetaKey', description='The ID of the file system.', example='0c7154xxxx'),
      metaValue?: {
        logstore?: string(name='Logstore', description='The name of the dedicated Logstore that is used to store NAS operation logs.', example='nas-nfs'),
        project?: string(name='Project', description='The name of the project where the dedicated Logstore resides.', example='nas-1746495857602745-cn-hangzhou'),
        region?: string(name='Region', description='The region where the dedicated Logstore resides.', example='cn-hangzhou'),
        roleArn?: string(name='RoleArn', description='The role that is used by NAS to access Simple Log Service.', example='acs:ram::162165525211xxxx:role/aliyunnaslogarchiverole'),
      }(name='MetaValue', description='The log dump information of the file system.'),
    }
  ](name='Analysis')
  }(name='Analyses', description='The collection of log dump information.'),
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of log dump entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='C84F77AF-3DE5-48F1-B19B-37FCBE24****'),
  totalCount?: int32(name='TotalCount', description='The total number of log dump entries in the region.', example='10'),
}

model DescribeLogAnalysisResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLogAnalysisResponseBody(name='body'),
}

/**
 * @summary Queries the log dump information configured in log analysis.
 *
 * @param request DescribeLogAnalysisRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeLogAnalysisResponse
 */
@context("describeLogAnalysisWithContext")
async function describeLogAnalysisWithOptions(request: DescribeLogAnalysisRequest, runtime: $RuntimeOptions): DescribeLogAnalysisResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeLogAnalysis',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the log dump information configured in log analysis.
 *
 * @param request DescribeLogAnalysisRequest
 * @return DescribeLogAnalysisResponse
 */
async function describeLogAnalysis(request: DescribeLogAnalysisRequest): DescribeLogAnalysisResponse {
  var runtime = new $RuntimeOptions{};
  return describeLogAnalysisWithOptions(request, runtime);
}

model DescribeMountTargetsRequest {
  dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', description='The dual-stack (IPv4 and IPv6) domain name of the mount target.

> Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.', example='1ca404****-x****.dualstack.cn-hangzhou.nas.aliyuncs.com'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: 31a8e4\\\\*\\\\*\\\\*\\\\*.
*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='1ca404****'),
  mountTargetDomain?: string(name='MountTargetDomain', description='The address of the mount target.', example='1ca404****-x****.cn-hangzhou.nas.aliyuncs.com'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='1'),
}

model DescribeMountTargetsResponseBody = {
  mountTargets?: {
    mountTarget?: [ 
    {
      accessGroup?: string(name='AccessGroup', description='The name of the permission group that is attached to the mount target.', example='DEFAULT_VPC_GROUP_NAME'),
      clientMasterNodes?: {
        clientMasterNode?: [ 
        {
          defaultPasswd?: string(name='DefaultPasswd', description='The default logon password of the ECS instance.', example='12****'),
          ecsId?: string(name='EcsId', description='The ID of the ECS instance on the client management node.', example='i-hp3i3odi5ory1buo****'),
          ecsIp?: string(name='EcsIp', description='The IP address of the ECS instance on the client management node.', example='192.168.1.0'),
        }
      ](name='ClientMasterNode')
      }(name='ClientMasterNodes', description='The information about client management nodes.'),
      dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', description='The dual-stack (IPv4 and IPv6) domain name of the mount target.', example='1ca404****-x****.dualstack.cn-hangzhou.nas.aliyuncs.com'),
      IPVersion?: string(name='IPVersion', description='The type of the mount target.

*   IPv4: an IPv4 mount target
*   DualStack: a dual-stack mount target', example='IPv4'),
      mountTargetDomain?: string(name='MountTargetDomain', description='The IPv4 domain name of the mount target.', example='1ca404****-w****.cn-hangzhou.nas.aliyuncs.com'),
      networkType?: string(name='NetworkType', description='The network type. Valid value: **Vpc**.', example='Vpc'),
      status?: string(name='Status', description='The status of the mount target.

Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.
*   Pending: The mount target is being created or modified.
*   Deleting: The mount target is being deleted.
*   Hibernating: The mount target is being hibernated.
*   Hibernated: The mount target is hibernated.

> You can mount a file system only when the mount target of the file system is in the Active state.', example='Active'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key. Limits:

*   The tag key cannot be null or an empty string.
*   The tag key can be up to 128 characters in length.
*   The key value cannot start with aliyun or acs:.
*   The key value cannot contain http:// or https://.', example='nastest'),
          value?: string(name='Value', description='The tag value.

Limits:

*   The tag value can be up to 128 characters in length.
*   The tag value cannot contain http:// or https://.', example='mounttargettest'),
        }
      ](name='Tag')
      }(name='Tags', description='An array of tags. The array may contain up to 20 tags. If the array contains multiple tags, each tag key is unique.'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC).', example='vpc-2zesj9afh3y518k9o****'),
      vswId?: string(name='VswId', description='The ID of the vSwitch.', example='vsw-2zevmwkwyztjuoffg****'),
    }
  ](name='MountTarget')
  }(name='MountTargets', description='The queried mount targets.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='3BAB90FD-B4A0-48DA-9F09-2B963510****'),
  totalCount?: int32(name='TotalCount', description='The total number of mount targets.', example='1'),
}

model DescribeMountTargetsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMountTargetsResponseBody(name='body'),
}

/**
 * @summary Queries mount targets.
 *
 * @param request DescribeMountTargetsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMountTargetsResponse
 */
@context("describeMountTargetsWithContext")
async function describeMountTargetsWithOptions(request: DescribeMountTargetsRequest, runtime: $RuntimeOptions): DescribeMountTargetsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.dualStackMountTargetDomain)) {
    query['DualStackMountTargetDomain'] = request.dualStackMountTargetDomain;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.mountTargetDomain)) {
    query['MountTargetDomain'] = request.mountTargetDomain;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeMountTargets',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries mount targets.
 *
 * @param request DescribeMountTargetsRequest
 * @return DescribeMountTargetsResponse
 */
async function describeMountTargets(request: DescribeMountTargetsRequest): DescribeMountTargetsResponse {
  var runtime = new $RuntimeOptions{};
  return describeMountTargetsWithOptions(request, runtime);
}

model DescribeMountedClientsRequest {
  clientIP?: string(name='ClientIP', description='The IP address of the client.

*   If you specify an IP address, the operation checks whether the client list includes this IP address. If the client list includes the IP address, the operation returns the IP address. If the client list does not include the IP address, the operation returns an empty list.
*   If you do not specify an IP address, the operation returns the IP addresses of all clients that have accessed the specified NAS file system within the last minute.', example='10.10.10.1'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='109c****66'),
  mountTargetDomain?: string(name='MountTargetDomain', description='The domain name of the mount target.

This parameter is required.', example='1111222****95.cn-hangzhou.nas.aliyuncs.com'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of IP addresses to return on each page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DescribeMountedClientsResponseBody = {
  clients?: {
    client?: [ 
    {
      clientIP?: string(name='ClientIP', description='The IP address of the client.', example='10.10.10.1'),
    }
  ](name='Client')
  }(name='Clients', description='The queried clients.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of IP addresses returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211****'),
  totalCount?: int32(name='TotalCount', description='The total number of IP addresses.', example='10'),
}

model DescribeMountedClientsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMountedClientsResponseBody(name='body'),
}

/**
 * @summary Queries the clients on which a file system is mounted.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   This operation returns the clients that have accessed the specified file system within the last minute. If the file system is mounted on a client but the client did not access the file system within the last minute, the client is not included in the returned information.
 *
 * @param request DescribeMountedClientsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeMountedClientsResponse
 */
@context("describeMountedClientsWithContext")
async function describeMountedClientsWithOptions(request: DescribeMountedClientsRequest, runtime: $RuntimeOptions): DescribeMountedClientsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientIP)) {
    query['ClientIP'] = request.clientIP;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.mountTargetDomain)) {
    query['MountTargetDomain'] = request.mountTargetDomain;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeMountedClients',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the clients on which a file system is mounted.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   This operation returns the clients that have accessed the specified file system within the last minute. If the file system is mounted on a client but the client did not access the file system within the last minute, the client is not included in the returned information.
 *
 * @param request DescribeMountedClientsRequest
 * @return DescribeMountedClientsResponse
 */
async function describeMountedClients(request: DescribeMountedClientsRequest): DescribeMountedClientsResponse {
  var runtime = new $RuntimeOptions{};
  return describeMountedClientsWithOptions(request, runtime);
}

model DescribeNfsAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='206614xxxx'),
}

model DescribeNfsAclResponseBody = {
  acl?: {
    enabled?: boolean(name='Enabled', description='Indicates whether the NFS ACL feature is enabled.

*   true: The NFS ACL feature is enabled.
*   false: The NFS ACL feature is disabled.', example='true'),
  }(name='Acl', description='The information about the ACL feature.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A1098673-1746-505E-A5F1-08527B7EDBDF'),
}

model DescribeNfsAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeNfsAclResponseBody(name='body'),
}

/**
 * @summary Queries whether the NFS ACL feature is enabled for a file system.
 *
 * @param request DescribeNfsAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeNfsAclResponse
 */
@context("describeNfsAclWithContext")
async function describeNfsAclWithOptions(request: DescribeNfsAclRequest, runtime: $RuntimeOptions): DescribeNfsAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeNfsAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether the NFS ACL feature is enabled for a file system.
 *
 * @param request DescribeNfsAclRequest
 * @return DescribeNfsAclResponse
 */
async function describeNfsAcl(request: DescribeNfsAclRequest): DescribeNfsAclResponse {
  var runtime = new $RuntimeOptions{};
  return describeNfsAclWithOptions(request, runtime);
}

model DescribeProtocolMountTargetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
  filters?: [ 
    {
      key?: string(name='Key', description='The filter name.

*   ProtocolServiceIds: filters export directories by protocol service ID.
*   ExportIds: filters export directories by export directory ID.
*   VpcIds: filters export directories by virtual private cloud (VPC) ID.
*   VSwitchIds: filters export directories by vSwitch ID.
*   FsetIds: filters export directories by fileset ID.
*   Paths: filters export directories based on the path of the file system corresponding to the mount target.
*   AccessGroupNames: filters export directories by permission group name.', example='ExportIds'),
      value?: string(name='Value', description='The filter value. This parameter does not support wildcards.

*   If Key is set to ProtocolServiceIds, set Value to a protocol service ID. You can specify a maximum of 10 protocol service IDs. Example: `ptc-12345678` or `ptc-12345678,ptc-12345679`.
*   If Key is set to ExportIds, set Value to an export directory ID. You can specify a maximum of 10 export directory IDs. Example: `exp-12345678` or `exp-12345678,exp-12345679`.
*   If Key is set to VpcIds, set Value to a VPC ID of the protocol service. You can specify a maximum of 10 VPC IDs. Example: `vpc-12345678` or `vpc-12345678,vpc-12345679`.
*   If Key is set to FsetIds, set Value to a fileset ID. You can specify a maximum of 10 fileset IDs. Example: `fset-12345678` or `fset-12345678,fset-12345679`.
*   If Key is set to Paths, set Value to a path of the file system corresponding to the mount target. You can specify a maximum of 10 paths. Example: `/cpfs/mnt_1/` or `/cpfs/mnt_1/,/cpfs/mnt_2/`.
*   If Key is set to AccessGroupNames, set Value to a permission group name for the protocol service. You can specify a maximum of 10 permission group names. Example: `ag-12345678` or `ag-12345678,ag-12345679`.', example='exp-19abf5beab8d****, exp-19acf6beaf7d****'),
    }
  ](name='Filters', description='The filter that is used to query the export directories of the protocol service.'),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

*   Value values: 10 to 100.
*   Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='aBcdg=='),
  protocolServiceIds?: string(name='ProtocolServiceIds', example='ptc-123xxx'),
}

model DescribeProtocolMountTargetResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='aBcdeg=='),
  protocolMountTargets?: [ 
    {
      accessGroupName?: string(name='AccessGroupName', description='The permission group that is associated with the export directory of the protocol service.', example='DEFAULT_VPC_GROUP_NAME'),
      createTime?: string(name='CreateTime', description='The time when the export directory of the protocol service was created.', example='2018-12-12T07:28:38Z'),
      description?: string(name='Description', description='The description of the export directory for the protocol service.', example='test'),
      exportId?: string(name='ExportId', description='The ID of the export directory for the protocol service.', example='exp-19abf5beab8d****'),
      fsetId?: string(name='FsetId', description='The fileset ID of the export directory for the protocol service.', example='fset-1902718ea0ae****'),
      path?: string(name='Path', description='The export directory of the protocol service.', example='/path/'),
      protocolMountTargetDomain?: string(name='ProtocolMountTargetDomain', description='The domain name of the export directory for the protocol service.', example='cpfs-123****.cn-hangzhou.cpfs.aliyuncs.com'),
      protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.', example='ptc-123****'),
      protocolType?: string(name='ProtocolType', description='The protocol type supported by the protocol service.', example='NFS'),
      status?: string(name='Status', description='The status of the mount target.', example='CREATING'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID of the export directory for the protocol service.', example='vsw-2vc3c2lybvdllxyq4****'),
      vSwitchIds?: [ string ](name='VSwitchIds'),
      vpcId?: string(name='VpcId', description='The VPC ID of the export directory for the protocol service.', example='vpc-2vct297b8157bth9z****'),
    }
  ](name='ProtocolMountTargets', description='The export directories of the protocol service.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0****'),
}

model DescribeProtocolMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeProtocolMountTargetResponseBody(name='body'),
}

/**
 * @summary Queries the export directories of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request DescribeProtocolMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeProtocolMountTargetResponse
 */
@context("describeProtocolMountTargetWithContext")
async function describeProtocolMountTargetWithOptions(request: DescribeProtocolMountTargetRequest, runtime: $RuntimeOptions): DescribeProtocolMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.protocolServiceIds)) {
    query['ProtocolServiceIds'] = request.protocolServiceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeProtocolMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the export directories of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request DescribeProtocolMountTargetRequest
 * @return DescribeProtocolMountTargetResponse
 */
async function describeProtocolMountTarget(request: DescribeProtocolMountTargetRequest): DescribeProtocolMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return describeProtocolMountTargetWithOptions(request, runtime);
}

model DescribeProtocolServiceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The description or a part of the description of the protocol service.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
  maxResults?: long(name='MaxResults', description='The number of results for each query.

*   Maximum value: 100.
*   Minimum value: 10.
*   Default value: 20.', example='20'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='aBcdg=='),
  protocolServiceIds?: string(name='ProtocolServiceIds', description='The ID of the protocol service.

*   Format: CSV.
*   Limit: You can specify a maximum of 10 protocol service IDs.', example='ptc-197ed6a00f2b****,ptc-196ed6a00f2b****'),
  status?: string(name='Status', description='The status of the protocol service.

Format: CSV.

Valid values:

*   Creating: The protocol service is being created.
*   Starting: The protocol service is being started.
*   Running: The protocol service is running.
*   Updating: The protocol service is being updated.
*   Deleting: The protocol service is being deleted.
*   Stopping: The protocol service is being stopped.
*   Stopped: The protocol service is stopped.', example='Running,Updating'),
}

model DescribeProtocolServiceResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='aBcdeg=='),
  protocolServices?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the protocol service was created. The time is displayed in UTC.', example='2018-12-12T07:28:38Z'),
      description?: string(name='Description', description='The description of the protocol service.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='cpfs-099394bd928c****'),
      instanceBaseThroughput?: int32(name='InstanceBaseThroughput', description='The base throughput of the protocol service. Unit: MB/s.', example='100'),
      instanceBurstThroughput?: int32(name='InstanceBurstThroughput', description='The burst throughput of the protocol service. Unit: MB/s.', example='100'),
      instanceRAM?: int32(name='InstanceRAM', description='The memory cache size of the protocol service. Unit: GiB.', example='0'),
      modifyTime?: string(name='ModifyTime', description='The time when the protocol service was modified. The time is displayed in UTC.', example='2018-12-12T07:28:38Z'),
      mountTargetCount?: int32(name='MountTargetCount', description='The total number of CPFS directories and filesets exported in the protocol service.', example='5'),
      protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.', example='ptc-197ed6a00f2b****'),
      protocolSpec?: string(name='ProtocolSpec', description='The specification of the protocol service.

*   Valid value: General.
*   Default value: General.', example='General'),
      protocolThroughput?: int32(name='ProtocolThroughput', description='The throughput of the protocol service. Unit: MB/s.', example='500'),
      protocolType?: string(name='ProtocolType', description='The protocol type supported by the protocol service.

Valid values:

*   NFS: The protocol service supports access over the Network File System (NFS) protocol.', example='NFS'),
      status?: string(name='Status', description='The status of the protocol service.

Valid values:

*   Creating: The protocol service is being created.
*   Starting: The protocol service is being started.
*   Running: The protocol service is running.
*   Updating: The protocol service is being updated.
*   Deleting: The protocol service is being deleted.
*   Stopping: The protocol service is being stopped.
*   Stopped: The protocol service is stopped.', example='Running'),
      vSwitchId?: string(name='VSwitchId', example='vsw-123xxx'),
      vpcId?: string(name='VpcId', example='vpc-123xxx'),
    }
  ](name='ProtocolServices', description='The information about protocol services.'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model DescribeProtocolServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeProtocolServiceResponseBody(name='body'),
}

/**
 * @summary Queries the information about protocol services.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request DescribeProtocolServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeProtocolServiceResponse
 */
@context("describeProtocolServiceWithContext")
async function describeProtocolServiceWithOptions(request: DescribeProtocolServiceRequest, runtime: $RuntimeOptions): DescribeProtocolServiceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.protocolServiceIds)) {
    query['ProtocolServiceIds'] = request.protocolServiceIds;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeProtocolService',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about protocol services.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request DescribeProtocolServiceRequest
 * @return DescribeProtocolServiceResponse
 */
async function describeProtocolService(request: DescribeProtocolServiceRequest): DescribeProtocolServiceResponse {
  var runtime = new $RuntimeOptions{};
  return describeProtocolServiceWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   all: all types of file systems
*   standard (default): General-purpose NAS file system
*   extreme: Extreme NAS file system
*   cpfs: Cloud Parallel File Storage (CPFS) file system

> CPFS file systems are available only on the China site (aliyun.com).', example='standard'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
}

model DescribeRegionsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName', description='The region name.', example='East China 1'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint for the region.', example='nas.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    }
  ](name='Region')
  }(name='Regions', description='The queried regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the regions in which File Storage NAS is available.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
@context("describeRegionsWithContext")
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $RuntimeOptions): DescribeRegionsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the regions in which File Storage NAS is available.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeSmbAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
}

model DescribeSmbAclResponseBody = {
  acl?: {
    enableAnonymousAccess?: boolean(name='EnableAnonymousAccess', description='Indicates whether the file system allows anonymous access. Valid values:

*   true: The file system allows anonymous access.
*   false: The file system does not allow anonymous access.', example='true'),
    enabled?: boolean(name='Enabled', description='Indicates whether the ACL feature is enabled. Valid values:

*   true: The ACL feature is enabled.
*   false: The ACL feature is disabled.', example='true'),
    encryptData?: boolean(name='EncryptData', description='Indicates whether encryption in transit is enabled. Valid values:

*   true: Encryption in transit is enabled.
*   false: Encryption in transit is disabled.', example='true'),
    homeDirPath?: string(name='HomeDirPath', description='The home directory of each user.', example='/home'),
    rejectUnencryptedAccess?: boolean(name='RejectUnencryptedAccess', description='Indicates whether the file system denies access from non-encrypted clients. Valid values:

*   true: The file system denies access from non-encrypted clients.
*   false: The file system allows access from non-encrypted clients.', example='true'),
    superAdminSid?: string(name='SuperAdminSid', description='The ID of a super admin.', example='S-1-0-0'),
  }(name='Acl', description='The information about the ACL feature.'),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DescribeSmbAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSmbAclResponseBody(name='body'),
}

/**
 * @summary Queries the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request DescribeSmbAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSmbAclResponse
 */
@context("describeSmbAclWithContext")
async function describeSmbAclWithOptions(request: DescribeSmbAclRequest, runtime: $RuntimeOptions): DescribeSmbAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSmbAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request DescribeSmbAclRequest
 * @return DescribeSmbAclResponse
 */
async function describeSmbAcl(request: DescribeSmbAclRequest): DescribeSmbAclResponse {
  var runtime = new $RuntimeOptions{};
  return describeSmbAclWithOptions(request, runtime);
}

model DescribeSnapshotsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='extreme-22f****'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid value: extreme, which indicates Extreme File Storage NAS (NAS) file systems.', example='extreme'),
  pageNumber?: int32(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  snapshotIds?: string(name='SnapshotIds', description='The snapshot IDs.

You can specify a maximum of 100 snapshot IDs. You must separate snapshot IDs with commas (,).', example='s-extreme-67pxwk9aevrkr****,s-extreme-snapsho****,s-extreme-6tmsbas6ljhwh****'),
  snapshotName?: string(name='SnapshotName', description='The snapshot name.', example='FinanceJoshua'),
  snapshotType?: string(name='SnapshotType', description='The type of the snapshot.

Valid values:

*   auto: auto snapshot
*   user: manual snapshot
*   all (default): all snapshot types', example='all'),
  status?: string(name='Status', description='The status of the snapshot.

Valid values:

*   progressing: The snapshot is being created.
*   accomplished: The snapshot is created.
*   failed: The snapshot fails to be created.
*   all (default): all snapshot states.', example='all'),
}

model DescribeSnapshotsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
  snapshots?: {
    snapshot?: [ 
    {
      completedTime?: string(name='CompletedTime', description='The time when snapshot creation was complete.

The time follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in UTC. The time is displayed in the `yyyy-MM-ddThh:mmZ` format.

>  This parameter is valid only when the snapshot is created. During snapshot creation, the value of this parameter is the same as that of CreateTime.', example='2014-07-24T13:10:52Z'),
      createTime?: string(name='CreateTime', description='The time when the snapshot was created.

The time follows the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) standard in UTC. The time is displayed in the `yyyy-MM-ddThh:mmZ` format.', example='2014-07-24T13:00:52Z'),
      description?: string(name='Description', description='The description of the snapshot.', example='FinanceDept'),
      encryptType?: int32(name='EncryptType', description='Indicates whether the snapshot is encrypted.

Valid values:

*   0: The snapshot is not encrypted.
*   1: The snapshot is encrypted.', example='1'),
      fileSystemType?: string(name='FileSystemType', description='The type of the file system.', example='extreme'),
      progress?: string(name='Progress', description='The progress of the snapshot creation. The value of this parameter is expressed as a percentage.', example='100'),
      remainTime?: int32(name='RemainTime', description='The remaining time that is required to create the snapshot.

Unit: seconds.', example='38'),
      retentionDays?: int32(name='RetentionDays', description='The retention period of the auto snapshot.

Unit: days.

Valid values:

*   \\\\-1: Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
*   1 to 65536: Auto snapshots are retained for the specified days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.', example='30'),
      snapshotId?: string(name='SnapshotId', description='The snapshot ID.', example='s-extreme-snapsho****'),
      snapshotName?: string(name='SnapshotName', description='The snapshot name.

If you specify a name to create a snapshot, the name of the snapshot is returned. Otherwise, no value is returned for this parameter.', example='FinanceJoshua'),
      snapshotType?: string(name='SnapshotType', description='The snapshot type. Valid values:

*   auto: automatically created snapshots
*   user: manually created snapshots', example='user'),
      sourceFileSystemId?: string(name='SourceFileSystemId', description='The ID of the source file system.

This parameter is retained even if the source file system of the snapshot is deleted.', example='extreme-012****'),
      sourceFileSystemSize?: long(name='SourceFileSystemSize', description='The capacity of the source file system.

Unit: GiB.', example='2000'),
      sourceFileSystemVersion?: string(name='SourceFileSystemVersion', description='The version of the source file system.', example='1'),
      status?: string(name='Status', description='The status of the snapshot.

Valid values:

*   progressing: The snapshot is being created.
*   accomplished: The snapshot is created.
*   failed: The snapshot fails to be created.', example='accomplished'),
    }
  ](name='Snapshot')
  }(name='Snapshots', description='The details about snapshots.'),
  totalCount?: int32(name='TotalCount', description='The total number of snapshots returned.', example='36'),
}

model DescribeSnapshotsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSnapshotsResponseBody(name='body'),
}

/**
 * @summary Queries the information about one or more snapshots of a file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DescribeSnapshotsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSnapshotsResponse
 */
@context("describeSnapshotsWithContext")
async function describeSnapshotsWithOptions(request: DescribeSnapshotsRequest, runtime: $RuntimeOptions): DescribeSnapshotsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.snapshotIds)) {
    query['SnapshotIds'] = request.snapshotIds;
  }
  if (!$isNull(request.snapshotName)) {
    query['SnapshotName'] = request.snapshotName;
  }
  if (!$isNull(request.snapshotType)) {
    query['SnapshotType'] = request.snapshotType;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeSnapshots',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about one or more snapshots of a file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request DescribeSnapshotsRequest
 * @return DescribeSnapshotsResponse
 */
async function describeSnapshots(request: DescribeSnapshotsRequest): DescribeSnapshotsResponse {
  var runtime = new $RuntimeOptions{};
  return describeSnapshotsWithOptions(request, runtime);
}

model DescribeStoragePackagesRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of storage plans to return on each page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  useUTCDateTime?: boolean(name='UseUTCDateTime', description='Specifies whether the time to return is in UTC.

Valid values:

*   true (default): returns UTC time.
*   false: returns UNIX timestamp.', example='true'),
}

model DescribeStoragePackagesResponseBody = {
  packages?: {
    package?: [ 
    {
      expiredTime?: string(name='ExpiredTime', description='The end time of the validity period for the storage plan.', example='2020-01-05T16:00:00Z'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system that is bound to the storage plan.', example='109c****66'),
      packageId?: string(name='PackageId', description='The ID of the storage plan.', example='naspackage-@string(\\\\"*****\\\\", *)-@string(\\\\"*****\\\\", *)'),
      size?: long(name='Size', description='The capacity of the storage plan.

Unit: bytes.', example='10'),
      startTime?: string(name='StartTime', description='The start time of the validity period for the storage plan.', example='2019-12-05T01:40:56Z'),
      status?: string(name='Status', description='The status of the storage plan.

Valid values:

*   free: The storage plan is not bound to a file system. You can bind the storage plan to a file system of the same storage type.
*   bound: The storage plan is bound to a file system.', example='free'),
      storageType?: string(name='StorageType', description='The type of the storage plan.

Valid values:

*   Performance
*   Capacity', example='Capacity'),
    }
  ](name='Package')
  }(name='Packages', description='The list of storage plans.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of storage plans returned per page.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='035B3A3A-E514-4B41-B906-5D906CFB****'),
  totalCount?: int32(name='TotalCount', description='The number of storage plans.', example='3'),
}

model DescribeStoragePackagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStoragePackagesResponseBody(name='body'),
}

/**
 * @summary You can call the DescribeStoragePackages operation to query the list of storage plans.
 *
 * @param request DescribeStoragePackagesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeStoragePackagesResponse
 */
@context("describeStoragePackagesWithContext")
async function describeStoragePackagesWithOptions(request: DescribeStoragePackagesRequest, runtime: $RuntimeOptions): DescribeStoragePackagesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.useUTCDateTime)) {
    query['UseUTCDateTime'] = request.useUTCDateTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeStoragePackages',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary You can call the DescribeStoragePackages operation to query the list of storage plans.
 *
 * @param request DescribeStoragePackagesRequest
 * @return DescribeStoragePackagesResponse
 */
async function describeStoragePackages(request: DescribeStoragePackagesRequest): DescribeStoragePackagesResponse {
  var runtime = new $RuntimeOptions{};
  return describeStoragePackagesWithOptions(request, runtime);
}

model DescribeZonesRequest {
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid value:

*   standard: General-purpose Apsara File Storage NAS (NAS) file system
*   extreme: Extreme NAS file system.
*   cpfs: CPFS file system.', example='standard'),
  regionId?: string(name='RegionId', description='The ID of the region where you want to query zones.

You can call the DescribeRegions operation to query the latest region list.

This parameter is required.', example='cn-hangzhou'),
}

model DescribeZonesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A70BEE5D-76D3-49FB-B58F-1F398211****'),
  zones?: {
    zone?: [ 
    {
      capacity?: {
        protocol?: [ string ](name='Protocol')
      }(name='Capacity', description='This parameter is reserved. You can ignore this parameter.'),
      instanceTypes?: {
        instanceType?: [ 
        {
          protocolType?: string(name='ProtocolType', description='The protocol type.

*   If the FileSystemType parameter is set to standard, the protocol type is nfs or smb.
*   If the FileSystemType parameter is set to extreme, the protocol type is nfs.
*   If the FileSystemType parameter is set to cpfs, the protocol type is cpfs.', example='nfs'),
          storageType?: string(name='StorageType', description='The storage type.

*   If the FileSystemType parameter is set to standard, the storage type is Performance or Capacity.
*   If the FileSystemType parameter is set to extreme, the storage type is standard or advance.
*   If the FileSystemType parameter is set to cpfs, the storage type is advance_100 (100 MB/s/TiB baseline) or advance_200 (200 MB/s/TiB baseline).', example='Capacity'),
        }
      ](name='InstanceType')
      }(name='InstanceTypes', description='The details about file system types.'),
      performance?: {
        protocol?: [ string ](name='Protocol')
      }(name='Performance', description='This parameter is reserved. You can ignore this parameter.'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-b'),
    }
  ](name='Zone')
  }(name='Zones', description='The queried zones.'),
}

model DescribeZonesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeZonesResponseBody(name='body'),
}

/**
 * @summary Queries all zones in a region and the file system types that are supported in each zone.
 *
 * @param request DescribeZonesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeZonesResponse
 */
@context("describeZonesWithContext")
async function describeZonesWithOptions(request: DescribeZonesRequest, runtime: $RuntimeOptions): DescribeZonesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeZones',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries all zones in a region and the file system types that are supported in each zone.
 *
 * @param request DescribeZonesRequest
 * @return DescribeZonesResponse
 */
async function describeZones(request: DescribeZonesRequest): DescribeZonesResponse {
  var runtime = new $RuntimeOptions{};
  return describeZonesWithOptions(request, runtime);
}

model DetachVscFromFilesystemsRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  resourceIds?: [ 
    {
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='bmcpfs-290t15yn4uo8lid****'),
      vscId?: string(name='VscId', description='The ID of the virtual storage channel.', example='vsc-8vb864o3ppwfvh****'),
    }
  ](name='ResourceIds', description='The ID information of the file system and virtual storage channel. Each batch can contain up to 10 IDs.

This parameter is required.'),
}

model DetachVscFromFilesystemsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model DetachVscFromFilesystemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DetachVscFromFilesystemsResponseBody(name='body'),
}

/**
 * @summary Unassociates a VSC device from a file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request DetachVscFromFilesystemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DetachVscFromFilesystemsResponse
 */
@context("detachVscFromFilesystemsWithContext")
async function detachVscFromFilesystemsWithOptions(request: DetachVscFromFilesystemsRequest, runtime: $RuntimeOptions): DetachVscFromFilesystemsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.resourceIds)) {
    query['ResourceIds'] = request.resourceIds;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DetachVscFromFilesystems',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Unassociates a VSC device from a file system.
 *
 * @description *   Only CPFS for Lingjun supports this operation.
 * *   Batch execution is supported. In batch execution, only one VscId can be associated with multiple FileSystemIDs, meaning the VscId in the ResourceIds must be the same.
 *
 * @param request DetachVscFromFilesystemsRequest
 * @return DetachVscFromFilesystemsResponse
 */
async function detachVscFromFilesystems(request: DetachVscFromFilesystemsRequest): DetachVscFromFilesystemsResponse {
  var runtime = new $RuntimeOptions{};
  return detachVscFromFilesystemsWithOptions(request, runtime);
}

model DisableAndCleanRecycleBinRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model DisableAndCleanRecycleBinResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model DisableAndCleanRecycleBinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableAndCleanRecycleBinResponseBody(name='body'),
}

/**
 * @summary Disables and empties the recycle bin of a General-purpose NAS file system.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   If you disable the recycle bin, all files in the recycle bin are permanently deleted.
 * *   If you disable and then enable the recycle bin, the recycle bin is empty. You cannot retrieve the deleted files.
 *
 * @param request DisableAndCleanRecycleBinRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableAndCleanRecycleBinResponse
 */
@context("disableAndCleanRecycleBinWithContext")
async function disableAndCleanRecycleBinWithOptions(request: DisableAndCleanRecycleBinRequest, runtime: $RuntimeOptions): DisableAndCleanRecycleBinResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableAndCleanRecycleBin',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables and empties the recycle bin of a General-purpose NAS file system.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   If you disable the recycle bin, all files in the recycle bin are permanently deleted.
 * *   If you disable and then enable the recycle bin, the recycle bin is empty. You cannot retrieve the deleted files.
 *
 * @param request DisableAndCleanRecycleBinRequest
 * @return DisableAndCleanRecycleBinResponse
 */
async function disableAndCleanRecycleBin(request: DisableAndCleanRecycleBinRequest): DisableAndCleanRecycleBinResponse {
  var runtime = new $RuntimeOptions{};
  return disableAndCleanRecycleBinWithOptions(request, runtime);
}

model DisableNfsAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='91fcdxxxx'),
}

model DisableNfsAclResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='24487C24-AE54-57EC-B4E4-4EDEEEB83B01'),
}

model DisableNfsAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableNfsAclResponseBody(name='body'),
}

/**
 * @summary Disables the NFS ACL feature for a file system.
 *
 * @param request DisableNfsAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableNfsAclResponse
 */
@context("disableNfsAclWithContext")
async function disableNfsAclWithOptions(request: DisableNfsAclRequest, runtime: $RuntimeOptions): DisableNfsAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableNfsAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the NFS ACL feature for a file system.
 *
 * @param request DisableNfsAclRequest
 * @return DisableNfsAclResponse
 */
async function disableNfsAcl(request: DisableNfsAclRequest): DisableNfsAclResponse {
  var runtime = new $RuntimeOptions{};
  return disableNfsAclWithOptions(request, runtime);
}

model DisableSmbAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model DisableSmbAclResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model DisableSmbAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableSmbAclResponseBody(name='body'),
}

/**
 * @summary Disables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request DisableSmbAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableSmbAclResponse
 */
@context("disableSmbAclWithContext")
async function disableSmbAclWithOptions(request: DisableSmbAclRequest, runtime: $RuntimeOptions): DisableSmbAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableSmbAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request DisableSmbAclRequest
 * @return DisableSmbAclResponse
 */
async function disableSmbAcl(request: DisableSmbAclRequest): DisableSmbAclResponse {
  var runtime = new $RuntimeOptions{};
  return disableSmbAclWithOptions(request, runtime);
}

model EnableNfsAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='43f264xxxx'),
}

model EnableNfsAclResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='29F4F360-A6A8-561A-A45B-A0F6882969BA'),
}

model EnableNfsAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableNfsAclResponseBody(name='body'),
}

/**
 * @summary Enables the NFS ACL feature for a file system.
 *
 * @param request EnableNfsAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableNfsAclResponse
 */
@context("enableNfsAclWithContext")
async function enableNfsAclWithOptions(request: EnableNfsAclRequest, runtime: $RuntimeOptions): EnableNfsAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableNfsAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the NFS ACL feature for a file system.
 *
 * @param request EnableNfsAclRequest
 * @return EnableNfsAclResponse
 */
async function enableNfsAcl(request: EnableNfsAclRequest): EnableNfsAclResponse {
  var runtime = new $RuntimeOptions{};
  return enableNfsAclWithOptions(request, runtime);
}

model EnableRecycleBinRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system for which you want to enable the recycle bin feature.

This parameter is required.', example='1ca404****'),
  reservedDays?: long(name='ReservedDays', description='The retention period of the files in the recycle bin. Unit: days.

Valid values: 1 to 180.

Default value: 3.', example='3'),
}

model EnableRecycleBinResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model EnableRecycleBinResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableRecycleBinResponseBody(name='body'),
}

/**
 * @summary Enables the recycle bin feature for a file system.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request EnableRecycleBinRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableRecycleBinResponse
 */
@context("enableRecycleBinWithContext")
async function enableRecycleBinWithOptions(request: EnableRecycleBinRequest, runtime: $RuntimeOptions): EnableRecycleBinResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.reservedDays)) {
    query['ReservedDays'] = request.reservedDays;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableRecycleBin',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the recycle bin feature for a file system.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request EnableRecycleBinRequest
 * @return EnableRecycleBinResponse
 */
async function enableRecycleBin(request: EnableRecycleBinRequest): EnableRecycleBinResponse {
  var runtime = new $RuntimeOptions{};
  return enableRecycleBinWithOptions(request, runtime);
}

model EnableSmbAclRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  keytab?: string(name='Keytab', description='The string that is generated after the system encodes the keytab file by using Base64.', example='BQIAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAQAIqIx6v7p11oUAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAwAIqIx6v7p11oUAAABPAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAFwAQnQZWB3RAPHU7PMIJyBWePAAAAF8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQASACAGJ7F0s+bcBjf6jD5HlvlRLmPSOW+qDZe0Qk0lQcf8WwAAAE8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQARABDdFmanrSIatnDDhxxxxx'),
  keytabMd5?: string(name='KeytabMd5', description='The string that is generated after the system encodes the keytab file by using MD5.', example='E3CCF7E2416DF04FA958AA4513EAxxxx'),
}

model EnableSmbAclResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model EnableSmbAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableSmbAclResponseBody(name='body'),
}

/**
 * @summary Enables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request EnableSmbAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableSmbAclResponse
 */
@context("enableSmbAclWithContext")
async function enableSmbAclWithOptions(request: EnableSmbAclRequest, runtime: $RuntimeOptions): EnableSmbAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.keytab)) {
    query['Keytab'] = request.keytab;
  }
  if (!$isNull(request.keytabMd5)) {
    query['KeytabMd5'] = request.keytabMd5;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableSmbAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the access control list (ACL) feature for a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request EnableSmbAclRequest
 * @return EnableSmbAclResponse
 */
async function enableSmbAcl(request: EnableSmbAclRequest): EnableSmbAclResponse {
  var runtime = new $RuntimeOptions{};
  return enableSmbAclWithOptions(request, runtime);
}

model GetDirectoryOrFilePropertiesRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  path?: string(name='Path', description='The absolute path of the directory.

The path must start with a forward slash (/) and must be a path that exists in the mount target.

This parameter is required.', example='/pathway/to/folder'),
}

model GetDirectoryOrFilePropertiesResponseBody = {
  entry?: {
    ATime?: string(name='ATime', description='The time when the file was queried.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is returned only if the value of the Type parameter is File.', example='2021-02-01T10:08:08Z'),
    CTime?: string(name='CTime', description='The time when the metadata was modified.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is returned only if the value of the Type parameter is File.', example='2021-02-11T10:08:10Z'),
    hasArchiveFile?: boolean(name='HasArchiveFile', description='Indicates whether the directory contains files stored in the Archive storage class.

This parameter is returned only if the Type parameter is set to Directory.

Valid values:

*   true: The directory contains files stored in the Archive storage class.
*   false: The directory does not contain files stored in the Archive storage class.', example='false'),
    hasInfrequentAccessFile?: boolean(name='HasInfrequentAccessFile', description='Indicates whether the directory contains files stored in the IA storage medium.

This parameter is returned only if the value of the Type parameter is Directory.

Valid values:

*   true: The directory contains files stored in the IA storage medium.
*   false: The directory does not contain files stored in the IA storage medium.', example='true'),
    inode?: string(name='Inode', description='The file or directory inode.', example='40'),
    MTime?: string(name='MTime', description='The time when the file was modified.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is returned only if the value of the Type parameter is File.', example='2021-02-11T10:08:08Z'),
    name?: string(name='Name', description='The name of the file or directory.', example='file.txt'),
    retrieveTime?: string(name='RetrieveTime', description='The time when the last data retrieval task was run.

The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is returned only if the value of the Type parameter is File.', example='2021-02-11T10:08:08Z'),
    size?: long(name='Size', description='The size of the file.

Unit: bytes.

This parameter is returned only if the value of the Type parameter is File.', example='1024'),
    storageType?: string(name='StorageType', description='The storage class of the file.

This parameter is returned only if the value of the Type parameter is File.

Valid values:

*   standard: General-purpose NAS file system
*   InfrequentAccess: the IA storage class.', example='InfrequentAccess'),
    type?: string(name='Type', description='The type of the query result.

Valid values:

*   File
*   Directory', example='File'),
  }(name='Entry', description='The details about the file or directory.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model GetDirectoryOrFilePropertiesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDirectoryOrFilePropertiesResponseBody(name='body'),
}

/**
 * @summary Queries whether a directory contains files that are stored in the Infrequent Access (IA) or Archive storage class, or whether a file is stored in the IA or Archive storage class.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request GetDirectoryOrFilePropertiesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetDirectoryOrFilePropertiesResponse
 */
@context("getDirectoryOrFilePropertiesWithContext")
async function getDirectoryOrFilePropertiesWithOptions(request: GetDirectoryOrFilePropertiesRequest, runtime: $RuntimeOptions): GetDirectoryOrFilePropertiesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetDirectoryOrFileProperties',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether a directory contains files that are stored in the Infrequent Access (IA) or Archive storage class, or whether a file is stored in the IA or Archive storage class.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request GetDirectoryOrFilePropertiesRequest
 * @return GetDirectoryOrFilePropertiesResponse
 */
async function getDirectoryOrFileProperties(request: GetDirectoryOrFilePropertiesRequest): GetDirectoryOrFilePropertiesResponse {
  var runtime = new $RuntimeOptions{};
  return getDirectoryOrFilePropertiesWithOptions(request, runtime);
}

model GetRecycleBinAttributeRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model GetRecycleBinAttributeResponseBody = {
  recycleBinAttribute?: {
    archiveSize?: long(name='ArchiveSize', description='The size of the archived data that is dumped to the recycle bin. Unit: bytes.', example='1611661312'),
    enableTime?: string(name='EnableTime', description='The time at which the recycle bin was enabled.', example='2021-05-30T10:08:08Z'),
    reservedDays?: long(name='ReservedDays', description='The retention period of the files in the recycle bin. Unit: days.

If the recycle bin is disabled, 0 is returned for this parameter.', example='0'),
    secondarySize?: long(name='SecondarySize', description='The size of the Infrequent Access (IA) data that is dumped to the recycle bin. Unit: bytes.', example='100'),
    size?: long(name='Size', description='The size of the files that are dumped to the recycle bin. Unit: bytes.', example='100'),
    status?: string(name='Status', description='The status of the recycle bin.

Valid values:

*   Enable: The recycle bin is enabled.
*   Disable: The recycle bin is disabled.', example='Disable'),
  }(name='RecycleBinAttribute', description='The description of the recycle bin.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model GetRecycleBinAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRecycleBinAttributeResponseBody(name='body'),
}

/**
 * @summary Queries the recycle bin configurations of a General-purpose NAS file system.
 *
 * @description Only General-purpose File Storage NAS (NAS) file systems support this operation.
 *
 * @param request GetRecycleBinAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetRecycleBinAttributeResponse
 */
@context("getRecycleBinAttributeWithContext")
async function getRecycleBinAttributeWithOptions(request: GetRecycleBinAttributeRequest, runtime: $RuntimeOptions): GetRecycleBinAttributeResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetRecycleBinAttribute',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the recycle bin configurations of a General-purpose NAS file system.
 *
 * @description Only General-purpose File Storage NAS (NAS) file systems support this operation.
 *
 * @param request GetRecycleBinAttributeRequest
 * @return GetRecycleBinAttributeResponse
 */
async function getRecycleBinAttribute(request: GetRecycleBinAttributeRequest): GetRecycleBinAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return getRecycleBinAttributeWithOptions(request, runtime);
}

model ListDirectoriesAndFilesRequest {
  directoryOnly?: boolean(name='DirectoryOnly', description='Specifies whether to query only directories.

Valid values:

*   false (default): queries both directories and files.
*   true: queries only directories.

>  If you set the StorageType parameter to All, you must set the DirectoryOnly parameter to true.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  maxResults?: long(name='MaxResults', description='The maximum number of directories or files to include in the results of each query.

Valid values: 10 to 128.

Default value: 100.', example='100'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  path?: string(name='Path', description='The absolute path of the directory.

The path must start with a forward slash (/) and must be a path that exists in the mount target.

This parameter is required.', example='/pathway/to/folder'),
  storageType?: string(name='StorageType', description='The storage class.

*   InfrequentAccess: the Infrequent Access (IA) storage class.
*   Archive: the Archive storage class.
*   All: all stored data.

>  If you set the StorageType parameter to All, you must set the DirectoryOnly parameter to true.

This parameter is required.', example='InfrequentAccess'),
}

model ListDirectoriesAndFilesResponseBody = {
  entries?: [ 
    {
      atime?: string(name='Atime', description='The time when the file was queried.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

This parameter is returned and valid only if the value of the Type parameter is File.', example='2021-02-01T10:08:08Z'),
      ctime?: string(name='Ctime', description='The time when the raw data was modified.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

This parameter is returned and valid only if the value of the Type parameter is File.', example='2021-02-11T10:08:10Z'),
      fileId?: string(name='FileId', description='The ID of the directory or file.', example='66'),
      hasArchiveFile?: string(name='HasArchiveFile', description='Indicates whether the directory contains files stored in the Archive storage class.

This parameter is returned and valid only if the value of the Type parameter is Directory.

Valid values:

*   true: The directory contains files stored in the Archive storage class.
*   false: The directory does not contain files stored in the Archive storage class.', example='true'),
      hasInfrequentAccessFile?: boolean(name='HasInfrequentAccessFile', description='Indicates whether the directory contains files stored in the IA storage class.

This parameter is returned and valid only if the value of the Type parameter is Directory.

Valid values:

*   true: The directory contains files stored in the IA storage class.
*   false: The directory does not contain files stored in the IA storage class.', example='true'),
      inode?: string(name='Inode', description='The file or directory inode.', example='66'),
      mtime?: string(name='Mtime', description='The time when the file was modified.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

This parameter is returned and valid only if the value of the Type parameter is File.', example='2021-02-11T10:08:08Z'),
      name?: string(name='Name', description='The name of the file or directory.', example='file.txt'),
      owner?: string(name='Owner', description='The ID of the portable account. This parameter is returned and valid only if the value of the ProtocolType parameter is SMB and RAM-based access control is enabled.', example='37862c****'),
      retrieveTime?: string(name='RetrieveTime', description='The time when the last data retrieval task was run.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.

This parameter is returned and valid only if the value of the Type parameter is File.', example='2021-02-11T10:08:08Z'),
      size?: long(name='Size', description='The size of the file.

Unit: bytes.

This parameter is returned and valid only if the value of the Type parameter is File.', example='1024'),
      storageType?: string(name='StorageType', description='The storage class.

This parameter is returned and valid only if the value of the Type parameter is File.

Valid values:

*   InfrequentAccess: the IA storage class.
*   Archive: the Archive storage class.', example='InfrequentAccess'),
      type?: string(name='Type', description='The type of the query result.

Valid values:

*   File
*   Directory', example='Directory'),
    }
  ](name='Entries', description='The details about the files or directories.'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='TGlzdFJlc291cmNlU****mVzJjE1MTI2NjY4NzY5MTAzOTEmMiZORnI4NDhVeEtrUT0='),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model ListDirectoriesAndFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDirectoriesAndFilesResponseBody(name='body'),
}

/**
 * @summary Queries the infrequently-accessed files in a specified directory of a General-purpose NAS file system and the subdirectories that contain the files.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListDirectoriesAndFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListDirectoriesAndFilesResponse
 */
@context("listDirectoriesAndFilesWithContext")
async function listDirectoriesAndFilesWithOptions(request: ListDirectoriesAndFilesRequest, runtime: $RuntimeOptions): ListDirectoriesAndFilesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.directoryOnly)) {
    query['DirectoryOnly'] = request.directoryOnly;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListDirectoriesAndFiles',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the infrequently-accessed files in a specified directory of a General-purpose NAS file system and the subdirectories that contain the files.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListDirectoriesAndFilesRequest
 * @return ListDirectoriesAndFilesResponse
 */
async function listDirectoriesAndFiles(request: ListDirectoriesAndFilesRequest): ListDirectoriesAndFilesResponse {
  var runtime = new $RuntimeOptions{};
  return listDirectoriesAndFilesWithOptions(request, runtime);
}

model ListLifecycleRetrieveJobsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  status?: string(name='Status', description='The status of the data retrieval task. Valid values:

*   active: The task is running.
*   canceled: The task is canceled.
*   completed: The task is completed.
*   failed: The task has failed.', example='completed'),
  storageType?: string(name='StorageType', description='The storage class.

*   InfrequentAccess: the Infrequent Access (IA) storage class.
*   Archive: the Archive storage class.

>  If the StorageType parameter is not specified, data retrieval tasks of all types are returned.', example='InfrequentAccess'),
}

model ListLifecycleRetrieveJobsResponseBody = {
  lifecycleRetrieveJobs?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the task was created.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.', example='2021-02-30T10:08:08Z'),
      discoveredFileCount?: long(name='DiscoveredFileCount', description='The total number of files that are read in the data retrieval task.', example='100'),
      fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='31a8e4****'),
      jobId?: string(name='JobId', description='The ID of the data retrieval task.', example='lrj-nfstest-ia-160****853-hshvw'),
      paths?: [ string ](name='Paths', description='The execution path of the data retrieval task.'),
      retrievedFileCount?: long(name='RetrievedFileCount', description='The total number of files that are retrieved.', example='80'),
      status?: string(name='Status', description='The status of the data retrieval task. Valid values:

*   active: The task is running.
*   canceled: The task is canceled.
*   completed: The task is completed.
*   failed: The task has failed.', example='completed'),
      storageType?: string(name='StorageType', description='The storage class.

*   InfrequentAccess: the IA storage class.
*   Archive: the Archive storage class.', example='InfrequentAccess'),
      updateTime?: string(name='UpdateTime', description='The time when the task was updated.

The time follows the ISO 8601 standard in the `yyyy-MM-ddTHH:mm:ssZ` format.', example='2021-02-30T11:08:08Z'),
    }
  ](name='LifecycleRetrieveJobs', description='The details about the data retrieval tasks.'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  totalCount?: int32(name='TotalCount', description='The total number of data retrieval tasks.', example='10'),
}

model ListLifecycleRetrieveJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLifecycleRetrieveJobsResponseBody(name='body'),
}

/**
 * @summary Queries data retrieval tasks.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListLifecycleRetrieveJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListLifecycleRetrieveJobsResponse
 */
@context("listLifecycleRetrieveJobsWithContext")
async function listLifecycleRetrieveJobsWithOptions(request: ListLifecycleRetrieveJobsRequest, runtime: $RuntimeOptions): ListLifecycleRetrieveJobsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListLifecycleRetrieveJobs',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries data retrieval tasks.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListLifecycleRetrieveJobsRequest
 * @return ListLifecycleRetrieveJobsResponse
 */
async function listLifecycleRetrieveJobs(request: ListLifecycleRetrieveJobsRequest): ListLifecycleRetrieveJobsResponse {
  var runtime = new $RuntimeOptions{};
  return listLifecycleRetrieveJobsWithOptions(request, runtime);
}

model ListRecentlyRecycledDirectoriesRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  maxResults?: long(name='MaxResults', description='The number of directories to return for each query.

Valid values: 10 to 1000.

Default value: 100.', example='100'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.

If not all directories are returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.', example='1256****25'),
}

model ListRecentlyRecycledDirectoriesResponseBody = {
  entries?: [ 
    {
      fileId?: string(name='FileId', description='The ID of the directory.', example='04***08'),
      lastDeleteTime?: string(name='LastDeleteTime', description='The time when the directory was last deleted.', example='2021-05-30T10:08:08Z'),
      name?: string(name='Name', description='The name of the directory.', example='b'),
      path?: string(name='Path', description='The absolute path to the directory.', example='/a/b'),
    }
  ](name='Entries', description='The information about the directories that are recently deleted.'),
  nextToken?: string(name='NextToken', description='A pagination token.

If not all directories are returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.', example='1256****25'),
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
}

model ListRecentlyRecycledDirectoriesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecentlyRecycledDirectoriesResponseBody(name='body'),
}

/**
 * @summary Queries the directories that are recently deleted.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListRecentlyRecycledDirectoriesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRecentlyRecycledDirectoriesResponse
 */
@context("listRecentlyRecycledDirectoriesWithContext")
async function listRecentlyRecycledDirectoriesWithOptions(request: ListRecentlyRecycledDirectoriesRequest, runtime: $RuntimeOptions): ListRecentlyRecycledDirectoriesResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRecentlyRecycledDirectories',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the directories that are recently deleted.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListRecentlyRecycledDirectoriesRequest
 * @return ListRecentlyRecycledDirectoriesResponse
 */
async function listRecentlyRecycledDirectories(request: ListRecentlyRecycledDirectoriesRequest): ListRecentlyRecycledDirectoriesResponse {
  var runtime = new $RuntimeOptions{};
  return listRecentlyRecycledDirectoriesWithOptions(request, runtime);
}

model ListRecycleBinJobsRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  jobId?: string(name='JobId', description='The job ID.', example='rb-15****ed-r-1625****2441'),
  pageNumber?: long(name='PageNumber', description='The page number.

Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.

Valid values: 1 to 100.

Default value: 10.', example='10'),
  status?: string(name='Status', description='The job status. Valid values:

*   Running: The job is running.
*   Defragmenting: The job is defragmenting data.
*   PartialSuccess: The job is partially completed.
*   Success: The job is completed.
*   Fail: The job failed.
*   Cancelled: The job is canceled.
*   all (default)', example='All'),
}

model ListRecycleBinJobsResponseBody = {
  jobs?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the job was created.', example='2021-05-30T10:08:08Z'),
      errorCode?: string(name='ErrorCode', description='The error code returned.

A valid value is returned only if you set the Status parameter to Fail or PartialSuccess.', example='InvalidFileId.NotFound'),
      errorMessage?: string(name='ErrorMessage', description='The error message.

A valid value is returned only if you set the Status parameter to Fail or PartialSuccess.', example='The Target File or Directory does not exist.'),
      fileId?: string(name='FileId', description='The ID of the file or directory in the job.', example='04***08'),
      fileName?: string(name='FileName', description='The name of the file or directory that is associated with the job.', example='test001'),
      id?: string(name='Id', description='The job ID.', example='8C****C54'),
      progress?: string(name='Progress', description='The progress of the job.

Valid values: 1 to 100.', example='100'),
      status?: string(name='Status', description='The status of the job. Valid values:

*   Running: The job is running.
*   Defragmenting: The job is defragmenting data.
*   PartialSuccess: The job is partially completed.
*   Success: The job is completed.
*   Fail: The job failed.
*   Cancelled: The job is canceled.', example='Fail'),
      type?: string(name='Type', description='The type of the job. Valid values:

*   Restore: a file restoration job
*   Delete: a file deletion job', example='Restore'),
    }
  ](name='Jobs', description='The information about the jobs of the recycle bin.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of jobs returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='9E15E394-38A6-457A-A62A-D9797C9A****'),
  totalCount?: long(name='TotalCount', description='The total number of jobs.', example='1'),
}

model ListRecycleBinJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecycleBinJobsResponseBody(name='body'),
}

/**
 * @summary Queries the jobs of the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can query a maximum of 50 jobs that are recently executed.
 *
 * @param request ListRecycleBinJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRecycleBinJobsResponse
 */
@context("listRecycleBinJobsWithContext")
async function listRecycleBinJobsWithOptions(request: ListRecycleBinJobsRequest, runtime: $RuntimeOptions): ListRecycleBinJobsResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRecycleBinJobs',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the jobs of the recycle bin.
 *
 * @description *   Only General-purpose NAS file systems support this operation.
 * *   You can query a maximum of 50 jobs that are recently executed.
 *
 * @param request ListRecycleBinJobsRequest
 * @return ListRecycleBinJobsResponse
 */
async function listRecycleBinJobs(request: ListRecycleBinJobsRequest): ListRecycleBinJobsResponse {
  var runtime = new $RuntimeOptions{};
  return listRecycleBinJobsWithOptions(request, runtime);
}

model ListRecycledDirectoriesAndFilesRequest {
  fileId?: string(name='FileId', description='The ID of the directory that you want to query.

You can call the [ListRecentlyRecycledDirectories ](https://help.aliyun.com/document_detail/2412173.html)operation to query the file ID.

This parameter is required.', example='04***08'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  maxResults?: long(name='MaxResults', description='The number of files or directories to return for each query.

Valid values: 10 to 1000.

Default value: 100.', example='100'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You do not need to specify this parameter for the first request.

If all the files and directories are incompletely returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.', example='CJyNARIsMTY5OTI2NjQ3NTEzMjY2OTMwOF8xODA5NF8ufnl0YkROTl9uZXcuaXB5bmI='),
}

model ListRecycledDirectoriesAndFilesResponseBody = {
  entries?: [ 
    {
      ATime?: string(name='ATime', description='The time when the file or directory was last accessed.', example='2019-10-30T10:08:08Z'),
      CTime?: string(name='CTime', description='The time when the metadata was last modified.', example='2019-10-30T10:08:08Z'),
      deleteTime?: string(name='DeleteTime', description='The time when the file or directory was deleted.', example='2021-05-30T10:08:08Z'),
      fileId?: string(name='FileId', description='The IDs of the files or directories.', example='04***08'),
      inode?: string(name='Inode', description='The inode of the file or directory.', example='04***08'),
      MTime?: string(name='MTime', description='The time when the file or directory was last modified.', example='2019-10-30T10:08:08Z'),
      name?: string(name='Name', description='The name of the file or directory before it was deleted.', example='test001'),
      size?: long(name='Size', description='The size of the file. Unit: bytes.

The value 0 is returned for this parameter if Directory is returned for the Type parameter.', example='1073741824'),
      type?: string(name='Type', description='The type of the returned object. Valid values:

*   File
*   Directory', example='File'),
    }
  ](name='Entries', description='The information about files or directories in the recycle bin.'),
  nextToken?: string(name='NextToken', description='A pagination token.

If all the files and directories are incompletely returned in a query, the return value of the NextToken parameter is not empty. In this case, you can specify a valid value for the NextToken parameter to continue the query.', example='CKuO8QMSIjE2OTc3NzI0NjI5MTcyMTYyNDVfMzEzNTUyMF81MjEzODY='),
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ListRecycledDirectoriesAndFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRecycledDirectoriesAndFilesResponseBody(name='body'),
}

/**
 * @summary Queries deleted files or directories.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListRecycledDirectoriesAndFilesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListRecycledDirectoriesAndFilesResponse
 */
@context("listRecycledDirectoriesAndFilesWithContext")
async function listRecycledDirectoriesAndFilesWithOptions(request: ListRecycledDirectoriesAndFilesRequest, runtime: $RuntimeOptions): ListRecycledDirectoriesAndFilesResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListRecycledDirectoriesAndFiles',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries deleted files or directories.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ListRecycledDirectoriesAndFilesRequest
 * @return ListRecycledDirectoriesAndFilesResponse
 */
async function listRecycledDirectoriesAndFiles(request: ListRecycledDirectoriesAndFilesRequest): ListRecycledDirectoriesAndFilesResponse {
  var runtime = new $RuntimeOptions{};
  return listRecycledDirectoriesAndFilesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results.', example='MTcyNDU1MTYyNjIxNTMyNzM4NiMzNjExMzQxNw=='),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs.', example='03e08484f0'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to filesystem.

This parameter is required.', example='filesystem'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.

Limits:

*   The tag key cannot be left empty.
*   Valid values of N: 1 to 20.
*   The tag key must be 1 to 128 characters in length.
*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.', example='nastest'),
      value?: string(name='Value', description='The tag value.

Limits:

*   Valid values of N: 1 to 20.
*   The tag value must be 1 to 128 characters in length.
*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or `https://`.', example='filetest'),
    }
  ](name='Tag', description='The details about the tags.'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results. If the value of this parameter is null, no queries are performed after the current query.', example='MTcyNDU1MTYyNjIxNTMyNzM4NiMzNjExMzQxNw=='),
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId', description='The resource ID.', example='i-2zebd226fxed6h4iadhe'),
      resourceType?: string(name='ResourceType', description='The resource type.', example='filesystem'),
      tagKey?: string(name='TagKey', description='The tag key.', example='test1'),
      tagValue?: string(name='TagValue', description='The tag value.', example='test'),
    }
  ](name='TagResource')
  }(name='TagResources', description='The list of resources.'),
}

model ListTagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListTagResourcesResponseBody(name='body'),
}

/**
 * @summary Queries tags.
 *
 * @param request ListTagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListTagResourcesResponse
 */
@context("listTagResourcesWithContext")
async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: $RuntimeOptions): ListTagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListTagResources',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries tags.
 *
 * @param request ListTagResourcesRequest
 * @return ListTagResourcesResponse
 */
async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ModifyAccessGroupRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

Limits:

*   The name must be 3 to 64 characters in length.
*   The name must start with a letter and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='vpc-test'),
  description?: string(name='Description', description='The description of the permission group.

Limits:

*   By default, the description of the permission group is the same as the name of the permission group. The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain digits, colons (:), underscores (_), and hyphens (-).', example='vpc-test'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system
*   extreme: Extreme NAS file system', example='standard'),
}

model ModifyAccessGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='ED2AE737-9D50-4CA4-B0DA-31BD610C****'),
}

model ModifyAccessGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccessGroupResponseBody(name='body'),
}

/**
 * @summary Modifies a permission group.
 *
 * @description The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
 *
 * @param request ModifyAccessGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccessGroupResponse
 */
@context("modifyAccessGroupWithContext")
async function modifyAccessGroupWithOptions(request: ModifyAccessGroupRequest, runtime: $RuntimeOptions): ModifyAccessGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAccessGroup',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a permission group.
 *
 * @description The default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
 *
 * @param request ModifyAccessGroupRequest
 * @return ModifyAccessGroupResponse
 */
async function modifyAccessGroup(request: ModifyAccessGroupRequest): ModifyAccessGroupResponse {
  var runtime = new $RuntimeOptions{};
  return modifyAccessGroupWithOptions(request, runtime);
}

model ModifyAccessPointRequest {
  accessGroup?: string(name='AccessGroup', description='The name of the permission group.

This parameter is required for a General-purpose File Storage NAS (NAS) file system.

The default permission group for virtual private clouds (VPCs) is named DEFAULT_VPC_GROUP_NAME.', example='DEFAULT_VPC_GROUP_NAME'),
  accessPointId?: string(name='AccessPointId', description='The ID of the access point.

This parameter is required.', example='ap-ie15yd****'),
  accessPointName?: string(name='AccessPointName', description='The name of the access point.', example='test'),
  enabledRam?: boolean(name='EnabledRam', description='Specifies whether to enable the Resource Access Management (RAM) policy. Valid values:

*   true: The RAM policy is enabled.
*   false (default): The RAM policy is disabled.

>  After the RAM policy is enabled for access points, no RAM user is allowed to use access points to mount and access data by default. To use access points to mount and access data as a RAM user, you must grant the related access permissions to the RAM user. If the RAM policy is disabled, access points can be anonymously mounted.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
}

model ModifyAccessPointResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.

This parameter is required.', example='70EACC9C-D07A-4A34-ADA4-77506C42****'),
}

model ModifyAccessPointResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccessPointResponseBody(name='body'),
}

/**
 * @summary Modifies the information about an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request ModifyAccessPointRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccessPointResponse
 */
@context("modifyAccessPointWithContext")
async function modifyAccessPointWithOptions(request: ModifyAccessPointRequest, runtime: $RuntimeOptions): ModifyAccessPointResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroup)) {
    query['AccessGroup'] = request.accessGroup;
  }
  if (!$isNull(request.accessPointId)) {
    query['AccessPointId'] = request.accessPointId;
  }
  if (!$isNull(request.accessPointName)) {
    query['AccessPointName'] = request.accessPointName;
  }
  if (!$isNull(request.enabledRam)) {
    query['EnabledRam'] = request.enabledRam;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAccessPoint',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the information about an access point.
 *
 * @description Only General-purpose Network File System (NFS) file systems support this operation.
 *
 * @param request ModifyAccessPointRequest
 * @return ModifyAccessPointResponse
 */
async function modifyAccessPoint(request: ModifyAccessPointRequest): ModifyAccessPointResponse {
  var runtime = new $RuntimeOptions{};
  return modifyAccessPointWithOptions(request, runtime);
}

model ModifyAccessRuleRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group.

This parameter is required.', example='vpc-test'),
  accessRuleId?: string(name='AccessRuleId', description='The rule ID.

This parameter is required.', example='1'),
  fileSystemType?: string(name='FileSystemType', description='The type of the file system.

Valid values:

*   standard (default): General-purpose NAS file system.
*   extreme: Extreme NAS file system.', example='standard'),
  ipv6SourceCidrIp?: string(name='Ipv6SourceCidrIp', description='The IPv6 address or CIDR block of the authorized object.

You must set this parameter to an IPv6 IP address or CIDR block.

> *   Only Extreme NAS file systems that reside in the China (Hohhot) region support IPv6.
>*   Only permission groups that reside in virtual private clouds (VPCs) support IPv6.
>*   This parameter is unavailable if you specify the SourceCidrIp parameter.', example='fe80::3d4a:80fd:f05d:****'),
  priority?: int32(name='Priority', description='The priority of the rule.

Valid values: 1 to 100.

Default value: 1, which indicates the highest priority.', example='1'),
  RWAccessType?: string(name='RWAccessType', description='The access permissions of the authorized object on the file system.

Valid values:

*   RDWR (default): the read and write permissions.
*   RDONLY: the read-only permissions.', example='RDWR'),
  sourceCidrIp?: string(name='SourceCidrIp', description='The IP address or CIDR block of the authorized object.

You must set this parameter to an IP address or CIDR block.', example='``192.0.**.**``'),
  userAccessType?: string(name='UserAccessType', description='The access permissions for different types of users in the authorized object.

Valid values:

*   no_squash: allows access from root users to the file system.
*   root_squash: grants root users the least permissions as the nobody user.
*   all_squash: grants all users the least permissions as the nobody user.

The nobody user has the least permissions in Linux and can access only the public content of the file system. This ensures the security of the file system.', example='all_squash'),
}

model ModifyAccessRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6299428C-3861-435D-AE54-9B330A00****'),
}

model ModifyAccessRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccessRuleResponseBody(name='body'),
}

/**
 * @summary Modifies a rule in a permission group.
 *
 * @description The rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
 *
 * @param request ModifyAccessRuleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccessRuleResponse
 */
@context("modifyAccessRuleWithContext")
async function modifyAccessRuleWithOptions(request: ModifyAccessRuleRequest, runtime: $RuntimeOptions): ModifyAccessRuleResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.accessRuleId)) {
    query['AccessRuleId'] = request.accessRuleId;
  }
  if (!$isNull(request.fileSystemType)) {
    query['FileSystemType'] = request.fileSystemType;
  }
  if (!$isNull(request.ipv6SourceCidrIp)) {
    query['Ipv6SourceCidrIp'] = request.ipv6SourceCidrIp;
  }
  if (!$isNull(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!$isNull(request.RWAccessType)) {
    query['RWAccessType'] = request.RWAccessType;
  }
  if (!$isNull(request.sourceCidrIp)) {
    query['SourceCidrIp'] = request.sourceCidrIp;
  }
  if (!$isNull(request.userAccessType)) {
    query['UserAccessType'] = request.userAccessType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAccessRule',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a rule in a permission group.
 *
 * @description The rules in the default permission group (DEFAULT_VPC_GROUP_NAME) cannot be modified.
 *
 * @param request ModifyAccessRuleRequest
 * @return ModifyAccessRuleResponse
 */
async function modifyAccessRule(request: ModifyAccessRuleRequest): ModifyAccessRuleResponse {
  var runtime = new $RuntimeOptions{};
  return modifyAccessRuleWithOptions(request, runtime);
}

model ModifyAutoSnapshotPolicyRequest {
  autoSnapshotPolicyId?: string(name='AutoSnapshotPolicyId', description='The ID of the automatic snapshot policy.

You can call the DescribeAutoSnapshotPolicies operation to view available automatic snapshot policies.

This parameter is required.', example='sp-extreme-233e6****'),
  autoSnapshotPolicyName?: string(name='AutoSnapshotPolicyName', description='The name of the automatic snapshot policy. If you do not specify this parameter, the policy name is not changed.

Limits:

*   The name must be 2 to 128 characters in length.
*   The name must start with a letter.
*   The name can contain digits, letters, colons (:), underscores (_), and hyphens (-). It cannot start with `http://` or `https://`.', example='FinanceJoshua'),
  repeatWeekdays?: string(name='RepeatWeekdays', description='The days of a week on which auto snapshots are created.

Cycle: week.

Valid values: 1 to 7. The value 1 indicates Monday. If you want to create multiple auto snapshots within a week, you can specify multiple days from Monday to Sunday and separate the days with commas (,). You can specify a maximum of seven days.', example='1,7'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of auto snapshots.

Unit: days.

Valid values:

*   \\\\-1 (default): Auto snapshots are permanently retained. After the number of auto snapshots exceeds the upper limit, the earliest auto snapshot is automatically deleted.
*   1 to 65536: Auto snapshots are retained for the specified number of days. After the retention period of auto snapshots expires, the auto snapshots are automatically deleted.', example='30'),
  timePoints?: string(name='TimePoints', description='The points in time at which auto snapshots are created.

Unit: hours.

Valid values: 0 to 23. The values from 0 to 23 indicate a total of 24 hours from 00:00 to 23:00. For example, the value 1 indicates 01:00. If you want to create multiple auto snapshots within a day, you can specify multiple points in time and separate the points in time with commas (,). You can specify a maximum of 24 points in time.', example='0,1'),
}

model ModifyAutoSnapshotPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.

Every response returns a unique request ID regardless of whether the request is successful.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ModifyAutoSnapshotPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAutoSnapshotPolicyResponseBody(name='body'),
}

/**
 * @summary An automatic snapshot policy is modified. After you modify an automatic snapshot policy that is applied to a file system, the modification immediately applies to subsequent snapshots that are created for the file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request ModifyAutoSnapshotPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAutoSnapshotPolicyResponse
 */
@context("modifyAutoSnapshotPolicyWithContext")
async function modifyAutoSnapshotPolicyWithOptions(request: ModifyAutoSnapshotPolicyRequest, runtime: $RuntimeOptions): ModifyAutoSnapshotPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoSnapshotPolicyId)) {
    query['AutoSnapshotPolicyId'] = request.autoSnapshotPolicyId;
  }
  if (!$isNull(request.autoSnapshotPolicyName)) {
    query['AutoSnapshotPolicyName'] = request.autoSnapshotPolicyName;
  }
  if (!$isNull(request.repeatWeekdays)) {
    query['RepeatWeekdays'] = request.repeatWeekdays;
  }
  if (!$isNull(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!$isNull(request.timePoints)) {
    query['TimePoints'] = request.timePoints;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyAutoSnapshotPolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary An automatic snapshot policy is modified. After you modify an automatic snapshot policy that is applied to a file system, the modification immediately applies to subsequent snapshots that are created for the file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 *
 * @param request ModifyAutoSnapshotPolicyRequest
 * @return ModifyAutoSnapshotPolicyResponse
 */
async function modifyAutoSnapshotPolicy(request: ModifyAutoSnapshotPolicyRequest): ModifyAutoSnapshotPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return modifyAutoSnapshotPolicyWithOptions(request, runtime);
}

model ModifyDataFlowRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The value of RequestId may be different for each API request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  description?: string(name='Description', description='The description of the dataflow.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter but cannot start with http:// or https://.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for Lingjun file systems must start with `bmcpfs-`. Example: bmcpfs-0015\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='cpfs-099394bd928c****'),
  throughput?: long(name='Throughput', description='The maximum data flow throughput. Unit: MB/s. Valid values:

*   600
*   1200
*   1500

>  The data flow throughput must be less than the I/O throughput of the file system. This parameter is required for CPFS file systems.', example='600'),
}

model ModifyDataFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ModifyDataFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDataFlowResponseBody(name='body'),
}

/**
 * @summary Modifies the attributes of a dataflow.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows.
 * *   You can modify the attributes only of the data flows that are in the `Running` state.
 * *   It generally takes 2 to 5 minutes to modify the attributes of a data flow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the status of the data flow to be modified.
 * *   CPFS data flow specifications:
 *     *   The data flow throughput supports the following specifications: 600 MB/s, 1,200 MB/s, and 1,500 MB/s. The data flow throughput is the maximum transmission bandwidth that can be reached when data is imported or exported for a data flow.
 *     *   Inventory query: If you set the DryRun parameter to true, you can check whether the resources for the dataflow whose throughput is changed meet the requirements.
 * *   Billing of CPFS file systems
 *     Changing the dataflow throughput involves the billing of dataflow bandwidth. We recommend that you understand CPFS billing methods in advance. For more information, see [Billing methods and billable items of CPFS](https://help.aliyun.com/document_detail/111858.html).
 *
 * @param request ModifyDataFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDataFlowResponse
 */
@context("modifyDataFlowWithContext")
async function modifyDataFlowWithOptions(request: ModifyDataFlowRequest, runtime: $RuntimeOptions): ModifyDataFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.throughput)) {
    query['Throughput'] = request.throughput;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyDataFlow',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the attributes of a dataflow.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) V2.2.0 and later and CPFS for Lingjun V2.4.0 and later support data flows.
 * *   You can modify the attributes only of the data flows that are in the `Running` state.
 * *   It generally takes 2 to 5 minutes to modify the attributes of a data flow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the status of the data flow to be modified.
 * *   CPFS data flow specifications:
 *     *   The data flow throughput supports the following specifications: 600 MB/s, 1,200 MB/s, and 1,500 MB/s. The data flow throughput is the maximum transmission bandwidth that can be reached when data is imported or exported for a data flow.
 *     *   Inventory query: If you set the DryRun parameter to true, you can check whether the resources for the dataflow whose throughput is changed meet the requirements.
 * *   Billing of CPFS file systems
 *     Changing the dataflow throughput involves the billing of dataflow bandwidth. We recommend that you understand CPFS billing methods in advance. For more information, see [Billing methods and billable items of CPFS](https://help.aliyun.com/document_detail/111858.html).
 *
 * @param request ModifyDataFlowRequest
 * @return ModifyDataFlowResponse
 */
async function modifyDataFlow(request: ModifyDataFlowRequest): ModifyDataFlowResponse {
  var runtime = new $RuntimeOptions{};
  return modifyDataFlowWithOptions(request, runtime);
}

model ModifyDataFlowAutoRefreshRequest {
  autoRefreshInterval?: long(name='AutoRefreshInterval', description='The automatic update interval. CPFS checks whether data is updated in the directory at the interval specified by this parameter. If data is updated, CPFS starts an automatic update task. Unit: minute.

Valid values: 5 to 526600. Default value: 10.', example='10'),
  autoRefreshPolicy?: string(name='AutoRefreshPolicy', description='The automatic update policy. The updated data in the source storage is imported into the CPFS file system based on the policy. The following information is displayed:

*   None: Updated data in the source storage is not automatically imported into the CPFS file system. You can run a dataflow task to import the updated data from the source storage.
*   ImportChanged: Updated data in the source storage is automatically imported into the CPFS file system.', example='None'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset quota is canceled and no fee is incurred.

Valid value:

*   true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available Apsara File Storage NAS (NAS) resources. Otherwise, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a fileset is created.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
}

model ModifyDataFlowAutoRefreshResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ModifyDataFlowAutoRefreshResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDataFlowAutoRefreshResponseBody(name='body'),
}

/**
 * @summary Modifies an AutoRefresh configuration of a dataflow.
 *
 * @description *   This operation is available only to CPFS file systems.
 * *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   You can modify the AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
 * *   It generally takes 2 to 5 minutes to modify an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the task of modifying an AutoRefresh configuration.
 *
 * @param request ModifyDataFlowAutoRefreshRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDataFlowAutoRefreshResponse
 */
@context("modifyDataFlowAutoRefreshWithContext")
async function modifyDataFlowAutoRefreshWithOptions(request: ModifyDataFlowAutoRefreshRequest, runtime: $RuntimeOptions): ModifyDataFlowAutoRefreshResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.autoRefreshInterval)) {
    query['AutoRefreshInterval'] = request.autoRefreshInterval;
  }
  if (!$isNull(request.autoRefreshPolicy)) {
    query['AutoRefreshPolicy'] = request.autoRefreshPolicy;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyDataFlowAutoRefresh',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies an AutoRefresh configuration of a dataflow.
 *
 * @description *   This operation is available only to CPFS file systems.
 * *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   You can modify the AutoRefresh configurations only for the dataflows that are in the `Running` or `Stopped` state.
 * *   It generally takes 2 to 5 minutes to modify an AutoRefresh configuration. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation to query the task of modifying an AutoRefresh configuration.
 *
 * @param request ModifyDataFlowAutoRefreshRequest
 * @return ModifyDataFlowAutoRefreshResponse
 */
async function modifyDataFlowAutoRefresh(request: ModifyDataFlowAutoRefreshRequest): ModifyDataFlowAutoRefreshResponse {
  var runtime = new $RuntimeOptions{};
  return modifyDataFlowAutoRefreshWithOptions(request, runtime);
}

model ModifyFileSystemRequest {
  description?: string(name='Description', description='The description of the file system.

Limits:

*   The description must be 2 to 128 characters in length.
*   It must start with a letter but cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='NAS-test-1'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: `31a8e4****`.
*   The IDs of Extreme NAS file systems must start with `extreme-`. Example: `extreme-0015****`.
*   The IDs of Cloud Paralleled File System (CPFS) file systems must start with `cpfs-`. Example: `cpfs-125487****`.

This parameter is required.', example='1ca404****'),
  options?: {
    enableOplock?: boolean(name='EnableOplock', description='Specifies whether to enable the oplock feature. Valid values:

*   true: enables the feature.
*   false: disables the feature.

>  Only Server Message Block (SMB) file systems support this feature.', example='true'),
  }(name='Options', description='The options.'),
}

model ModifyFileSystemShrinkRequest {
  description?: string(name='Description', description='The description of the file system.

Limits:

*   The description must be 2 to 128 characters in length.
*   It must start with a letter but cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='NAS-test-1'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: `31a8e4****`.
*   The IDs of Extreme NAS file systems must start with `extreme-`. Example: `extreme-0015****`.
*   The IDs of Cloud Paralleled File System (CPFS) file systems must start with `cpfs-`. Example: `cpfs-125487****`.

This parameter is required.', example='1ca404****'),
  optionsShrink?: string(name='Options', description='The options.'),
}

model ModifyFileSystemResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5BC5CB97-9F28-42FE-84A4-0CD0DF42****'),
}

model ModifyFileSystemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFileSystemResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a file system.
 *
 * @param tmpReq ModifyFileSystemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFileSystemResponse
 */
@context("modifyFileSystemWithContext")
async function modifyFileSystemWithOptions(tmpReq: ModifyFileSystemRequest, runtime: $RuntimeOptions): ModifyFileSystemResponse {
  tmpReq.validate();
  var request = new ModifyFileSystemShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.options)) {
    request.optionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.options, 'Options', 'json');
  }
  var query = {};
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.optionsShrink)) {
    query['Options'] = request.optionsShrink;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyFileSystem',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a file system.
 *
 * @param request ModifyFileSystemRequest
 * @return ModifyFileSystemResponse
 */
async function modifyFileSystem(request: ModifyFileSystemRequest): ModifyFileSystemResponse {
  var runtime = new $RuntimeOptions{};
  return modifyFileSystemWithOptions(request, runtime);
}

model ModifyFilesetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  deletionProtection?: boolean(name='DeletionProtection', description='Specifies whether to enable deletion protection to allow you to release the fileset by using the console or by calling the [DeleteFileset](https://help.aliyun.com/document_detail/2402263.html) operation. Valid values:

*   true: enables release protection.
*   false: disables release protection.

> This parameter can protect filesets only against manual releases, but not against automatic releases.', example='false', nullable=true),
  description?: string(name='Description', description='The fileset description.', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset is modified and no fees incurred.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and Apsara File Storage NAS (NAS) inventory data. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the specified fileset is modified.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-099394bd928c\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  fsetId?: string(name='FsetId', description='The fileset ID.

This parameter is required.', example='fset-1902718ea0ae****'),
}

model ModifyFilesetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model ModifyFilesetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyFilesetResponseBody(name='body'),
}

/**
 * @summary Modifies a fileset.
 *
 * @description Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation.
 *
 * @param request ModifyFilesetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyFilesetResponse
 */
@context("modifyFilesetWithContext")
async function modifyFilesetWithOptions(request: ModifyFilesetRequest, runtime: $RuntimeOptions): ModifyFilesetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyFileset',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a fileset.
 *
 * @description Only Cloud Parallel File Storage (CPFS) V2.2.0 and CPFS for Lingjun V2.7.0 and later support this operation.
 *
 * @param request ModifyFilesetRequest
 * @return ModifyFilesetResponse
 */
async function modifyFileset(request: ModifyFilesetRequest): ModifyFilesetResponse {
  var runtime = new $RuntimeOptions{};
  return modifyFilesetWithOptions(request, runtime);
}

model ModifyLDAPConfigRequest {
  bindDN?: string(name='BindDN', description='The LDAP entry.', example='cn=alibaba,dc=com'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='109c042666'),
  searchBase?: string(name='SearchBase', description='The LDAP search base.

This parameter is required.', example='dc=example'),
  URI?: string(name='URI', description='The LDAP service address.

This parameter is required.', example='ldap://ldap.example.example'),
}

model ModifyLDAPConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5B4511A7-C99E-4071-AA8C-32E2529DA963'),
}

model ModifyLDAPConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLDAPConfigResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI ModifyLDAPConfig is deprecated
 *
 * @summary Used to modify LDAP configuration.
 *
 * @description The API operation is available only for Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request ModifyLDAPConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLDAPConfigResponse
 */
// Deprecated
@context("modifyLDAPConfigWithContext")
async function modifyLDAPConfigWithOptions(request: ModifyLDAPConfigRequest, runtime: $RuntimeOptions): ModifyLDAPConfigResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.bindDN)) {
    query['BindDN'] = request.bindDN;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.searchBase)) {
    query['SearchBase'] = request.searchBase;
  }
  if (!$isNull(request.URI)) {
    query['URI'] = request.URI;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyLDAPConfig',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI ModifyLDAPConfig is deprecated
 *
 * @summary Used to modify LDAP configuration.
 *
 * @description The API operation is available only for Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request ModifyLDAPConfigRequest
 * @return ModifyLDAPConfigResponse
 */
// Deprecated
async function modifyLDAPConfig(request: ModifyLDAPConfigRequest): ModifyLDAPConfigResponse {
  var runtime = new $RuntimeOptions{};
  return modifyLDAPConfigWithOptions(request, runtime);
}

model ModifyLifecyclePolicyRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='31a8e4****'),
  lifecyclePolicyName?: string(name='LifecyclePolicyName', description='The name of the lifecycle policy.

The name must be 3 to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The name must start with a letter.

This parameter is required.', example='lifecyclepolicy_01'),
  lifecycleRuleName?: string(name='LifecycleRuleName', description='The management rule that is associated with the lifecycle policy.

Valid values:

*   DEFAULT_ATIME_14: Files that are not accessed in the last 14 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_30: Files that are not accessed in the last 30 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_60: Files that are not accessed in the last 60 days are dumped to the IA storage medium.
*   DEFAULT_ATIME_90: Files that are not accessed in the last 90 days are dumped to the IA storage medium.', example='DEFAULT_ATIME_14'),
  path?: string(name='Path', description='The absolute path of a directory with which the lifecycle policy is associated.

The path must start with a forward slash (/) and must be a path that exists in the mount target.', example='/pathway/to/folder'),
  storageType?: string(name='StorageType', description='The storage type of the data that is dumped to the IA storage medium.

Default value: InfrequentAccess (IA).', example='InfrequentAccess'),
}

model ModifyLifecyclePolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

Valid values:

*   true
*   false', example='true'),
}

model ModifyLifecyclePolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLifecyclePolicyResponseBody(name='body'),
}

/**
 * @summary Modifies a lifecycle policy.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ModifyLifecyclePolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyLifecyclePolicyResponse
 */
@context("modifyLifecyclePolicyWithContext")
async function modifyLifecyclePolicyWithOptions(request: ModifyLifecyclePolicyRequest, runtime: $RuntimeOptions): ModifyLifecyclePolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.lifecyclePolicyName)) {
    query['LifecyclePolicyName'] = request.lifecyclePolicyName;
  }
  if (!$isNull(request.lifecycleRuleName)) {
    query['LifecycleRuleName'] = request.lifecycleRuleName;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyLifecyclePolicy',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a lifecycle policy.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request ModifyLifecyclePolicyRequest
 * @return ModifyLifecyclePolicyResponse
 */
async function modifyLifecyclePolicy(request: ModifyLifecyclePolicyRequest): ModifyLifecyclePolicyResponse {
  var runtime = new $RuntimeOptions{};
  return modifyLifecyclePolicyWithOptions(request, runtime);
}

model ModifyMountTargetRequest {
  accessGroupName?: string(name='AccessGroupName', description='The name of the permission group that is attached to the mount target.', example='classic-test'),
  dualStackMountTargetDomain?: string(name='DualStackMountTargetDomain', description='The dual-stack (IPv4 and IPv6) domain name of the mount target.

>  Only Extreme NAS file systems that reside in the Chinese mainland support IPv6.', example='174494b666-x****.dualstack.cn-hangzhou.nas.aliyuncs.com'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   Sample ID of a General-purpose NAS file system: `31a8e4****`.
*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, `extreme-0015****`.

This parameter is required.', example='1ca404****'),
  mountTargetDomain?: string(name='MountTargetDomain', description='The IPv4 domain name of the mount target.', example='1ca404a666-w****.cn-hangzhou.nas.aliyuncs.com'),
  status?: string(name='Status', description='The status of the mount target.

Valid values:

*   Active: The mount target is available.
*   Inactive: The mount target is unavailable.

>  Only General-purpose File Storage NAS (NAS) file systems support changing the mount target status.', example='Inactive'),
}

model ModifyMountTargetResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='FF387D95-34C4-4879-B65A-99D1FA1B****'),
}

model ModifyMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMountTargetResponseBody(name='body'),
}

/**
 * @summary Modifies a mount target.
 *
 * @param request ModifyMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyMountTargetResponse
 */
@context("modifyMountTargetWithContext")
async function modifyMountTargetWithOptions(request: ModifyMountTargetRequest, runtime: $RuntimeOptions): ModifyMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.accessGroupName)) {
    query['AccessGroupName'] = request.accessGroupName;
  }
  if (!$isNull(request.dualStackMountTargetDomain)) {
    query['DualStackMountTargetDomain'] = request.dualStackMountTargetDomain;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.mountTargetDomain)) {
    query['MountTargetDomain'] = request.mountTargetDomain;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a mount target.
 *
 * @param request ModifyMountTargetRequest
 * @return ModifyMountTargetResponse
 */
async function modifyMountTarget(request: ModifyMountTargetRequest): ModifyMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return modifyMountTargetWithOptions(request, runtime);
}

model ModifyProtocolMountTargetRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  description?: string(name='Description', description='The description of the export directory for the protocol service.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter but cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not modify the specified export directory or incur fees.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request.', example='true'),
  exportId?: string(name='ExportId', description='The ID of the export directory for the protocol service.

This parameter is required.', example='exp-19abf5beab8d****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.

This parameter is required.', example='ptc-197ed6a00f2b****'),
}

model ModifyProtocolMountTargetResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
}

model ModifyProtocolMountTargetResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyProtocolMountTargetResponseBody(name='body'),
}

/**
 * @summary Modifies the export directory parameters of a protocol service. Only the description can be modified. The virtual private cloud (VPC) ID and vSwitch ID cannot be changed. To change these IDs, you must delete the export directory and create a new one.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request ModifyProtocolMountTargetRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyProtocolMountTargetResponse
 */
@context("modifyProtocolMountTargetWithContext")
async function modifyProtocolMountTargetWithOptions(request: ModifyProtocolMountTargetRequest, runtime: $RuntimeOptions): ModifyProtocolMountTargetResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.exportId)) {
    query['ExportId'] = request.exportId;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.protocolServiceId)) {
    query['ProtocolServiceId'] = request.protocolServiceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyProtocolMountTarget',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the export directory parameters of a protocol service. Only the description can be modified. The virtual private cloud (VPC) ID and vSwitch ID cannot be changed. To change these IDs, you must delete the export directory and create a new one.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 *
 * @param request ModifyProtocolMountTargetRequest
 * @return ModifyProtocolMountTargetResponse
 */
async function modifyProtocolMountTarget(request: ModifyProtocolMountTargetRequest): ModifyProtocolMountTargetResponse {
  var runtime = new $RuntimeOptions{};
  return modifyProtocolMountTargetWithOptions(request, runtime);
}

model ModifyProtocolServiceRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  description?: string(name='Description', description='The description of the protocol service.

Limits:

*   The description must be 2 to 128 characters in length.
*   The description must start with a letter and cannot start with `http://` or `https://`.
*   The description can contain letters, digits, colons (:), underscores (_), and hyphens (-).', example='test', nullable=false),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request. The dry run checks parameter validity and prerequisites. The dry run does not modify a file system or incur fees.

Valid values:

*   true: performs only a dry run and does not modify the protocol service. The system checks the request format, service limits, prerequisites, and whether the required parameters are specified. If the request fails the dry run, an error message is returned. If the request passes the dry run, a 200 HTTP status code is returned.
*   false (default): performs a dry run and performs the actual request. If the request passes the dry run, the service protocol is modified.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-123****'),
  protocolServiceId?: string(name='ProtocolServiceId', description='The ID of the protocol service.

This parameter is required.', example='ptc-123****'),
}

model ModifyProtocolServiceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ModifyProtocolServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyProtocolServiceResponseBody(name='body'),
}

/**
 * @summary Modifies a protocol service. You can modify the description of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
 *
 * @param request ModifyProtocolServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyProtocolServiceResponse
 */
@context("modifyProtocolServiceWithContext")
async function modifyProtocolServiceWithOptions(request: ModifyProtocolServiceRequest, runtime: $RuntimeOptions): ModifyProtocolServiceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.protocolServiceId)) {
    query['ProtocolServiceId'] = request.protocolServiceId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifyProtocolService',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies a protocol service. You can modify the description of a protocol service.
 *
 * @description This operation is available only to Cloud Parallel File Storage (CPFS) file systems on the China site (aliyun.com).
 *
 * @param request ModifyProtocolServiceRequest
 * @return ModifyProtocolServiceResponse
 */
async function modifyProtocolService(request: ModifyProtocolServiceRequest): ModifyProtocolServiceResponse {
  var runtime = new $RuntimeOptions{};
  return modifyProtocolServiceWithOptions(request, runtime);
}

model ModifySmbAclRequest {
  enableAnonymousAccess?: boolean(name='EnableAnonymousAccess', description='Specifies whether to allow anonymous access. Valid values:

*   true: The file system allows anonymous access.
*   false (default): The file system denies anonymous access.', example='false', nullable=false),
  encryptData?: boolean(name='EncryptData', description='Specifies whether to enable encryption in transit. Valid values:

*   true: enables encryption in transit.
*   false (default): disables encryption in transit.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  homeDirPath?: string(name='HomeDirPath', description='The home directory of each user. Each user-specific home directory must meet the following requirements:

*   Each segment starts with a forward slash (/) or a backward slash (\\\\\\\\).
*   Each segment does not contain the following special characters: `<>":|?*`.
*   Each segment is 0 to 255 characters in length.
*   The total length is 0 to 32,767 characters.

For example, if you create a user named A and the home directory is `/home`, the file system automatically creates a directory named `/home/A` when User A logs on to the file system. If the `/home/A` directory already exists, the file system does not create the directory.

> User A must have the permissions to create folders in the \\\\home directory. Otherwise, the file system cannot create the `/home/A` directory when User A logs on to the file system.', example='/home'),
  keytab?: string(name='Keytab', description='The string that is generated after the system encodes the keytab file by using Base64.', example='BQIAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAQAIqIx6v7p11oUAAABHAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAAwAIqIx6v7p11oUAAABPAAIADUFMSUFEVEVTVC5DT00ABGNpZnMAGXNtYnNlcnZlcjI0LmFsaWFkdGVzdC5jb20AAAABAAAAAAEAFwAQnQZWB3RAPHU7PMIJyBWePAAAAF8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQASACAGJ7F0s+bcBjf6jD5HlvlRLmPSOW+qDZe0Qk0lQcf8WwAAAE8AAgANQUxJQURURVNULkNPTQAEY2lmcwAZc21ic2VydmVyMjQuYWxpYWR0ZXN0LmNvbQAAAAEAAAAAAQARABDdFmanrSIatnDDh****'),
  keytabMd5?: string(name='KeytabMd5', description='The string that is generated after the system encodes the keytab file by using MD5.', example='E3CCF7E2416DF04FA958AA4513EA****'),
  rejectUnencryptedAccess?: boolean(name='RejectUnencryptedAccess', description='Specifies whether to deny access from non-encrypted clients. Valid values:

*   true: The file system denies access from non-encrypted clients.
*   false (default): The file system allows access from non-encrypted clients.', example='false'),
  superAdminSid?: string(name='SuperAdminSid', description='The ID of a super admin. The ID must meet the following requirements:

*   The ID starts with `S` and does not contain letters except S.
*   The ID contains at least three hyphens (-) as delimiters.

Examples: `S-1-5-22` and `S-1-5-22-23`.', example='S-1-5-22'),
}

model ModifySmbAclResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model ModifySmbAclResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifySmbAclResponseBody(name='body'),
}

/**
 * @summary Updates the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request ModifySmbAclRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifySmbAclResponse
 */
@context("modifySmbAclWithContext")
async function modifySmbAclWithOptions(request: ModifySmbAclRequest, runtime: $RuntimeOptions): ModifySmbAclResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.enableAnonymousAccess)) {
    query['EnableAnonymousAccess'] = request.enableAnonymousAccess;
  }
  if (!$isNull(request.encryptData)) {
    query['EncryptData'] = request.encryptData;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.homeDirPath)) {
    query['HomeDirPath'] = request.homeDirPath;
  }
  if (!$isNull(request.keytab)) {
    query['Keytab'] = request.keytab;
  }
  if (!$isNull(request.keytabMd5)) {
    query['KeytabMd5'] = request.keytabMd5;
  }
  if (!$isNull(request.rejectUnencryptedAccess)) {
    query['RejectUnencryptedAccess'] = request.rejectUnencryptedAccess;
  }
  if (!$isNull(request.superAdminSid)) {
    query['SuperAdminSid'] = request.superAdminSid;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ModifySmbAcl',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the information about the access control list (ACL) feature of a Server Message Block (SMB) file system that resides in an Active Directory (AD) domain.
 *
 * @param request ModifySmbAclRequest
 * @return ModifySmbAclResponse
 */
async function modifySmbAcl(request: ModifySmbAclRequest): ModifySmbAclResponse {
  var runtime = new $RuntimeOptions{};
  return modifySmbAclWithOptions(request, runtime);
}

model OpenNASServiceResponseBody = {
  accessDeniedDetail?: string(name='AccessDeniedDetail', description='The details about the failed permission verification.', example='{
    "PolicyType": "AccountLevelIdentityBasedPolicy",
    "AuthPrincipalOwnerId": "178321033379****",
    "EncodedDiagnosticMessage": "AJpt/382mjxDSIYIqa/cUIFvOg9tajlLyN+LJA0C78kWfKIl****",
    "AuthPrincipalType": "SubUser",
    "AuthPrincipalDisplayName": "21794847602038****",
    "NoPermissionType": "ImplicitDeny",
    "AuthAction": "nas:OpenNASService"
  }'),
  orderId?: string(name='OrderId', description='The order ID.', example='20671870151****'),
  requestId?: string(name='RequestId', description='The request ID.', example='427DB0B3-9436-4A3C-B2BC-B961F95E****'),
}

model OpenNASServiceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenNASServiceResponseBody(name='body'),
}

/**
 * @summary Activates File Storage NAS.
 *
 * @param request OpenNASServiceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return OpenNASServiceResponse
 */
async function openNASServiceWithOptions(runtime: $RuntimeOptions): OpenNASServiceResponse {
  var req = new OpenApiUtil.OpenApiRequest{};
  var params = new OpenApiUtil.Params{
    action = 'OpenNASService',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Activates File Storage NAS.
 *
 * @return OpenNASServiceResponse
 */
async function openNASService(): OpenNASServiceResponse {
  var runtime = new $RuntimeOptions{};
  return openNASServiceWithOptions(runtime);
}

model RemoveClientFromBlackListRequest {
  clientIP?: string(name='ClientIP', description='The IP address of a client to remove from the blacklist.

This parameter is required.', example='192.168.0.0'),
  clientToken?: string(name='ClientToken', description='This parameter ensures the idempotency of each request. A ClientToken is generated for each client. Make sure that each ClientToken is unique between different requests. The parameter can be a maximum of 64 characters in length and contain only ASCII characters.

For more information, see [How to ensure idempotence](https://www.alibabacloud.com/help/doc-detail/25693.htm).

This parameter is required.', example='123e4567-e89b-12d3-a456-42665544****'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-00d91ca404a348****'),
  regionId?: string(name='RegionId', description='The ID of the region where the file system resides.

This parameter is required.', example='cn-hangzhou'),
}

model RemoveClientFromBlackListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='A70BEE5D-76D3-49FB-B58F-1F398211****'),
}

model RemoveClientFromBlackListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveClientFromBlackListResponseBody(name='body'),
}

/**
 * @deprecated OpenAPI RemoveClientFromBlackList is deprecated
 *
 * @summary Remove the client from the blacklist.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request RemoveClientFromBlackListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RemoveClientFromBlackListResponse
 */
// Deprecated
@context("removeClientFromBlackListWithContext")
async function removeClientFromBlackListWithOptions(request: RemoveClientFromBlackListRequest, runtime: $RuntimeOptions): RemoveClientFromBlackListResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientIP)) {
    query['ClientIP'] = request.clientIP;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RemoveClientFromBlackList',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @deprecated OpenAPI RemoveClientFromBlackList is deprecated
 *
 * @summary Remove the client from the blacklist.
 *
 * @description The API operation is available only for CPFS file systems.
 *
 * @param request RemoveClientFromBlackListRequest
 * @return RemoveClientFromBlackListResponse
 */
// Deprecated
async function removeClientFromBlackList(request: RemoveClientFromBlackListRequest): RemoveClientFromBlackListResponse {
  var runtime = new $RuntimeOptions{};
  return removeClientFromBlackListWithOptions(request, runtime);
}

model ResetFileSystemRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the advanced Extreme NAS file system.

This parameter is required.', example='extreme-012dd****'),
  snapshotId?: string(name='SnapshotId', description='The snapshot ID.

This parameter is required.', example='s-extreme-snapsho****'),
}

model ResetFileSystemResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3****'),
}

model ResetFileSystemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetFileSystemResponseBody(name='body'),
}

/**
 * @summary Rolls back a file system to a snapshot of the file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 * *   The file system must be in the Running state.
 * *   To roll back a file system to a snapshot, you must specify the ID of the snapshot that is created from the file system.
 *
 * @param request ResetFileSystemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetFileSystemResponse
 */
@context("resetFileSystemWithContext")
async function resetFileSystemWithOptions(request: ResetFileSystemRequest, runtime: $RuntimeOptions): ResetFileSystemResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ResetFileSystem',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Rolls back a file system to a snapshot of the file system.
 *
 * @description *   The snapshot feature is in public preview and is provided free of charge. [File Storage NAS Service Level Agreement (SLA)](https://www.alibabacloud.com/help/legal/latest/network-attached-storage-service-level-agreement) is not guaranteed in public preview.
 * *   Only advanced Extreme NAS file systems support this feature.
 * *   The file system must be in the Running state.
 * *   To roll back a file system to a snapshot, you must specify the ID of the snapshot that is created from the file system.
 *
 * @param request ResetFileSystemRequest
 * @return ResetFileSystemResponse
 */
async function resetFileSystem(request: ResetFileSystemRequest): ResetFileSystemResponse {
  var runtime = new $RuntimeOptions{};
  return resetFileSystemWithOptions(request, runtime);
}

model RetryLifecycleRetrieveJobRequest {
  jobId?: string(name='JobId', description='The ID of the data retrieval task.

This parameter is required.', example='lrj-nfstest-ia-160****853-hshvw'),
}

model RetryLifecycleRetrieveJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C56C7C****'),
}

model RetryLifecycleRetrieveJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetryLifecycleRetrieveJobResponseBody(name='body'),
}

/**
 * @summary Retries failed a data retrieval task.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request RetryLifecycleRetrieveJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryLifecycleRetrieveJobResponse
 */
@context("retryLifecycleRetrieveJobWithContext")
async function retryLifecycleRetrieveJobWithOptions(request: RetryLifecycleRetrieveJobRequest, runtime: $RuntimeOptions): RetryLifecycleRetrieveJobResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RetryLifecycleRetrieveJob',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retries failed a data retrieval task.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request RetryLifecycleRetrieveJobRequest
 * @return RetryLifecycleRetrieveJobResponse
 */
async function retryLifecycleRetrieveJob(request: RetryLifecycleRetrieveJobRequest): RetryLifecycleRetrieveJobResponse {
  var runtime = new $RuntimeOptions{};
  return retryLifecycleRetrieveJobWithOptions(request, runtime);
}

model SetDirQuotaRequest {
  fileCountLimit?: long(name='FileCountLimit', description='The number of files that a user can create in the directory.

This number includes the number of files, subdirectories, and special files.

If you set the QuotaType parameter to Enforcement, you must specify at least one of the SizeLimit and FileCountLimit parameters.', example='10000'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  path?: string(name='Path', description='The absolute path of the directory in the file system.

> *   You can set quotas only for the directories that have been created in a NAS file system. The path of the directory that you specify for a quota is the absolute path of the directory in the NAS file system, but not the local path of the compute node, such as an Elastic Compute Service (ECS) instance or a container.
> *   Directories whose names contain Chinese characters are not supported.

This parameter is required.', example='/data/sub1'),
  quotaType?: string(name='QuotaType', description='The type of the quota.

Valid values:

*   Accounting: a statistical quota. If you set this parameter to Accounting, NAS calculates only the storage usage of the directory.
*   Enforcement: a restricted quota. If you set this parameter to Enforcement and the storage usage exceeds the quota, you can no longer create files or subdirectories for the directory, or write data to the directory.

This parameter is required.', example='Accounting'),
  sizeLimit?: long(name='SizeLimit', description='The size of files that a user can create in the directory.

Unit: GiB.

If you set the QuotaType parameter to Enforcement, you must specify at least one of the SizeLimit and FileCountLimit parameters.', example='1024'),
  userId?: string(name='UserId', description='The UID or GID of the user for whom you want to set a directory quota.

This parameter is required and valid only if the UserType parameter is set to Uid or Gid.

Examples:

*   If you want to set a directory quota for a user whose UID is 500, set the UserType parameter to Uid and set the UserId parameter to 500.
*   If you want to set a directory quota for a user group whose GID is 100, set the UserType parameter to Gid and set the UserId parameter to 100.', example='500'),
  userType?: string(name='UserType', description='The type of the user.

Valid values:

*   Uid: user ID
*   Gid: user group ID
*   AllUsers: all users

This parameter is required.', example='Uid'),
}

model SetDirQuotaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5BC5CB97-9F28-42FE-84A4-0CD0DF42****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.

Valid values:

*   true
*   false', example='true'),
}

model SetDirQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetDirQuotaResponseBody(name='body'),
}

/**
 * @summary Creates a directory quota for a file system.
 *
 * @description Only General-purpose File Storage NAS (NAS) file systems support the directory quota feature.
 *
 * @param request SetDirQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetDirQuotaResponse
 */
@context("setDirQuotaWithContext")
async function setDirQuotaWithOptions(request: SetDirQuotaRequest, runtime: $RuntimeOptions): SetDirQuotaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.fileCountLimit)) {
    query['FileCountLimit'] = request.fileCountLimit;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.path)) {
    query['Path'] = request.path;
  }
  if (!$isNull(request.quotaType)) {
    query['QuotaType'] = request.quotaType;
  }
  if (!$isNull(request.sizeLimit)) {
    query['SizeLimit'] = request.sizeLimit;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!$isNull(request.userType)) {
    query['UserType'] = request.userType;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetDirQuota',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a directory quota for a file system.
 *
 * @description Only General-purpose File Storage NAS (NAS) file systems support the directory quota feature.
 *
 * @param request SetDirQuotaRequest
 * @return SetDirQuotaResponse
 */
async function setDirQuota(request: SetDirQuotaRequest): SetDirQuotaResponse {
  var runtime = new $RuntimeOptions{};
  return setDirQuotaWithOptions(request, runtime);
}

model SetFilesetQuotaRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run. The dry run checks parameter validity and prerequisites. The dry run does not delete the specified quota or incur fees.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, and service limits. If the request fails the dry run, an error code is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the quota is deleted.', example='false'),
  fileCountLimit?: long(name='FileCountLimit', description='The number of files of the quota. Valid values:

*   Minimum value: 10,000.
*   Maximum value: 10,000,000,000.

>  If you do not specify this parameter, the number of files is unlimited.', example='10000'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the CPFS for LINGJUN file system. The IDs of CPFS for LINGJUN file systems must start with `bmcpfs-`. Example: bmcpfs-290w65p03ok64ya\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='bmcpfs-290w65p03ok64ya****'),
  fsetId?: string(name='FsetId', description='The fileset ID.

This parameter is required.', example='fset-1902718ea0ae****'),
  sizeLimit?: long(name='SizeLimit', description='The total capacity of the quota. Unit: bytes.

Valid values:

*   Minimum value: 10,737,418,240 (10 GiB).
*   Step size: 1,073,741,824 (1 GiB).

>  If you do not specify this parameter, the capacity is unlimited.', example='10737418240'),
}

model SetFilesetQuotaResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model SetFilesetQuotaResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetFilesetQuotaResponseBody(name='body'),
}

/**
 * @summary Sets the quota for a fileset.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for Lingjun V2.7.0 and later support this operation.
 * *   The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB.
 * *   A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
 * *   When modifying a directory quota, you must set the new capacity or file quantity higher than what is currently used.
 * *   You must configure at least one of the Capacity Limit (GiB) and File Limit parameters.
 * *   The quota statistics have a 15-minute latency. The actual usage takes effect after 15 minutes.
 *
 * @param request SetFilesetQuotaRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetFilesetQuotaResponse
 */
@context("setFilesetQuotaWithContext")
async function setFilesetQuotaWithOptions(request: SetFilesetQuotaRequest, runtime: $RuntimeOptions): SetFilesetQuotaResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileCountLimit)) {
    query['FileCountLimit'] = request.fileCountLimit;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!$isNull(request.fsetId)) {
    query['FsetId'] = request.fsetId;
  }
  if (!$isNull(request.sizeLimit)) {
    query['SizeLimit'] = request.sizeLimit;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetFilesetQuota',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Sets the quota for a fileset.
 *
 * @description *   Only Cloud Parallel File Storage (CPFS) for Lingjun V2.7.0 and later support this operation.
 * *   The minimum capacity quota of a fileset is 10 GiB. The scaling step size is 1 GiB.
 * *   A fileset supports a minimum of 10,000 files or directories and a maximum of 10 billion files or directories. The scaling step size is 1.
 * *   When modifying a directory quota, you must set the new capacity or file quantity higher than what is currently used.
 * *   You must configure at least one of the Capacity Limit (GiB) and File Limit parameters.
 * *   The quota statistics have a 15-minute latency. The actual usage takes effect after 15 minutes.
 *
 * @param request SetFilesetQuotaRequest
 * @return SetFilesetQuotaResponse
 */
async function setFilesetQuota(request: SetFilesetQuotaRequest): SetFilesetQuotaResponse {
  var runtime = new $RuntimeOptions{};
  return setFilesetQuotaWithOptions(request, runtime);
}

model StartDataFlowRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run, without performing the actual request.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. The dry run does not enable the specified dataflow or incur fees.

Valid values:

*   true: performs only a dry run. The system checks the required parameters, request syntax, service limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the specified dataflow is enabled.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
}

model StartDataFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model StartDataFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartDataFlowResponseBody(name='body'),
}

/**
 * @summary Enables a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can enable the data flows that are only in the `Stopped` state.
 * *   If the value of DryRun is `true`, you can check whether sufficient resources are available to enable the specified data flow. If the resources are insufficient, the data flow cannot be enabled.
 * *   It generally takes 2 to 5 minutes to enable a data flow. You can query the data flow status by calling the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation.
 *
 * @param request StartDataFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StartDataFlowResponse
 */
@context("startDataFlowWithContext")
async function startDataFlowWithOptions(request: StartDataFlowRequest, runtime: $RuntimeOptions): StartDataFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StartDataFlow',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables a dataflow.
 *
 * @description *   This operation is available only to Cloud Parallel File Storage (CPFS) file systems.
 * *   Only CPFS V2.2.0 and later support data flows. You can view the version information on the file system details page in the console.
 * *   You can enable the data flows that are only in the `Stopped` state.
 * *   If the value of DryRun is `true`, you can check whether sufficient resources are available to enable the specified data flow. If the resources are insufficient, the data flow cannot be enabled.
 * *   It generally takes 2 to 5 minutes to enable a data flow. You can query the data flow status by calling the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402270.html) operation.
 *
 * @param request StartDataFlowRequest
 * @return StartDataFlowResponse
 */
async function startDataFlow(request: StartDataFlowRequest): StartDataFlowResponse {
  var runtime = new $RuntimeOptions{};
  return startDataFlowWithOptions(request, runtime);
}

model StopDataFlowRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](https://help.aliyun.com/document_detail/25693.html).

>  If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dataFlowId?: string(name='DataFlowId', description='The ID of the dataflow.

This parameter is required.', example='df-194433a5be31****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no fileset quota is canceled and no fee is incurred.

Valid value:

*   true: performs a dry run. The system checks the required parameters, request syntax, service limits, and available Apsara File Storage NAS (NAS) resources. Otherwise, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, the fileset quota is canceled.', example='false'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='cpfs-099394bd928c****'),
}

model StopDataFlowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model StopDataFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopDataFlowResponseBody(name='body'),
}

/**
 * @summary Disables a dataflow.
 *
 * @description *   This operation is available only to CPFS file systems.
 * *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   You can disable only the dataflows that are in the `Running` state.
 * *   After a dataflow is disabled, you cannot create a dataflow task for the dataflow. If AutoRefresh is configured, source data updates are not synchronized to CPFS.
 * *   After a dataflow is disabled, the dataflow throughput is no longer billed because resources are reclaimed. However, the dataflow may fail to be restarted due to insufficient resources.
 * *   It generally takes 2 to 5 minutes to disable a dataflow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402271.html) operation to query the dataflow status.
 *
 * @param request StopDataFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopDataFlowResponse
 */
@context("stopDataFlowWithContext")
async function stopDataFlowWithOptions(request: StopDataFlowRequest, runtime: $RuntimeOptions): StopDataFlowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dataFlowId)) {
    query['DataFlowId'] = request.dataFlowId;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopDataFlow',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables a dataflow.
 *
 * @description *   This operation is available only to CPFS file systems.
 * *   Only CPFS V2.2.0 and later support dataflows. You can view the version information on the file system details page in the console.
 * *   You can disable only the dataflows that are in the `Running` state.
 * *   After a dataflow is disabled, you cannot create a dataflow task for the dataflow. If AutoRefresh is configured, source data updates are not synchronized to CPFS.
 * *   After a dataflow is disabled, the dataflow throughput is no longer billed because resources are reclaimed. However, the dataflow may fail to be restarted due to insufficient resources.
 * *   It generally takes 2 to 5 minutes to disable a dataflow. You can call the [DescribeDataFlows](https://help.aliyun.com/document_detail/2402271.html) operation to query the dataflow status.
 *
 * @param request StopDataFlowRequest
 * @return StopDataFlowResponse
 */
async function stopDataFlow(request: StopDataFlowRequest): StopDataFlowResponse {
  var runtime = new $RuntimeOptions{};
  return stopDataFlowWithOptions(request, runtime);
}

model TagResourcesRequest {
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. Valid values of N: 1 to 50.

This parameter is required.', example='03e08484f0'),
  resourceType?: string(name='ResourceType', description='The resource type. Set the value to filesystem.

This parameter is required.', example='filesystem'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N to add to the resource.

Limits:

*   The tag key cannot be left empty.
*   Valid values of N: 1 to 20.
*   The tag key must be 1 to 128 characters in length.
*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.

This parameter is required.', example='nastest'),
      value?: string(name='Value', description='The value of tag N to add to the resource.

Limits:

*   Valid values of N: 1 to 20.
*   The tag value must be 1 to 128 characters in length.
*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or `https://`.

This parameter is required.', example='filetest'),
    }
  ](name='Tag', description='The details about the tags.

This parameter is required.'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model TagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagResourcesResponseBody(name='body'),
}

/**
 * @summary Creates tags and binds the tags to file systems.
 *
 * @param request TagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TagResourcesResponse
 */
@context("tagResourcesWithContext")
async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: $RuntimeOptions): TagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'TagResources',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates tags and binds the tags to file systems.
 *
 * @param request TagResourcesRequest
 * @return TagResourcesResponse
 */
async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All', description='Specifies whether to remove all tags from the file system.

This parameter is valid only if the TagKey.N parameter is not specified.

Valid values:

*   true: All tags are removed from the file system. If the file system does not have tags, a success message is returned.
*   false (default): No tags are removed from the file system and a success message is returned.', example='false'),
  resourceId?: [ string ](name='ResourceId', description='The resource IDs. Valid values of N: 1 to 50.

This parameter is required.', example='03e08484f0'),
  resourceType?: string(name='ResourceType', description='The resource type.

Set the value to filesystem.

This parameter is required.', example='filesystem'),
  tagKey?: [ string ](name='TagKey', description='The tag keys of the resources. Valid values of N: 1 to 20.', example='nastest'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2D69A58F-345C-4FDE-88E4-BF518948****'),
}

model UntagResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UntagResourcesResponseBody(name='body'),
}

/**
 * @summary Removes tags from a file system.
 *
 * @param request UntagResourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UntagResourcesResponse
 */
@context("untagResourcesWithContext")
async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: $RuntimeOptions): UntagResourcesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.all)) {
    query['All'] = request.all;
  }
  if (!$isNull(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!$isNull(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!$isNull(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UntagResources',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Removes tags from a file system.
 *
 * @param request UntagResourcesRequest
 * @return UntagResourcesResponse
 */
async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new $RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateRecycleBinAttributeRequest {
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

This parameter is required.', example='1ca404****'),
  reservedDays?: long(name='ReservedDays', description='The retention period of the files in the recycle bin. Unit: days.

Valid values: 1 to 180.

Default value: 3.

This parameter is required.', example='3'),
}

model UpdateRecycleBinAttributeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BC7C825C-5F65-4B56-BEF6-98C5****546E'),
}

model UpdateRecycleBinAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRecycleBinAttributeResponseBody(name='body'),
}

/**
 * @summary Modifies the retention period of data in the recycle bin of a file system.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request UpdateRecycleBinAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateRecycleBinAttributeResponse
 */
@context("updateRecycleBinAttributeWithContext")
async function updateRecycleBinAttributeWithOptions(request: UpdateRecycleBinAttributeRequest, runtime: $RuntimeOptions): UpdateRecycleBinAttributeResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateRecycleBinAttribute',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the retention period of data in the recycle bin of a file system.
 *
 * @description Only General-purpose NAS file systems support this operation.
 *
 * @param request UpdateRecycleBinAttributeRequest
 * @return UpdateRecycleBinAttributeResponse
 */
async function updateRecycleBinAttribute(request: UpdateRecycleBinAttributeRequest): UpdateRecycleBinAttributeResponse {
  var runtime = new $RuntimeOptions{};
  return updateRecycleBinAttributeWithOptions(request, runtime);
}

model UpgradeFileSystemRequest {
  capacity?: long(name='Capacity', description='The desired capacity of the file system.

The desired capacity of the file system must be greater than the original capacity of the file system. Unit: GiB.

This parameter is required.', example='100'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests.

The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How do I ensure the idempotence?](https://help.aliyun.com/document_detail/25693.html)

> If you do not specify this parameter, the system automatically uses the request ID as the client token. The request ID may be different for each request.', example='123e4567-e89b-12d3-a456-42665544****'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform a dry run.

During the dry run, the system checks whether the request parameters are valid and whether the requested resources are available. During the dry run, no file system is created and no fee is incurred.

Valid values:

*   true: performs a dry run. The system checks the required parameters, request syntax, limits, and available NAS resources. If the request fails the dry run, an error message is returned. If the request passes the dry run, the HTTP status code 200 is returned. No value is returned for the FileSystemId parameter.
*   false (default): performs a dry run and sends the request. If the request passes the dry run, a file system is created.', example='true'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.

*   The IDs of Extreme NAS file systems must start with `extreme-`, for example, extreme-0015\\\\*\\\\*\\\\*\\\\*.
*   The IDs of CPFS file systems must start with `cpfs-`. Example: cpfs-125487\\\\*\\\\*\\\\*\\\\*.

This parameter is required.', example='1ca404****'),
}

model UpgradeFileSystemResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='98696EF0-1607-4E9D-B01D-F20930B6****'),
}

model UpgradeFileSystemResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeFileSystemResponseBody(name='body'),
}

/**
 * @summary Scales up an Extreme NAS file system or a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description *   Only Extreme NAS file systems and CPFS file systems can be scaled up. CPFS file systems are available only on the China site (aliyun.com).
 * *   A General-purpose NAS file system is automatically scaled up. You do not need to call this operation to scale up a General-purpose NAS file system.
 *
 * @param request UpgradeFileSystemRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeFileSystemResponse
 */
@context("upgradeFileSystemWithContext")
async function upgradeFileSystemWithOptions(request: UpgradeFileSystemRequest, runtime: $RuntimeOptions): UpgradeFileSystemResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.capacity)) {
    query['Capacity'] = request.capacity;
  }
  if (!$isNull(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!$isNull(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!$isNull(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpgradeFileSystem',
    version = '2017-06-26',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Scales up an Extreme NAS file system or a Cloud Parallel File Storage (CPFS) file system.
 *
 * @description *   Only Extreme NAS file systems and CPFS file systems can be scaled up. CPFS file systems are available only on the China site (aliyun.com).
 * *   A General-purpose NAS file system is automatically scaled up. You do not need to call this operation to scale up a General-purpose NAS file system.
 *
 * @param request UpgradeFileSystemRequest
 * @return UpgradeFileSystemResponse
 */
async function upgradeFileSystem(request: UpgradeFileSystemRequest): UpgradeFileSystemResponse {
  var runtime = new $RuntimeOptions{};
  return upgradeFileSystemWithOptions(request, runtime);
}

