/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  
  checkConfig(config);
  @endpoint = getEndpoint('quotas', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateQuotaAlarmRequest {
  alarmName?: string(name='AlarmName'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaDimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='QuotaDimensions'),
  threshold?: float(name='Threshold'),
  thresholdPercent?: float(name='ThresholdPercent'),
  thresholdType?: string(name='ThresholdType'),
  webHook?: string(name='WebHook'),
}

model CreateQuotaAlarmResponseBody = {
  alarmId?: string(name='AlarmId'),
  requestId?: string(name='RequestId'),
}

model CreateQuotaAlarmResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQuotaAlarmResponseBody(name='body'),
}

async function createQuotaAlarmWithOptions(request: CreateQuotaAlarmRequest, runtime: Util.RuntimeOptions): CreateQuotaAlarmResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmName)) {
    body['AlarmName'] = request.alarmName;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  if (!Util.isUnset(request.quotaDimensions)) {
    body['QuotaDimensions'] = request.quotaDimensions;
  }
  if (!Util.isUnset(request.threshold)) {
    body['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.thresholdPercent)) {
    body['ThresholdPercent'] = request.thresholdPercent;
  }
  if (!Util.isUnset(request.thresholdType)) {
    body['ThresholdType'] = request.thresholdType;
  }
  if (!Util.isUnset(request.webHook)) {
    body['WebHook'] = request.webHook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQuotaAlarm',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQuotaAlarm(request: CreateQuotaAlarmRequest): CreateQuotaAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQuotaAlarmWithOptions(request, runtime);
}

model CreateQuotaApplicationRequest {
  auditMode?: string(name='AuditMode'),
  desireValue?: float(name='DesireValue'),
  dimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  noticeType?: int32(name='NoticeType'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaCategory?: string(name='QuotaCategory'),
  reason?: string(name='Reason'),
}

model CreateQuotaApplicationResponseBody = {
  applicationId?: string(name='ApplicationId'),
  applyTime?: string(name='ApplyTime'),
  approveValue?: float(name='ApproveValue'),
  auditReason?: string(name='AuditReason'),
  desireValue?: int32(name='DesireValue'),
  dimension?: map[string]any(name='Dimension'),
  effectiveTime?: string(name='EffectiveTime'),
  expireTime?: string(name='ExpireTime'),
  noticeType?: long(name='NoticeType'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaArn?: string(name='QuotaArn'),
  quotaDescription?: string(name='QuotaDescription'),
  quotaName?: string(name='QuotaName'),
  quotaUnit?: string(name='QuotaUnit'),
  reason?: string(name='Reason'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model CreateQuotaApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: CreateQuotaApplicationResponseBody(name='body'),
}

async function createQuotaApplicationWithOptions(request: CreateQuotaApplicationRequest, runtime: Util.RuntimeOptions): CreateQuotaApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.auditMode)) {
    body['AuditMode'] = request.auditMode;
  }
  if (!Util.isUnset(request.desireValue)) {
    body['DesireValue'] = request.desireValue;
  }
  if (!Util.isUnset(request.dimensions)) {
    body['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.noticeType)) {
    body['NoticeType'] = request.noticeType;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  if (!Util.isUnset(request.quotaCategory)) {
    body['QuotaCategory'] = request.quotaCategory;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateQuotaApplication',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createQuotaApplication(request: CreateQuotaApplicationRequest): CreateQuotaApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createQuotaApplicationWithOptions(request, runtime);
}

model DeleteQuotaAlarmRequest {
  alarmId?: string(name='AlarmId'),
}

model DeleteQuotaAlarmResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteQuotaAlarmResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteQuotaAlarmResponseBody(name='body'),
}

async function deleteQuotaAlarmWithOptions(request: DeleteQuotaAlarmRequest, runtime: Util.RuntimeOptions): DeleteQuotaAlarmResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmId)) {
    body['AlarmId'] = request.alarmId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteQuotaAlarm',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteQuotaAlarm(request: DeleteQuotaAlarmRequest): DeleteQuotaAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteQuotaAlarmWithOptions(request, runtime);
}

model GetProductQuotaRequest {
  dimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
}

model GetProductQuotaResponseBody = {
  quota?: {
    adjustable?: boolean(name='Adjustable'),
    applicableRange?: [ float ](name='ApplicableRange'),
    applicableType?: string(name='ApplicableType'),
    consumable?: boolean(name='Consumable'),
    dimensions?: map[string]any(name='Dimensions'),
    period?: {
      periodUnit?: string(name='PeriodUnit'),
      periodValue?: int32(name='PeriodValue'),
    }(name='Period'),
    productCode?: string(name='ProductCode'),
    quotaActionCode?: string(name='QuotaActionCode'),
    quotaArn?: string(name='QuotaArn'),
    quotaDescription?: string(name='QuotaDescription'),
    quotaItems?: [ 
      {
        quota?: string(name='Quota'),
        quotaUnit?: string(name='QuotaUnit'),
        type?: string(name='Type'),
        usage?: string(name='Usage'),
      }
    ](name='QuotaItems'),
    quotaName?: string(name='QuotaName'),
    quotaType?: string(name='QuotaType'),
    quotaUnit?: string(name='QuotaUnit'),
    totalQuota?: float(name='TotalQuota'),
    totalUsage?: float(name='TotalUsage'),
    unadjustableDetail?: string(name='UnadjustableDetail'),
  }(name='Quota'),
  requestId?: string(name='RequestId'),
}

model GetProductQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductQuotaResponseBody(name='body'),
}

async function getProductQuotaWithOptions(request: GetProductQuotaRequest, runtime: Util.RuntimeOptions): GetProductQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dimensions)) {
    body['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProductQuota',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProductQuota(request: GetProductQuotaRequest): GetProductQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProductQuotaWithOptions(request, runtime);
}

model GetProductQuotaDimensionRequest {
  dependentDimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='DependentDimensions'),
  dimensionKey?: string(name='DimensionKey'),
  productCode?: string(name='ProductCode'),
}

model GetProductQuotaDimensionResponseBody = {
  quotaDimension?: {
    dependentDimensions?: [ string ](name='DependentDimensions'),
    dimensionKey?: string(name='DimensionKey'),
    dimensionValueDetail?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='DimensionValueDetail'),
    dimensionValues?: [ string ](name='DimensionValues'),
    name?: string(name='Name'),
  }(name='QuotaDimension'),
  requestId?: string(name='RequestId'),
}

model GetProductQuotaDimensionResponse = {
  headers: map[string]string(name='headers'),
  body: GetProductQuotaDimensionResponseBody(name='body'),
}

async function getProductQuotaDimensionWithOptions(request: GetProductQuotaDimensionRequest, runtime: Util.RuntimeOptions): GetProductQuotaDimensionResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dependentDimensions)) {
    body['DependentDimensions'] = request.dependentDimensions;
  }
  if (!Util.isUnset(request.dimensionKey)) {
    body['DimensionKey'] = request.dimensionKey;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProductQuotaDimension',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProductQuotaDimension(request: GetProductQuotaDimensionRequest): GetProductQuotaDimensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProductQuotaDimensionWithOptions(request, runtime);
}

model GetQuotaAlarmRequest {
  alarmId?: string(name='AlarmId'),
}

model GetQuotaAlarmResponseBody = {
  quotaAlarm?: {
    alarmId?: string(name='AlarmId'),
    alarmName?: string(name='AlarmName'),
    createTime?: string(name='CreateTime'),
    notifyChannels?: [ string ](name='NotifyChannels'),
    notifyTarget?: string(name='NotifyTarget'),
    productCode?: string(name='ProductCode'),
    quotaActionCode?: string(name='QuotaActionCode'),
    quotaDimension?: map[string]any(name='QuotaDimension'),
    quotaUsage?: float(name='QuotaUsage'),
    quotaValue?: float(name='QuotaValue'),
    threshold?: float(name='Threshold'),
    thresholdPercent?: float(name='ThresholdPercent'),
    thresholdType?: string(name='ThresholdType'),
  }(name='QuotaAlarm'),
  requestId?: string(name='RequestId'),
}

model GetQuotaAlarmResponse = {
  headers: map[string]string(name='headers'),
  body: GetQuotaAlarmResponseBody(name='body'),
}

async function getQuotaAlarmWithOptions(request: GetQuotaAlarmRequest, runtime: Util.RuntimeOptions): GetQuotaAlarmResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmId)) {
    body['AlarmId'] = request.alarmId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQuotaAlarm',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQuotaAlarm(request: GetQuotaAlarmRequest): GetQuotaAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQuotaAlarmWithOptions(request, runtime);
}

model GetQuotaApplicationRequest {
  applicationId?: string(name='ApplicationId'),
}

model GetQuotaApplicationResponseBody = {
  quotaApplication?: {
    applicationId?: string(name='ApplicationId'),
    applyTime?: string(name='ApplyTime'),
    approveValue?: float(name='ApproveValue'),
    auditReason?: string(name='AuditReason'),
    desireValue?: int32(name='DesireValue'),
    dimension?: map[string]any(name='Dimension'),
    effectiveTime?: string(name='EffectiveTime'),
    expireTime?: string(name='ExpireTime'),
    noticeType?: long(name='NoticeType'),
    productCode?: string(name='ProductCode'),
    quotaActionCode?: string(name='QuotaActionCode'),
    quotaArn?: string(name='QuotaArn'),
    quotaDescription?: string(name='QuotaDescription'),
    quotaName?: string(name='QuotaName'),
    quotaUnit?: string(name='QuotaUnit'),
    reason?: string(name='Reason'),
    status?: string(name='Status'),
  }(name='QuotaApplication'),
  requestId?: string(name='RequestId'),
}

model GetQuotaApplicationResponse = {
  headers: map[string]string(name='headers'),
  body: GetQuotaApplicationResponseBody(name='body'),
}

async function getQuotaApplicationWithOptions(request: GetQuotaApplicationRequest, runtime: Util.RuntimeOptions): GetQuotaApplicationResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.applicationId)) {
    body['ApplicationId'] = request.applicationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetQuotaApplication',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getQuotaApplication(request: GetQuotaApplicationRequest): GetQuotaApplicationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getQuotaApplicationWithOptions(request, runtime);
}

model ListAlarmHistoriesRequest {
  endTime?: long(name='EndTime'),
  keyword?: string(name='Keyword'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
  startTime?: long(name='StartTime'),
}

model ListAlarmHistoriesResponseBody = {
  alarmHistories?: [ 
    {
      alarmName?: string(name='AlarmName'),
      createTime?: string(name='CreateTime'),
      notifyChannels?: [ string ](name='NotifyChannels'),
      notifyTarget?: string(name='NotifyTarget'),
      productCode?: string(name='ProductCode'),
      quotaActionCode?: string(name='QuotaActionCode'),
      quotaUsage?: float(name='QuotaUsage'),
      threshold?: float(name='Threshold'),
      thresholdPercent?: float(name='ThresholdPercent'),
    }
  ](name='AlarmHistories'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmHistoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAlarmHistoriesResponseBody(name='body'),
}

async function listAlarmHistoriesWithOptions(request: ListAlarmHistoriesRequest, runtime: Util.RuntimeOptions): ListAlarmHistoriesResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmHistories',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmHistories(request: ListAlarmHistoriesRequest): ListAlarmHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmHistoriesWithOptions(request, runtime);
}

model ListDependentQuotasRequest {
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
}

model ListDependentQuotasResponseBody = {
  quotas?: [ 
    {
      dimensions?: [ 
        {
          dependentDimension?: [ string ](name='DependentDimension'),
          dimensionKey?: string(name='DimensionKey'),
          dimensionValues?: [ string ](name='DimensionValues'),
        }
      ](name='Dimensions'),
      productCode?: string(name='ProductCode'),
      quotaActionCode?: string(name='QuotaActionCode'),
      scale?: float(name='Scale'),
    }
  ](name='Quotas'),
  requestId?: string(name='RequestId'),
}

model ListDependentQuotasResponse = {
  headers: map[string]string(name='headers'),
  body: ListDependentQuotasResponseBody(name='body'),
}

async function listDependentQuotasWithOptions(request: ListDependentQuotasRequest, runtime: Util.RuntimeOptions): ListDependentQuotasResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDependentQuotas',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDependentQuotas(request: ListDependentQuotasRequest): ListDependentQuotasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDependentQuotasWithOptions(request, runtime);
}

model ListProductDimensionGroupsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
}

model ListProductDimensionGroupsResponseBody = {
  dimensionGroups?: [ 
    {
      dimensionKeys?: [ string ](name='DimensionKeys'),
      groupCode?: string(name='GroupCode'),
      groupName?: string(name='GroupName'),
      productCode?: string(name='ProductCode'),
    }
  ](name='DimensionGroups'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProductDimensionGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductDimensionGroupsResponseBody(name='body'),
}

async function listProductDimensionGroupsWithOptions(request: ListProductDimensionGroupsRequest, runtime: Util.RuntimeOptions): ListProductDimensionGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProductDimensionGroups',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductDimensionGroups(request: ListProductDimensionGroupsRequest): ListProductDimensionGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductDimensionGroupsWithOptions(request, runtime);
}

model ListProductQuotaDimensionsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
  quotaCategory?: string(name='QuotaCategory'),
}

model ListProductQuotaDimensionsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  quotaDimensions?: [ 
    {
      dependentDimensions?: [ string ](name='DependentDimensions'),
      dimensionKey?: string(name='DimensionKey'),
      dimensionValueDetail?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='DimensionValueDetail'),
      dimensionValues?: [ string ](name='DimensionValues'),
      name?: string(name='Name'),
      requisite?: boolean(name='Requisite'),
    }
  ](name='QuotaDimensions'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProductQuotaDimensionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductQuotaDimensionsResponseBody(name='body'),
}

async function listProductQuotaDimensionsWithOptions(request: ListProductQuotaDimensionsRequest, runtime: Util.RuntimeOptions): ListProductQuotaDimensionsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaCategory)) {
    body['QuotaCategory'] = request.quotaCategory;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProductQuotaDimensions',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductQuotaDimensions(request: ListProductQuotaDimensionsRequest): ListProductQuotaDimensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductQuotaDimensionsWithOptions(request, runtime);
}

model ListProductQuotasRequest {
  dimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  groupCode?: string(name='GroupCode'),
  keyWord?: string(name='KeyWord'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaCategory?: string(name='QuotaCategory'),
  sortField?: string(name='SortField'),
  sortOrder?: string(name='SortOrder'),
}

model ListProductQuotasResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  quotas?: [ 
    {
      adjustable?: boolean(name='Adjustable'),
      applicableRange?: [ float ](name='ApplicableRange'),
      applicableType?: string(name='ApplicableType'),
      consumable?: boolean(name='Consumable'),
      dimensions?: map[string]any(name='Dimensions'),
      period?: {
        periodUnit?: string(name='PeriodUnit'),
        periodValue?: int32(name='PeriodValue'),
      }(name='Period'),
      productCode?: string(name='ProductCode'),
      quotaActionCode?: string(name='QuotaActionCode'),
      quotaArn?: string(name='QuotaArn'),
      quotaDescription?: string(name='QuotaDescription'),
      quotaItems?: [ 
        {
          quota?: string(name='Quota'),
          quotaUnit?: string(name='QuotaUnit'),
          type?: string(name='Type'),
          usage?: string(name='Usage'),
        }
      ](name='QuotaItems'),
      quotaName?: string(name='QuotaName'),
      quotaType?: string(name='QuotaType'),
      quotaUnit?: string(name='QuotaUnit'),
      totalQuota?: float(name='TotalQuota'),
      totalUsage?: float(name='TotalUsage'),
      unadjustableDetail?: string(name='UnadjustableDetail'),
    }
  ](name='Quotas'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProductQuotasResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductQuotasResponseBody(name='body'),
}

async function listProductQuotasWithOptions(request: ListProductQuotasRequest, runtime: Util.RuntimeOptions): ListProductQuotasResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dimensions)) {
    body['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.groupCode)) {
    body['GroupCode'] = request.groupCode;
  }
  if (!Util.isUnset(request.keyWord)) {
    body['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  if (!Util.isUnset(request.quotaCategory)) {
    body['QuotaCategory'] = request.quotaCategory;
  }
  if (!Util.isUnset(request.sortField)) {
    body['SortField'] = request.sortField;
  }
  if (!Util.isUnset(request.sortOrder)) {
    body['SortOrder'] = request.sortOrder;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProductQuotas',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProductQuotas(request: ListProductQuotasRequest): ListProductQuotasResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductQuotasWithOptions(request, runtime);
}

model ListProductsRequest {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListProductsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productInfo?: [ 
    {
      commonQuotaSupport?: string(name='CommonQuotaSupport', description='通用配额是否支持'),
      dynamic?: boolean(name='Dynamic'),
      flowControlSupport?: string(name='FlowControlSupport', description='是否支持流程'),
      productCode?: string(name='ProductCode'),
      productName?: string(name='ProductName'),
      productNameEn?: string(name='ProductNameEn'),
      secondCategoryId?: long(name='SecondCategoryId'),
      secondCategoryName?: string(name='SecondCategoryName'),
      secondCategoryNameEn?: string(name='SecondCategoryNameEn'),
    }
  ](name='ProductInfo'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  body: ListProductsResponseBody(name='body'),
}

async function listProductsWithOptions(request: ListProductsRequest, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listProductsWithOptions(request, runtime);
}

model ListQuotaAlarmsRequest {
  alarmName?: string(name='AlarmName'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaDimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='QuotaDimensions'),
}

model ListQuotaAlarmsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  quotaAlarms?: [ 
    {
      alarmId?: string(name='AlarmId'),
      alarmName?: string(name='AlarmName'),
      createTime?: string(name='CreateTime'),
      exceedThreshold?: boolean(name='ExceedThreshold'),
      notifyChannels?: [ string ](name='NotifyChannels'),
      notifyTarget?: string(name='NotifyTarget'),
      productCode?: string(name='ProductCode'),
      quotaActionCode?: string(name='QuotaActionCode'),
      quotaDimensions?: map[string]any(name='QuotaDimensions'),
      quotaUsage?: float(name='QuotaUsage'),
      quotaValue?: float(name='QuotaValue'),
      threshold?: float(name='Threshold'),
      thresholdPercent?: float(name='ThresholdPercent'),
      thresholdType?: string(name='ThresholdType'),
      webHook?: string(name='WebHook'),
    }
  ](name='QuotaAlarms'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListQuotaAlarmsResponse = {
  headers: map[string]string(name='headers'),
  body: ListQuotaAlarmsResponseBody(name='body'),
}

async function listQuotaAlarmsWithOptions(request: ListQuotaAlarmsRequest, runtime: Util.RuntimeOptions): ListQuotaAlarmsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmName)) {
    body['AlarmName'] = request.alarmName;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  if (!Util.isUnset(request.quotaDimensions)) {
    body['QuotaDimensions'] = request.quotaDimensions;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListQuotaAlarms',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQuotaAlarms(request: ListQuotaAlarmsRequest): ListQuotaAlarmsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQuotaAlarmsWithOptions(request, runtime);
}

model ListQuotaApplicationsRequest {
  dimensions?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Dimensions'),
  keyWord?: string(name='KeyWord'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  productCode?: string(name='ProductCode'),
  quotaActionCode?: string(name='QuotaActionCode'),
  quotaCategory?: string(name='QuotaCategory'),
  status?: string(name='Status'),
}

model ListQuotaApplicationsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  quotaApplications?: [ 
    {
      applicationId?: string(name='ApplicationId'),
      applyTime?: string(name='ApplyTime'),
      approveValue?: float(name='ApproveValue'),
      auditReason?: string(name='AuditReason'),
      comment?: string(name='Comment'),
      desireValue?: float(name='DesireValue'),
      dimension?: map[string]any(name='Dimension'),
      effectiveTime?: string(name='EffectiveTime'),
      expireTime?: string(name='ExpireTime'),
      noticeType?: int32(name='NoticeType'),
      period?: {
        periodUnit?: string(name='PeriodUnit'),
        periodValue?: long(name='PeriodValue'),
      }(name='Period'),
      productCode?: string(name='ProductCode'),
      quotaActionCode?: string(name='QuotaActionCode'),
      quotaArn?: string(name='QuotaArn'),
      quotaDescription?: string(name='QuotaDescription'),
      quotaName?: string(name='QuotaName'),
      quotaUnit?: string(name='QuotaUnit'),
      reason?: string(name='Reason'),
      status?: string(name='Status'),
    }
  ](name='QuotaApplications'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListQuotaApplicationsResponse = {
  headers: map[string]string(name='headers'),
  body: ListQuotaApplicationsResponseBody(name='body'),
}

async function listQuotaApplicationsWithOptions(request: ListQuotaApplicationsRequest, runtime: Util.RuntimeOptions): ListQuotaApplicationsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.dimensions)) {
    body['Dimensions'] = request.dimensions;
  }
  if (!Util.isUnset(request.keyWord)) {
    body['KeyWord'] = request.keyWord;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.productCode)) {
    body['ProductCode'] = request.productCode;
  }
  if (!Util.isUnset(request.quotaActionCode)) {
    body['QuotaActionCode'] = request.quotaActionCode;
  }
  if (!Util.isUnset(request.quotaCategory)) {
    body['QuotaCategory'] = request.quotaCategory;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListQuotaApplications',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listQuotaApplications(request: ListQuotaApplicationsRequest): ListQuotaApplicationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listQuotaApplicationsWithOptions(request, runtime);
}

model UpdateQuotaAlarmRequest {
  alarmId?: string(name='AlarmId'),
  alarmName?: string(name='AlarmName'),
  threshold?: float(name='Threshold'),
  thresholdPercent?: float(name='ThresholdPercent'),
  thresholdType?: string(name='ThresholdType'),
  webHook?: string(name='WebHook'),
}

model UpdateQuotaAlarmResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateQuotaAlarmResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateQuotaAlarmResponseBody(name='body'),
}

async function updateQuotaAlarmWithOptions(request: UpdateQuotaAlarmRequest, runtime: Util.RuntimeOptions): UpdateQuotaAlarmResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.alarmId)) {
    body['AlarmId'] = request.alarmId;
  }
  if (!Util.isUnset(request.alarmName)) {
    body['AlarmName'] = request.alarmName;
  }
  if (!Util.isUnset(request.threshold)) {
    body['Threshold'] = request.threshold;
  }
  if (!Util.isUnset(request.thresholdPercent)) {
    body['ThresholdPercent'] = request.thresholdPercent;
  }
  if (!Util.isUnset(request.thresholdType)) {
    body['ThresholdType'] = request.thresholdType;
  }
  if (!Util.isUnset(request.webHook)) {
    body['WebHook'] = request.webHook;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateQuotaAlarm',
    version = '2020-05-10',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateQuotaAlarm(request: UpdateQuotaAlarmRequest): UpdateQuotaAlarmResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateQuotaAlarmWithOptions(request, runtime);
}

