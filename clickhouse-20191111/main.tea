/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'ap-northeast-2-pop' = 'clickhouse.aliyuncs.com',
    'ap-southeast-1' = 'clickhouse.aliyuncs.com',
    'cn-beijing' = 'clickhouse.aliyuncs.com',
    'cn-beijing-finance-1' = 'clickhouse.aliyuncs.com',
    'cn-beijing-finance-pop' = 'clickhouse.aliyuncs.com',
    'cn-beijing-gov-1' = 'clickhouse.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'clickhouse.aliyuncs.com',
    'cn-edge-1' = 'clickhouse.aliyuncs.com',
    'cn-fujian' = 'clickhouse.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-finance' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'clickhouse.aliyuncs.com',
    'cn-hangzhou-test-306' = 'clickhouse.aliyuncs.com',
    'cn-hongkong' = 'clickhouse.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'clickhouse.aliyuncs.com',
    'cn-north-2-gov-1' = 'clickhouse.aliyuncs.com',
    'cn-qingdao' = 'clickhouse.aliyuncs.com',
    'cn-qingdao-nebula' = 'clickhouse.aliyuncs.com',
    'cn-shanghai' = 'clickhouse.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'clickhouse.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'clickhouse.aliyuncs.com',
    'cn-shanghai-finance-1' = 'clickhouse.aliyuncs.com',
    'cn-shanghai-inner' = 'clickhouse.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'clickhouse.aliyuncs.com',
    'cn-shenzhen' = 'clickhouse.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'clickhouse.aliyuncs.com',
    'cn-shenzhen-inner' = 'clickhouse.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'clickhouse.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'clickhouse.aliyuncs.com',
    'cn-wuhan' = 'clickhouse.aliyuncs.com',
    'cn-yushanfang' = 'clickhouse.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'clickhouse.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'clickhouse.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'clickhouse.aliyuncs.com',
    'eu-west-1-oxs' = 'clickhouse.aliyuncs.com',
    'me-east-1' = 'clickhouse.aliyuncs.com',
    'rus-west-1-pop' = 'clickhouse.aliyuncs.com',
    'us-east-1' = 'clickhouse.aliyuncs.com',
    'us-west-1' = 'clickhouse.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('clickhouse', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AllocateClusterPublicConnectionRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', description='The prefix of the endpoint that is used to connect to the database. Set the value to the cluster ID.', example='cc-bp108z124a8o7****'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateClusterPublicConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model AllocateClusterPublicConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AllocateClusterPublicConnectionResponseBody(name='body'),
}

/**
 * @summary Creates a public endpoint for an ApsaraDB for ClickHouse cluster.
 *
 * @param request AllocateClusterPublicConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return AllocateClusterPublicConnectionResponse
 */
async function allocateClusterPublicConnectionWithOptions(request: AllocateClusterPublicConnectionRequest, runtime: Util.RuntimeOptions): AllocateClusterPublicConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateClusterPublicConnection',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a public endpoint for an ApsaraDB for ClickHouse cluster.
 *
 * @param request AllocateClusterPublicConnectionRequest
 * @return AllocateClusterPublicConnectionResponse
 */
async function allocateClusterPublicConnection(request: AllocateClusterPublicConnectionRequest): AllocateClusterPublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateClusterPublicConnectionWithOptions(request, runtime);
}

model CheckClickhouseToRDSRequest {
  ckPassword?: string(name='CkPassword', description='The password of the account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='123456Aa'),
  ckUserName?: string(name='CkUserName', description='The account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='user1'),
  clickhousePort?: long(name='ClickhousePort', description='The port number of the ApsaraDB for ClickHouse cluster.', example='8123'),
  dbClusterId?: string(name='DbClusterId', description='The ID of the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-2zeyy362b5sbm****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  rdsId?: string(name='RdsId', description='The ID of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='rm-bp13v4bnwlu8j****'),
  rdsPassword?: string(name='RdsPassword', description='The password of the account that is used to log on to the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='123456Rr'),
  rdsPort?: long(name='RdsPort', description='The port number of the ApsaraDB RDS for MySQL instance.', example='3306'),
  rdsUserName?: string(name='RdsUserName', description='The account that is used to log on to the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='user2'),
  rdsVpcId?: string(name='RdsVpcId', description='The ID of the VPC in which the ApsaraDB RDS for MySQL instance is deployed.

This parameter is required.', example='vpc-wz9mm0qka0winfl47****'),
  rdsVpcUrl?: string(name='RdsVpcUrl', description='The internal endpoint of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='rm-bp16t9h3999xb0a7****.mysql.rds.aliyuncs.com'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckClickhouseToRDSResponseBody = {
  errorCode?: string(name='ErrorCode', description='*   When the value **true** is returned for the **Status** parameter, the system does not return the ErrorCode parameter.
*   When the value **false** is returned for the **Status** parameter, the system returns for the ErrorCode parameter the reason why the ApsaraDB for ClickHouse cluster cannot be connected to the ApsaraDB RDS for MySQL instance.', example='NotSameVpc'),
  requestId?: string(name='RequestId', description='The request ID.', example='A82758F8-E793-5610-BE11-0E46664305C2'),
  status?: boolean(name='Status', description='Indicates whether the ApsaraDB for ClickHouse cluster can be connected to the ApsaraDB RDS for MySQL instance.

*   **true**: The ApsaraDB for ClickHouse cluster can be connected to the ApsaraDB RDS for MySQL instance.
*   **false**: The ApsaraDB for ClickHouse cluster cannot be connected to the ApsaraDB RDS for MySQL instance.', example='false'),
}

model CheckClickhouseToRDSResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckClickhouseToRDSResponseBody(name='body'),
}

/**
 * @summary Checks the connectivity between an ApsaraDB for ClickHouse cluster and an ApsaraDB RDS for MySQL instance.
 *
 * @param request CheckClickhouseToRDSRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckClickhouseToRDSResponse
 */
async function checkClickhouseToRDSWithOptions(request: CheckClickhouseToRDSRequest, runtime: Util.RuntimeOptions): CheckClickhouseToRDSResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ckPassword)) {
    query['CkPassword'] = request.ckPassword;
  }
  if (!Util.isUnset(request.ckUserName)) {
    query['CkUserName'] = request.ckUserName;
  }
  if (!Util.isUnset(request.clickhousePort)) {
    query['ClickhousePort'] = request.clickhousePort;
  }
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.rdsId)) {
    query['RdsId'] = request.rdsId;
  }
  if (!Util.isUnset(request.rdsPassword)) {
    query['RdsPassword'] = request.rdsPassword;
  }
  if (!Util.isUnset(request.rdsPort)) {
    query['RdsPort'] = request.rdsPort;
  }
  if (!Util.isUnset(request.rdsUserName)) {
    query['RdsUserName'] = request.rdsUserName;
  }
  if (!Util.isUnset(request.rdsVpcId)) {
    query['RdsVpcId'] = request.rdsVpcId;
  }
  if (!Util.isUnset(request.rdsVpcUrl)) {
    query['RdsVpcUrl'] = request.rdsVpcUrl;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckClickhouseToRDS',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks the connectivity between an ApsaraDB for ClickHouse cluster and an ApsaraDB RDS for MySQL instance.
 *
 * @param request CheckClickhouseToRDSRequest
 * @return CheckClickhouseToRDSResponse
 */
async function checkClickhouseToRDS(request: CheckClickhouseToRDSRequest): CheckClickhouseToRDSResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkClickhouseToRDSWithOptions(request, runtime);
}

model CheckModifyConfigNeedRestartRequest {
  config?: string(name='Config', description='The configuration parameters whose settings are modified.

This parameter is required.', example='<?xml version="1.0"?>
<yandex>
    <keep_alive_timeout>400</keep_alive_timeout>
    <listen_backlog>4096</listen_backlog>
    <logger>
        <level>debug</level>
        <size>1000M</size>
    </logger>
    <mark_cache_size>5368709120</mark_cache_size>
    <max_concurrent_queries>201</max_concurrent_queries>
    <max_connections>4096</max_connections>
    <max_partition_size_to_drop>0</max_partition_size_to_drop>
    <max_table_size_to_drop>0</max_table_size_to_drop>
    <merge_tree>
        <max_delay_to_insert>256</max_delay_to_insert>
        <max_part_loading_threads>auto</max_part_loading_threads>
        <max_suspicious_broken_parts>100</max_suspicious_broken_parts>
        <zookeeper_session_expiration_check_period>1</zookeeper_session_expiration_check_period>
    </merge_tree>
    <uncompressed_cache_size>1717986918</uncompressed_cache_size>
</yandex>'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1tm8zf130ew****'),
}

model CheckModifyConfigNeedRestartResponseBody = {
  needRestart?: boolean(name='NeedRestart', description='Indicates whether the cluster was restarted after you modified the configuration parameters. Valid values:

*   **true**: The cluster was restarted.
*   **false**: The cluster was not restarted.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='06798FEE-BEF2-5FAF-A30D-728973BBE97C'),
}

model CheckModifyConfigNeedRestartResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckModifyConfigNeedRestartResponseBody(name='body'),
}

/**
 * @summary Queries whether an ApsaraDB for ClickHouse cluster needs to be restarted after you change the values of the configuration parameters in XML mode.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request CheckModifyConfigNeedRestartRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckModifyConfigNeedRestartResponse
 */
async function checkModifyConfigNeedRestartWithOptions(request: CheckModifyConfigNeedRestartRequest, runtime: Util.RuntimeOptions): CheckModifyConfigNeedRestartResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckModifyConfigNeedRestart',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries whether an ApsaraDB for ClickHouse cluster needs to be restarted after you change the values of the configuration parameters in XML mode.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request CheckModifyConfigNeedRestartRequest
 * @return CheckModifyConfigNeedRestartResponse
 */
async function checkModifyConfigNeedRestart(request: CheckModifyConfigNeedRestartRequest): CheckModifyConfigNeedRestartResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkModifyConfigNeedRestartWithOptions(request, runtime);
}

model CheckMonitorAlertRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp13s14l8498l****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckMonitorAlertResponseBody = {
  parameter?: string(name='Parameter', description='The parameters that are used to configure the monitoring and alerting feature.', example='{   "monitor":{     "key1":"value1",     "key2":"value2"   },   "alert":{     "key1":"value1",     "key2":"value2"   } }'),
  requestId?: string(name='RequestId', description='The request ID.', example='94F92113-FF63-5E57-8401-6FE123AD11DD'),
  state?: string(name='State', description='Indicates whether the monitoring and alerting feature is enabled. Valid values:

*   **enable**: The monitoring and alerting feature is enabled.
*   **disable**: The monitoring and alerting feature is disabled.', example='enable'),
}

model CheckMonitorAlertResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckMonitorAlertResponseBody(name='body'),
}

/**
 * @summary Checks whether the monitoring and alerting feature that is provided by Application Real-Time Monitoring Service (ARMS) is enabled for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CheckMonitorAlertRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckMonitorAlertResponse
 */
async function checkMonitorAlertWithOptions(request: CheckMonitorAlertRequest, runtime: Util.RuntimeOptions): CheckMonitorAlertResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckMonitorAlert',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Checks whether the monitoring and alerting feature that is provided by Application Real-Time Monitoring Service (ARMS) is enabled for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CheckMonitorAlertRequest
 * @return CheckMonitorAlertResponse
 */
async function checkMonitorAlert(request: CheckMonitorAlertRequest): CheckMonitorAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMonitorAlertWithOptions(request, runtime);
}

model CheckScaleOutBalancedRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of pages to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Default value: 30. Valid values:

*   **30**
*   **50**
*   **100**', example='30'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckScaleOutBalancedResponseBody = {
  checkCode?: string(name='CheckCode', description='The check result. Valid values:

*   **400**: The cluster failed the check.
*   **200**: The cluster passed the check.', example='400'),
  pageNumber?: int32(name='PageNumber', description='The total number of returned pages.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  tableDetails?: {
    tableDetail?: [ 
    {
      cluster?: string(name='Cluster', description='The cluster. The value is fixed as **default**.', example='default'),
      database?: string(name='Database', description='The database name.', example='db_name'),
      detail?: int32(name='Detail', description='The error details. Valid values:

*   **1**: The unique distributed table is missing.
*   **2**: More than one distributed table exists for the local table.', example='1'),
      tableName?: string(name='TableName', description='The name of the local table.', example='test'),
    }
  ](name='TableDetail')
  }(name='TableDetails', description='The error information returned for a check failure.'),
  timeDuration?: string(name='TimeDuration', description='The amount of time that is required for the migration and scale-out. Unit: minutes.', example='21'),
  totalCount?: int32(name='TotalCount', description='The total number of entries that are returned.', example='1'),
}

model CheckScaleOutBalancedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckScaleOutBalancedResponseBody(name='body'),
}

/**
 * @summary Performs migration and scale-out detection on an ApsaraDB for ClickHouse cluster.
 *
 * @param request CheckScaleOutBalancedRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckScaleOutBalancedResponse
 */
async function checkScaleOutBalancedWithOptions(request: CheckScaleOutBalancedRequest, runtime: Util.RuntimeOptions): CheckScaleOutBalancedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckScaleOutBalanced',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Performs migration and scale-out detection on an ApsaraDB for ClickHouse cluster.
 *
 * @param request CheckScaleOutBalancedRequest
 * @return CheckScaleOutBalancedResponse
 */
async function checkScaleOutBalanced(request: CheckScaleOutBalancedRequest): CheckScaleOutBalancedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkScaleOutBalancedWithOptions(request, runtime);
}

model CheckServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: boolean(name='HasServiceLinkedRole', description='Indicates whether a service-linked role is created for ApsaraDB for ClickHouse.', example='xxxx'),
  requestId?: string(name='RequestId', description='The request ID.', example='xxx'),
}

model CheckServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckServiceLinkedRoleResponseBody(name='body'),
}

/**
 * @summary Queries the service-linked role of ApsaraDB for ClickHouse.
 *
 * @param request CheckServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CheckServiceLinkedRoleResponse
 */
async function checkServiceLinkedRoleWithOptions(request: CheckServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceLinkedRole',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the service-linked role of ApsaraDB for ClickHouse.
 *
 * @param request CheckServiceLinkedRoleRequest
 * @return CheckServiceLinkedRoleResponse
 */
async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleWithOptions(request, runtime);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the database account.

> 

*   The description cannot start with http:// or https://.

*   The description must be 0 to 256 characters in length.', example='ceshi'),
  accountName?: string(name='AccountName', description='The name of the database account.

> 

*   The name must be unique in the cluster.

*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a lowercase letter and end with a lowercase letter or a digit.
*   The name must be 2 to 64 characters in length.

This parameter is required.', example='test'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.

> 

*   The password must contain at least three types of the following characters: uppercase letters, lowercase letters, digits, and special characters.

*   The password can contain the following special characters: ! @ # $ % ^ & \\\\* ( ) _ + - =
*   The password must be 8 to 32 characters in length.

This parameter is required.', example='123789Ff!'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627FA5A19'),
}

model CreateAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountResponseBody(name='body'),
}

/**
 * @summary Creates a database account for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CreateAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountResponse
 */
async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a database account for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CreateAccountRequest
 * @return CreateAccountResponse
 */
async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CreateAccountAndAuthorityRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the database account.

*   The description cannot start with http:// or https://.
*   The description must be 0 to 256 characters in length.', example='ceshi'),
  accountName?: string(name='AccountName', description='The database account.

*   The name must be unique within the cluster.
*   The name can contain lowercase letters, digits, and underscores (_).
*   The name must start with a lowercase letter and end with a lowercase letter or digit.
*   The name must be 2 to 64 characters in length.

This parameter is required.', example='test'),
  accountPassword?: string(name='AccountPassword', description='The password of your database account.

> 

*   The password contains at least three types of the following characters: uppercase letters, lowercase letters, digits, and special characters.

*   The password can contain the following special characters: ! @ # $ % ^ & \\\\* ( ) _ + - =
*   The password must be 8 to 32 characters in length.

This parameter is required.', example='123456Aa'),
  allowDatabases?: string(name='AllowDatabases', description='The databases to which you want to grant permissions. Separate databases with commas (,).

This parameter is required.', example='db1'),
  allowDictionaries?: string(name='AllowDictionaries', description='The dictionaries to which you want to grant permissions. Separate dictionaries with commas (,).

This parameter is required.', example='dt1'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1p816075e21****'),
  ddlAuthority?: boolean(name='DdlAuthority', description='Specifies whether to grant the DDL permissions to the database account. Valid values:

*   **true**
*   **false**

This parameter is required.', example='true'),
  dmlAuthority?: string(name='DmlAuthority', description='Specifies whether to grant DML permissions to the database account. Valid values:

*   **all**
*   **readOnly,modify**

This parameter is required.', example='all'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  totalDatabases?: string(name='TotalDatabases', description='All databases. Separate databases with commas (,).', example='db1,db2'),
  totalDictionaries?: string(name='TotalDictionaries', description='All dictionaries. Separate dictionaries with commas (,).', example='dt1,dt2'),
}

model CreateAccountAndAuthorityResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model CreateAccountAndAuthorityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAccountAndAuthorityResponseBody(name='body'),
}

/**
 * @summary Creates an account and grants permissions to the account.
 *
 * @param request CreateAccountAndAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAccountAndAuthorityResponse
 */
async function createAccountAndAuthorityWithOptions(request: CreateAccountAndAuthorityRequest, runtime: Util.RuntimeOptions): CreateAccountAndAuthorityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.allowDatabases)) {
    query['AllowDatabases'] = request.allowDatabases;
  }
  if (!Util.isUnset(request.allowDictionaries)) {
    query['AllowDictionaries'] = request.allowDictionaries;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ddlAuthority)) {
    query['DdlAuthority'] = request.ddlAuthority;
  }
  if (!Util.isUnset(request.dmlAuthority)) {
    query['DmlAuthority'] = request.dmlAuthority;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.totalDatabases)) {
    query['TotalDatabases'] = request.totalDatabases;
  }
  if (!Util.isUnset(request.totalDictionaries)) {
    query['TotalDictionaries'] = request.totalDictionaries;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccountAndAuthority',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an account and grants permissions to the account.
 *
 * @param request CreateAccountAndAuthorityRequest
 * @return CreateAccountAndAuthorityResponse
 */
async function createAccountAndAuthority(request: CreateAccountAndAuthorityRequest): CreateAccountAndAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountAndAuthorityWithOptions(request, runtime);
}

model CreateBackupPolicyRequest {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod', description='The backup retention period. The default retention period is seven days. Valid values: 7 to 730. Unit: day.', example='8'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The day of a week when the system regularly backs up data. If you specify multiple days of a week, separate them with commas (,). Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

This parameter is required.', example='Monday,Friday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The backup window. Specify the time in the ISO 8601 standard in the HH:mmZ-HH:mmZ format. The time must be in Coordinated Universal Time (UTC).

For example, if you set the backup window to 00:00Z-01:00Z, the data of the cluster can be backed up from 08:00 (UTC+8) to 09:00 (UTC+8).

This parameter is required.', example='10:00Z-11:00Z'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model CreateBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Creates a backup policy.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request CreateBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateBackupPolicyResponse
 */
async function createBackupPolicyWithOptions(request: CreateBackupPolicyRequest, runtime: Util.RuntimeOptions): CreateBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRetentionPeriod)) {
    query['BackupRetentionPeriod'] = request.backupRetentionPeriod;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPolicy',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a backup policy.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request CreateBackupPolicyRequest
 * @return CreateBackupPolicyResponse
 */
async function createBackupPolicy(request: CreateBackupPolicyRequest): CreateBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPolicyWithOptions(request, runtime);
}

model CreateDBInstanceRequest {
  autoRenew?: boolean(name='AutoRenew', description='Specifies whether to enable auto-renewal.

>  This parameter is valid only if the value of PayType is set to Prepaid.', example='false'),
  backupSetID?: string(name='BackupSetID', description='The ID of the backup set. You can call the [DescribeBackups](https://help.aliyun.com/document_detail/360339.html) operation to query the backup sets.

>  If you want to restore the data of an ApsaraDB for ClickHouse cluster, this parameter is required.', example='b-12af23adsf'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. The value is a string and can be up to 64 ASCII characters in length.', example='AB'),
  DBClusterCategory?: string(name='DBClusterCategory', description='The edition of the cluster. Valid values:

*   **Basic**: Single-replica Edition
*   **HighAvailability**: Double-replica Edition

This parameter is required.', example='Basic'),
  DBClusterClass?: string(name='DBClusterClass', description='The specifications of the cluster.

*   Valid values for a Single-replica Edition cluster:

    *   **S8**: 8 cores and 32 GB of memory
    *   **S16**: 16 cores and 64 GB of memory
    *   **S32**: 32 cores and 128 GB of memory
    *   **S64**: 64 cores and 256 GB of memory
    *   **S104**: 104 cores and 384 GB of memory

*   Valid values for a Double-replica Edition cluster:

    *   **C8**: 8 cores and 32 GB of memory
    *   **C16**: 16 cores and 64 GB of memory
    *   **C32**: 32 cores and 128 GB of memory
    *   **C64**: 64 cores and 256 GB of memory
    *   **C104**: 104 cores and 384 GB of memory

This parameter is required.', example='S8'),
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
  DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster. Only Virtual Private Cloud (VPC) is supported.

This parameter is required.', example='VPC'),
  DBClusterVersion?: string(name='DBClusterVersion', description='The kernel version. Valid values:

*   **21.8.10.19**
*   **22.8.5.29**

This parameter is required.', example='21.8.10.19'),
  DBNodeGroupCount?: string(name='DBNodeGroupCount', description='The number of nodes.

*   Valid values when the cluster is of Single-replica Edition: 1 to 48.
*   Valid values when the cluster is of Double-replica Edition: 1 to 24.

This parameter is required.', example='1'),
  DBNodeStorage?: string(name='DBNodeStorage', description='The storage capacity of a single node. Valid values: 100 to 32000. Unit: GB.

>  This value is a multiple of 100.

This parameter is required.', example='100'),
  dbNodeStorageType?: string(name='DbNodeStorageType', description='The storage type of the cluster. Valid values:

*   **CloudESSD**: The cluster uses an enhanced SSD (ESSD) of performance level 1 (PL1).
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL3.
*   **CloudEfficiency**: The cluster uses an ultra disk.

This parameter is required.', example='CloudESSD_PL2'),
  encryptionKey?: string(name='EncryptionKey', description='You must specify this parameter when EncryptionType is set to CloudDisk.

The ID of the key that is used to encrypt data on disks. You can obtain the ID of the key from the Key Management Service (KMS) console. You can also create a key.

>  If EncryptionType is empty, you do not need to specify this parameter.', example='0d2470df-da7b-4786-b981-9a164dae****'),
  encryptionType?: string(name='EncryptionType', description='The encryption type. Set the value to **CloudDisk**, which indicates that only disk encryption is supported.

>  If this parameter is not specified, data is not encrypted.', example='CloudDisk'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: The cluster uses the pay-as-you-go billing method.
*   **Prepaid**: The cluster uses the subscription billing method.

This parameter is required.', example='Prepaid'),
  period?: string(name='Period', description='The unit of the subscription duration for the cluster. Valid values:

>  This parameter is required only when PayType is set to Prepaid.

*   **Year**
*   **Month**', example='Month'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.', example='rg-4690g37929****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBClusterId?: string(name='SourceDBClusterId', description='The ID of the source cluster. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query backup set IDs.

>  If you want to restore the data of an ApsaraDB for ClickHouse cluster, this parameter is required.', example='cc-bp1lxbo89u950****'),
  usedTime?: string(name='UsedTime', description='The subscription duration of the subscription cluster.

>  This parameter is required only when PayType is set to Prepaid.

*   Valid values when Period is set to Year: 1 to 3 (integer)
*   Valid values when Period is set to Month: 1 to 9 (integer)', example='1'),
  VPCId?: string(name='VPCId', description='The VPC ID.

This parameter is required.', example='vpc-bp175iuvg8nxqraf2****'),
  vSwitchBak?: string(name='VSwitchBak', description='The vSwitch in the secondary zone for the VPC.', example='vsw-bp1gzt31twhlo0sa5****'),
  vSwitchBak2?: string(name='VSwitchBak2', description='The vSwitch in secondary zone 2 for the VPC.', example='vsw-bp1gzt31twhlo0sa5****'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.

This parameter is required.', example='vsw-bp1gzt31twhlo0sa5****'),
  zondIdBak2?: string(name='ZondIdBak2', description='The secondary zone 2 of the instance.', example='cn-hangzhou-j'),
  zoneId?: string(name='ZoneId', description='The zone ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent zone list.', example='cn-hangzhou-h'),
  zoneIdBak?: string(name='ZoneIdBak', description='The secondary zone.', example='cn-hangzhou-k'),
}

model CreateDBInstanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp1qx68m06981****'),
  orderId?: string(name='OrderId', description='The order ID.', example='21137950671****'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model CreateDBInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDBInstanceResponseBody(name='body'),
}

/**
 * @summary Creates an ApsaraDB for ClickHouse cluster.
 *
 * @description Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://help.aliyun.com/document_detail/167450.html) of ApsaraDB for ClickHouse.
 *
 * @param request CreateDBInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateDBInstanceResponse
 */
async function createDBInstanceWithOptions(request: CreateDBInstanceRequest, runtime: Util.RuntimeOptions): CreateDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.backupSetID)) {
    query['BackupSetID'] = request.backupSetID;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBClusterCategory)) {
    query['DBClusterCategory'] = request.DBClusterCategory;
  }
  if (!Util.isUnset(request.DBClusterClass)) {
    query['DBClusterClass'] = request.DBClusterClass;
  }
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterNetworkType)) {
    query['DBClusterNetworkType'] = request.DBClusterNetworkType;
  }
  if (!Util.isUnset(request.DBClusterVersion)) {
    query['DBClusterVersion'] = request.DBClusterVersion;
  }
  if (!Util.isUnset(request.DBNodeGroupCount)) {
    query['DBNodeGroupCount'] = request.DBNodeGroupCount;
  }
  if (!Util.isUnset(request.DBNodeStorage)) {
    query['DBNodeStorage'] = request.DBNodeStorage;
  }
  if (!Util.isUnset(request.dbNodeStorageType)) {
    query['DbNodeStorageType'] = request.dbNodeStorageType;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.encryptionType)) {
    query['EncryptionType'] = request.encryptionType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBClusterId)) {
    query['SourceDBClusterId'] = request.sourceDBClusterId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchBak)) {
    query['VSwitchBak'] = request.vSwitchBak;
  }
  if (!Util.isUnset(request.vSwitchBak2)) {
    query['VSwitchBak2'] = request.vSwitchBak2;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zondIdBak2)) {
    query['ZondIdBak2'] = request.zondIdBak2;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.zoneIdBak)) {
    query['ZoneIdBak'] = request.zoneIdBak;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBInstance',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an ApsaraDB for ClickHouse cluster.
 *
 * @description Before you call this operation, make sure that you are familiar with the billing methods and [pricing](https://help.aliyun.com/document_detail/167450.html) of ApsaraDB for ClickHouse.
 *
 * @param request CreateDBInstanceRequest
 * @return CreateDBInstanceResponse
 */
async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBInstanceWithOptions(request, runtime);
}

model CreateMonitorDataReportRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp13s14l8498l****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateMonitorDataReportResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='94F92113-FF63-5E57-8401-6FE123AD11DD'),
}

model CreateMonitorDataReportResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMonitorDataReportResponseBody(name='body'),
}

/**
 * @summary Creates a monitoring data report for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CreateMonitorDataReportRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateMonitorDataReportResponse
 */
async function createMonitorDataReportWithOptions(request: CreateMonitorDataReportRequest, runtime: Util.RuntimeOptions): CreateMonitorDataReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorDataReport',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a monitoring data report for an ApsaraDB for ClickHouse cluster.
 *
 * @param request CreateMonitorDataReportRequest
 * @return CreateMonitorDataReportResponse
 */
async function createMonitorDataReport(request: CreateMonitorDataReportRequest): CreateMonitorDataReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorDataReportWithOptions(request, runtime);
}

model CreateOSSStorageRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1z3a2hc8dmt****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateOSSStorageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='1F488A93-83FD-540F-9B67-0333AF64E6A0'),
}

model CreateOSSStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateOSSStorageResponseBody(name='body'),
}

/**
 * @summary Creates a storage task for cold data.
 *
 * @description Only an ApsaraDB for ClickHouse cluster of V20.8 or later supports tiered storage of hot data and cold data. If your data is in an ApsaraDB for ClickHouse cluster of a version earlier than V20.8 and you want to use tiered storage of hot data and cold data to store the data, you can migrate the data to an ApsaraDB for ClickHouse cluster of V20.8 or later and use tiered storage of hot data and cold data. For more information about how to migrate data between ApsaraDB for ClickHouse clusters, see [Migrate data between ApsaraDB for ClickHouse clusters](https://help.aliyun.com/document_detail/276926.html).
 *
 * @param request CreateOSSStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateOSSStorageResponse
 */
async function createOSSStorageWithOptions(request: CreateOSSStorageRequest, runtime: Util.RuntimeOptions): CreateOSSStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOSSStorage',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a storage task for cold data.
 *
 * @description Only an ApsaraDB for ClickHouse cluster of V20.8 or later supports tiered storage of hot data and cold data. If your data is in an ApsaraDB for ClickHouse cluster of a version earlier than V20.8 and you want to use tiered storage of hot data and cold data to store the data, you can migrate the data to an ApsaraDB for ClickHouse cluster of V20.8 or later and use tiered storage of hot data and cold data. For more information about how to migrate data between ApsaraDB for ClickHouse clusters, see [Migrate data between ApsaraDB for ClickHouse clusters](https://help.aliyun.com/document_detail/276926.html).
 *
 * @param request CreateOSSStorageRequest
 * @return CreateOSSStorageResponse
 */
async function createOSSStorage(request: CreateOSSStorageRequest): CreateOSSStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOSSStorageWithOptions(request, runtime);
}

model CreatePortsForClickHouseRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  portType?: string(name='PortType', description='The port type. Set the value to mysql_port.

This parameter is required.', example='mysql_port'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreatePortsForClickHouseResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627FA5A19'),
}

model CreatePortsForClickHouseResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePortsForClickHouseResponseBody(name='body'),
}

/**
 * @summary Enables the MySQL port for an ApsaraDB for ClickHouse cluster.
 *
 * @description >  For an ApsaraDB for ClickHouse cluster of V20.8 or later that was created before December 1, 2021, you must manually enable the MySQL port. For an ApsaraDB for ClickHouse cluster of V20.8 or later that was created after December 1, 2021, the MySQL port is automatically enabled.
 *
 * @param request CreatePortsForClickHouseRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreatePortsForClickHouseResponse
 */
async function createPortsForClickHouseWithOptions(request: CreatePortsForClickHouseRequest, runtime: Util.RuntimeOptions): CreatePortsForClickHouseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.portType)) {
    query['PortType'] = request.portType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePortsForClickHouse',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables the MySQL port for an ApsaraDB for ClickHouse cluster.
 *
 * @description >  For an ApsaraDB for ClickHouse cluster of V20.8 or later that was created before December 1, 2021, you must manually enable the MySQL port. For an ApsaraDB for ClickHouse cluster of V20.8 or later that was created after December 1, 2021, the MySQL port is automatically enabled.
 *
 * @param request CreatePortsForClickHouseRequest
 * @return CreatePortsForClickHouseResponse
 */
async function createPortsForClickHouse(request: CreatePortsForClickHouseRequest): CreatePortsForClickHouseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPortsForClickHouseWithOptions(request, runtime);
}

model CreateRDSToClickhouseDbRequest {
  ckPassword?: string(name='CkPassword', description='The password of the account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='123456Aa'),
  ckUserName?: string(name='CkUserName', description='The account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='user1'),
  clickhousePort?: long(name='ClickhousePort', description='The port number of the ApsaraDB for ClickHouse cluster.', example='8123'),
  dbClusterId?: string(name='DbClusterId', description='The ID of the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-2ze5zeyl72188****'),
  limitUpper?: long(name='LimitUpper', description='The maximum number of rows that can be synchronized per second.', example='50000'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  rdsId?: string(name='RdsId', description='The ID of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='rm-8vb989qj9roh0****'),
  rdsPassword?: string(name='RdsPassword', description='The password of the account that is used to log on to the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='123456Rr'),
  rdsPort?: long(name='RdsPort', description='The port number of the ApsaraDB RDS for MySQL instance.', example='3306'),
  rdsUserName?: string(name='RdsUserName', description='The account that is used to log on to the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='user2'),
  rdsVpcId?: string(name='RdsVpcId', description='The ID of the virtual private cloud (VPC) to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-2zen93xryil99jsfy****'),
  rdsVpcUrl?: string(name='RdsVpcUrl', description='The private endpoint of the ApsaraDB RDS for MySQL instance.', example='rm-bp16t9h3999xb0a7****.mysql.rds.aliyuncs.com'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  skipUnsupported?: boolean(name='SkipUnsupported', description='Specifies whether to ignore the table schemas that do not support synchronization. Valid values:

*   **true**
*   **false**

This parameter is required.', example='true'),
  synDbTables?: string(name='SynDbTables', description='The tables whose data you want to synchronize.

This parameter is required.', example='[{"Schema":"recommend","Tables":["mr_platform_cpm","mr_platform_ecpm","p_monitor_record"]}]'),
}

model CreateRDSToClickhouseDbResponseBody = {
  errorMsg?: string(name='ErrorMsg', description='If the value of the **Status** parameter is -1, the cause of the creation failure is returned.', example='ClickHouse exception, code: 49, host: 100.100.79.102, port: 14540; Code: 49, e.displayText() = DB::Exception: Logical error: there is no global context (version 20.8.17.25)n'),
  repeatedDbs?: [ string ](name='RepeatedDbs', description='Duplicate tables in the synchronization task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='66676F54-1994-5DCF-993F-74536649628A'),
  status?: long(name='Status', description='Indicates whether the synchronization task was created. Valid values:

*   **1**: Created.
*   **0**: Creation failed. The tables in the synchronization task are duplicate. The duplicate tables are returned for the **RepeatedDbs** parameter.
*   **-1**: Creation failed. The cause why the creation failed is returned for the **ErrorMsg** parameter.', example='0'),
}

model CreateRDSToClickhouseDbResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRDSToClickhouseDbResponseBody(name='body'),
}

/**
 * @summary Creates a task to synchronize data from an ApsaraDB RDS for MySQL instance to an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is only applicable to ApsaraDB for ClickHouse clusters.
 *
 * @param request CreateRDSToClickhouseDbRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRDSToClickhouseDbResponse
 */
async function createRDSToClickhouseDbWithOptions(request: CreateRDSToClickhouseDbRequest, runtime: Util.RuntimeOptions): CreateRDSToClickhouseDbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ckPassword)) {
    query['CkPassword'] = request.ckPassword;
  }
  if (!Util.isUnset(request.ckUserName)) {
    query['CkUserName'] = request.ckUserName;
  }
  if (!Util.isUnset(request.clickhousePort)) {
    query['ClickhousePort'] = request.clickhousePort;
  }
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.limitUpper)) {
    query['LimitUpper'] = request.limitUpper;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.rdsId)) {
    query['RdsId'] = request.rdsId;
  }
  if (!Util.isUnset(request.rdsPassword)) {
    query['RdsPassword'] = request.rdsPassword;
  }
  if (!Util.isUnset(request.rdsPort)) {
    query['RdsPort'] = request.rdsPort;
  }
  if (!Util.isUnset(request.rdsUserName)) {
    query['RdsUserName'] = request.rdsUserName;
  }
  if (!Util.isUnset(request.rdsVpcId)) {
    query['RdsVpcId'] = request.rdsVpcId;
  }
  if (!Util.isUnset(request.rdsVpcUrl)) {
    query['RdsVpcUrl'] = request.rdsVpcUrl;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.skipUnsupported)) {
    query['SkipUnsupported'] = request.skipUnsupported;
  }
  if (!Util.isUnset(request.synDbTables)) {
    query['SynDbTables'] = request.synDbTables;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRDSToClickhouseDb',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a task to synchronize data from an ApsaraDB RDS for MySQL instance to an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is only applicable to ApsaraDB for ClickHouse clusters.
 *
 * @param request CreateRDSToClickhouseDbRequest
 * @return CreateRDSToClickhouseDbResponse
 */
async function createRDSToClickhouseDb(request: CreateRDSToClickhouseDbRequest): CreateRDSToClickhouseDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRDSToClickhouseDbWithOptions(request, runtime);
}

model CreateSQLAccountRequest {
  accountDescription?: string(name='AccountDescription', description='The description of the database account.

*   The description cannot start with http:// or https://.
*   The description can be up to 256 characters in length or be an empty string.', example='Used for test'),
  accountName?: string(name='AccountName', description='The name of the database account.

*   The name must be unique in the cluster.
*   The name can contain lowercase letters, digits, or underscores (_).
*   The name must start with a lowercase letter and end with a lowercase letter or digit.
*   The name must be 2 to 64 characters in length.

This parameter is required.', example='test'),
  accountPassword?: string(name='AccountPassword', description='The password of the database account.

*   The password must contain at least three of the following character types: uppercase letters, lowercase letters, digits, and special characters.
*   Special characters include ! @ # $ % ^ & \\\\* ( ) _ + - =
*   The password must be 8 to 32 characters in length.

This parameter is required.', example='Test1234'),
  accountType?: string(name='AccountType', description='The type of the database account. Valid values:

*   **Super**: privileged account.
*   **Normal**: standard account.

This parameter is required.', example='Super'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1p816075e21****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateSQLAccountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F76'),
}

model CreateSQLAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSQLAccountResponseBody(name='body'),
}

/**
 * @summary Creates a privileged account or a standard account for an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is applicable only to ApsaraDB for ClickHouse clusters of V20.8 or later that were created after December 1, 2021,
 *
 * @param request CreateSQLAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSQLAccountResponse
 */
async function createSQLAccountWithOptions(request: CreateSQLAccountRequest, runtime: Util.RuntimeOptions): CreateSQLAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSQLAccount',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a privileged account or a standard account for an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is applicable only to ApsaraDB for ClickHouse clusters of V20.8 or later that were created after December 1, 2021,
 *
 * @param request CreateSQLAccountRequest
 * @return CreateSQLAccountResponse
 */
async function createSQLAccount(request: CreateSQLAccountRequest): CreateSQLAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSQLAccountWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='66428721-FFEC-5023-B4E5-3BD1B67837E0'),
}

model CreateServiceLinkedRoleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateServiceLinkedRoleResponseBody(name='body'),
}

/**
 * @summary Creates a service-linked role.
 *
 * @param request CreateServiceLinkedRoleRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a service-linked role.
 *
 * @param request CreateServiceLinkedRoleRequest
 * @return CreateServiceLinkedRoleResponse
 */
async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model DeleteAccountRequest {
  accountName?: string(name='AccountName', description='The name of the database account.

This parameter is required.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627FA5A19'),
}

model DeleteAccountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAccountResponseBody(name='body'),
}

/**
 * @summary Deletes a database account of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  After you delete a database account, you cannot use the account to log on to the ApsaraDB for ClickHouse cluster. Exercise caution when performing this operation.
 *
 * @param request DeleteAccountRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAccountResponse
 */
async function deleteAccountWithOptions(request: DeleteAccountRequest, runtime: Util.RuntimeOptions): DeleteAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccount',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database account of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  After you delete a database account, you cannot use the account to log on to the ApsaraDB for ClickHouse cluster. Exercise caution when performing this operation.
 *
 * @param request DeleteAccountRequest
 * @return DeleteAccountResponse
 */
async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountWithOptions(request, runtime);
}

model DeleteDBClusterRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the pay-as-you-go ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBClusterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model DeleteDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDBClusterResponseBody(name='body'),
}

/**
 * @summary Releases a pay-as-you-go ApsaraDB for ClickHouse cluster.
 *
 * @description **Warning** After an ApsaraDB for ClickHouse cluster is deleted, all data in the cluster is deleted and cannot be recovered. Exercise caution when performing this operation.
 *
 * @param request DeleteDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteDBClusterResponse
 */
async function deleteDBClusterWithOptions(request: DeleteDBClusterRequest, runtime: Util.RuntimeOptions): DeleteDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBCluster',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases a pay-as-you-go ApsaraDB for ClickHouse cluster.
 *
 * @description **Warning** After an ApsaraDB for ClickHouse cluster is deleted, all data in the cluster is deleted and cannot be recovered. Exercise caution when performing this operation.
 *
 * @param request DeleteDBClusterRequest
 * @return DeleteDBClusterResponse
 */
async function deleteDBCluster(request: DeleteDBClusterRequest): DeleteDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBClusterWithOptions(request, runtime);
}

model DeleteSyndbRequest {
  dbClusterId?: string(name='DbClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp158i5wvj436****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  synDb?: string(name='SynDb', description='The name of the database in the ApsaraDB RDS for MySQL instance. The database is used for data synchronization.

This parameter is required.', example='database'),
}

model DeleteSyndbResponseBody = {
  errorCode?: long(name='ErrorCode', description='The error code.', example='0'),
  errorMsg?: string(name='ErrorMsg', description='*   If the value **true** is returned for the **Status** parameter, the system does not return the ErrorMsg parameter.
*   If the value **false** is returned for the **Status** parameter, the system returns the deletion failure cause for the ErrorMsg parameter.', example='ClickHouse exception, code: 49, host: 100.100.xx.xx, port: 49670; Code: 49, e.displayText() = DB::Exception: Logical error: there is no global context (version 20.8.17.25)n'),
  requestId?: string(name='RequestId', description='The request ID.', example='2C7393F1-5FD1-5CEE-A2EA-270A2CF99693'),
  status?: boolean(name='Status', description='Indicates whether the database used for data synchronization was deleted. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteSyndbResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSyndbResponseBody(name='body'),
}

/**
 * @summary Deletes a database used for data synchronization.
 *
 * @param request DeleteSyndbRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSyndbResponse
 */
async function deleteSyndbWithOptions(request: DeleteSyndbRequest, runtime: Util.RuntimeOptions): DeleteSyndbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.synDb)) {
    query['SynDb'] = request.synDb;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSyndb',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a database used for data synchronization.
 *
 * @param request DeleteSyndbRequest
 * @return DeleteSyndbResponse
 */
async function deleteSyndb(request: DeleteSyndbRequest): DeleteSyndbResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSyndbWithOptions(request, runtime);
}

model DescribeAccountAuthorityRequest {
  accountName?: string(name='AccountName', description='The name of the database account.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1p816075e21****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountAuthorityResponseBody = {
  accountName?: string(name='AccountName', description='The name of the database account.', example='test'),
  allowDatabases?: [ string ](name='AllowDatabases', description='Databases to which permissions have been granted.'),
  allowDictionaries?: [ string ](name='AllowDictionaries', description='Dictionaries to which permissions have been granted.'),
  ddlAuthority?: boolean(name='DdlAuthority', description='Indicates whether the database account has DDL permissions. Valid values:

*   **true**: has DDL permissions.
*   **false**: does not have DDL permissions.', example='true'),
  dmlAuthority?: string(name='DmlAuthority', description='Indicates whether the database account has DML permissions. Valid values:

*   **all**
*   **readOnly,modify**', example='all'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  totalDatabases?: [ string ](name='TotalDatabases', description='All databases.'),
  totalDictionaries?: [ string ](name='TotalDictionaries', description='All dictionaries.'),
}

model DescribeAccountAuthorityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccountAuthorityResponseBody(name='body'),
}

/**
 * @summary Queries the permissions of an account.
 *
 * @param request DescribeAccountAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccountAuthorityResponse
 */
async function describeAccountAuthorityWithOptions(request: DescribeAccountAuthorityRequest, runtime: Util.RuntimeOptions): DescribeAccountAuthorityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccountAuthority',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the permissions of an account.
 *
 * @param request DescribeAccountAuthorityRequest
 * @return DescribeAccountAuthorityResponse
 */
async function describeAccountAuthority(request: DescribeAccountAuthorityRequest): DescribeAccountAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountAuthorityWithOptions(request, runtime);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', description='The name of the database account.

>  If you do not specify this parameter, the information about all database accounts in the ApsaraDB for ClickHouse cluster is queried by default.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from 1. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    account?: [ 
    {
      accountDescription?: string(name='AccountDescription', description='The description of the database account.', example='test'),
      accountName?: string(name='AccountName', description='The name of the database account.', example='test'),
      accountStatus?: string(name='AccountStatus', description='The state of the database account. Valid values:

*   **Creating**
*   **Available**
*   **AuthorityModifying**
*   **Deleting**

>  Only XML-configured database accounts can be in the **AuthorityModifying** state.', example='Creating'),
      accountType?: string(name='AccountType', description='The type of the database account. Valid values:

*   **Super**: privileged account
*   **Normal**: standard account', example='Super'),
      configType?: string(name='ConfigType', description='The configuration mode of the database account.', example='SQL'),
    }
  ](name='Account')
  }(name='Accounts', description='The database accounts.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeAccountsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAccountsResponseBody(name='body'),
}

/**
 * @summary Queries the information about the database accounts of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAccountsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAccountsResponse
 */
async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccounts',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about the database accounts of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAccountsRequest
 * @return DescribeAccountsResponse
 */
async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescribeAllDataSourceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemaName?: string(name='SchemaName', description='The database name.', example='database'),
  tableName?: string(name='TableName', description='The table name.', example='table'),
}

model DescribeAllDataSourceResponseBody = {
  columns?: {
    column?: [ 
    {
      autoIncrementColumn?: boolean(name='AutoIncrementColumn', description='Indicates whether the column is an auto-increment column. Valid values:

*   **true**
*   **false**', example='true'),
      columnName?: string(name='ColumnName', description='The column name.', example='name'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      primaryKey?: boolean(name='PrimaryKey', description='Indicates whether the column is the primary key of the table. Valid values:

*   **true**
*   **false**', example='true'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='table'),
      type?: string(name='Type', description='The type of the column.', example='String'),
    }
  ](name='Column')
  }(name='Columns', description='The information about the columns.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
  schemas?: {
    schema?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
    }
  ](name='Schema')
  }(name='Schemas', description='The information about the databases.'),
  tables?: {
    table?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='table'),
    }
  ](name='Table')
  }(name='Tables', description='The information about the tables.'),
}

model DescribeAllDataSourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllDataSourceResponseBody(name='body'),
}

/**
 * @summary Queries a list of databases, tables, and columns in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAllDataSourceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllDataSourceResponse
 */
async function describeAllDataSourceWithOptions(request: DescribeAllDataSourceRequest, runtime: Util.RuntimeOptions): DescribeAllDataSourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllDataSource',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of databases, tables, and columns in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAllDataSourceRequest
 * @return DescribeAllDataSourceResponse
 */
async function describeAllDataSource(request: DescribeAllDataSourceRequest): DescribeAllDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllDataSourceWithOptions(request, runtime);
}

model DescribeAllDataSourcesRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemaName?: string(name='SchemaName', description='The database name.', example='database'),
  tableName?: string(name='TableName', description='The table name.', example='table'),
}

model DescribeAllDataSourcesResponseBody = {
  columns?: {
    column?: [ 
    {
      autoIncrementColumn?: boolean(name='AutoIncrementColumn', description='Indicates whether the column is an auto-increment column. Valid values:

*   **true**
*   **false**', example='true'),
      columnName?: string(name='ColumnName', description='The column name.', example='name'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      primaryKey?: boolean(name='PrimaryKey', description='Indicates whether the column is the primary key of the table. Valid values:

*   **true**: The column is the primary key of the table.
*   **false**: The column is not the primary key of the table.', example='true'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='table'),
      type?: string(name='Type', description='The column type.', example='String'),
    }
  ](name='Column')
  }(name='Columns', description='Details of the columns.'),
  requestId?: string(name='RequestId', description='The request ID.', example='75EA41D7-025A-50A6-9287-359A91399F1E'),
  schemas?: {
    schema?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
    }
  ](name='Schema')
  }(name='Schemas', description='The information about the databases.'),
  tables?: {
    table?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='table'),
    }
  ](name='Table')
  }(name='Tables', description='The information about the tables.'),
}

model DescribeAllDataSourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAllDataSourcesResponseBody(name='body'),
}

/**
 * @summary Queries the data sources of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAllDataSourcesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeAllDataSourcesResponse
 */
async function describeAllDataSourcesWithOptions(request: DescribeAllDataSourcesRequest, runtime: Util.RuntimeOptions): DescribeAllDataSourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAllDataSources',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the data sources of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeAllDataSourcesRequest
 * @return DescribeAllDataSourcesResponse
 */
async function describeAllDataSources(request: DescribeAllDataSourcesRequest): DescribeAllDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAllDataSourcesWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupPolicyResponseBody = {
  backupRetentionPeriod?: int32(name='BackupRetentionPeriod', description='The retention period for the backup data. By default, the backup data is retained for seven days. Valid values: 7 to 730. Unit: day.', example='7'),
  backupSize?: string(name='BackupSize', description='The size of the backup data. Unit: MB.', example='123124'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The day of a week when the system regularly backs up data. Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**', example='Monday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The backup window. The time is displayed in Coordinated Universal Time (UTC).', example='15:00Z-16:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  switch?: string(name='Switch', description='Indicates whether the backup feature is enabled. Valid values:

*   **true**
*   **false**', example='true'),
}

model DescribeBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Queries the backup settings of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request DescribeBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the backup settings of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request DescribeBackupPolicyRequest
 * @return DescribeBackupPolicyResponse
 */
async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', description='The backup task ID.', example='117403****'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in UTC.

This parameter is required.', example='2021-11-25T16:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in UTC.

This parameter is required.', example='2021-11-21T16:00Z'),
}

model DescribeBackupsResponseBody = {
  items?: [ 
    {
      backupEndTime?: string(name='BackupEndTime', description='The end time of the backup task. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC.', example='2021-11-22T18:28:41Z'),
      backupId?: string(name='BackupId', description='The backup task ID.', example='117403****'),
      backupMethod?: string(name='BackupMethod', description='The backup method. Valid values: Only **Physical** is returned. This value indicates that a physical backup was performed.', example='Physical'),
      backupSetInfo?: string(name='BackupSetInfo', description='The number of nodes in the cluster.

*   If the cluster is of Single-replica Edition, the value ranges from 1 to 48.
*   If the cluster is of Double-replica Edition, the value ranges from 1 to 24.', example='{"shard_count":4}'),
      backupSize?: long(name='BackupSize', description='The size of the backup set. Unit: MB.', example='131072'),
      backupStartTime?: string(name='BackupStartTime', description='The start time of the backup task. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC.', example='2021-11-22T18:28:22Z'),
      backupStatus?: string(name='BackupStatus', description='The backup status. Valid values:

*   **Success**
*   **Failure**', example='Success'),
      backupType?: string(name='BackupType', description='The backup type. Valid values:

*   **FullBackup**
*   **IncrementalBackup**', example='IncrementalBackup'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp1qx68m06981****'),
      expireDate?: string(name='ExpireDate', description='The time when the backup set expired. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC.', example='2022-07-22T18:28:41Z'),
    }
  ](name='Items', description='The backup sets.'),
  pageNumber?: string(name='PageNumber', description='The page number.', example='1'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Valid values: Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  totalCount?: string(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeBackupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeBackupsResponseBody(name='body'),
}

/**
 * @summary Queries the backup sets of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for ApsaraDB for ClickHouse clusters of version 21.8 and later.
 *
 * @param request DescribeBackupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeBackupsResponse
 */
async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the backup sets of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for ApsaraDB for ClickHouse clusters of version 21.8 and later.
 *
 * @param request DescribeBackupsRequest
 * @return DescribeBackupsResponse
 */
async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeColumnsRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-2zeux3ua25242****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemaName?: string(name='SchemaName', description='The database name. You can call the [DescribeSchemas](https://help.aliyun.com/document_detail/350931.html) operation to query database names.

This parameter is required.', example='database'),
  tableName?: string(name='TableName', description='The table name. You can call the [DescribeTables](https://help.aliyun.com/document_detail/350932.html) operation to query table names.

This parameter is required.', example='table'),
}

model DescribeColumnsResponseBody = {
  items?: {
    column?: [ 
    {
      autoIncrementColumn?: boolean(name='AutoIncrementColumn', description='Indicates whether the column is an auto-increment column. Valid values:

*   **true**
*   **false**', example='true'),
      columnName?: string(name='ColumnName', description='The column name.', example='name'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-2zeux3ua25242****'),
      primaryKey?: boolean(name='PrimaryKey', description='Indicates whether the column is the primary key of the table. Valid values:

*   **true**
*   **false**', example='true'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='table'),
      type?: string(name='Type', description='The column type.', example='String'),
    }
  ](name='Column')
  }(name='Items', description='Details of the columns.'),
  requestId?: string(name='RequestId', description='The request ID.', example='66428721-FFEC-5023-B4E5-3BD1B67837E0'),
}

model DescribeColumnsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeColumnsResponseBody(name='body'),
}

/**
 * @summary Queries information about columns.
 *
 * @param request DescribeColumnsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeColumnsResponse
 */
async function describeColumnsWithOptions(request: DescribeColumnsRequest, runtime: Util.RuntimeOptions): DescribeColumnsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  if (!Util.isUnset(request.tableName)) {
    query['TableName'] = request.tableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeColumns',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about columns.
 *
 * @param request DescribeColumnsRequest
 * @return DescribeColumnsResponse
 */
async function describeColumns(request: DescribeColumnsRequest): DescribeColumnsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeColumnsWithOptions(request, runtime);
}

model DescribeConfigHistoryRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1p816075e21****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2022-08-22T10:06:00Z'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in Coordinated Universal Time (UTC).

This parameter is required.', example='2022-08-11T06:27:00Z'),
}

model DescribeConfigHistoryResponseBody = {
  configHistoryItems?: [ 
    {
      changeId?: string(name='ChangeId', description='The ID of the change record.', example='1'),
      ownerId?: string(name='OwnerId', description='The user ID (UID) of the Alibaba Cloud account.', example='253460731706911258'),
      reason?: string(name='Reason', description='The reason for the setting modification of the configuration parameters.', example='test'),
      success?: boolean(name='Success', description='Indicates whether the setting modification of the configuration parameters took effect. Valid values:

*   **true**
*   **false**', example='true'),
      time?: string(name='Time', description='The time when the values of the configuration parameters were changed. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-08-22T10:00:00Z'),
    }
  ](name='ConfigHistoryItems', description='The change records of the configuration parameters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model DescribeConfigHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConfigHistoryResponseBody(name='body'),
}

/**
 * @summary Queries the change records of the configuration parameters of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeConfigHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConfigHistoryResponse
 */
async function describeConfigHistoryWithOptions(request: DescribeConfigHistoryRequest, runtime: Util.RuntimeOptions): DescribeConfigHistoryResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConfigHistory',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the change records of the configuration parameters of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeConfigHistoryRequest
 * @return DescribeConfigHistoryResponse
 */
async function describeConfigHistory(request: DescribeConfigHistoryRequest): DescribeConfigHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigHistoryWithOptions(request, runtime);
}

model DescribeConfigVersionDifferenceRequest {
  changeId?: string(name='ChangeId', description='The ID of the change record. You can call the [DescribeConfigHistory](https://help.aliyun.com/document_detail/452209.html) operation to query the ID of the change record.

This parameter is required.', example='1'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1tm8zf130ew****'),
}

model DescribeConfigVersionDifferenceResponseBody = {
  newConfigXML?: string(name='NewConfigXML', description='The values of the configuration parameters after the values of the configuration parameters are changed.', example='"<?xml version="1.0"?>
<yandex>
    <keep_alive_timeout>400</keep_alive_timeout>
    <listen_backlog>4096</listen_backlog>
    <logger>
        <level>debug</level>
        <size>1000M</size>
    </logger>
    <mark_cache_size>5368709120</mark_cache_size>
    <max_concurrent_queries>201</max_concurrent_queries>
    <max_connections>4096</max_connections>
    <max_partition_size_to_drop>0</max_partition_size_to_drop>
    <max_table_size_to_drop>0</max_table_size_to_drop>
    <merge_tree>
        <max_delay_to_insert>256</max_delay_to_insert>
        <max_part_loading_threads>auto</max_part_loading_threads>
        <max_suspicious_broken_parts>100</max_suspicious_broken_parts>
        <zookeeper_session_expiration_check_period>1</zookeeper_session_expiration_check_period>
    </merge_tree>
    <uncompressed_cache_size>1717986918</uncompressed_cache_size>
</yandex>"'),
  oldConfigXML?: string(name='OldConfigXML', description='The values of the configuration parameters before the values of the configuration parameters are changed.', example='"<?xml version="1.0"?>
<yandex>
    <keep_alive_timeout>300</keep_alive_timeout>
    <listen_backlog>4096</listen_backlog>
    <logger>
        <level>debug</level>
        <size>1000M</size>
    </logger>
    <mark_cache_size>5368709120</mark_cache_size>
    <max_concurrent_queries>150</max_concurrent_queries>
    <max_connections>4096</max_connections>
    <max_partition_size_to_drop>0</max_partition_size_to_drop>
    <max_table_size_to_drop>0</max_table_size_to_drop>
    <merge_tree>
        <max_delay_to_insert>256</max_delay_to_insert>
        <max_part_loading_threads>auto</max_part_loading_threads>
        <max_suspicious_broken_parts>100</max_suspicious_broken_parts>
        <zookeeper_session_expiration_check_period>1</zookeeper_session_expiration_check_period>
    </merge_tree>
    <uncompressed_cache_size>1717986918</uncompressed_cache_size>
</yandex>"'),
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model DescribeConfigVersionDifferenceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeConfigVersionDifferenceResponseBody(name='body'),
}

/**
 * @summary Queries the values of the configuration parameters of an ApsaraDB for ClickHouse cluster before and after the values of the configuration parameters are changed.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeConfigVersionDifferenceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeConfigVersionDifferenceResponse
 */
async function describeConfigVersionDifferenceWithOptions(request: DescribeConfigVersionDifferenceRequest, runtime: Util.RuntimeOptions): DescribeConfigVersionDifferenceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeConfigVersionDifference',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the values of the configuration parameters of an ApsaraDB for ClickHouse cluster before and after the values of the configuration parameters are changed.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeConfigVersionDifferenceRequest
 * @return DescribeConfigVersionDifferenceResponse
 */
async function describeConfigVersionDifference(request: DescribeConfigVersionDifferenceRequest): DescribeConfigVersionDifferenceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeConfigVersionDifferenceWithOptions(request, runtime);
}

model DescribeDBClusterAccessWhiteListRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAccessWhiteListResponseBody = {
  DBClusterAccessWhiteList?: {
    IPArray?: [ 
    {
      DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attribute of the IP address whitelist.', example='default'),
      DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP address whitelist.', example='default'),
      securityIPList?: string(name='SecurityIPList', description='The IP addresses in the IP address whitelist.', example='192.168.xx.xx,192.168.xx.xx'),
    }
  ](name='IPArray')
  }(name='DBClusterAccessWhiteList', description='The details about the IP address whitelist.'),
  requestId?: string(name='RequestId', description='The request ID.', example='905F13A4-5097-4897-A84D-527EC75FFF4F'),
}

model DescribeDBClusterAccessWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAccessWhiteListResponseBody(name='body'),
}

/**
 * @summary Queries the IP address whitelist of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterAccessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAccessWhiteListResponse
 */
async function describeDBClusterAccessWhiteListWithOptions(request: DescribeDBClusterAccessWhiteListRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAccessWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAccessWhiteList',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the IP address whitelist of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterAccessWhiteListRequest
 * @return DescribeDBClusterAccessWhiteListResponse
 */
async function describeDBClusterAccessWhiteList(request: DescribeDBClusterAccessWhiteListRequest): DescribeDBClusterAccessWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAccessWhiteListWithOptions(request, runtime);
}

model DescribeDBClusterAttributeRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterAttributeResponseBody = {
  DBCluster?: {
    aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='140692647406****'),
    appointmentElectZookeeperDisableWrite?: boolean(name='AppointmentElectZookeeperDisableWrite'),
    appointmentElectZookeeperTime?: string(name='AppointmentElectZookeeperTime'),
    appointmentRestartNodeList?: string(name='AppointmentRestartNodeList'),
    appointmentRestartNodeTime?: string(name='AppointmentRestartNodeTime'),
    appointmentRestartTime?: string(name='AppointmentRestartTime', description='The scheduled restart time. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time is displayed in Coordinated Universal Time (UTC).', example='2023-11-06T12:00:00Z'),
    availableUpgradeMajorVersion?: map[string]any(name='AvailableUpgradeMajorVersion', description='The major engine versions available for upgrades.', example='{"MajorVersion":"MinorVersion"}'),
    bid?: string(name='Bid', description='The site ID. Valid values:

*   **26842**: the China site (aliyun.com)
*   **26888**: the international site (alibabacloud.com)', example='26842'),
    category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Basic**: Single-replica Edition
*   **HighAvailability**: Double-replica Edition', example='HighAvailability'),
    commodityCode?: string(name='CommodityCode', description='The commodity code of the cluster.', example='clickhouse_go_public_cn'),
    connectionString?: string(name='ConnectionString', description='The VPC endpoint of the cluster.', example='cc-bp1qx68m06981****.ads.rds.aliyuncs.com'),
    controlVersion?: string(name='ControlVersion', description='The version of the ApsaraDB for ClickHouse console that is used to manage the cluster. Valid values:

*   **v1**
*   **v2**', example='v1'),
    createTime?: string(name='CreateTime', description='The time when the cluster was created. The value is in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-12-13T11:33:11Z'),
    DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='cc-bp108z124a8o7****'),
    DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
    DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster. Only VPC is supported.', example='vpc'),
    DBClusterStatus?: string(name='DBClusterStatus', description='The cluster state. Valid values:

*   **Preparing**: The cluster is being prepared.
*   **Creating**: The cluster is being created.
*   **Running**: The cluster is running.
*   **Deleting**: The cluster is being deleted.
*   **SCALING_OUT**: The storage capacity of the cluster is being expanded.', example='Running'),
    DBClusterType?: string(name='DBClusterType', description='The type of the cluster. Valid values:

*   **Common**: a common cluster
*   **Readonly**: a read-only cluster
*   **Guard**: a disaster recovery cluster', example='Common'),
    DBNodeClass?: string(name='DBNodeClass', description='The specifications of the cluster.

*   Valid values when the cluster is of Single-replica Edition:

    *   **S4-NEW**
    *   **S8**
    *   **S16**
    *   **S32**
    *   **S64**
    *   **S104**

*   Valid values when the cluster is of Double-replica Edition:

    *   **C4-NEW**
    *   **C8**
    *   **C16**
    *   **C32**
    *   **C64**
    *   **C104**', example='C8'),
    DBNodeCount?: long(name='DBNodeCount', description='The number of nodes.

*   Valid values when the cluster is of Single-replica Edition: 1 to 48.
*   Valid values when the cluster is of Double-replica Edition: 1 to 24.', example='1'),
    DBNodeStorage?: long(name='DBNodeStorage', description='The storage capacity of a single node of the cluster. Unit: GB.

Valid values: 100 to 32000.

>  This value is a multiple of 100.', example='100'),
    encryptionKey?: string(name='EncryptionKey', description='The Key Management Service (KMS) key that is used to encrypt data.

>  If the value of the EncryptionType parameter is off, an empty string is returned for this parameter.', example='685f416f-87c9-4554-8d3a-75b6ce25****'),
    encryptionType?: string(name='EncryptionType', description='The encryption type. Valid values:

*   **CloudDisk**: Disk encryption is enabled.
*   **off**: Data is not encrypted.', example='CloudDisk'),
    engine?: string(name='Engine', description='The type of the database engine.', example='ClickHouse'),
    engineLatestMinorVersion?: string(name='EngineLatestMinorVersion', description='The latest minor version to which the cluster can be updated.', example='1.34.0'),
    engineMinorVersion?: string(name='EngineMinorVersion', description='The current minor version.', example='1.6.0'),
    engineVersion?: string(name='EngineVersion', description='The engine version.', example='21.8.10.19'),
    expireTime?: string(name='ExpireTime', description='The time when the cluster expired. The time is in the yyyy-MM-ddTHH:mm:ssZ format.

>  Pay-as-you-go clusters never expire. If the cluster is a pay-as-you-go cluster, an empty string is returned for this parameter.', example='2022-11-11T16:00:00Z'),
    extStorageSize?: int32(name='ExtStorageSize', description='The extended storage space. Unit: GB.', example='500'),
    extStorageType?: string(name='ExtStorageType', description='The extended storage type. Valid values:

*   **CloudESSD**: The cluster uses an enhanced SSD (ESSD) of performance level (PL) 1.
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL 2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL 3.
*   **CloudEfficiency**: The cluster uses an ultra disk.', example='CloudESSD'),
    isExpired?: string(name='IsExpired', description='Indicates whether the cluster has expired. Valid values:

*   **true**
*   **false**', example='false'),
    lockMode?: string(name='LockMode', description='The lock mode of the cluster. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked due to cluster expiration.
*   **LockByRestoration**: The cluster is automatically locked because the cluster is about to be rolled back.
*   **LockByDiskQuota**: The cluster is automatically locked because the disk space is exhausted.', example='Unlock'),
    lockReason?: string(name='LockReason', description='The cause why the cluster was locked.

>  If the value of the LockMode parameter is Unlock, an empty string is returned for this parameter.', example='DISK_FULL'),
    maintainAutoType?: boolean(name='MaintainAutoType', description='The update type. If the value of the parameter is **false**, it indicates a manual update.', example='false'),
    maintainTime?: string(name='MaintainTime', description='The maintenance window of the cluster. The value is in the HH:mmZ-HH:mmZ format. The time is displayed in UTC.

For example, if you set the maintenance window to 00:00Z-01:00Z, the cluster can be maintained from 08:00 (UTC+8) to 09:00 (UTC+8).', example='00:00Z-01:00Z'),
    payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: indicates the pay-as-you-go billing method.
*   **Prepaid**: indicates the subscription billing method.', example='Prepaid'),
    port?: int32(name='Port', description='The HTTP port number.', example='8123'),
    publicConnectionString?: string(name='PublicConnectionString', description='The public endpoint.', example='cc-bp1199ya710s7****.public.clickhouse.ads.aliyuncs.com'),
    publicIpAddr?: string(name='PublicIpAddr', description='The IP address that is used to connect to the cluster over the Internet.', example='121.40.xx.xx'),
    publicPort?: string(name='PublicPort', description='The TCP port number in the public endpoint.', example='3306'),
    regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
    resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmyf65je6****'),
    scaleOutStatus?: {
      progress?: string(name='Progress', description='The progress of the data migration task in percentage.

>  This parameter is returned only when the cluster is in the SCALING_OUT state.', example='0'),
      ratio?: string(name='Ratio', description='The progress of the data migration task. This value is displayed in the following format: Data volume that has been migrated/Total data volume.

>  This parameter is returned only when the cluster is in the SCALING_OUT state.', example='0MB/60469MB'),
    }(name='ScaleOutStatus', description='The status of the data migration task.'),
    storageType?: string(name='StorageType', description='The storage type of the cluster. Valid values:

*   **CloudESSD**: The cluster uses an enhanced SSD (ESSD) of performance level (PL) 1.
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL 2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL 3.
*   **CloudEfficiency**: The cluster uses an ultra disk.', example='CloudESSD'),
    supportBackup?: int32(name='SupportBackup', description='Indicates whether data backup is supported. Valid values:

*   **1**: Data backup is supported.
*   **2**: Data backup is not supported.', example='1'),
    supportHttpsPort?: boolean(name='SupportHttpsPort', description='Indicates whether HTTPS ports are supported. Valid values:

*   **true**
*   **false**', example='false'),
    supportMysqlPort?: boolean(name='SupportMysqlPort', description='Indicates whether the cluster supports a MySQL port. Valid values:

*   **true**: A MySQL port is supported.
*   **false**: A MySQL port is not supported.', example='false'),
    supportOss?: int32(name='SupportOss', description='Indicates whether tiered storage of hot data and cold data is supported. Valid values:

*   **1**: Tiered storage of hot data and cold data is supported.
*   **2**: Tiered storage of hot data and cold data is not supported.', example='1'),
    tags?: {
      tag?: [ 
      {
        key?: string(name='Key', description='The tag name.', example='department'),
        value?: string(name='Value', description='The tag value.', example='it'),
      }
    ](name='Tag')
    }(name='Tags', description='The tags.'),
    vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1n874li1t5y57wi****'),
    vpcCloudInstanceId?: string(name='VpcCloudInstanceId', description='The ID of the VPC in which the cluster is deployed.', example='vpc-bp10tr8k9qasioaty****'),
    vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.', example='vpc-bp10tr8k9qasioaty****'),
    vpcIpAddr?: string(name='VpcIpAddr', description='The IP address that is used to connect to the cluster over the VPC.', example='192.168.xx.xx'),
    zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-h'),
    zoneIdVswitchMap?: map[string]any(name='ZoneIdVswitchMap', description='The list of vSwitch IDs in multi-zone clusters.', example='cn-shanghai-f: vsw-zm0n42d5vvuo****'),
    zookeeperClass?: string(name='ZookeeperClass', description='The ZooKeeper specifications.', example='4 Core 8 GB'),
  }(name='DBCluster', description='The information about the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model DescribeDBClusterAttributeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterAttributeResponseBody(name='body'),
}

/**
 * @summary Queries the information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterAttributeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterAttributeResponse
 */
async function describeDBClusterAttributeWithOptions(request: DescribeDBClusterAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBClusterAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterAttribute',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterAttributeRequest
 * @return DescribeDBClusterAttributeResponse
 */
async function describeDBClusterAttribute(request: DescribeDBClusterAttributeRequest): DescribeDBClusterAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterAttributeWithOptions(request, runtime);
}

model DescribeDBClusterConfigRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-wz988vja2mor4****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterConfigResponseBody = {
  config?: string(name='Config', description='The information about the parameter settings of the cluster.', example='[ { "name": "keep_alive_timeout", "defaultValue": 300, "currentValue": 300, "restart": true, "valueRange": ">0", "desc": "The number of seconds that ClickHouse waits for incoming requests before closing the connection." }, ... ,{ "name": "max_partition_size_to_drop", "defaultValue": 0, "currentValue": 0, "restart": true, "valueRange": ">=0", "desc": "If the size of a MergeTree partition exceeds max_partition_size_to_drop (in bytes), you can’t delete it using a DROP query." } ]'),
  requestId?: string(name='RequestId', description='The request ID.', example='9A23C87D-87DF-4DA0-A50E-CB13F4F7923D'),
}

model DescribeDBClusterConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterConfigResponseBody(name='body'),
}

/**
 * @summary Queries information about the parameter settings of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterConfigResponse
 */
async function describeDBClusterConfigWithOptions(request: DescribeDBClusterConfigRequest, runtime: Util.RuntimeOptions): DescribeDBClusterConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterConfig',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about the parameter settings of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterConfigRequest
 * @return DescribeDBClusterConfigResponse
 */
async function describeDBClusterConfig(request: DescribeDBClusterConfigRequest): DescribeDBClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterConfigWithOptions(request, runtime);
}

model DescribeDBClusterConfigInXMLRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp108z124a8o7****'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
}

model DescribeDBClusterConfigInXMLResponseBody = {
  config?: string(name='Config', description='The values of the configuration parameters.', example='<?xml version="1.0"?>
<yandex>
    <keep_alive_timeout>300</keep_alive_timeout>
    <listen_backlog>64</listen_backlog>
    <logger>
        <level>debug</level>
        <size>1000M</size>
    </logger>
    <mark_cache_size>6871947673</mark_cache_size>
    <max_concurrent_queries>100</max_concurrent_queries>
    <max_connections>4096</max_connections>
    <max_partition_size_to_drop>0</max_partition_size_to_drop>
    <max_server_memory_usage>0</max_server_memory_usage>
<max_server_memory_usage_to_ram_ratio>0.9</max_server_memory_usage_to_ram_ratio>
    <max_table_size_to_drop>0</max_table_size_to_drop>
    <max_thread_pool_size>10000</max_thread_pool_size>
    <merge_tree>
        <max_delay_to_insert>256</max_delay_to_insert>
        <max_part_loading_threads>16</max_part_loading_threads>      <zookeeper_session_expiration_check_period>1</zookeeper_session_expiration_check_period>
    </merge_tree>
    <total_memory_profiler_step>4194304</total_memory_profiler_step>
<total_memory_tracker_sample_probability>0</total_memory_tracker_sample_probability>
    <uncompressed_cache_size>3435973836</uncompressed_cache_size>
</yandex>'),
  requestId?: string(name='RequestId', description='The request ID.', example='FE042911-2B00-134C-9F42-816871BBAFB8'),
}

model DescribeDBClusterConfigInXMLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterConfigInXMLResponseBody(name='body'),
}

/**
 * @summary Queries the values of the configuration parameters in the config.xml file of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeDBClusterConfigInXMLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterConfigInXMLResponse
 */
async function describeDBClusterConfigInXMLWithOptions(request: DescribeDBClusterConfigInXMLRequest, runtime: Util.RuntimeOptions): DescribeDBClusterConfigInXMLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterConfigInXML',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the values of the configuration parameters in the config.xml file of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request DescribeDBClusterConfigInXMLRequest
 * @return DescribeDBClusterConfigInXMLResponse
 */
async function describeDBClusterConfigInXML(request: DescribeDBClusterConfigInXMLRequest): DescribeDBClusterConfigInXMLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterConfigInXMLWithOptions(request, runtime);
}

model DescribeDBClusterNetInfoItemsRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBClusterNetInfoItemsResponseBody = {
  clusterNetworkType?: string(name='ClusterNetworkType', description='The network type of the cluster. Only VPC is supported.', example='VPC'),
  enableSLB?: boolean(name='EnableSLB', description='Indicates whether Server Load Balancer (SLB) is activated in the VPC. Valid values:

*   true
*   false

This parameter is required.', example='true'),
  netInfoItems?: {
    netInfoItem?: [ 
    {
      connectionString?: string(name='ConnectionString', description='The endpoint that is used to connect to the database.', example='cc-bp1554t789i8e****.clickhouse.ads.aliyuncs.com'),
      httpPort?: string(name='HttpPort', description='The HTTP port number.', example='8123'),
      httpsPort?: string(name='HttpsPort', description='The HTTPS port number.', example='8443'),
      IPAddress?: string(name='IPAddress', description='The IP address.', example='10.255.234.251'),
      jdbcPort?: string(name='JdbcPort', description='The port number that is used in Java Database Connectivity (JDBC).', example='3306'),
      mySQLPort?: string(name='MySQLPort', description='The port of the MySQL instance.', example='9004'),
      netType?: string(name='NetType', description='The network type of the endpoint. Valid values:

*   Public: public endpoint
*   VPC: VPC', example='VPC'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.

>  If the value of the NetType parameter is set to Public, an empty string is returned.', example='vsw-bp1gzt31twhlo0sa5****'),
      vpcId?: string(name='VpcId', description='The virtual private cloud (VPC) ID.

>  If the value of the NetType parameter is set to Public, an empty string is returned.', example='vpc-bp175iuvg8nxqraf2****'),
    }
  ](name='NetInfoItem')
  }(name='NetInfoItems', description='The network information about the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='9A23C87D-87DF-4DA0-A50E-CB13F4F7923D'),
}

model DescribeDBClusterNetInfoItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterNetInfoItemsResponseBody(name='body'),
}

/**
 * @summary Queries the network information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterNetInfoItemsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterNetInfoItemsResponse
 */
async function describeDBClusterNetInfoItemsWithOptions(request: DescribeDBClusterNetInfoItemsRequest, runtime: Util.RuntimeOptions): DescribeDBClusterNetInfoItemsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterNetInfoItems',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the network information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBClusterNetInfoItemsRequest
 * @return DescribeDBClusterNetInfoItemsResponse
 */
async function describeDBClusterNetInfoItems(request: DescribeDBClusterNetInfoItemsRequest): DescribeDBClusterNetInfoItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterNetInfoItemsWithOptions(request, runtime);
}

model DescribeDBClusterPerformanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp125e3uu94wo****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in UTC.

>  The end time must be later than the start time. The interval cannot be more than 32 days.

This parameter is required.', example='2021-11-27T16:38Z'),
  key?: string(name='Key', description='The performance metrics that you want to query. Separate multiple performance metrics with commas (,). You can query up to five performance metrics at a time. You can query the following performance metrics:

>  The **Key** parameter is required.

*   **CPU**:

    *   **CPU_USAGE**: the CPU utilization

*   **Memory**:

    *   **MEM_USAGE**: the memory usage
    *   **MEM_USAGE_SIZE**: the used memory. Unit: MB

*   **Disk**:

    *   **DISK_USAGE**: the disk usage
    *   **DISK_USAGE_SIZE**: the size of the used disks. Unit: MB
    *   **IOPS**: the disk Input/Output Operations per Second (IOPS)

*   **Connection**:

    *   **CONN_USAGE**: the database connection usage
    *   **CONN_USAGE_COUNT**: the number of database connections used

*   **Write**:

    *   **TPS**: the number of rows written per second
    *   **INSERT_SIZE**: the amount of data written per second. Unit: MB

*   **Query**:

    *   **QPS**: the queries per second
    *   **AVG_SEEK**: the average number of random seek calls

*   **WAIT**:

    *   **ZK_WAIT**: the average ZooKeeper wait time. Unit: ms
    *   **IO_WAIT**: the average I/O wait time. Unit: ms
    *   **CPU_WAIT**: the average CPU wait time. Unit: ms', example='MEM_USAGE'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in Coordinated Universal Time (UTC).

This parameter is required.', example='2021-11-27T16:37Z'),
}

model DescribeDBClusterPerformanceResponseBody = {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp125e3uu94wo****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in Coordinated Universal Time (UTC).', example='2021-11-27T16:38Z'),
  performances?: [ 
    {
      key?: string(name='Key', description='The name of the performance metric.', example='MEM_USAGE'),
      name?: string(name='Name', description='The name of the performance metric value.', example='mem_usage'),
      series?: [ 
        {
          name?: string(name='Name', description='The name of the list of performance metric values.', example='cc-bp125e3uu94wo1s0k16****'),
          values?: [ 
            {
              point?: [ string ](name='Point', description='The values of a metric.'),
            }
          ](name='Values', description='The values of the performance parameter. Each value of the performance parameter is collected at a point in time.'),
        }
      ](name='Series', description='The queried performance pamaters.'),
      unit?: string(name='Unit', description='The unit of the performance metric.', example='%'),
    }
  ](name='Performances', description='The values of the queried performance metrics of the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FE242962-6DA3-5FC8-9691-37B62A3210F7'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time is displayed in UTC.', example='2021-11-27T16:37Z'),
}

model DescribeDBClusterPerformanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClusterPerformanceResponseBody(name='body'),
}

/**
 * @summary Queries performance data about an ApsaraDB for ClickHouse cluster.
 *
 * @description You can query the performance data of a specified cluster over a specific time range based on the performance metrics. The data is collected every 30 seconds.
 * >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created before December 1, 2021.
 *
 * @param request DescribeDBClusterPerformanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformanceWithOptions(request: DescribeDBClusterPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBClusterPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusterPerformance',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries performance data about an ApsaraDB for ClickHouse cluster.
 *
 * @description You can query the performance data of a specified cluster over a specific time range based on the performance metrics. The data is collected every 30 seconds.
 * >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created before December 1, 2021.
 *
 * @param request DescribeDBClusterPerformanceRequest
 * @return DescribeDBClusterPerformanceResponse
 */
async function describeDBClusterPerformance(request: DescribeDBClusterPerformanceRequest): DescribeDBClusterPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClusterPerformanceWithOptions(request, runtime);
}

model DescribeDBClustersRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='cc-bp108z124a8o7****'),
  DBClusterIds?: string(name='DBClusterIds', description='The cluster ID.

>  If you do not specify this parameter, the information about all clusters is queried.', example='cc-bp108z124a8o7****'),
  DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster. Valid values:

*   **Preparing**: The cluster is being prepared.
*   **Creating**: The cluster is being created.
*   **Running**: The cluster is running.
*   **Deleting**: The cluster is being deleted.
*   **SCALING_OUT**: The storage capacity of the cluster is being expanded.', example='Running'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.', example='rg-4690g37929****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag name.', example='department'),
      value?: string(name='Value', description='The tag value.', example='it'),
    }
  ](name='Tag', description='The tags.'),
}

model DescribeDBClustersResponseBody = {
  DBClusters?: {
    DBCluster?: [ 
    {
      aliUid?: string(name='AliUid', description='The ID of the Alibaba Cloud account.', example='140692647406****'),
      bid?: string(name='Bid', description='The site ID. Valid values:

*   **26842**: the China site (aliyun.com)
*   **26888**: the international site (alibabacloud.com)', example='26842'),
      category?: string(name='Category', description='The edition of the cluster. Valid values:

*   **Basic**: Single-replica Edition
*   **HighAvailability**: Double-replica Edition', example='Basic'),
      commodityCode?: string(name='CommodityCode', description='The commodity code of the cluster.', example='clickhouse_go_public_cn'),
      connectionString?: string(name='ConnectionString', description='The VPC endpoint of the cluster.', example='cc-bp1fs5o051c61****.clickhouse.ads.aliyuncs.com'),
      controlVersion?: string(name='ControlVersion', description='The version number of the backend management system of ApsaraDB for ClickHouse. Valid values:

*   **v1**
*   **v2**', example='v1'),
      createTime?: string(name='CreateTime', description='The time when the cluster was created. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.', example='2021-10-28T07:24:45Z'),
      DBClusterDescription?: string(name='DBClusterDescription', description='The description of the cluster.', example='test'),
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      DBClusterNetworkType?: string(name='DBClusterNetworkType', description='The network type of the cluster. Only VPC is supported.', example='VPC'),
      DBClusterStatus?: string(name='DBClusterStatus', description='The state of the cluster. Valid values:

*   **Preparing**: The cluster is being prepared.
*   **Creating**: The cluster is being created.
*   **Running**: The cluster is running.
*   **Deleting**: The cluster is being deleted.
*   **SCALING_OUT**: The storage capacity of the cluster is being expanded.', example='Running'),
      DBNodeClass?: string(name='DBNodeClass', description='The specifications of the cluster.

*   Valid values when the cluster is of Single-replica Edition: -**S4**: 4 CPU cores and 16 GB of memory -**S8**: 8 CPU cores and 32 GB of memory

    *   **S16**: 16 CPU cores and 64 GB of memory
    *   **S32**: 32 CPU cores and 128 GB of memory
    *   **S64**: 64 CPU cores and 256 GB of memory
    *   **S104**: 104 CPU cores and 384 GB of memory

*   Valid values when the cluster is of Double-replica Edition: -**C4**: 4 CPU cores and 16 GB of memory -**C8**: 8 CPU cores and 32 GB of memory -**C16**: 16 CPU cores and 64 GB of memory -**C32**: 32 CPU cores and 128 GB of memory -**C64**: 64 CPU cores and 256 GB of memory -**C104**: 104 CPU cores and 384 GB of memory', example='C8'),
      DBNodeCount?: long(name='DBNodeCount', description='The number of nodes.

*   Valid values when the cluster is of Single-replica Edition: 1 to 48.
*   Valid values when the cluster is of Double-replica Edition: 1 to 24.', example='2'),
      DBNodeStorage?: long(name='DBNodeStorage', description='The storage capacity of each node. Valid values: 100 to 32000. Unit: GB.

>  This value is a multiple of 100.', example='100'),
      dbVersion?: string(name='DbVersion', description='The engine version of the cluster.', example='23.8'),
      expireTime?: string(name='ExpireTime', description='The time when the cluster expired. The time is in the yyyy-MM-ddTHH:mm:ssZ format.

>  Pay-as-you-go clusters never expire. If the cluster is a pay-as-you-go cluster, an empty string is returned for this parameter.', example='2011-05-30T12:11:4Z'),
      extStorageSize?: int32(name='ExtStorageSize', description='The extended storage space.', example='100GB'),
      extStorageType?: string(name='ExtStorageType', description='The extended storage type. Valid values:

*   **CloudSSD**: standard SSD.
*   **CloudESSD**: The cluster uses an enhanced SSD (ESSD) of performance level (PL) 1.
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL 2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL 3.
*   **CloudEfficiency**: The cluster uses an ultra disk.', example='CloudESSD'),
      isExpired?: string(name='IsExpired', description='Indicates whether the cluster has expired. Valid values:

*   **true**: The cluster has expired.
*   **false**: The cluster has not expired.', example='false'),
      lockMode?: string(name='LockMode', description='The lock mode of the cluster. Valid values:

*   **Unlock**: The cluster is not locked.
*   **ManualLock**: The cluster is manually locked.
*   **LockByExpiration**: The cluster is automatically locked due to cluster expiration.
*   **LockByRestoration**: The cluster is automatically locked because the cluster is about to be rolled back.
*   **LockByDiskQuota**: The cluster is automatically locked because the disk space is exhausted.', example='Unlock'),
      lockReason?: string(name='LockReason', description='The cause why the cluster was locked.

>  If the value of the LockMode parameter is Unlock, an empty string is returned for this parameter.', example='DISK_FULL'),
      payType?: string(name='PayType', description='The billing method of the cluster. Valid values:

*   **Postpaid**: The cluster uses the pay-as-you-go billing method.
*   **Prepaid**: The cluster uses the subscription billing method.', example='Postpaid'),
      port?: int32(name='Port', description='The HTTP port number.', example='8123'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the cluster belongs.', example='rg-4690g37929****'),
      scaleOutDisableWriteWindows?: string(name='ScaleOutDisableWriteWindows', description='The time window during which write operations are stopped for specification changes.', example='2025-02-08T00:00:00+08:00,2025-02-12T00:00:00+08:00'),
      scaleOutStatus?: {
        progress?: string(name='Progress', description='The progress of the data migration task in percentage.

>  This parameter is returned only when the cluster is in the SCALING_OUT state.', example='0'),
        ratio?: string(name='Ratio', description='The progress of the data migration task. This value is displayed in the following format: Data volume that has been migrated/Total data volume.

>  This parameter is returned only when the cluster is in the SCALING_OUT state.', example='0MB/60469MB'),
      }(name='ScaleOutStatus', description='The status of a data migration task.'),
      storageType?: string(name='StorageType', description='The storage type of the cluster. Valid values:

*   **CloudESSD**: The cluster uses an enhanced SSD (ESSD) of performance level (PL) 1.
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL 2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL 3.
*   **CloudEfficiency**: The cluster uses an ultra disk.', example='CloudESSD'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag name.', example='department'),
          value?: string(name='Value', description='The tag value.', example='it'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags.'),
      vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-bp1gzt31twhlo0sa5****'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId', description='The ID of the VPC in which the cluster is deployed.', example='vpc-bp175iuvg8nxqraf2****'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) in which the cluster is deployed.', example='vpc-bp175iuvg8nxqraf2****'),
      zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-h'),
    }
  ](name='DBCluster')
  }(name='DBClusters', description='The clusters.'),
  pageNumber?: int32(name='PageNumber', description='The total number of returned pages.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
  totalCount?: int32(name='TotalCount', description='The total number of entries that are returned.', example='1'),
}

model DescribeDBClustersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBClustersResponseBody(name='body'),
}

/**
 * @summary Queries the information about ApsaraDB for ClickHouse clusters in a region.
 *
 * @param request DescribeDBClustersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBClustersResponse
 */
async function describeDBClustersWithOptions(request: DescribeDBClustersRequest, runtime: Util.RuntimeOptions): DescribeDBClustersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterIds)) {
    query['DBClusterIds'] = request.DBClusterIds;
  }
  if (!Util.isUnset(request.DBClusterStatus)) {
    query['DBClusterStatus'] = request.DBClusterStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBClusters',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about ApsaraDB for ClickHouse clusters in a region.
 *
 * @param request DescribeDBClustersRequest
 * @return DescribeDBClustersResponse
 */
async function describeDBClusters(request: DescribeDBClustersRequest): DescribeDBClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBClustersWithOptions(request, runtime);
}

model DescribeDBConfigRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-t4nw17nh2e4t2****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBConfigResponseBody = {
  config?: string(name='Config', description='The configuration information about the cluster.', example='<dictionaries><dictionary><name>test</name><source><clickhouse><host>10.37.XX.XX</host><port>9000</port><user>default</user><password></password><db>default</db><table>t_organization</table><where>id=1</where><invalidate_query>SQL_QUERY</invalidate_query></clickhouse></source><lifetime><min>31</min><max>33</max></lifetime><layout><flat></flat></layout><structure><key><attribute><name>field1</name><type>String</type></attribute></key></structure></dictionary></dictionaries>'),
  requestId?: string(name='RequestId', description='The request ID.', example='16060117-92E1-5F3B-BF42-28B172D0F869'),
}

model DescribeDBConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDBConfigResponseBody(name='body'),
}

/**
 * @summary Queries configuration information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeDBConfigResponse
 */
async function describeDBConfigWithOptions(request: DescribeDBConfigRequest, runtime: Util.RuntimeOptions): DescribeDBConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBConfig',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries configuration information about an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeDBConfigRequest
 * @return DescribeDBConfigResponse
 */
async function describeDBConfig(request: DescribeDBConfigRequest): DescribeDBConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBConfigWithOptions(request, runtime);
}

model DescribeOSSStorageRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeOSSStorageResponseBody = {
  coldStorage?: boolean(name='ColdStorage', description='Indicates whether tiered storage of hot data and cold data is supported. Valid values:

*   **true**: Tiered storage of hot data and cold data is supported.
*   **false**: Tiered storage of hot data and cold data is not supported.', example='true'),
  policy?: string(name='Policy', description='The parameters for tiered storage of hot data and cold data.', example='[{ "currentValue":"0.1", "defaultValue":"0.1", "desc":"Ratio of free disk space. When the ratio exceeds the value of configuration parameter, ClickHouse start to move data to the cold storage", "name":"move_factor", "restart":true, "valueRange":"(0, 1]" },{ "currentValue":"true", "defaultValue":"true", "desc":"Disables merging of data parts on cold storage", "name":"prefer_not_to_merge", "restart":true, "valueRange":"true|false" }]'),
  requestId?: string(name='RequestId', description='The request ID.', example='aadbb456-ebf7-4ed8-9671-fad9f3846ca4'),
  state?: string(name='State', description='The state of tiered storage of hot data and cold data. Valid values:

*   **CREATING**: Tiered storage of hot data and cold data is being enabled.
*   **DISABLE**: Tiered storage of hot data and cold data is not enabled.
*   **ENABLE**: Tiered storage of hot data and cold data is enabled.', example='ENABLE'),
  storageUsage?: string(name='StorageUsage', description='The space used for tiered storage of hot data and cold data. Unit: GB.', example='0.00'),
}

model DescribeOSSStorageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeOSSStorageResponseBody(name='body'),
}

/**
 * @summary Queries the storage of cold data.
 *
 * @param request DescribeOSSStorageRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeOSSStorageResponse
 */
async function describeOSSStorageWithOptions(request: DescribeOSSStorageRequest, runtime: Util.RuntimeOptions): DescribeOSSStorageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOSSStorage',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the storage of cold data.
 *
 * @param request DescribeOSSStorageRequest
 * @return DescribeOSSStorageResponse
 */
async function describeOSSStorage(request: DescribeOSSStorageRequest): DescribeOSSStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOSSStorageWithOptions(request, runtime);
}

model DescribeProcessListRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1190tj036am****'),
  initialQueryId?: string(name='InitialQueryId', description='The ID of the query statement.', example='6c69d508-f05f-4c74-857c-d982b7e7e79f'),
  initialUser?: string(name='InitialUser', description='The account that is used to log on to the database.', example='user'),
  keyword?: string(name='Keyword', description='The keyword that is used to query.', example='join'),
  order?: string(name='Order', description='Sorting by the specified column name. Valid values:

*   elapsed: the cumulative execution time
*   written_rows: the number of written rows
*   read_rows: the number of read rows
*   memory_usage: the memory usage', example='elapsed'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Default value: 30. Valid values:

*   **30**
*   **50**
*   **100**', example='30'),
  queryDurationMs?: int32(name='QueryDurationMs', description='The minimum query duration. The minimum value is **1000**, and the default value is **1000**. Unit: milliseconds. Queries that last longer than this duration are returned in response parameters.', example='500'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeProcessListResponseBody = {
  processList?: {
    data?: {
      resultSet?: [ 
      {
        initialAddress?: string(name='InitialAddress', description='The IP address of the client that initiates the query.', example='::ffff:10.1.XX.XX'),
        initialQueryId?: string(name='InitialQueryId', description='The query ID.', example='2dd144fd-4230-4249-b15c-e63f964fbb5a'),
        initialUser?: string(name='InitialUser', description='The database account.', example='test'),
        query?: string(name='Query', description='The SQL statement that is executed in the query.', example='select * from test order by score limit 1;'),
        queryDurationMs?: string(name='QueryDurationMs', description='The execution duration of the query. Unit: milliseconds.', example='2000'),
        queryStartTime?: string(name='QueryStartTime', description='The beginning of the time range to query. The value is in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in Coordinated Universal Time (UTC).', example='2021-02-02T09:14:48Z'),
      }
    ](name='ResultSet')
    }(name='Data', description='The details of the query.'),
    rows?: string(name='Rows', description='The number of rows returned for the query.', example='1145700'),
    rowsBeforeLimitAtLeast?: string(name='RowsBeforeLimitAtLeast', description='The number of entries returned per page.', example='1'),
    statistics?: {
      bytesRead?: int32(name='BytesRead', description='The size of the data that was scanned. Unit: bytes.', example='9141300000'),
      elapsedTime?: float(name='ElapsedTime', description='The average response time.', example='4156'),
      rowsRead?: int32(name='RowsRead', description='The number of scanned rows.', example='1000000'),
    }(name='Statistics', description='The statistics of the results.'),
    tableSchema?: {
      resultSet?: [ 
      {
        name?: string(name='Name', description='The column name.', example='InitialUser'),
        type?: string(name='Type', description='The column type.', example='String'),
      }
    ](name='ResultSet')
    }(name='TableSchema', description='Details of the columns.'),
  }(name='ProcessList', description='The queries.'),
  requestId?: string(name='RequestId', description='The request ID.', example='FD61BB0D-788A-5185-A8E3-1B90BA8F6F04'),
}

model DescribeProcessListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeProcessListResponseBody(name='body'),
}

/**
 * @summary Queries the details of queries that are being executed in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeProcessListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeProcessListResponse
 */
async function describeProcessListWithOptions(request: DescribeProcessListRequest, runtime: Util.RuntimeOptions): DescribeProcessListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.initialQueryId)) {
    query['InitialQueryId'] = request.initialQueryId;
  }
  if (!Util.isUnset(request.initialUser)) {
    query['InitialUser'] = request.initialUser;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.order)) {
    query['Order'] = request.order;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryDurationMs)) {
    query['QueryDurationMs'] = request.queryDurationMs;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeProcessList',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of queries that are being executed in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeProcessListRequest
 * @return DescribeProcessListResponse
 */
async function describeProcessList(request: DescribeProcessListRequest): DescribeProcessListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeProcessListWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    region?: [ 
    {
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      zones?: {
        zone?: [ 
        {
          vpcEnabled?: boolean(name='VpcEnabled', description='Indicates whether Virtual Private Cloud (VPC) is supported in the zone. Valid values:

*   **true**
*   **false**', example='true'),
          zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-h'),
        }
      ](name='Zone')
      }(name='Zones', description='The zones.'),
    }
  ](name='Region')
  }(name='Regions', description='The queried regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Queries the information about all regions and zones of ApsaraDB for ClickHouse clusters.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about all regions and zones of ApsaraDB for ClickHouse clusters.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeSchemasRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSchemasResponseBody = {
  items?: {
    schema?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
    }
  ](name='Schema')
  }(name='Items', description='The information about the databases of the cluster.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model DescribeSchemasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSchemasResponseBody(name='body'),
}

/**
 * @summary Queries a list of all databases in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeSchemasRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSchemasResponse
 */
async function describeSchemasWithOptions(request: DescribeSchemasRequest, runtime: Util.RuntimeOptions): DescribeSchemasResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSchemas',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of all databases in an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeSchemasRequest
 * @return DescribeSchemasResponse
 */
async function describeSchemas(request: DescribeSchemasRequest): DescribeSchemasResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSchemasWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1z58t881wcx****'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd hh:mm:ss format. The time must be in UTC.

>  The end time must be later than the start time. The specified time range that can be specified must be less than seven days.

This parameter is required.', example='2022-05-27 16:00:00'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number. Pages start from page 1. Default value: **1**.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Default value: 30. Valid values:

*   **30**
*   **50**
*   **100**', example='30'),
  queryDurationMs?: int32(name='QueryDurationMs', description='The minimum query duration. Minimum value: **1000**. Default value: **1000**. Unit: milliseconds. Queries that last longer than the specified duration are returned in response parameters.', example='1000'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-dd hh:mm:ss format. The time must be in Coordinated Universal Time (UTC).

This parameter is required.', example='2022-05-20 16:00:00'),
}

model DescribeSlowLogRecordsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='DF203CC8-5F68-5E3F-8050-3C77DD65731A'),
  slowLogRecords?: {
    data?: {
      resultSet?: [ 
      {
        initialAddress?: string(name='InitialAddress', description='The IP address of the client that initiated the query.', example='::ffff:100.104.XX.XX'),
        initialQueryId?: string(name='InitialQueryId', description='The query ID.', example='\\\\"b51496f2-6b0b-4546-aff9-e17951cb9410\\\\"'),
        initialUser?: string(name='InitialUser', description='The username that is used to initiate the query.', example='test_users'),
        memoryUsage?: string(name='MemoryUsage', description='The peak memory usage for the query. Unit: bytes.', example='1048576'),
        query?: string(name='Query', description='The statement that was executed in the query.', example='Select * from table'),
        queryDurationMs?: string(name='QueryDurationMs', description='The duration of the query. Unit: milliseconds.', example='2000'),
        queryStartTime?: string(name='QueryStartTime', description='The beginning of the time range to query. The time is in the yyyy-MM-dd hh:mm:ss format. The time is displayed in UTC.', example='2022-05-22 20:00:01'),
        readBytes?: string(name='ReadBytes', description='The size of the data read by executing the statement. Unit: bytes.', example='1048576'),
        readRows?: string(name='ReadRows', description='The number of rows read by executing the statement.', example='10027008'),
        resultBytes?: string(name='ResultBytes', description='The size of the result data. Unit: bytes.', example='1024'),
        type?: string(name='Type', description='The query status. Valid values:

*   **QueryFinish**: The query is complete.
*   **Processing**: The query is running.', example='QueryFinish'),
      }
    ](name='ResultSet')
    }(name='Data', description='Details about the slow query logs.'),
    rows?: string(name='Rows', description='The number of rows in the result set.', example='1'),
    rowsBeforeLimitAtLeast?: string(name='RowsBeforeLimitAtLeast', description='The number of entries per page.', example='1'),
    statistics?: {
      bytesRead?: int32(name='BytesRead', description='The total size of data that were read. Unit: bytes.', example='123456'),
      elapsedTime?: float(name='ElapsedTime', description='The time consumed by the slow query. Unit: milliseconds.', example='21.35'),
      rowsRead?: int32(name='RowsRead', description='The total number of rows that were read.', example='2016722'),
    }(name='Statistics', description='The statistics of the results.'),
    tableSchema?: {
      resultSet?: [ 
      {
        name?: string(name='Name', description='The name of the column.', example='name'),
        type?: string(name='Type', description='The type of the column.', example='String'),
      }
    ](name='ResultSet')
    }(name='TableSchema', description='The schema of the table in the database.'),
  }(name='SlowLogRecords', description='The details about the slow query logs.'),
}

model DescribeSlowLogRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSlowLogRecordsResponseBody(name='body'),
}

/**
 * @summary Queries the details about slow query logs.
 *
 * @param request DescribeSlowLogRecordsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryDurationMs)) {
    query['QueryDurationMs'] = request.queryDurationMs;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogRecords',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details about slow query logs.
 *
 * @param request DescribeSlowLogRecordsRequest
 * @return DescribeSlowLogRecordsResponse
 */
async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeSynDbTablesRequest {
  dbClusterId?: string(name='DbClusterId', description='The ID of the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp158i5wvj436****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  synDb?: string(name='SynDb', description='The name of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='database'),
}

model DescribeSynDbTablesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='851D11EA-681C-5B38-A065-C3F90BBD49DE'),
  tables?: [ string ](name='Tables', description='The queried tables.'),
}

model DescribeSynDbTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSynDbTablesResponseBody(name='body'),
}

/**
 * @summary Queries information about tables that are synchronized from an ApsaraDB RDS for MySQL instance to an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeSynDbTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSynDbTablesResponse
 */
async function describeSynDbTablesWithOptions(request: DescribeSynDbTablesRequest, runtime: Util.RuntimeOptions): DescribeSynDbTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.synDb)) {
    query['SynDb'] = request.synDb;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSynDbTables',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about tables that are synchronized from an ApsaraDB RDS for MySQL instance to an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeSynDbTablesRequest
 * @return DescribeSynDbTablesResponse
 */
async function describeSynDbTables(request: DescribeSynDbTablesRequest): DescribeSynDbTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSynDbTablesWithOptions(request, runtime);
}

model DescribeSynDbsRequest {
  dbClusterId?: string(name='DbClusterId', description='The ID of the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp1ab22b80814****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSynDbsResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='7655F5F9-1313-5ABA-8516-F6EB79605A5F'),
  synDbs?: [ 
    {
      errorMsg?: string(name='ErrorMsg', description='*   When the value **true** is returned for the **SynStatus** parameter, the system does not return the ErrorMsg parameter.
*   When the value **false** is returned for the **SynStatus** parameter, the system returns for the ErrorMsg parameter the cause why the data synchronization failed.', example='ClickHouse exception, code: 49, host: 100.100.118.132, port: 49670; Code: 49, e.displayText() = DB::Exception: Logical error: there is no global context (version 20.8.17.25)n'),
      rdsId?: string(name='RdsId', description='The ID of the ApsaraDB RDS for MySQL instance.', example='rm-wz9d11qg1j0h4****'),
      rdsUserName?: string(name='RdsUserName', description='The database account that is used to log on to the ApsaraDB RDS for MySQL instance.', example='test'),
      rdsVpcUrl?: string(name='RdsVpcUrl', description='The internal endpoint of the ApsaraDB RDS for MySQL instance.', example='rm-bp16t9h3999xb0a711****.mysql.rds.aliyuncs.com:3306'),
      synDb?: string(name='SynDb', description='The name of the database in the ApsaraDB RDS for MySQL instance.', example='database'),
      synStatus?: boolean(name='SynStatus', description='Indicates whether the data synchronization succeeded. Valid values:

*   **true**: The data synchronization succeeded.
*   **false**: The data synchronization failed.', example='true'),
    }
  ](name='SynDbs', description='The information about data synchronization between the ApsaraDB for ClickHouse cluster and an ApsaraDB RDS for MySQL instance.'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='0'),
}

model DescribeSynDbsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeSynDbsResponseBody(name='body'),
}

/**
 * @summary Queries the information about data synchronization between an ApsaraDB for ClickHouse cluster and an ApsaraDB RDS for MySQL instance.
 *
 * @param request DescribeSynDbsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeSynDbsResponse
 */
async function describeSynDbsWithOptions(request: DescribeSynDbsRequest, runtime: Util.RuntimeOptions): DescribeSynDbsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSynDbs',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about data synchronization between an ApsaraDB for ClickHouse cluster and an ApsaraDB RDS for MySQL instance.
 *
 * @param request DescribeSynDbsRequest
 * @return DescribeSynDbsResponse
 */
async function describeSynDbs(request: DescribeSynDbsRequest): DescribeSynDbsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSynDbsWithOptions(request, runtime);
}

model DescribeTablesRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  schemaName?: string(name='SchemaName', description='The database name.

This parameter is required.', example='database'),
}

model DescribeTablesResponseBody = {
  items?: {
    table?: [ 
    {
      DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp108z124a8o7****'),
      schemaName?: string(name='SchemaName', description='The database name.', example='database'),
      tableName?: string(name='TableName', description='The table name.', example='test'),
    }
  ](name='Table')
  }(name='Items', description='The information about the tables.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model DescribeTablesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTablesResponseBody(name='body'),
}

/**
 * @summary Queries the information about tables in a database of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeTablesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTablesResponse
 */
async function describeTablesWithOptions(request: DescribeTablesRequest, runtime: Util.RuntimeOptions): DescribeTablesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.schemaName)) {
    query['SchemaName'] = request.schemaName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTables',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about tables in a database of an ApsaraDB for ClickHouse cluster.
 *
 * @param request DescribeTablesRequest
 * @return DescribeTablesResponse
 */
async function describeTables(request: DescribeTablesRequest): DescribeTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTablesWithOptions(request, runtime);
}

model DescribeTransferHistoryRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeTransferHistoryResponseBody = {
  historyDetails?: {
    historyDetail?: [ 
    {
      bytesPerMinute?: long(name='BytesPerMinute', description='The amount of data that is migrated per minute.', example='10240'),
      disableWriteWindows?: string(name='DisableWriteWindows', description='The time window during which write operations are stopped.', example='2025-02-08T00:00:00+08:00,2025-02-12T00:00:00+08:00', nullable=false),
      partsPerMinute?: double(name='PartsPerMinute', description='The number of parts that are migrated per minute.', example='1.24'),
      progress?: string(name='Progress', description='The progress of the data migration.', example='100%'),
      sourceControlVersion?: string(name='SourceControlVersion', description='The control version of the source cluster.', example='v1'),
      sourceDBCluster?: string(name='SourceDBCluster', description='The ID of the source cluster.', example='cc-bp108z124a8o7****'),
      status?: string(name='Status', description='The status of the data migration task. Valid values:

*   **Finished**: The data migration task is complete.
*   **Processing**: The data migration task is in progress.', example='Finished'),
      subJob?: string(name='SubJob', description='The running subtask.', example='SubJob'),
      subJobStatus?: string(name='SubJobStatus', description='The subtask status.', example='running'),
      targetControlVersion?: string(name='TargetControlVersion', description='The control version of the destination cluster.', example='v2'),
      targetDBCluster?: string(name='TargetDBCluster', description='The ID of the destination cluster.', example='cc-bp13zkh9uw523****'),
      unsyncedBytes?: long(name='UnsyncedBytes', description='The amount of data that is not migrated.', example='102400'),
      unsyncedParts?: long(name='UnsyncedParts', description='The number of parts that are not migrated.', example='1000'),
    }
  ](name='HistoryDetail')
  }(name='HistoryDetails', description='The migration information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model DescribeTransferHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeTransferHistoryResponseBody(name='body'),
}

/**
 * @summary Queries information about data migration from an ApsaraDB for ClickHouse cluster of an earlier version to an ApsaraDB for ClickHouse cluster of a later version
 *
 * @description >  You can call this operation to query information about only data migration from an ApsaraDB for ClickHouse cluster of an earlier version to an ApsaraDB for ClickHouse cluster of a later version.
 *
 * @param request DescribeTransferHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeTransferHistoryResponse
 */
async function describeTransferHistoryWithOptions(request: DescribeTransferHistoryRequest, runtime: Util.RuntimeOptions): DescribeTransferHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTransferHistory',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries information about data migration from an ApsaraDB for ClickHouse cluster of an earlier version to an ApsaraDB for ClickHouse cluster of a later version
 *
 * @description >  You can call this operation to query information about only data migration from an ApsaraDB for ClickHouse cluster of an earlier version to an ApsaraDB for ClickHouse cluster of a later version.
 *
 * @param request DescribeTransferHistoryRequest
 * @return DescribeTransferHistoryResponse
 */
async function describeTransferHistory(request: DescribeTransferHistoryRequest): DescribeTransferHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTransferHistoryWithOptions(request, runtime);
}

model KillProcessRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  initialQueryId?: string(name='InitialQueryId', description='The query statement or query statements that you want to stop executing. If you want to stop executing multiple query statements, separate the statements with commas (,).

>  If you do not set this parameter, all query statements are stopped by default.', example='SELECT * FROM `test01` ;'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model KillProcessResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model KillProcessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: KillProcessResponseBody(name='body'),
}

/**
 * @summary Terminates an ongoing task.
 *
 * @param request KillProcessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return KillProcessResponse
 */
async function killProcessWithOptions(request: KillProcessRequest, runtime: Util.RuntimeOptions): KillProcessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.initialQueryId)) {
    query['InitialQueryId'] = request.initialQueryId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'KillProcess',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Terminates an ongoing task.
 *
 * @param request KillProcessRequest
 * @return KillProcessResponse
 */
async function killProcess(request: KillProcessRequest): KillProcessResponse {
  var runtime = new Util.RuntimeOptions{};
  return killProcessWithOptions(request, runtime);
}

model ModifyAccountAuthorityRequest {
  accountName?: string(name='AccountName', description='The name of the database account.

This parameter is required.', example='test'),
  allowDatabases?: string(name='AllowDatabases', description='The databases to which you want to grant permissions. Separate databases with commas (,).

This parameter is required.', example='db1'),
  allowDictionaries?: string(name='AllowDictionaries', description='The dictionaries to which you want to grant permissions. Separate dictionaries with commas (,).

This parameter is required.', example='dt1'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ddlAuthority?: boolean(name='DdlAuthority', description='Specifies whether to grant DDL permissions to the database account. Valid values:

*   **true**: grants DDL permissions to the database account.
*   **false**: does not grant DDL permissions to the database account.

This parameter is required.', example='true'),
  dmlAuthority?: string(name='DmlAuthority', description='Specifies whether to grant DML permissions to the database account. Valid values:

*   **all**
*   **readonly,modify**

This parameter is required.', example='all'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  totalDatabases?: string(name='TotalDatabases', description='All databases. Separate databases with commas (,).', example='db1,db2'),
  totalDictionaries?: string(name='TotalDictionaries', description='All dictionaries. Separate dictionaries with commas (,).', example='dt1,dt2'),
}

model ModifyAccountAuthorityResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model ModifyAccountAuthorityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountAuthorityResponseBody(name='body'),
}

/**
 * @summary Modifies the permissions of an account.
 *
 * @param request ModifyAccountAuthorityRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountAuthorityResponse
 */
async function modifyAccountAuthorityWithOptions(request: ModifyAccountAuthorityRequest, runtime: Util.RuntimeOptions): ModifyAccountAuthorityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.allowDatabases)) {
    query['AllowDatabases'] = request.allowDatabases;
  }
  if (!Util.isUnset(request.allowDictionaries)) {
    query['AllowDictionaries'] = request.allowDictionaries;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ddlAuthority)) {
    query['DdlAuthority'] = request.ddlAuthority;
  }
  if (!Util.isUnset(request.dmlAuthority)) {
    query['DmlAuthority'] = request.dmlAuthority;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.totalDatabases)) {
    query['TotalDatabases'] = request.totalDatabases;
  }
  if (!Util.isUnset(request.totalDictionaries)) {
    query['TotalDictionaries'] = request.totalDictionaries;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountAuthority',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the permissions of an account.
 *
 * @param request ModifyAccountAuthorityRequest
 * @return ModifyAccountAuthorityResponse
 */
async function modifyAccountAuthority(request: ModifyAccountAuthorityRequest): ModifyAccountAuthorityResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountAuthorityWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest {
  accountDescription?: string(name='AccountDescription', description='The new description of the database account.

*   The value cannot start with http:// or https://.
*   The value must be 0 to 256 characters in length.

This parameter is required.', example='ceshi'),
  accountName?: string(name='AccountName', description='The name of the database account.

This parameter is required.', example='test'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627FA5A19'),
}

model ModifyAccountDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyAccountDescriptionResponseBody(name='body'),
}

/**
 * @summary Modifies the description of a database account of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyAccountDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyAccountDescriptionResponse
 */
async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescription',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the description of a database account of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyAccountDescriptionRequest
 * @return ModifyAccountDescriptionResponse
 */
async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  backupRetentionPeriod?: string(name='BackupRetentionPeriod', description='The retention period for the backup data. Valid values: 7 to 730. Unit: days.', example='7'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', description='The day of a week when the system regularly backs up data. If you specify multiple days of a week, separate them with commas (,). Valid values:

*   **Monday**
*   **Tuesday**
*   **Wednesday**
*   **Thursday**
*   **Friday**
*   **Saturday**
*   **Sunday**

This parameter is required.', example='Monday'),
  preferredBackupTime?: string(name='PreferredBackupTime', description='The backup window. Specify the time in the ISO 8601 standard in the HH:mmZ-HH:mmZ format. The time must be in Coordinated Universal Time (UTC).

For example, if you set the backup window to 00:00Z-01:00Z, the data of the cluster can be backed up from 08:00 (UTC+8) to 09:00 (UTC+8).

This parameter is required.', example='15:00Z-16:00Z'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBackupPolicyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model ModifyBackupPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyBackupPolicyResponseBody(name='body'),
}

/**
 * @summary Modifies the backup settings of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request ModifyBackupPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupRetentionPeriod)) {
    query['BackupRetentionPeriod'] = request.backupRetentionPeriod;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the backup settings of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is available only for the ApsaraDB for ClickHouse clusters of versions 20.3, 20.8, and 21.8.
 *
 * @param request ModifyBackupPolicyRequest
 * @return ModifyBackupPolicyResponse
 */
async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyDBClusterRequest {
  DBClusterClass?: string(name='DBClusterClass', description='The specifications of the cluster.

*   Valid values when the cluster is of Single-replica Edition:

    *   **S8**
    *   **S16**
    *   **S32**
    *   **S64**
    *   **S104**

*   Valid values when the cluster is of Double-replica Edition:

    *   **C8**
    *   **C16**
    *   **C32**
    *   **C64**
    *   **C104**

This parameter is required.', example='S4-NEW'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.', example='cc-bp19lo45sy98x****'),
  DBNodeGroupCount?: string(name='DBNodeGroupCount', description='The number of nodes in the cluster.

*   If the cluster is of Single-replica Edition, the value must be an integer that ranges from 1 to 48.
*   If the cluster is of Double-replica Edition, the value must be an integer that ranges from 1 to 24.

This parameter is required.', example='1'),
  DBNodeStorage?: string(name='DBNodeStorage', description='The storage capacity of a single node of the cluster. Unit: GB.

Valid values: 100 to 32000.

>  This value is a multiple of 100.

This parameter is required.', example='100'),
  dbNodeStorageType?: string(name='DbNodeStorageType', description='The storage type of the cluster. Valid values:

*   **CloudESSD**: The cluster uses an Enterprise SSD (ESSD) of performance level 1 (PL1).
*   **CloudESSD_PL2**: The cluster uses an ESSD of PL2.
*   **CloudESSD_PL3**: The cluster uses an ESSD of PL3.
*   **CloudEfficiency**: The cluster uses an ultra disk.
*   **CloudSSD**: The cluster uses a standard SSD.', example='CloudESSD'),
  disableWriteWindows?: string(name='DisableWriteWindows', description='The time window during which write operations are stopped. Separate the start time and end time with commas (,). Specify the time in the ISO 8601 standard.', example='2024-07-09T20:00:00+08:00,2024-07-09T21:00:00+08:00'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterResponseBody = {
  DBCluster?: {
    dbClusterId?: string(name='dbClusterId', description='The cluster ID.', example='cc-bp19lo45sy98x****'),
    orderId?: string(name='orderId', description='The order ID.', example='21417210003****'),
  }(name='DBCluster', description='The clusters.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BA30A000-3A4D-5B97-9420-E5D0D49F7016'),
}

model ModifyDBClusterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterResponseBody(name='body'),
}

/**
 * @summary Upgrades or downgrades an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterResponse
 */
async function modifyDBClusterWithOptions(request: ModifyDBClusterRequest, runtime: Util.RuntimeOptions): ModifyDBClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterClass)) {
    query['DBClusterClass'] = request.DBClusterClass;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.DBNodeGroupCount)) {
    query['DBNodeGroupCount'] = request.DBNodeGroupCount;
  }
  if (!Util.isUnset(request.DBNodeStorage)) {
    query['DBNodeStorage'] = request.DBNodeStorage;
  }
  if (!Util.isUnset(request.dbNodeStorageType)) {
    query['DbNodeStorageType'] = request.dbNodeStorageType;
  }
  if (!Util.isUnset(request.disableWriteWindows)) {
    query['DisableWriteWindows'] = request.disableWriteWindows;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBCluster',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Upgrades or downgrades an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterRequest
 * @return ModifyDBClusterResponse
 */
async function modifyDBCluster(request: ModifyDBClusterRequest): ModifyDBClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterWithOptions(request, runtime);
}

model ModifyDBClusterAccessWhiteListRequest {
  DBClusterIPArrayAttribute?: string(name='DBClusterIPArrayAttribute', description='The attribute of the IP address whitelist. By default, this parameter is **empty**.', example='NULL'),
  DBClusterIPArrayName?: string(name='DBClusterIPArrayName', description='The name of the IP address whitelist that you want to modify.

>  If you do not specify this parameter, the default IP address whitelist is modified.', example='default'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  modifyMode?: string(name='ModifyMode', description='The method that is used to modify the IP address whitelist. Valid values:

*   **Cover**: overwrites the original IP address whitelist.
*   **Append**: appends the specified IP addresses to the original IP address whitelist.
*   **Delete**: deletes the original IP address whitelist.

>  If you do not specify this parameter, the default value of Cover is used.', example='Cover'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIps?: string(name='SecurityIps', description='The IP addresses in the IP address whitelist. You can specify IP addresses in the following formats:

*   IP address. For example, you can set SecurityIps to 192.168.0.1. This allows you to use this IP address to access your ApsaraDB for ClickHouse cluster.
*   CIDR block. For example, you can set SecurityIps to 192.168.0.0/24. This allows you to use the IP addresses from 192.168.0.1 to 192.168.0.255 to access your ApsaraDB for ClickHouse cluster.

> 

*   Do not set SecurityIps to 0.0.0.0.

*   If you set SecurityIps to 127.0.0.1, all IP addresses are blocked from accessing your ApsaraDB for ClickHouse cluster.

This parameter is required.', example='192.168.xx.xx'),
}

model ModifyDBClusterAccessWhiteListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model ModifyDBClusterAccessWhiteListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterAccessWhiteListResponseBody(name='body'),
}

/**
 * @summary Modifies the IP address whitelist of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterAccessWhiteListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterAccessWhiteListResponse
 */
async function modifyDBClusterAccessWhiteListWithOptions(request: ModifyDBClusterAccessWhiteListRequest, runtime: Util.RuntimeOptions): ModifyDBClusterAccessWhiteListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterIPArrayAttribute)) {
    query['DBClusterIPArrayAttribute'] = request.DBClusterIPArrayAttribute;
  }
  if (!Util.isUnset(request.DBClusterIPArrayName)) {
    query['DBClusterIPArrayName'] = request.DBClusterIPArrayName;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIps)) {
    query['SecurityIps'] = request.securityIps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterAccessWhiteList',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the IP address whitelist of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterAccessWhiteListRequest
 * @return ModifyDBClusterAccessWhiteListResponse
 */
async function modifyDBClusterAccessWhiteList(request: ModifyDBClusterAccessWhiteListRequest): ModifyDBClusterAccessWhiteListResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterAccessWhiteListWithOptions(request, runtime);
}

model ModifyDBClusterConfigRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp1t9lbb7a4z7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  reason?: string(name='Reason', description='The reason for the change.', example='test'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  userConfig?: string(name='UserConfig', description='The names of the parameters and the new values that you want to specify for the parameters.

>  You can change the value of a single parameter. The values of parameters that are not specified will not be changed.

This parameter is required.', example='{"keep_alive_timeout":"301"}'),
}

model ModifyDBClusterConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A9AA1E0A-2AEE-5847-87CF-E4FDC0E66052'),
}

model ModifyDBClusterConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the configurations of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterConfigResponse
 */
async function modifyDBClusterConfigWithOptions(request: ModifyDBClusterConfigRequest, runtime: Util.RuntimeOptions): ModifyDBClusterConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.userConfig)) {
    query['UserConfig'] = request.userConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterConfig',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the configurations of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterConfigRequest
 * @return ModifyDBClusterConfigResponse
 */
async function modifyDBClusterConfig(request: ModifyDBClusterConfigRequest): ModifyDBClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterConfigWithOptions(request, runtime);
}

model ModifyDBClusterConfigInXMLRequest {
  config?: string(name='Config', description='The configuration parameters whose settings you want to modify. You can call the [DescribeDBClusterConfigInXML](https://help.aliyun.com/document_detail/452210.html) operation to query configuration parameters, and modify the settings of the returned configuration parameters.

> You must specify all configuration parameters even when you want to modify the setting of a single parameter. If a configuration parameter is not specified, the original value of this parameter is retained or the modification fails.

This parameter is required.', example='<?xml version="1.0"?>
<yandex>
    <keep_alive_timeout>400</keep_alive_timeout>
    <listen_backlog>4096</listen_backlog>
    <logger>
        <level>debug</level>
        <size>1000M</size>
    </logger>
    <mark_cache_size>5368709120</mark_cache_size>
    <max_concurrent_queries>201</max_concurrent_queries>
    <max_connections>4096</max_connections>
    <max_partition_size_to_drop>0</max_partition_size_to_drop>
    <max_table_size_to_drop>0</max_table_size_to_drop>
    <merge_tree>
        <max_delay_to_insert>256</max_delay_to_insert>
        <max_part_loading_threads>auto</max_part_loading_threads>
        <max_suspicious_broken_parts>100</max_suspicious_broken_parts>
        <zookeeper_session_expiration_check_period>1</zookeeper_session_expiration_check_period>
    </merge_tree>
    <uncompressed_cache_size>1717986918</uncompressed_cache_size>
</yandex>'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specified region, including the cluster IDs.

This parameter is required.', example='cc-bp108z124a8o7****'),
  reason?: string(name='Reason', description='The reason for the modification.', example='test'),
  regionId?: string(name='RegionId', description='The region ID of the cluster. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
}

model ModifyDBClusterConfigInXMLResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BDD29EB1-BE76-5CFA-9068-D34B696310BF'),
}

model ModifyDBClusterConfigInXMLResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterConfigInXMLResponseBody(name='body'),
}

/**
 * @summary Changes the configuration parameters of an ApsaraDB for ClickHouse cluster that runs Community-compatible Edition.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request ModifyDBClusterConfigInXMLRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterConfigInXMLResponse
 */
async function modifyDBClusterConfigInXMLWithOptions(request: ModifyDBClusterConfigInXMLRequest, runtime: Util.RuntimeOptions): ModifyDBClusterConfigInXMLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.reason)) {
    query['Reason'] = request.reason;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterConfigInXML',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the configuration parameters of an ApsaraDB for ClickHouse cluster that runs Community-compatible Edition.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were created after December 1, 2021.
 *
 * @param request ModifyDBClusterConfigInXMLRequest
 * @return ModifyDBClusterConfigInXMLResponse
 */
async function modifyDBClusterConfigInXML(request: ModifyDBClusterConfigInXMLRequest): ModifyDBClusterConfigInXMLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterConfigInXMLWithOptions(request, runtime);
}

model ModifyDBClusterDescriptionRequest {
  DBClusterDescription?: string(name='DBClusterDescription', description='The cluster name. When you set the cluster name, take note of the following rules:

*   The cluster name cannot start with http:// or https://.
*   The cluster name must be 2 to 256 characters in length.

This parameter is required.', example='ClusterDescriptionTest'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterDescriptionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model ModifyDBClusterDescriptionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterDescriptionResponseBody(name='body'),
}

/**
 * @summary Changes the name of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterDescriptionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterDescriptionResponse
 */
async function modifyDBClusterDescriptionWithOptions(request: ModifyDBClusterDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBClusterDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterDescription)) {
    query['DBClusterDescription'] = request.DBClusterDescription;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterDescription',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Changes the name of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterDescriptionRequest
 * @return ModifyDBClusterDescriptionResponse
 */
async function modifyDBClusterDescription(request: ModifyDBClusterDescriptionRequest): ModifyDBClusterDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterDescriptionWithOptions(request, runtime);
}

model ModifyDBClusterMaintainTimeRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  maintainTime?: string(name='MaintainTime', description='The maintenance window of the cluster. Specify the time in the HH:mmZ-HH:mmZ format. The time must be in Coordinated Universal Time (UTC).

For example, a value of 00:00Z-01:00Z indicates that routine maintenance can be performed on the cluster from 08:00 (UTC+8) to 09:00 (UTC+8).

>  You can set the start time and end time of the maintenance window to the time on the hour, and the maintenance window is 1 hour.

This parameter is required.', example='00:00Z-01:00Z'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBClusterMaintainTimeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05321590-BB65-4720-8CB6-8218E041CDD0'),
}

model ModifyDBClusterMaintainTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBClusterMaintainTimeResponseBody(name='body'),
}

/**
 * @summary Modifies the maintenance window of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterMaintainTimeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTimeWithOptions(request: ModifyDBClusterMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBClusterMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maintainTime)) {
    query['MaintainTime'] = request.maintainTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBClusterMaintainTime',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the maintenance window of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBClusterMaintainTimeRequest
 * @return ModifyDBClusterMaintainTimeResponse
 */
async function modifyDBClusterMaintainTime(request: ModifyDBClusterMaintainTimeRequest): ModifyDBClusterMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBClusterMaintainTimeWithOptions(request, runtime);
}

model ModifyDBConfigRequest {
  config?: string(name='Config', description='The dictionary configuration.', example='{"name":"test"}'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1r59y779o04****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BF3844B6-1B12-57A0-A259-476D2079EE83'),
}

model ModifyDBConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyDBConfigResponseBody(name='body'),
}

/**
 * @summary Modifies the dictionary configuration of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBConfigRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyDBConfigResponse
 */
async function modifyDBConfigWithOptions(request: ModifyDBConfigRequest, runtime: Util.RuntimeOptions): ModifyDBConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.config)) {
    query['Config'] = request.config;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBConfig',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the dictionary configuration of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ModifyDBConfigRequest
 * @return ModifyDBConfigResponse
 */
async function modifyDBConfig(request: ModifyDBConfigRequest): ModifyDBConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBConfigWithOptions(request, runtime);
}

model ModifyMinorVersionGreadeTypeRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp1qx68m06981****'),
  maintainAutoType?: boolean(name='MaintainAutoType', description='The update type. If you set the parameter to **false**, you perform the manual update.

This parameter is required.', example='false'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyMinorVersionGreadeTypeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model ModifyMinorVersionGreadeTypeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyMinorVersionGreadeTypeResponseBody(name='body'),
}

/**
 * @summary Modifies the type of a minor version update in ApsaraDB for ClickHouse.
 *
 * @param request ModifyMinorVersionGreadeTypeRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyMinorVersionGreadeTypeResponse
 */
async function modifyMinorVersionGreadeTypeWithOptions(request: ModifyMinorVersionGreadeTypeRequest, runtime: Util.RuntimeOptions): ModifyMinorVersionGreadeTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.maintainAutoType)) {
    query['MaintainAutoType'] = request.maintainAutoType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyMinorVersionGreadeType',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the type of a minor version update in ApsaraDB for ClickHouse.
 *
 * @param request ModifyMinorVersionGreadeTypeRequest
 * @return ModifyMinorVersionGreadeTypeResponse
 */
async function modifyMinorVersionGreadeType(request: ModifyMinorVersionGreadeTypeRequest): ModifyMinorVersionGreadeTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyMinorVersionGreadeTypeWithOptions(request, runtime);
}

model ModifyRDSToClickhouseDbRequest {
  ckPassword?: string(name='CkPassword', description='The password of the account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='123456Aa'),
  ckUserName?: string(name='CkUserName', description='The account that is used to log on to the database in the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='user1'),
  clickhousePort?: long(name='ClickhousePort', description='The port number of the ApsaraDB for ClickHouse cluster.', example='8123'),
  dbClusterId?: string(name='DbClusterId', description='The ID of the ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp158i5wvj436****'),
  limitUpper?: long(name='LimitUpper', description='The maximum number of rows that can be synchronized per second.', example='50000'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  rdsId?: string(name='RdsId', description='The ID of the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='rm-uf6x3qq4t90ok****'),
  rdsPassword?: string(name='RdsPassword', description='The password of the account that is used to log on to the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='123456Rr'),
  rdsPort?: long(name='RdsPort', description='The port number of the ApsaraDB RDS for MySQL instance.', example='3306'),
  rdsSynDb?: string(name='RdsSynDb', description='The database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='database'),
  rdsSynTables?: string(name='RdsSynTables', description='The table in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='table'),
  rdsUserName?: string(name='RdsUserName', description='The account that is used to log on to the database in the ApsaraDB RDS for MySQL instance.

This parameter is required.', example='user2'),
  rdsVpcId?: string(name='RdsVpcId', description='The ID of the virtual private cloud (VPC) to which the ApsaraDB RDS for MySQL instance belongs.', example='vpc-bp1v9dtwmqqjhwwg****'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  skipUnsupported?: boolean(name='SkipUnsupported', description='Specifies whether to ignore databases that do not support synchronization. Valid values:

*   **true**
*   **false**

This parameter is required.', example='true'),
}

model ModifyRDSToClickhouseDbResponseBody = {
  errorCode?: long(name='ErrorCode', description='The error code.', example='0'),
  errorMsg?: string(name='ErrorMsg', description='*   If the value **1** is returned for the **Status** parameter, the system does not return the ErrorMsg parameter.
*   If the value **0** is returned for the **Status** parameter, the ErrorMsg parameter returns the cause for the modification failure.', example='ClickHouse exception, code: 49, host: 100.100.118.132, port: 49670; Code: 49, e.displayText() = DB::Exception: Logical error: there is no global context (version 20.8.17.25)n'),
  requestId?: string(name='RequestId', description='The request ID.', example='746CD303-0B82-5E8D-886D-93A9FAF3A876'),
  status?: long(name='Status', description='Indicates whether the modification was successful. Valid values:

*   **1**: The modification was successful.
*   **0**: The modification failed.', example='1'),
}

model ModifyRDSToClickhouseDbResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyRDSToClickhouseDbResponseBody(name='body'),
}

/**
 * @summary Modifies the synchronization task of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is applicable only to ApsaraDB for ClickHouse clusters.
 *
 * @param request ModifyRDSToClickhouseDbRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ModifyRDSToClickhouseDbResponse
 */
async function modifyRDSToClickhouseDbWithOptions(request: ModifyRDSToClickhouseDbRequest, runtime: Util.RuntimeOptions): ModifyRDSToClickhouseDbResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ckPassword)) {
    query['CkPassword'] = request.ckPassword;
  }
  if (!Util.isUnset(request.ckUserName)) {
    query['CkUserName'] = request.ckUserName;
  }
  if (!Util.isUnset(request.clickhousePort)) {
    query['ClickhousePort'] = request.clickhousePort;
  }
  if (!Util.isUnset(request.dbClusterId)) {
    query['DbClusterId'] = request.dbClusterId;
  }
  if (!Util.isUnset(request.limitUpper)) {
    query['LimitUpper'] = request.limitUpper;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.rdsId)) {
    query['RdsId'] = request.rdsId;
  }
  if (!Util.isUnset(request.rdsPassword)) {
    query['RdsPassword'] = request.rdsPassword;
  }
  if (!Util.isUnset(request.rdsPort)) {
    query['RdsPort'] = request.rdsPort;
  }
  if (!Util.isUnset(request.rdsSynDb)) {
    query['RdsSynDb'] = request.rdsSynDb;
  }
  if (!Util.isUnset(request.rdsSynTables)) {
    query['RdsSynTables'] = request.rdsSynTables;
  }
  if (!Util.isUnset(request.rdsUserName)) {
    query['RdsUserName'] = request.rdsUserName;
  }
  if (!Util.isUnset(request.rdsVpcId)) {
    query['RdsVpcId'] = request.rdsVpcId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.skipUnsupported)) {
    query['SkipUnsupported'] = request.skipUnsupported;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyRDSToClickhouseDb',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the synchronization task of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  This operation is applicable only to ApsaraDB for ClickHouse clusters.
 *
 * @param request ModifyRDSToClickhouseDbRequest
 * @return ModifyRDSToClickhouseDbResponse
 */
async function modifyRDSToClickhouseDb(request: ModifyRDSToClickhouseDbRequest): ModifyRDSToClickhouseDbResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyRDSToClickhouseDbWithOptions(request, runtime);
}

model ReleaseClusterPublicConnectionRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseClusterPublicConnectionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='D0CEC6AC-7760-409A-A0D5-E6CD8660E9CC'),
}

model ReleaseClusterPublicConnectionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReleaseClusterPublicConnectionResponseBody(name='body'),
}

/**
 * @summary Releases the public endpoint of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ReleaseClusterPublicConnectionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReleaseClusterPublicConnectionResponse
 */
async function releaseClusterPublicConnectionWithOptions(request: ReleaseClusterPublicConnectionRequest, runtime: Util.RuntimeOptions): ReleaseClusterPublicConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseClusterPublicConnection',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Releases the public endpoint of an ApsaraDB for ClickHouse cluster.
 *
 * @param request ReleaseClusterPublicConnectionRequest
 * @return ReleaseClusterPublicConnectionResponse
 */
async function releaseClusterPublicConnection(request: ReleaseClusterPublicConnectionRequest): ReleaseClusterPublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseClusterPublicConnectionWithOptions(request, runtime);
}

model ResetAccountPasswordRequest {
  accountName?: string(name='AccountName', description='The name of the database account.

This parameter is required.', example='test'),
  accountPassword?: string(name='AccountPassword', description='The new password for the database account.

> 

*   The password must contain at least three types of the following characters: uppercase letters, lowercase letters, digits, and special characters.

*   The password can contain the following special characters: ! @ # $ % ^ & \\\\* ( ) _ + - =
*   The password must be 8 to 32 characters in length.

This parameter is required.', example='123456Ff'),
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='2FED790E-FB61-4721-8C1C-07C627FA5A19'),
}

model ResetAccountPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAccountPasswordResponseBody(name='body'),
}

/**
 * @summary Resets the password of a database account for an ApsaraDB for ClickHouse cluster.
 *
 * @param request ResetAccountPasswordRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ResetAccountPasswordResponse
 */
async function resetAccountPasswordWithOptions(request: ResetAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccountPassword',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Resets the password of a database account for an ApsaraDB for ClickHouse cluster.
 *
 * @param request ResetAccountPasswordRequest
 * @return ResetAccountPasswordResponse
 */
async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountPasswordWithOptions(request, runtime);
}

model RestartInstanceRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID. You can call the [DescribeDBClusters](https://help.aliyun.com/document_detail/170879.html) operation to query information about all the clusters that are deployed in a specific region. The information includes the cluster IDs.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The number of pages to return.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return per page. Default value: 30. Valid values:

*   30
*   50
*   100', example='30'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restartTime?: string(name='RestartTime', description='The scheduled restart time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in Coordinated Universal Time (UTC).

>  If this parameter is left empty or the time specified by this parameter is earlier than the current time, the cluster is immediately restarted.', example='2023-03-22T00:00:50Z'),
}

model RestartInstanceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F5178C10-1407-4987-9133-DE4DC9119F75'),
}

model RestartInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartInstanceResponseBody(name='body'),
}

/**
 * @summary Restarts an ApsaraDB for ClickHouse cluster.
 *
 * @param request RestartInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RestartInstanceResponse
 */
async function restartInstanceWithOptions(request: RestartInstanceRequest, runtime: Util.RuntimeOptions): RestartInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restartTime)) {
    query['RestartTime'] = request.restartTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartInstance',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Restarts an ApsaraDB for ClickHouse cluster.
 *
 * @param request RestartInstanceRequest
 * @return RestartInstanceResponse
 */
async function restartInstance(request: RestartInstanceRequest): RestartInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartInstanceWithOptions(request, runtime);
}

model TransferVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The ID of the source ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp1tm8zf130ew****'),
  disableWriteWindows?: string(name='DisableWriteWindows', description='The time window during which write operations are stopped.', example='2025-02-08T00:00:00+08:00,2025-02-12T00:00:00+08:00'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:

*   **30** (default)
*   **50**
*   **100**', example='30'),
  regionId?: string(name='RegionId', description='The region ID. You can call the [DescribeRegions](https://help.aliyun.com/document_detail/170875.html) operation to query the most recent region list.

This parameter is required.', example='cn-hangzhou'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceAccount?: string(name='SourceAccount', description='The database account that is used to log on to the database in the source ApsaraDB for ClickHouse cluster.

This parameter is required.', example='test'),
  sourceClusterName?: string(name='SourceClusterName', description='The name of the self-managed ClickHouse cluster. You can execute the `SELECT * FROM system.clusters` statement to query the cluster name.', example='default'),
  sourcePassword?: string(name='SourcePassword', description='The password that corresponds to the database account for logging on to the database in the source ApsaraDB for ClickHouse cluster.

This parameter is required.', example='123456Aa'),
  sourceShards?: string(name='SourceShards', description='The endpoint and TCP port of the self-managed ClickHouse cluster.', example='192.168.0.4:9000,192.168.0.5:9000,192.168.0.6:9000'),
  targetAccount?: string(name='TargetAccount', description='The database account that is used to log on to the database in the destination ApsaraDB for ClickHouse cluster.

This parameter is required.', example='test01'),
  targetDbClusterId?: string(name='TargetDbClusterId', description='The ID of the destination ApsaraDB for ClickHouse cluster.

This parameter is required.', example='cc-bp14b39djx7zg****'),
  targetPassword?: string(name='TargetPassword', description='The password that corresponds to the database account for logging on to the database in the destination ApsaraDB for ClickHouse cluster.

This parameter is required.', example='123456Ff'),
}

model TransferVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7084CDB5-308F-5D0B-8F9B-5F7D83E09738'),
}

model TransferVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TransferVersionResponseBody(name='body'),
}

/**
 * @summary Migrates the data of a source ApsaraDB for ClickHouse cluster to a destination ApsaraDB for ClickHouse cluster.
 *
 * @description ## [](#)Prerequisites
 * *   The IP address of the source ApsaraDB for ClickHouse cluster is added to the IP address whitelist of the destination ApsaraDB for ClickHouse cluster.
 * *   The IP address of the destination ApsaraDB for ClickHouse cluster is added to the IP address whitelist of the source ApsaraDB for ClickHouse cluster.
 * >  You can execute the `select * from system.clusters;` statement to query the IP address of an ApsaraDB for ClickHouse cluster.
 *
 * @param request TransferVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return TransferVersionResponse
 */
async function transferVersionWithOptions(request: TransferVersionRequest, runtime: Util.RuntimeOptions): TransferVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.disableWriteWindows)) {
    query['DisableWriteWindows'] = request.disableWriteWindows;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceAccount)) {
    query['SourceAccount'] = request.sourceAccount;
  }
  if (!Util.isUnset(request.sourceClusterName)) {
    query['SourceClusterName'] = request.sourceClusterName;
  }
  if (!Util.isUnset(request.sourcePassword)) {
    query['SourcePassword'] = request.sourcePassword;
  }
  if (!Util.isUnset(request.sourceShards)) {
    query['SourceShards'] = request.sourceShards;
  }
  if (!Util.isUnset(request.targetAccount)) {
    query['TargetAccount'] = request.targetAccount;
  }
  if (!Util.isUnset(request.targetDbClusterId)) {
    query['TargetDbClusterId'] = request.targetDbClusterId;
  }
  if (!Util.isUnset(request.targetPassword)) {
    query['TargetPassword'] = request.targetPassword;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransferVersion',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Migrates the data of a source ApsaraDB for ClickHouse cluster to a destination ApsaraDB for ClickHouse cluster.
 *
 * @description ## [](#)Prerequisites
 * *   The IP address of the source ApsaraDB for ClickHouse cluster is added to the IP address whitelist of the destination ApsaraDB for ClickHouse cluster.
 * *   The IP address of the destination ApsaraDB for ClickHouse cluster is added to the IP address whitelist of the source ApsaraDB for ClickHouse cluster.
 * >  You can execute the `select * from system.clusters;` statement to query the IP address of an ApsaraDB for ClickHouse cluster.
 *
 * @param request TransferVersionRequest
 * @return TransferVersionResponse
 */
async function transferVersion(request: TransferVersionRequest): TransferVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return transferVersionWithOptions(request, runtime);
}

model UpgradeMinorVersionRequest {
  DBClusterId?: string(name='DBClusterId', description='The cluster ID.

This parameter is required.', example='cc-bp108z124a8o7****'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  upgradeImmediately?: boolean(name='UpgradeImmediately', description='Specifies whether to update the minor engine version of the ApsaraDB for ClickHouse cluster immediately. Valid values:

*   **true**: updates the minor engine version of the ApsaraDB for ClickHouse cluster immediately.
*   **false**: updates the minor engine version of the ApsaraDB for ClickHouse cluster at the specified time or within the specified maintenance window.

>  If you want to update the minor engine version of the ApsaraDB for ClickHouse cluster at the specified time, **UpgradeTime** is required.

This parameter is required.', example='false'),
  upgradeTime?: string(name='UpgradeTime', description='The update time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mmZ format. The time must be in Coordinated Universal Time (UTC).

>  If you do not set this parameter, the minor engine version of an ApsaraDB for ClickHouse cluster is updated within the specified maintenance window.', example='2022-08-07T16:38Z'),
  upgradeVersion?: string(name='UpgradeVersion', description='The minor engine version to which you want to update.

>  By default, UpgradeVersion is not set and the minor engine version of the ApsaraDB for ClickHouse cluster is updated to the latest version.', example='1.37.0'),
}

model UpgradeMinorVersionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FE242962-6DA3-5FC8-9691-37B62A3210F7'),
}

model UpgradeMinorVersionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpgradeMinorVersionResponseBody(name='body'),
}

/**
 * @summary Updates the minor engine version of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were purchased after December 1, 2021.
 *
 * @param request UpgradeMinorVersionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpgradeMinorVersionResponse
 */
async function upgradeMinorVersionWithOptions(request: UpgradeMinorVersionRequest, runtime: Util.RuntimeOptions): UpgradeMinorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBClusterId)) {
    query['DBClusterId'] = request.DBClusterId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.upgradeImmediately)) {
    query['UpgradeImmediately'] = request.upgradeImmediately;
  }
  if (!Util.isUnset(request.upgradeTime)) {
    query['UpgradeTime'] = request.upgradeTime;
  }
  if (!Util.isUnset(request.upgradeVersion)) {
    query['UpgradeVersion'] = request.upgradeVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeMinorVersion',
    version = '2019-11-11',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the minor engine version of an ApsaraDB for ClickHouse cluster.
 *
 * @description >  You can call this operation only for ApsaraDB for ClickHouse clusters that were purchased after December 1, 2021.
 *
 * @param request UpgradeMinorVersionRequest
 * @return UpgradeMinorVersionResponse
 */
async function upgradeMinorVersion(request: UpgradeMinorVersionRequest): UpgradeMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeMinorVersionWithOptions(request, runtime);
}

