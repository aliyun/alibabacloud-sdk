/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  

  checkConfig(config);
  @endpoint = getEndpoint('airec', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model AttachDatasetResponseBody = {
  result?: {
    versionId?: string(name='versionId'),
    state?: string(name='state'),
    gmtModified?: long(name='gmtModified'),
    gmtCreate?: long(name='gmtCreate'),
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model AttachDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: AttachDatasetResponseBody(name='body'),
}

async function attachDataset(instanceId: string, versionId: string): AttachDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachDatasetWithOptions(instanceId, versionId, headers, runtime);
}

async function attachDatasetWithOptions(instanceId: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): AttachDatasetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'AttachDataset',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSets/{versionId}/actions/current`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AttachIndexVersionResponseBody = {
  result?: boolean(name='result'),
  requestId?: string(name='requestId'),
}

model AttachIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  body: AttachIndexVersionResponseBody(name='body'),
}

async function attachIndexVersion(instanceId: string, algorithmId: string, versionId: string): AttachIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return attachIndexVersionWithOptions(instanceId, algorithmId, versionId, headers, runtime);
}

async function attachIndexVersionWithOptions(instanceId: string, algorithmId: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): AttachIndexVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'AttachIndexVersion',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/index-versions/{versionId}/actions/attach`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckRankingModelReachableResponseBody = {
  result?: boolean(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model CheckRankingModelReachableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckRankingModelReachableResponseBody(name='body'),
}

async function checkRankingModelReachable(instanceId: string, rankingModelId: string): CheckRankingModelReachableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkRankingModelReachableWithOptions(instanceId, rankingModelId, headers, runtime);
}

async function checkRankingModelReachableWithOptions(instanceId: string, rankingModelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CheckRankingModelReachableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CheckRankingModelReachable',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models/{rankingModelId}/actions/check-connectivity`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CloneExperimentRequest {
  dryRun?: boolean(name='dryRun'),
}

model CloneExperimentResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model CloneExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: CloneExperimentResponseBody(name='body'),
}

async function cloneExperiment(instanceId: string, sceneId: string, experimentId: string, request: CloneExperimentRequest): CloneExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return cloneExperimentWithOptions(instanceId, sceneId, experimentId, request, headers, runtime);
}

async function cloneExperimentWithOptions(instanceId: string, sceneId: string, experimentId: string, request: CloneExperimentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CloneExperimentResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneExperiment',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}/actions/clone`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateFilteringAlgorithmRequest {
  dryRun?: string(name='dryRun'),
}

model CreateFilteringAlgorithmResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    algorithmId?: string(name='algorithmId'),
    meta?: {
      type?: string(name='type'),
      extInfo?: map[string]any(name='extInfo'),
      category?: string(name='category'),
      threshold?: {
        sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
        sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
        indexSizeThreshold?: int32(name='indexSizeThreshold'),
        indexLossThreshold?: int32(name='indexLossThreshold'),
      }(name='threshold'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
      tableName?: string(name='tableName'),
      cron?: string(name='cron'),
      description?: string(name='description'),
      gmtModified?: string(name='gmtModified'),
      projectName?: string(name='projectName'),
      algorithmName?: string(name='algorithmName'),
      cronEnabled?: boolean(name='cronEnabled'),
    }(name='meta'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model CreateFilteringAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFilteringAlgorithmResponseBody(name='body'),
}

async function createFilteringAlgorithm(instanceId: string, request: CreateFilteringAlgorithmRequest): CreateFilteringAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createFilteringAlgorithmWithOptions(instanceId, request, headers, runtime);
}

async function createFilteringAlgorithmWithOptions(instanceId: string, request: CreateFilteringAlgorithmRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateFilteringAlgorithmResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateFilteringAlgorithm',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateInstanceResponseBody = {
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model CreateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateInstanceResponseBody(name='body'),
}

async function createInstance(): CreateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createInstanceWithOptions(headers, runtime);
}

async function createInstanceWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CreateInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRankingModelRequest {
  dryRun?: boolean(name='dryRun'),
}

model CreateRankingModelResponseBody = {
  result?: {
    rankingModelId?: string(name='rankingModelId'),
    gmtModified?: string(name='gmtModified'),
    gmtCreate?: string(name='gmtCreate'),
    meta?: map[string]any(name='meta'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model CreateRankingModelResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRankingModelResponseBody(name='body'),
}

async function createRankingModel(instanceId: string, request: CreateRankingModelRequest): CreateRankingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRankingModelWithOptions(instanceId, request, headers, runtime);
}

async function createRankingModelWithOptions(instanceId: string, request: CreateRankingModelRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRankingModelResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRankingModel',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRuleResponseBody = {
  result?: {
    ruleId?: string(name='ruleId'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model CreateRuleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRuleResponseBody(name='body'),
}

async function createRule(instanceId: string): CreateRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRuleWithOptions(instanceId, headers, runtime);
}

async function createRuleWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateRule',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rules`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateSceneRequest {
  dryRun?: boolean(name='dryRun'),
}

model CreateSceneResponseBody = {
  result?: {
    sceneId?: string(name='sceneId'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model CreateSceneResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSceneResponseBody(name='body'),
}

async function createScene(instanceId: string, request: CreateSceneRequest): CreateSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSceneWithOptions(instanceId, request, headers, runtime);
}

async function createSceneWithOptions(instanceId: string, request: CreateSceneRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSceneResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.dryRun)) {
    query.dryRun = request.dryRun;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateScene',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DecribeRankingModelResponseBody = {
  result?: {
    rankingModelId?: string(name='rankingModelId'),
    gmtModified?: string(name='gmtModified'),
    gmtCreate?: string(name='gmtCreate'),
    meta?: map[string]any(name='meta'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DecribeRankingModelResponse = {
  headers: map[string]string(name='headers'),
  body: DecribeRankingModelResponseBody(name='body'),
}

async function decribeRankingModel(instanceId: string, rankingModelId: string): DecribeRankingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return decribeRankingModelWithOptions(instanceId, rankingModelId, headers, runtime);
}

async function decribeRankingModelWithOptions(instanceId: string, rankingModelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DecribeRankingModelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DecribeRankingModel',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models/{rankingModelId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDataSetResponseBody = {
  result?: {
    versionId?: string(name='versionId'),
    state?: string(name='state'),
    gmtModified?: long(name='gmtModified'),
    gmtCreate?: long(name='gmtCreate'),
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DeleteDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDataSetResponseBody(name='body'),
}

async function deleteDataSet(instanceId: string, versionId: string): DeleteDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDataSetWithOptions(instanceId, versionId, headers, runtime);
}

async function deleteDataSetWithOptions(instanceId: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSet',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSets/{versionId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteExperimentResponseBody = {
  result?: boolean(name='result'),
  requestId?: string(name='requestId'),
}

model DeleteExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteExperimentResponseBody(name='body'),
}

async function deleteExperiment(instanceId: string, sceneId: string, experimentId: string): DeleteExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteExperimentWithOptions(instanceId, sceneId, experimentId, headers, runtime);
}

async function deleteExperimentWithOptions(instanceId: string, sceneId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteExperiment',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteFilteringAlgorithmResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    algorithmId?: string(name='algorithmId'),
    meta?: {
      taskId?: string(name='taskId'),
      metaType?: string(name='metaType'),
      type?: string(name='type'),
      extInfo?: {
        kvSeparator?: string(name='kvSeparator'),
        itemSeparator?: string(name='itemSeparator'),
      }(name='extInfo'),
      category?: string(name='category'),
      threshold?: {
        sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
        sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
        indexSizeThreshold?: int32(name='indexSizeThreshold'),
        indexLossThreshold?: int32(name='indexLossThreshold'),
      }(name='threshold'),
      tableName?: string(name='tableName'),
      clusterId?: string(name='clusterId'),
      cron?: string(name='cron'),
      description?: string(name='description'),
      projectName?: string(name='projectName'),
      algorithmName?: string(name='algorithmName'),
      cronEnabled?: boolean(name='cronEnabled'),
    }(name='meta'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DeleteFilteringAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFilteringAlgorithmResponseBody(name='body'),
}

async function deleteFilteringAlgorithm(instanceId: string, algorithmId: string): DeleteFilteringAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteFilteringAlgorithmWithOptions(instanceId, algorithmId, headers, runtime);
}

async function deleteFilteringAlgorithmWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteFilteringAlgorithmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteFilteringAlgorithm',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteRankingModelResponseBody = {
  result?: {
    rankingModelId?: string(name='rankingModelId'),
    meta?: map[string]any(name='meta'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DeleteRankingModelResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRankingModelResponseBody(name='body'),
}

async function deleteRankingModel(instanceId: string, rankingModelId: string): DeleteRankingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRankingModelWithOptions(instanceId, rankingModelId, headers, runtime);
}

async function deleteRankingModelWithOptions(instanceId: string, rankingModelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRankingModelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRankingModel',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models/{rankingModelId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteSceneResponseBody = {
  result?: {
    sceneId?: string(name='sceneId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DeleteSceneResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSceneResponseBody(name='body'),
}

async function deleteScene(instanceId: string, sceneId: string): DeleteSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSceneWithOptions(instanceId, sceneId, headers, runtime);
}

async function deleteSceneWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSceneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteScene',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeBaseExperimentResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeBaseExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBaseExperimentResponseBody(name='body'),
}

async function describeBaseExperiment(instanceId: string, sceneId: string): DescribeBaseExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeBaseExperimentWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeBaseExperimentWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeBaseExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeBaseExperiment',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/base-experiment`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDataSetMessageResponseBody = {
  result?: [ 
    {
      message?: string(name='message'),
      timestamp?: string(name='timestamp'),
      errorLevel?: string(name='errorLevel'),
      errorType?: string(name='errorType'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeDataSetMessageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDataSetMessageResponseBody(name='body'),
}

async function describeDataSetMessage(instanceId: string, versionId: string): DescribeDataSetMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDataSetMessageWithOptions(instanceId, versionId, headers, runtime);
}

async function describeDataSetMessageWithOptions(instanceId: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDataSetMessageResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataSetMessage',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSets/{versionId}/messages`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeDefaultAlgorithmsResponseBody = {
  result?: [ 
    {
      key?: string(name='key'),
      config?: [ 
        {
          key?: string(name='key'),
          defaultValue?: string(name='defaultValue'),
          experimentValue?: string(name='experimentValue'),
          name?: string(name='name'),
        }
      ](name='config'),
      defaultValue?: string(name='defaultValue'),
      type?: string(name='type'),
      experimentValue?: string(name='experimentValue'),
      hasConfig?: boolean(name='hasConfig'),
      category?: string(name='category'),
      name?: string(name='name'),
    }
  ](name='result'),
  requestId?: string(name='requestId'),
}

model DescribeDefaultAlgorithmsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDefaultAlgorithmsResponseBody(name='body'),
}

async function describeDefaultAlgorithms(instanceId: string, sceneId: string): DescribeDefaultAlgorithmsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeDefaultAlgorithmsWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeDefaultAlgorithmsWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeDefaultAlgorithmsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeDefaultAlgorithms',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/default-algorithms`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeExperimentResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExperimentResponseBody(name='body'),
}

async function describeExperiment(instanceId: string, sceneId: string, experimentId: string): DescribeExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeExperimentWithOptions(instanceId, sceneId, experimentId, headers, runtime);
}

async function describeExperimentWithOptions(instanceId: string, sceneId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeExperiment',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeExperimentEnvResponseBody = {
  result?: {
    bucketCount?: int32(name='bucketCount'),
    divideType?: string(name='divideType'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeExperimentEnvResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExperimentEnvResponseBody(name='body'),
}

async function describeExperimentEnv(instanceId: string, sceneId: string): DescribeExperimentEnvResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeExperimentEnvWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeExperimentEnvWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeExperimentEnvResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeExperimentEnv',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiment-env`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeExperimentEnvProgressResponseBody = {
  result?: {
    status?: string(name='status'),
    progress?: int32(name='progress'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeExperimentEnvProgressResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeExperimentEnvProgressResponseBody(name='body'),
}

async function describeExperimentEnvProgress(instanceId: string, sceneId: string): DescribeExperimentEnvProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeExperimentEnvProgressWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeExperimentEnvProgressWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeExperimentEnvProgressResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeExperimentEnvProgress',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiment-progress`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeFilteringAlgorithmResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    algorithmId?: string(name='algorithmId'),
    meta?: {
      taskId?: string(name='taskId'),
      metaType?: string(name='metaType'),
      type?: string(name='type'),
      extInfo?: {
        kvSeparator?: string(name='kvSeparator'),
        itemSeparator?: string(name='itemSeparator'),
      }(name='extInfo'),
      category?: string(name='category'),
      threshold?: {
        sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
        sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
        indexSizeThreshold?: int32(name='indexSizeThreshold'),
        indexLossThreshold?: int32(name='indexLossThreshold'),
      }(name='threshold'),
      tableName?: string(name='tableName'),
      clusterId?: string(name='clusterId'),
      cron?: string(name='cron'),
      description?: string(name='description'),
      projectName?: string(name='projectName'),
      algorithmName?: string(name='algorithmName'),
      cronEnabled?: boolean(name='cronEnabled'),
    }(name='meta'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeFilteringAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFilteringAlgorithmResponseBody(name='body'),
}

async function describeFilteringAlgorithm(instanceId: string, algorithmId: string): DescribeFilteringAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeFilteringAlgorithmWithOptions(instanceId, algorithmId, headers, runtime);
}

async function describeFilteringAlgorithmWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeFilteringAlgorithmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeFilteringAlgorithm',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeInstanceResponseBody = {
  result?: {
    regionId?: string(name='regionId'),
    type?: string(name='type'),
    lockMode?: string(name='lockMode'),
    expiredTime?: string(name='expiredTime'),
    scene?: string(name='scene'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    chargeType?: string(name='chargeType'),
    industry?: string(name='industry'),
    commodityCode?: string(name='commodityCode'),
    gmtModified?: string(name='gmtModified'),
    dataSetVersion?: string(name='dataSetVersion'),
    name?: string(name='name'),
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceResponseBody(name='body'),
}

async function describeInstance(instanceId: string): DescribeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeInstanceWithOptions(instanceId, headers, runtime);
}

async function describeInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeLatestTaskResponseBody = {
  result?: [ 
    {
      code?: string(name='code'),
      switchedTime?: string(name='switchedTime'),
      rollbackEnabled?: boolean(name='rollbackEnabled'),
      message?: string(name='message'),
      flowType?: string(name='flowType'),
      costSeconds?: int32(name='costSeconds'),
      builtTime?: string(name='builtTime'),
      versionId?: string(name='versionId'),
      size?: long(name='size'),
      status?: string(name='status'),
      progress?: int32(name='progress'),
    }
  ](name='result'),
  requestId?: string(name='requestId'),
}

model DescribeLatestTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLatestTaskResponseBody(name='body'),
}

async function describeLatestTask(instanceId: string, algorithmId: string): DescribeLatestTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeLatestTaskWithOptions(instanceId, algorithmId, headers, runtime);
}

async function describeLatestTaskWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeLatestTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeLatestTask',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/tasks/latest`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeQuotaResponseBody = {
  result?: {
    itemCountUsed?: long(name='itemCountUsed'),
    itemCount?: long(name='itemCount'),
    userCount?: long(name='userCount'),
    userCountUsed?: long(name='userCountUsed'),
    qps?: int32(name='qps'),
    currentQps?: int32(name='currentQps'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeQuotaResponseBody(name='body'),
}

async function describeQuota(instanceId: string): DescribeQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeQuotaWithOptions(instanceId, headers, runtime);
}

async function describeQuotaWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeQuotaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeQuota',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/quota`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='acceptLanguage'),
}

model DescribeRegionsResponseBody = {
  result?: [ 
    {
      regionId?: string(name='regionId'),
      endpoint?: string(name='endpoint'),
      status?: string(name='status'),
      localName?: string(name='localName'),
      consoleUrl?: string(name='consoleUrl'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query.acceptLanguage = request.acceptLanguage;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/configurations/regions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeRuleRequest {
  sceneId?: string(name='sceneId'),
  ruleType?: string(name='ruleType'),
}

model DescribeRuleResponseBody = {
  result?: {
    ruleId?: string(name='ruleId'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeRuleResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRuleResponseBody(name='body'),
}

async function describeRule(instanceId: string, ruleId: string, request: DescribeRuleRequest): DescribeRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRuleWithOptions(instanceId, ruleId, request, headers, runtime);
}

async function describeRuleWithOptions(instanceId: string, ruleId: string, request: DescribeRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.ruleType = request.ruleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRule',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rules/{ruleId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSceneResponseBody = {
  result?: {
    sceneId?: string(name='sceneId'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeSceneResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSceneResponseBody(name='body'),
}

async function describeScene(instanceId: string, sceneId: string): DescribeSceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSceneWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeSceneWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSceneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeScene',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSceneBucketResponseBody = {
  result?: {
    num?: int32(name='num'),
    inUse?: string(name='inUse'),
    detail?: map[string]any(name='detail'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model DescribeSceneBucketResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSceneBucketResponseBody(name='body'),
}

async function describeSceneBucket(instanceId: string, sceneId: string): DescribeSceneBucketResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSceneBucketWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeSceneBucketWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSceneBucketResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSceneBucket',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiment-bucket`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSceneThroughputResponseBody = {
  result?: {
    pvCount?: long(name='pvCount'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeSceneThroughputResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSceneThroughputResponseBody(name='body'),
}

async function describeSceneThroughput(instanceId: string, sceneId: string): DescribeSceneThroughputResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSceneThroughputWithOptions(instanceId, sceneId, headers, runtime);
}

async function describeSceneThroughputWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSceneThroughputResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DescribeSceneThroughput',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/throughput`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSyncReportDetailRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  type?: string(name='type'),
  levelType?: string(name='levelType'),
}

model DescribeSyncReportDetailResponseBody = {
  result?: [ 
    {
      historyData?: [ 
        {
          errorPercent?: float(name='errorPercent'),
          startTime?: long(name='startTime'),
          endTime?: long(name='endTime'),
        }
      ](name='historyData'),
      sampleDisplay?: boolean(name='sampleDisplay'),
      type?: string(name='type'),
      errorCount?: int32(name='errorCount'),
      errorPercent?: float(name='errorPercent'),
      defaultDisplay?: boolean(name='defaultDisplay'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeSyncReportDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSyncReportDetailResponseBody(name='body'),
}

async function describeSyncReportDetail(instanceId: string, request: DescribeSyncReportDetailRequest): DescribeSyncReportDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSyncReportDetailWithOptions(instanceId, request, headers, runtime);
}

async function describeSyncReportDetailWithOptions(instanceId: string, request: DescribeSyncReportDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSyncReportDetailResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }
  if (!Util.isUnset(request.levelType)) {
    query.levelType = request.levelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSyncReportDetail',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/detail`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeSyncReportOutliersRequest {
  startTime?: long(name='startTime'),
  key?: string(name='key'),
  type?: string(name='type'),
  endTime?: long(name='endTime'),
  levelType?: string(name='levelType'),
}

model DescribeSyncReportOutliersResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeSyncReportOutliersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSyncReportOutliersResponseBody(name='body'),
}

async function describeSyncReportOutliers(instanceId: string, request: DescribeSyncReportOutliersRequest): DescribeSyncReportOutliersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeSyncReportOutliersWithOptions(instanceId, request, headers, runtime);
}

async function describeSyncReportOutliersWithOptions(instanceId: string, request: DescribeSyncReportOutliersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeSyncReportOutliersResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.key)) {
    query.key = request.key;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.levelType)) {
    query.levelType = request.levelType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSyncReportOutliers',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/outliers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DescribeUserMetricsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  metricType?: string(name='metricType'),
}

model DescribeUserMetricsResponseBody = {
  result?: [ 
    {
      sceneId?: string(name='sceneId'),
      dataPoints?: [ 
        {
          val?: float(name='val'),
          startTime?: long(name='startTime'),
          endTime?: long(name='endTime'),
        }
      ](name='dataPoints'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DescribeUserMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUserMetricsResponseBody(name='body'),
}

async function describeUserMetrics(instanceId: string, request: DescribeUserMetricsRequest): DescribeUserMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeUserMetricsWithOptions(instanceId, request, headers, runtime);
}

async function describeUserMetricsWithOptions(instanceId: string, request: DescribeUserMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeUserMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query.metricType = request.metricType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUserMetrics',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DowngradeInstanceResponseBody = {
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model DowngradeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DowngradeInstanceResponseBody(name='body'),
}

async function downgradeInstance(instanceId: string): DowngradeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return downgradeInstanceWithOptions(instanceId, headers, runtime);
}

async function downgradeInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DowngradeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DowngradeInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/downgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model EnableExperimentResponseBody = {
  result?: boolean(name='result'),
  requestId?: string(name='requestId'),
}

model EnableExperimentResponse = {
  headers: map[string]string(name='headers'),
  body: EnableExperimentResponseBody(name='body'),
}

async function enableExperiment(instanceId: string, sceneId: string): EnableExperimentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return enableExperimentWithOptions(instanceId, sceneId, headers, runtime);
}

async function enableExperimentWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): EnableExperimentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'EnableExperiment',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/actions/enable-experiment`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDashboardDetailsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  traceIds?: string(name='traceIds'),
  sceneIds?: string(name='sceneIds'),
  metricType?: string(name='metricType'),
  experimentIds?: string(name='experimentIds'),
}

model ListDashboardDetailsResponseBody = {
  result?: [ 
    {
      traceId?: string(name='traceId'),
      sceneId?: string(name='sceneId'),
      metricRes?: {
        total?: map[string]any(name='total'),
        detail?: map[string]any(name='detail'),
      }(name='metricRes'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDashboardDetailsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardDetailsResponseBody(name='body'),
}

async function listDashboardDetails(instanceId: string, request: ListDashboardDetailsRequest): ListDashboardDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardDetailsWithOptions(instanceId, request, headers, runtime);
}

async function listDashboardDetailsWithOptions(instanceId: string, request: ListDashboardDetailsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardDetailsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.traceIds)) {
    query.traceIds = request.traceIds;
  }
  if (!Util.isUnset(request.sceneIds)) {
    query.sceneIds = request.sceneIds;
  }
  if (!Util.isUnset(request.metricType)) {
    query.metricType = request.metricType;
  }
  if (!Util.isUnset(request.experimentIds)) {
    query.experimentIds = request.experimentIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardDetails',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dashboard/details`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDashboardDetailsFlowsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  traceIds?: string(name='traceIds'),
  sceneIds?: string(name='sceneIds'),
  metricType?: string(name='metricType'),
  experimentIds?: string(name='experimentIds'),
}

model ListDashboardDetailsFlowsResponseBody = {
  result?: {
    metricType?: string(name='metricType'),
    metricData?: [ 
      {
        traceId?: string(name='traceId'),
        sceneId?: string(name='sceneId'),
        metricRes?: map[string]any(name='metricRes'),
      }
    ](name='metricData'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDashboardDetailsFlowsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardDetailsFlowsResponseBody(name='body'),
}

async function listDashboardDetailsFlows(instanceId: string, request: ListDashboardDetailsFlowsRequest): ListDashboardDetailsFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardDetailsFlowsWithOptions(instanceId, request, headers, runtime);
}

async function listDashboardDetailsFlowsWithOptions(instanceId: string, request: ListDashboardDetailsFlowsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardDetailsFlowsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.traceIds)) {
    query.traceIds = request.traceIds;
  }
  if (!Util.isUnset(request.sceneIds)) {
    query.sceneIds = request.sceneIds;
  }
  if (!Util.isUnset(request.metricType)) {
    query.metricType = request.metricType;
  }
  if (!Util.isUnset(request.experimentIds)) {
    query.experimentIds = request.experimentIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardDetailsFlows',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dashboard/details/flows`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDashboardMetricsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  metricType?: string(name='metricType'),
}

model ListDashboardMetricsResponseBody = {
  result?: [ 
    {
      total?: map[string]any(name='total'),
      detail?: [ 
        {
          val?: string(name='val'),
          startTime?: string(name='startTime'),
          endTime?: string(name='endTime'),
        }
      ](name='detail'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDashboardMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardMetricsResponseBody(name='body'),
}

async function listDashboardMetrics(instanceId: string, request: ListDashboardMetricsRequest): ListDashboardMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardMetricsWithOptions(instanceId, request, headers, runtime);
}

async function listDashboardMetricsWithOptions(instanceId: string, request: ListDashboardMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query.metricType = request.metricType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardMetrics',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dashboard/metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDashboardMetricsFlowsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  metricType?: string(name='metricType'),
}

model ListDashboardMetricsFlowsResponseBody = {
  result?: [ 
    {
      metricType?: string(name='metricType'),
      metricData?: map[string]any(name='metricData'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDashboardMetricsFlowsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDashboardMetricsFlowsResponseBody(name='body'),
}

async function listDashboardMetricsFlows(instanceId: string, request: ListDashboardMetricsFlowsRequest): ListDashboardMetricsFlowsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDashboardMetricsFlowsWithOptions(instanceId, request, headers, runtime);
}

async function listDashboardMetricsFlowsWithOptions(instanceId: string, request: ListDashboardMetricsFlowsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDashboardMetricsFlowsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.metricType)) {
    query.metricType = request.metricType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDashboardMetricsFlows',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dashboard/metrics/flows`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSetResponseBody = {
  result?: [ 
    {
      versionId?: string(name='versionId'),
      state?: string(name='state'),
      gmtModified?: long(name='gmtModified'),
      gmtCreate?: long(name='gmtCreate'),
      instanceId?: string(name='instanceId'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSetResponseBody(name='body'),
}

async function listDataSet(instanceId: string): ListDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSetWithOptions(instanceId, headers, runtime);
}

async function listDataSetWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSet',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDataSourceResponseBody = {
  result?: [ 
    {
      gmtModified?: string(name='gmtModified'),
      gmtCreate?: string(name='gmtCreate'),
      tableName?: string(name='tableName'),
      meta?: {
        bucketName?: string(name='bucketName'),
        accessKeyId?: string(name='accessKeyId'),
        type?: string(name='type'),
        partition?: string(name='partition'),
        timestamp?: long(name='timestamp'),
        path?: string(name='path'),
        tableName?: string(name='tableName'),
        projectName?: string(name='projectName'),
      }(name='meta'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ListDataSourceResponseBody(name='body'),
}

async function listDataSource(instanceId: string): ListDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDataSourceWithOptions(instanceId, headers, runtime);
}

async function listDataSourceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDataSourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDataSource',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSources`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListExperimentsResponseBody = {
  result?: [ 
    {
      base?: boolean(name='base'),
      onlineTime?: string(name='onlineTime'),
      offlineTime?: string(name='offlineTime'),
      description?: string(name='description'),
      status?: string(name='status'),
      name?: string(name='name'),
      buckets?: [ string ](name='buckets'),
      experimentId?: string(name='experimentId'),
    }
  ](name='result'),
  requestId?: string(name='requestId'),
}

model ListExperimentsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExperimentsResponseBody(name='body'),
}

async function listExperiments(instanceId: string, sceneId: string): ListExperimentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listExperimentsWithOptions(instanceId, sceneId, headers, runtime);
}

async function listExperimentsWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListExperimentsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListExperiments',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListFilteringAlgorithmsRequest {
  status?: string(name='status'),
  algorithmId?: string(name='algorithmId'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListFilteringAlgorithmsResponseBody = {
  result?: [ 
    {
      gmtModified?: string(name='gmtModified'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
      algorithmId?: string(name='algorithmId'),
      meta?: {
        taskId?: string(name='taskId'),
        metaType?: string(name='metaType'),
        type?: string(name='type'),
        extInfo?: {
          kvSeparator?: string(name='kvSeparator'),
          itemSeparator?: string(name='itemSeparator'),
        }(name='extInfo'),
        category?: string(name='category'),
        threshold?: {
          sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
          sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
          indexSizeThreshold?: int32(name='indexSizeThreshold'),
          indexLossThreshold?: int32(name='indexLossThreshold'),
        }(name='threshold'),
        tableName?: string(name='tableName'),
        clusterId?: string(name='clusterId'),
        cron?: string(name='cron'),
        description?: string(name='description'),
        projectName?: string(name='projectName'),
        algorithmName?: string(name='algorithmName'),
        cronEnabled?: boolean(name='cronEnabled'),
      }(name='meta'),
    }
  ](name='result'),
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='headers'),
  requestId?: string(name='requestId'),
}

model ListFilteringAlgorithmsResponse = {
  headers: map[string]string(name='headers'),
  body: ListFilteringAlgorithmsResponseBody(name='body'),
}

async function listFilteringAlgorithms(instanceId: string, request: ListFilteringAlgorithmsRequest): ListFilteringAlgorithmsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listFilteringAlgorithmsWithOptions(instanceId, request, headers, runtime);
}

async function listFilteringAlgorithmsWithOptions(instanceId: string, request: ListFilteringAlgorithmsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListFilteringAlgorithmsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.algorithmId)) {
    query.algorithmId = request.algorithmId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListFilteringAlgorithms',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListIndexVersionsResponseBody = {
  result?: [ 
    {
      code?: string(name='code'),
      switchedTime?: string(name='switchedTime'),
      rollbackEnabled?: boolean(name='rollbackEnabled'),
      message?: string(name='message'),
      flowType?: string(name='flowType'),
      costSeconds?: int32(name='costSeconds'),
      builtTime?: string(name='builtTime'),
      versionId?: string(name='versionId'),
      size?: long(name='size'),
      status?: string(name='status'),
      progress?: int32(name='progress'),
    }
  ](name='result'),
  requestId?: string(name='requestId'),
}

model ListIndexVersionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListIndexVersionsResponseBody(name='body'),
}

async function listIndexVersions(instanceId: string, algorithmId: string): ListIndexVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listIndexVersionsWithOptions(instanceId, algorithmId, headers, runtime);
}

async function listIndexVersionsWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListIndexVersionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListIndexVersions',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/index-versions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceRequest {
  page?: int32(name='page'),
  size?: int32(name='size'),
  status?: string(name='status'),
  name?: string(name='name'),
  expiredTime?: string(name='expiredTime'),
  instanceId?: string(name='instanceId'),
}

model ListInstanceResponseBody = {
  result?: [ 
    {
      regionId?: string(name='regionId'),
      type?: string(name='type'),
      lockMode?: string(name='lockMode'),
      expiredTime?: string(name='expiredTime'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
      chargeType?: string(name='chargeType'),
      industry?: string(name='industry'),
      commodityCode?: string(name='commodityCode'),
      gmtModified?: string(name='gmtModified'),
      dataSetVersion?: string(name='dataSetVersion'),
      name?: string(name='name'),
      instanceId?: string(name='instanceId'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceResponseBody(name='body'),
}

async function listInstance(request: ListInstanceRequest): ListInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceWithOptions(request, headers, runtime);
}

async function listInstanceWithOptions(request: ListInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.name)) {
    query.name = request.name;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query.expiredTime = request.expiredTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query.instanceId = request.instanceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInstanceTaskResponseBody = {
  result?: [ 
    {
      subProgressInfos?: [ 
        {
          type?: string(name='type'),
          detail?: string(name='detail'),
          totalNum?: int32(name='totalNum'),
          finishedNum?: int32(name='finishedNum'),
          progress?: int32(name='progress'),
        }
      ](name='subProgressInfos'),
      totalProgress?: int32(name='totalProgress'),
      name?: string(name='name'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListInstanceTaskResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstanceTaskResponseBody(name='body'),
}

async function listInstanceTask(instanceId: string): ListInstanceTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstanceTaskWithOptions(instanceId, headers, runtime);
}

async function listInstanceTaskWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstanceTaskResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListInstanceTask',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListItemsRequest {
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListItemsResponseBody = {
  result?: {
    total?: {
      sceneWeightItem?: long(name='sceneWeightItem'),
      totalCount?: long(name='totalCount'),
      queryCount?: long(name='queryCount'),
      sceneRecommendItem?: long(name='sceneRecommendItem'),
      weightItem?: long(name='weightItem'),
      instanceRecommendItem?: long(name='instanceRecommendItem'),
    }(name='total'),
    detail?: [ 
      {
        title?: string(name='title'),
        categoryPath?: string(name='categoryPath'),
        itemId?: string(name='itemId'),
        itemType?: string(name='itemType'),
        status?: string(name='status'),
        brandId?: string(name='brandId'),
        shopId?: string(name='shopId'),
        pubTime?: string(name='pubTime'),
        channel?: string(name='channel'),
        duration?: string(name='duration'),
        author?: string(name='author'),
        expireTime?: string(name='expireTime'),
      }
    ](name='detail'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model ListItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListItemsResponseBody(name='body'),
}

async function listItems(instanceId: string, request: ListItemsRequest): ListItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listItemsWithOptions(instanceId, request, headers, runtime);
}

async function listItemsWithOptions(instanceId: string, request: ListItemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListItemsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListItems',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/items/actions/list`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLogsRequest {
  queryParams?: string(name='queryParams'),
  startTime?: int32(name='startTime'),
  endTime?: int32(name='endTime'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListLogsResponseBody = {
  result?: [  map[string]any ](name='result'),
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='headers'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListLogsResponse = {
  headers: map[string]string(name='headers'),
  body: ListLogsResponseBody(name='body'),
}

async function listLogs(instanceId: string, request: ListLogsRequest): ListLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLogsWithOptions(instanceId, request, headers, runtime);
}

async function listLogsWithOptions(instanceId: string, request: ListLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLogsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.queryParams)) {
    query.queryParams = request.queryParams;
  }
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogs',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/logs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMixCategoriesResponseBody = {
  result?: [ 
    {
      categories?: [ long ](name='categories'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListMixCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: ListMixCategoriesResponseBody(name='body'),
}

async function listMixCategories(): ListMixCategoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMixCategoriesWithOptions(headers, runtime);
}

async function listMixCategoriesWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListMixCategoriesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListMixCategories',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/configurations/mixCategories`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRankingModelsRequest {
  rankingModelId?: string(name='rankingModelId'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListRankingModelsResponseBody = {
  result?: [ 
    {
      rankingModelId?: string(name='rankingModelId'),
      gmtModified?: string(name='gmtModified'),
      gmtCreate?: string(name='gmtCreate'),
      meta?: map[string]any(name='meta'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListRankingModelsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRankingModelsResponseBody(name='body'),
}

async function listRankingModels(instanceId: string, request: ListRankingModelsRequest): ListRankingModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRankingModelsWithOptions(instanceId, request, headers, runtime);
}

async function listRankingModelsWithOptions(instanceId: string, request: ListRankingModelsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRankingModelsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.rankingModelId)) {
    query.rankingModelId = request.rankingModelId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRankingModels',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRuleConditionsResponseBody = {
  result?: [ 
    {
      selectType?: string(name='selectType'),
      selectValue?: string(name='selectValue'),
      selectionOperation?: string(name='selectionOperation'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListRuleConditionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListRuleConditionsResponseBody(name='body'),
}

async function listRuleConditions(instanceId: string): ListRuleConditionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRuleConditionsWithOptions(instanceId, headers, runtime);
}

async function listRuleConditionsWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListRuleConditionsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListRuleConditions',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rule-conditions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRulesRequest {
  sceneId?: string(name='sceneId'),
  ruleType?: string(name='ruleType'),
  status?: string(name='status'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
}

model ListRulesResponseBody = {
  result?: [ 
    {
      ruleId?: string(name='ruleId'),
      gmtModified?: string(name='gmtModified'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListRulesResponse = {
  headers: map[string]string(name='headers'),
  body: ListRulesResponseBody(name='body'),
}

async function listRules(instanceId: string, request: ListRulesRequest): ListRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRulesWithOptions(instanceId, request, headers, runtime);
}

async function listRulesWithOptions(instanceId: string, request: ListRulesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRulesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.ruleType)) {
    query.ruleType = request.ruleType;
  }
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRules',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rules`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRuleTasksRequest {
  sceneId?: string(name='sceneId'),
}

model ListRuleTasksResponseBody = {
  result?: {
    finishTime?: int32(name='finishTime'),
    finishRate?: int32(name='finishRate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListRuleTasksResponse = {
  headers: map[string]string(name='headers'),
  body: ListRuleTasksResponseBody(name='body'),
}

async function listRuleTasks(instanceId: string, request: ListRuleTasksRequest): ListRuleTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRuleTasksWithOptions(instanceId, request, headers, runtime);
}

async function listRuleTasksWithOptions(instanceId: string, request: ListRuleTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRuleTasksResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRuleTasks',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rule-tasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSceneItemsRequest {
  operationRuleId?: string(name='operationRuleId'),
  selectionRuleId?: string(name='selectionRuleId'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  previewType?: string(name='previewType'),
  queryCount?: int32(name='queryCount'),
}

model ListSceneItemsResponseBody = {
  result?: {
    total?: {
      totalCount?: long(name='totalCount'),
      sceneWeightItem?: long(name='sceneWeightItem'),
      sceneRecommendItem?: long(name='sceneRecommendItem'),
      weightItem?: long(name='weightItem'),
      instanceRecommendItem?: long(name='instanceRecommendItem'),
    }(name='total'),
    detail?: [ 
      {
        title?: string(name='title'),
        categoryPath?: string(name='categoryPath'),
        itemId?: string(name='itemId'),
        itemType?: string(name='itemType'),
        status?: string(name='status'),
        brandId?: string(name='brandId'),
        shopId?: string(name='shopId'),
        pubTime?: string(name='pubTime'),
        channel?: string(name='channel'),
        duration?: string(name='duration'),
        author?: string(name='author'),
        expireTime?: string(name='expireTime'),
      }
    ](name='detail'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListSceneItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ListSceneItemsResponseBody(name='body'),
}

async function listSceneItems(instanceId: string, sceneId: string, request: ListSceneItemsRequest): ListSceneItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSceneItemsWithOptions(instanceId, sceneId, request, headers, runtime);
}

async function listSceneItemsWithOptions(instanceId: string, sceneId: string, request: ListSceneItemsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSceneItemsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.operationRuleId)) {
    query.operationRuleId = request.operationRuleId;
  }
  if (!Util.isUnset(request.selectionRuleId)) {
    query.selectionRuleId = request.selectionRuleId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.previewType)) {
    query.previewType = request.previewType;
  }
  if (!Util.isUnset(request.queryCount)) {
    query.queryCount = request.queryCount;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSceneItems',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/items`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSceneParametersResponseBody = {
  result?: {
    traceId?: [ string ](name='traceId'),
    sceneId?: [ string ](name='sceneId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListSceneParametersResponse = {
  headers: map[string]string(name='headers'),
  body: ListSceneParametersResponseBody(name='body'),
}

async function listSceneParameters(instanceId: string): ListSceneParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSceneParametersWithOptions(instanceId, headers, runtime);
}

async function listSceneParametersWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSceneParametersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSceneParameters',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dashboard/scene-parameters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListScenesRequest {
  status?: string(name='status'),
  sceneId?: string(name='sceneId'),
  page?: int32(name='page'),
  size?: int32(name='size'),
}

model ListScenesResponseBody = {
  result?: [ 
    {
      sceneId?: string(name='sceneId'),
      gmtModified?: string(name='gmtModified'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListScenesResponse = {
  headers: map[string]string(name='headers'),
  body: ListScenesResponseBody(name='body'),
}

async function listScenes(instanceId: string, request: ListScenesRequest): ListScenesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listScenesWithOptions(instanceId, request, headers, runtime);
}

async function listScenesWithOptions(instanceId: string, request: ListScenesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListScenesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.status)) {
    query.status = request.status;
  }
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListScenes',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUmengAppkeysResponseBody = {
  result?: [ 
    {
      appkey?: string(name='appkey'),
      platform?: string(name='platform'),
      name?: string(name='name'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ListUmengAppkeysResponse = {
  headers: map[string]string(name='headers'),
  body: ListUmengAppkeysResponseBody(name='body'),
}

async function listUmengAppkeys(): ListUmengAppkeysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUmengAppkeysWithOptions(headers, runtime);
}

async function listUmengAppkeysWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListUmengAppkeysResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListUmengAppkeys',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/umeng/appkeys`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUserClustersResponseBody = {
  result?: [ 
    {
      gmtModified?: string(name='gmtModified'),
      status?: string(name='status'),
      gmtCreate?: string(name='gmtCreate'),
      name?: string(name='name'),
      meta?: {
        metaType?: string(name='metaType'),
        description?: string(name='description'),
      }(name='meta'),
    }
  ](name='result'),
  headers?: {
    xTotalCount?: int32(name='X-Total-Count'),
  }(name='headers'),
  requestId?: string(name='requestId'),
}

model ListUserClustersResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserClustersResponseBody(name='body'),
}

async function listUserClusters(instanceId: string): ListUserClustersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUserClustersWithOptions(instanceId, headers, runtime);
}

async function listUserClustersWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListUserClustersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListUserClusters',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/user-clusters`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyDataSourceResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    gmtCreate?: string(name='gmtCreate'),
    tableName?: string(name='tableName'),
    meta?: {
      bucketName?: string(name='bucketName'),
      accessKeyId?: string(name='accessKeyId'),
      type?: string(name='type'),
      partition?: string(name='partition'),
      timestamp?: long(name='timestamp'),
      path?: string(name='path'),
      tableName?: string(name='tableName'),
      projectName?: string(name='projectName'),
    }(name='meta'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ModifyDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDataSourceResponseBody(name='body'),
}

async function modifyDataSource(instanceId: string, tableName: string): ModifyDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyDataSourceWithOptions(instanceId, tableName, headers, runtime);
}

async function modifyDataSourceWithOptions(instanceId: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyDataSourceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyDataSource',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSources/{tableName}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyFilteringAlgorithmMetaResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    algorithmId?: string(name='algorithmId'),
    meta?: {
      taskId?: string(name='taskId'),
      metaType?: string(name='metaType'),
      type?: string(name='type'),
      extInfo?: {
        kvSeparator?: string(name='kvSeparator'),
        itemSeparator?: string(name='itemSeparator'),
      }(name='extInfo'),
      category?: string(name='category'),
      threshold?: {
        sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
        sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
        indexSizeThreshold?: int32(name='indexSizeThreshold'),
        indexLossThreshold?: int32(name='indexLossThreshold'),
      }(name='threshold'),
      tableName?: string(name='tableName'),
      clusterId?: string(name='clusterId'),
      cron?: string(name='cron'),
      description?: string(name='description'),
      projectName?: string(name='projectName'),
      algorithmName?: string(name='algorithmName'),
      cronEnabled?: boolean(name='cronEnabled'),
    }(name='meta'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model ModifyFilteringAlgorithmMetaResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyFilteringAlgorithmMetaResponseBody(name='body'),
}

async function modifyFilteringAlgorithmMeta(instanceId: string, algorithmId: string): ModifyFilteringAlgorithmMetaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyFilteringAlgorithmMetaWithOptions(instanceId, algorithmId, headers, runtime);
}

async function modifyFilteringAlgorithmMetaWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyFilteringAlgorithmMetaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyFilteringAlgorithmMeta',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/meta`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyInstanceResponseBody = {
  result?: {
    regionId?: string(name='regionId'),
    type?: string(name='type'),
    lockMode?: string(name='lockMode'),
    expiredTime?: string(name='expiredTime'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    chargeType?: string(name='chargeType'),
    industry?: string(name='industry'),
    commodityCode?: string(name='commodityCode'),
    gmtModified?: string(name='gmtModified'),
    dataSetVersion?: string(name='dataSetVersion'),
    name?: string(name='name'),
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ModifyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceResponseBody(name='body'),
}

async function modifyInstance(instanceId: string): ModifyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyInstanceWithOptions(instanceId, headers, runtime);
}

async function modifyInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyItemsResponseBody = {
  result?: boolean(name='result'),
  requestId?: string(name='requestId'),
}

model ModifyItemsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyItemsResponseBody(name='body'),
}

async function modifyItems(instanceId: string): ModifyItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyItemsWithOptions(instanceId, headers, runtime);
}

async function modifyItemsWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyItemsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyItems',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/items`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyRankingModelResponseBody = {
  result?: {
    rankingModelId?: string(name='rankingModelId'),
    gmtModified?: string(name='gmtModified'),
    gmtCreate?: string(name='gmtCreate'),
    meta?: map[string]any(name='meta'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ModifyRankingModelResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRankingModelResponseBody(name='body'),
}

async function modifyRankingModel(instanceId: string, rankingModelId: string): ModifyRankingModelResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyRankingModelWithOptions(instanceId, rankingModelId, headers, runtime);
}

async function modifyRankingModelWithOptions(instanceId: string, rankingModelId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyRankingModelResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyRankingModel',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/ranking-models/{rankingModelId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifyRuleResponseBody = {
  result?: {
    ruleId?: string(name='ruleId'),
    ruleMeta?: map[string]any(name='ruleMeta'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ModifyRuleResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyRuleResponseBody(name='body'),
}

async function modifyRule(instanceId: string, ruleId: string): ModifyRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifyRuleWithOptions(instanceId, ruleId, headers, runtime);
}

async function modifyRuleWithOptions(instanceId: string, ruleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifyRuleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyRule',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rules/{ruleId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ModifySceneResponseBody = {
  result?: {
    sceneId?: string(name='sceneId'),
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ModifySceneResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySceneResponseBody(name='body'),
}

async function modifyScene(instanceId: string, sceneId: string): ModifySceneResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return modifySceneWithOptions(instanceId, sceneId, headers, runtime);
}

async function modifySceneWithOptions(instanceId: string, sceneId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ModifySceneResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ModifyScene',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model OfflineFilteringAlgorithmResponseBody = {
  result?: {
    gmtModified?: string(name='gmtModified'),
    status?: string(name='status'),
    gmtCreate?: string(name='gmtCreate'),
    algorithmId?: string(name='algorithmId'),
    meta?: {
      taskId?: string(name='taskId'),
      metaType?: string(name='metaType'),
      type?: string(name='type'),
      extInfo?: {
        kvSeparator?: string(name='kvSeparator'),
        itemSeparator?: string(name='itemSeparator'),
      }(name='extInfo'),
      category?: string(name='category'),
      threshold?: {
        sourceDataSizeThreshold?: int32(name='sourceDataSizeThreshold'),
        sourceDataRecordThreshold?: int32(name='sourceDataRecordThreshold'),
        indexSizeThreshold?: int32(name='indexSizeThreshold'),
        indexLossThreshold?: int32(name='indexLossThreshold'),
      }(name='threshold'),
      tableName?: string(name='tableName'),
      clusterId?: string(name='clusterId'),
      cron?: string(name='cron'),
      description?: string(name='description'),
      projectName?: string(name='projectName'),
      algorithmName?: string(name='algorithmName'),
      cronEnabled?: boolean(name='cronEnabled'),
    }(name='meta'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model OfflineFilteringAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  body: OfflineFilteringAlgorithmResponseBody(name='body'),
}

async function offlineFilteringAlgorithm(instanceId: string, algorithmId: string): OfflineFilteringAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return offlineFilteringAlgorithmWithOptions(instanceId, algorithmId, headers, runtime);
}

async function offlineFilteringAlgorithmWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): OfflineFilteringAlgorithmResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'OfflineFilteringAlgorithm',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/actions/offline`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PublishRuleRequest {
  ruleType?: string(name='ruleType'),
  sceneId?: string(name='sceneId'),
}

model PublishRuleResponseBody = {
  result?: {
    ruleId?: string(name='ruleId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model PublishRuleResponse = {
  headers: map[string]string(name='headers'),
  body: PublishRuleResponseBody(name='body'),
}

async function publishRule(ruleId: string, instanceId: string, request: PublishRuleRequest): PublishRuleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return publishRuleWithOptions(ruleId, instanceId, request, headers, runtime);
}

async function publishRuleWithOptions(ruleId: string, instanceId: string, request: PublishRuleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): PublishRuleResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.ruleType)) {
    query.ruleType = request.ruleType;
  }
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PublishRule',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/rules/{ruleId}/actions/publish`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PushDocumentResponseBody = {
  result?: boolean(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model PushDocumentResponse = {
  headers: map[string]string(name='headers'),
  body: PushDocumentResponseBody(name='body'),
}

async function pushDocument(instanceId: string, tableName: string): PushDocumentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pushDocumentWithOptions(instanceId, tableName, headers, runtime);
}

async function pushDocumentWithOptions(instanceId: string, tableName: string, headers: map[string]string, runtime: Util.RuntimeOptions): PushDocumentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PushDocument',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/tables/{tableName}/actions/bulk`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model PushInterventionResponseBody = {
  result?: boolean(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model PushInterventionResponse = {
  headers: map[string]string(name='headers'),
  body: PushInterventionResponseBody(name='body'),
}

async function pushIntervention(instanceId: string): PushInterventionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return pushInterventionWithOptions(instanceId, headers, runtime);
}

async function pushInterventionWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): PushInterventionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'PushIntervention',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/intervene`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryDataMessageRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  cmdType?: string(name='cmdType'),
  itemId?: string(name='itemId'),
  itemType?: string(name='itemType'),
  userId?: string(name='userId'),
  userType?: string(name='userType'),
  page?: int32(name='page'),
  size?: int32(name='size'),
  traceId?: string(name='traceId'),
  sceneId?: string(name='sceneId'),
  bhvType?: string(name='bhvType'),
  messageSource?: string(name='messageSource'),
}

model QueryDataMessageResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QueryDataMessageResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataMessageResponseBody(name='body'),
}

async function queryDataMessage(instanceId: string, table: string, request: QueryDataMessageRequest): QueryDataMessageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryDataMessageWithOptions(instanceId, table, request, headers, runtime);
}

async function queryDataMessageWithOptions(instanceId: string, table: string, request: QueryDataMessageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryDataMessageResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.cmdType)) {
    query.cmdType = request.cmdType;
  }
  if (!Util.isUnset(request.itemId)) {
    query.itemId = request.itemId;
  }
  if (!Util.isUnset(request.itemType)) {
    query.itemType = request.itemType;
  }
  if (!Util.isUnset(request.userId)) {
    query.userId = request.userId;
  }
  if (!Util.isUnset(request.userType)) {
    query.userType = request.userType;
  }
  if (!Util.isUnset(request.page)) {
    query.page = request.page;
  }
  if (!Util.isUnset(request.size)) {
    query.size = request.size;
  }
  if (!Util.isUnset(request.traceId)) {
    query.traceId = request.traceId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.bhvType)) {
    query.bhvType = request.bhvType;
  }
  if (!Util.isUnset(request.messageSource)) {
    query.messageSource = request.messageSource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataMessage',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/tables/{table}/data-message`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryDataMessageStatisticsRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  cmdType?: string(name='cmdType'),
  itemId?: string(name='itemId'),
  itemType?: string(name='itemType'),
  userId?: string(name='userId'),
  userType?: string(name='userType'),
  traceId?: string(name='traceId'),
  sceneId?: string(name='sceneId'),
  bhvType?: string(name='bhvType'),
  messageSource?: string(name='messageSource'),
}

model QueryDataMessageStatisticsResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QueryDataMessageStatisticsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDataMessageStatisticsResponseBody(name='body'),
}

async function queryDataMessageStatistics(instanceId: string, table: string, request: QueryDataMessageStatisticsRequest): QueryDataMessageStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryDataMessageStatisticsWithOptions(instanceId, table, request, headers, runtime);
}

async function queryDataMessageStatisticsWithOptions(instanceId: string, table: string, request: QueryDataMessageStatisticsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryDataMessageStatisticsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.cmdType)) {
    query.cmdType = request.cmdType;
  }
  if (!Util.isUnset(request.itemId)) {
    query.itemId = request.itemId;
  }
  if (!Util.isUnset(request.itemType)) {
    query.itemType = request.itemType;
  }
  if (!Util.isUnset(request.userId)) {
    query.userId = request.userId;
  }
  if (!Util.isUnset(request.userType)) {
    query.userType = request.userType;
  }
  if (!Util.isUnset(request.traceId)) {
    query.traceId = request.traceId;
  }
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.bhvType)) {
    query.bhvType = request.bhvType;
  }
  if (!Util.isUnset(request.messageSource)) {
    query.messageSource = request.messageSource;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryDataMessageStatistics',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/tables/{table}/data-message-statistics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryExceptionHistoryRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
  type?: string(name='type'),
}

model QueryExceptionHistoryResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QueryExceptionHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: QueryExceptionHistoryResponseBody(name='body'),
}

async function queryExceptionHistory(instanceId: string, request: QueryExceptionHistoryRequest): QueryExceptionHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryExceptionHistoryWithOptions(instanceId, request, headers, runtime);
}

async function queryExceptionHistoryWithOptions(instanceId: string, request: QueryExceptionHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryExceptionHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }
  if (!Util.isUnset(request.type)) {
    query.type = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryExceptionHistory',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/exception-history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QueryRawDataRequest {
  itemId?: string(name='itemId'),
  itemType?: string(name='itemType'),
  userId?: string(name='userId'),
  userType?: string(name='userType'),
}

model QueryRawDataResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  message?: string(name='Message'),
  requestId?: string(name='requestId'),
}

model QueryRawDataResponse = {
  headers: map[string]string(name='headers'),
  body: QueryRawDataResponseBody(name='body'),
}

async function queryRawData(instanceId: string, table: string, request: QueryRawDataRequest): QueryRawDataResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return queryRawDataWithOptions(instanceId, table, request, headers, runtime);
}

async function queryRawDataWithOptions(instanceId: string, table: string, request: QueryRawDataRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QueryRawDataResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.itemId)) {
    query.itemId = request.itemId;
  }
  if (!Util.isUnset(request.itemType)) {
    query.itemType = request.itemType;
  }
  if (!Util.isUnset(request.userId)) {
    query.userId = request.userId;
  }
  if (!Util.isUnset(request.userType)) {
    query.userType = request.userType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QueryRawData',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/tables/{table}/raw-data`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySingleAggregationReportResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QuerySingleAggregationReportResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySingleAggregationReportResponseBody(name='body'),
}

async function querySingleAggregationReport(instanceId: string): QuerySingleAggregationReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySingleAggregationReportWithOptions(instanceId, headers, runtime);
}

async function querySingleAggregationReportWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySingleAggregationReportResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'QuerySingleAggregationReport',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/single-aggregation-report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySingleReportRequest {
  reportType?: string(name='reportType'),
}

model QuerySingleReportResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QuerySingleReportResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySingleReportResponseBody(name='body'),
}

async function querySingleReport(instanceId: string, request: QuerySingleReportRequest): QuerySingleReportResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySingleReportWithOptions(instanceId, request, headers, runtime);
}

async function querySingleReportWithOptions(instanceId: string, request: QuerySingleReportRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySingleReportResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.reportType)) {
    query.reportType = request.reportType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySingleReport',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/single-report`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model QuerySyncReportAggregationRequest {
  startTime?: long(name='startTime'),
  endTime?: long(name='endTime'),
}

model QuerySyncReportAggregationResponseBody = {
  result?: map[string]any(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model QuerySyncReportAggregationResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySyncReportAggregationResponseBody(name='body'),
}

async function querySyncReportAggregation(instanceId: string, request: QuerySyncReportAggregationRequest): QuerySyncReportAggregationResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return querySyncReportAggregationWithOptions(instanceId, request, headers, runtime);
}

async function querySyncReportAggregationWithOptions(instanceId: string, request: QuerySyncReportAggregationRequest, headers: map[string]string, runtime: Util.RuntimeOptions): QuerySyncReportAggregationResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.startTime)) {
    query.startTime = request.startTime;
  }
  if (!Util.isUnset(request.endTime)) {
    query.endTime = request.endTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'QuerySyncReportAggregation',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/sync-reports/aggregation`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RebuildIndexResponseBody = {
  result?: string(name='result'),
  requestId?: string(name='requestId'),
}

model RebuildIndexResponse = {
  headers: map[string]string(name='headers'),
  body: RebuildIndexResponseBody(name='body'),
}

async function rebuildIndex(instanceId: string, algorithmId: string): RebuildIndexResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rebuildIndexWithOptions(instanceId, algorithmId, headers, runtime);
}

async function rebuildIndexWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RebuildIndexResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RebuildIndex',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/actions/rebuild`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RecommendRequest {
  sceneId?: string(name='sceneId'),
  userId?: string(name='userId'),
  ip?: string(name='ip'),
  imei?: string(name='imei'),
  returnCount?: int32(name='returnCount'),
  items?: string(name='items'),
  serviceType?: string(name='serviceType'),
  userInfo?: string(name='userInfo'),
}

model RecommendResponseBody = {
  result?: [ 
    {
      matchInfo?: string(name='matchInfo'),
      traceId?: string(name='traceId'),
      position?: int32(name='position'),
      itemId?: string(name='itemId'),
      itemType?: string(name='itemType'),
      traceInfo?: string(name='traceInfo'),
      weight?: float(name='weight'),
    }
  ](name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model RecommendResponse = {
  headers: map[string]string(name='headers'),
  body: RecommendResponseBody(name='body'),
}

async function recommend(instanceId: string, request: RecommendRequest): RecommendResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return recommendWithOptions(instanceId, request, headers, runtime);
}

async function recommendWithOptions(instanceId: string, request: RecommendRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RecommendResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.sceneId)) {
    query.sceneId = request.sceneId;
  }
  if (!Util.isUnset(request.userId)) {
    query.userId = request.userId;
  }
  if (!Util.isUnset(request.ip)) {
    query.ip = request.ip;
  }
  if (!Util.isUnset(request.imei)) {
    query.imei = request.imei;
  }
  if (!Util.isUnset(request.returnCount)) {
    query.returnCount = request.returnCount;
  }
  if (!Util.isUnset(request.items)) {
    query.items = request.items;
  }
  if (!Util.isUnset(request.serviceType)) {
    query.serviceType = request.serviceType;
  }
  if (!Util.isUnset(request.userInfo)) {
    query.userInfo = request.userInfo;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'Recommend',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/recommend`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RunInstanceResponseBody = {
  result?: boolean(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model RunInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RunInstanceResponseBody(name='body'),
}

async function runInstance(instanceId: string): RunInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return runInstanceWithOptions(instanceId, headers, runtime);
}

async function runInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): RunInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RunInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/import`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model StopDataSetResponseBody = {
  result?: {
    versionId?: string(name='versionId'),
    state?: string(name='state'),
    gmtModified?: long(name='gmtModified'),
    gmtCreate?: long(name='gmtCreate'),
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model StopDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: StopDataSetResponseBody(name='body'),
}

async function stopDataSet(instanceId: string, versionId: string): StopDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return stopDataSetWithOptions(instanceId, versionId, headers, runtime);
}

async function stopDataSetWithOptions(instanceId: string, versionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): StopDataSetResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'StopDataSet',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/dataSets/{versionId}/actions/stop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UnLockIndexVersionResponseBody = {
  result?: boolean(name='result'),
  requestId?: string(name='requestId'),
}

model UnLockIndexVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UnLockIndexVersionResponseBody(name='body'),
}

async function unLockIndexVersion(instanceId: string, algorithmId: string): UnLockIndexVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return unLockIndexVersionWithOptions(instanceId, algorithmId, headers, runtime);
}

async function unLockIndexVersionWithOptions(instanceId: string, algorithmId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UnLockIndexVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UnLockIndexVersion',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/filtering-algorithms/{algorithmId}/actions/unlock`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentBasicInfoResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model UpdateExperimentBasicInfoResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentBasicInfoResponseBody(name='body'),
}

async function updateExperimentBasicInfo(instanceId: string, sceneId: string, experimentId: string): UpdateExperimentBasicInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentBasicInfoWithOptions(instanceId, sceneId, experimentId, headers, runtime);
}

async function updateExperimentBasicInfoWithOptions(instanceId: string, sceneId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentBasicInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentBasicInfo',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}/basic`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentConfigResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model UpdateExperimentConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentConfigResponseBody(name='body'),
}

async function updateExperimentConfig(instanceId: string, sceneId: string, experimentId: string): UpdateExperimentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentConfigWithOptions(instanceId, sceneId, experimentId, headers, runtime);
}

async function updateExperimentConfigWithOptions(instanceId: string, sceneId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentConfig',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}/config`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateExperimentStatusResponseBody = {
  result?: {
    base?: boolean(name='base'),
    onlineTime?: string(name='onlineTime'),
    offlineTime?: string(name='offlineTime'),
    description?: string(name='description'),
    status?: string(name='status'),
    name?: string(name='name'),
    algorithms?: [ 
      {
        key?: string(name='key'),
        config?: [ 
          {
            key?: string(name='key'),
            defaultValue?: string(name='defaultValue'),
            experimentValue?: string(name='experimentValue'),
            name?: string(name='name'),
          }
        ](name='config'),
        defaultValue?: string(name='defaultValue'),
        type?: string(name='type'),
        experimentValue?: string(name='experimentValue'),
        hasConfig?: boolean(name='hasConfig'),
        category?: string(name='category'),
        name?: string(name='name'),
      }
    ](name='algorithms'),
    buckets?: [ string ](name='buckets'),
    experimentId?: string(name='experimentId'),
  }(name='result'),
  requestId?: string(name='requestId'),
}

model UpdateExperimentStatusResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateExperimentStatusResponseBody(name='body'),
}

async function updateExperimentStatus(instanceId: string, sceneId: string, experimentId: string): UpdateExperimentStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateExperimentStatusWithOptions(instanceId, sceneId, experimentId, headers, runtime);
}

async function updateExperimentStatusWithOptions(instanceId: string, sceneId: string, experimentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateExperimentStatusResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateExperimentStatus',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/scenes/{sceneId}/experiments/{experimentId}/status`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpgradeInstanceResponseBody = {
  result?: {
    instanceId?: string(name='instanceId'),
  }(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model UpgradeInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeInstanceResponseBody(name='body'),
}

async function upgradeInstance(instanceId: string): UpgradeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upgradeInstanceWithOptions(instanceId, headers, runtime);
}

async function upgradeInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpgradeInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpgradeInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/upgrade`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ValidateInstanceResponseBody = {
  result?: boolean(name='result'),
  code?: string(name='code'),
  requestId?: string(name='requestId'),
  message?: string(name='message'),
}

model ValidateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ValidateInstanceResponseBody(name='body'),
}

async function validateInstance(instanceId: string): ValidateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return validateInstanceWithOptions(instanceId, headers, runtime);
}

async function validateInstanceWithOptions(instanceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ValidateInstanceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ValidateInstance',
    version = '2020-11-26',
    protocol = 'HTTPS',
    pathname = `/v2/openapi/instances/${instanceId}/actions/validate`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

