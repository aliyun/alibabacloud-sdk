/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('tablestore', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model GetInstanceRequest {
  instanceName?: string(name='InstanceName'),
}

model GetInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  instanceName?: string(name='InstanceName'),
  regionId?: string(name='RegionId'),
  SPInstanceId?: string(name='SPInstanceId'),
  aliasName?: string(name='AliasName'),
  userId?: string(name='UserId'),
  network?: string(name='Network'),
  instanceDescription?: string(name='InstanceDescription'),
  instanceSpecification?: string(name='InstanceSpecification'),
  paymentType?: string(name='PaymentType'),
  storageType?: string(name='StorageType'),
  VCUQuota?: int32(name='VCUQuota'),
  tableQuota?: int32(name='TableQuota'),
  instanceStatus?: string(name='InstanceStatus'),
  createTime?: string(name='CreateTime'),
  tags?: [ 
    {
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='Tags'),
}

model GetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceResponseBody(name='body'),
}

async function getInstance(request: GetInstanceRequest): GetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getInstanceWithOptions(request, headers, runtime);
}

async function getInstanceWithOptions(request: GetInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetInstanceResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.instanceName)) {
    query.InstanceName = request.instanceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('GetInstance', '2020-12-09', 'HTTPS', 'GET', 'AK', `/v2/openapi/getinstance`, 'json', req, runtime);
}

model DescribeRegionsRequest {
  clientToken?: string(name='ClientToken', description='幂等参数'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='requestId', description='Id of the request'),
  regions?: [ 
    {
      regionId?: string(name='RegionId', description='region id'),
      i18nKey?: string(name='I18nKey', description='region key'),
    }
  ](name='Regions', description='region list'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return describeRegionsWithOptions(request, headers, runtime);
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.clientToken)) {
    query.ClientToken = request.clientToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('DescribeRegions', '2020-12-09', 'HTTPS', 'GET', 'AK', `/region/DescribeRegions`, 'json', req, runtime);
}

model ListInstancesRequest {
  status?: string(name='Status'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListInstancesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  totalCount?: long(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  instances?: [ 
    {
      instanceName?: string(name='InstanceName', description='实例名称，唯一键'),
      resourceGroupId?: string(name='ResourceGroupId', description='资源组id'),
      regionId?: string(name='RegionId'),
      SPInstanceId?: string(name='SPInstanceId'),
      aliasName?: string(name='AliasName'),
      userId?: string(name='UserId'),
      instanceDescription?: string(name='InstanceDescription'),
      instanceSpecification?: string(name='InstanceSpecification'),
      paymentType?: string(name='PaymentType'),
      storageType?: string(name='StorageType'),
      VCUQuota?: int32(name='VCUQuota'),
      instanceStatus?: string(name='InstanceStatus'),
      createTime?: string(name='CreateTime'),
    }
  ](name='Instances'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInstancesWithOptions(request, headers, runtime);
}

async function listInstancesWithOptions(request: ListInstancesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query : map[string]any= {};
  if (!Util.isUnset(request.status)) {
    query.Status = request.status;
  }
  if (!Util.isUnset(request.maxResults)) {
    query.MaxResults = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query.NextToken = request.nextToken;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  return doROARequest('ListInstances', '2020-12-09', 'HTTPS', 'GET', 'AK', `/v2/openapi/listinstances`, 'json', req, runtime);
}

model UpdateInstanceRequest {
  instanceName?: string(name='InstanceName'),
  aliasName?: string(name='AliasName'),
  instanceDescription?: string(name='InstanceDescription'),
  network?: string(name='Network'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateInstanceWithOptions(request, headers, runtime);
}

async function updateInstanceWithOptions(request: UpdateInstanceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceName)) {
    body.InstanceName = request.instanceName;
  }
  if (!Util.isUnset(request.aliasName)) {
    body.AliasName = request.aliasName;
  }
  if (!Util.isUnset(request.instanceDescription)) {
    body.InstanceDescription = request.instanceDescription;
  }
  if (!Util.isUnset(request.network)) {
    body.Network = request.network;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  return doROARequest('UpdateInstance', '2020-12-09', 'HTTPS', 'POST', 'AK', `/v2/openapi/updateinstance`, 'json', req, runtime);
}

