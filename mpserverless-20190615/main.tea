/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('mpserverless', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddCorsDomainRequest {
  domain?: string(name='Domain'),
  spaceId?: string(name='SpaceId'),
}

model AddCorsDomainResponseBody = {
  domainId?: string(name='DomainId'),
  requestId?: string(name='RequestId'),
}

model AddCorsDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCorsDomainResponseBody(name='body'),
}

async function addCorsDomainWithOptions(request: AddCorsDomainRequest, runtime: Util.RuntimeOptions): AddCorsDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddCorsDomain',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCorsDomain(request: AddCorsDomainRequest): AddCorsDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCorsDomainWithOptions(request, runtime);
}

model AddDingtalkOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  appSecret?: string(name='AppSecret'),
  spaceId?: string(name='SpaceId'),
}

model AddDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function addDingtalkOpenPlatformConfigWithOptions(request: AddDingtalkOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): AddDingtalkOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDingtalkOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDingtalkOpenPlatformConfig(request: AddDingtalkOpenPlatformConfigRequest): AddDingtalkOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDingtalkOpenPlatformConfigWithOptions(request, runtime);
}

model AttachWebHostingCertificateRequest {
  certName?: string(name='CertName'),
  certType?: string(name='CertType'),
  domain?: string(name='Domain'),
  privateKey?: string(name='PrivateKey'),
  serverCertificate?: string(name='ServerCertificate'),
  spaceId?: string(name='SpaceId'),
}

model AttachWebHostingCertificateResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model AttachWebHostingCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AttachWebHostingCertificateResponseBody(name='body'),
}

async function attachWebHostingCertificateWithOptions(request: AttachWebHostingCertificateRequest, runtime: Util.RuntimeOptions): AttachWebHostingCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.certName)) {
    body['CertName'] = request.certName;
  }
  if (!Util.isUnset(request.certType)) {
    body['CertType'] = request.certType;
  }
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.privateKey)) {
    body['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.serverCertificate)) {
    body['ServerCertificate'] = request.serverCertificate;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AttachWebHostingCertificate',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function attachWebHostingCertificate(request: AttachWebHostingCertificateRequest): AttachWebHostingCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return attachWebHostingCertificateWithOptions(request, runtime);
}

model BatchDeleteWebHostingFilesRequest {
  filePaths?: [ string ](name='FilePaths'),
  spaceId?: string(name='SpaceId'),
}

model BatchDeleteWebHostingFilesResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteWebHostingFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteWebHostingFilesResponseBody(name='body'),
}

async function batchDeleteWebHostingFilesWithOptions(request: BatchDeleteWebHostingFilesRequest, runtime: Util.RuntimeOptions): BatchDeleteWebHostingFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filePaths)) {
    body['FilePaths'] = request.filePaths;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteWebHostingFiles',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteWebHostingFiles(request: BatchDeleteWebHostingFilesRequest): BatchDeleteWebHostingFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteWebHostingFilesWithOptions(request, runtime);
}

model BindWebHostingCustomDomainRequest {
  customDomain?: string(name='CustomDomain'),
  spaceId?: string(name='SpaceId'),
}

model BindWebHostingCustomDomainResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model BindWebHostingCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindWebHostingCustomDomainResponseBody(name='body'),
}

async function bindWebHostingCustomDomainWithOptions(request: BindWebHostingCustomDomainRequest, runtime: Util.RuntimeOptions): BindWebHostingCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customDomain)) {
    body['CustomDomain'] = request.customDomain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindWebHostingCustomDomain',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindWebHostingCustomDomain(request: BindWebHostingCustomDomainRequest): BindWebHostingCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindWebHostingCustomDomainWithOptions(request, runtime);
}

model CheckMpServerlessRoleExistsRequest {
  roleName?: string(name='RoleName'),
}

model CheckMpServerlessRoleExistsResponseBody = {
  exists?: boolean(name='Exists'),
  requestId?: string(name='RequestId'),
}

model CheckMpServerlessRoleExistsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckMpServerlessRoleExistsResponseBody(name='body'),
}

async function checkMpServerlessRoleExistsWithOptions(request: CheckMpServerlessRoleExistsRequest, runtime: Util.RuntimeOptions): CheckMpServerlessRoleExistsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.roleName)) {
    query['RoleName'] = request.roleName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckMpServerlessRoleExists',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkMpServerlessRoleExists(request: CheckMpServerlessRoleExistsRequest): CheckMpServerlessRoleExistsResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkMpServerlessRoleExistsWithOptions(request, runtime);
}

model CreateDBExportTaskRequest {
  collection?: string(name='Collection'),
  fields?: string(name='Fields'),
  fileType?: string(name='FileType'),
  spaceId?: string(name='SpaceId'),
}

model CreateDBExportTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateDBExportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBExportTaskResponseBody(name='body'),
}

async function createDBExportTaskWithOptions(request: CreateDBExportTaskRequest, runtime: Util.RuntimeOptions): CreateDBExportTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.collection)) {
    body['Collection'] = request.collection;
  }
  if (!Util.isUnset(request.fields)) {
    body['Fields'] = request.fields;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBExportTask',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBExportTask(request: CreateDBExportTaskRequest): CreateDBExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBExportTaskWithOptions(request, runtime);
}

model CreateDBImportTaskRequest {
  collection?: string(name='Collection'),
  fileType?: string(name='FileType'),
  mode?: string(name='Mode'),
  spaceId?: string(name='SpaceId'),
}

model CreateDBImportTaskResponseBody = {
  accessKeyId?: string(name='AccessKeyId'),
  expireTime?: string(name='ExpireTime'),
  fileKey?: string(name='FileKey'),
  host?: string(name='Host'),
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
  signature?: string(name='Signature'),
  taskId?: string(name='TaskId'),
}

model CreateDBImportTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBImportTaskResponseBody(name='body'),
}

async function createDBImportTaskWithOptions(request: CreateDBImportTaskRequest, runtime: Util.RuntimeOptions): CreateDBImportTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.collection)) {
    body['Collection'] = request.collection;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.mode)) {
    body['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBImportTask',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBImportTask(request: CreateDBImportTaskRequest): CreateDBImportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBImportTaskWithOptions(request, runtime);
}

model CreateDBRestoreTaskRequest {
  backupId?: string(name='BackupId'),
  newCollections?: string(name='NewCollections'),
  originCollections?: string(name='OriginCollections'),
  spaceId?: string(name='SpaceId'),
}

model CreateDBRestoreTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateDBRestoreTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBRestoreTaskResponseBody(name='body'),
}

async function createDBRestoreTaskWithOptions(request: CreateDBRestoreTaskRequest, runtime: Util.RuntimeOptions): CreateDBRestoreTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.backupId)) {
    body['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.newCollections)) {
    body['NewCollections'] = request.newCollections;
  }
  if (!Util.isUnset(request.originCollections)) {
    body['OriginCollections'] = request.originCollections;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBRestoreTask',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBRestoreTask(request: CreateDBRestoreTaskRequest): CreateDBRestoreTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBRestoreTaskWithOptions(request, runtime);
}

model CreateFunctionRequest {
  desc?: string(name='Desc'),
  memory?: int32(name='Memory'),
  name?: string(name='Name'),
  runtime?: string(name='Runtime'),
  spaceId?: string(name='SpaceId'),
  timeout?: int32(name='Timeout'),
}

model CreateFunctionResponseBody = {
  createdAt?: string(name='CreatedAt'),
  desc?: string(name='Desc'),
  modifiedAt?: string(name='ModifiedAt'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: {
    instanceConcurrency?: string(name='InstanceConcurrency'),
    memory?: string(name='Memory'),
    runtime?: string(name='Runtime'),
    timeout?: string(name='Timeout'),
  }(name='Spec'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunctionWithOptions(request: CreateFunctionRequest, runtime: Util.RuntimeOptions): CreateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.runtime)) {
    body['Runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFunctionWithOptions(request, runtime);
}

model CreateFunctionDeploymentRequest {
  name?: string(name='Name'),
  spaceId?: string(name='SpaceId'),
}

model CreateFunctionDeploymentResponseBody = {
  deploymentId?: string(name='DeploymentId'),
  requestId?: string(name='RequestId'),
  uploadSignedUrl?: string(name='UploadSignedUrl'),
}

model CreateFunctionDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateFunctionDeploymentResponseBody(name='body'),
}

async function createFunctionDeploymentWithOptions(request: CreateFunctionDeploymentRequest, runtime: Util.RuntimeOptions): CreateFunctionDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateFunctionDeployment',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createFunctionDeployment(request: CreateFunctionDeploymentRequest): CreateFunctionDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFunctionDeploymentWithOptions(request, runtime);
}

model CreateSpaceRequest {
  desc?: string(name='Desc'),
  name?: string(name='Name'),
  workspaceId?: long(name='WorkspaceId'),
}

model CreateSpaceResponseBody = {
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
}

model CreateSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSpaceResponseBody(name='body'),
}

async function createSpaceWithOptions(request: CreateSpaceRequest, runtime: Util.RuntimeOptions): CreateSpaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSpace',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSpace(request: CreateSpaceRequest): CreateSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSpaceWithOptions(request, runtime);
}

model DeleteAntOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  spaceId?: string(name='SpaceId'),
}

model DeleteAntOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAntOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAntOpenPlatformConfigResponseBody(name='body'),
}

async function deleteAntOpenPlatformConfigWithOptions(request: DeleteAntOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): DeleteAntOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAntOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAntOpenPlatformConfig(request: DeleteAntOpenPlatformConfigRequest): DeleteAntOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAntOpenPlatformConfigWithOptions(request, runtime);
}

model DeleteCorsDomainRequest {
  domainId?: string(name='DomainId'),
  spaceId?: string(name='SpaceId'),
}

model DeleteCorsDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCorsDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCorsDomainResponseBody(name='body'),
}

async function deleteCorsDomainWithOptions(request: DeleteCorsDomainRequest, runtime: Util.RuntimeOptions): DeleteCorsDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainId)) {
    body['DomainId'] = request.domainId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCorsDomain',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCorsDomain(request: DeleteCorsDomainRequest): DeleteCorsDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCorsDomainWithOptions(request, runtime);
}

model DeleteDBCollectionRequest {
  body?: string(name='Body'),
  spaceId?: string(name='SpaceId'),
}

model DeleteDBCollectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBCollectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBCollectionResponseBody(name='body'),
}

async function deleteDBCollectionWithOptions(request: DeleteDBCollectionRequest, runtime: Util.RuntimeOptions): DeleteDBCollectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBCollection',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBCollection(request: DeleteDBCollectionRequest): DeleteDBCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBCollectionWithOptions(request, runtime);
}

model DeleteDingtalkOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  spaceId?: string(name='SpaceId'),
}

model DeleteDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function deleteDingtalkOpenPlatformConfigWithOptions(request: DeleteDingtalkOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): DeleteDingtalkOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDingtalkOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDingtalkOpenPlatformConfig(request: DeleteDingtalkOpenPlatformConfigRequest): DeleteDingtalkOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDingtalkOpenPlatformConfigWithOptions(request, runtime);
}

model DeleteFileRequest {
  id?: string(name='Id'),
  spaceId?: string(name='SpaceId'),
}

model DeleteFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFileWithOptions(request: DeleteFileRequest, runtime: Util.RuntimeOptions): DeleteFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFile',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFileWithOptions(request, runtime);
}

model DeleteFunctionRequest {
  name?: string(name='Name'),
  spaceId?: string(name='SpaceId'),
}

model DeleteFunctionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunctionWithOptions(request: DeleteFunctionRequest, runtime: Util.RuntimeOptions): DeleteFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFunctionWithOptions(request, runtime);
}

model DeleteSpaceRequest {
  spaceId?: string(name='SpaceId'),
}

model DeleteSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSpaceResponseBody(name='body'),
}

async function deleteSpaceWithOptions(request: DeleteSpaceRequest, runtime: Util.RuntimeOptions): DeleteSpaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSpace',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSpace(request: DeleteSpaceRequest): DeleteSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSpaceWithOptions(request, runtime);
}

model DeleteWebHostingCertificateRequest {
  domain?: string(name='Domain'),
  spaceId?: string(name='SpaceId'),
}

model DeleteWebHostingCertificateResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteWebHostingCertificateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebHostingCertificateResponseBody(name='body'),
}

async function deleteWebHostingCertificateWithOptions(request: DeleteWebHostingCertificateRequest, runtime: Util.RuntimeOptions): DeleteWebHostingCertificateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebHostingCertificate',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebHostingCertificate(request: DeleteWebHostingCertificateRequest): DeleteWebHostingCertificateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebHostingCertificateWithOptions(request, runtime);
}

model DeleteWebHostingFileRequest {
  filePath?: string(name='FilePath'),
  spaceId?: string(name='SpaceId'),
}

model DeleteWebHostingFileResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteWebHostingFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWebHostingFileResponseBody(name='body'),
}

async function deleteWebHostingFileWithOptions(request: DeleteWebHostingFileRequest, runtime: Util.RuntimeOptions): DeleteWebHostingFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWebHostingFile',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWebHostingFile(request: DeleteWebHostingFileRequest): DeleteWebHostingFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWebHostingFileWithOptions(request, runtime);
}

model DeleteWechatOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  spaceId?: string(name='SpaceId'),
}

model DeleteWechatOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWechatOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWechatOpenPlatformConfigResponseBody(name='body'),
}

async function deleteWechatOpenPlatformConfigWithOptions(request: DeleteWechatOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): DeleteWechatOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWechatOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWechatOpenPlatformConfig(request: DeleteWechatOpenPlatformConfigRequest): DeleteWechatOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWechatOpenPlatformConfigWithOptions(request, runtime);
}

model DeployFunctionRequest {
  deploymentId?: string(name='DeploymentId'),
  spaceId?: string(name='SpaceId'),
}

model DeployFunctionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployFunctionResponseBody(name='body'),
}

async function deployFunctionWithOptions(request: DeployFunctionRequest, runtime: Util.RuntimeOptions): DeployFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deploymentId)) {
    body['DeploymentId'] = request.deploymentId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeployFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deployFunction(request: DeployFunctionRequest): DeployFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deployFunctionWithOptions(request, runtime);
}

model DescribeFCOpenStatusResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeFCOpenStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFCOpenStatusResponseBody(name='body'),
}

async function describeFCOpenStatusWithOptions(runtime: Util.RuntimeOptions): DescribeFCOpenStatusResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeFCOpenStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFCOpenStatus(): DescribeFCOpenStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFCOpenStatusWithOptions(runtime);
}

model DescribeFileUploadSignedUrlRequest {
  contentType?: string(name='ContentType'),
  filename?: string(name='Filename'),
  size?: long(name='Size'),
  spaceId?: string(name='SpaceId'),
}

model DescribeFileUploadSignedUrlResponseBody = {
  id?: string(name='Id'),
  ossCallbackUrl?: string(name='OssCallbackUrl'),
  requestId?: string(name='RequestId'),
  signUrl?: string(name='SignUrl'),
}

model DescribeFileUploadSignedUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFileUploadSignedUrlResponseBody(name='body'),
}

async function describeFileUploadSignedUrlWithOptions(request: DescribeFileUploadSignedUrlRequest, runtime: Util.RuntimeOptions): DescribeFileUploadSignedUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.contentType)) {
    body['ContentType'] = request.contentType;
  }
  if (!Util.isUnset(request.filename)) {
    body['Filename'] = request.filename;
  }
  if (!Util.isUnset(request.size)) {
    body['Size'] = request.size;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFileUploadSignedUrl',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFileUploadSignedUrl(request: DescribeFileUploadSignedUrlRequest): DescribeFileUploadSignedUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFileUploadSignedUrlWithOptions(request, runtime);
}

model DescribeFunctionRequest {
  name?: string(name='Name'),
  spaceId?: string(name='SpaceId'),
}

model DescribeFunctionResponseBody = {
  deployment?: {
    createdAt?: string(name='CreatedAt'),
    deploymentId?: string(name='DeploymentId'),
    downloadSignedUrl?: string(name='DownloadSignedUrl'),
    modifiedAt?: string(name='ModifiedAt'),
    versionNo?: string(name='VersionNo'),
  }(name='Deployment'),
  function?: {
    createdAt?: string(name='CreatedAt'),
    desc?: string(name='Desc'),
    httpTriggerPath?: string(name='HttpTriggerPath'),
    modifiedAt?: string(name='ModifiedAt'),
    name?: string(name='Name'),
    spec?: {
      instanceConcurrency?: int32(name='InstanceConcurrency'),
      memory?: string(name='Memory'),
      runtime?: string(name='Runtime'),
      timeout?: string(name='Timeout'),
    }(name='Spec'),
    timingTriggerConfig?: string(name='TimingTriggerConfig'),
    timingTriggerUserPayload?: string(name='TimingTriggerUserPayload'),
  }(name='Function'),
  requestId?: string(name='RequestId'),
}

model DescribeFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeFunctionResponseBody(name='body'),
}

async function describeFunctionWithOptions(request: DescribeFunctionRequest, runtime: Util.RuntimeOptions): DescribeFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeFunction(request: DescribeFunctionRequest): DescribeFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFunctionWithOptions(request, runtime);
}

model DescribeHttpTriggerConfigRequest {
  spaceId?: string(name='SpaceId'),
}

model DescribeHttpTriggerConfigResponseBody = {
  customDomain?: string(name='CustomDomain'),
  customDomainCertificateInfo?: string(name='CustomDomainCertificateInfo'),
  customDomainCname?: string(name='CustomDomainCname'),
  defaultEndpoint?: string(name='DefaultEndpoint'),
  enableService?: boolean(name='EnableService'),
  requestId?: string(name='RequestId'),
}

model DescribeHttpTriggerConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHttpTriggerConfigResponseBody(name='body'),
}

async function describeHttpTriggerConfigWithOptions(request: DescribeHttpTriggerConfigRequest, runtime: Util.RuntimeOptions): DescribeHttpTriggerConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHttpTriggerConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHttpTriggerConfig(request: DescribeHttpTriggerConfigRequest): DescribeHttpTriggerConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHttpTriggerConfigWithOptions(request, runtime);
}

model DescribeResourceQuotaRequest {
  spaceId?: string(name='SpaceId'),
}

model DescribeResourceQuotaResponseBody = {
  cloudStorageDataSizeQuota?: double(name='CloudStorageDataSizeQuota'),
  requestId?: string(name='RequestId'),
  staticWebDataSizeQuota?: double(name='StaticWebDataSizeQuota'),
}

model DescribeResourceQuotaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceQuotaResponseBody(name='body'),
}

async function describeResourceQuotaWithOptions(request: DescribeResourceQuotaRequest, runtime: Util.RuntimeOptions): DescribeResourceQuotaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceQuota',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceQuota(request: DescribeResourceQuotaRequest): DescribeResourceQuotaResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceQuotaWithOptions(request, runtime);
}

model DescribeResourceUsageRequest {
  endTime?: string(name='EndTime'),
  format?: string(name='Format'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  spaceId?: string(name='SpaceId'),
  startTime?: string(name='StartTime'),
}

model DescribeResourceUsageResponseBody = {
  code?: string(name='Code'),
  dataList?: [ 
    {
      cloudDB?: {
        dataSize?: long(name='DataSize'),
        read?: long(name='Read'),
        write?: long(name='Write'),
      }(name='CloudDB'),
      cloudFunction?: {
        compute?: long(name='Compute'),
        count?: long(name='Count'),
        traffic?: long(name='Traffic'),
      }(name='CloudFunction'),
      cloudStorage?: {
        dataSize?: long(name='DataSize'),
        download?: long(name='Download'),
        traffic?: long(name='Traffic'),
        upload?: long(name='Upload'),
      }(name='CloudStorage'),
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      staticWeb?: {
        dataSize?: long(name='DataSize'),
        traffic?: long(name='Traffic'),
      }(name='StaticWeb'),
    }
  ](name='DataList'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  paginator?: {
    pageCount?: long(name='PageCount'),
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceUsageResponseBody(name='body'),
}

async function describeResourceUsageWithOptions(request: DescribeResourceUsageRequest, runtime: Util.RuntimeOptions): DescribeResourceUsageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.format)) {
    body['Format'] = request.format;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceUsage',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceUsageWithOptions(request, runtime);
}

model DescribeServicePolicyRequest {
  collectionName?: string(name='CollectionName'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model DescribeServicePolicyResponseBody = {
  collectionName?: string(name='CollectionName'),
  policy?: string(name='Policy'),
  policyName?: string(name='PolicyName'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model DescribeServicePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeServicePolicyResponseBody(name='body'),
}

async function describeServicePolicyWithOptions(request: DescribeServicePolicyRequest, runtime: Util.RuntimeOptions): DescribeServicePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.collectionName)) {
    body['CollectionName'] = request.collectionName;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeServicePolicy',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeServicePolicy(request: DescribeServicePolicyRequest): DescribeServicePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeServicePolicyWithOptions(request, runtime);
}

model DescribeSpaceClientConfigRequest {
  detail?: string(name='Detail'),
  spaceId?: string(name='SpaceId'),
  workspaceId?: long(name='WorkspaceId'),
}

model DescribeSpaceClientConfigResponseBody = {
  apiKey?: string(name='ApiKey'),
  endpoint?: string(name='Endpoint'),
  fileUploadEndpoint?: string(name='FileUploadEndpoint'),
  name?: string(name='Name'),
  privateKey?: string(name='PrivateKey'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
}

model DescribeSpaceClientConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSpaceClientConfigResponseBody(name='body'),
}

async function describeSpaceClientConfigWithOptions(request: DescribeSpaceClientConfigRequest, runtime: Util.RuntimeOptions): DescribeSpaceClientConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.detail)) {
    body['Detail'] = request.detail;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.workspaceId)) {
    body['WorkspaceId'] = request.workspaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSpaceClientConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSpaceClientConfig(request: DescribeSpaceClientConfigRequest): DescribeSpaceClientConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSpaceClientConfigWithOptions(request, runtime);
}

model DescribeSpacesRequest {
  emasWorkspaceId?: long(name='EmasWorkspaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceIds?: [ string ](name='SpaceIds'),
  specCode?: string(name='SpecCode'),
  tenantId?: string(name='TenantId'),
}

model DescribeSpacesShrinkRequest {
  emasWorkspaceId?: long(name='EmasWorkspaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceIdsShrink?: string(name='SpaceIds'),
  specCode?: string(name='SpecCode'),
  tenantId?: string(name='TenantId'),
}

model DescribeSpacesResponseBody = {
  count?: int32(name='Count'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaces?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      description?: string(name='Description'),
      emasWorkspaceId?: long(name='EmasWorkspaceId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      orderType?: string(name='OrderType'),
      packageEndDate?: string(name='PackageEndDate'),
      packageStartDate?: string(name='PackageStartDate'),
      packageStatus?: string(name='PackageStatus'),
      renewDuration?: string(name='RenewDuration'),
      serviceStatus?: string(name='ServiceStatus'),
      spaceId?: string(name='SpaceId'),
      specCode?: string(name='SpecCode'),
    }
  ](name='Spaces'),
}

model DescribeSpacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSpacesResponseBody(name='body'),
}

async function describeSpacesWithOptions(tmpReq: DescribeSpacesRequest, runtime: Util.RuntimeOptions): DescribeSpacesResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeSpacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.spaceIds)) {
    request.spaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.spaceIds, 'SpaceIds', 'simple');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.emasWorkspaceId)) {
    body['EmasWorkspaceId'] = request.emasWorkspaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceIdsShrink)) {
    body['SpaceIds'] = request.spaceIdsShrink;
  }
  if (!Util.isUnset(request.specCode)) {
    body['SpecCode'] = request.specCode;
  }
  if (!Util.isUnset(request.tenantId)) {
    body['TenantId'] = request.tenantId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSpaces',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSpaces(request: DescribeSpacesRequest): DescribeSpacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSpacesWithOptions(request, runtime);
}

model DescribeWebHostingFileRequest {
  filePath?: string(name='FilePath'),
  spaceId?: string(name='SpaceId'),
}

model DescribeWebHostingFileResponseBody = {
  data?: {
    contentType?: string(name='ContentType'),
    ETag?: string(name='ETag'),
    exists?: boolean(name='Exists'),
    filePath?: string(name='FilePath'),
    lastModifiedTime?: long(name='LastModifiedTime'),
    signedUrl?: string(name='SignedUrl'),
    size?: long(name='Size'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeWebHostingFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWebHostingFileResponseBody(name='body'),
}

async function describeWebHostingFileWithOptions(request: DescribeWebHostingFileRequest, runtime: Util.RuntimeOptions): DescribeWebHostingFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWebHostingFile',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWebHostingFile(request: DescribeWebHostingFileRequest): DescribeWebHostingFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWebHostingFileWithOptions(request, runtime);
}

model EnableExtensionRequest {
  extensionId?: string(name='ExtensionId'),
}

model EnableExtensionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableExtensionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableExtensionResponseBody(name='body'),
}

async function enableExtensionWithOptions(request: EnableExtensionRequest, runtime: Util.RuntimeOptions): EnableExtensionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.extensionId)) {
    body['ExtensionId'] = request.extensionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableExtension',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableExtension(request: EnableExtensionRequest): EnableExtensionResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableExtensionWithOptions(request, runtime);
}

model GetWebHostingCertificateDetailRequest {
  customDomain?: string(name='CustomDomain'),
  spaceId?: string(name='SpaceId'),
}

model GetWebHostingCertificateDetailResponseBody = {
  data?: {
    certDomainName?: string(name='CertDomainName'),
    certExpiredTime?: long(name='CertExpiredTime'),
    certLife?: string(name='CertLife'),
    certName?: string(name='CertName'),
    certType?: string(name='CertType'),
    serverCertificateStatus?: string(name='ServerCertificateStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingCertificateDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebHostingCertificateDetailResponseBody(name='body'),
}

async function getWebHostingCertificateDetailWithOptions(request: GetWebHostingCertificateDetailRequest, runtime: Util.RuntimeOptions): GetWebHostingCertificateDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customDomain)) {
    body['CustomDomain'] = request.customDomain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetWebHostingCertificateDetail',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebHostingCertificateDetail(request: GetWebHostingCertificateDetailRequest): GetWebHostingCertificateDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebHostingCertificateDetailWithOptions(request, runtime);
}

model GetWebHostingConfigRequest {
  spaceId?: string(name='SpaceId'),
}

model GetWebHostingConfigResponseBody = {
  data?: {
    allowedIps?: string(name='AllowedIps'),
    defaultDomain?: string(name='DefaultDomain'),
    errorPath?: string(name='ErrorPath'),
    historyModePath?: string(name='HistoryModePath'),
    indexPath?: string(name='IndexPath'),
    spaceId?: string(name='SpaceId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebHostingConfigResponseBody(name='body'),
}

async function getWebHostingConfigWithOptions(request: GetWebHostingConfigRequest, runtime: Util.RuntimeOptions): GetWebHostingConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetWebHostingConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebHostingConfig(request: GetWebHostingConfigRequest): GetWebHostingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebHostingConfigWithOptions(request, runtime);
}

model GetWebHostingDomainVerificationContentRequest {
  domain?: string(name='Domain'),
  spaceId?: string(name='SpaceId'),
}

model GetWebHostingDomainVerificationContentResponseBody = {
  data?: {
    content?: string(name='Content'),
    domain?: string(name='Domain'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingDomainVerificationContentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebHostingDomainVerificationContentResponseBody(name='body'),
}

async function getWebHostingDomainVerificationContentWithOptions(request: GetWebHostingDomainVerificationContentRequest, runtime: Util.RuntimeOptions): GetWebHostingDomainVerificationContentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetWebHostingDomainVerificationContent',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebHostingDomainVerificationContent(request: GetWebHostingDomainVerificationContentRequest): GetWebHostingDomainVerificationContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebHostingDomainVerificationContentWithOptions(request, runtime);
}

model GetWebHostingStatusRequest {
  spaceId?: string(name='SpaceId'),
}

model GetWebHostingStatusResponseBody = {
  data?: {
    spaceId?: string(name='SpaceId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebHostingStatusResponseBody(name='body'),
}

async function getWebHostingStatusWithOptions(request: GetWebHostingStatusRequest, runtime: Util.RuntimeOptions): GetWebHostingStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetWebHostingStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebHostingStatus(request: GetWebHostingStatusRequest): GetWebHostingStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebHostingStatusWithOptions(request, runtime);
}

model GetWebHostingUploadCredentialRequest {
  filePath?: string(name='FilePath'),
  spaceId?: string(name='SpaceId'),
}

model GetWebHostingUploadCredentialResponseBody = {
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    endpoint?: string(name='Endpoint'),
    expiredTime?: long(name='ExpiredTime'),
    filePath?: string(name='FilePath'),
    policy?: string(name='Policy'),
    securityToken?: string(name='SecurityToken'),
    signature?: string(name='Signature'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingUploadCredentialResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWebHostingUploadCredentialResponseBody(name='body'),
}

async function getWebHostingUploadCredentialWithOptions(request: GetWebHostingUploadCredentialRequest, runtime: Util.RuntimeOptions): GetWebHostingUploadCredentialResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetWebHostingUploadCredential',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWebHostingUploadCredential(request: GetWebHostingUploadCredentialRequest): GetWebHostingUploadCredentialResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWebHostingUploadCredentialWithOptions(request, runtime);
}

model ListAvailableCertificatesRequest {
  domain?: string(name='Domain'),
  spaceId?: string(name='SpaceId'),
}

model ListAvailableCertificatesResponseBody = {
  data?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      statusCode?: string(name='StatusCode'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAvailableCertificatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAvailableCertificatesResponseBody(name='body'),
}

async function listAvailableCertificatesWithOptions(request: ListAvailableCertificatesRequest, runtime: Util.RuntimeOptions): ListAvailableCertificatesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAvailableCertificates',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAvailableCertificates(request: ListAvailableCertificatesRequest): ListAvailableCertificatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAvailableCertificatesWithOptions(request, runtime);
}

model ListCorsDomainsRequest {
  spaceId?: string(name='SpaceId'),
}

model ListCorsDomainsResponseBody = {
  domains?: [ 
    {
      domain?: string(name='Domain'),
      domainId?: string(name='DomainId'),
    }
  ](name='Domains'),
  requestId?: string(name='RequestId'),
}

model ListCorsDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCorsDomainsResponseBody(name='body'),
}

async function listCorsDomainsWithOptions(request: ListCorsDomainsRequest, runtime: Util.RuntimeOptions): ListCorsDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCorsDomains',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCorsDomains(request: ListCorsDomainsRequest): ListCorsDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCorsDomainsWithOptions(request, runtime);
}

model ListDingtalkOpenPlatformConfigsRequest {
  spaceId?: string(name='SpaceId'),
}

model ListDingtalkOpenPlatformConfigsResponseBody = {
  configs?: [ 
    {
      appId?: string(name='AppId'),
      appSecret?: string(name='AppSecret'),
      createTime?: string(name='CreateTime'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Configs'),
  requestId?: string(name='RequestId'),
}

model ListDingtalkOpenPlatformConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDingtalkOpenPlatformConfigsResponseBody(name='body'),
}

async function listDingtalkOpenPlatformConfigsWithOptions(request: ListDingtalkOpenPlatformConfigsRequest, runtime: Util.RuntimeOptions): ListDingtalkOpenPlatformConfigsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDingtalkOpenPlatformConfigs',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDingtalkOpenPlatformConfigs(request: ListDingtalkOpenPlatformConfigsRequest): ListDingtalkOpenPlatformConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDingtalkOpenPlatformConfigsWithOptions(request, runtime);
}

model ListExtensionsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListExtensionsResponseBody = {
  extensions?: [ 
    {
      enabled?: string(name='Enabled'),
      extensionDesc?: string(name='ExtensionDesc'),
      extensionDocumentationLink?: string(name='ExtensionDocumentationLink'),
      extensionId?: string(name='ExtensionId'),
      extensionName?: string(name='ExtensionName'),
    }
  ](name='Extensions'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListExtensionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListExtensionsResponseBody(name='body'),
}

async function listExtensionsWithOptions(request: ListExtensionsRequest, runtime: Util.RuntimeOptions): ListExtensionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListExtensions',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listExtensions(request: ListExtensionsRequest): ListExtensionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listExtensionsWithOptions(request, runtime);
}

model ListFileRequest {
  fileId?: string(name='FileId'),
  keyword?: string(name='Keyword'),
  nextToken?: string(name='NextToken'),
  pageSize?: int32(name='PageSize'),
  spaceId?: string(name='SpaceId'),
}

model ListFileResponseBody = {
  dataList?: [ 
    {
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      size?: int32(name='Size'),
      type?: string(name='Type'),
      url?: string(name='Url'),
    }
  ](name='DataList'),
  paginator?: {
    nextToken?: string(name='NextToken'),
    pageSize?: int32(name='PageSize'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFileResponseBody(name='body'),
}

async function listFileWithOptions(request: ListFileRequest, runtime: Util.RuntimeOptions): ListFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileId)) {
    body['FileId'] = request.fileId;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFile',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFile(request: ListFileRequest): ListFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFileWithOptions(request, runtime);
}

model ListFunctionRequest {
  filterBy?: string(name='FilterBy'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceId?: string(name='SpaceId'),
}

model ListFunctionResponseBody = {
  dataList?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      desc?: string(name='Desc'),
      httpTriggerPath?: string(name='HttpTriggerPath'),
      modifiedAt?: string(name='ModifiedAt'),
      name?: string(name='Name'),
      spec?: {
        instanceConcurrency?: int32(name='InstanceConcurrency'),
        memory?: string(name='Memory'),
        runtime?: string(name='Runtime'),
        timeout?: string(name='Timeout'),
      }(name='Spec'),
      timingTriggerConfig?: string(name='TimingTriggerConfig'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionResponseBody(name='body'),
}

async function listFunctionWithOptions(request: ListFunctionRequest, runtime: Util.RuntimeOptions): ListFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.filterBy)) {
    body['FilterBy'] = request.filterBy;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunction(request: ListFunctionRequest): ListFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionWithOptions(request, runtime);
}

model ListFunctionDeploymentRequest {
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceId?: string(name='SpaceId'),
  status?: string(name='Status'),
}

model ListFunctionDeploymentResponseBody = {
  dataList?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      deploymentId?: string(name='DeploymentId'),
      downloadSignedUrl?: string(name='DownloadSignedUrl'),
      modifiedAt?: string(name='ModifiedAt'),
      status?: {
        label?: string(name='Label'),
        status?: string(name='Status'),
      }(name='Status'),
      versionNo?: string(name='VersionNo'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionDeploymentResponseBody(name='body'),
}

async function listFunctionDeploymentWithOptions(request: ListFunctionDeploymentRequest, runtime: Util.RuntimeOptions): ListFunctionDeploymentResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionDeployment',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionDeployment(request: ListFunctionDeploymentRequest): ListFunctionDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionDeploymentWithOptions(request, runtime);
}

model ListFunctionLogRequest {
  fromDate?: long(name='FromDate'),
  logRequestId?: string(name='LogRequestId'),
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceId?: string(name='SpaceId'),
  status?: string(name='Status'),
  toDate?: long(name='ToDate'),
}

model ListFunctionLogResponseBody = {
  dataList?: [ 
    {
      contents?: [ string ](name='Contents'),
      functionName?: string(name='FunctionName'),
      levels?: [ string ](name='Levels'),
      requestId?: string(name='RequestId'),
      spaceId?: string(name='SpaceId'),
      status?: string(name='Status'),
      timestamps?: [ string ](name='Timestamps'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFunctionLogResponseBody(name='body'),
}

async function listFunctionLogWithOptions(request: ListFunctionLogRequest, runtime: Util.RuntimeOptions): ListFunctionLogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fromDate)) {
    body['FromDate'] = request.fromDate;
  }
  if (!Util.isUnset(request.logRequestId)) {
    body['LogRequestId'] = request.logRequestId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.toDate)) {
    body['ToDate'] = request.toDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFunctionLog',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFunctionLog(request: ListFunctionLogRequest): ListFunctionLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFunctionLogWithOptions(request, runtime);
}

model ListOpenPlatformConfigRequest {
  platform?: string(name='Platform'),
  spaceId?: string(name='SpaceId'),
}

model ListOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
  secretList?: [ 
    {
      appCert?: string(name='AppCert'),
      appId?: string(name='AppId'),
      appSecret?: string(name='AppSecret'),
      platform?: string(name='Platform'),
      privateKey?: string(name='PrivateKey'),
      publicCert?: string(name='PublicCert'),
      publicKey?: string(name='PublicKey'),
      rootCert?: string(name='RootCert'),
      signMode?: string(name='SignMode'),
      spaceId?: string(name='SpaceId'),
    }
  ](name='SecretList'),
}

model ListOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOpenPlatformConfigResponseBody(name='body'),
}

async function listOpenPlatformConfigWithOptions(request: ListOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): ListOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.platform)) {
    body['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOpenPlatformConfig(request: ListOpenPlatformConfigRequest): ListOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOpenPlatformConfigWithOptions(request, runtime);
}

model ListSpaceRequest {
  emasWorkspaceId?: string(name='EmasWorkspaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceIds?: [ string ](name='SpaceIds'),
}

model ListSpaceShrinkRequest {
  emasWorkspaceId?: string(name='EmasWorkspaceId'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
  spaceIdsShrink?: string(name='SpaceIds'),
}

model ListSpaceResponseBody = {
  count?: int32(name='Count'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaces?: [ 
    {
      desc?: string(name='Desc'),
      gmtCreate?: long(name='GmtCreate'),
      gmtLastAccess?: long(name='GmtLastAccess'),
      name?: string(name='Name'),
      spaceId?: string(name='SpaceId'),
      status?: string(name='Status'),
    }
  ](name='Spaces'),
}

model ListSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSpaceResponseBody(name='body'),
}

async function listSpaceWithOptions(tmpReq: ListSpaceRequest, runtime: Util.RuntimeOptions): ListSpaceResponse {
  Util.validateModel(tmpReq);
  var request = new ListSpaceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.spaceIds)) {
    request.spaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.spaceIds, 'SpaceIds', 'simple');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.emasWorkspaceId)) {
    body['EmasWorkspaceId'] = request.emasWorkspaceId;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.spaceIdsShrink)) {
    body['SpaceIds'] = request.spaceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListSpace',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSpace(request: ListSpaceRequest): ListSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSpaceWithOptions(request, runtime);
}

model ListWebHostingCustomDomainsRequest {
  spaceId?: string(name='SpaceId'),
}

model ListWebHostingCustomDomainsResponseBody = {
  data?: [ 
    {
      accessControlAllowOrigin?: string(name='AccessControlAllowOrigin'),
      cname?: string(name='Cname'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      domain?: string(name='Domain'),
      enableCors?: boolean(name='EnableCors'),
      forceRedirectType?: string(name='ForceRedirectType'),
      sslProtocol?: string(name='SslProtocol'),
      status?: string(name='Status'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListWebHostingCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWebHostingCustomDomainsResponseBody(name='body'),
}

async function listWebHostingCustomDomainsWithOptions(request: ListWebHostingCustomDomainsRequest, runtime: Util.RuntimeOptions): ListWebHostingCustomDomainsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListWebHostingCustomDomains',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWebHostingCustomDomains(request: ListWebHostingCustomDomainsRequest): ListWebHostingCustomDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWebHostingCustomDomainsWithOptions(request, runtime);
}

model ListWebHostingFilesRequest {
  marker?: string(name='Marker'),
  pageSize?: int32(name='PageSize'),
  prefix?: string(name='Prefix'),
  spaceId?: string(name='SpaceId'),
}

model ListWebHostingFilesResponseBody = {
  data?: {
    count?: int32(name='Count'),
    nextMarker?: string(name='NextMarker'),
    webHostingFiles?: [ 
      {
        contentType?: string(name='ContentType'),
        ETag?: string(name='ETag'),
        filePath?: string(name='FilePath'),
        lastModifiedTime?: long(name='LastModifiedTime'),
        signedUrl?: string(name='SignedUrl'),
        size?: long(name='Size'),
      }
    ](name='WebHostingFiles'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListWebHostingFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWebHostingFilesResponseBody(name='body'),
}

async function listWebHostingFilesWithOptions(request: ListWebHostingFilesRequest, runtime: Util.RuntimeOptions): ListWebHostingFilesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.marker)) {
    body['Marker'] = request.marker;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.prefix)) {
    body['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListWebHostingFiles',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWebHostingFiles(request: ListWebHostingFilesRequest): ListWebHostingFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWebHostingFilesWithOptions(request, runtime);
}

model ModifyWebHostingConfigRequest {
  allowedIps?: string(name='AllowedIps'),
  errorPath?: string(name='ErrorPath'),
  historyModePath?: string(name='HistoryModePath'),
  indexPath?: string(name='IndexPath'),
  spaceId?: string(name='SpaceId'),
}

model ModifyWebHostingConfigResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyWebHostingConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyWebHostingConfigResponseBody(name='body'),
}

async function modifyWebHostingConfigWithOptions(request: ModifyWebHostingConfigRequest, runtime: Util.RuntimeOptions): ModifyWebHostingConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.allowedIps)) {
    body['AllowedIps'] = request.allowedIps;
  }
  if (!Util.isUnset(request.errorPath)) {
    body['ErrorPath'] = request.errorPath;
  }
  if (!Util.isUnset(request.historyModePath)) {
    body['HistoryModePath'] = request.historyModePath;
  }
  if (!Util.isUnset(request.indexPath)) {
    body['IndexPath'] = request.indexPath;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyWebHostingConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyWebHostingConfig(request: ModifyWebHostingConfigRequest): ModifyWebHostingConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyWebHostingConfigWithOptions(request, runtime);
}

model OpenServiceRequest {
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model OpenServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenServiceResponseBody(name='body'),
}

async function openServiceWithOptions(request: OpenServiceRequest, runtime: Util.RuntimeOptions): OpenServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenService',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openService(request: OpenServiceRequest): OpenServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openServiceWithOptions(request, runtime);
}

model OpenWebHostingServiceRequest {
  spaceId?: string(name='SpaceId'),
}

model OpenWebHostingServiceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenWebHostingServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenWebHostingServiceResponseBody(name='body'),
}

async function openWebHostingServiceWithOptions(request: OpenWebHostingServiceRequest, runtime: Util.RuntimeOptions): OpenWebHostingServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'OpenWebHostingService',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openWebHostingService(request: OpenWebHostingServiceRequest): OpenWebHostingServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openWebHostingServiceWithOptions(request, runtime);
}

model QueryDBBackupCollectionsRequest {
  backupId?: string(name='BackupId'),
  spaceId?: string(name='SpaceId'),
}

model QueryDBBackupCollectionsResponseBody = {
  collections?: [ string ](name='Collections'),
  requestId?: string(name='RequestId'),
}

model QueryDBBackupCollectionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDBBackupCollectionsResponseBody(name='body'),
}

async function queryDBBackupCollectionsWithOptions(request: QueryDBBackupCollectionsRequest, runtime: Util.RuntimeOptions): QueryDBBackupCollectionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.backupId)) {
    body['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDBBackupCollections',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDBBackupCollections(request: QueryDBBackupCollectionsRequest): QueryDBBackupCollectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDBBackupCollectionsWithOptions(request, runtime);
}

model QueryDBBackupDumpTimesRequest {
  spaceId?: string(name='SpaceId'),
}

model QueryDBBackupDumpTimesResponseBody = {
  backupDumpTimes?: [ 
    {
      backupId?: string(name='BackupId'),
      dumpTime?: string(name='DumpTime'),
    }
  ](name='BackupDumpTimes'),
  requestId?: string(name='RequestId'),
}

model QueryDBBackupDumpTimesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDBBackupDumpTimesResponseBody(name='body'),
}

async function queryDBBackupDumpTimesWithOptions(request: QueryDBBackupDumpTimesRequest, runtime: Util.RuntimeOptions): QueryDBBackupDumpTimesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDBBackupDumpTimes',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDBBackupDumpTimes(request: QueryDBBackupDumpTimesRequest): QueryDBBackupDumpTimesResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDBBackupDumpTimesWithOptions(request, runtime);
}

model QueryDBExportTaskStatusRequest {
  spaceId?: string(name='SpaceId'),
  taskId?: string(name='TaskId'),
}

model QueryDBExportTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  downloadUrl?: string(name='DownloadUrl'),
  exportedCount?: string(name='ExportedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model QueryDBExportTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDBExportTaskStatusResponseBody(name='body'),
}

async function queryDBExportTaskStatusWithOptions(request: QueryDBExportTaskStatusRequest, runtime: Util.RuntimeOptions): QueryDBExportTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDBExportTaskStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDBExportTaskStatus(request: QueryDBExportTaskStatusRequest): QueryDBExportTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDBExportTaskStatusWithOptions(request, runtime);
}

model QueryDBImportTaskStatusRequest {
  spaceId?: string(name='SpaceId'),
  taskId?: string(name='TaskId'),
}

model QueryDBImportTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  failedCount?: string(name='FailedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  successCount?: string(name='SuccessCount'),
}

model QueryDBImportTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDBImportTaskStatusResponseBody(name='body'),
}

async function queryDBImportTaskStatusWithOptions(request: QueryDBImportTaskStatusRequest, runtime: Util.RuntimeOptions): QueryDBImportTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDBImportTaskStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDBImportTaskStatus(request: QueryDBImportTaskStatusRequest): QueryDBImportTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDBImportTaskStatusWithOptions(request, runtime);
}

model QueryDBRestoreTaskStatusRequest {
  spaceId?: string(name='SpaceId'),
  taskId?: string(name='TaskId'),
}

model QueryDBRestoreTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  failedCount?: long(name='FailedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  successCount?: long(name='SuccessCount'),
}

model QueryDBRestoreTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryDBRestoreTaskStatusResponseBody(name='body'),
}

async function queryDBRestoreTaskStatusWithOptions(request: QueryDBRestoreTaskStatusRequest, runtime: Util.RuntimeOptions): QueryDBRestoreTaskStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryDBRestoreTaskStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryDBRestoreTaskStatus(request: QueryDBRestoreTaskStatusRequest): QueryDBRestoreTaskStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryDBRestoreTaskStatusWithOptions(request, runtime);
}

model QueryServiceStatusRequest {
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model QueryServiceStatusResponseBody = {
  requestId?: string(name='RequestId'),
  serviceStatus?: string(name='ServiceStatus'),
}

model QueryServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryServiceStatusResponseBody(name='body'),
}

async function queryServiceStatusWithOptions(request: QueryServiceStatusRequest, runtime: Util.RuntimeOptions): QueryServiceStatusResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryServiceStatus',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryServiceStatus(request: QueryServiceStatusRequest): QueryServiceStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryServiceStatusWithOptions(request, runtime);
}

model QuerySpaceConsumptionRequest {
  spaceId?: string(name='SpaceId'),
}

model QuerySpaceConsumptionResponseBody = {
  csUsage?: {
    cdnTraffic?: long(name='CdnTraffic'),
    downloadCount?: long(name='DownloadCount'),
    storageSize?: long(name='StorageSize'),
    uploadCount?: long(name='UploadCount'),
  }(name='CsUsage'),
  cycleEndTime?: long(name='CycleEndTime'),
  cycleStartTime?: long(name='CycleStartTime'),
  dbUsage?: {
    readCount?: long(name='ReadCount'),
    storageSize?: long(name='StorageSize'),
    writeCount?: long(name='WriteCount'),
  }(name='DbUsage'),
  fcUsage?: {
    cost?: long(name='Cost'),
    requestCount?: long(name='RequestCount'),
    txTraffic?: long(name='TxTraffic'),
  }(name='FcUsage'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
  specCode?: string(name='SpecCode'),
  whUsage?: {
    cdnTraffic?: long(name='CdnTraffic'),
    storageSize?: long(name='StorageSize'),
  }(name='WhUsage'),
}

model QuerySpaceConsumptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySpaceConsumptionResponseBody(name='body'),
}

async function querySpaceConsumptionWithOptions(request: QuerySpaceConsumptionRequest, runtime: Util.RuntimeOptions): QuerySpaceConsumptionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpaceConsumption',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySpaceConsumption(request: QuerySpaceConsumptionRequest): QuerySpaceConsumptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpaceConsumptionWithOptions(request, runtime);
}

model QuerySpaceSpecDetailRequest {
  specCode?: string(name='SpecCode'),
}

model QuerySpaceSpecDetailResponseBody = {
  csCdnTraffic?: long(name='CsCdnTraffic'),
  csDownloadCount?: long(name='CsDownloadCount'),
  csStorageSize?: long(name='CsStorageSize'),
  csUploadCount?: long(name='CsUploadCount'),
  dbReadCount?: long(name='DbReadCount'),
  dbStorageSize?: long(name='DbStorageSize'),
  dbWriteCount?: long(name='DbWriteCount'),
  fcCost?: long(name='FcCost'),
  fcRequestCount?: long(name='FcRequestCount'),
  fcTxTraffic?: long(name='FcTxTraffic'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  specCode?: string(name='SpecCode'),
  specDetailText?: string(name='SpecDetailText'),
  whCdnTraffic?: long(name='WhCdnTraffic'),
  whStorageSize?: long(name='WhStorageSize'),
}

model QuerySpaceSpecDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySpaceSpecDetailResponseBody(name='body'),
}

async function querySpaceSpecDetailWithOptions(request: QuerySpaceSpecDetailRequest, runtime: Util.RuntimeOptions): QuerySpaceSpecDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.specCode)) {
    body['SpecCode'] = request.specCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpaceSpecDetail',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySpaceSpecDetail(request: QuerySpaceSpecDetailRequest): QuerySpaceSpecDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpaceSpecDetailWithOptions(request, runtime);
}

model QuerySpaceUsageRequest {
  endTime?: string(name='EndTime'),
  spaceId?: string(name='SpaceId'),
  startTime?: string(name='StartTime'),
}

model QuerySpaceUsageResponseBody = {
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
  spaceUsageDataList?: [ 
    {
      csUsage?: {
        cdnTraffic?: long(name='CdnTraffic'),
        downloadCount?: long(name='DownloadCount'),
        storageSize?: long(name='StorageSize'),
        uploadCount?: long(name='UploadCount'),
      }(name='CsUsage'),
      dbUsage?: {
        readCount?: long(name='ReadCount'),
        storageSize?: long(name='StorageSize'),
        writeCount?: long(name='WriteCount'),
      }(name='DbUsage'),
      fcUsage?: {
        cost?: long(name='Cost'),
        requestCount?: long(name='RequestCount'),
        txTraffic?: long(name='TxTraffic'),
      }(name='FcUsage'),
      timestamp?: string(name='Timestamp'),
      whUsage?: {
        cdnTraffic?: long(name='CdnTraffic'),
        storageSize?: long(name='StorageSize'),
      }(name='WhUsage'),
    }
  ](name='SpaceUsageDataList'),
  startTime?: string(name='StartTime'),
}

model QuerySpaceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QuerySpaceUsageResponseBody(name='body'),
}

async function querySpaceUsageWithOptions(request: QuerySpaceUsageRequest, runtime: Util.RuntimeOptions): QuerySpaceUsageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QuerySpaceUsage',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function querySpaceUsage(request: QuerySpaceUsageRequest): QuerySpaceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return querySpaceUsageWithOptions(request, runtime);
}

model RefreshWebHostingCustomDomainCacheRequest {
  domainName?: string(name='DomainName'),
  spaceId?: string(name='SpaceId'),
}

model RefreshWebHostingCustomDomainCacheResponseBody = {
  requestId?: string(name='RequestId'),
}

model RefreshWebHostingCustomDomainCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RefreshWebHostingCustomDomainCacheResponseBody(name='body'),
}

async function refreshWebHostingCustomDomainCacheWithOptions(request: RefreshWebHostingCustomDomainCacheRequest, runtime: Util.RuntimeOptions): RefreshWebHostingCustomDomainCacheResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RefreshWebHostingCustomDomainCache',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function refreshWebHostingCustomDomainCache(request: RefreshWebHostingCustomDomainCacheRequest): RefreshWebHostingCustomDomainCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return refreshWebHostingCustomDomainCacheWithOptions(request, runtime);
}

model RegisterFileRequest {
  id?: string(name='Id'),
  spaceId?: string(name='SpaceId'),
}

model RegisterFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RegisterFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterFileResponseBody(name='body'),
}

async function registerFileWithOptions(request: RegisterFileRequest, runtime: Util.RuntimeOptions): RegisterFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterFile',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerFile(request: RegisterFileRequest): RegisterFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerFileWithOptions(request, runtime);
}

model RenameDBCollectionRequest {
  newCollection?: string(name='NewCollection'),
  originCollection?: string(name='OriginCollection'),
  spaceId?: string(name='SpaceId'),
}

model RenameDBCollectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenameDBCollectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenameDBCollectionResponseBody(name='body'),
}

async function renameDBCollectionWithOptions(request: RenameDBCollectionRequest, runtime: Util.RuntimeOptions): RenameDBCollectionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.newCollection)) {
    body['NewCollection'] = request.newCollection;
  }
  if (!Util.isUnset(request.originCollection)) {
    body['OriginCollection'] = request.originCollection;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RenameDBCollection',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renameDBCollection(request: RenameDBCollectionRequest): RenameDBCollectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return renameDBCollectionWithOptions(request, runtime);
}

model ResetServerSecretRequest {
  spaceId?: string(name='SpaceId'),
}

model ResetServerSecretResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetServerSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetServerSecretResponseBody(name='body'),
}

async function resetServerSecretWithOptions(request: ResetServerSecretRequest, runtime: Util.RuntimeOptions): ResetServerSecretResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ResetServerSecret',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetServerSecret(request: ResetServerSecretRequest): ResetServerSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetServerSecretWithOptions(request, runtime);
}

model RunDBCommandRequest {
  body?: string(name='Body'),
  spaceId?: string(name='SpaceId'),
}

model RunDBCommandResponseBody = {
  affectedDocs?: int32(name='AffectedDocs'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RunDBCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunDBCommandResponseBody(name='body'),
}

async function runDBCommandWithOptions(request: RunDBCommandRequest, runtime: Util.RuntimeOptions): RunDBCommandResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunDBCommand',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runDBCommand(request: RunDBCommandRequest): RunDBCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return runDBCommandWithOptions(request, runtime);
}

model RunFunctionRequest {
  body?: string(name='Body'),
  spaceId?: string(name='SpaceId'),
}

model RunFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  runtimeMeta?: {
    billingDuration?: int32(name='BillingDuration'),
    invocationDuration?: int32(name='InvocationDuration'),
    maxMemoryUsage?: int32(name='MaxMemoryUsage'),
    requestId?: string(name='RequestId'),
  }(name='RuntimeMeta'),
}

model RunFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RunFunctionResponseBody(name='body'),
}

async function runFunctionWithOptions(request: RunFunctionRequest, runtime: Util.RuntimeOptions): RunFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.body)) {
    body['Body'] = request.body;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RunFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runFunction(request: RunFunctionRequest): RunFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return runFunctionWithOptions(request, runtime);
}

model SaveAntOpenPlatformConfigRequest {
  appCert?: string(name='AppCert'),
  appId?: string(name='AppId'),
  privateKey?: string(name='PrivateKey'),
  publicCert?: string(name='PublicCert'),
  publicKey?: string(name='PublicKey'),
  rootCert?: string(name='RootCert'),
  signMode?: string(name='SignMode'),
  spaceId?: string(name='SpaceId'),
}

model SaveAntOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveAntOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAntOpenPlatformConfigResponseBody(name='body'),
}

async function saveAntOpenPlatformConfigWithOptions(request: SaveAntOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): SaveAntOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appCert)) {
    body['AppCert'] = request.appCert;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.privateKey)) {
    body['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.publicCert)) {
    body['PublicCert'] = request.publicCert;
  }
  if (!Util.isUnset(request.publicKey)) {
    body['PublicKey'] = request.publicKey;
  }
  if (!Util.isUnset(request.rootCert)) {
    body['RootCert'] = request.rootCert;
  }
  if (!Util.isUnset(request.signMode)) {
    body['SignMode'] = request.signMode;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveAntOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAntOpenPlatformConfig(request: SaveAntOpenPlatformConfigRequest): SaveAntOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAntOpenPlatformConfigWithOptions(request, runtime);
}

model SaveAppAuthTokenRequest {
  appAuthToken?: string(name='AppAuthToken'),
  appId?: string(name='AppId'),
  isvAppId?: string(name='IsvAppId'),
  spaceId?: string(name='SpaceId'),
}

model SaveAppAuthTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveAppAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveAppAuthTokenResponseBody(name='body'),
}

async function saveAppAuthTokenWithOptions(request: SaveAppAuthTokenRequest, runtime: Util.RuntimeOptions): SaveAppAuthTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appAuthToken)) {
    body['AppAuthToken'] = request.appAuthToken;
  }
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.isvAppId)) {
    body['IsvAppId'] = request.isvAppId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveAppAuthToken',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveAppAuthToken(request: SaveAppAuthTokenRequest): SaveAppAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveAppAuthTokenWithOptions(request, runtime);
}

model SaveWebHostingCustomDomainConfigRequest {
  domainName?: string(name='DomainName'),
  forceRedirectType?: string(name='ForceRedirectType'),
  spaceId?: string(name='SpaceId'),
}

model SaveWebHostingCustomDomainConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveWebHostingCustomDomainConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveWebHostingCustomDomainConfigResponseBody(name='body'),
}

async function saveWebHostingCustomDomainConfigWithOptions(request: SaveWebHostingCustomDomainConfigRequest, runtime: Util.RuntimeOptions): SaveWebHostingCustomDomainConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.forceRedirectType)) {
    body['ForceRedirectType'] = request.forceRedirectType;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveWebHostingCustomDomainConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveWebHostingCustomDomainConfig(request: SaveWebHostingCustomDomainConfigRequest): SaveWebHostingCustomDomainConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveWebHostingCustomDomainConfigWithOptions(request, runtime);
}

model SaveWebHostingCustomDomainCorsConfigRequest {
  accessControlAllowOrigin?: string(name='AccessControlAllowOrigin'),
  domainName?: string(name='DomainName'),
  enableCors?: boolean(name='EnableCors'),
  spaceId?: string(name='SpaceId'),
}

model SaveWebHostingCustomDomainCorsConfigResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveWebHostingCustomDomainCorsConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveWebHostingCustomDomainCorsConfigResponseBody(name='body'),
}

async function saveWebHostingCustomDomainCorsConfigWithOptions(request: SaveWebHostingCustomDomainCorsConfigRequest, runtime: Util.RuntimeOptions): SaveWebHostingCustomDomainCorsConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accessControlAllowOrigin)) {
    body['AccessControlAllowOrigin'] = request.accessControlAllowOrigin;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.enableCors)) {
    body['EnableCors'] = request.enableCors;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveWebHostingCustomDomainCorsConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveWebHostingCustomDomainCorsConfig(request: SaveWebHostingCustomDomainCorsConfigRequest): SaveWebHostingCustomDomainCorsConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveWebHostingCustomDomainCorsConfigWithOptions(request, runtime);
}

model SaveWechatOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  appSecret?: string(name='AppSecret'),
  spaceId?: string(name='SpaceId'),
}

model SaveWechatOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveWechatOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveWechatOpenPlatformConfigResponseBody(name='body'),
}

async function saveWechatOpenPlatformConfigWithOptions(request: SaveWechatOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): SaveWechatOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveWechatOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveWechatOpenPlatformConfig(request: SaveWechatOpenPlatformConfigRequest): SaveWechatOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveWechatOpenPlatformConfigWithOptions(request, runtime);
}

model UnbindWebHostingCustomDomainRequest {
  customDomain?: string(name='CustomDomain'),
  spaceId?: string(name='SpaceId'),
}

model UnbindWebHostingCustomDomainResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UnbindWebHostingCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindWebHostingCustomDomainResponseBody(name='body'),
}

async function unbindWebHostingCustomDomainWithOptions(request: UnbindWebHostingCustomDomainRequest, runtime: Util.RuntimeOptions): UnbindWebHostingCustomDomainResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customDomain)) {
    body['CustomDomain'] = request.customDomain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindWebHostingCustomDomain',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindWebHostingCustomDomain(request: UnbindWebHostingCustomDomainRequest): UnbindWebHostingCustomDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindWebHostingCustomDomainWithOptions(request, runtime);
}

model UpdateDingtalkOpenPlatformConfigRequest {
  appId?: string(name='AppId'),
  appSecret?: string(name='AppSecret'),
  spaceId?: string(name='SpaceId'),
}

model UpdateDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function updateDingtalkOpenPlatformConfigWithOptions(request: UpdateDingtalkOpenPlatformConfigRequest, runtime: Util.RuntimeOptions): UpdateDingtalkOpenPlatformConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appId)) {
    body['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appSecret)) {
    body['AppSecret'] = request.appSecret;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDingtalkOpenPlatformConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDingtalkOpenPlatformConfig(request: UpdateDingtalkOpenPlatformConfigRequest): UpdateDingtalkOpenPlatformConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDingtalkOpenPlatformConfigWithOptions(request, runtime);
}

model UpdateFunctionRequest {
  desc?: string(name='Desc'),
  httpTriggerPath?: string(name='HttpTriggerPath'),
  instanceConcurrency?: int32(name='InstanceConcurrency'),
  memory?: int32(name='Memory'),
  name?: string(name='Name'),
  runtime?: string(name='Runtime'),
  spaceId?: string(name='SpaceId'),
  timeout?: int32(name='Timeout'),
  timingTriggerConfig?: string(name='TimingTriggerConfig'),
  timingTriggerUserPayload?: string(name='TimingTriggerUserPayload'),
}

model UpdateFunctionResponseBody = {
  createdAt?: string(name='CreatedAt'),
  desc?: string(name='Desc'),
  httpTriggerPath?: string(name='HttpTriggerPath'),
  modifiedAt?: string(name='ModifiedAt'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: {
    instanceConcurrency?: int32(name='InstanceConcurrency'),
    memory?: string(name='Memory'),
    runtime?: string(name='Runtime'),
    timeout?: string(name='Timeout'),
  }(name='Spec'),
  timingTriggerConfig?: string(name='TimingTriggerConfig'),
  timingTriggerUserPayload?: string(name='TimingTriggerUserPayload'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunctionWithOptions(request: UpdateFunctionRequest, runtime: Util.RuntimeOptions): UpdateFunctionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.httpTriggerPath)) {
    body['HttpTriggerPath'] = request.httpTriggerPath;
  }
  if (!Util.isUnset(request.instanceConcurrency)) {
    body['InstanceConcurrency'] = request.instanceConcurrency;
  }
  if (!Util.isUnset(request.memory)) {
    body['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.runtime)) {
    body['Runtime'] = request.runtime;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timingTriggerConfig)) {
    body['TimingTriggerConfig'] = request.timingTriggerConfig;
  }
  if (!Util.isUnset(request.timingTriggerUserPayload)) {
    body['TimingTriggerUserPayload'] = request.timingTriggerUserPayload;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateFunction',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateFunctionWithOptions(request, runtime);
}

model UpdateHttpTriggerConfigRequest {
  customDomain?: string(name='CustomDomain'),
  customDomainCertificate?: string(name='CustomDomainCertificate'),
  customDomainPrivateKey?: string(name='CustomDomainPrivateKey'),
  enableService?: boolean(name='EnableService'),
  spaceId?: string(name='SpaceId'),
}

model UpdateHttpTriggerConfigResponseBody = {
  customDomain?: string(name='CustomDomain'),
  customDomainCertificateInfo?: string(name='CustomDomainCertificateInfo'),
  customDomainCname?: string(name='CustomDomainCname'),
  defaultEndpoint?: string(name='DefaultEndpoint'),
  enableService?: boolean(name='EnableService'),
  requestId?: string(name='RequestId'),
}

model UpdateHttpTriggerConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHttpTriggerConfigResponseBody(name='body'),
}

async function updateHttpTriggerConfigWithOptions(request: UpdateHttpTriggerConfigRequest, runtime: Util.RuntimeOptions): UpdateHttpTriggerConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.customDomain)) {
    body['CustomDomain'] = request.customDomain;
  }
  if (!Util.isUnset(request.customDomainCertificate)) {
    body['CustomDomainCertificate'] = request.customDomainCertificate;
  }
  if (!Util.isUnset(request.customDomainPrivateKey)) {
    body['CustomDomainPrivateKey'] = request.customDomainPrivateKey;
  }
  if (!Util.isUnset(request.enableService)) {
    body['EnableService'] = request.enableService;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHttpTriggerConfig',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHttpTriggerConfig(request: UpdateHttpTriggerConfigRequest): UpdateHttpTriggerConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHttpTriggerConfigWithOptions(request, runtime);
}

model UpdateServicePolicyRequest {
  collectionName?: string(name='CollectionName'),
  policy?: string(name='Policy'),
  policyName?: string(name='PolicyName'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model UpdateServicePolicyResponseBody = {
  collectionName?: string(name='CollectionName'),
  policy?: string(name='Policy'),
  policyName?: string(name='PolicyName'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model UpdateServicePolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateServicePolicyResponseBody(name='body'),
}

async function updateServicePolicyWithOptions(request: UpdateServicePolicyRequest, runtime: Util.RuntimeOptions): UpdateServicePolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.collectionName)) {
    body['CollectionName'] = request.collectionName;
  }
  if (!Util.isUnset(request.policy)) {
    body['Policy'] = request.policy;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.serviceName)) {
    body['ServiceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateServicePolicy',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateServicePolicy(request: UpdateServicePolicyRequest): UpdateServicePolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateServicePolicyWithOptions(request, runtime);
}

model UpdateSpaceRequest {
  desc?: string(name='Desc'),
  spaceId?: string(name='SpaceId'),
  status?: string(name='Status'),
}

model UpdateSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSpaceResponseBody(name='body'),
}

async function updateSpaceWithOptions(request: UpdateSpaceRequest, runtime: Util.RuntimeOptions): UpdateSpaceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.desc)) {
    body['Desc'] = request.desc;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSpace',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSpace(request: UpdateSpaceRequest): UpdateSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSpaceWithOptions(request, runtime);
}

model VerifyWebHostingDomainOwnerRequest {
  domain?: string(name='Domain'),
  spaceId?: string(name='SpaceId'),
  verifyType?: string(name='VerifyType'),
}

model VerifyWebHostingDomainOwnerResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyWebHostingDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyWebHostingDomainOwnerResponseBody(name='body'),
}

async function verifyWebHostingDomainOwnerWithOptions(request: VerifyWebHostingDomainOwnerRequest, runtime: Util.RuntimeOptions): VerifyWebHostingDomainOwnerResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.domain)) {
    body['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  if (!Util.isUnset(request.verifyType)) {
    body['VerifyType'] = request.verifyType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'VerifyWebHostingDomainOwner',
    version = '2019-06-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyWebHostingDomainOwner(request: VerifyWebHostingDomainOwnerRequest): VerifyWebHostingDomainOwnerResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyWebHostingDomainOwnerWithOptions(request, runtime);
}

