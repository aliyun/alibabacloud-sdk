/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'MPServerless';
  @version = '2019-06-15';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model AddCorsDomainRequest {
  domain: string(name='Domain', minLength=1, maxLength=253, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model AddCorsDomainResponseBody = {
  domainId?: string(name='DomainId'),
  requestId?: string(name='RequestId'),
}

model AddCorsDomainResponse = {
  headers: map[string]string(name='headers'),
  body: AddCorsDomainResponseBody(name='body'),
}

async function addCorsDomain(request: AddCorsDomainRequest): AddCorsDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCorsDomain', 'POST', '/', 'json', true, 'form', request);
}

model AddDingtalkOpenPlatformConfigRequest {
  appId: string(name='AppId', maxLength=64, position='Body'),
  appSecret: string(name='AppSecret', maxLength=200, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model AddDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: AddDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function addDingtalkOpenPlatformConfig(request: AddDingtalkOpenPlatformConfigRequest): AddDingtalkOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddDingtalkOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model AttachWebHostingCertificateRequest {
  certName?: string(name='CertName', position='Body'),
  certType: string(name='CertType', position='Body'),
  domain: string(name='Domain', position='Body'),
  privateKey: string(name='PrivateKey', position='Body'),
  serverCertificate: string(name='ServerCertificate', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model AttachWebHostingCertificateResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model AttachWebHostingCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: AttachWebHostingCertificateResponseBody(name='body'),
}

async function attachWebHostingCertificate(request: AttachWebHostingCertificateRequest): AttachWebHostingCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AttachWebHostingCertificate', 'POST', '/', 'json', true, 'form', request);
}

model BatchDeleteWebHostingFilesRequest {
  filePaths: [ string ](name='FilePaths', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model BatchDeleteWebHostingFilesResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteWebHostingFilesResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteWebHostingFilesResponseBody(name='body'),
}

async function batchDeleteWebHostingFiles(request: BatchDeleteWebHostingFilesRequest): BatchDeleteWebHostingFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteWebHostingFiles', 'POST', '/', 'json', true, 'form', request);
}

model BindWebHostingCustomDomainRequest {
  customDomain: string(name='CustomDomain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model BindWebHostingCustomDomainResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model BindWebHostingCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: BindWebHostingCustomDomainResponseBody(name='body'),
}

async function bindWebHostingCustomDomain(request: BindWebHostingCustomDomainRequest): BindWebHostingCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BindWebHostingCustomDomain', 'POST', '/', 'json', true, 'form', request);
}

model CheckMpServerlessRoleExistsRequest {
  roleName: string(name='RoleName', position='Query'),
}

model CheckMpServerlessRoleExistsResponseBody = {
  exists?: boolean(name='Exists'),
  requestId?: string(name='RequestId'),
}

model CheckMpServerlessRoleExistsResponse = {
  headers: map[string]string(name='headers'),
  body: CheckMpServerlessRoleExistsResponseBody(name='body'),
}

async function checkMpServerlessRoleExists(request: CheckMpServerlessRoleExistsRequest): CheckMpServerlessRoleExistsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckMpServerlessRoleExists', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBExportTaskRequest {
  collection: string(name='Collection', position='Body'),
  fields?: string(name='Fields', position='Body'),
  fileType: string(name='FileType', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model CreateDBExportTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateDBExportTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBExportTaskResponseBody(name='body'),
}

async function createDBExportTask(request: CreateDBExportTaskRequest): CreateDBExportTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBExportTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateDBImportTaskRequest {
  collection: string(name='Collection', position='Body'),
  fileType: string(name='FileType', position='Body'),
  mode?: string(name='Mode', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model CreateDBImportTaskResponseBody = {
  accessKeyId?: string(name='AccessKeyId'),
  expireTime?: string(name='ExpireTime'),
  fileKey?: string(name='FileKey'),
  host?: string(name='Host'),
  policy?: string(name='Policy'),
  requestId?: string(name='RequestId'),
  signature?: string(name='Signature'),
  taskId?: string(name='TaskId'),
}

model CreateDBImportTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBImportTaskResponseBody(name='body'),
}

async function createDBImportTask(request: CreateDBImportTaskRequest): CreateDBImportTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBImportTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateDBRestoreTaskRequest {
  backupId: string(name='BackupId', position='Body'),
  newCollections: string(name='NewCollections', position='Body'),
  originCollections: string(name='OriginCollections', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model CreateDBRestoreTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateDBRestoreTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBRestoreTaskResponseBody(name='body'),
}

async function createDBRestoreTask(request: CreateDBRestoreTaskRequest): CreateDBRestoreTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBRestoreTask', 'POST', '/', 'json', true, 'form', request);
}

model CreateFunctionRequest {
  desc?: string(name='Desc', maxLength=128, position='Body'),
  memory?: int32(name='Memory', position='Body'),
  name: string(name='Name', position='Body'),
  runtime?: string(name='Runtime', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  timeout?: int32(name='Timeout', position='Body'),
}

model CreateFunctionResponseBody = {
  createdAt?: string(name='CreatedAt'),
  desc?: string(name='Desc'),
  modifiedAt?: string(name='ModifiedAt'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: {
    instanceConcurrency?: string(name='InstanceConcurrency'),
    memory?: string(name='Memory'),
    runtime?: string(name='Runtime'),
    timeout?: string(name='Timeout'),
  }(name='Spec'),
}

model CreateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionResponseBody(name='body'),
}

async function createFunction(request: CreateFunctionRequest): CreateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFunction', 'POST', '/', 'json', true, 'form', request);
}

model CreateFunctionDeploymentRequest {
  name: string(name='Name', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model CreateFunctionDeploymentResponseBody = {
  deploymentId?: string(name='DeploymentId'),
  requestId?: string(name='RequestId'),
  uploadSignedUrl?: string(name='UploadSignedUrl'),
}

model CreateFunctionDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFunctionDeploymentResponseBody(name='body'),
}

async function createFunctionDeployment(request: CreateFunctionDeploymentRequest): CreateFunctionDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateFunctionDeployment', 'POST', '/', 'json', true, 'form', request);
}

model CreateSpaceRequest {
  desc?: string(name='Desc', maxLength=128, position='Body'),
  name?: string(name='Name', position='Body'),
  workspaceId?: long(name='WorkspaceId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model CreateSpaceResponseBody = {
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
}

model CreateSpaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateSpaceResponseBody(name='body'),
}

async function createSpace(request: CreateSpaceRequest): CreateSpaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateSpace', 'POST', '/', 'json', true, 'form', request);
}

model DeleteAntOpenPlatformConfigRequest {
  appId: string(name='AppId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteAntOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAntOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAntOpenPlatformConfigResponseBody(name='body'),
}

async function deleteAntOpenPlatformConfig(request: DeleteAntOpenPlatformConfigRequest): DeleteAntOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAntOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model DeleteCorsDomainRequest {
  domainId: string(name='DomainId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteCorsDomainResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteCorsDomainResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCorsDomainResponseBody(name='body'),
}

async function deleteCorsDomain(request: DeleteCorsDomainRequest): DeleteCorsDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCorsDomain', 'POST', '/', 'json', true, 'form', request);
}

model DeleteDBCollectionRequest {
  body: string(name='Body', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteDBCollectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBCollectionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDBCollectionResponseBody(name='body'),
}

async function deleteDBCollection(request: DeleteDBCollectionRequest): DeleteDBCollectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBCollection', 'POST', '/', 'json', true, 'form', request);
}

model DeleteDingtalkOpenPlatformConfigRequest {
  appId: string(name='AppId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function deleteDingtalkOpenPlatformConfig(request: DeleteDingtalkOpenPlatformConfigRequest): DeleteDingtalkOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDingtalkOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model DeleteFileRequest {
  id: string(name='Id', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFileResponseBody(name='body'),
}

async function deleteFile(request: DeleteFileRequest): DeleteFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFile', 'POST', '/', 'json', true, 'form', request);
}

model DeleteFunctionRequest {
  name: string(name='Name', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteFunctionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFunctionResponseBody(name='body'),
}

async function deleteFunction(request: DeleteFunctionRequest): DeleteFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteFunction', 'POST', '/', 'json', true, 'form', request);
}

model DeleteSpaceRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSpaceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSpaceResponseBody(name='body'),
}

async function deleteSpace(request: DeleteSpaceRequest): DeleteSpaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSpace', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWebHostingCertificateRequest {
  domain: string(name='Domain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteWebHostingCertificateResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteWebHostingCertificateResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebHostingCertificateResponseBody(name='body'),
}

async function deleteWebHostingCertificate(request: DeleteWebHostingCertificateRequest): DeleteWebHostingCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebHostingCertificate', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWebHostingFileRequest {
  filePath: string(name='FilePath', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteWebHostingFileResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteWebHostingFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWebHostingFileResponseBody(name='body'),
}

async function deleteWebHostingFile(request: DeleteWebHostingFileRequest): DeleteWebHostingFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWebHostingFile', 'POST', '/', 'json', true, 'form', request);
}

model DeleteWechatOpenPlatformConfigRequest {
  appId: string(name='AppId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeleteWechatOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWechatOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWechatOpenPlatformConfigResponseBody(name='body'),
}

async function deleteWechatOpenPlatformConfig(request: DeleteWechatOpenPlatformConfigRequest): DeleteWechatOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWechatOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model DeployFunctionRequest {
  deploymentId: string(name='DeploymentId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DeployFunctionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeployFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DeployFunctionResponseBody(name='body'),
}

async function deployFunction(request: DeployFunctionRequest): DeployFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeployFunction', 'POST', '/', 'json', true, 'form', request);
}

model DescribeFCOpenStatusRequest {
}

model DescribeFCOpenStatusResponseBody = {
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeFCOpenStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFCOpenStatusResponseBody(name='body'),
}

async function describeFCOpenStatus(request: DescribeFCOpenStatusRequest): DescribeFCOpenStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFCOpenStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeFileUploadSignedUrlRequest {
  contentType: string(name='ContentType', position='Body'),
  filename: string(name='Filename', position='Body'),
  size: long(name='Size', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeFileUploadSignedUrlResponseBody = {
  id?: string(name='Id'),
  ossCallbackUrl?: string(name='OssCallbackUrl'),
  requestId?: string(name='RequestId'),
  signUrl?: string(name='SignUrl'),
}

model DescribeFileUploadSignedUrlResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFileUploadSignedUrlResponseBody(name='body'),
}

async function describeFileUploadSignedUrl(request: DescribeFileUploadSignedUrlRequest): DescribeFileUploadSignedUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFileUploadSignedUrl', 'POST', '/', 'json', true, 'form', request);
}

model DescribeFunctionRequest {
  name: string(name='Name', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeFunctionResponseBody = {
  deployment?: {
    createdAt?: string(name='CreatedAt'),
    deploymentId?: string(name='DeploymentId'),
    downloadSignedUrl?: string(name='DownloadSignedUrl'),
    modifiedAt?: string(name='ModifiedAt'),
    versionNo?: string(name='VersionNo'),
  }(name='Deployment'),
  function?: {
    createdAt?: string(name='CreatedAt'),
    desc?: string(name='Desc'),
    httpTriggerPath?: string(name='HttpTriggerPath'),
    modifiedAt?: string(name='ModifiedAt'),
    name?: string(name='Name'),
    spec?: {
      instanceConcurrency?: int32(name='InstanceConcurrency'),
      memory?: string(name='Memory'),
      runtime?: string(name='Runtime'),
      timeout?: string(name='Timeout'),
    }(name='Spec'),
    timingTriggerConfig?: string(name='TimingTriggerConfig'),
    timingTriggerUserPayload?: string(name='TimingTriggerUserPayload'),
  }(name='Function'),
  requestId?: string(name='RequestId'),
}

model DescribeFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFunctionResponseBody(name='body'),
}

async function describeFunction(request: DescribeFunctionRequest): DescribeFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeFunction', 'POST', '/', 'json', true, 'form', request);
}

model DescribeHttpTriggerConfigRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeHttpTriggerConfigResponseBody = {
  customDomain?: string(name='CustomDomain'),
  customDomainCertificateInfo?: string(name='CustomDomainCertificateInfo'),
  customDomainCname?: string(name='CustomDomainCname'),
  defaultEndpoint?: string(name='DefaultEndpoint'),
  enableService?: boolean(name='EnableService'),
  requestId?: string(name='RequestId'),
}

model DescribeHttpTriggerConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHttpTriggerConfigResponseBody(name='body'),
}

async function describeHttpTriggerConfig(request: DescribeHttpTriggerConfigRequest): DescribeHttpTriggerConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHttpTriggerConfig', 'POST', '/', 'json', true, 'form', request);
}

model DescribeResourceQuotaRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeResourceQuotaResponseBody = {
  cloudStorageDataSizeQuota?: double(name='CloudStorageDataSizeQuota'),
  requestId?: string(name='RequestId'),
  staticWebDataSizeQuota?: double(name='StaticWebDataSizeQuota'),
}

model DescribeResourceQuotaResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceQuotaResponseBody(name='body'),
}

async function describeResourceQuota(request: DescribeResourceQuotaRequest): DescribeResourceQuotaResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceQuota', 'POST', '/', 'json', true, 'form', request);
}

model DescribeResourceUsageRequest {
  endTime?: string(name='EndTime', position='Body'),
  format?: string(name='Format', position='Body'),
  pageNumber?: long(name='PageNumber', minimum=1, position='Body'),
  pageSize?: long(name='PageSize', minimum=1, maximum=1000, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  startTime?: string(name='StartTime', position='Body'),
}

model DescribeResourceUsageResponseBody = {
  code?: string(name='Code'),
  dataList?: [ 
    {
      cloudDB?: {
        dataSize?: long(name='DataSize'),
        read?: long(name='Read'),
        write?: long(name='Write'),
      }(name='CloudDB'),
      cloudFunction?: {
        compute?: long(name='Compute'),
        count?: long(name='Count'),
        traffic?: long(name='Traffic'),
      }(name='CloudFunction'),
      cloudStorage?: {
        dataSize?: long(name='DataSize'),
        download?: long(name='Download'),
        traffic?: long(name='Traffic'),
        upload?: long(name='Upload'),
      }(name='CloudStorage'),
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
      staticWeb?: {
        dataSize?: long(name='DataSize'),
        traffic?: long(name='Traffic'),
      }(name='StaticWeb'),
    }
  ](name='DataList'),
  httpStatusCode: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  paginator?: {
    pageCount?: long(name='PageCount'),
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceUsageResponseBody(name='body'),
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceUsage', 'POST', '/', 'json', true, 'form', request);
}

model DescribeServicePolicyRequest {
  collectionName?: string(name='CollectionName', position='Body'),
  serviceName: string(name='ServiceName', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeServicePolicyResponseBody = {
  collectionName?: string(name='CollectionName'),
  policy?: string(name='Policy'),
  policyName?: string(name='PolicyName'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model DescribeServicePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeServicePolicyResponseBody(name='body'),
}

async function describeServicePolicy(request: DescribeServicePolicyRequest): DescribeServicePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeServicePolicy', 'POST', '/', 'json', true, 'form', request);
}

model DescribeSpaceClientConfigRequest {
  detail?: string(name='Detail', position='Body'),
  spaceId?: string(name='SpaceId', position='Body'),
  workspaceId?: long(name='WorkspaceId', minimum=1, maximum=9223372036854775807, position='Body'),
}

model DescribeSpaceClientConfigResponseBody = {
  apiKey?: string(name='ApiKey'),
  endpoint?: string(name='Endpoint'),
  fileUploadEndpoint?: string(name='FileUploadEndpoint'),
  name?: string(name='Name'),
  privateKey?: string(name='PrivateKey'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
}

model DescribeSpaceClientConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpaceClientConfigResponseBody(name='body'),
}

async function describeSpaceClientConfig(request: DescribeSpaceClientConfigRequest): DescribeSpaceClientConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpaceClientConfig', 'POST', '/', 'json', true, 'form', request);
}

model DescribeSpacesRequest {
  emasWorkspaceId?: long(name='EmasWorkspaceId', position='Body'),
  pageNum?: int32(name='PageNum', minimum=0, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Body'),
  spaceIds?: [ string ](name='SpaceIds', shrink='simple', position='Body'),
  specCode?: string(name='SpecCode', position='Body'),
  tenantId?: string(name='TenantId', position='Body'),
}

model DescribeSpacesResponseBody = {
  count?: int32(name='Count'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaces?: [ 
    {
      autoRenew?: boolean(name='AutoRenew'),
      chargeType?: string(name='ChargeType'),
      description?: string(name='Description'),
      emasWorkspaceId?: long(name='EmasWorkspaceId'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      instanceId?: string(name='InstanceId'),
      name?: string(name='Name'),
      orderType?: string(name='OrderType'),
      packageEndDate?: string(name='PackageEndDate'),
      packageStartDate?: string(name='PackageStartDate'),
      packageStatus?: string(name='PackageStatus'),
      renewDuration?: string(name='RenewDuration'),
      serviceStatus?: string(name='ServiceStatus'),
      spaceId?: string(name='SpaceId'),
      specCode?: string(name='SpecCode'),
    }
  ](name='Spaces'),
}

model DescribeSpacesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSpacesResponseBody(name='body'),
}

async function describeSpaces(request: DescribeSpacesRequest): DescribeSpacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSpaces', 'POST', '/', 'json', true, 'form', request);
}

model DescribeWebHostingFileRequest {
  filePath: string(name='FilePath', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model DescribeWebHostingFileResponseBody = {
  data?: {
    contentType?: string(name='ContentType'),
    eTag?: string(name='ETag'),
    exists?: boolean(name='Exists'),
    filePath?: string(name='FilePath'),
    lastModifiedTime?: long(name='LastModifiedTime'),
    signedUrl?: string(name='SignedUrl'),
    size?: long(name='Size'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DescribeWebHostingFileResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeWebHostingFileResponseBody(name='body'),
}

async function describeWebHostingFile(request: DescribeWebHostingFileRequest): DescribeWebHostingFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeWebHostingFile', 'POST', '/', 'json', true, 'form', request);
}

model EnableExtensionRequest {
  extensionId: string(name='ExtensionId', position='Body'),
}

model EnableExtensionResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableExtensionResponse = {
  headers: map[string]string(name='headers'),
  body: EnableExtensionResponseBody(name='body'),
}

async function enableExtension(request: EnableExtensionRequest): EnableExtensionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableExtension', 'POST', '/', 'json', true, 'form', request);
}

model GetWebHostingCertificateDetailRequest {
  customDomain: string(name='CustomDomain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model GetWebHostingCertificateDetailResponseBody = {
  data?: {
    certDomainName?: string(name='CertDomainName'),
    certExpiredTime?: long(name='CertExpiredTime'),
    certLife?: string(name='CertLife'),
    certName?: string(name='CertName'),
    certType?: string(name='CertType'),
    serverCertificateStatus?: string(name='ServerCertificateStatus'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingCertificateDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebHostingCertificateDetailResponseBody(name='body'),
}

async function getWebHostingCertificateDetail(request: GetWebHostingCertificateDetailRequest): GetWebHostingCertificateDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebHostingCertificateDetail', 'POST', '/', 'json', true, 'form', request);
}

model GetWebHostingConfigRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model GetWebHostingConfigResponseBody = {
  data?: {
    allowedIps?: string(name='AllowedIps'),
    defaultDomain?: string(name='DefaultDomain'),
    errorPath?: string(name='ErrorPath'),
    historyModePath?: string(name='HistoryModePath'),
    indexPath?: string(name='IndexPath'),
    spaceId?: string(name='SpaceId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebHostingConfigResponseBody(name='body'),
}

async function getWebHostingConfig(request: GetWebHostingConfigRequest): GetWebHostingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebHostingConfig', 'POST', '/', 'json', true, 'form', request);
}

model GetWebHostingDomainVerificationContentRequest {
  domain: string(name='Domain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model GetWebHostingDomainVerificationContentResponseBody = {
  data?: {
    content?: string(name='Content'),
    domain?: string(name='Domain'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingDomainVerificationContentResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebHostingDomainVerificationContentResponseBody(name='body'),
}

async function getWebHostingDomainVerificationContent(request: GetWebHostingDomainVerificationContentRequest): GetWebHostingDomainVerificationContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebHostingDomainVerificationContent', 'POST', '/', 'json', true, 'form', request);
}

model GetWebHostingStatusRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model GetWebHostingStatusResponseBody = {
  data?: {
    spaceId?: string(name='SpaceId'),
    status?: string(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingStatusResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebHostingStatusResponseBody(name='body'),
}

async function getWebHostingStatus(request: GetWebHostingStatusRequest): GetWebHostingStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebHostingStatus', 'POST', '/', 'json', true, 'form', request);
}

model GetWebHostingUploadCredentialRequest {
  filePath: string(name='FilePath', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model GetWebHostingUploadCredentialResponseBody = {
  data?: {
    accessKeyId?: string(name='AccessKeyId'),
    endpoint?: string(name='Endpoint'),
    expiredTime?: long(name='ExpiredTime'),
    filePath?: string(name='FilePath'),
    policy?: string(name='Policy'),
    securityToken?: string(name='SecurityToken'),
    signature?: string(name='Signature'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetWebHostingUploadCredentialResponse = {
  headers: map[string]string(name='headers'),
  body: GetWebHostingUploadCredentialResponseBody(name='body'),
}

async function getWebHostingUploadCredential(request: GetWebHostingUploadCredentialRequest): GetWebHostingUploadCredentialResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWebHostingUploadCredential', 'POST', '/', 'json', true, 'form', request);
}

model ListAvailableCertificatesRequest {
  domain: string(name='Domain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ListAvailableCertificatesResponseBody = {
  data?: [ 
    {
      id?: string(name='Id'),
      name?: string(name='Name'),
      statusCode?: string(name='StatusCode'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAvailableCertificatesResponse = {
  headers: map[string]string(name='headers'),
  body: ListAvailableCertificatesResponseBody(name='body'),
}

async function listAvailableCertificates(request: ListAvailableCertificatesRequest): ListAvailableCertificatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAvailableCertificates', 'POST', '/', 'json', true, 'form', request);
}

model ListCorsDomainsRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model ListCorsDomainsResponseBody = {
  domains?: [ 
    {
      domain?: string(name='Domain'),
      domainId?: string(name='DomainId'),
    }
  ](name='Domains'),
  requestId?: string(name='RequestId'),
}

model ListCorsDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: ListCorsDomainsResponseBody(name='body'),
}

async function listCorsDomains(request: ListCorsDomainsRequest): ListCorsDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCorsDomains', 'POST', '/', 'json', true, 'form', request);
}

model ListDingtalkOpenPlatformConfigsRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model ListDingtalkOpenPlatformConfigsResponseBody = {
  configs?: [ 
    {
      appId?: string(name='AppId'),
      appSecret?: string(name='AppSecret'),
      createTime?: string(name='CreateTime'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='Configs'),
  requestId?: string(name='RequestId'),
}

model ListDingtalkOpenPlatformConfigsResponse = {
  headers: map[string]string(name='headers'),
  body: ListDingtalkOpenPlatformConfigsResponseBody(name='body'),
}

async function listDingtalkOpenPlatformConfigs(request: ListDingtalkOpenPlatformConfigsRequest): ListDingtalkOpenPlatformConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDingtalkOpenPlatformConfigs', 'POST', '/', 'json', true, 'form', request);
}

model ListExtensionsRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
}

model ListExtensionsResponseBody = {
  extensions?: [ 
    {
      enabled?: string(name='Enabled'),
      extensionDesc?: string(name='ExtensionDesc'),
      extensionDocumentationLink?: string(name='ExtensionDocumentationLink'),
      extensionId?: string(name='ExtensionId'),
      extensionName?: string(name='ExtensionName'),
    }
  ](name='Extensions'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListExtensionsResponse = {
  headers: map[string]string(name='headers'),
  body: ListExtensionsResponseBody(name='body'),
}

async function listExtensions(request: ListExtensionsRequest): ListExtensionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListExtensions', 'POST', '/', 'json', true, 'form', request);
}

model ListFileRequest {
  fileId?: string(name='FileId', position='Body'),
  keyword?: string(name='Keyword', position='Body'),
  nextToken?: string(name='NextToken', position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ListFileResponseBody = {
  dataList?: [ 
    {
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      id?: string(name='Id'),
      name?: string(name='Name'),
      size?: int32(name='Size'),
      type?: string(name='Type'),
      url?: string(name='Url'),
    }
  ](name='DataList'),
  paginator?: {
    nextToken?: string(name='NextToken'),
    pageSize?: int32(name='PageSize'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFileResponse = {
  headers: map[string]string(name='headers'),
  body: ListFileResponseBody(name='body'),
}

async function listFile(request: ListFileRequest): ListFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFile', 'POST', '/', 'json', true, 'form', request);
}

model ListFunctionRequest {
  filterBy?: string(name='FilterBy', position='Body'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=100, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ListFunctionResponseBody = {
  dataList?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      desc?: string(name='Desc'),
      httpTriggerPath?: string(name='HttpTriggerPath'),
      modifiedAt?: string(name='ModifiedAt'),
      name?: string(name='Name'),
      spec?: {
        instanceConcurrency?: int32(name='InstanceConcurrency'),
        memory?: string(name='Memory'),
        runtime?: string(name='Runtime'),
        timeout?: string(name='Timeout'),
      }(name='Spec'),
      timingTriggerConfig?: string(name='TimingTriggerConfig'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionResponseBody(name='body'),
}

async function listFunction(request: ListFunctionRequest): ListFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFunction', 'POST', '/', 'json', true, 'form', request);
}

model ListFunctionDeploymentRequest {
  name: string(name='Name', position='Body'),
  pageNum?: int32(name='PageNum', minimum=1, maximum=9223372036854775807, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  status?: string(name='Status', position='Body'),
}

model ListFunctionDeploymentResponseBody = {
  dataList?: [ 
    {
      createdAt?: string(name='CreatedAt'),
      deploymentId?: string(name='DeploymentId'),
      downloadSignedUrl?: string(name='DownloadSignedUrl'),
      modifiedAt?: string(name='ModifiedAt'),
      status?: {
        label?: string(name='Label'),
        status?: string(name='Status'),
      }(name='Status'),
      versionNo?: string(name='VersionNo'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionDeploymentResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionDeploymentResponseBody(name='body'),
}

async function listFunctionDeployment(request: ListFunctionDeploymentRequest): ListFunctionDeploymentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFunctionDeployment', 'POST', '/', 'json', true, 'form', request);
}

model ListFunctionLogRequest {
  fromDate?: long(name='FromDate', position='Body'),
  logRequestId?: string(name='LogRequestId', position='Body'),
  name: string(name='Name', position='Body'),
  pageNum?: int32(name='PageNum', minimum=1, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  status?: string(name='Status', position='Body'),
  toDate?: long(name='ToDate', position='Body'),
}

model ListFunctionLogResponseBody = {
  dataList?: [ 
    {
      contents?: [ string ](name='Contents'),
      functionName?: string(name='FunctionName'),
      levels?: [ string ](name='Levels'),
      requestId?: string(name='RequestId'),
      spaceId?: string(name='SpaceId'),
      status?: string(name='Status'),
      timestamps?: [ string ](name='Timestamps'),
    }
  ](name='DataList'),
  paginator?: {
    pageCount?: int32(name='PageCount'),
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    total?: int32(name='Total'),
  }(name='Paginator'),
  requestId?: string(name='RequestId'),
}

model ListFunctionLogResponse = {
  headers: map[string]string(name='headers'),
  body: ListFunctionLogResponseBody(name='body'),
}

async function listFunctionLog(request: ListFunctionLogRequest): ListFunctionLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListFunctionLog', 'POST', '/', 'json', true, 'form', request);
}

model ListOpenPlatformConfigRequest {
  platform: string(name='Platform', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ListOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
  secretList?: [ 
    {
      appCert?: string(name='AppCert'),
      appId?: string(name='AppId'),
      appSecret?: string(name='AppSecret'),
      platform?: string(name='Platform'),
      privateKey?: string(name='PrivateKey'),
      publicCert?: string(name='PublicCert'),
      publicKey?: string(name='PublicKey'),
      rootCert?: string(name='RootCert'),
      signMode?: string(name='SignMode'),
      spaceId?: string(name='SpaceId'),
    }
  ](name='SecretList'),
}

model ListOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ListOpenPlatformConfigResponseBody(name='body'),
}

async function listOpenPlatformConfig(request: ListOpenPlatformConfigRequest): ListOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model ListSpaceRequest {
  emasWorkspaceId?: string(name='EmasWorkspaceId', position='Body'),
  pageNum?: int32(name='PageNum', minimum=0, position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Body'),
  spaceIds?: [ string ](name='SpaceIds', shrink='simple', position='Body'),
}

model ListSpaceResponseBody = {
  count?: int32(name='Count'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaces?: [ 
    {
      desc?: string(name='Desc'),
      gmtCreate?: long(name='GmtCreate'),
      gmtLastAccess?: long(name='GmtLastAccess'),
      name?: string(name='Name'),
      spaceId?: string(name='SpaceId'),
      status?: string(name='Status'),
    }
  ](name='Spaces'),
}

model ListSpaceResponse = {
  headers: map[string]string(name='headers'),
  body: ListSpaceResponseBody(name='body'),
}

async function listSpace(request: ListSpaceRequest): ListSpaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListSpace', 'POST', '/', 'json', true, 'form', request);
}

model ListWebHostingCustomDomainsRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model ListWebHostingCustomDomainsResponseBody = {
  data?: [ 
    {
      accessControlAllowOrigin?: string(name='AccessControlAllowOrigin'),
      cname?: string(name='Cname'),
      createTime?: long(name='CreateTime'),
      description?: string(name='Description'),
      domain?: string(name='Domain'),
      enableCors?: boolean(name='EnableCors'),
      forceRedirectType?: string(name='ForceRedirectType'),
      sslProtocol?: string(name='SslProtocol'),
      status?: string(name='Status'),
      updateTime?: long(name='UpdateTime'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
}

model ListWebHostingCustomDomainsResponse = {
  headers: map[string]string(name='headers'),
  body: ListWebHostingCustomDomainsResponseBody(name='body'),
}

async function listWebHostingCustomDomains(request: ListWebHostingCustomDomainsRequest): ListWebHostingCustomDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWebHostingCustomDomains', 'POST', '/', 'json', true, 'form', request);
}

model ListWebHostingFilesRequest {
  marker?: string(name='Marker', position='Body'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=500, position='Body'),
  prefix: string(name='Prefix', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ListWebHostingFilesResponseBody = {
  data?: {
    count?: int32(name='Count'),
    nextMarker?: string(name='NextMarker'),
    webHostingFiles?: [ 
      {
        contentType?: string(name='ContentType'),
        eTag?: string(name='ETag'),
        filePath?: string(name='FilePath'),
        lastModifiedTime?: long(name='LastModifiedTime'),
        signedUrl?: string(name='SignedUrl'),
        size?: long(name='Size'),
      }
    ](name='WebHostingFiles'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListWebHostingFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListWebHostingFilesResponseBody(name='body'),
}

async function listWebHostingFiles(request: ListWebHostingFilesRequest): ListWebHostingFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWebHostingFiles', 'POST', '/', 'json', true, 'form', request);
}

model ModifyWebHostingConfigRequest {
  allowedIps?: string(name='AllowedIps', position='Body'),
  errorPath?: string(name='ErrorPath', position='Body'),
  historyModePath?: string(name='HistoryModePath', position='Body'),
  indexPath: string(name='IndexPath', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model ModifyWebHostingConfigResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model ModifyWebHostingConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyWebHostingConfigResponseBody(name='body'),
}

async function modifyWebHostingConfig(request: ModifyWebHostingConfigRequest): ModifyWebHostingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyWebHostingConfig', 'POST', '/', 'json', true, 'form', request);
}

model OpenServiceRequest {
  serviceName: string(name='ServiceName', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model OpenServiceResponseBody = {
  requestId?: string(name='RequestId'),
}

model OpenServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenServiceResponseBody(name='body'),
}

async function openService(request: OpenServiceRequest): OpenServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenService', 'POST', '/', 'json', true, 'form', request);
}

model OpenWebHostingServiceRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model OpenWebHostingServiceResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model OpenWebHostingServiceResponse = {
  headers: map[string]string(name='headers'),
  body: OpenWebHostingServiceResponseBody(name='body'),
}

async function openWebHostingService(request: OpenWebHostingServiceRequest): OpenWebHostingServiceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenWebHostingService', 'POST', '/', 'json', true, 'form', request);
}

model QueryDBBackupCollectionsRequest {
  backupId: string(name='BackupId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model QueryDBBackupCollectionsResponseBody = {
  collections?: [ string ](name='Collections'),
  requestId?: string(name='RequestId'),
}

model QueryDBBackupCollectionsResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDBBackupCollectionsResponseBody(name='body'),
}

async function queryDBBackupCollections(request: QueryDBBackupCollectionsRequest): QueryDBBackupCollectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDBBackupCollections', 'POST', '/', 'json', true, 'form', request);
}

model QueryDBBackupDumpTimesRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model QueryDBBackupDumpTimesResponseBody = {
  backupDumpTimes?: [ 
    {
      backupId?: string(name='BackupId'),
      dumpTime?: string(name='DumpTime'),
    }
  ](name='BackupDumpTimes'),
  requestId?: string(name='RequestId'),
}

model QueryDBBackupDumpTimesResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDBBackupDumpTimesResponseBody(name='body'),
}

async function queryDBBackupDumpTimes(request: QueryDBBackupDumpTimesRequest): QueryDBBackupDumpTimesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDBBackupDumpTimes', 'POST', '/', 'json', true, 'form', request);
}

model QueryDBExportTaskStatusRequest {
  spaceId: string(name='SpaceId', position='Body'),
  taskId: string(name='TaskId', position='Body'),
}

model QueryDBExportTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  downloadUrl?: string(name='DownloadUrl'),
  exportedCount?: string(name='ExportedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model QueryDBExportTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDBExportTaskStatusResponseBody(name='body'),
}

async function queryDBExportTaskStatus(request: QueryDBExportTaskStatusRequest): QueryDBExportTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDBExportTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model QueryDBImportTaskStatusRequest {
  spaceId: string(name='SpaceId', position='Body'),
  taskId: string(name='TaskId', position='Body'),
}

model QueryDBImportTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  failedCount?: string(name='FailedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  successCount?: string(name='SuccessCount'),
}

model QueryDBImportTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDBImportTaskStatusResponseBody(name='body'),
}

async function queryDBImportTaskStatus(request: QueryDBImportTaskStatusRequest): QueryDBImportTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDBImportTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model QueryDBRestoreTaskStatusRequest {
  spaceId: string(name='SpaceId', position='Body'),
  taskId: string(name='TaskId', position='Body'),
}

model QueryDBRestoreTaskStatusResponseBody = {
  detailMessage?: string(name='DetailMessage'),
  failedCount?: long(name='FailedCount'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  successCount?: long(name='SuccessCount'),
}

model QueryDBRestoreTaskStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryDBRestoreTaskStatusResponseBody(name='body'),
}

async function queryDBRestoreTaskStatus(request: QueryDBRestoreTaskStatusRequest): QueryDBRestoreTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryDBRestoreTaskStatus', 'POST', '/', 'json', true, 'form', request);
}

model QueryServiceStatusRequest {
  serviceName: string(name='ServiceName', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model QueryServiceStatusResponseBody = {
  requestId?: string(name='RequestId'),
  serviceStatus?: string(name='ServiceStatus'),
}

model QueryServiceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: QueryServiceStatusResponseBody(name='body'),
}

async function queryServiceStatus(request: QueryServiceStatusRequest): QueryServiceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryServiceStatus', 'POST', '/', 'json', true, 'form', request);
}

model QuerySpaceConsumptionRequest {
  spaceId?: string(name='SpaceId', position='Body'),
}

model QuerySpaceConsumptionResponseBody = {
  csUsage?: {
    cdnTraffic?: long(name='CdnTraffic'),
    downloadCount?: long(name='DownloadCount'),
    storageSize?: long(name='StorageSize'),
    uploadCount?: long(name='UploadCount'),
  }(name='CsUsage'),
  cycleEndTime?: long(name='CycleEndTime'),
  cycleStartTime?: long(name='CycleStartTime'),
  dbUsage?: {
    readCount?: long(name='ReadCount'),
    storageSize?: long(name='StorageSize'),
    writeCount?: long(name='WriteCount'),
  }(name='DbUsage'),
  fcUsage?: {
    cost?: long(name='Cost'),
    requestCount?: long(name='RequestCount'),
    txTraffic?: long(name='TxTraffic'),
  }(name='FcUsage'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
  specCode?: string(name='SpecCode'),
  whUsage?: {
    cdnTraffic?: long(name='CdnTraffic'),
    storageSize?: long(name='StorageSize'),
  }(name='WhUsage'),
}

model QuerySpaceConsumptionResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySpaceConsumptionResponseBody(name='body'),
}

async function querySpaceConsumption(request: QuerySpaceConsumptionRequest): QuerySpaceConsumptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySpaceConsumption', 'POST', '/', 'json', true, 'form', request);
}

model QuerySpaceSpecDetailRequest {
  specCode: string(name='SpecCode', position='Body'),
}

model QuerySpaceSpecDetailResponseBody = {
  csCdnTraffic?: long(name='CsCdnTraffic'),
  csDownloadCount?: long(name='CsDownloadCount'),
  csStorageSize?: long(name='CsStorageSize'),
  csUploadCount?: long(name='CsUploadCount'),
  dbReadCount?: long(name='DbReadCount'),
  dbStorageSize?: long(name='DbStorageSize'),
  dbWriteCount?: long(name='DbWriteCount'),
  fcCost?: long(name='FcCost'),
  fcRequestCount?: long(name='FcRequestCount'),
  fcTxTraffic?: long(name='FcTxTraffic'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  specCode?: string(name='SpecCode'),
  specDetailText?: string(name='SpecDetailText'),
  whCdnTraffic?: long(name='WhCdnTraffic'),
  whStorageSize?: long(name='WhStorageSize'),
}

model QuerySpaceSpecDetailResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySpaceSpecDetailResponseBody(name='body'),
}

async function querySpaceSpecDetail(request: QuerySpaceSpecDetailRequest): QuerySpaceSpecDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySpaceSpecDetail', 'POST', '/', 'json', true, 'form', request);
}

model QuerySpaceUsageRequest {
  endTime?: string(name='EndTime', position='Body'),
  spaceId?: string(name='SpaceId', position='Body'),
  startTime?: string(name='StartTime', position='Body'),
}

model QuerySpaceUsageResponseBody = {
  endTime?: string(name='EndTime'),
  gmtCreate?: string(name='GmtCreate'),
  requestId?: string(name='RequestId'),
  spaceId?: string(name='SpaceId'),
  spaceUsageDataList?: [ 
    {
      csUsage?: {
        cdnTraffic?: long(name='CdnTraffic'),
        downloadCount?: long(name='DownloadCount'),
        storageSize?: long(name='StorageSize'),
        uploadCount?: long(name='UploadCount'),
      }(name='CsUsage'),
      dbUsage?: {
        readCount?: long(name='ReadCount'),
        storageSize?: long(name='StorageSize'),
        writeCount?: long(name='WriteCount'),
      }(name='DbUsage'),
      fcUsage?: {
        cost?: long(name='Cost'),
        requestCount?: long(name='RequestCount'),
        txTraffic?: long(name='TxTraffic'),
      }(name='FcUsage'),
      timestamp?: string(name='Timestamp'),
      whUsage?: {
        cdnTraffic?: long(name='CdnTraffic'),
        storageSize?: long(name='StorageSize'),
      }(name='WhUsage'),
    }
  ](name='SpaceUsageDataList'),
  startTime?: string(name='StartTime'),
}

model QuerySpaceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySpaceUsageResponseBody(name='body'),
}

async function querySpaceUsage(request: QuerySpaceUsageRequest): QuerySpaceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySpaceUsage', 'POST', '/', 'json', true, 'form', request);
}

model RefreshWebHostingCustomDomainCacheRequest {
  domainName: string(name='DomainName', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model RefreshWebHostingCustomDomainCacheResponseBody = {
  requestId?: string(name='RequestId'),
}

model RefreshWebHostingCustomDomainCacheResponse = {
  headers: map[string]string(name='headers'),
  body: RefreshWebHostingCustomDomainCacheResponseBody(name='body'),
}

async function refreshWebHostingCustomDomainCache(request: RefreshWebHostingCustomDomainCacheRequest): RefreshWebHostingCustomDomainCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RefreshWebHostingCustomDomainCache', 'POST', '/', 'json', true, 'form', request);
}

model RegisterFileRequest {
  id: string(name='Id', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model RegisterFileResponseBody = {
  requestId?: string(name='RequestId'),
}

model RegisterFileResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterFileResponseBody(name='body'),
}

async function registerFile(request: RegisterFileRequest): RegisterFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RegisterFile', 'POST', '/', 'json', true, 'form', request);
}

model RenameDBCollectionRequest {
  newCollection: string(name='NewCollection', position='Body'),
  originCollection: string(name='OriginCollection', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model RenameDBCollectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RenameDBCollectionResponse = {
  headers: map[string]string(name='headers'),
  body: RenameDBCollectionResponseBody(name='body'),
}

async function renameDBCollection(request: RenameDBCollectionRequest): RenameDBCollectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenameDBCollection', 'POST', '/', 'json', true, 'form', request);
}

model ResetServerSecretRequest {
  spaceId: string(name='SpaceId', position='Body'),
}

model ResetServerSecretResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetServerSecretResponse = {
  headers: map[string]string(name='headers'),
  body: ResetServerSecretResponseBody(name='body'),
}

async function resetServerSecret(request: ResetServerSecretRequest): ResetServerSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetServerSecret', 'POST', '/', 'json', true, 'form', request);
}

model RunDBCommandRequest {
  body: string(name='Body', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model RunDBCommandResponseBody = {
  affectedDocs?: int32(name='AffectedDocs'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model RunDBCommandResponse = {
  headers: map[string]string(name='headers'),
  body: RunDBCommandResponseBody(name='body'),
}

async function runDBCommand(request: RunDBCommandRequest): RunDBCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunDBCommand', 'POST', '/', 'json', true, 'form', request);
}

model RunFunctionRequest {
  body: string(name='Body', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model RunFunctionResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  runtimeMeta?: {
    billingDuration?: int32(name='BillingDuration'),
    invocationDuration?: int32(name='InvocationDuration'),
    maxMemoryUsage?: int32(name='MaxMemoryUsage'),
    requestId?: string(name='RequestId'),
  }(name='RuntimeMeta'),
}

model RunFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: RunFunctionResponseBody(name='body'),
}

async function runFunction(request: RunFunctionRequest): RunFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunFunction', 'POST', '/', 'json', true, 'form', request);
}

model SaveAntOpenPlatformConfigRequest {
  appCert?: string(name='AppCert', position='Body'),
  appId: string(name='AppId', maxLength=64, position='Body'),
  privateKey: string(name='PrivateKey', position='Body'),
  publicCert?: string(name='PublicCert', position='Body'),
  publicKey?: string(name='PublicKey', position='Body'),
  rootCert?: string(name='RootCert', position='Body'),
  signMode: string(name='SignMode', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model SaveAntOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveAntOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveAntOpenPlatformConfigResponseBody(name='body'),
}

async function saveAntOpenPlatformConfig(request: SaveAntOpenPlatformConfigRequest): SaveAntOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveAntOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model SaveAppAuthTokenRequest {
  appAuthToken: string(name='AppAuthToken', position='Body'),
  appId: string(name='AppId', position='Body'),
  isvAppId: string(name='IsvAppId', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model SaveAppAuthTokenResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveAppAuthTokenResponse = {
  headers: map[string]string(name='headers'),
  body: SaveAppAuthTokenResponseBody(name='body'),
}

async function saveAppAuthToken(request: SaveAppAuthTokenRequest): SaveAppAuthTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveAppAuthToken', 'POST', '/', 'json', true, 'form', request);
}

model SaveWebHostingCustomDomainConfigRequest {
  domainName: string(name='DomainName', position='Body'),
  forceRedirectType: string(name='ForceRedirectType', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model SaveWebHostingCustomDomainConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveWebHostingCustomDomainConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveWebHostingCustomDomainConfigResponseBody(name='body'),
}

async function saveWebHostingCustomDomainConfig(request: SaveWebHostingCustomDomainConfigRequest): SaveWebHostingCustomDomainConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveWebHostingCustomDomainConfig', 'POST', '/', 'json', true, 'form', request);
}

model SaveWebHostingCustomDomainCorsConfigRequest {
  accessControlAllowOrigin?: string(name='AccessControlAllowOrigin', position='Body'),
  domainName: string(name='DomainName', position='Body'),
  enableCors: boolean(name='EnableCors', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model SaveWebHostingCustomDomainCorsConfigResponseBody = {
  code?: string(name='Code', description='Id of the request'),
  data?: boolean(name='Data'),
  httpStatusCode?: string(name='HttpStatusCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SaveWebHostingCustomDomainCorsConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveWebHostingCustomDomainCorsConfigResponseBody(name='body'),
}

async function saveWebHostingCustomDomainCorsConfig(request: SaveWebHostingCustomDomainCorsConfigRequest): SaveWebHostingCustomDomainCorsConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveWebHostingCustomDomainCorsConfig', 'POST', '/', 'json', true, 'form', request);
}

model SaveWechatOpenPlatformConfigRequest {
  appId: string(name='AppId', maxLength=64, position='Body'),
  appSecret: string(name='AppSecret', maxLength=200, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model SaveWechatOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model SaveWechatOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: SaveWechatOpenPlatformConfigResponseBody(name='body'),
}

async function saveWechatOpenPlatformConfig(request: SaveWechatOpenPlatformConfigRequest): SaveWechatOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SaveWechatOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model UnbindWebHostingCustomDomainRequest {
  customDomain: string(name='CustomDomain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model UnbindWebHostingCustomDomainResponseBody = {
  data?: boolean(name='Data'),
  requestId?: string(name='RequestId'),
}

model UnbindWebHostingCustomDomainResponse = {
  headers: map[string]string(name='headers'),
  body: UnbindWebHostingCustomDomainResponseBody(name='body'),
}

async function unbindWebHostingCustomDomain(request: UnbindWebHostingCustomDomainRequest): UnbindWebHostingCustomDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbindWebHostingCustomDomain', 'POST', '/', 'json', true, 'form', request);
}

model UpdateDingtalkOpenPlatformConfigRequest {
  appId: string(name='AppId', maxLength=128, position='Body'),
  appSecret: string(name='AppSecret', maxLength=400, position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model UpdateDingtalkOpenPlatformConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDingtalkOpenPlatformConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDingtalkOpenPlatformConfigResponseBody(name='body'),
}

async function updateDingtalkOpenPlatformConfig(request: UpdateDingtalkOpenPlatformConfigRequest): UpdateDingtalkOpenPlatformConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDingtalkOpenPlatformConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateFunctionRequest {
  desc?: string(name='Desc', maxLength=128, position='Body'),
  httpTriggerPath?: string(name='HttpTriggerPath', maxLength=128, position='Body'),
  instanceConcurrency?: int32(name='InstanceConcurrency', minimum=1, maximum=100, position='Body'),
  memory?: int32(name='Memory', minimum=128, maximum=3096, position='Body'),
  name: string(name='Name', position='Body'),
  runtime?: string(name='Runtime', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  timeout?: int32(name='Timeout', minimum=1, maximum=600, position='Body'),
  timingTriggerConfig?: string(name='TimingTriggerConfig', position='Body'),
  timingTriggerUserPayload?: string(name='TimingTriggerUserPayload', position='Body'),
}

model UpdateFunctionResponseBody = {
  createdAt?: string(name='CreatedAt'),
  desc?: string(name='Desc'),
  httpTriggerPath?: string(name='HttpTriggerPath'),
  modifiedAt?: string(name='ModifiedAt'),
  name?: string(name='Name'),
  requestId?: string(name='RequestId'),
  spec?: {
    instanceConcurrency?: int32(name='InstanceConcurrency'),
    memory?: string(name='Memory'),
    runtime?: string(name='Runtime'),
    timeout?: string(name='Timeout'),
  }(name='Spec'),
  timingTriggerConfig?: string(name='TimingTriggerConfig'),
  timingTriggerUserPayload?: string(name='TimingTriggerUserPayload'),
}

model UpdateFunctionResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateFunctionResponseBody(name='body'),
}

async function updateFunction(request: UpdateFunctionRequest): UpdateFunctionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateFunction', 'POST', '/', 'json', true, 'form', request);
}

model UpdateHttpTriggerConfigRequest {
  customDomain?: string(name='CustomDomain', maxLength=253, position='Body'),
  customDomainCertificate?: string(name='CustomDomainCertificate', position='Body'),
  customDomainPrivateKey?: string(name='CustomDomainPrivateKey', position='Body'),
  enableService: boolean(name='EnableService', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model UpdateHttpTriggerConfigResponseBody = {
  customDomain?: string(name='CustomDomain'),
  customDomainCertificateInfo?: string(name='CustomDomainCertificateInfo'),
  customDomainCname?: string(name='CustomDomainCname'),
  defaultEndpoint?: string(name='DefaultEndpoint'),
  enableService?: boolean(name='EnableService'),
  requestId?: string(name='RequestId'),
}

model UpdateHttpTriggerConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateHttpTriggerConfigResponseBody(name='body'),
}

async function updateHttpTriggerConfig(request: UpdateHttpTriggerConfigRequest): UpdateHttpTriggerConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateHttpTriggerConfig', 'POST', '/', 'json', true, 'form', request);
}

model UpdateServicePolicyRequest {
  collectionName?: string(name='CollectionName', position='Body'),
  policy?: string(name='Policy', position='Body'),
  policyName?: string(name='PolicyName', position='Body'),
  serviceName: string(name='ServiceName', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
}

model UpdateServicePolicyResponseBody = {
  collectionName?: string(name='CollectionName'),
  policy?: string(name='Policy'),
  policyName?: string(name='PolicyName'),
  requestId?: string(name='RequestId'),
  serviceName?: string(name='ServiceName'),
  spaceId?: string(name='SpaceId'),
}

model UpdateServicePolicyResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateServicePolicyResponseBody(name='body'),
}

async function updateServicePolicy(request: UpdateServicePolicyRequest): UpdateServicePolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateServicePolicy', 'POST', '/', 'json', true, 'form', request);
}

model UpdateSpaceRequest {
  desc?: string(name='Desc', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  status?: string(name='Status', position='Body'),
}

model UpdateSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSpaceResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateSpaceResponseBody(name='body'),
}

async function updateSpace(request: UpdateSpaceRequest): UpdateSpaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateSpace', 'POST', '/', 'json', true, 'form', request);
}

model VerifyWebHostingDomainOwnerRequest {
  domain: string(name='Domain', position='Body'),
  spaceId: string(name='SpaceId', position='Body'),
  verifyType: string(name='VerifyType', position='Body'),
}

model VerifyWebHostingDomainOwnerResponseBody = {
  requestId?: string(name='RequestId'),
}

model VerifyWebHostingDomainOwnerResponse = {
  headers: map[string]string(name='headers'),
  body: VerifyWebHostingDomainOwnerResponseBody(name='body'),
}

async function verifyWebHostingDomainOwner(request: VerifyWebHostingDomainOwnerRequest): VerifyWebHostingDomainOwnerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyWebHostingDomainOwner', 'POST', '/', 'json', true, 'form', request);
}

