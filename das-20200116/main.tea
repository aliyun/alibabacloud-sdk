/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'central';
  @endpointMap = {
    cn-shanghai = 'das.cn-shanghai.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('das', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AddHDMInstanceRequest {
  engine?: string(name='Engine'),
  flushAccount?: string(name='FlushAccount'),
  instanceAlias?: string(name='InstanceAlias'),
  instanceArea?: string(name='InstanceArea'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  networkType?: string(name='NetworkType'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  region?: string(name='Region'),
  username?: string(name='Username'),
  vpcId?: string(name='VpcId'),
  context?: string(name='__context'),
}

model AddHDMInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    callerUid?: string(name='CallerUid'),
    code?: int32(name='Code'),
    error?: string(name='Error'),
    instanceId?: string(name='InstanceId'),
    ip?: string(name='Ip'),
    ownerId?: string(name='OwnerId'),
    port?: int32(name='Port'),
    role?: string(name='Role'),
    tenantId?: string(name='TenantId'),
    token?: string(name='Token'),
    uuid?: string(name='Uuid'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model AddHDMInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AddHDMInstanceResponseBody(name='body'),
}

async function addHDMInstanceWithOptions(request: AddHDMInstanceRequest, runtime: Util.RuntimeOptions): AddHDMInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.flushAccount)) {
    query['FlushAccount'] = request.flushAccount;
  }
  if (!Util.isUnset(request.instanceAlias)) {
    query['InstanceAlias'] = request.instanceAlias;
  }
  if (!Util.isUnset(request.instanceArea)) {
    query['InstanceArea'] = request.instanceArea;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ip)) {
    query['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddHDMInstance',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addHDMInstance(request: AddHDMInstanceRequest): AddHDMInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addHDMInstanceWithOptions(request, runtime);
}

model CreateAdamBenchTaskRequest {
  description?: string(name='Description'),
  dstInstanceId?: string(name='DstInstanceId'),
  dstSuperAccount?: string(name='DstSuperAccount'),
  dstSuperPassword?: string(name='DstSuperPassword'),
  rate?: int32(name='Rate'),
  requestDuration?: long(name='RequestDuration'),
  requestStartTime?: long(name='RequestStartTime'),
  srcEngine?: string(name='SrcEngine'),
  srcEngineVersion?: string(name='SrcEngineVersion'),
  srcMaxQps?: double(name='SrcMaxQps'),
  srcMeanQps?: double(name='SrcMeanQps'),
  srcSqlOssAddr?: string(name='SrcSqlOssAddr'),
}

model CreateAdamBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateAdamBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAdamBenchTaskResponseBody(name='body'),
}

async function createAdamBenchTaskWithOptions(request: CreateAdamBenchTaskRequest, runtime: Util.RuntimeOptions): CreateAdamBenchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dstInstanceId)) {
    query['DstInstanceId'] = request.dstInstanceId;
  }
  if (!Util.isUnset(request.dstSuperAccount)) {
    query['DstSuperAccount'] = request.dstSuperAccount;
  }
  if (!Util.isUnset(request.dstSuperPassword)) {
    query['DstSuperPassword'] = request.dstSuperPassword;
  }
  if (!Util.isUnset(request.rate)) {
    query['Rate'] = request.rate;
  }
  if (!Util.isUnset(request.requestDuration)) {
    query['RequestDuration'] = request.requestDuration;
  }
  if (!Util.isUnset(request.requestStartTime)) {
    query['RequestStartTime'] = request.requestStartTime;
  }
  if (!Util.isUnset(request.srcEngine)) {
    query['SrcEngine'] = request.srcEngine;
  }
  if (!Util.isUnset(request.srcEngineVersion)) {
    query['SrcEngineVersion'] = request.srcEngineVersion;
  }
  if (!Util.isUnset(request.srcMaxQps)) {
    query['SrcMaxQps'] = request.srcMaxQps;
  }
  if (!Util.isUnset(request.srcMeanQps)) {
    query['SrcMeanQps'] = request.srcMeanQps;
  }
  if (!Util.isUnset(request.srcSqlOssAddr)) {
    query['SrcSqlOssAddr'] = request.srcSqlOssAddr;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAdamBenchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAdamBenchTask(request: CreateAdamBenchTaskRequest): CreateAdamBenchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAdamBenchTaskWithOptions(request, runtime);
}

model CreateCacheAnalysisJobRequest {
  backupSetId?: string(name='BackupSetId'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
}

model CreateCacheAnalysisJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeys?: {
      keyInfo?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        db?: int32(name='Db'),
        encoding?: string(name='Encoding'),
        expirationTimeMillis?: long(name='ExpirationTimeMillis'),
        key?: string(name='Key'),
        nodeId?: string(name='NodeId'),
        type?: string(name='Type'),
      }
    ](name='KeyInfo')
    }(name='BigKeys'),
    instanceId?: string(name='InstanceId'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    nodeId?: string(name='NodeId'),
    taskState?: string(name='TaskState'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateCacheAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCacheAnalysisJobResponseBody(name='body'),
}

async function createCacheAnalysisJobWithOptions(request: CreateCacheAnalysisJobRequest, runtime: Util.RuntimeOptions): CreateCacheAnalysisJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupSetId)) {
    query['BackupSetId'] = request.backupSetId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCacheAnalysisJob',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCacheAnalysisJob(request: CreateCacheAnalysisJobRequest): CreateCacheAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCacheAnalysisJobWithOptions(request, runtime);
}

model CreateCloudBenchTasksRequest {
  amount?: string(name='Amount'),
  backupId?: string(name='BackupId'),
  backupTime?: string(name='BackupTime'),
  clientType?: string(name='ClientType'),
  description?: string(name='Description'),
  dstConnectionString?: string(name='DstConnectionString'),
  dstInstanceId?: string(name='DstInstanceId'),
  dstPort?: string(name='DstPort'),
  dstSuperAccount?: string(name='DstSuperAccount'),
  dstSuperPassword?: string(name='DstSuperPassword'),
  dstType?: string(name='DstType'),
  dtsJobClass?: string(name='DtsJobClass'),
  dtsJobId?: string(name='DtsJobId'),
  endState?: string(name='EndState'),
  gatewayVpcId?: string(name='GatewayVpcId'),
  gatewayVpcIp?: string(name='GatewayVpcIp'),
  rate?: string(name='Rate'),
  requestDuration?: string(name='RequestDuration'),
  requestEndTime?: string(name='RequestEndTime'),
  requestStartTime?: string(name='RequestStartTime'),
  smartPressureTime?: string(name='SmartPressureTime'),
  srcInstanceId?: string(name='SrcInstanceId'),
  srcPublicIp?: string(name='SrcPublicIp'),
  srcSuperAccount?: string(name='SrcSuperAccount'),
  srcSuperPassword?: string(name='SrcSuperPassword'),
  taskType?: string(name='TaskType'),
  workDir?: string(name='WorkDir'),
}

model CreateCloudBenchTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskIds?: [ string ](name='taskIds')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateCloudBenchTasksResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCloudBenchTasksResponseBody(name='body'),
}

async function createCloudBenchTasksWithOptions(request: CreateCloudBenchTasksRequest, runtime: Util.RuntimeOptions): CreateCloudBenchTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupTime)) {
    query['BackupTime'] = request.backupTime;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.dstConnectionString)) {
    query['DstConnectionString'] = request.dstConnectionString;
  }
  if (!Util.isUnset(request.dstInstanceId)) {
    query['DstInstanceId'] = request.dstInstanceId;
  }
  if (!Util.isUnset(request.dstPort)) {
    query['DstPort'] = request.dstPort;
  }
  if (!Util.isUnset(request.dstSuperAccount)) {
    query['DstSuperAccount'] = request.dstSuperAccount;
  }
  if (!Util.isUnset(request.dstSuperPassword)) {
    query['DstSuperPassword'] = request.dstSuperPassword;
  }
  if (!Util.isUnset(request.dstType)) {
    query['DstType'] = request.dstType;
  }
  if (!Util.isUnset(request.dtsJobClass)) {
    query['DtsJobClass'] = request.dtsJobClass;
  }
  if (!Util.isUnset(request.dtsJobId)) {
    query['DtsJobId'] = request.dtsJobId;
  }
  if (!Util.isUnset(request.endState)) {
    query['EndState'] = request.endState;
  }
  if (!Util.isUnset(request.gatewayVpcId)) {
    query['GatewayVpcId'] = request.gatewayVpcId;
  }
  if (!Util.isUnset(request.gatewayVpcIp)) {
    query['GatewayVpcIp'] = request.gatewayVpcIp;
  }
  if (!Util.isUnset(request.rate)) {
    query['Rate'] = request.rate;
  }
  if (!Util.isUnset(request.requestDuration)) {
    query['RequestDuration'] = request.requestDuration;
  }
  if (!Util.isUnset(request.requestEndTime)) {
    query['RequestEndTime'] = request.requestEndTime;
  }
  if (!Util.isUnset(request.requestStartTime)) {
    query['RequestStartTime'] = request.requestStartTime;
  }
  if (!Util.isUnset(request.smartPressureTime)) {
    query['SmartPressureTime'] = request.smartPressureTime;
  }
  if (!Util.isUnset(request.srcInstanceId)) {
    query['SrcInstanceId'] = request.srcInstanceId;
  }
  if (!Util.isUnset(request.srcPublicIp)) {
    query['SrcPublicIp'] = request.srcPublicIp;
  }
  if (!Util.isUnset(request.srcSuperAccount)) {
    query['SrcSuperAccount'] = request.srcSuperAccount;
  }
  if (!Util.isUnset(request.srcSuperPassword)) {
    query['SrcSuperPassword'] = request.srcSuperPassword;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.workDir)) {
    query['WorkDir'] = request.workDir;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudBenchTasks',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCloudBenchTasks(request: CreateCloudBenchTasksRequest): CreateCloudBenchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudBenchTasksWithOptions(request, runtime);
}

model CreateDiagnosticReportRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  startTime?: string(name='StartTime'),
}

model CreateDiagnosticReportResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReportWithOptions(request: CreateDiagnosticReportRequest, runtime: Util.RuntimeOptions): CreateDiagnosticReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDiagnosticReport',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiagnosticReportWithOptions(request, runtime);
}

model CreateRequestDiagnosisRequest {
  database?: string(name='Database'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
  sql?: string(name='Sql'),
}

model CreateRequestDiagnosisResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateRequestDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRequestDiagnosisResponseBody(name='body'),
}

async function createRequestDiagnosisWithOptions(request: CreateRequestDiagnosisRequest, runtime: Util.RuntimeOptions): CreateRequestDiagnosisResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.sql)) {
    query['Sql'] = request.sql;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRequestDiagnosis',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRequestDiagnosis(request: CreateRequestDiagnosisRequest): CreateRequestDiagnosisResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRequestDiagnosisWithOptions(request, runtime);
}

model DeleteCloudBenchTaskRequest {
  taskId?: string(name='TaskId'),
}

model DeleteCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCloudBenchTaskResponseBody(name='body'),
}

async function deleteCloudBenchTaskWithOptions(request: DeleteCloudBenchTaskRequest, runtime: Util.RuntimeOptions): DeleteCloudBenchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCloudBenchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCloudBenchTask(request: DeleteCloudBenchTaskRequest): DeleteCloudBenchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCloudBenchTaskWithOptions(request, runtime);
}

model DescribeCacheAnalysisJobRequest {
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
}

model DescribeCacheAnalysisJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeys?: {
      keyInfo?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        db?: int32(name='Db'),
        encoding?: string(name='Encoding'),
        expirationTimeMillis?: long(name='ExpirationTimeMillis'),
        key?: string(name='Key'),
        nodeId?: string(name='NodeId'),
        type?: string(name='Type'),
      }
    ](name='KeyInfo')
    }(name='BigKeys'),
    instanceId?: string(name='InstanceId'),
    jobId?: string(name='JobId'),
    keyPrefixes?: {
      prefix?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        keyNum?: long(name='KeyNum'),
        prefix?: string(name='Prefix'),
        type?: string(name='Type'),
      }
    ](name='Prefix')
    }(name='KeyPrefixes'),
    message?: string(name='Message'),
    nodeId?: string(name='NodeId'),
    taskState?: string(name='TaskState'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCacheAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCacheAnalysisJobResponseBody(name='body'),
}

async function describeCacheAnalysisJobWithOptions(request: DescribeCacheAnalysisJobRequest, runtime: Util.RuntimeOptions): DescribeCacheAnalysisJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCacheAnalysisJob',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCacheAnalysisJob(request: DescribeCacheAnalysisJobRequest): DescribeCacheAnalysisJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCacheAnalysisJobWithOptions(request, runtime);
}

model DescribeCacheAnalysisJobsRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model DescribeCacheAnalysisJobsResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      cacheAnalysisJob?: [ 
      {
        bigKeys?: {
          keyInfo?: [ 
          {
            bytes?: long(name='Bytes'),
            count?: long(name='Count'),
            db?: int32(name='Db'),
            encoding?: string(name='Encoding'),
            expirationTimeMillis?: long(name='ExpirationTimeMillis'),
            key?: string(name='Key'),
            nodeId?: string(name='NodeId'),
            type?: string(name='Type'),
          }
        ](name='KeyInfo')
        }(name='BigKeys'),
        instanceId?: string(name='InstanceId'),
        jobId?: string(name='JobId'),
        message?: string(name='Message'),
        nodeId?: string(name='NodeId'),
        taskState?: string(name='TaskState'),
      }
    ](name='CacheAnalysisJob')
    }(name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCacheAnalysisJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCacheAnalysisJobsResponseBody(name='body'),
}

async function describeCacheAnalysisJobsWithOptions(request: DescribeCacheAnalysisJobsRequest, runtime: Util.RuntimeOptions): DescribeCacheAnalysisJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCacheAnalysisJobs',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCacheAnalysisJobs(request: DescribeCacheAnalysisJobsRequest): DescribeCacheAnalysisJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCacheAnalysisJobsWithOptions(request, runtime);
}

model DescribeCloudBenchTasksRequest {
  endTime?: string(name='EndTime'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  taskType?: string(name='TaskType'),
}

model DescribeCloudBenchTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      cloudbenchTasks?: [ 
      {
        archiveJobId?: string(name='ArchiveJobId'),
        archiveOssTableName?: string(name='ArchiveOssTableName'),
        archiveState?: int32(name='ArchiveState'),
        backupId?: string(name='BackupId'),
        backupType?: string(name='BackupType'),
        benchStep?: string(name='BenchStep'),
        benchStepStatus?: string(name='BenchStepStatus'),
        clientGatewayId?: string(name='ClientGatewayId'),
        clientType?: string(name='ClientType'),
        description?: string(name='Description'),
        dstInstanceUuid?: string(name='DstInstanceUuid'),
        dstIp?: string(name='DstIp'),
        dstPort?: int32(name='DstPort'),
        dstType?: string(name='DstType'),
        dtsJobClass?: string(name='DtsJobClass'),
        dtsJobId?: string(name='DtsJobId'),
        dtsJobName?: string(name='DtsJobName'),
        dtsJobState?: int32(name='DtsJobState'),
        dtsJobStatus?: string(name='DtsJobStatus'),
        ecsInstanceId?: string(name='EcsInstanceId'),
        endState?: string(name='EndState'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        external?: string(name='External'),
        rate?: int32(name='Rate'),
        requestDuration?: long(name='RequestDuration'),
        smartPressureTime?: int32(name='SmartPressureTime'),
        source?: string(name='Source'),
        sqlCompleteReuse?: string(name='SqlCompleteReuse'),
        srcInstanceArea?: string(name='SrcInstanceArea'),
        srcInstanceUuid?: string(name='SrcInstanceUuid'),
        srcPublicIp?: string(name='SrcPublicIp'),
        state?: string(name='State'),
        status?: string(name='Status'),
        tableSchema?: string(name='TableSchema'),
        taskId?: string(name='TaskId'),
        taskType?: string(name='TaskType'),
        topic?: string(name='Topic'),
        userId?: string(name='UserId'),
        version?: string(name='Version'),
        workDir?: string(name='WorkDir'),
      }
    ](name='cloudbenchTasks')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudBenchTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudBenchTasksResponseBody(name='body'),
}

async function describeCloudBenchTasksWithOptions(request: DescribeCloudBenchTasksRequest, runtime: Util.RuntimeOptions): DescribeCloudBenchTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudBenchTasks',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudBenchTasks(request: DescribeCloudBenchTasksRequest): DescribeCloudBenchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudBenchTasksWithOptions(request, runtime);
}

model DescribeCloudbenchTaskRequest {
  taskId?: string(name='TaskId'),
}

model DescribeCloudbenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    archiveJobId?: string(name='ArchiveJobId'),
    archiveOssTableName?: string(name='ArchiveOssTableName'),
    archiveState?: int32(name='ArchiveState'),
    backupId?: string(name='BackupId'),
    backupType?: string(name='BackupType'),
    benchStep?: string(name='BenchStep'),
    benchStepStatus?: string(name='BenchStepStatus'),
    clientGatewayId?: string(name='ClientGatewayId'),
    clientType?: string(name='ClientType'),
    description?: string(name='Description'),
    dstInstanceUuid?: string(name='DstInstanceUuid'),
    dstIp?: string(name='DstIp'),
    dstPort?: int32(name='DstPort'),
    dstType?: string(name='DstType'),
    dtsJobClass?: string(name='DtsJobClass'),
    dtsJobId?: string(name='DtsJobId'),
    dtsJobName?: string(name='DtsJobName'),
    dtsJobState?: int32(name='DtsJobState'),
    dtsJobStatus?: string(name='DtsJobStatus'),
    ecsInstanceId?: string(name='EcsInstanceId'),
    endState?: string(name='EndState'),
    errorCode?: string(name='ErrorCode'),
    errorMessage?: string(name='ErrorMessage'),
    external?: string(name='External'),
    rate?: long(name='Rate'),
    requestDuration?: long(name='RequestDuration'),
    smartPressureTime?: int32(name='SmartPressureTime'),
    source?: string(name='Source'),
    sqlCompleteReuse?: string(name='SqlCompleteReuse'),
    srcInstanceArea?: string(name='SrcInstanceArea'),
    srcInstanceUuid?: string(name='SrcInstanceUuid'),
    srcPublicIp?: string(name='SrcPublicIp'),
    state?: string(name='State'),
    status?: string(name='Status'),
    tableSchema?: string(name='TableSchema'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
    topic?: string(name='Topic'),
    userId?: string(name='UserId'),
    version?: string(name='Version'),
    workDir?: string(name='WorkDir'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudbenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudbenchTaskResponseBody(name='body'),
}

async function describeCloudbenchTaskWithOptions(request: DescribeCloudbenchTaskRequest, runtime: Util.RuntimeOptions): DescribeCloudbenchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudbenchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudbenchTask(request: DescribeCloudbenchTaskRequest): DescribeCloudbenchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudbenchTaskWithOptions(request, runtime);
}

model DescribeCloudbenchTaskConfigRequest {
  taskId?: string(name='TaskId'),
}

model DescribeCloudbenchTaskConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    archiveFolder?: string(name='ArchiveFolder'),
    benchCmd?: string(name='BenchCmd'),
    clientJarPath?: string(name='ClientJarPath'),
    jarOnOss?: string(name='JarOnOss'),
    loadCmd?: string(name='LoadCmd'),
    metaFileName?: string(name='MetaFileName'),
    metaFileOnOss?: string(name='MetaFileOnOss'),
    metaFilePath?: string(name='MetaFilePath'),
    parseCmd?: string(name='ParseCmd'),
    parseFilePath?: string(name='ParseFilePath'),
    rocksDbPath?: string(name='RocksDbPath'),
    sqlFileName?: string(name='SqlFileName'),
    sqlFileOnOss?: string(name='SqlFileOnOss'),
    sqlFilePath?: string(name='SqlFilePath'),
    taskId?: string(name='TaskId'),
    userId?: string(name='UserId'),
    workDir?: string(name='WorkDir'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudbenchTaskConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudbenchTaskConfigResponseBody(name='body'),
}

async function describeCloudbenchTaskConfigWithOptions(request: DescribeCloudbenchTaskConfigRequest, runtime: Util.RuntimeOptions): DescribeCloudbenchTaskConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudbenchTaskConfig',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudbenchTaskConfig(request: DescribeCloudbenchTaskConfigRequest): DescribeCloudbenchTaskConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudbenchTaskConfigWithOptions(request, runtime);
}

model DescribeDiagnosticReportListRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model DescribeDiagnosticReportListResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model DescribeDiagnosticReportListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticReportListResponseBody(name='body'),
}

async function describeDiagnosticReportListWithOptions(request: DescribeDiagnosticReportListRequest, runtime: Util.RuntimeOptions): DescribeDiagnosticReportListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnosticReportList',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiagnosticReportListWithOptions(request, runtime);
}

model DescribeHotBigKeysRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
}

model DescribeHotBigKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeyMsg?: string(name='BigKeyMsg'),
    bigKeys?: {
      bigKey?: [ 
      {
        db?: int32(name='Db'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        nodeId?: string(name='NodeId'),
        size?: long(name='Size'),
      }
    ](name='BigKey')
    }(name='BigKeys'),
    hotKeyMsg?: string(name='HotKeyMsg'),
    hotKeys?: {
      hotKey?: [ 
      {
        db?: int32(name='Db'),
        hot?: string(name='Hot'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        lfu?: int32(name='Lfu'),
        nodeId?: string(name='NodeId'),
      }
    ](name='HotKey')
    }(name='HotKeys'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHotBigKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHotBigKeysResponseBody(name='body'),
}

async function describeHotBigKeysWithOptions(request: DescribeHotBigKeysRequest, runtime: Util.RuntimeOptions): DescribeHotBigKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHotBigKeys',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHotBigKeys(request: DescribeHotBigKeysRequest): DescribeHotBigKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHotBigKeysWithOptions(request, runtime);
}

model DescribeHotKeysRequest {
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
}

model DescribeHotKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    hotKey?: [ 
    {
      db?: int32(name='Db'),
      hot?: string(name='Hot'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      size?: long(name='Size'),
    }
  ](name='HotKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHotKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHotKeysResponseBody(name='body'),
}

async function describeHotKeysWithOptions(request: DescribeHotKeysRequest, runtime: Util.RuntimeOptions): DescribeHotKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHotKeys',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHotKeys(request: DescribeHotKeysRequest): DescribeHotKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHotKeysWithOptions(request, runtime);
}

model DescribeTopBigKeysRequest {
  consoleContext?: string(name='ConsoleContext'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
  startTime?: string(name='StartTime'),
}

model DescribeTopBigKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKey?: [ 
    {
      db?: int32(name='Db'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      nodeId?: string(name='NodeId'),
      size?: long(name='Size'),
    }
  ](name='BigKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeTopBigKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTopBigKeysResponseBody(name='body'),
}

async function describeTopBigKeysWithOptions(request: DescribeTopBigKeysRequest, runtime: Util.RuntimeOptions): DescribeTopBigKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTopBigKeys',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTopBigKeys(request: DescribeTopBigKeysRequest): DescribeTopBigKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTopBigKeysWithOptions(request, runtime);
}

model DescribeTopHotKeysRequest {
  consoleContext?: string(name='ConsoleContext'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
  startTime?: string(name='StartTime'),
}

model DescribeTopHotKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    hotKey?: [ 
    {
      db?: int32(name='Db'),
      hot?: string(name='Hot'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      lfu?: int32(name='Lfu'),
      nodeId?: string(name='NodeId'),
    }
  ](name='HotKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeTopHotKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTopHotKeysResponseBody(name='body'),
}

async function describeTopHotKeysWithOptions(request: DescribeTopHotKeysRequest, runtime: Util.RuntimeOptions): DescribeTopHotKeysResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTopHotKeys',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTopHotKeys(request: DescribeTopHotKeysRequest): DescribeTopHotKeysResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTopHotKeysWithOptions(request, runtime);
}

model DisableAllSqlConcurrencyControlRulesRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
}

model DisableAllSqlConcurrencyControlRulesResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DisableAllSqlConcurrencyControlRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DisableAllSqlConcurrencyControlRulesResponseBody(name='body'),
}

async function disableAllSqlConcurrencyControlRulesWithOptions(request: DisableAllSqlConcurrencyControlRulesRequest, runtime: Util.RuntimeOptions): DisableAllSqlConcurrencyControlRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableAllSqlConcurrencyControlRules',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableAllSqlConcurrencyControlRules(request: DisableAllSqlConcurrencyControlRulesRequest): DisableAllSqlConcurrencyControlRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableAllSqlConcurrencyControlRulesWithOptions(request, runtime);
}

model DisableSqlConcurrencyControlRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  itemId?: long(name='ItemId'),
}

model DisableSqlConcurrencyControlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DisableSqlConcurrencyControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSqlConcurrencyControlResponseBody(name='body'),
}

async function disableSqlConcurrencyControlWithOptions(request: DisableSqlConcurrencyControlRequest, runtime: Util.RuntimeOptions): DisableSqlConcurrencyControlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.itemId)) {
    query['ItemId'] = request.itemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableSqlConcurrencyControl',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableSqlConcurrencyControl(request: DisableSqlConcurrencyControlRequest): DisableSqlConcurrencyControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableSqlConcurrencyControlWithOptions(request, runtime);
}

model EnableSqlConcurrencyControlRequest {
  concurrencyControlTime?: long(name='ConcurrencyControlTime'),
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  maxConcurrency?: long(name='MaxConcurrency'),
  sqlKeywords?: string(name='SqlKeywords'),
  sqlType?: string(name='SqlType'),
}

model EnableSqlConcurrencyControlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model EnableSqlConcurrencyControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSqlConcurrencyControlResponseBody(name='body'),
}

async function enableSqlConcurrencyControlWithOptions(request: EnableSqlConcurrencyControlRequest, runtime: Util.RuntimeOptions): EnableSqlConcurrencyControlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.concurrencyControlTime)) {
    query['ConcurrencyControlTime'] = request.concurrencyControlTime;
  }
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    query['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.sqlKeywords)) {
    query['SqlKeywords'] = request.sqlKeywords;
  }
  if (!Util.isUnset(request.sqlType)) {
    query['SqlType'] = request.sqlType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableSqlConcurrencyControl',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableSqlConcurrencyControl(request: EnableSqlConcurrencyControlRequest): EnableSqlConcurrencyControlResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableSqlConcurrencyControlWithOptions(request, runtime);
}

model GetAutoResourceOptimizeConfigRequest {
  accessKey?: string(name='AccessKey'),
  instanceId?: string(name='InstanceId'),
  signature?: string(name='Signature'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
}

model GetAutoResourceOptimizeConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetAutoResourceOptimizeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoResourceOptimizeConfigResponseBody(name='body'),
}

async function getAutoResourceOptimizeConfigWithOptions(request: GetAutoResourceOptimizeConfigRequest, runtime: Util.RuntimeOptions): GetAutoResourceOptimizeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutoResourceOptimizeConfig',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAutoResourceOptimizeConfig(request: GetAutoResourceOptimizeConfigRequest): GetAutoResourceOptimizeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutoResourceOptimizeConfigWithOptions(request, runtime);
}

model GetAutonomousNotifyEventContentRequest {
  instanceId?: string(name='InstanceId'),
  spanId?: string(name='SpanId'),
  context?: string(name='__context'),
}

model GetAutonomousNotifyEventContentResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAutonomousNotifyEventContentResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutonomousNotifyEventContentResponseBody(name='body'),
}

async function getAutonomousNotifyEventContentWithOptions(request: GetAutonomousNotifyEventContentRequest, runtime: Util.RuntimeOptions): GetAutonomousNotifyEventContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.spanId)) {
    query['SpanId'] = request.spanId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutonomousNotifyEventContent',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAutonomousNotifyEventContent(request: GetAutonomousNotifyEventContentRequest): GetAutonomousNotifyEventContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutonomousNotifyEventContentWithOptions(request, runtime);
}

model GetAutonomousNotifyEventsInRangeRequest {
  endTime?: string(name='EndTime'),
  eventContext?: string(name='EventContext'),
  instanceId?: string(name='InstanceId'),
  level?: string(name='Level'),
  minLevel?: string(name='MinLevel'),
  nodeId?: string(name='NodeId'),
  pageOffset?: string(name='PageOffset'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  context?: string(name='__context'),
}

model GetAutonomousNotifyEventsInRangeResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      t?: [ string ](name='T')
    }(name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAutonomousNotifyEventsInRangeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutonomousNotifyEventsInRangeResponseBody(name='body'),
}

async function getAutonomousNotifyEventsInRangeWithOptions(request: GetAutonomousNotifyEventsInRangeRequest, runtime: Util.RuntimeOptions): GetAutonomousNotifyEventsInRangeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventContext)) {
    query['EventContext'] = request.eventContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.level)) {
    query['Level'] = request.level;
  }
  if (!Util.isUnset(request.minLevel)) {
    query['MinLevel'] = request.minLevel;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.pageOffset)) {
    query['PageOffset'] = request.pageOffset;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAutonomousNotifyEventsInRange',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAutonomousNotifyEventsInRange(request: GetAutonomousNotifyEventsInRangeRequest): GetAutonomousNotifyEventsInRangeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAutonomousNotifyEventsInRangeWithOptions(request, runtime);
}

model GetEndpointSwitchTaskRequest {
  taskId?: string(name='TaskId'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  skipAuth?: string(name='skipAuth'),
  timestamp?: string(name='timestamp'),
}

model GetEndpointSwitchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    dbLinkId?: long(name='DbLinkId'),
    errMsg?: string(name='ErrMsg'),
    oriUuid?: string(name='OriUuid'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    uuid?: string(name='Uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetEndpointSwitchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetEndpointSwitchTaskResponseBody(name='body'),
}

async function getEndpointSwitchTaskWithOptions(request: GetEndpointSwitchTaskRequest, runtime: Util.RuntimeOptions): GetEndpointSwitchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  if (!Util.isUnset(request.accessKey)) {
    query['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.signature)) {
    query['signature'] = request.signature;
  }
  if (!Util.isUnset(request.skipAuth)) {
    query['skipAuth'] = request.skipAuth;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['timestamp'] = request.timestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEndpointSwitchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEndpointSwitchTask(request: GetEndpointSwitchTaskRequest): GetEndpointSwitchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEndpointSwitchTaskWithOptions(request, runtime);
}

model GetHDMAliyunResourceSyncResultRequest {
  taskId?: string(name='TaskId'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  skipAuth?: string(name='skipAuth'),
  timestamp?: string(name='timestamp'),
}

model GetHDMAliyunResourceSyncResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorMsg?: string(name='ErrorMsg'),
    results?: string(name='Results'),
    subResults?: {
      resourceSyncSubResult?: [ 
      {
        errMsg?: string(name='ErrMsg'),
        resourceType?: string(name='ResourceType'),
        success?: boolean(name='Success'),
        syncCount?: int32(name='SyncCount'),
      }
    ](name='ResourceSyncSubResult')
    }(name='SubResults'),
    syncStatus?: string(name='SyncStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetHDMAliyunResourceSyncResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetHDMAliyunResourceSyncResultResponseBody(name='body'),
}

async function getHDMAliyunResourceSyncResultWithOptions(request: GetHDMAliyunResourceSyncResultRequest, runtime: Util.RuntimeOptions): GetHDMAliyunResourceSyncResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  if (!Util.isUnset(request.accessKey)) {
    query['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.signature)) {
    query['signature'] = request.signature;
  }
  if (!Util.isUnset(request.skipAuth)) {
    query['skipAuth'] = request.skipAuth;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['timestamp'] = request.timestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHDMAliyunResourceSyncResult',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHDMAliyunResourceSyncResult(request: GetHDMAliyunResourceSyncResultRequest): GetHDMAliyunResourceSyncResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHDMAliyunResourceSyncResultWithOptions(request, runtime);
}

model GetHDMLastAliyunResourceSyncResultRequest {
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  skipAuth?: string(name='skipAuth'),
  timestamp?: string(name='timestamp'),
}

model GetHDMLastAliyunResourceSyncResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorMsg?: string(name='ErrorMsg'),
    results?: string(name='Results'),
    subResults?: {
      resourceSyncSubResult?: [ 
      {
        errMsg?: string(name='ErrMsg'),
        resourceType?: string(name='ResourceType'),
        success?: boolean(name='Success'),
        syncCount?: int32(name='SyncCount'),
      }
    ](name='ResourceSyncSubResult')
    }(name='SubResults'),
    syncStatus?: string(name='SyncStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetHDMLastAliyunResourceSyncResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetHDMLastAliyunResourceSyncResultResponseBody(name='body'),
}

async function getHDMLastAliyunResourceSyncResultWithOptions(request: GetHDMLastAliyunResourceSyncResultRequest, runtime: Util.RuntimeOptions): GetHDMLastAliyunResourceSyncResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  if (!Util.isUnset(request.accessKey)) {
    query['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.signature)) {
    query['signature'] = request.signature;
  }
  if (!Util.isUnset(request.skipAuth)) {
    query['skipAuth'] = request.skipAuth;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['timestamp'] = request.timestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHDMLastAliyunResourceSyncResult',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHDMLastAliyunResourceSyncResult(request: GetHDMLastAliyunResourceSyncResultRequest): GetHDMLastAliyunResourceSyncResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHDMLastAliyunResourceSyncResultWithOptions(request, runtime);
}

model GetInstanceInspectionsRequest {
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  instanceArea?: string(name='InstanceArea'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  searchMap?: string(name='SearchMap'),
  startTime?: string(name='StartTime'),
}

model GetInstanceInspectionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      baseInspection?: [ 
      {
        data?: string(name='Data'),
        endTime?: long(name='EndTime'),
        gmtCreate?: long(name='GmtCreate'),
        instance?: {
          accountId?: string(name='AccountId'),
          engine?: string(name='Engine'),
          engineVersion?: string(name='EngineVersion'),
          instanceArea?: string(name='InstanceArea'),
          instanceClass?: string(name='InstanceClass'),
          instanceId?: string(name='InstanceId'),
          networkType?: string(name='NetworkType'),
          nodeId?: string(name='NodeId'),
          region?: string(name='Region'),
          uuid?: string(name='Uuid'),
          vpcId?: string(name='VpcId'),
        }(name='Instance'),
        score?: int32(name='Score'),
        scoreMap?: string(name='ScoreMap'),
        startTime?: long(name='StartTime'),
      }
    ](name='BaseInspection')
    }(name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetInstanceInspectionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceInspectionsResponseBody(name='body'),
}

async function getInstanceInspectionsWithOptions(request: GetInstanceInspectionsRequest, runtime: Util.RuntimeOptions): GetInstanceInspectionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.instanceArea)) {
    query['InstanceArea'] = request.instanceArea;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchMap)) {
    query['SearchMap'] = request.searchMap;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInstanceInspections',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInstanceInspections(request: GetInstanceInspectionsRequest): GetInstanceInspectionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceInspectionsWithOptions(request, runtime);
}

model GetRequestDiagnosisPageRequest {
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  nodeId?: string(name='NodeId'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model GetRequestDiagnosisPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='extra'),
    list?: [ 
      {
        accountId?: string(name='accountId'),
        dbSchema?: string(name='dbSchema'),
        engine?: string(name='engine'),
        gmtCreate?: string(name='gmtCreate'),
        gmtModified?: string(name='gmtModified'),
        messageId?: string(name='messageId'),
        param?: string(name='param'),
        result?: string(name='result'),
        sqlId?: string(name='sqlId'),
        state?: int32(name='state'),
        uuid?: string(name='uuid'),
      }
    ](name='list'),
    pageNo?: long(name='pageNo'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRequestDiagnosisPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetRequestDiagnosisPageResponseBody(name='body'),
}

async function getRequestDiagnosisPageWithOptions(request: GetRequestDiagnosisPageRequest, runtime: Util.RuntimeOptions): GetRequestDiagnosisPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRequestDiagnosisPage',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRequestDiagnosisPage(request: GetRequestDiagnosisPageRequest): GetRequestDiagnosisPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRequestDiagnosisPageWithOptions(request, runtime);
}

model GetRequestDiagnosisResultRequest {
  instanceId?: string(name='InstanceId'),
  messageId?: string(name='MessageId'),
  nodeId?: string(name='NodeId'),
}

model GetRequestDiagnosisResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='accountId'),
    dbSchema?: string(name='dbSchema'),
    engine?: string(name='engine'),
    gmtCreate?: string(name='gmtCreate'),
    gmtModified?: string(name='gmtModified'),
    messageId?: string(name='messageId'),
    param?: string(name='param'),
    result?: string(name='result'),
    sqlId?: string(name='sqlId'),
    state?: int32(name='state'),
    uuid?: string(name='uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRequestDiagnosisResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetRequestDiagnosisResultResponseBody(name='body'),
}

async function getRequestDiagnosisResultWithOptions(request: GetRequestDiagnosisResultRequest, runtime: Util.RuntimeOptions): GetRequestDiagnosisResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.messageId)) {
    query['MessageId'] = request.messageId;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRequestDiagnosisResult',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRequestDiagnosisResult(request: GetRequestDiagnosisResultRequest): GetRequestDiagnosisResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRequestDiagnosisResultWithOptions(request, runtime);
}

model GetResourceOptimizeHistoryListRequest {
  accessKey?: string(name='AccessKey'),
  endTime?: string(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  page?: int32(name='Page'),
  pageSize?: int32(name='PageSize'),
  signature?: string(name='Signature'),
  startTime?: string(name='StartTime'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
}

model GetResourceOptimizeHistoryListResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetResourceOptimizeHistoryListResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceOptimizeHistoryListResponseBody(name='body'),
}

async function getResourceOptimizeHistoryListWithOptions(request: GetResourceOptimizeHistoryListRequest, runtime: Util.RuntimeOptions): GetResourceOptimizeHistoryListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.page)) {
    query['Page'] = request.page;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResourceOptimizeHistoryList',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResourceOptimizeHistoryList(request: GetResourceOptimizeHistoryListRequest): GetResourceOptimizeHistoryListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceOptimizeHistoryListWithOptions(request, runtime);
}

model GetRunningSqlConcurrencyControlRulesRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
}

model GetRunningSqlConcurrencyControlRulesResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      runningRules?: [ 
      {
        concurrencyControlTime?: long(name='ConcurrencyControlTime'),
        instanceId?: string(name='InstanceId'),
        itemId?: long(name='ItemId'),
        keywordsHash?: string(name='KeywordsHash'),
        maxConcurrency?: string(name='MaxConcurrency'),
        sqlKeywords?: string(name='SqlKeywords'),
        sqlType?: string(name='SqlType'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='runningRules')
    }(name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRunningSqlConcurrencyControlRulesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRunningSqlConcurrencyControlRulesResponseBody(name='body'),
}

async function getRunningSqlConcurrencyControlRulesWithOptions(request: GetRunningSqlConcurrencyControlRulesRequest, runtime: Util.RuntimeOptions): GetRunningSqlConcurrencyControlRulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRunningSqlConcurrencyControlRules',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRunningSqlConcurrencyControlRules(request: GetRunningSqlConcurrencyControlRulesRequest): GetRunningSqlConcurrencyControlRulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRunningSqlConcurrencyControlRulesWithOptions(request, runtime);
}

model GetSqlConcurrencyControlKeywordsFromSqlTextRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  sqlText?: string(name='SqlText'),
}

model GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlConcurrencyControlKeywordsFromSqlTextResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody(name='body'),
}

async function getSqlConcurrencyControlKeywordsFromSqlTextWithOptions(request: GetSqlConcurrencyControlKeywordsFromSqlTextRequest, runtime: Util.RuntimeOptions): GetSqlConcurrencyControlKeywordsFromSqlTextResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sqlText)) {
    query['SqlText'] = request.sqlText;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSqlConcurrencyControlKeywordsFromSqlText',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSqlConcurrencyControlKeywordsFromSqlText(request: GetSqlConcurrencyControlKeywordsFromSqlTextRequest): GetSqlConcurrencyControlKeywordsFromSqlTextResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSqlConcurrencyControlKeywordsFromSqlTextWithOptions(request, runtime);
}

model GetSqlConcurrencyControlRulesHistoryRequest {
  consoleContext?: string(name='ConsoleContext'),
  instanceId?: string(name='InstanceId'),
  pageNo?: long(name='PageNo'),
  pageSize?: long(name='PageSize'),
}

model GetSqlConcurrencyControlRulesHistoryResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      rules?: [ 
      {
        concurrencyControlTime?: long(name='ConcurrencyControlTime'),
        instanceId?: string(name='InstanceId'),
        itemId?: long(name='ItemId'),
        keywordsHash?: string(name='KeywordsHash'),
        maxConcurrency?: long(name='MaxConcurrency'),
        sqlKeywords?: string(name='SqlKeywords'),
        sqlType?: string(name='SqlType'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='rules')
    }(name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlConcurrencyControlRulesHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlConcurrencyControlRulesHistoryResponseBody(name='body'),
}

async function getSqlConcurrencyControlRulesHistoryWithOptions(request: GetSqlConcurrencyControlRulesHistoryRequest, runtime: Util.RuntimeOptions): GetSqlConcurrencyControlRulesHistoryResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNo)) {
    query['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSqlConcurrencyControlRulesHistory',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSqlConcurrencyControlRulesHistory(request: GetSqlConcurrencyControlRulesHistoryRequest): GetSqlConcurrencyControlRulesHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSqlConcurrencyControlRulesHistoryWithOptions(request, runtime);
}

model GetSqlOptimizeAdviceRequest {
  consoleContext?: string(name='ConsoleContext'),
  endDt?: string(name='EndDt'),
  engine?: string(name='Engine'),
  instanceIds?: string(name='InstanceIds'),
  startDt?: string(name='StartDt'),
}

model GetSqlOptimizeAdviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTime?: string(name='CreateTime'),
    downloadUrl?: string(name='DownloadUrl'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
    statusCode?: string(name='StatusCode'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlOptimizeAdviceResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlOptimizeAdviceResponseBody(name='body'),
}

async function getSqlOptimizeAdviceWithOptions(request: GetSqlOptimizeAdviceRequest, runtime: Util.RuntimeOptions): GetSqlOptimizeAdviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.consoleContext)) {
    query['ConsoleContext'] = request.consoleContext;
  }
  if (!Util.isUnset(request.endDt)) {
    query['EndDt'] = request.endDt;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  if (!Util.isUnset(request.startDt)) {
    query['StartDt'] = request.startDt;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSqlOptimizeAdvice',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSqlOptimizeAdvice(request: GetSqlOptimizeAdviceRequest): GetSqlOptimizeAdviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSqlOptimizeAdviceWithOptions(request, runtime);
}

model RunCloudBenchTaskRequest {
  taskId?: string(name='TaskId'),
}

model RunCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    preCheckItem?: [ 
    {
      code?: int32(name='Code'),
      details?: string(name='Details'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      order?: int32(name='Order'),
      status?: string(name='Status'),
    }
  ](name='PreCheckItem')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model RunCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: RunCloudBenchTaskResponseBody(name='body'),
}

async function runCloudBenchTaskWithOptions(request: RunCloudBenchTaskRequest, runtime: Util.RuntimeOptions): RunCloudBenchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunCloudBenchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runCloudBenchTask(request: RunCloudBenchTaskRequest): RunCloudBenchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return runCloudBenchTaskWithOptions(request, runtime);
}

model StopCloudBenchTaskRequest {
  taskId?: string(name='TaskId'),
}

model StopCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model StopCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopCloudBenchTaskResponseBody(name='body'),
}

async function stopCloudBenchTaskWithOptions(request: StopCloudBenchTaskRequest, runtime: Util.RuntimeOptions): StopCloudBenchTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopCloudBenchTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopCloudBenchTask(request: StopCloudBenchTaskRequest): StopCloudBenchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopCloudBenchTaskWithOptions(request, runtime);
}

model StopOrRollbackOptimizeTaskRequest {
  accessKey?: string(name='AccessKey'),
  instanceId?: string(name='InstanceId'),
  signature?: string(name='Signature'),
  stopOrRollback?: string(name='StopOrRollback'),
  taskType?: string(name='TaskType'),
  taskUuid?: string(name='TaskUuid'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
}

model StopOrRollbackOptimizeTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model StopOrRollbackOptimizeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopOrRollbackOptimizeTaskResponseBody(name='body'),
}

async function stopOrRollbackOptimizeTaskWithOptions(request: StopOrRollbackOptimizeTaskRequest, runtime: Util.RuntimeOptions): StopOrRollbackOptimizeTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }
  if (!Util.isUnset(request.stopOrRollback)) {
    query['StopOrRollback'] = request.stopOrRollback;
  }
  if (!Util.isUnset(request.taskType)) {
    query['TaskType'] = request.taskType;
  }
  if (!Util.isUnset(request.taskUuid)) {
    query['TaskUuid'] = request.taskUuid;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopOrRollbackOptimizeTask',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopOrRollbackOptimizeTask(request: StopOrRollbackOptimizeTaskRequest): StopOrRollbackOptimizeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopOrRollbackOptimizeTaskWithOptions(request, runtime);
}

model SyncHDMAliyunResourceRequest {
  async?: string(name='Async'),
  resourceTypes?: string(name='ResourceTypes'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  waitForModifySecurityIps?: string(name='WaitForModifySecurityIps'),
  context?: string(name='__context'),
  accessKey?: string(name='accessKey'),
  signature?: string(name='signature'),
  skipAuth?: string(name='skipAuth'),
  timestamp?: string(name='timestamp'),
}

model SyncHDMAliyunResourceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model SyncHDMAliyunResourceResponse = {
  headers: map[string]string(name='headers'),
  body: SyncHDMAliyunResourceResponseBody(name='body'),
}

async function syncHDMAliyunResourceWithOptions(request: SyncHDMAliyunResourceRequest, runtime: Util.RuntimeOptions): SyncHDMAliyunResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.async)) {
    query['Async'] = request.async;
  }
  if (!Util.isUnset(request.resourceTypes)) {
    query['ResourceTypes'] = request.resourceTypes;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.waitForModifySecurityIps)) {
    query['WaitForModifySecurityIps'] = request.waitForModifySecurityIps;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  if (!Util.isUnset(request.accessKey)) {
    query['accessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.signature)) {
    query['signature'] = request.signature;
  }
  if (!Util.isUnset(request.skipAuth)) {
    query['skipAuth'] = request.skipAuth;
  }
  if (!Util.isUnset(request.timestamp)) {
    query['timestamp'] = request.timestamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SyncHDMAliyunResource',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncHDMAliyunResource(request: SyncHDMAliyunResourceRequest): SyncHDMAliyunResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncHDMAliyunResourceWithOptions(request, runtime);
}

model TurnOffAutoResourceOptimizeRequest {
  accessKey?: string(name='AccessKey'),
  instanceId?: string(name='InstanceId'),
  signature?: string(name='Signature'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
}

model TurnOffAutoResourceOptimizeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model TurnOffAutoResourceOptimizeResponse = {
  headers: map[string]string(name='headers'),
  body: TurnOffAutoResourceOptimizeResponseBody(name='body'),
}

async function turnOffAutoResourceOptimizeWithOptions(request: TurnOffAutoResourceOptimizeRequest, runtime: Util.RuntimeOptions): TurnOffAutoResourceOptimizeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TurnOffAutoResourceOptimize',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function turnOffAutoResourceOptimize(request: TurnOffAutoResourceOptimizeRequest): TurnOffAutoResourceOptimizeResponse {
  var runtime = new Util.RuntimeOptions{};
  return turnOffAutoResourceOptimizeWithOptions(request, runtime);
}

model UpdateAutoResourceOptimizeConfigRequest {
  accessKey?: string(name='AccessKey'),
  autoDefragment?: int32(name='AutoDefragment'),
  autoDuplicateIndexDelete?: int32(name='AutoDuplicateIndexDelete'),
  instanceId?: string(name='InstanceId'),
  signature?: string(name='Signature'),
  tableFragmentationRatio?: float(name='TableFragmentationRatio'),
  tableSpaceSize?: float(name='TableSpaceSize'),
  uid?: string(name='Uid'),
  userId?: string(name='UserId'),
  context?: string(name='__context'),
}

model UpdateAutoResourceOptimizeConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model UpdateAutoResourceOptimizeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAutoResourceOptimizeConfigResponseBody(name='body'),
}

async function updateAutoResourceOptimizeConfigWithOptions(request: UpdateAutoResourceOptimizeConfigRequest, runtime: Util.RuntimeOptions): UpdateAutoResourceOptimizeConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accessKey)) {
    query['AccessKey'] = request.accessKey;
  }
  if (!Util.isUnset(request.autoDefragment)) {
    query['AutoDefragment'] = request.autoDefragment;
  }
  if (!Util.isUnset(request.autoDuplicateIndexDelete)) {
    query['AutoDuplicateIndexDelete'] = request.autoDuplicateIndexDelete;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.signature)) {
    query['Signature'] = request.signature;
  }
  if (!Util.isUnset(request.tableFragmentationRatio)) {
    query['TableFragmentationRatio'] = request.tableFragmentationRatio;
  }
  if (!Util.isUnset(request.tableSpaceSize)) {
    query['TableSpaceSize'] = request.tableSpaceSize;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.context)) {
    query['__context'] = request.context;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAutoResourceOptimizeConfig',
    version = '2020-01-16',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAutoResourceOptimizeConfig(request: UpdateAutoResourceOptimizeConfigRequest): UpdateAutoResourceOptimizeConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAutoResourceOptimizeConfigWithOptions(request, runtime);
}

