/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'DAS';
  @version = '2020-01-16';
  @endpointRule = 'central';
  @endpointMap = {
    cn-shanghai = 'das.cn-shanghai.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AddHDMInstanceRequest {
  engine?: string(name='Engine', position='Query'),
  flushAccount?: string(name='FlushAccount', position='Query'),
  instanceAlias?: string(name='InstanceAlias', position='Query'),
  instanceArea?: string(name='InstanceArea', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  ip?: string(name='Ip', position='Query'),
  networkType?: string(name='NetworkType', position='Query'),
  password?: string(name='Password', position='Query'),
  port?: string(name='Port', position='Query'),
  region?: string(name='Region', position='Query'),
  username?: string(name='Username', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model AddHDMInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    callerUid?: string(name='CallerUid'),
    code?: int32(name='Code'),
    error?: string(name='Error'),
    instanceId?: string(name='InstanceId'),
    ip?: string(name='Ip'),
    ownerId?: string(name='OwnerId'),
    port?: int32(name='Port'),
    role?: string(name='Role'),
    tenantId?: string(name='TenantId'),
    token?: string(name='Token'),
    uuid?: string(name='Uuid'),
    vpcId?: string(name='VpcId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model AddHDMInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: AddHDMInstanceResponseBody(name='body'),
}

async function addHDMInstance(request: AddHDMInstanceRequest): AddHDMInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddHDMInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateAdamBenchTaskRequest {
  description: string(name='Description', position='Query'),
  dstInstanceId: string(name='DstInstanceId', position='Query'),
  dstSuperAccount: string(name='DstSuperAccount', position='Query'),
  dstSuperPassword: string(name='DstSuperPassword', position='Query'),
  rate?: int32(name='Rate', position='Query'),
  requestDuration: long(name='RequestDuration', position='Query'),
  requestStartTime: long(name='RequestStartTime', position='Query'),
  srcEngine?: string(name='SrcEngine', position='Query'),
  srcEngineVersion?: string(name='SrcEngineVersion', position='Query'),
  srcMaxQps: double(name='SrcMaxQps', position='Query'),
  srcMeanQps: double(name='SrcMeanQps', position='Query'),
  srcSqlOssAddr: string(name='SrcSqlOssAddr', position='Query'),
}

model CreateAdamBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateAdamBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAdamBenchTaskResponseBody(name='body'),
}

async function createAdamBenchTask(request: CreateAdamBenchTaskRequest): CreateAdamBenchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAdamBenchTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateCacheAnalysisJobRequest {
  backupSetId?: string(name='BackupSetId', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
}

model CreateCacheAnalysisJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeys?: {
      keyInfo?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        db?: int32(name='Db'),
        encoding?: string(name='Encoding'),
        expirationTimeMillis?: long(name='ExpirationTimeMillis'),
        key?: string(name='Key'),
        nodeId?: string(name='NodeId'),
        type?: string(name='Type'),
      }
    ](name='KeyInfo')
    }(name='BigKeys'),
    instanceId?: string(name='InstanceId'),
    jobId?: string(name='JobId'),
    message?: string(name='Message'),
    nodeId?: string(name='NodeId'),
    taskState?: string(name='TaskState'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateCacheAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCacheAnalysisJobResponseBody(name='body'),
}

async function createCacheAnalysisJob(request: CreateCacheAnalysisJobRequest): CreateCacheAnalysisJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCacheAnalysisJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudBenchTasksRequest {
  amount?: string(name='Amount', position='Query'),
  backupId?: string(name='BackupId', position='Query'),
  backupTime?: string(name='BackupTime', position='Query'),
  clientType: string(name='ClientType', position='Query'),
  description: string(name='Description', position='Query'),
  dstConnectionString?: string(name='DstConnectionString', position='Query'),
  dstInstanceId?: string(name='DstInstanceId', position='Query'),
  dstPort?: string(name='DstPort', position='Query'),
  dstSuperAccount?: string(name='DstSuperAccount', position='Query'),
  dstSuperPassword?: string(name='DstSuperPassword', position='Query'),
  dstType?: string(name='DstType', position='Query'),
  dtsJobClass?: string(name='DtsJobClass', position='Query'),
  dtsJobId?: string(name='DtsJobId', position='Query'),
  endState?: string(name='EndState', position='Query'),
  gatewayVpcId?: string(name='GatewayVpcId', position='Query'),
  gatewayVpcIp?: string(name='GatewayVpcIp', position='Query'),
  rate?: string(name='Rate', position='Query'),
  requestDuration?: string(name='RequestDuration', position='Query'),
  requestEndTime?: string(name='RequestEndTime', position='Query'),
  requestStartTime?: string(name='RequestStartTime', position='Query'),
  smartPressureTime?: string(name='SmartPressureTime', position='Query'),
  srcInstanceId: string(name='SrcInstanceId', position='Query'),
  srcPublicIp?: string(name='SrcPublicIp', position='Query'),
  srcSuperAccount?: string(name='SrcSuperAccount', position='Query'),
  srcSuperPassword?: string(name='SrcSuperPassword', position='Query'),
  taskType: string(name='TaskType', position='Query'),
  workDir?: string(name='WorkDir', position='Query'),
}

model CreateCloudBenchTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskIds?: [ string ](name='taskIds')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateCloudBenchTasksResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCloudBenchTasksResponseBody(name='body'),
}

async function createCloudBenchTasks(request: CreateCloudBenchTasksRequest): CreateCloudBenchTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudBenchTasks', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiagnosticReportRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model CreateDiagnosticReportResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiagnosticReport', 'POST', '/', 'json', false, 'json', request);
}

model CreateRequestDiagnosisRequest {
  database?: string(name='Database', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  sql?: string(name='Sql', position='Query'),
}

model CreateRequestDiagnosisResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model CreateRequestDiagnosisResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRequestDiagnosisResponseBody(name='body'),
}

async function createRequestDiagnosis(request: CreateRequestDiagnosisRequest): CreateRequestDiagnosisResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRequestDiagnosis', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCloudBenchTaskRequest {
  taskId: string(name='TaskId', position='Query'),
}

model DeleteCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteCloudBenchTaskResponseBody(name='body'),
}

async function deleteCloudBenchTask(request: DeleteCloudBenchTaskRequest): DeleteCloudBenchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCloudBenchTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCacheAnalysisJobRequest {
  instanceId: string(name='InstanceId', position='Query'),
  jobId: string(name='JobId', position='Query'),
}

model DescribeCacheAnalysisJobResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeys?: {
      keyInfo?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        db?: int32(name='Db'),
        encoding?: string(name='Encoding'),
        expirationTimeMillis?: long(name='ExpirationTimeMillis'),
        key?: string(name='Key'),
        nodeId?: string(name='NodeId'),
        type?: string(name='Type'),
      }
    ](name='KeyInfo')
    }(name='BigKeys'),
    instanceId?: string(name='InstanceId'),
    jobId?: string(name='JobId'),
    keyPrefixes?: {
      prefix?: [ 
      {
        bytes?: long(name='Bytes'),
        count?: long(name='Count'),
        keyNum?: long(name='KeyNum'),
        prefix?: string(name='Prefix'),
        type?: string(name='Type'),
      }
    ](name='Prefix')
    }(name='KeyPrefixes'),
    message?: string(name='Message'),
    nodeId?: string(name='NodeId'),
    taskState?: string(name='TaskState'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCacheAnalysisJobResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCacheAnalysisJobResponseBody(name='body'),
}

async function describeCacheAnalysisJob(request: DescribeCacheAnalysisJobRequest): DescribeCacheAnalysisJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCacheAnalysisJob', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCacheAnalysisJobsRequest {
  endTime?: string(name='EndTime', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeCacheAnalysisJobsResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      cacheAnalysisJob?: [ 
      {
        bigKeys?: {
          keyInfo?: [ 
          {
            bytes?: long(name='Bytes'),
            count?: long(name='Count'),
            db?: int32(name='Db'),
            encoding?: string(name='Encoding'),
            expirationTimeMillis?: long(name='ExpirationTimeMillis'),
            key?: string(name='Key'),
            nodeId?: string(name='NodeId'),
            type?: string(name='Type'),
          }
        ](name='KeyInfo')
        }(name='BigKeys'),
        instanceId?: string(name='InstanceId'),
        jobId?: string(name='JobId'),
        message?: string(name='Message'),
        nodeId?: string(name='NodeId'),
        taskState?: string(name='TaskState'),
      }
    ](name='CacheAnalysisJob')
    }(name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCacheAnalysisJobsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCacheAnalysisJobsResponseBody(name='body'),
}

async function describeCacheAnalysisJobs(request: DescribeCacheAnalysisJobsRequest): DescribeCacheAnalysisJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCacheAnalysisJobs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudBenchTasksRequest {
  endTime?: string(name='EndTime', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  taskType?: string(name='TaskType', position='Query'),
}

model DescribeCloudBenchTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      cloudbenchTasks?: [ 
      {
        archiveJobId?: string(name='ArchiveJobId'),
        archiveOssTableName?: string(name='ArchiveOssTableName'),
        archiveState?: int32(name='ArchiveState'),
        backupId?: string(name='BackupId'),
        backupType?: string(name='BackupType'),
        benchStep?: string(name='BenchStep'),
        benchStepStatus?: string(name='BenchStepStatus'),
        clientGatewayId?: string(name='ClientGatewayId'),
        clientType?: string(name='ClientType'),
        description?: string(name='Description'),
        dstInstanceUuid?: string(name='DstInstanceUuid'),
        dstIp?: string(name='DstIp'),
        dstPort?: int32(name='DstPort'),
        dstType?: string(name='DstType'),
        dtsJobClass?: string(name='DtsJobClass'),
        dtsJobId?: string(name='DtsJobId'),
        dtsJobName?: string(name='DtsJobName'),
        dtsJobState?: int32(name='DtsJobState'),
        dtsJobStatus?: string(name='DtsJobStatus'),
        ecsInstanceId?: string(name='EcsInstanceId'),
        endState?: string(name='EndState'),
        errorCode?: string(name='ErrorCode'),
        errorMessage?: string(name='ErrorMessage'),
        external?: string(name='External'),
        rate?: int32(name='Rate'),
        requestDuration?: long(name='RequestDuration'),
        smartPressureTime?: int32(name='SmartPressureTime'),
        source?: string(name='Source'),
        sqlCompleteReuse?: string(name='SqlCompleteReuse'),
        srcInstanceArea?: string(name='SrcInstanceArea'),
        srcInstanceUuid?: string(name='SrcInstanceUuid'),
        srcPublicIp?: string(name='SrcPublicIp'),
        state?: string(name='State'),
        status?: string(name='Status'),
        tableSchema?: string(name='TableSchema'),
        taskId?: string(name='TaskId'),
        taskType?: string(name='TaskType'),
        topic?: string(name='Topic'),
        userId?: string(name='UserId'),
        version?: string(name='Version'),
        workDir?: string(name='WorkDir'),
      }
    ](name='cloudbenchTasks')
    }(name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudBenchTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudBenchTasksResponseBody(name='body'),
}

async function describeCloudBenchTasks(request: DescribeCloudBenchTasksRequest): DescribeCloudBenchTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudBenchTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudbenchTaskRequest {
  taskId: string(name='TaskId', position='Query'),
}

model DescribeCloudbenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    archiveJobId?: string(name='ArchiveJobId'),
    archiveOssTableName?: string(name='ArchiveOssTableName'),
    archiveState?: int32(name='ArchiveState'),
    backupId?: string(name='BackupId'),
    backupType?: string(name='BackupType'),
    benchStep?: string(name='BenchStep'),
    benchStepStatus?: string(name='BenchStepStatus'),
    clientGatewayId?: string(name='ClientGatewayId'),
    clientType?: string(name='ClientType'),
    description?: string(name='Description'),
    dstInstanceUuid?: string(name='DstInstanceUuid'),
    dstIp?: string(name='DstIp'),
    dstPort?: int32(name='DstPort'),
    dstType?: string(name='DstType'),
    dtsJobClass?: string(name='DtsJobClass'),
    dtsJobId?: string(name='DtsJobId'),
    dtsJobName?: string(name='DtsJobName'),
    dtsJobState?: int32(name='DtsJobState'),
    dtsJobStatus?: string(name='DtsJobStatus'),
    ecsInstanceId?: string(name='EcsInstanceId'),
    endState?: string(name='EndState'),
    errorCode?: string(name='ErrorCode'),
    errorMessage?: string(name='ErrorMessage'),
    external?: string(name='External'),
    rate?: long(name='Rate'),
    requestDuration?: long(name='RequestDuration'),
    smartPressureTime?: int32(name='SmartPressureTime'),
    source?: string(name='Source'),
    sqlCompleteReuse?: string(name='SqlCompleteReuse'),
    srcInstanceArea?: string(name='SrcInstanceArea'),
    srcInstanceUuid?: string(name='SrcInstanceUuid'),
    srcPublicIp?: string(name='SrcPublicIp'),
    state?: string(name='State'),
    status?: string(name='Status'),
    tableSchema?: string(name='TableSchema'),
    taskId?: string(name='TaskId'),
    taskType?: string(name='TaskType'),
    topic?: string(name='Topic'),
    userId?: string(name='UserId'),
    version?: string(name='Version'),
    workDir?: string(name='WorkDir'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudbenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudbenchTaskResponseBody(name='body'),
}

async function describeCloudbenchTask(request: DescribeCloudbenchTaskRequest): DescribeCloudbenchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudbenchTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudbenchTaskConfigRequest {
  taskId: string(name='TaskId', position='Query'),
}

model DescribeCloudbenchTaskConfigResponseBody = {
  code?: string(name='Code'),
  data?: {
    archiveFolder?: string(name='ArchiveFolder'),
    benchCmd?: string(name='BenchCmd'),
    clientJarPath?: string(name='ClientJarPath'),
    jarOnOss?: string(name='JarOnOss'),
    loadCmd?: string(name='LoadCmd'),
    metaFileName?: string(name='MetaFileName'),
    metaFileOnOss?: string(name='MetaFileOnOss'),
    metaFilePath?: string(name='MetaFilePath'),
    parseCmd?: string(name='ParseCmd'),
    parseFilePath?: string(name='ParseFilePath'),
    rocksDbPath?: string(name='RocksDbPath'),
    sqlFileName?: string(name='SqlFileName'),
    sqlFileOnOss?: string(name='SqlFileOnOss'),
    sqlFilePath?: string(name='SqlFilePath'),
    taskId?: string(name='TaskId'),
    userId?: string(name='UserId'),
    workDir?: string(name='WorkDir'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeCloudbenchTaskConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudbenchTaskConfigResponseBody(name='body'),
}

async function describeCloudbenchTaskConfig(request: DescribeCloudbenchTaskConfigRequest): DescribeCloudbenchTaskConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudbenchTaskConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiagnosticReportListRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDiagnosticReportListResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model DescribeDiagnosticReportListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticReportListResponseBody(name='body'),
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiagnosticReportList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHotBigKeysRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
}

model DescribeHotBigKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKeyMsg?: string(name='BigKeyMsg'),
    bigKeys?: {
      bigKey?: [ 
      {
        db?: int32(name='Db'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        nodeId?: string(name='NodeId'),
        size?: long(name='Size'),
      }
    ](name='BigKey')
    }(name='BigKeys'),
    hotKeyMsg?: string(name='HotKeyMsg'),
    hotKeys?: {
      hotKey?: [ 
      {
        db?: int32(name='Db'),
        hot?: string(name='Hot'),
        key?: string(name='Key'),
        keyType?: string(name='KeyType'),
        lfu?: int32(name='Lfu'),
        nodeId?: string(name='NodeId'),
      }
    ](name='HotKey')
    }(name='HotKeys'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHotBigKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHotBigKeysResponseBody(name='body'),
}

async function describeHotBigKeys(request: DescribeHotBigKeysRequest): DescribeHotBigKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHotBigKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHotKeysRequest {
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
}

model DescribeHotKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    hotKey?: [ 
    {
      db?: int32(name='Db'),
      hot?: string(name='Hot'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      size?: long(name='Size'),
    }
  ](name='HotKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeHotKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHotKeysResponseBody(name='body'),
}

async function describeHotKeys(request: DescribeHotKeysRequest): DescribeHotKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHotKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceDasProRequest {
  instanceId: string(name='InstanceId', position='Query'),
}

model DescribeInstanceDasProResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeInstanceDasProResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceDasProResponseBody(name='body'),
}

async function describeInstanceDasPro(request: DescribeInstanceDasProRequest): DescribeInstanceDasProResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceDasPro', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTopBigKeysRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeTopBigKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    bigKey?: [ 
    {
      db?: int32(name='Db'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      nodeId?: string(name='NodeId'),
      size?: long(name='Size'),
    }
  ](name='BigKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeTopBigKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTopBigKeysResponseBody(name='body'),
}

async function describeTopBigKeys(request: DescribeTopBigKeysRequest): DescribeTopBigKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTopBigKeys', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTopHotKeysRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeTopHotKeysResponseBody = {
  code?: string(name='Code'),
  data?: {
    hotKey?: [ 
    {
      db?: int32(name='Db'),
      hot?: string(name='Hot'),
      key?: string(name='Key'),
      keyType?: string(name='KeyType'),
      lfu?: int32(name='Lfu'),
      nodeId?: string(name='NodeId'),
    }
  ](name='HotKey')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeTopHotKeysResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTopHotKeysResponseBody(name='body'),
}

async function describeTopHotKeys(request: DescribeTopHotKeysRequest): DescribeTopHotKeysResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTopHotKeys', 'POST', '/', 'json', false, 'json', request);
}

model DisableAllSqlConcurrencyControlRulesRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
}

model DisableAllSqlConcurrencyControlRulesResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DisableAllSqlConcurrencyControlRulesResponse = {
  headers: map[string]string(name='headers'),
  body: DisableAllSqlConcurrencyControlRulesResponseBody(name='body'),
}

async function disableAllSqlConcurrencyControlRules(request: DisableAllSqlConcurrencyControlRulesRequest): DisableAllSqlConcurrencyControlRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableAllSqlConcurrencyControlRules', 'POST', '/', 'json', false, 'json', request);
}

model DisableDasProRequest {
  instanceId: string(name='InstanceId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model DisableDasProResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model DisableDasProResponse = {
  headers: map[string]string(name='headers'),
  body: DisableDasProResponseBody(name='body'),
}

async function disableDasPro(request: DisableDasProRequest): DisableDasProResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableDasPro', 'POST', '/', 'json', false, 'json', request);
}

model DisableSqlConcurrencyControlRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  itemId: long(name='ItemId', position='Query'),
}

model DisableSqlConcurrencyControlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DisableSqlConcurrencyControlResponse = {
  headers: map[string]string(name='headers'),
  body: DisableSqlConcurrencyControlResponseBody(name='body'),
}

async function disableSqlConcurrencyControl(request: DisableSqlConcurrencyControlRequest): DisableSqlConcurrencyControlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableSqlConcurrencyControl', 'POST', '/', 'json', false, 'json', request);
}

model EnableDasProRequest {
  instanceId: string(name='InstanceId', position='Query'),
  sqlRetention?: int32(name='SqlRetention', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model EnableDasProResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model EnableDasProResponse = {
  headers: map[string]string(name='headers'),
  body: EnableDasProResponseBody(name='body'),
}

async function enableDasPro(request: EnableDasProRequest): EnableDasProResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableDasPro', 'POST', '/', 'json', false, 'json', request);
}

model EnableSqlConcurrencyControlRequest {
  concurrencyControlTime: long(name='ConcurrencyControlTime', position='Query'),
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  maxConcurrency: long(name='MaxConcurrency', position='Query'),
  sqlKeywords: string(name='SqlKeywords', position='Query'),
  sqlType: string(name='SqlType', position='Query'),
}

model EnableSqlConcurrencyControlResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model EnableSqlConcurrencyControlResponse = {
  headers: map[string]string(name='headers'),
  body: EnableSqlConcurrencyControlResponseBody(name='body'),
}

async function enableSqlConcurrencyControl(request: EnableSqlConcurrencyControlRequest): EnableSqlConcurrencyControlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableSqlConcurrencyControl', 'POST', '/', 'json', false, 'json', request);
}

model GetAsyncErrorRequestListByCodeRequest {
  end?: long(name='End', position='Query'),
  errorCode?: string(name='ErrorCode', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  start?: long(name='Start', position='Query'),
}

model GetAsyncErrorRequestListByCodeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAsyncErrorRequestListByCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncErrorRequestListByCodeResponseBody(name='body'),
}

async function getAsyncErrorRequestListByCode(request: GetAsyncErrorRequestListByCodeRequest): GetAsyncErrorRequestListByCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAsyncErrorRequestListByCode', 'POST', '/', 'json', false, 'json', request);
}

model GetAsyncErrorRequestStatByCodeRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  dbName?: string(name='DbName', position='Query'),
  end?: string(name='End', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  role?: string(name='Role', position='Query'),
  start?: string(name='Start', position='Query'),
}

model GetAsyncErrorRequestStatByCodeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAsyncErrorRequestStatByCodeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncErrorRequestStatByCodeResponseBody(name='body'),
}

async function getAsyncErrorRequestStatByCode(request: GetAsyncErrorRequestStatByCodeRequest): GetAsyncErrorRequestStatByCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAsyncErrorRequestStatByCode', 'POST', '/', 'json', false, 'json', request);
}

model GetAsyncErrorRequestStatResultRequest {
  dbName?: string(name='DbName', position='Query'),
  end?: long(name='End', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  sqlIdList?: string(name='SqlIdList', position='Query'),
  start?: long(name='Start', position='Query'),
}

model GetAsyncErrorRequestStatResultResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAsyncErrorRequestStatResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetAsyncErrorRequestStatResultResponseBody(name='body'),
}

async function getAsyncErrorRequestStatResult(request: GetAsyncErrorRequestStatResultRequest): GetAsyncErrorRequestStatResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAsyncErrorRequestStatResult', 'POST', '/', 'json', false, 'json', request);
}

model GetAutoResourceOptimizeConfigRequest {
  accessKey?: string(name='AccessKey', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  signature?: string(name='Signature', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model GetAutoResourceOptimizeConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetAutoResourceOptimizeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutoResourceOptimizeConfigResponseBody(name='body'),
}

async function getAutoResourceOptimizeConfig(request: GetAutoResourceOptimizeConfigRequest): GetAutoResourceOptimizeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAutoResourceOptimizeConfig', 'POST', '/', 'json', false, 'json', request);
}

model GetAutonomousNotifyEventContentRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  spanId?: string(name='SpanId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model GetAutonomousNotifyEventContentResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAutonomousNotifyEventContentResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutonomousNotifyEventContentResponseBody(name='body'),
}

async function getAutonomousNotifyEventContent(request: GetAutonomousNotifyEventContentRequest): GetAutonomousNotifyEventContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAutonomousNotifyEventContent', 'POST', '/', 'json', false, 'json', request);
}

model GetAutonomousNotifyEventsInRangeRequest {
  endTime?: string(name='EndTime', position='Query'),
  eventContext?: string(name='EventContext', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  level?: string(name='Level', position='Query'),
  minLevel?: string(name='MinLevel', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  pageOffset?: string(name='PageOffset', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  context?: string(name='__context', position='Query'),
}

model GetAutonomousNotifyEventsInRangeResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: {
      t?: [ string ](name='T')
    }(name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetAutonomousNotifyEventsInRangeResponse = {
  headers: map[string]string(name='headers'),
  body: GetAutonomousNotifyEventsInRangeResponseBody(name='body'),
}

async function getAutonomousNotifyEventsInRange(request: GetAutonomousNotifyEventsInRangeRequest): GetAutonomousNotifyEventsInRangeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAutonomousNotifyEventsInRange', 'POST', '/', 'json', false, 'json', request);
}

model GetDasProServiceUsageRequest {
  instanceId: string(name='InstanceId', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetDasProServiceUsageResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetDasProServiceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: GetDasProServiceUsageResponseBody(name='body'),
}

async function getDasProServiceUsage(request: GetDasProServiceUsageRequest): GetDasProServiceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDasProServiceUsage', 'POST', '/', 'json', false, 'json', request);
}

model GetEndpointSwitchTaskRequest {
  taskId?: string(name='TaskId', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
  accessKey?: string(name='accessKey', position='Query'),
  signature?: string(name='signature', position='Query'),
  skipAuth?: string(name='skipAuth', position='Query'),
  timestamp?: string(name='timestamp', position='Query'),
}

model GetEndpointSwitchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='AccountId'),
    dbLinkId?: long(name='DbLinkId'),
    errMsg?: string(name='ErrMsg'),
    oriUuid?: string(name='OriUuid'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    uuid?: string(name='Uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetEndpointSwitchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: GetEndpointSwitchTaskResponseBody(name='body'),
}

async function getEndpointSwitchTask(request: GetEndpointSwitchTaskRequest): GetEndpointSwitchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEndpointSwitchTask', 'POST', '/', 'json', false, 'json', request);
}

model GetErrorRequestSampleRequest {
  dbName?: string(name='DbName', position='Query'),
  end?: long(name='End', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  sqlId?: string(name='SqlId', position='Query'),
  start?: long(name='Start', position='Query'),
}

model GetErrorRequestSampleResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetErrorRequestSampleResponse = {
  headers: map[string]string(name='headers'),
  body: GetErrorRequestSampleResponseBody(name='body'),
}

async function getErrorRequestSample(request: GetErrorRequestSampleRequest): GetErrorRequestSampleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetErrorRequestSample', 'POST', '/', 'json', false, 'json', request);
}

model GetFullRequestOriginStatByInstanceIdRequest {
  asc?: boolean(name='Asc', position='Query'),
  end?: long(name='End', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  role?: string(name='Role', position='Query'),
  sqlType?: string(name='SqlType', position='Query'),
  start?: long(name='Start', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetFullRequestOriginStatByInstanceIdResponseBody = {
  code?: long(name='Code'),
  data?: {
    list?: [ 
      {
        avgExaminedRows?: double(name='AvgExaminedRows'),
        avgFetchRows?: long(name='AvgFetchRows'),
        avgLockWaitTime?: double(name='AvgLockWaitTime'),
        avgLogicalRead?: double(name='AvgLogicalRead'),
        avgPhysicalAsyncRead?: long(name='AvgPhysicalAsyncRead'),
        avgPhysicalSyncRead?: double(name='AvgPhysicalSyncRead'),
        avgReturnedRows?: double(name='AvgReturnedRows'),
        avgRows?: long(name='AvgRows'),
        avgRt?: double(name='AvgRt'),
        avgSqlCount?: long(name='AvgSqlCount'),
        avgUpdatedRows?: double(name='AvgUpdatedRows'),
        count?: long(name='Count'),
        countRate?: double(name='CountRate'),
        database?: string(name='Database'),
        errorCount?: long(name='ErrorCount'),
        examinedRows?: long(name='ExaminedRows'),
        fetchRows?: long(name='FetchRows'),
        ip?: string(name='Ip'),
        key?: string(name='Key'),
        lockWaitTime?: double(name='LockWaitTime'),
        logicalRead?: long(name='LogicalRead'),
        originHost?: string(name='OriginHost'),
        physicalAsyncRead?: long(name='PhysicalAsyncRead'),
        physicalSyncRead?: long(name='PhysicalSyncRead'),
        port?: long(name='Port'),
        rows?: long(name='Rows'),
        rtGreaterThanOneSecondCount?: long(name='RtGreaterThanOneSecondCount'),
        rtRate?: double(name='RtRate'),
        sqlCount?: long(name='SqlCount'),
        sumUpdatedRows?: long(name='SumUpdatedRows'),
        version?: long(name='Version'),
        vpcId?: string(name='VpcId'),
      }
    ](name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFullRequestOriginStatByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetFullRequestOriginStatByInstanceIdResponseBody(name='body'),
}

async function getFullRequestOriginStatByInstanceId(request: GetFullRequestOriginStatByInstanceIdRequest): GetFullRequestOriginStatByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFullRequestOriginStatByInstanceId', 'POST', '/', 'json', false, 'json', request);
}

model GetFullRequestStatResultByInstanceIdRequest {
  asc?: boolean(name='Asc', position='Query'),
  dbName?: string(name='DbName', position='Query'),
  end?: long(name='End', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  keyword?: string(name='Keyword', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  originHost?: string(name='OriginHost', position='Query'),
  pageNo?: int32(name='PageNo', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  role?: string(name='Role', position='Query'),
  sqlId?: string(name='SqlId', position='Query'),
  sqlType?: string(name='SqlType', position='Query'),
  start?: long(name='Start', position='Query'),
  userId?: string(name='UserId', position='Query'),
}

model GetFullRequestStatResultByInstanceIdResponseBody = {
  code?: long(name='Code'),
  data?: {
    fail?: boolean(name='Fail'),
    isFinish?: boolean(name='IsFinish'),
    result?: {
      list?: [ 
        {
          avgExaminedRows?: double(name='AvgExaminedRows'),
          avgFetchRows?: long(name='AvgFetchRows'),
          avgLockWaitTime?: double(name='AvgLockWaitTime'),
          avgLogicalRead?: double(name='AvgLogicalRead'),
          avgPhysicalAsyncRead?: long(name='AvgPhysicalAsyncRead'),
          avgPhysicalSyncRead?: long(name='AvgPhysicalSyncRead'),
          avgReturnedRows?: double(name='AvgReturnedRows'),
          avgRt?: double(name='AvgRt'),
          avgSqlCount?: long(name='AvgSqlCount'),
          avgUpdatedRows?: long(name='AvgUpdatedRows'),
          count?: long(name='Count'),
          countRate?: double(name='CountRate'),
          database?: string(name='Database'),
          errorCount?: long(name='ErrorCount'),
          examinedRows?: long(name='ExaminedRows'),
          fetchRows?: long(name='FetchRows'),
          ip?: string(name='Ip'),
          lockWaitTime?: double(name='LockWaitTime'),
          logicalRead?: long(name='LogicalRead'),
          physicalAsyncRead?: long(name='PhysicalAsyncRead'),
          physicalSyncRead?: long(name='PhysicalSyncRead'),
          port?: long(name='Port'),
          psql?: string(name='Psql'),
          rows?: long(name='Rows'),
          rtGreaterThanOneSecondCount?: long(name='RtGreaterThanOneSecondCount'),
          rtRate?: double(name='RtRate'),
          sqlCount?: long(name='SqlCount'),
          sqlId?: string(name='SqlId'),
          sumUpdatedRows?: long(name='SumUpdatedRows'),
          tables?: [ string ](name='Tables'),
          version?: long(name='Version'),
          vpcId?: string(name='VpcId'),
        }
      ](name='List'),
      total?: long(name='Total'),
    }(name='Result'),
    resultId?: string(name='ResultId'),
    state?: string(name='State'),
    timestamp?: long(name='Timestamp'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetFullRequestStatResultByInstanceIdResponse = {
  headers: map[string]string(name='headers'),
  body: GetFullRequestStatResultByInstanceIdResponseBody(name='body'),
}

async function getFullRequestStatResultByInstanceId(request: GetFullRequestStatResultByInstanceIdRequest): GetFullRequestStatResultByInstanceIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetFullRequestStatResultByInstanceId', 'POST', '/', 'json', false, 'json', request);
}

model GetHDMAliyunResourceSyncResultRequest {
  taskId?: string(name='TaskId', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
  accessKey?: string(name='accessKey', position='Query'),
  signature?: string(name='signature', position='Query'),
  skipAuth?: string(name='skipAuth', position='Query'),
  timestamp?: string(name='timestamp', position='Query'),
}

model GetHDMAliyunResourceSyncResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorMsg?: string(name='ErrorMsg'),
    results?: string(name='Results'),
    subResults?: {
      resourceSyncSubResult?: [ 
      {
        errMsg?: string(name='ErrMsg'),
        resourceType?: string(name='ResourceType'),
        success?: boolean(name='Success'),
        syncCount?: int32(name='SyncCount'),
      }
    ](name='ResourceSyncSubResult')
    }(name='SubResults'),
    syncStatus?: string(name='SyncStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetHDMAliyunResourceSyncResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetHDMAliyunResourceSyncResultResponseBody(name='body'),
}

async function getHDMAliyunResourceSyncResult(request: GetHDMAliyunResourceSyncResultRequest): GetHDMAliyunResourceSyncResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHDMAliyunResourceSyncResult', 'POST', '/', 'json', false, 'json', request);
}

model GetHDMLastAliyunResourceSyncResultRequest {
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
  accessKey?: string(name='accessKey', position='Query'),
  signature?: string(name='signature', position='Query'),
  skipAuth?: string(name='skipAuth', position='Query'),
  timestamp?: string(name='timestamp', position='Query'),
}

model GetHDMLastAliyunResourceSyncResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    errorMsg?: string(name='ErrorMsg'),
    results?: string(name='Results'),
    subResults?: {
      resourceSyncSubResult?: [ 
      {
        errMsg?: string(name='ErrMsg'),
        resourceType?: string(name='ResourceType'),
        success?: boolean(name='Success'),
        syncCount?: int32(name='SyncCount'),
      }
    ](name='ResourceSyncSubResult')
    }(name='SubResults'),
    syncStatus?: string(name='SyncStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetHDMLastAliyunResourceSyncResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetHDMLastAliyunResourceSyncResultResponseBody(name='body'),
}

async function getHDMLastAliyunResourceSyncResult(request: GetHDMLastAliyunResourceSyncResultRequest): GetHDMLastAliyunResourceSyncResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHDMLastAliyunResourceSyncResult', 'POST', '/', 'json', false, 'json', request);
}

model GetInstanceInspectionsRequest {
  endTime: string(name='EndTime', position='Query'),
  engine: string(name='Engine', position='Query'),
  instanceArea: string(name='InstanceArea', position='Query'),
  pageNo: string(name='PageNo', position='Query'),
  pageSize: string(name='PageSize', position='Query'),
  searchMap?: string(name='SearchMap', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model GetInstanceInspectionsResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: [ 
      {
        data?: map[string]any(name='Data'),
        endTime?: long(name='EndTime'),
        gmtCreate?: long(name='GmtCreate'),
        instance?: {
          accountId?: string(name='AccountId'),
          engine?: string(name='Engine'),
          engineVersion?: string(name='EngineVersion'),
          instanceArea?: string(name='InstanceArea'),
          instanceClass?: string(name='InstanceClass'),
          instanceId?: string(name='InstanceId'),
          networkType?: string(name='NetworkType'),
          nodeId?: string(name='NodeId'),
          region?: string(name='Region'),
          uuid?: string(name='Uuid'),
          vpcId?: string(name='VpcId'),
        }(name='Instance'),
        score?: int32(name='Score'),
        scoreMap?: map[string]any(name='ScoreMap'),
        startTime?: long(name='StartTime'),
      }
    ](name='List'),
    pageNo?: long(name='PageNo'),
    pageSize?: long(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetInstanceInspectionsResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceInspectionsResponseBody(name='body'),
}

async function getInstanceInspections(request: GetInstanceInspectionsRequest): GetInstanceInspectionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetInstanceInspections', 'POST', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeDataStatsRequest {
  asc?: string(name='Asc', position='Query'),
  dbNames?: string(name='DbNames', position='Query'),
  engine: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  keywords?: string(name='Keywords', position='Query'),
  logicalOperator?: string(name='LogicalOperator', position='Query'),
  onlyOptimizedSql?: string(name='OnlyOptimizedSql', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  rules?: string(name='Rules', position='Query'),
  sqlIds?: string(name='SqlIds', position='Query'),
  tagNames?: string(name='TagNames', position='Query'),
  time: string(name='Time', position='Query'),
}

model GetQueryOptimizeDataStatsResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        avgLockTime?: double(name='AvgLockTime'),
        avgQueryTime?: double(name='AvgQueryTime'),
        avgRowsAffected?: double(name='AvgRowsAffected'),
        avgRowsExamined?: double(name='AvgRowsExamined'),
        avgRowsSent?: double(name='AvgRowsSent'),
        count?: int32(name='Count'),
        dbname?: string(name='Dbname'),
        instanceId?: string(name='InstanceId'),
        maxLockTime?: double(name='MaxLockTime'),
        maxQueryTime?: double(name='MaxQueryTime'),
        maxRowsAffected?: long(name='MaxRowsAffected'),
        maxRowsExamined?: long(name='MaxRowsExamined'),
        maxRowsSent?: long(name='MaxRowsSent'),
        psql?: string(name='Psql'),
        ruleList?: [ 
          {
            name?: string(name='Name'),
            type?: string(name='Type'),
          }
        ](name='RuleList'),
        sqlId?: string(name='SqlId'),
        sqlSample?: string(name='SqlSample'),
        sqlType?: string(name='SqlType'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeDataStatsResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeDataStatsResponseBody(name='body'),
}

async function getQueryOptimizeDataStats(request: GetQueryOptimizeDataStatsRequest): GetQueryOptimizeDataStatsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeDataStats', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeDataTopRequest {
  engine: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  tagNames?: string(name='TagNames', position='Query'),
  time: string(name='Time', position='Query'),
  type: string(name='Type', position='Query'),
}

model GetQueryOptimizeDataTopResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        instanceId?: string(name='InstanceId'),
        type?: string(name='Type'),
        value?: double(name='Value'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeDataTopResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeDataTopResponseBody(name='body'),
}

async function getQueryOptimizeDataTop(request: GetQueryOptimizeDataTopRequest): GetQueryOptimizeDataTopResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeDataTop', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeDataTrendRequest {
  end: string(name='End', position='Query'),
  engine: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  start: string(name='Start', position='Query'),
  tagNames?: string(name='TagNames', position='Query'),
}

model GetQueryOptimizeDataTrendResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        kpi?: string(name='Kpi'),
        timestamp?: long(name='Timestamp'),
        value?: double(name='Value'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeDataTrendResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeDataTrendResponseBody(name='body'),
}

async function getQueryOptimizeDataTrend(request: GetQueryOptimizeDataTrendRequest): GetQueryOptimizeDataTrendResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeDataTrend', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeExecErrorSampleRequest {
  engine: string(name='Engine', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  sqlId: string(name='SqlId', position='Query'),
  time: string(name='Time', position='Query'),
}

model GetQueryOptimizeExecErrorSampleResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        dbname?: string(name='Dbname'),
        errorCode?: string(name='ErrorCode'),
        origHost?: string(name='OrigHost'),
        sqlId?: string(name='SqlId'),
        sqlText?: string(name='SqlText'),
        timestamp?: long(name='Timestamp'),
        user?: string(name='User'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeExecErrorSampleResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeExecErrorSampleResponseBody(name='body'),
}

async function getQueryOptimizeExecErrorSample(request: GetQueryOptimizeExecErrorSampleRequest): GetQueryOptimizeExecErrorSampleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeExecErrorSample', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeExecErrorStatsRequest {
  asc?: string(name='Asc', position='Query'),
  dbNames?: string(name='DbNames', position='Query'),
  engine: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  keywords?: string(name='Keywords', position='Query'),
  logicalOperator?: string(name='LogicalOperator', position='Query'),
  orderBy?: string(name='OrderBy', position='Query'),
  pageNo: string(name='PageNo', position='Query'),
  pageSize: string(name='PageSize', position='Query'),
  time: string(name='Time', position='Query'),
}

model GetQueryOptimizeExecErrorStatsResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        dbname?: string(name='Dbname'),
        errorCode?: string(name='ErrorCode'),
        errorCount?: long(name='ErrorCount'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        sqlId?: string(name='SqlId'),
        sqlText?: string(name='SqlText'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeExecErrorStatsResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeExecErrorStatsResponseBody(name='body'),
}

async function getQueryOptimizeExecErrorStats(request: GetQueryOptimizeExecErrorStatsRequest): GetQueryOptimizeExecErrorStatsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeExecErrorStats', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeRuleListRequest {
  engine: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  tagNames?: string(name='TagNames', position='Query'),
}

model GetQueryOptimizeRuleListResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        name?: string(name='Name'),
        ruleId?: string(name='RuleId'),
        type?: string(name='Type'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeRuleListResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeRuleListResponseBody(name='body'),
}

async function getQueryOptimizeRuleList(request: GetQueryOptimizeRuleListRequest): GetQueryOptimizeRuleListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeRuleList', 'GET', '/', 'json', false, 'json', request);
}

model GetQueryOptimizeSolutionRequest {
  engine: string(name='Engine', position='Query'),
  ruleIds: string(name='RuleIds', position='Query'),
  sqlId: string(name='SqlId', position='Query'),
}

model GetQueryOptimizeSolutionResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='Extra'),
    list?: [ 
      {
        level?: string(name='Level'),
        ruleId?: string(name='RuleId'),
        solution?: string(name='Solution'),
        solutionExt?: string(name='SolutionExt'),
      }
    ](name='List'),
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetQueryOptimizeSolutionResponse = {
  headers: map[string]string(name='headers'),
  body: GetQueryOptimizeSolutionResponseBody(name='body'),
}

async function getQueryOptimizeSolution(request: GetQueryOptimizeSolutionRequest): GetQueryOptimizeSolutionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetQueryOptimizeSolution', 'GET', '/', 'json', false, 'json', request);
}

model GetRequestDiagnosisPageRequest {
  endTime?: string(name='EndTime', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
  pageNo?: string(name='PageNo', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model GetRequestDiagnosisPageResponseBody = {
  code?: string(name='Code'),
  data?: {
    extra?: string(name='extra'),
    list?: [ 
      {
        accountId?: string(name='accountId'),
        dbSchema?: string(name='dbSchema'),
        engine?: string(name='engine'),
        gmtCreate?: string(name='gmtCreate'),
        gmtModified?: string(name='gmtModified'),
        messageId?: string(name='messageId'),
        param?: string(name='param'),
        result?: string(name='result'),
        sqlId?: string(name='sqlId'),
        state?: int32(name='state'),
        uuid?: string(name='uuid'),
      }
    ](name='list'),
    pageNo?: long(name='pageNo'),
    pageSize?: long(name='pageSize'),
    total?: long(name='total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRequestDiagnosisPageResponse = {
  headers: map[string]string(name='headers'),
  body: GetRequestDiagnosisPageResponseBody(name='body'),
}

async function getRequestDiagnosisPage(request: GetRequestDiagnosisPageRequest): GetRequestDiagnosisPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRequestDiagnosisPage', 'POST', '/', 'json', false, 'json', request);
}

model GetRequestDiagnosisResultRequest {
  instanceId?: string(name='InstanceId', position='Query'),
  messageId?: string(name='MessageId', position='Query'),
  nodeId?: string(name='NodeId', position='Query'),
}

model GetRequestDiagnosisResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    accountId?: string(name='accountId'),
    dbSchema?: string(name='dbSchema'),
    engine?: string(name='engine'),
    gmtCreate?: string(name='gmtCreate'),
    gmtModified?: string(name='gmtModified'),
    messageId?: string(name='messageId'),
    param?: string(name='param'),
    result?: string(name='result'),
    sqlId?: string(name='sqlId'),
    state?: int32(name='state'),
    uuid?: string(name='uuid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRequestDiagnosisResultResponse = {
  headers: map[string]string(name='headers'),
  body: GetRequestDiagnosisResultResponseBody(name='body'),
}

async function getRequestDiagnosisResult(request: GetRequestDiagnosisResultRequest): GetRequestDiagnosisResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRequestDiagnosisResult', 'POST', '/', 'json', false, 'json', request);
}

model GetResourceOptimizeHistoryListRequest {
  accessKey?: string(name='AccessKey', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  page?: int32(name='Page', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  signature?: string(name='Signature', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model GetResourceOptimizeHistoryListResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model GetResourceOptimizeHistoryListResponse = {
  headers: map[string]string(name='headers'),
  body: GetResourceOptimizeHistoryListResponseBody(name='body'),
}

async function getResourceOptimizeHistoryList(request: GetResourceOptimizeHistoryListRequest): GetResourceOptimizeHistoryListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetResourceOptimizeHistoryList', 'POST', '/', 'json', false, 'json', request);
}

model GetRunningSqlConcurrencyControlRulesRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  pageNo?: long(name='PageNo', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model GetRunningSqlConcurrencyControlRulesResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      runningRules?: [ 
      {
        concurrencyControlTime?: long(name='ConcurrencyControlTime'),
        instanceId?: string(name='InstanceId'),
        itemId?: long(name='ItemId'),
        keywordsHash?: string(name='KeywordsHash'),
        maxConcurrency?: string(name='MaxConcurrency'),
        sqlKeywords?: string(name='SqlKeywords'),
        sqlType?: string(name='SqlType'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='runningRules')
    }(name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetRunningSqlConcurrencyControlRulesResponse = {
  headers: map[string]string(name='headers'),
  body: GetRunningSqlConcurrencyControlRulesResponseBody(name='body'),
}

async function getRunningSqlConcurrencyControlRules(request: GetRunningSqlConcurrencyControlRulesRequest): GetRunningSqlConcurrencyControlRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRunningSqlConcurrencyControlRules', 'POST', '/', 'json', false, 'json', request);
}

model GetSqlAnalysisReportRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  moduleNameList?: string(name='ModuleNameList', position='Query'),
  taskId?: string(name='TaskId', position='Body'),
}

model GetSqlAnalysisReportResponseBody = {
  code?: long(name='Code'),
  data?: [ 
    {
      instanceId?: string(name='InstanceId'),
      moduleName?: string(name='ModuleName'),
      result?: string(name='Result'),
      taskId?: string(name='TaskId'),
      userId?: string(name='UserId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetSqlAnalysisReportResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlAnalysisReportResponseBody(name='body'),
}

async function getSqlAnalysisReport(request: GetSqlAnalysisReportRequest): GetSqlAnalysisReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSqlAnalysisReport', 'POST', '/', 'json', true, 'form', request);
}

model GetSqlConcurrencyControlKeywordsFromSqlTextRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  sqlText: string(name='SqlText', position='Query'),
}

model GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlConcurrencyControlKeywordsFromSqlTextResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlConcurrencyControlKeywordsFromSqlTextResponseBody(name='body'),
}

async function getSqlConcurrencyControlKeywordsFromSqlText(request: GetSqlConcurrencyControlKeywordsFromSqlTextRequest): GetSqlConcurrencyControlKeywordsFromSqlTextResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSqlConcurrencyControlKeywordsFromSqlText', 'POST', '/', 'json', false, 'json', request);
}

model GetSqlConcurrencyControlRulesHistoryRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  instanceId: string(name='InstanceId', position='Query'),
  pageNo?: long(name='PageNo', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
}

model GetSqlConcurrencyControlRulesHistoryResponseBody = {
  code?: string(name='Code'),
  data?: {
    list?: {
      rules?: [ 
      {
        concurrencyControlTime?: long(name='ConcurrencyControlTime'),
        instanceId?: string(name='InstanceId'),
        itemId?: long(name='ItemId'),
        keywordsHash?: string(name='KeywordsHash'),
        maxConcurrency?: long(name='MaxConcurrency'),
        sqlKeywords?: string(name='SqlKeywords'),
        sqlType?: string(name='SqlType'),
        startTime?: long(name='StartTime'),
        status?: string(name='Status'),
        userId?: string(name='UserId'),
      }
    ](name='rules')
    }(name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlConcurrencyControlRulesHistoryResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlConcurrencyControlRulesHistoryResponseBody(name='body'),
}

async function getSqlConcurrencyControlRulesHistory(request: GetSqlConcurrencyControlRulesHistoryRequest): GetSqlConcurrencyControlRulesHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSqlConcurrencyControlRulesHistory', 'POST', '/', 'json', false, 'json', request);
}

model GetSqlOptimizeAdviceRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  endDt?: string(name='EndDt', position='Query'),
  engine?: string(name='Engine', position='Query'),
  instanceIds?: string(name='InstanceIds', position='Query'),
  startDt?: string(name='StartDt', position='Query'),
}

model GetSqlOptimizeAdviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    createTime?: string(name='CreateTime'),
    downloadUrl?: string(name='DownloadUrl'),
    expireTime?: string(name='ExpireTime'),
    status?: string(name='Status'),
    statusCode?: string(name='StatusCode'),
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model GetSqlOptimizeAdviceResponse = {
  headers: map[string]string(name='headers'),
  body: GetSqlOptimizeAdviceResponseBody(name='body'),
}

async function getSqlOptimizeAdvice(request: GetSqlOptimizeAdviceRequest): GetSqlOptimizeAdviceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetSqlOptimizeAdvice', 'POST', '/', 'json', false, 'json', request);
}

model QuerySqlAnalysisDataRequest {
  consoleContext?: string(name='ConsoleContext', position='Query'),
  pageNo?: int32(name='PageNo', position='Body'),
  pageSize?: int32(name='PageSize', position='Body'),
  sqlIdList?: string(name='SqlIdList', position='Body'),
  sqlTextFeature?: string(name='SqlTextFeature', position='Body'),
  sqlType?: string(name='SqlType', position='Body'),
  taskId?: string(name='TaskId', position='Body'),
  type?: string(name='Type', position='Body'),
}

model QuerySqlAnalysisDataResponseBody = {
  code?: long(name='Code'),
  data?: {
    list?: [ 
      {
        avgRowsExamined?: long(name='AvgRowsExamined'),
        avgRt?: double(name='AvgRt'),
        cnt?: long(name='Cnt'),
        currentEndTime?: long(name='CurrentEndTime'),
        dbName?: string(name='DbName'),
        errorCnt?: long(name='ErrorCnt'),
        firstTime?: long(name='FirstTime'),
        instanceId?: string(name='InstanceId'),
        maxRowsExamined?: long(name='MaxRowsExamined'),
        sql?: string(name='Sql'),
        sqlId?: string(name='SqlId'),
        sqlTextFeature?: string(name='SqlTextFeature'),
        sqlType?: string(name='SqlType'),
        sumRt?: double(name='SumRt'),
        tableList?: string(name='TableList'),
        taskId?: string(name='TaskId'),
        type?: string(name='Type'),
        userId?: string(name='UserId'),
      }
    ](name='List'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model QuerySqlAnalysisDataResponse = {
  headers: map[string]string(name='headers'),
  body: QuerySqlAnalysisDataResponseBody(name='body'),
}

async function querySqlAnalysisData(request: QuerySqlAnalysisDataRequest): QuerySqlAnalysisDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySqlAnalysisData', 'POST', '/', 'json', true, 'form', request);
}

model RunCloudBenchTaskRequest {
  taskId: string(name='TaskId', position='Query'),
}

model RunCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    preCheckItem?: [ 
    {
      code?: int32(name='Code'),
      details?: string(name='Details'),
      message?: string(name='Message'),
      name?: string(name='Name'),
      order?: int32(name='Order'),
      status?: string(name='Status'),
    }
  ](name='PreCheckItem')
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model RunCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: RunCloudBenchTaskResponseBody(name='body'),
}

async function runCloudBenchTask(request: RunCloudBenchTaskRequest): RunCloudBenchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunCloudBenchTask', 'POST', '/', 'json', false, 'json', request);
}

model StopCloudBenchTaskRequest {
  taskId: string(name='TaskId', position='Query'),
}

model StopCloudBenchTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model StopCloudBenchTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopCloudBenchTaskResponseBody(name='body'),
}

async function stopCloudBenchTask(request: StopCloudBenchTaskRequest): StopCloudBenchTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopCloudBenchTask', 'POST', '/', 'json', false, 'json', request);
}

model StopOrRollbackOptimizeTaskRequest {
  accessKey?: string(name='AccessKey', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  signature?: string(name='Signature', position='Query'),
  stopOrRollback?: string(name='StopOrRollback', position='Query'),
  taskType?: string(name='TaskType', position='Query'),
  taskUuid?: string(name='TaskUuid', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model StopOrRollbackOptimizeTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model StopOrRollbackOptimizeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: StopOrRollbackOptimizeTaskResponseBody(name='body'),
}

async function stopOrRollbackOptimizeTask(request: StopOrRollbackOptimizeTaskRequest): StopOrRollbackOptimizeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopOrRollbackOptimizeTask', 'POST', '/', 'json', false, 'json', request);
}

model SyncHDMAliyunResourceRequest {
  async?: string(name='Async', position='Query'),
  resourceTypes?: string(name='ResourceTypes', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  waitForModifySecurityIps?: string(name='WaitForModifySecurityIps', position='Query'),
  context?: string(name='__context', position='Query'),
  accessKey?: string(name='accessKey', position='Query'),
  signature?: string(name='signature', position='Query'),
  skipAuth?: string(name='skipAuth', position='Query'),
  timestamp?: string(name='timestamp', position='Query'),
}

model SyncHDMAliyunResourceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model SyncHDMAliyunResourceResponse = {
  headers: map[string]string(name='headers'),
  body: SyncHDMAliyunResourceResponseBody(name='body'),
}

async function syncHDMAliyunResource(request: SyncHDMAliyunResourceRequest): SyncHDMAliyunResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SyncHDMAliyunResource', 'POST', '/', 'json', false, 'json', request);
}

model TurnOffAutoResourceOptimizeRequest {
  accessKey?: string(name='AccessKey', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  signature?: string(name='Signature', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model TurnOffAutoResourceOptimizeResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model TurnOffAutoResourceOptimizeResponse = {
  headers: map[string]string(name='headers'),
  body: TurnOffAutoResourceOptimizeResponseBody(name='body'),
}

async function turnOffAutoResourceOptimize(request: TurnOffAutoResourceOptimizeRequest): TurnOffAutoResourceOptimizeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TurnOffAutoResourceOptimize', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAutoResourceOptimizeConfigRequest {
  accessKey?: string(name='AccessKey', position='Query'),
  autoDefragment?: int32(name='AutoDefragment', position='Query'),
  autoDuplicateIndexDelete?: int32(name='AutoDuplicateIndexDelete', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  signature?: string(name='Signature', position='Query'),
  tableFragmentationRatio?: float(name='TableFragmentationRatio', position='Query'),
  tableSpaceSize?: float(name='TableSpaceSize', position='Query'),
  uid?: string(name='Uid', position='Query'),
  userId?: string(name='UserId', position='Query'),
  context?: string(name='__context', position='Query'),
}

model UpdateAutoResourceOptimizeConfigResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  synchro?: string(name='Synchro'),
}

model UpdateAutoResourceOptimizeConfigResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAutoResourceOptimizeConfigResponseBody(name='body'),
}

async function updateAutoResourceOptimizeConfig(request: UpdateAutoResourceOptimizeConfigRequest): UpdateAutoResourceOptimizeConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAutoResourceOptimizeConfig', 'POST', '/', 'json', false, 'json', request);
}

