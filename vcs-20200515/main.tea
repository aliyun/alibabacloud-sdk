/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @signatureAlgorithm = 'v2';
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('vcs', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AiotDevice {
  IPAddr?: string(name='IPAddr'),
  latitude?: float(name='Latitude'),
  longitude?: float(name='Longitude'),
  name?: string(name='Name'),
  place?: string(name='Place'),
  port?: long(name='Port'),
}

model AddAiotDevicesRequest {
  aiotDeviceList?: [ 
    {
      corpId?: string(name='CorpId'),
      deviceId?: string(name='DeviceId'),
      IPAddr?: string(name='IPAddr'),
      latitude?: float(name='Latitude'),
      longitude?: float(name='Longitude'),
      name?: string(name='Name'),
      place?: string(name='Place'),
      port?: long(name='Port'),
    }
  ](name='AiotDeviceList'),
}

model AddAiotDevicesShrinkRequest {
  aiotDeviceListShrink?: string(name='AiotDeviceList'),
}

model AddAiotDevicesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resultList?: [ 
    {
      code?: string(name='Code'),
      deviceId?: string(name='DeviceId'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      password?: string(name='Password'),
      serverHost?: string(name='ServerHost'),
      serverHostInternal?: string(name='ServerHostInternal'),
      serverId?: string(name='ServerId'),
      serverIp?: string(name='ServerIp'),
      serverIpInternal?: string(name='ServerIpInternal'),
      serverPort?: string(name='ServerPort'),
      serverWssPort?: string(name='ServerWssPort'),
      userId?: string(name='UserId'),
    }
  ](name='ResultList'),
}

model AddAiotDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAiotDevicesResponseBody(name='body'),
}

async function addAiotDevicesWithOptions(tmpReq: AddAiotDevicesRequest, runtime: Util.RuntimeOptions): AddAiotDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new AddAiotDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aiotDeviceList)) {
    request.aiotDeviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aiotDeviceList, 'AiotDeviceList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.aiotDeviceListShrink)) {
    body['AiotDeviceList'] = request.aiotDeviceListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAiotDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAiotDevices(request: AddAiotDevicesRequest): AddAiotDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAiotDevicesWithOptions(request, runtime);
}

model AddAiotPersonTableRequest {
  id?: string(name='Id'),
  personTable?: {
    name?: string(name='Name'),
    personTableId?: string(name='PersonTableId'),
    type?: long(name='Type'),
    verificationModelList?: [ long ](name='VerificationModelList'),
  }(name='PersonTable'),
}

model AddAiotPersonTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  personTableId?: string(name='PersonTableId'),
  requestId?: string(name='RequestId'),
}

model AddAiotPersonTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAiotPersonTableResponseBody(name='body'),
}

async function addAiotPersonTableWithOptions(request: AddAiotPersonTableRequest, runtime: Util.RuntimeOptions): AddAiotPersonTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.personTable)) {
    bodyFlat['PersonTable'] = request.personTable;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAiotPersonTable',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAiotPersonTable(request: AddAiotPersonTableRequest): AddAiotPersonTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAiotPersonTableWithOptions(request, runtime);
}

model AddAiotPersonTableItemsRequest {
  id?: string(name='Id'),
  personTableId?: string(name='PersonTableId'),
  personTableItemList?: [ 
    {
      identificationList?: [ 
        {
          number?: string(name='Number'),
          type?: long(name='Type'),
        }
      ](name='IdentificationList'),
      identificationNum?: long(name='IdentificationNum'),
      imageList?: [ 
        {
          data?: string(name='Data'),
          deviceId?: string(name='DeviceId'),
          eventSort?: string(name='EventSort'),
          featureInfo?: {
            algorithmType?: string(name='AlgorithmType'),
            algorithmVersion?: string(name='AlgorithmVersion'),
            featureData?: string(name='FeatureData'),
            imageId?: string(name='ImageId'),
            objectId?: string(name='ObjectId'),
            tabIed?: string(name='TabIed'),
            vendor?: string(name='Vendor'),
          }(name='FeatureInfo'),
          fileFormat?: string(name='FileFormat'),
          height?: long(name='Height'),
          imageId?: string(name='ImageId'),
          shotTime?: string(name='ShotTime'),
          size?: long(name='Size'),
          storagePath?: string(name='StoragePath'),
          type?: string(name='Type'),
          width?: long(name='Width'),
        }
      ](name='ImageList'),
      imageNum?: long(name='ImageNum'),
      personCode?: string(name='PersonCode'),
      personId?: string(name='PersonId'),
      personName?: string(name='PersonName'),
      remarks?: string(name='Remarks'),
    }
  ](name='PersonTableItemList'),
}

model AddAiotPersonTableItemsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resultList?: [ 
    {
      code?: string(name='Code'),
      message?: string(name='Message'),
      personTableItemId?: string(name='PersonTableItemId'),
    }
  ](name='ResultList'),
}

model AddAiotPersonTableItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAiotPersonTableItemsResponseBody(name='body'),
}

async function addAiotPersonTableItemsWithOptions(request: AddAiotPersonTableItemsRequest, runtime: Util.RuntimeOptions): AddAiotPersonTableItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.personTableId)) {
    body['PersonTableId'] = request.personTableId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.personTableItemList)) {
    bodyFlat['PersonTableItemList'] = request.personTableItemList;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAiotPersonTableItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAiotPersonTableItems(request: AddAiotPersonTableItemsRequest): AddAiotPersonTableItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAiotPersonTableItemsWithOptions(request, runtime);
}

model AddAiotPersonTableItemsForTablesRequest {
  personTableItemList?: [ 
    {
      identificationList?: [ 
        {
          number?: string(name='Number'),
          type?: long(name='Type'),
        }
      ](name='IdentificationList'),
      identificationNum?: long(name='IdentificationNum'),
      imageList?: [ 
        {
          data?: string(name='Data'),
          deviceId?: string(name='DeviceId'),
          eventSort?: string(name='EventSort'),
          featureInfo?: {
            algorithmType?: string(name='AlgorithmType'),
            algorithmVersion?: string(name='AlgorithmVersion'),
            featureData?: string(name='FeatureData'),
            imageId?: string(name='ImageId'),
            objectId?: string(name='ObjectId'),
            tabIed?: string(name='TabIed'),
            vendor?: string(name='Vendor'),
          }(name='FeatureInfo'),
          fileFormat?: string(name='FileFormat'),
          height?: long(name='Height'),
          imageId?: string(name='ImageId'),
          shotTime?: string(name='ShotTime'),
          size?: long(name='Size'),
          storagePath?: string(name='StoragePath'),
          type?: string(name='Type'),
          width?: long(name='Width'),
        }
      ](name='ImageList'),
      imageNum?: long(name='ImageNum'),
      personCode?: string(name='PersonCode'),
      personId?: string(name='PersonId'),
      personName?: string(name='PersonName'),
      remarks?: string(name='Remarks'),
    }
  ](name='PersonTableItemList'),
  personTableList?: [ 
    {
      id?: string(name='Id'),
      personTableId?: string(name='PersonTableId'),
    }
  ](name='PersonTableList'),
}

model AddAiotPersonTableItemsForTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddAiotPersonTableItemsForTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAiotPersonTableItemsForTablesResponseBody(name='body'),
}

async function addAiotPersonTableItemsForTablesWithOptions(request: AddAiotPersonTableItemsForTablesRequest, runtime: Util.RuntimeOptions): AddAiotPersonTableItemsForTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.personTableItemList)) {
    bodyFlat['PersonTableItemList'] = request.personTableItemList;
  }
  if (!Util.isUnset(request.personTableList)) {
    bodyFlat['PersonTableList'] = request.personTableList;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAiotPersonTableItemsForTables',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAiotPersonTableItemsForTables(request: AddAiotPersonTableItemsForTablesRequest): AddAiotPersonTableItemsForTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAiotPersonTableItemsForTablesWithOptions(request, runtime);
}

model AddAiotVehicleTableItemsRequest {
  id?: string(name='Id'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItem?: {
    beginTime?: string(name='BeginTime'),
    endTime?: string(name='EndTime'),
    ownerName?: string(name='OwnerName'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    remarks?: string(name='Remarks'),
    vehicleTableItemId?: string(name='VehicleTableItemId'),
  }(name='VehicleTableItem'),
}

model AddAiotVehicleTableItemsShrinkRequest {
  id?: string(name='Id'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItemShrink?: string(name='VehicleTableItem'),
}

model AddAiotVehicleTableItemsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddAiotVehicleTableItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddAiotVehicleTableItemsResponseBody(name='body'),
}

async function addAiotVehicleTableItemsWithOptions(tmpReq: AddAiotVehicleTableItemsRequest, runtime: Util.RuntimeOptions): AddAiotVehicleTableItemsResponse {
  Util.validateModel(tmpReq);
  var request = new AddAiotVehicleTableItemsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.vehicleTableItem)) {
    request.vehicleTableItemShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vehicleTableItem, 'VehicleTableItem', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.vehicleTableId)) {
    body['VehicleTableId'] = request.vehicleTableId;
  }
  if (!Util.isUnset(request.vehicleTableItemShrink)) {
    body['VehicleTableItem'] = request.vehicleTableItemShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddAiotVehicleTableItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addAiotVehicleTableItems(request: AddAiotVehicleTableItemsRequest): AddAiotVehicleTableItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addAiotVehicleTableItemsWithOptions(request, runtime);
}

model AddCameraForInstanceRequest {
  cameraIds?: [ string ](name='CameraIds'),
  instanceId?: string(name='InstanceId'),
}

model AddCameraForInstanceShrinkRequest {
  cameraIdsShrink?: string(name='CameraIds'),
  instanceId?: string(name='InstanceId'),
}

model AddCameraForInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddCameraForInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddCameraForInstanceResponseBody(name='body'),
}

async function addCameraForInstanceWithOptions(tmpReq: AddCameraForInstanceRequest, runtime: Util.RuntimeOptions): AddCameraForInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new AddCameraForInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.cameraIds)) {
    request.cameraIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cameraIds, 'CameraIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cameraIdsShrink)) {
    body['CameraIds'] = request.cameraIdsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddCameraForInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addCameraForInstance(request: AddCameraForInstanceRequest): AddCameraForInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addCameraForInstanceWithOptions(request, runtime);
}

model AddChannelRequest {
  parentDeviceGbId?: string(name='ParentDeviceGbId'),
}

model AddChannelResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddChannelResponseBody(name='body'),
}

async function addChannelWithOptions(request: AddChannelRequest, runtime: Util.RuntimeOptions): AddChannelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.parentDeviceGbId)) {
    body['ParentDeviceGbId'] = request.parentDeviceGbId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddChannel',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addChannel(request: AddChannelRequest): AddChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return addChannelWithOptions(request, runtime);
}

model AddDataSourceRequest {
  corpId?: string(name='CorpId'),
  dataSourceName?: string(name='DataSourceName'),
  dataSourceType?: string(name='DataSourceType'),
  description?: string(name='Description'),
  url?: string(name='Url'),
}

model AddDataSourceResponseBody = {
  code?: string(name='Code'),
  data?: {
    dataSourceId?: string(name='DataSourceId'),
    kafkaTopic?: string(name='KafkaTopic'),
    ossPath?: string(name='OssPath'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDataSourceResponseBody(name='body'),
}

async function addDataSourceWithOptions(request: AddDataSourceRequest, runtime: Util.RuntimeOptions): AddDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['DataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDataSource',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDataSource(request: AddDataSourceRequest): AddDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDataSourceWithOptions(request, runtime);
}

model AddDeviceRequest {
  bitRate?: string(name='BitRate'),
  corpId?: string(name='CorpId'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceDirection?: string(name='DeviceDirection'),
  deviceName?: string(name='DeviceName'),
  deviceResolution?: string(name='DeviceResolution'),
  deviceSite?: string(name='DeviceSite'),
  deviceType?: string(name='DeviceType'),
  gbId?: string(name='GbId'),
  vendor?: string(name='Vendor'),
}

model AddDeviceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDeviceResponseBody(name='body'),
}

async function addDeviceWithOptions(request: AddDeviceRequest, runtime: Util.RuntimeOptions): AddDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bitRate)) {
    body['BitRate'] = request.bitRate;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceDirection)) {
    body['DeviceDirection'] = request.deviceDirection;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceResolution)) {
    body['DeviceResolution'] = request.deviceResolution;
  }
  if (!Util.isUnset(request.deviceSite)) {
    body['DeviceSite'] = request.deviceSite;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDevice(request: AddDeviceRequest): AddDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDeviceWithOptions(request, runtime);
}

model AddDoubleVerificationGroupsRequest {
  doubleVerificationGroupList?: [ 
    {
      groupId?: string(name='GroupId'),
      interval?: long(name='Interval'),
      memberNumber?: long(name='MemberNumber'),
      personIdList?: [ 
        {
          personId?: string(name='PersonId'),
          personTableId?: string(name='PersonTableId'),
        }
      ](name='PersonIdList'),
    }
  ](name='DoubleVerificationGroupList'),
  id?: string(name='Id'),
}

model AddDoubleVerificationGroupsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  resultList?: [ 
    {
      code?: string(name='Code'),
      groupId?: string(name='GroupId'),
      message?: string(name='Message'),
    }
  ](name='ResultList'),
}

model AddDoubleVerificationGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddDoubleVerificationGroupsResponseBody(name='body'),
}

async function addDoubleVerificationGroupsWithOptions(request: AddDoubleVerificationGroupsRequest, runtime: Util.RuntimeOptions): AddDoubleVerificationGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.doubleVerificationGroupList)) {
    bodyFlat['DoubleVerificationGroupList'] = request.doubleVerificationGroupList;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddDoubleVerificationGroups',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addDoubleVerificationGroups(request: AddDoubleVerificationGroupsRequest): AddDoubleVerificationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addDoubleVerificationGroupsWithOptions(request, runtime);
}

model AddMonitorRequest {
  algorithmVendor?: string(name='AlgorithmVendor'),
  batchIndicator?: int32(name='BatchIndicator'),
  corpId?: string(name='CorpId'),
  description?: string(name='Description'),
  monitorType?: string(name='MonitorType'),
  notifierAppSecret?: string(name='NotifierAppSecret'),
  notifierExtendValues?: string(name='NotifierExtendValues'),
  notifierTimeOut?: int32(name='NotifierTimeOut'),
  notifierType?: string(name='NotifierType'),
  notifierUrl?: string(name='NotifierUrl'),
}

model AddMonitorResponseBody = {
  code?: string(name='Code'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddMonitorResponseBody(name='body'),
}

async function addMonitorWithOptions(request: AddMonitorRequest, runtime: Util.RuntimeOptions): AddMonitorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmVendor)) {
    body['AlgorithmVendor'] = request.algorithmVendor;
  }
  if (!Util.isUnset(request.batchIndicator)) {
    body['BatchIndicator'] = request.batchIndicator;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.monitorType)) {
    body['MonitorType'] = request.monitorType;
  }
  if (!Util.isUnset(request.notifierAppSecret)) {
    body['NotifierAppSecret'] = request.notifierAppSecret;
  }
  if (!Util.isUnset(request.notifierExtendValues)) {
    body['NotifierExtendValues'] = request.notifierExtendValues;
  }
  if (!Util.isUnset(request.notifierTimeOut)) {
    body['NotifierTimeOut'] = request.notifierTimeOut;
  }
  if (!Util.isUnset(request.notifierType)) {
    body['NotifierType'] = request.notifierType;
  }
  if (!Util.isUnset(request.notifierUrl)) {
    body['NotifierUrl'] = request.notifierUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddMonitor',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addMonitor(request: AddMonitorRequest): AddMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return addMonitorWithOptions(request, runtime);
}

model AddProfileRequest {
  bizId?: string(name='BizId'),
  catalogId?: long(name='CatalogId'),
  corpId?: string(name='CorpId'),
  faceUrl?: string(name='FaceUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  liveAddress?: string(name='LiveAddress'),
  name?: string(name='Name'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  sceneType?: string(name='SceneType'),
}

model AddProfileResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizId?: string(name='BizId'),
    catalogId?: int32(name='CatalogId'),
    faceUrl?: string(name='FaceUrl'),
    gender?: string(name='Gender'),
    idNumber?: string(name='IdNumber'),
    isvSubId?: string(name='IsvSubId'),
    liveAddress?: string(name='LiveAddress'),
    name?: string(name='Name'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    profileId?: int32(name='ProfileId'),
    sceneType?: string(name='SceneType'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProfileResponseBody(name='body'),
}

async function addProfileWithOptions(request: AddProfileRequest, runtime: Util.RuntimeOptions): AddProfileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceUrl)) {
    body['FaceUrl'] = request.faceUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.liveAddress)) {
    body['LiveAddress'] = request.liveAddress;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.sceneType)) {
    body['SceneType'] = request.sceneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProfile',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProfile(request: AddProfileRequest): AddProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProfileWithOptions(request, runtime);
}

model AddProfileCatalogRequest {
  catalogName?: string(name='CatalogName'),
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  parentCatalogId?: long(name='ParentCatalogId'),
}

model AddProfileCatalogResponseBody = {
  code?: string(name='Code'),
  data?: {
    catalogId?: long(name='CatalogId'),
    catalogName?: string(name='CatalogName'),
    isvSubId?: string(name='IsvSubId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model AddProfileCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddProfileCatalogResponseBody(name='body'),
}

async function addProfileCatalogWithOptions(request: AddProfileCatalogRequest, runtime: Util.RuntimeOptions): AddProfileCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogName)) {
    body['CatalogName'] = request.catalogName;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.parentCatalogId)) {
    body['ParentCatalogId'] = request.parentCatalogId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddProfileCatalog',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addProfileCatalog(request: AddProfileCatalogRequest): AddProfileCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return addProfileCatalogWithOptions(request, runtime);
}

model AddSearchItemsRequest {
  searchItemList?: [ 
    {
      itemImageUrl?: string(name='ItemImageUrl'),
      searchItemId?: string(name='SearchItemId'),
      searchItemName?: string(name='SearchItemName'),
    }
  ](name='SearchItemList'),
  searchTableId?: string(name='SearchTableId'),
}

model AddSearchItemsShrinkRequest {
  searchItemListShrink?: string(name='SearchItemList'),
  searchTableId?: string(name='SearchTableId'),
}

model AddSearchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    addedItemIds?: string(name='AddedItemIds'),
    failedItemIds?: string(name='FailedItemIds'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model AddSearchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddSearchItemsResponseBody(name='body'),
}

async function addSearchItemsWithOptions(tmpReq: AddSearchItemsRequest, runtime: Util.RuntimeOptions): AddSearchItemsResponse {
  Util.validateModel(tmpReq);
  var request = new AddSearchItemsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.searchItemList)) {
    request.searchItemListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.searchItemList, 'SearchItemList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.searchItemListShrink)) {
    body['SearchItemList'] = request.searchItemListShrink;
  }
  if (!Util.isUnset(request.searchTableId)) {
    body['SearchTableId'] = request.searchTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddSearchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addSearchItems(request: AddSearchItemsRequest): AddSearchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addSearchItemsWithOptions(request, runtime);
}

model AddWatchItemsRequest {
  watchItemList?: [ 
    {
      itemAttributes?: string(name='ItemAttributes'),
      itemImageUrl?: string(name='ItemImageUrl'),
      watchItemId?: string(name='WatchItemId'),
      watchItemName?: string(name='WatchItemName'),
    }
  ](name='WatchItemList'),
  watchPolicyId?: string(name='WatchPolicyId'),
}

model AddWatchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    addedItemIds?: string(name='AddedItemIds'),
    failedItemIds?: string(name='FailedItemIds'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddWatchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddWatchItemsResponseBody(name='body'),
}

async function addWatchItemsWithOptions(request: AddWatchItemsRequest, runtime: Util.RuntimeOptions): AddWatchItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.watchItemList)) {
    bodyFlat['WatchItemList'] = request.watchItemList;
  }
  if (!Util.isUnset(request.watchPolicyId)) {
    body['WatchPolicyId'] = request.watchPolicyId;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AddWatchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addWatchItems(request: AddWatchItemsRequest): AddWatchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return addWatchItemsWithOptions(request, runtime);
}

model BatchDeleteInstanceRequest {
  instanceIds?: [ string ](name='InstanceIds'),
  projectId?: string(name='ProjectId'),
}

model BatchDeleteInstanceShrinkRequest {
  instanceIdsShrink?: string(name='InstanceIds'),
  projectId?: string(name='ProjectId'),
}

model BatchDeleteInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDeleteInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteInstanceResponseBody(name='body'),
}

async function batchDeleteInstanceWithOptions(tmpReq: BatchDeleteInstanceRequest, runtime: Util.RuntimeOptions): BatchDeleteInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new BatchDeleteInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceIdsShrink)) {
    body['InstanceIds'] = request.instanceIdsShrink;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteInstance(request: BatchDeleteInstanceRequest): BatchDeleteInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteInstanceWithOptions(request, runtime);
}

model BindCorpGroupRequest {
  corpGroupId?: string(name='CorpGroupId'),
  corpId?: string(name='CorpId'),
}

model BindCorpGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BindCorpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindCorpGroupResponseBody(name='body'),
}

async function bindCorpGroupWithOptions(request: BindCorpGroupRequest, runtime: Util.RuntimeOptions): BindCorpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpGroupId)) {
    body['CorpGroupId'] = request.corpGroupId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindCorpGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindCorpGroup(request: BindCorpGroupRequest): BindCorpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindCorpGroupWithOptions(request, runtime);
}

model BindDevicesRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  subDeviceList?: [ 
    {
      accessProtocol?: string(name='AccessProtocol'),
      loginName?: string(name='LoginName'),
      PIN?: string(name='PIN'),
      subDeviceIp?: string(name='SubDeviceIp'),
      subDeviceName?: string(name='SubDeviceName'),
      subDevicePort?: string(name='SubDevicePort'),
    }
  ](name='SubDeviceList'),
}

model BindDevicesShrinkRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  subDeviceListShrink?: string(name='SubDeviceList'),
}

model BindDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    subDeviceList?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
        subDeviceId?: string(name='SubDeviceId'),
        subDeviceIp?: string(name='SubDeviceIp'),
        subDeviceName?: string(name='SubDeviceName'),
        subDeviceNum?: string(name='SubDeviceNum'),
        subDevicePort?: string(name='SubDevicePort'),
      }
    ](name='SubDeviceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindDevicesResponseBody(name='body'),
}

async function bindDevicesWithOptions(tmpReq: BindDevicesRequest, runtime: Util.RuntimeOptions): BindDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new BindDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.subDeviceList)) {
    request.subDeviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.subDeviceList, 'SubDeviceList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.subDeviceListShrink)) {
    body['SubDeviceList'] = request.subDeviceListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindDevices(request: BindDevicesRequest): BindDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindDevicesWithOptions(request, runtime);
}

model BindPersonRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  personId?: string(name='PersonId'),
  personMatchingRate?: string(name='PersonMatchingRate'),
  profileId?: long(name='ProfileId'),
}

model BindPersonResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindPersonResponseBody(name='body'),
}

async function bindPersonWithOptions(request: BindPersonRequest, runtime: Util.RuntimeOptions): BindPersonResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.personMatchingRate)) {
    body['PersonMatchingRate'] = request.personMatchingRate;
  }
  if (!Util.isUnset(request.profileId)) {
    body['ProfileId'] = request.profileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindPerson',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindPerson(request: BindPersonRequest): BindPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindPersonWithOptions(request, runtime);
}

model BindUserRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  matchingRate?: string(name='MatchingRate'),
  personId?: string(name='PersonId'),
  userId?: long(name='UserId'),
}

model BindUserResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model BindUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BindUserResponseBody(name='body'),
}

async function bindUserWithOptions(request: BindUserRequest, runtime: Util.RuntimeOptions): BindUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.matchingRate)) {
    body['MatchingRate'] = request.matchingRate;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BindUser',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function bindUser(request: BindUserRequest): BindUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return bindUserWithOptions(request, runtime);
}

model CheckAIInstanceNameRequest {
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  projectId?: string(name='ProjectId'),
}

model CheckAIInstanceNameResponseBody = {
  code?: string(name='Code'),
  data?: {
    available?: boolean(name='Available'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CheckAIInstanceNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckAIInstanceNameResponseBody(name='body'),
}

async function checkAIInstanceNameWithOptions(request: CheckAIInstanceNameRequest, runtime: Util.RuntimeOptions): CheckAIInstanceNameResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckAIInstanceName',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkAIInstanceName(request: CheckAIInstanceNameRequest): CheckAIInstanceNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAIInstanceNameWithOptions(request, runtime);
}

model ControlAiotDeviceRequest {
  associatedDeviceId?: string(name='AssociatedDeviceId'),
  associatedIPAddr?: string(name='AssociatedIPAddr'),
  associatedPort?: long(name='AssociatedPort'),
  associatedVerificationEnable?: string(name='AssociatedVerificationEnable'),
  barrierCommand?: long(name='BarrierCommand'),
  checkEnabled?: string(name='CheckEnabled'),
  commandType?: long(name='CommandType'),
  doubleVerificationGroupEnabled?: string(name='DoubleVerificationGroupEnabled'),
  gateCtlStatus?: long(name='GateCtlStatus'),
  id?: string(name='Id'),
  identityNumber?: string(name='IdentityNumber'),
  isProxy?: boolean(name='IsProxy'),
  miFareCard?: {
    areaCode?: long(name='AreaCode'),
    areaDeviate?: long(name='AreaDeviate'),
    areaLen?: long(name='AreaLen'),
    enabled?: string(name='Enabled'),
    keyType?: long(name='KeyType'),
    lastChange?: string(name='LastChange'),
    secretKey?: string(name='SecretKey'),
  }(name='MiFareCard'),
  name?: string(name='Name'),
  rebootDevice?: string(name='RebootDevice'),
  singleInterval?: long(name='SingleInterval'),
  superPassword?: string(name='SuperPassword'),
  upgradeFileURL?: string(name='UpgradeFileURL'),
}

model ControlAiotDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ControlAiotDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ControlAiotDeviceResponseBody(name='body'),
}

async function controlAiotDeviceWithOptions(request: ControlAiotDeviceRequest, runtime: Util.RuntimeOptions): ControlAiotDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.associatedDeviceId)) {
    body['AssociatedDeviceId'] = request.associatedDeviceId;
  }
  if (!Util.isUnset(request.associatedIPAddr)) {
    body['AssociatedIPAddr'] = request.associatedIPAddr;
  }
  if (!Util.isUnset(request.associatedPort)) {
    body['AssociatedPort'] = request.associatedPort;
  }
  if (!Util.isUnset(request.associatedVerificationEnable)) {
    body['AssociatedVerificationEnable'] = request.associatedVerificationEnable;
  }
  if (!Util.isUnset(request.barrierCommand)) {
    body['BarrierCommand'] = request.barrierCommand;
  }
  if (!Util.isUnset(request.checkEnabled)) {
    body['CheckEnabled'] = request.checkEnabled;
  }
  if (!Util.isUnset(request.commandType)) {
    body['CommandType'] = request.commandType;
  }
  if (!Util.isUnset(request.doubleVerificationGroupEnabled)) {
    body['DoubleVerificationGroupEnabled'] = request.doubleVerificationGroupEnabled;
  }
  if (!Util.isUnset(request.gateCtlStatus)) {
    body['GateCtlStatus'] = request.gateCtlStatus;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.identityNumber)) {
    body['IdentityNumber'] = request.identityNumber;
  }
  if (!Util.isUnset(request.isProxy)) {
    body['IsProxy'] = request.isProxy;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.miFareCard)) {
    bodyFlat['MiFareCard'] = request.miFareCard;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.rebootDevice)) {
    body['RebootDevice'] = request.rebootDevice;
  }
  if (!Util.isUnset(request.singleInterval)) {
    body['SingleInterval'] = request.singleInterval;
  }
  if (!Util.isUnset(request.superPassword)) {
    body['SuperPassword'] = request.superPassword;
  }
  if (!Util.isUnset(request.upgradeFileURL)) {
    body['UpgradeFileURL'] = request.upgradeFileURL;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ControlAiotDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function controlAiotDevice(request: ControlAiotDeviceRequest): ControlAiotDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return controlAiotDeviceWithOptions(request, runtime);
}

model CreateAIInstanceRequest {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  computeType?: string(name='ComputeType'),
  containerType?: string(name='ContainerType'),
  dataSource?: string(name='DataSource'),
  dataSourceTimes?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
    }
  ](name='DataSourceTimes'),
  dataType?: string(name='DataType'),
  fps?: long(name='Fps'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  projectId?: string(name='ProjectId'),
  scheduleCycleDates?: [ long ](name='ScheduleCycleDates'),
  scheduleTimes?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
    }
  ](name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  spf?: long(name='Spf'),
}

model CreateAIInstanceShrinkRequest {
  algorithmId?: string(name='AlgorithmId'),
  algorithmName?: string(name='AlgorithmName'),
  computeType?: string(name='ComputeType'),
  containerType?: string(name='ContainerType'),
  dataSource?: string(name='DataSource'),
  dataSourceTimesShrink?: string(name='DataSourceTimes'),
  dataType?: string(name='DataType'),
  fps?: long(name='Fps'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  projectId?: string(name='ProjectId'),
  scheduleCycleDatesShrink?: string(name='ScheduleCycleDates'),
  scheduleTimesShrink?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  spf?: long(name='Spf'),
}

model CreateAIInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    acuUsed?: long(name='AcuUsed'),
    instanceId?: double(name='InstanceId'),
    storage?: string(name='Storage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateAIInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAIInstanceResponseBody(name='body'),
}

async function createAIInstanceWithOptions(tmpReq: CreateAIInstanceRequest, runtime: Util.RuntimeOptions): CreateAIInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateAIInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceTimes)) {
    request.dataSourceTimesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceTimes, 'DataSourceTimes', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleCycleDates)) {
    request.scheduleCycleDatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleCycleDates, 'ScheduleCycleDates', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleTimes)) {
    request.scheduleTimesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleTimes, 'ScheduleTimes', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    body['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.algorithmName)) {
    body['AlgorithmName'] = request.algorithmName;
  }
  if (!Util.isUnset(request.computeType)) {
    body['ComputeType'] = request.computeType;
  }
  if (!Util.isUnset(request.containerType)) {
    body['ContainerType'] = request.containerType;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['DataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataSourceTimesShrink)) {
    body['DataSourceTimes'] = request.dataSourceTimesShrink;
  }
  if (!Util.isUnset(request.dataType)) {
    body['DataType'] = request.dataType;
  }
  if (!Util.isUnset(request.fps)) {
    body['Fps'] = request.fps;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scheduleCycleDatesShrink)) {
    body['ScheduleCycleDates'] = request.scheduleCycleDatesShrink;
  }
  if (!Util.isUnset(request.scheduleTimesShrink)) {
    body['ScheduleTimes'] = request.scheduleTimesShrink;
  }
  if (!Util.isUnset(request.scheduleType)) {
    body['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.spf)) {
    body['Spf'] = request.spf;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAIInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAIInstance(request: CreateAIInstanceRequest): CreateAIInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAIInstanceWithOptions(request, runtime);
}

model CreateComputeInstanceRequest {
  acuUsed?: long(name='AcuUsed'),
  algorithmType?: string(name='AlgorithmType'),
  algorithms?: [ 
    {
      algorithmId?: string(name='AlgorithmId'),
      algorithmName?: string(name='AlgorithmName'),
    }
  ](name='Algorithms'),
  computePictureType?: string(name='ComputePictureType'),
  computePictureValue?: string(name='ComputePictureValue'),
  datasourceType?: string(name='DatasourceType'),
  devices?: [ 
    {
      bitRate?: string(name='BitRate'),
      codingFormat?: string(name='CodingFormat'),
      deviceId?: string(name='DeviceId'),
      regionId?: string(name='RegionId'),
      resolvingPower?: string(name='ResolvingPower'),
      startStream?: boolean(name='StartStream'),
    }
  ](name='Devices'),
  instanceName?: string(name='InstanceName'),
  isFrameExtraction?: string(name='IsFrameExtraction'),
  isPolling?: boolean(name='IsPolling'),
  overallExecutionTime?: string(name='OverallExecutionTime'),
  picTopic?: string(name='PicTopic'),
  picType?: string(name='PicType'),
  pollingConfigs?: string(name='PollingConfigs'),
  projectId?: string(name='ProjectId'),
  scheduleCycleDate?: string(name='ScheduleCycleDate'),
  scheduleDay?: string(name='ScheduleDay'),
  scheduleDaySize?: string(name='ScheduleDaySize'),
  scheduleTimes?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  sliceExecutionTime?: string(name='SliceExecutionTime'),
  storageUsed?: string(name='StorageUsed'),
}

model CreateComputeInstanceShrinkRequest {
  acuUsed?: long(name='AcuUsed'),
  algorithmType?: string(name='AlgorithmType'),
  algorithmsShrink?: string(name='Algorithms'),
  computePictureType?: string(name='ComputePictureType'),
  computePictureValue?: string(name='ComputePictureValue'),
  datasourceType?: string(name='DatasourceType'),
  devicesShrink?: string(name='Devices'),
  instanceName?: string(name='InstanceName'),
  isFrameExtraction?: string(name='IsFrameExtraction'),
  isPolling?: boolean(name='IsPolling'),
  overallExecutionTime?: string(name='OverallExecutionTime'),
  picTopic?: string(name='PicTopic'),
  picType?: string(name='PicType'),
  pollingConfigs?: string(name='PollingConfigs'),
  projectId?: string(name='ProjectId'),
  scheduleCycleDate?: string(name='ScheduleCycleDate'),
  scheduleDay?: string(name='ScheduleDay'),
  scheduleDaySize?: string(name='ScheduleDaySize'),
  scheduleTimes?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  sliceExecutionTime?: string(name='SliceExecutionTime'),
  storageUsed?: string(name='StorageUsed'),
}

model CreateComputeInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    acuUsed?: long(name='AcuUsed'),
    instanceId?: string(name='InstanceId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateComputeInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateComputeInstanceResponseBody(name='body'),
}

async function createComputeInstanceWithOptions(tmpReq: CreateComputeInstanceRequest, runtime: Util.RuntimeOptions): CreateComputeInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateComputeInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.algorithms)) {
    request.algorithmsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.algorithms, 'Algorithms', 'json');
  }
  if (!Util.isUnset(tmpReq.devices)) {
    request.devicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.devices, 'Devices', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.acuUsed)) {
    body['AcuUsed'] = request.acuUsed;
  }
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.algorithmsShrink)) {
    body['Algorithms'] = request.algorithmsShrink;
  }
  if (!Util.isUnset(request.computePictureType)) {
    body['ComputePictureType'] = request.computePictureType;
  }
  if (!Util.isUnset(request.computePictureValue)) {
    body['ComputePictureValue'] = request.computePictureValue;
  }
  if (!Util.isUnset(request.datasourceType)) {
    body['DatasourceType'] = request.datasourceType;
  }
  if (!Util.isUnset(request.devicesShrink)) {
    body['Devices'] = request.devicesShrink;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.isFrameExtraction)) {
    body['IsFrameExtraction'] = request.isFrameExtraction;
  }
  if (!Util.isUnset(request.isPolling)) {
    body['IsPolling'] = request.isPolling;
  }
  if (!Util.isUnset(request.overallExecutionTime)) {
    body['OverallExecutionTime'] = request.overallExecutionTime;
  }
  if (!Util.isUnset(request.picTopic)) {
    body['PicTopic'] = request.picTopic;
  }
  if (!Util.isUnset(request.picType)) {
    body['PicType'] = request.picType;
  }
  if (!Util.isUnset(request.pollingConfigs)) {
    body['PollingConfigs'] = request.pollingConfigs;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  if (!Util.isUnset(request.scheduleCycleDate)) {
    body['ScheduleCycleDate'] = request.scheduleCycleDate;
  }
  if (!Util.isUnset(request.scheduleDay)) {
    body['ScheduleDay'] = request.scheduleDay;
  }
  if (!Util.isUnset(request.scheduleDaySize)) {
    body['ScheduleDaySize'] = request.scheduleDaySize;
  }
  if (!Util.isUnset(request.scheduleTimes)) {
    body['ScheduleTimes'] = request.scheduleTimes;
  }
  if (!Util.isUnset(request.scheduleType)) {
    body['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.sliceExecutionTime)) {
    body['SliceExecutionTime'] = request.sliceExecutionTime;
  }
  if (!Util.isUnset(request.storageUsed)) {
    body['StorageUsed'] = request.storageUsed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateComputeInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createComputeInstance(request: CreateComputeInstanceRequest): CreateComputeInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createComputeInstanceWithOptions(request, runtime);
}

model CreateCorpRequest {
  algorithmType?: string(name='AlgorithmType'),
  appName?: string(name='AppName'),
  corpName?: string(name='CorpName'),
  description?: string(name='Description'),
  iconPath?: string(name='IconPath'),
  isvSubId?: string(name='IsvSubId'),
  parentCorpId?: string(name='ParentCorpId'),
}

model CreateCorpResponseBody = {
  code?: string(name='Code'),
  corpId?: string(name='CorpId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateCorpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCorpResponseBody(name='body'),
}

async function createCorpWithOptions(request: CreateCorpRequest, runtime: Util.RuntimeOptions): CreateCorpResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.corpName)) {
    body['CorpName'] = request.corpName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.iconPath)) {
    body['IconPath'] = request.iconPath;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.parentCorpId)) {
    body['ParentCorpId'] = request.parentCorpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCorp',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCorp(request: CreateCorpRequest): CreateCorpResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCorpWithOptions(request, runtime);
}

model CreateCorpGroupRequest {
  clientToken?: string(name='ClientToken'),
  corpId?: string(name='CorpId'),
  groupId?: string(name='GroupId'),
}

model CreateCorpGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateCorpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCorpGroupResponseBody(name='body'),
}

async function createCorpGroupWithOptions(request: CreateCorpGroupRequest, runtime: Util.RuntimeOptions): CreateCorpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateCorpGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCorpGroup(request: CreateCorpGroupRequest): CreateCorpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCorpGroupWithOptions(request, runtime);
}

model CreateDeviceRequest {
  activateCode?: string(name='ActivateCode'),
  audioEnable?: string(name='AudioEnable'),
  cityCode?: string(name='CityCode'),
  corpId?: string(name='CorpId'),
  dataSourceType?: string(name='DataSourceType'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceDirection?: string(name='DeviceDirection'),
  deviceId?: string(name='DeviceId'),
  deviceModel?: string(name='DeviceModel'),
  deviceName?: string(name='DeviceName'),
  deviceRate?: string(name='DeviceRate'),
  deviceResolution?: string(name='DeviceResolution'),
  deviceSite?: string(name='DeviceSite'),
  deviceSn?: string(name='DeviceSn'),
  deviceType?: string(name='DeviceType'),
  encodeFormat?: string(name='EncodeFormat'),
  frameRate?: string(name='FrameRate'),
  govLength?: string(name='GovLength'),
  inProtocol?: string(name='InProtocol'),
  latitude?: string(name='Latitude'),
  longitude?: string(name='Longitude'),
  OSDTimeEnable?: string(name='OSDTimeEnable'),
  OSDTimeType?: string(name='OSDTimeType'),
  OSDTimeX?: string(name='OSDTimeX'),
  OSDTimeY?: string(name='OSDTimeY'),
  parentDeviceId?: string(name='ParentDeviceId'),
  subDeviceCount?: long(name='SubDeviceCount'),
  subDeviceIdList?: string(name='SubDeviceIdList'),
  vendor?: string(name='Vendor'),
}

model CreateDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceId?: string(name='DeviceId'),
    password?: string(name='Password'),
    serverId?: string(name='ServerId'),
    serverIp?: string(name='ServerIp'),
    serverPort?: string(name='ServerPort'),
    serverRealm?: string(name='ServerRealm'),
    subDeviceInfo?: [ 
      {
        subDeviceId?: string(name='SubDeviceId'),
      }
    ](name='SubDeviceInfo'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceResponseBody(name='body'),
}

async function createDeviceWithOptions(request: CreateDeviceRequest, runtime: Util.RuntimeOptions): CreateDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.activateCode)) {
    body['ActivateCode'] = request.activateCode;
  }
  if (!Util.isUnset(request.audioEnable)) {
    body['AudioEnable'] = request.audioEnable;
  }
  if (!Util.isUnset(request.cityCode)) {
    body['CityCode'] = request.cityCode;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceDirection)) {
    body['DeviceDirection'] = request.deviceDirection;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceModel)) {
    body['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceRate)) {
    body['DeviceRate'] = request.deviceRate;
  }
  if (!Util.isUnset(request.deviceResolution)) {
    body['DeviceResolution'] = request.deviceResolution;
  }
  if (!Util.isUnset(request.deviceSite)) {
    body['DeviceSite'] = request.deviceSite;
  }
  if (!Util.isUnset(request.deviceSn)) {
    body['DeviceSn'] = request.deviceSn;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.encodeFormat)) {
    body['EncodeFormat'] = request.encodeFormat;
  }
  if (!Util.isUnset(request.frameRate)) {
    body['FrameRate'] = request.frameRate;
  }
  if (!Util.isUnset(request.govLength)) {
    body['GovLength'] = request.govLength;
  }
  if (!Util.isUnset(request.inProtocol)) {
    body['InProtocol'] = request.inProtocol;
  }
  if (!Util.isUnset(request.latitude)) {
    body['Latitude'] = request.latitude;
  }
  if (!Util.isUnset(request.longitude)) {
    body['Longitude'] = request.longitude;
  }
  if (!Util.isUnset(request.OSDTimeEnable)) {
    body['OSDTimeEnable'] = request.OSDTimeEnable;
  }
  if (!Util.isUnset(request.OSDTimeType)) {
    body['OSDTimeType'] = request.OSDTimeType;
  }
  if (!Util.isUnset(request.OSDTimeX)) {
    body['OSDTimeX'] = request.OSDTimeX;
  }
  if (!Util.isUnset(request.OSDTimeY)) {
    body['OSDTimeY'] = request.OSDTimeY;
  }
  if (!Util.isUnset(request.parentDeviceId)) {
    body['ParentDeviceId'] = request.parentDeviceId;
  }
  if (!Util.isUnset(request.subDeviceCount)) {
    body['SubDeviceCount'] = request.subDeviceCount;
  }
  if (!Util.isUnset(request.subDeviceIdList)) {
    body['SubDeviceIdList'] = request.subDeviceIdList;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevice(request: CreateDeviceRequest): CreateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceWithOptions(request, runtime);
}

model CreateModelServiceRequest {
  algorithmCode?: string(name='AlgorithmCode'),
  clientToken?: string(name='ClientToken'),
  instanceName?: string(name='InstanceName'),
  QPSRequired?: int32(name='QPSRequired'),
}

model CreateModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    appCode?: string(name='AppCode'),
    modelApiList?: [ 
      {
        algorithmApiCode?: string(name='AlgorithmApiCode'),
        apiId?: string(name='ApiId'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        createTime?: string(name='CreateTime'),
      }
    ](name='ModelApiList'),
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
    qpsRequired?: int32(name='QpsRequired'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateModelServiceResponseBody(name='body'),
}

async function createModelServiceWithOptions(request: CreateModelServiceRequest, runtime: Util.RuntimeOptions): CreateModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmCode)) {
    body['AlgorithmCode'] = request.algorithmCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.QPSRequired)) {
    body['QPSRequired'] = request.QPSRequired;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createModelService(request: CreateModelServiceRequest): CreateModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createModelServiceWithOptions(request, runtime);
}

model CreateNewDeviceRequest {
  cityCode?: string(name='CityCode'),
  corpId?: string(name='CorpId'),
  dataSourceType?: string(name='DataSourceType'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceId?: string(name='DeviceId'),
  deviceModel?: string(name='DeviceModel'),
  deviceName?: string(name='DeviceName'),
  deviceType?: string(name='DeviceType'),
  filePath?: string(name='FilePath'),
  inProtocol?: string(name='InProtocol'),
  latitude?: string(name='Latitude'),
  longitude?: string(name='Longitude'),
  subDeviceCount?: long(name='SubDeviceCount'),
  vendor?: string(name='Vendor'),
}

model CreateNewDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceId?: string(name='DeviceId'),
    password?: string(name='Password'),
    serverId?: string(name='ServerId'),
    serverIp?: string(name='ServerIp'),
    serverPort?: string(name='ServerPort'),
    sipRealm?: string(name='SipRealm'),
    subDeviceInfo?: [ 
      {
        channelDeviceId?: string(name='ChannelDeviceId'),
      }
    ](name='SubDeviceInfo'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateNewDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNewDeviceResponseBody(name='body'),
}

async function createNewDeviceWithOptions(request: CreateNewDeviceRequest, runtime: Util.RuntimeOptions): CreateNewDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.cityCode)) {
    body['CityCode'] = request.cityCode;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceModel)) {
    body['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.inProtocol)) {
    body['InProtocol'] = request.inProtocol;
  }
  if (!Util.isUnset(request.latitude)) {
    body['Latitude'] = request.latitude;
  }
  if (!Util.isUnset(request.longitude)) {
    body['Longitude'] = request.longitude;
  }
  if (!Util.isUnset(request.subDeviceCount)) {
    body['SubDeviceCount'] = request.subDeviceCount;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateNewDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNewDevice(request: CreateNewDeviceRequest): CreateNewDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNewDeviceWithOptions(request, runtime);
}

model CreateScanDeviceRequest {
  audioEnable?: string(name='AudioEnable'),
  cityCode?: string(name='CityCode'),
  corpId?: string(name='CorpId'),
  dataSourceType?: string(name='DataSourceType'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceDirection?: string(name='DeviceDirection'),
  deviceId?: string(name='DeviceId'),
  deviceModel?: string(name='DeviceModel'),
  deviceName?: string(name='DeviceName'),
  deviceRate?: string(name='DeviceRate'),
  deviceResolution?: string(name='DeviceResolution'),
  deviceSite?: string(name='DeviceSite'),
  deviceSn?: string(name='DeviceSn'),
  deviceType?: string(name='DeviceType'),
  encodeFormat?: string(name='EncodeFormat'),
  frameRate?: string(name='FrameRate'),
  govLength?: string(name='GovLength'),
  inProtocol?: string(name='InProtocol'),
  latitude?: string(name='Latitude'),
  longitude?: string(name='Longitude'),
  OSDTimeEnable?: string(name='OSDTimeEnable'),
  OSDTimeType?: string(name='OSDTimeType'),
  OSDTimeX?: string(name='OSDTimeX'),
  OSDTimeY?: string(name='OSDTimeY'),
  subDeviceCount?: long(name='SubDeviceCount'),
  vendor?: string(name='Vendor'),
}

model CreateScanDeviceResponseBody = {
  code?: string(name='Code'),
  data?: {
    corpId?: string(name='CorpId'),
    deviceId?: string(name='DeviceId'),
    deviceSn?: string(name='DeviceSn'),
    password?: string(name='Password'),
    serverId?: string(name='ServerId'),
    serverIp?: string(name='ServerIp'),
    serverPort?: string(name='ServerPort'),
    serverRealm?: string(name='ServerRealm'),
    sipDeviceGbId?: string(name='SipDeviceGbId'),
    subDeviceInfo?: [ 
      {
        channelDeviceId?: string(name='ChannelDeviceId'),
      }
    ](name='SubDeviceInfo'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateScanDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateScanDeviceResponseBody(name='body'),
}

async function createScanDeviceWithOptions(request: CreateScanDeviceRequest, runtime: Util.RuntimeOptions): CreateScanDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioEnable)) {
    body['AudioEnable'] = request.audioEnable;
  }
  if (!Util.isUnset(request.cityCode)) {
    body['CityCode'] = request.cityCode;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceDirection)) {
    body['DeviceDirection'] = request.deviceDirection;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceModel)) {
    body['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceRate)) {
    body['DeviceRate'] = request.deviceRate;
  }
  if (!Util.isUnset(request.deviceResolution)) {
    body['DeviceResolution'] = request.deviceResolution;
  }
  if (!Util.isUnset(request.deviceSite)) {
    body['DeviceSite'] = request.deviceSite;
  }
  if (!Util.isUnset(request.deviceSn)) {
    body['DeviceSn'] = request.deviceSn;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.encodeFormat)) {
    body['EncodeFormat'] = request.encodeFormat;
  }
  if (!Util.isUnset(request.frameRate)) {
    body['FrameRate'] = request.frameRate;
  }
  if (!Util.isUnset(request.govLength)) {
    body['GovLength'] = request.govLength;
  }
  if (!Util.isUnset(request.inProtocol)) {
    body['InProtocol'] = request.inProtocol;
  }
  if (!Util.isUnset(request.latitude)) {
    body['Latitude'] = request.latitude;
  }
  if (!Util.isUnset(request.longitude)) {
    body['Longitude'] = request.longitude;
  }
  if (!Util.isUnset(request.OSDTimeEnable)) {
    body['OSDTimeEnable'] = request.OSDTimeEnable;
  }
  if (!Util.isUnset(request.OSDTimeType)) {
    body['OSDTimeType'] = request.OSDTimeType;
  }
  if (!Util.isUnset(request.OSDTimeX)) {
    body['OSDTimeX'] = request.OSDTimeX;
  }
  if (!Util.isUnset(request.OSDTimeY)) {
    body['OSDTimeY'] = request.OSDTimeY;
  }
  if (!Util.isUnset(request.subDeviceCount)) {
    body['SubDeviceCount'] = request.subDeviceCount;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateScanDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createScanDevice(request: CreateScanDeviceRequest): CreateScanDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createScanDeviceWithOptions(request, runtime);
}

model CreateSearchTableRequest {
  algorithmId?: string(name='AlgorithmId'),
  searchTableName?: string(name='SearchTableName'),
  targetType?: string(name='TargetType'),
}

model CreateSearchTableResponseBody = {
  code?: string(name='Code'),
  data?: {
    searchTableId?: string(name='SearchTableId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateSearchTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSearchTableResponseBody(name='body'),
}

async function createSearchTableWithOptions(request: CreateSearchTableRequest, runtime: Util.RuntimeOptions): CreateSearchTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    body['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.searchTableName)) {
    body['SearchTableName'] = request.searchTableName;
  }
  if (!Util.isUnset(request.targetType)) {
    body['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSearchTable',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSearchTable(request: CreateSearchTableRequest): CreateSearchTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSearchTableWithOptions(request, runtime);
}

model CreateUserRequest {
  address?: string(name='Address'),
  age?: int32(name='Age'),
  attachment?: string(name='Attachment'),
  bizId?: string(name='BizId'),
  corpId?: string(name='CorpId'),
  faceImageUrl?: string(name='FaceImageUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  userGroupId?: long(name='UserGroupId'),
  userName?: string(name='UserName'),
}

model CreateUserResponseBody = {
  code?: string(name='Code'),
  data?: {
    address?: string(name='Address'),
    age?: string(name='Age'),
    attachment?: string(name='Attachment'),
    bizId?: string(name='BizId'),
    faceImageUrl?: string(name='FaceImageUrl'),
    gender?: string(name='Gender'),
    idNumber?: string(name='IdNumber'),
    isvSubId?: string(name='IsvSubId'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    userGroupId?: int32(name='UserGroupId'),
    userId?: int32(name='UserId'),
    userName?: string(name='UserName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserResponseBody(name='body'),
}

async function createUserWithOptions(request: CreateUserRequest, runtime: Util.RuntimeOptions): CreateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.age)) {
    body['Age'] = request.age;
  }
  if (!Util.isUnset(request.attachment)) {
    body['Attachment'] = request.attachment;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceImageUrl)) {
    body['FaceImageUrl'] = request.faceImageUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.userGroupId)) {
    body['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUser',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUser(request: CreateUserRequest): CreateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserWithOptions(request, runtime);
}

model CreateUserGroupRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  parentUserGroupId?: long(name='ParentUserGroupId'),
  userGroupName?: string(name='UserGroupName'),
}

model CreateUserGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    isvSubId?: string(name='IsvSubId'),
    userGroupId?: long(name='UserGroupId'),
    userGroupName?: string(name='UserGroupName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUserGroupResponseBody(name='body'),
}

async function createUserGroupWithOptions(request: CreateUserGroupRequest, runtime: Util.RuntimeOptions): CreateUserGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.parentUserGroupId)) {
    body['ParentUserGroupId'] = request.parentUserGroupId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    body['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateUserGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUserGroup(request: CreateUserGroupRequest): CreateUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUserGroupWithOptions(request, runtime);
}

model CreateVideoComposeTaskRequest {
  audioFileName?: string(name='AudioFileName'),
  bucketName?: string(name='BucketName'),
  corpId?: string(name='CorpId'),
  domainName?: string(name='DomainName'),
  imageFileNames?: string(name='ImageFileNames'),
  imageParameters?: string(name='ImageParameters'),
  videoFormat?: string(name='VideoFormat'),
  videoFrameRate?: int32(name='VideoFrameRate'),
}

model CreateVideoComposeTaskResponseBody = {
  bucketName?: string(name='BucketName'),
  code?: string(name='Code'),
  domainName?: string(name='DomainName'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateVideoComposeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVideoComposeTaskResponseBody(name='body'),
}

async function createVideoComposeTaskWithOptions(request: CreateVideoComposeTaskRequest, runtime: Util.RuntimeOptions): CreateVideoComposeTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioFileName)) {
    body['AudioFileName'] = request.audioFileName;
  }
  if (!Util.isUnset(request.bucketName)) {
    body['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.domainName)) {
    body['DomainName'] = request.domainName;
  }
  if (!Util.isUnset(request.imageFileNames)) {
    body['ImageFileNames'] = request.imageFileNames;
  }
  if (!Util.isUnset(request.imageParameters)) {
    body['ImageParameters'] = request.imageParameters;
  }
  if (!Util.isUnset(request.videoFormat)) {
    body['VideoFormat'] = request.videoFormat;
  }
  if (!Util.isUnset(request.videoFrameRate)) {
    body['VideoFrameRate'] = request.videoFrameRate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoComposeTask',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoComposeTask(request: CreateVideoComposeTaskRequest): CreateVideoComposeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoComposeTaskWithOptions(request, runtime);
}

model CreateVideoSummaryTaskRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  liveVideoSummary?: string(name='LiveVideoSummary'),
  optionList?: string(name='OptionList'),
  startTimeStamp?: long(name='StartTimeStamp'),
}

model CreateVideoSummaryTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model CreateVideoSummaryTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVideoSummaryTaskResponseBody(name='body'),
}

async function createVideoSummaryTaskWithOptions(request: CreateVideoSummaryTaskRequest, runtime: Util.RuntimeOptions): CreateVideoSummaryTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    body['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.liveVideoSummary)) {
    body['LiveVideoSummary'] = request.liveVideoSummary;
  }
  if (!Util.isUnset(request.optionList)) {
    body['OptionList'] = request.optionList;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    body['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateVideoSummaryTask',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVideoSummaryTask(request: CreateVideoSummaryTaskRequest): CreateVideoSummaryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVideoSummaryTaskWithOptions(request, runtime);
}

model CreateWatchPolicyRequest {
  itemMatchType?: string(name='ItemMatchType'),
  similarityThreshold?: double(name='SimilarityThreshold'),
  targetType?: string(name='TargetType'),
  watchMode?: string(name='WatchMode'),
  watchPolicyName?: string(name='WatchPolicyName'),
}

model CreateWatchPolicyResponseBody = {
  code?: string(name='Code'),
  data?: {
    watchPolicyId?: string(name='WatchPolicyId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateWatchPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWatchPolicyResponseBody(name='body'),
}

async function createWatchPolicyWithOptions(request: CreateWatchPolicyRequest, runtime: Util.RuntimeOptions): CreateWatchPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.itemMatchType)) {
    body['ItemMatchType'] = request.itemMatchType;
  }
  if (!Util.isUnset(request.similarityThreshold)) {
    body['SimilarityThreshold'] = request.similarityThreshold;
  }
  if (!Util.isUnset(request.targetType)) {
    body['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.watchMode)) {
    body['WatchMode'] = request.watchMode;
  }
  if (!Util.isUnset(request.watchPolicyName)) {
    body['WatchPolicyName'] = request.watchPolicyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWatchPolicy',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWatchPolicy(request: CreateWatchPolicyRequest): CreateWatchPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWatchPolicyWithOptions(request, runtime);
}

model CreateWatchTaskRequest {
  corpId?: string(name='CorpId'),
  description?: string(name='Description'),
  deviceList?: string(name='DeviceList'),
  messageReceiver?: string(name='MessageReceiver'),
  scheduleCycleDates?: string(name='ScheduleCycleDates'),
  scheduleTimes?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  taskName?: string(name='TaskName'),
  watchPolicyIds?: string(name='WatchPolicyIds'),
}

model CreateWatchTaskResponseBody = {
  code?: string(name='Code'),
  data?: {
    watchTaskId?: string(name='WatchTaskId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateWatchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWatchTaskResponseBody(name='body'),
}

async function createWatchTaskWithOptions(request: CreateWatchTaskRequest, runtime: Util.RuntimeOptions): CreateWatchTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.messageReceiver)) {
    body['MessageReceiver'] = request.messageReceiver;
  }
  if (!Util.isUnset(request.scheduleCycleDates)) {
    body['ScheduleCycleDates'] = request.scheduleCycleDates;
  }
  if (!Util.isUnset(request.scheduleTimes)) {
    body['ScheduleTimes'] = request.scheduleTimes;
  }
  if (!Util.isUnset(request.scheduleType)) {
    body['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.watchPolicyIds)) {
    body['WatchPolicyIds'] = request.watchPolicyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWatchTask',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWatchTask(request: CreateWatchTaskRequest): CreateWatchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWatchTaskWithOptions(request, runtime);
}

model DeleteAIInstanceRequest {
  instanceIds?: [ string ](name='InstanceIds'),
}

model DeleteAIInstanceShrinkRequest {
  instanceIdsShrink?: string(name='InstanceIds'),
}

model DeleteAIInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAIInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAIInstanceResponseBody(name='body'),
}

async function deleteAIInstanceWithOptions(tmpReq: DeleteAIInstanceRequest, runtime: Util.RuntimeOptions): DeleteAIInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteAIInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceIdsShrink)) {
    body['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAIInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAIInstance(request: DeleteAIInstanceRequest): DeleteAIInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAIInstanceWithOptions(request, runtime);
}

model DeleteAiotDeviceRequest {
  id?: string(name='Id'),
}

model DeleteAiotDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAiotDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAiotDeviceResponseBody(name='body'),
}

async function deleteAiotDeviceWithOptions(request: DeleteAiotDeviceRequest, runtime: Util.RuntimeOptions): DeleteAiotDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAiotDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAiotDevice(request: DeleteAiotDeviceRequest): DeleteAiotDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAiotDeviceWithOptions(request, runtime);
}

model DeleteAiotPersonTableRequest {
  id?: string(name='Id'),
  personTableId?: string(name='PersonTableId'),
}

model DeleteAiotPersonTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAiotPersonTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAiotPersonTableResponseBody(name='body'),
}

async function deleteAiotPersonTableWithOptions(request: DeleteAiotPersonTableRequest, runtime: Util.RuntimeOptions): DeleteAiotPersonTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.personTableId)) {
    body['PersonTableId'] = request.personTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAiotPersonTable',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAiotPersonTable(request: DeleteAiotPersonTableRequest): DeleteAiotPersonTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAiotPersonTableWithOptions(request, runtime);
}

model DeleteAiotPersonTableItemRequest {
  id?: string(name='Id'),
  personTableId?: string(name='PersonTableId'),
  personTableItemId?: string(name='PersonTableItemId'),
}

model DeleteAiotPersonTableItemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAiotPersonTableItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAiotPersonTableItemResponseBody(name='body'),
}

async function deleteAiotPersonTableItemWithOptions(request: DeleteAiotPersonTableItemRequest, runtime: Util.RuntimeOptions): DeleteAiotPersonTableItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.personTableId)) {
    body['PersonTableId'] = request.personTableId;
  }
  if (!Util.isUnset(request.personTableItemId)) {
    body['PersonTableItemId'] = request.personTableItemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAiotPersonTableItem',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAiotPersonTableItem(request: DeleteAiotPersonTableItemRequest): DeleteAiotPersonTableItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAiotPersonTableItemWithOptions(request, runtime);
}

model DeleteAiotVehicleTableItemRequest {
  id?: string(name='Id'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItemId?: string(name='VehicleTableItemId'),
}

model DeleteAiotVehicleTableItemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteAiotVehicleTableItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAiotVehicleTableItemResponseBody(name='body'),
}

async function deleteAiotVehicleTableItemWithOptions(request: DeleteAiotVehicleTableItemRequest, runtime: Util.RuntimeOptions): DeleteAiotVehicleTableItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.vehicleTableId)) {
    body['VehicleTableId'] = request.vehicleTableId;
  }
  if (!Util.isUnset(request.vehicleTableItemId)) {
    body['VehicleTableItemId'] = request.vehicleTableItemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAiotVehicleTableItem',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAiotVehicleTableItem(request: DeleteAiotVehicleTableItemRequest): DeleteAiotVehicleTableItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAiotVehicleTableItemWithOptions(request, runtime);
}

model DeleteChannelRequest {
  deviceCodes?: string(name='DeviceCodes'),
}

model DeleteChannelResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteChannelResponseBody(name='body'),
}

async function deleteChannelWithOptions(request: DeleteChannelRequest, runtime: Util.RuntimeOptions): DeleteChannelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCodes)) {
    body['DeviceCodes'] = request.deviceCodes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteChannel',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteChannel(request: DeleteChannelRequest): DeleteChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteChannelWithOptions(request, runtime);
}

model DeleteCorpGroupRequest {
  corpId?: string(name='CorpId'),
  groupId?: string(name='GroupId'),
}

model DeleteCorpGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteCorpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCorpGroupResponseBody(name='body'),
}

async function deleteCorpGroupWithOptions(request: DeleteCorpGroupRequest, runtime: Util.RuntimeOptions): DeleteCorpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCorpGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCorpGroup(request: DeleteCorpGroupRequest): DeleteCorpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCorpGroupWithOptions(request, runtime);
}

model DeleteDataSourceRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
}

model DeleteDataSourceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
}

model DeleteDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataSourceResponseBody(name='body'),
}

async function deleteDataSourceWithOptions(request: DeleteDataSourceRequest, runtime: Util.RuntimeOptions): DeleteDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSource',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataSource(request: DeleteDataSourceRequest): DeleteDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSourceWithOptions(request, runtime);
}

model DeleteDataSourcesRequest {
  dataSourceIdList?: string(name='DataSourceIdList'),
}

model DeleteDataSourcesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      code?: string(name='Code'),
      dataSourceId?: string(name='DataSourceId'),
      message?: string(name='Message'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataSourcesResponseBody(name='body'),
}

async function deleteDataSourcesWithOptions(request: DeleteDataSourcesRequest, runtime: Util.RuntimeOptions): DeleteDataSourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceIdList)) {
    body['DataSourceIdList'] = request.dataSourceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDataSources',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDataSources(request: DeleteDataSourcesRequest): DeleteDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDataSourcesWithOptions(request, runtime);
}

model DeleteDeviceRequest {
  corpId?: string(name='CorpId'),
  gbId?: string(name='GbId'),
}

model DeleteDeviceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceResponseBody(name='body'),
}

async function deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevice(request: DeleteDeviceRequest): DeleteDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceWithOptions(request, runtime);
}

model DeleteDeviceForInstanceRequest {
  algorithmId?: string(name='AlgorithmId'),
  deleteInstanceFlag?: boolean(name='DeleteInstanceFlag'),
  deviceCount?: string(name='DeviceCount'),
  devices?: [ 
    {
      deviceId?: string(name='DeviceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='Devices'),
  instanceId?: string(name='InstanceId'),
  projectId?: string(name='ProjectId'),
}

model DeleteDeviceForInstanceShrinkRequest {
  algorithmId?: string(name='AlgorithmId'),
  deleteInstanceFlag?: boolean(name='DeleteInstanceFlag'),
  deviceCount?: string(name='DeviceCount'),
  devicesShrink?: string(name='Devices'),
  instanceId?: string(name='InstanceId'),
  projectId?: string(name='ProjectId'),
}

model DeleteDeviceForInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteDeviceForInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceForInstanceResponseBody(name='body'),
}

async function deleteDeviceForInstanceWithOptions(tmpReq: DeleteDeviceForInstanceRequest, runtime: Util.RuntimeOptions): DeleteDeviceForInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteDeviceForInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.devices)) {
    request.devicesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.devices, 'Devices', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    body['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.deleteInstanceFlag)) {
    body['DeleteInstanceFlag'] = request.deleteInstanceFlag;
  }
  if (!Util.isUnset(request.deviceCount)) {
    body['DeviceCount'] = request.deviceCount;
  }
  if (!Util.isUnset(request.devicesShrink)) {
    body['Devices'] = request.devicesShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceForInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeviceForInstance(request: DeleteDeviceForInstanceRequest): DeleteDeviceForInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceForInstanceWithOptions(request, runtime);
}

model DeleteDevicesRequest {
  deviceIdList?: string(name='DeviceIdList'),
}

model DeleteDevicesResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      code?: string(name='Code'),
      description?: string(name='Description'),
      deviceId?: string(name='DeviceId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevicesResponseBody(name='body'),
}

async function deleteDevicesWithOptions(request: DeleteDevicesRequest, runtime: Util.RuntimeOptions): DeleteDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevices(request: DeleteDevicesRequest): DeleteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevicesWithOptions(request, runtime);
}

model DeleteDoubleVerificationGroupRequest {
  doubleVerificationGroupId?: string(name='DoubleVerificationGroupId'),
  id?: string(name='Id'),
}

model DeleteDoubleVerificationGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteDoubleVerificationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDoubleVerificationGroupResponseBody(name='body'),
}

async function deleteDoubleVerificationGroupWithOptions(request: DeleteDoubleVerificationGroupRequest, runtime: Util.RuntimeOptions): DeleteDoubleVerificationGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.doubleVerificationGroupId)) {
    body['DoubleVerificationGroupId'] = request.doubleVerificationGroupId;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDoubleVerificationGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDoubleVerificationGroup(request: DeleteDoubleVerificationGroupRequest): DeleteDoubleVerificationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDoubleVerificationGroupWithOptions(request, runtime);
}

model DeleteIPCDeviceRequest {
  deviceCodes?: string(name='DeviceCodes'),
}

model DeleteIPCDeviceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteIPCDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteIPCDeviceResponseBody(name='body'),
}

async function deleteIPCDeviceWithOptions(request: DeleteIPCDeviceRequest, runtime: Util.RuntimeOptions): DeleteIPCDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCodes)) {
    body['DeviceCodes'] = request.deviceCodes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteIPCDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteIPCDevice(request: DeleteIPCDeviceRequest): DeleteIPCDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteIPCDeviceWithOptions(request, runtime);
}

model DeleteModelServiceRequest {
  modelServiceId?: string(name='ModelServiceId'),
}

model DeleteModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceInstanceName?: int32(name='ModelServiceInstanceName'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteModelServiceResponseBody(name='body'),
}

async function deleteModelServiceWithOptions(request: DeleteModelServiceRequest, runtime: Util.RuntimeOptions): DeleteModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.modelServiceId)) {
    body['ModelServiceId'] = request.modelServiceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteModelService(request: DeleteModelServiceRequest): DeleteModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteModelServiceWithOptions(request, runtime);
}

model DeleteNVRDeviceRequest {
  deviceCodes?: string(name='DeviceCodes'),
}

model DeleteNVRDeviceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteNVRDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteNVRDeviceResponseBody(name='body'),
}

async function deleteNVRDeviceWithOptions(request: DeleteNVRDeviceRequest, runtime: Util.RuntimeOptions): DeleteNVRDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCodes)) {
    body['DeviceCodes'] = request.deviceCodes;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteNVRDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteNVRDevice(request: DeleteNVRDeviceRequest): DeleteNVRDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteNVRDeviceWithOptions(request, runtime);
}

model DeleteProfileRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  profileId?: long(name='ProfileId'),
}

model DeleteProfileResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProfileResponseBody(name='body'),
}

async function deleteProfileWithOptions(request: DeleteProfileRequest, runtime: Util.RuntimeOptions): DeleteProfileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.profileId)) {
    body['ProfileId'] = request.profileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProfile',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProfile(request: DeleteProfileRequest): DeleteProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProfileWithOptions(request, runtime);
}

model DeleteProfileCatalogRequest {
  catalogId?: string(name='CatalogId'),
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
}

model DeleteProfileCatalogResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteProfileCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProfileCatalogResponseBody(name='body'),
}

async function deleteProfileCatalogWithOptions(request: DeleteProfileCatalogRequest, runtime: Util.RuntimeOptions): DeleteProfileCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProfileCatalog',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProfileCatalog(request: DeleteProfileCatalogRequest): DeleteProfileCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProfileCatalogWithOptions(request, runtime);
}

model DeleteProjectRequest {
  projectIds?: string(name='ProjectIds'),
}

model DeleteProjectResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProjectResponseBody(name='body'),
}

async function deleteProjectWithOptions(request: DeleteProjectRequest, runtime: Util.RuntimeOptions): DeleteProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.projectIds)) {
    query['ProjectIds'] = request.projectIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteProject',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProject(request: DeleteProjectRequest): DeleteProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteProjectWithOptions(request, runtime);
}

model DeleteRecordsRequest {
  algorithmType?: string(name='AlgorithmType'),
  attributeName?: string(name='AttributeName'),
  corpId?: string(name='CorpId'),
  operatorType?: string(name='OperatorType'),
  value?: string(name='Value'),
}

model DeleteRecordsResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRecordsResponseBody(name='body'),
}

async function deleteRecordsWithOptions(request: DeleteRecordsRequest, runtime: Util.RuntimeOptions): DeleteRecordsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.attributeName)) {
    body['AttributeName'] = request.attributeName;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.operatorType)) {
    body['OperatorType'] = request.operatorType;
  }
  if (!Util.isUnset(request.value)) {
    body['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRecords',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRecords(request: DeleteRecordsRequest): DeleteRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRecordsWithOptions(request, runtime);
}

model DeleteSearchTablesRequest {
  searchTableIds?: string(name='SearchTableIds'),
}

model DeleteSearchTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DeleteSearchTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSearchTablesResponseBody(name='body'),
}

async function deleteSearchTablesWithOptions(request: DeleteSearchTablesRequest, runtime: Util.RuntimeOptions): DeleteSearchTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.searchTableIds)) {
    body['SearchTableIds'] = request.searchTableIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSearchTables',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSearchTables(request: DeleteSearchTablesRequest): DeleteSearchTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSearchTablesWithOptions(request, runtime);
}

model DeleteUserRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  userId?: long(name='UserId'),
}

model DeleteUserResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserResponseBody(name='body'),
}

async function deleteUserWithOptions(request: DeleteUserRequest, runtime: Util.RuntimeOptions): DeleteUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUser',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUser(request: DeleteUserRequest): DeleteUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserWithOptions(request, runtime);
}

model DeleteUserGroupRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  userGroupId?: string(name='UserGroupId'),
}

model DeleteUserGroupResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteUserGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserGroupResponseBody(name='body'),
}

async function deleteUserGroupWithOptions(request: DeleteUserGroupRequest, runtime: Util.RuntimeOptions): DeleteUserGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    body['UserGroupId'] = request.userGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserGroup(request: DeleteUserGroupRequest): DeleteUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserGroupWithOptions(request, runtime);
}

model DeleteVideoSummaryTaskRequest {
  corpId?: string(name='CorpId'),
  taskId?: string(name='TaskId'),
}

model DeleteVideoSummaryTaskResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DeleteVideoSummaryTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVideoSummaryTaskResponseBody(name='body'),
}

async function deleteVideoSummaryTaskWithOptions(request: DeleteVideoSummaryTaskRequest, runtime: Util.RuntimeOptions): DeleteVideoSummaryTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVideoSummaryTask',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVideoSummaryTask(request: DeleteVideoSummaryTaskRequest): DeleteVideoSummaryTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVideoSummaryTaskWithOptions(request, runtime);
}

model DeleteWatchPoliciesRequest {
  watchPolicyIds?: string(name='WatchPolicyIds'),
}

model DeleteWatchPoliciesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWatchPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWatchPoliciesResponseBody(name='body'),
}

async function deleteWatchPoliciesWithOptions(request: DeleteWatchPoliciesRequest, runtime: Util.RuntimeOptions): DeleteWatchPoliciesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.watchPolicyIds)) {
    body['WatchPolicyIds'] = request.watchPolicyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWatchPolicies',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWatchPolicies(request: DeleteWatchPoliciesRequest): DeleteWatchPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatchPoliciesWithOptions(request, runtime);
}

model DeleteWatchTasksRequest {
  watchTaskIds?: string(name='WatchTaskIds'),
}

model DeleteWatchTasksResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWatchTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWatchTasksResponseBody(name='body'),
}

async function deleteWatchTasksWithOptions(request: DeleteWatchTasksRequest, runtime: Util.RuntimeOptions): DeleteWatchTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.watchTaskIds)) {
    body['WatchTaskIds'] = request.watchTaskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWatchTasks',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWatchTasks(request: DeleteWatchTasksRequest): DeleteWatchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWatchTasksWithOptions(request, runtime);
}

model DescribeAIInstanceRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  instanceType?: string(name='InstanceType'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model DescribeAIInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        acuUsed?: long(name='AcuUsed'),
        algorithmId?: string(name='AlgorithmId'),
        algorithmName?: string(name='AlgorithmName'),
        cameraNumber?: long(name='CameraNumber'),
        computeType?: string(name='ComputeType'),
        containerType?: string(name='ContainerType'),
        createDateTime?: string(name='CreateDateTime'),
        dataSource?: string(name='DataSource'),
        dataSourceTimes?: string(name='DataSourceTimes'),
        dataType?: string(name='DataType'),
        fps?: long(name='Fps'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        instanceType?: string(name='InstanceType'),
        scheduleCycleDates?: string(name='ScheduleCycleDates'),
        scheduleTimes?: string(name='ScheduleTimes'),
        scheduleType?: string(name='ScheduleType'),
        spf?: long(name='Spf'),
        status?: string(name='Status'),
        storage?: double(name='Storage'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeAIInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAIInstanceResponseBody(name='body'),
}

async function describeAIInstanceWithOptions(request: DescribeAIInstanceRequest, runtime: Util.RuntimeOptions): DescribeAIInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    body['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAIInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAIInstance(request: DescribeAIInstanceRequest): DescribeAIInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAIInstanceWithOptions(request, runtime);
}

model DescribeAiotDevicesRequest {
  corpIdList?: string(name='CorpIdList'),
  idList?: string(name='IdList'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model DescribeAiotDevicesResponseBody = {
  aiotDevices?: {
    aiotDeviceList?: [ 
      {
        capDirection?: string(name='CapDirection'),
        corpId?: string(name='CorpId'),
        deviceId?: string(name='DeviceId'),
        deviceType?: string(name='DeviceType'),
        firmwareVersion?: string(name='FirmwareVersion'),
        IPAddr?: string(name='IPAddr'),
        IPV6Addr?: string(name='IPV6Addr'),
        IPv4Gateway?: string(name='IPv4Gateway'),
        IPv4Netmask?: string(name='IPv4Netmask'),
        id?: string(name='Id'),
        isOnline?: string(name='IsOnline'),
        latitude?: float(name='Latitude'),
        longitude?: float(name='Longitude'),
        MAC?: string(name='MAC'),
        manufacturer?: string(name='Manufacturer'),
        model?: string(name='Model'),
        monitorAreaDesc?: string(name='MonitorAreaDesc'),
        monitorDirection?: string(name='MonitorDirection'),
        name?: string(name='Name'),
        orgCode?: string(name='OrgCode'),
        ownerApsID?: string(name='OwnerApsID'),
        password?: string(name='Password'),
        place?: string(name='Place'),
        placeCode?: string(name='PlaceCode'),
        port?: long(name='Port'),
        serialNuber?: string(name='SerialNuber'),
        userId?: string(name='UserId'),
      }
    ](name='AiotDeviceList'),
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    totalNum?: long(name='TotalNum'),
  }(name='AiotDevices'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeAiotDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAiotDevicesResponseBody(name='body'),
}

async function describeAiotDevicesWithOptions(request: DescribeAiotDevicesRequest, runtime: Util.RuntimeOptions): DescribeAiotDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.idList)) {
    body['IdList'] = request.idList;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAiotDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAiotDevices(request: DescribeAiotDevicesRequest): DescribeAiotDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAiotDevicesWithOptions(request, runtime);
}

model DescribeAiotPersonTableItemsRequest {
  id?: string(name='Id'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  personTableId?: string(name='PersonTableId'),
  personTableItemId?: string(name='PersonTableItemId'),
}

model DescribeAiotPersonTableItemsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  personTableItems?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    personTableItemList?: [ 
      {
        identificationList?: [ 
          {
            number?: string(name='Number'),
            type?: long(name='Type'),
          }
        ](name='IdentificationList'),
        identificationNum?: long(name='IdentificationNum'),
        imageList?: [ 
          {
            data?: string(name='Data'),
            deviceId?: string(name='DeviceId'),
            eventSort?: string(name='EventSort'),
            featureInfo?: {
              algorithmType?: string(name='AlgorithmType'),
              algorithmVersion?: string(name='AlgorithmVersion'),
              featureData?: string(name='FeatureData'),
              imageId?: string(name='ImageId'),
              objectId?: string(name='ObjectId'),
              tableId?: string(name='TableId'),
              vendor?: string(name='Vendor'),
            }(name='FeatureInfo'),
            fileFormat?: string(name='FileFormat'),
            height?: long(name='Height'),
            imageId?: string(name='ImageId'),
            shotTime?: string(name='ShotTime'),
            size?: long(name='Size'),
            storagePath?: string(name='StoragePath'),
            type?: string(name='Type'),
            width?: long(name='Width'),
          }
        ](name='ImageList'),
        imageNum?: long(name='ImageNum'),
        lastChange?: string(name='LastChange'),
        personCode?: string(name='PersonCode'),
        personId?: string(name='PersonId'),
        personName?: string(name='PersonName'),
        personTableId?: string(name='PersonTableId'),
        remarks?: string(name='Remarks'),
      }
    ](name='PersonTableItemList'),
    totalNum?: long(name='TotalNum'),
  }(name='PersonTableItems'),
  requestId?: string(name='RequestId'),
}

model DescribeAiotPersonTableItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAiotPersonTableItemsResponseBody(name='body'),
}

async function describeAiotPersonTableItemsWithOptions(request: DescribeAiotPersonTableItemsRequest, runtime: Util.RuntimeOptions): DescribeAiotPersonTableItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personTableId)) {
    body['PersonTableId'] = request.personTableId;
  }
  if (!Util.isUnset(request.personTableItemId)) {
    body['PersonTableItemId'] = request.personTableItemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAiotPersonTableItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAiotPersonTableItems(request: DescribeAiotPersonTableItemsRequest): DescribeAiotPersonTableItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAiotPersonTableItemsWithOptions(request, runtime);
}

model DescribeAiotPersonTablesRequest {
  id?: string(name='Id'),
  personTableIdList?: string(name='PersonTableIdList'),
}

model DescribeAiotPersonTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  personTableList?: [ 
    {
      deviceId?: string(name='DeviceId'),
      faceNum?: long(name='FaceNum'),
      lastChange?: string(name='LastChange'),
      name?: string(name='Name'),
      personNum?: long(name='PersonNum'),
      personTableId?: string(name='PersonTableId'),
      totalPersonNum?: long(name='TotalPersonNum'),
      type?: long(name='Type'),
      verificationModelList?: [ long ](name='VerificationModelList'),
    }
  ](name='PersonTableList'),
  requestId?: string(name='RequestId'),
}

model DescribeAiotPersonTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAiotPersonTablesResponseBody(name='body'),
}

async function describeAiotPersonTablesWithOptions(request: DescribeAiotPersonTablesRequest, runtime: Util.RuntimeOptions): DescribeAiotPersonTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.personTableIdList)) {
    body['PersonTableIdList'] = request.personTableIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAiotPersonTables',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAiotPersonTables(request: DescribeAiotPersonTablesRequest): DescribeAiotPersonTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAiotPersonTablesWithOptions(request, runtime);
}

model DescribeAiotVehicleTableItemsRequest {
  id?: string(name='Id'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItemId?: string(name='VehicleTableItemId'),
}

model DescribeAiotVehicleTableItemsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  vehicleTableItems?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    totalNum?: long(name='TotalNum'),
    vehicleTableItemList?: [ 
      {
        beginTime?: string(name='BeginTime'),
        endTime?: string(name='EndTime'),
        ownerName?: string(name='OwnerName'),
        phoneNo?: string(name='PhoneNo'),
        plateNo?: string(name='PlateNo'),
        remarks?: string(name='Remarks'),
        vehicleTableId?: string(name='VehicleTableId'),
        vehicleTableItemId?: string(name='VehicleTableItemId'),
      }
    ](name='VehicleTableItemList'),
  }(name='VehicleTableItems'),
}

model DescribeAiotVehicleTableItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAiotVehicleTableItemsResponseBody(name='body'),
}

async function describeAiotVehicleTableItemsWithOptions(request: DescribeAiotVehicleTableItemsRequest, runtime: Util.RuntimeOptions): DescribeAiotVehicleTableItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.vehicleTableId)) {
    body['VehicleTableId'] = request.vehicleTableId;
  }
  if (!Util.isUnset(request.vehicleTableItemId)) {
    body['VehicleTableItemId'] = request.vehicleTableItemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAiotVehicleTableItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAiotVehicleTableItems(request: DescribeAiotVehicleTableItemsRequest): DescribeAiotVehicleTableItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAiotVehicleTableItemsWithOptions(request, runtime);
}

model DescribeAiotVehicleTablesRequest {
  id?: string(name='Id'),
  vehicleTableIdList?: string(name='VehicleTableIdList'),
}

model DescribeAiotVehicleTablesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  vehicleTableList?: [ 
    {
      vehicleTableId?: string(name='VehicleTableId'),
      vehicleTableName?: string(name='VehicleTableName'),
    }
  ](name='VehicleTableList'),
}

model DescribeAiotVehicleTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAiotVehicleTablesResponseBody(name='body'),
}

async function describeAiotVehicleTablesWithOptions(request: DescribeAiotVehicleTablesRequest, runtime: Util.RuntimeOptions): DescribeAiotVehicleTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.vehicleTableIdList)) {
    body['VehicleTableIdList'] = request.vehicleTableIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAiotVehicleTables',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAiotVehicleTables(request: DescribeAiotVehicleTablesRequest): DescribeAiotVehicleTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAiotVehicleTablesWithOptions(request, runtime);
}

model DescribeCameraForInstanceRequest {
  instanceId?: string(name='InstanceId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model DescribeCameraForInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        cameraAddress?: string(name='CameraAddress'),
        cameraId?: string(name='CameraId'),
        cameraName?: string(name='CameraName'),
        cameraStatus?: long(name='CameraStatus'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeCameraForInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCameraForInstanceResponseBody(name='body'),
}

async function describeCameraForInstanceWithOptions(request: DescribeCameraForInstanceRequest, runtime: Util.RuntimeOptions): DescribeCameraForInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCameraForInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCameraForInstance(request: DescribeCameraForInstanceRequest): DescribeCameraForInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCameraForInstanceWithOptions(request, runtime);
}

model DescribeChannelsRequest {
  deviceFilter?: string(name='DeviceFilter'),
  deviceStatus?: string(name='DeviceStatus'),
  nvrId?: string(name='NvrId'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  showUnConfig?: long(name='ShowUnConfig'),
}

model DescribeChannelsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        audioEnable?: string(name='AudioEnable'),
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        datasourceType?: string(name='DatasourceType'),
        deviceAddress?: string(name='DeviceAddress'),
        deviceDirection?: string(name='DeviceDirection'),
        deviceId?: string(name='DeviceId'),
        deviceIp?: string(name='DeviceIp'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        deviceRate?: string(name='DeviceRate'),
        deviceResolution?: string(name='DeviceResolution'),
        deviceSite?: string(name='DeviceSite'),
        deviceSn?: string(name='DeviceSn'),
        deviceStatus?: string(name='DeviceStatus'),
        deviceSubType?: string(name='DeviceSubType'),
        deviceType?: string(name='DeviceType'),
        encodeFormat?: string(name='EncodeFormat'),
        frameRate?: string(name='FrameRate'),
        govLength?: string(name='GovLength'),
        inProtocol?: string(name='InProtocol'),
        latitude?: string(name='Latitude'),
        longitude?: string(name='Longitude'),
        modifyTime?: string(name='ModifyTime'),
        OSDTimeEnable?: string(name='OSDTimeEnable'),
        OSDTimeType?: string(name='OSDTimeType'),
        OSDTimeX?: string(name='OSDTimeX'),
        OSDTimeY?: string(name='OSDTimeY'),
        parentDeviceId?: string(name='ParentDeviceId'),
        password?: string(name='Password'),
        serverId?: string(name='ServerId'),
        serverIp?: string(name='ServerIp'),
        serverPort?: string(name='ServerPort'),
        serverRealm?: string(name='ServerRealm'),
        streamAction?: string(name='StreamAction'),
        streamStatus?: string(name='StreamStatus'),
        vap?: string(name='Vap'),
        vendor?: string(name='Vendor'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
    unConfigList?: [ string ](name='UnConfigList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeChannelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeChannelsResponseBody(name='body'),
}

async function describeChannelsWithOptions(request: DescribeChannelsRequest, runtime: Util.RuntimeOptions): DescribeChannelsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceFilter)) {
    body['DeviceFilter'] = request.deviceFilter;
  }
  if (!Util.isUnset(request.deviceStatus)) {
    body['DeviceStatus'] = request.deviceStatus;
  }
  if (!Util.isUnset(request.nvrId)) {
    body['NvrId'] = request.nvrId;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.showUnConfig)) {
    body['ShowUnConfig'] = request.showUnConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeChannels',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeChannels(request: DescribeChannelsRequest): DescribeChannelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeChannelsWithOptions(request, runtime);
}

model DescribeDataSourcesRequest {
  corpIdList?: string(name='CorpIdList'),
  dataSourceCategory?: string(name='DataSourceCategory'),
  dataSourceFilter?: string(name='DataSourceFilter'),
  dataSourceIdList?: string(name='DataSourceIdList'),
  dataSourceType?: string(name='DataSourceType'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  streamStatus?: string(name='StreamStatus'),
}

model DescribeDataSourcesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        action?: string(name='Action'),
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        dataSourceId?: string(name='DataSourceId'),
        dataSourceName?: string(name='DataSourceName'),
        dataSourceType?: string(name='DataSourceType'),
        description?: string(name='Description'),
        kafkaTopic?: string(name='KafkaTopic'),
        ossPath?: string(name='OssPath'),
        streamStatus?: string(name='StreamStatus'),
        url?: string(name='Url'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeDataSourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDataSourcesResponseBody(name='body'),
}

async function describeDataSourcesWithOptions(request: DescribeDataSourcesRequest, runtime: Util.RuntimeOptions): DescribeDataSourcesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.dataSourceCategory)) {
    body['DataSourceCategory'] = request.dataSourceCategory;
  }
  if (!Util.isUnset(request.dataSourceFilter)) {
    body['DataSourceFilter'] = request.dataSourceFilter;
  }
  if (!Util.isUnset(request.dataSourceIdList)) {
    body['DataSourceIdList'] = request.dataSourceIdList;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.streamStatus)) {
    body['StreamStatus'] = request.streamStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDataSources',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDataSources(request: DescribeDataSourcesRequest): DescribeDataSourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDataSourcesWithOptions(request, runtime);
}

model DescribeDevicesRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceIdList?: string(name='DeviceIdList'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model DescribeDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        capturedPictureId?: string(name='CapturedPictureId'),
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        deviceAddress?: string(name='DeviceAddress'),
        deviceId?: string(name='DeviceId'),
        deviceName?: string(name='DeviceName'),
        deviceType?: string(name='DeviceType'),
        inProtocol?: string(name='InProtocol'),
        latitude?: string(name='Latitude'),
        longitude?: string(name='Longitude'),
        password?: string(name='Password'),
        status?: string(name='Status'),
        vendor?: string(name='Vendor'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDevicesResponseBody(name='body'),
}

async function describeDevicesWithOptions(request: DescribeDevicesRequest, runtime: Util.RuntimeOptions): DescribeDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDevices(request: DescribeDevicesRequest): DescribeDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDevicesWithOptions(request, runtime);
}

model DescribeIpcsRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceFilter?: string(name='DeviceFilter'),
  deviceIdList?: string(name='DeviceIdList'),
  deviceStatus?: string(name='DeviceStatus'),
  nvrIdList?: string(name='NvrIdList'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
  parentDeviceType?: string(name='ParentDeviceType'),
}

model DescribeIpcsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        audioEnable?: string(name='AudioEnable'),
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        datasourceType?: string(name='DatasourceType'),
        deviceAddress?: string(name='DeviceAddress'),
        deviceDirection?: string(name='DeviceDirection'),
        deviceId?: string(name='DeviceId'),
        deviceIp?: string(name='DeviceIp'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        deviceRate?: string(name='DeviceRate'),
        deviceResolution?: string(name='DeviceResolution'),
        deviceSite?: string(name='DeviceSite'),
        deviceSn?: string(name='DeviceSn'),
        deviceStatus?: string(name='DeviceStatus'),
        deviceSubType?: string(name='DeviceSubType'),
        deviceType?: string(name='DeviceType'),
        encodeFormat?: string(name='EncodeFormat'),
        frameRate?: string(name='FrameRate'),
        govLength?: string(name='GovLength'),
        inProtocol?: string(name='InProtocol'),
        latitude?: string(name='Latitude'),
        longitude?: string(name='Longitude'),
        modifyTime?: string(name='ModifyTime'),
        OSDTimeEnable?: string(name='OSDTimeEnable'),
        OSDTimeType?: string(name='OSDTimeType'),
        OSDTimeX?: string(name='OSDTimeX'),
        OSDTimeY?: string(name='OSDTimeY'),
        parentDeviceId?: string(name='ParentDeviceId'),
        password?: string(name='Password'),
        serverId?: string(name='ServerId'),
        serverIp?: string(name='ServerIp'),
        serverPort?: string(name='ServerPort'),
        serverRealm?: string(name='ServerRealm'),
        streamAction?: string(name='StreamAction'),
        streamStatus?: string(name='StreamStatus'),
        vap?: string(name='Vap'),
        vendor?: string(name='Vendor'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeIpcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeIpcsResponseBody(name='body'),
}

async function describeIpcsWithOptions(request: DescribeIpcsRequest, runtime: Util.RuntimeOptions): DescribeIpcsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceFilter)) {
    body['DeviceFilter'] = request.deviceFilter;
  }
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  if (!Util.isUnset(request.deviceStatus)) {
    body['DeviceStatus'] = request.deviceStatus;
  }
  if (!Util.isUnset(request.nvrIdList)) {
    body['NvrIdList'] = request.nvrIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parentDeviceType)) {
    body['ParentDeviceType'] = request.parentDeviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeIpcs',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeIpcs(request: DescribeIpcsRequest): DescribeIpcsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeIpcsWithOptions(request, runtime);
}

model DescribeModelServiceRequest {
  modelServiceId?: string(name='ModelServiceId'),
}

model DescribeModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    algorithmCode?: string(name='AlgorithmCode'),
    appCode?: string(name='AppCode'),
    createTime?: string(name='CreateTime'),
    modelApiList?: [ 
      {
        algorithmApiCode?: string(name='AlgorithmApiCode'),
        apiId?: string(name='ApiId'),
        apiName?: string(name='ApiName'),
        apiPath?: string(name='ApiPath'),
        createTime?: string(name='CreateTime'),
      }
    ](name='ModelApiList'),
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceInstanceName?: string(name='ModelServiceInstanceName'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
    qps?: long(name='Qps'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeModelServiceResponseBody(name='body'),
}

async function describeModelServiceWithOptions(request: DescribeModelServiceRequest, runtime: Util.RuntimeOptions): DescribeModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.modelServiceId)) {
    body['ModelServiceId'] = request.modelServiceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeModelService(request: DescribeModelServiceRequest): DescribeModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModelServiceWithOptions(request, runtime);
}

model DescribeModelServiceListRequest {
  algorithmCode?: string(name='AlgorithmCode'),
  includeDeleted?: boolean(name='IncludeDeleted'),
  modelServiceName?: string(name='ModelServiceName'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model DescribeModelServiceListResponseBody = {
  code?: string(name='Code'),
  data?: {
    modelList?: [ 
      {
        algorithmCode?: string(name='AlgorithmCode'),
        appCode?: string(name='AppCode'),
        createTime?: string(name='CreateTime'),
        modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
        modelServiceName?: string(name='ModelServiceName'),
        modelServiceStatus?: string(name='ModelServiceStatus'),
        qpsRequired?: int32(name='QpsRequired'),
      }
    ](name='ModelList'),
    total?: string(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeModelServiceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeModelServiceListResponseBody(name='body'),
}

async function describeModelServiceListWithOptions(request: DescribeModelServiceListRequest, runtime: Util.RuntimeOptions): DescribeModelServiceListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmCode)) {
    body['AlgorithmCode'] = request.algorithmCode;
  }
  if (!Util.isUnset(request.includeDeleted)) {
    body['IncludeDeleted'] = request.includeDeleted;
  }
  if (!Util.isUnset(request.modelServiceName)) {
    body['ModelServiceName'] = request.modelServiceName;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeModelServiceList',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeModelServiceList(request: DescribeModelServiceListRequest): DescribeModelServiceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModelServiceListWithOptions(request, runtime);
}

model DescribeNvrDevicesRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceFilter?: string(name='DeviceFilter'),
  nvrDeviceIdList?: string(name='NvrDeviceIdList'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model DescribeNvrDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        channel?: string(name='Channel'),
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        datasourceType?: string(name='DatasourceType'),
        deviceId?: string(name='DeviceId'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        deviceSn?: string(name='DeviceSn'),
        deviceStatus?: string(name='DeviceStatus'),
        deviceType?: string(name='DeviceType'),
        modifyTime?: string(name='ModifyTime'),
        projectName?: string(name='ProjectName'),
        regionName?: string(name='RegionName'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeNvrDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNvrDevicesResponseBody(name='body'),
}

async function describeNvrDevicesWithOptions(request: DescribeNvrDevicesRequest, runtime: Util.RuntimeOptions): DescribeNvrDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceFilter)) {
    body['DeviceFilter'] = request.deviceFilter;
  }
  if (!Util.isUnset(request.nvrDeviceIdList)) {
    body['NvrDeviceIdList'] = request.nvrDeviceIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNvrDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNvrDevices(request: DescribeNvrDevicesRequest): DescribeNvrDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNvrDevicesWithOptions(request, runtime);
}

model DescribeNvrsRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceFilter?: string(name='DeviceFilter'),
  nvrDeviceIdList?: string(name='NvrDeviceIdList'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model DescribeNvrsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        corpId?: string(name='CorpId'),
        createTime?: string(name='CreateTime'),
        datasourceType?: string(name='DatasourceType'),
        deviceAddress?: string(name='DeviceAddress'),
        deviceId?: string(name='DeviceId'),
        deviceModel?: string(name='DeviceModel'),
        deviceName?: string(name='DeviceName'),
        deviceSn?: string(name='DeviceSn'),
        deviceStatus?: string(name='DeviceStatus'),
        deviceType?: string(name='DeviceType'),
        inProtocol?: string(name='InProtocol'),
        latitude?: string(name='Latitude'),
        longitude?: string(name='Longitude'),
        modifyTime?: string(name='ModifyTime'),
        password?: string(name='Password'),
        serverId?: string(name='ServerId'),
        serverIp?: string(name='ServerIp'),
        serverPort?: string(name='ServerPort'),
        serverRealm?: string(name='ServerRealm'),
        subDeviceCount?: string(name='SubDeviceCount'),
        subDeviceInfo?: [ 
          {
            subDeviceId?: string(name='SubDeviceId'),
          }
        ](name='SubDeviceInfo'),
        vendor?: string(name='Vendor'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribeNvrsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeNvrsResponseBody(name='body'),
}

async function describeNvrsWithOptions(request: DescribeNvrsRequest, runtime: Util.RuntimeOptions): DescribeNvrsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceFilter)) {
    body['DeviceFilter'] = request.deviceFilter;
  }
  if (!Util.isUnset(request.nvrDeviceIdList)) {
    body['NvrDeviceIdList'] = request.nvrDeviceIdList;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeNvrs',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeNvrs(request: DescribeNvrsRequest): DescribeNvrsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeNvrsWithOptions(request, runtime);
}

model DescribeSearchItemsRequest {
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  searchItemIds?: string(name='SearchItemIds'),
  searchTableId?: string(name='SearchTableId'),
}

model DescribeSearchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: string(name='PageNumber'),
    pageSize?: string(name='PageSize'),
    records?: [ 
      {
        itemImageUrl?: string(name='ItemImageUrl'),
        searchItemId?: string(name='SearchItemId'),
        searchItemName?: string(name='SearchItemName'),
      }
    ](name='Records'),
    totalCount?: string(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSearchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSearchItemsResponseBody(name='body'),
}

async function describeSearchItemsWithOptions(request: DescribeSearchItemsRequest, runtime: Util.RuntimeOptions): DescribeSearchItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchItemIds)) {
    body['SearchItemIds'] = request.searchItemIds;
  }
  if (!Util.isUnset(request.searchTableId)) {
    body['SearchTableId'] = request.searchTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSearchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSearchItems(request: DescribeSearchItemsRequest): DescribeSearchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSearchItemsWithOptions(request, runtime);
}

model DescribeSearchTablesRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchTableIds?: string(name='SearchTableIds'),
}

model DescribeSearchTablesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumbei?: long(name='PageNumbei'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        algorithmId?: string(name='AlgorithmId'),
        searchTableId?: string(name='SearchTableId'),
        searchTableName?: string(name='SearchTableName'),
        targetType?: string(name='TargetType'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model DescribeSearchTablesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSearchTablesResponseBody(name='body'),
}

async function describeSearchTablesWithOptions(request: DescribeSearchTablesRequest, runtime: Util.RuntimeOptions): DescribeSearchTablesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchTableIds)) {
    body['SearchTableIds'] = request.searchTableIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSearchTables',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSearchTables(request: DescribeSearchTablesRequest): DescribeSearchTablesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSearchTablesWithOptions(request, runtime);
}

model DescribeWatchItemsRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  watchItemIds?: string(name='WatchItemIds'),
  watchPolicyId?: string(name='WatchPolicyId'),
}

model DescribeWatchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        itemAttributes?: string(name='ItemAttributes'),
        itemImageUrl?: string(name='ItemImageUrl'),
        watchItemId?: string(name='WatchItemId'),
        watchItemName?: string(name='WatchItemName'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeWatchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWatchItemsResponseBody(name='body'),
}

async function describeWatchItemsWithOptions(request: DescribeWatchItemsRequest, runtime: Util.RuntimeOptions): DescribeWatchItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.watchItemIds)) {
    body['WatchItemIds'] = request.watchItemIds;
  }
  if (!Util.isUnset(request.watchPolicyId)) {
    body['WatchPolicyId'] = request.watchPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWatchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWatchItems(request: DescribeWatchItemsRequest): DescribeWatchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWatchItemsWithOptions(request, runtime);
}

model DescribeWatchPoliciesRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  watchPolicyIds?: string(name='WatchPolicyIds'),
}

model DescribeWatchPoliciesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        itemMatchType?: string(name='ItemMatchType'),
        similarityThreshold?: double(name='SimilarityThreshold'),
        targetType?: string(name='TargetType'),
        watchMode?: string(name='WatchMode'),
        watchPolicyId?: string(name='WatchPolicyId'),
        watchPolicyName?: string(name='WatchPolicyName'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeWatchPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWatchPoliciesResponseBody(name='body'),
}

async function describeWatchPoliciesWithOptions(request: DescribeWatchPoliciesRequest, runtime: Util.RuntimeOptions): DescribeWatchPoliciesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.watchPolicyIds)) {
    body['WatchPolicyIds'] = request.watchPolicyIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWatchPolicies',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWatchPolicies(request: DescribeWatchPoliciesRequest): DescribeWatchPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWatchPoliciesWithOptions(request, runtime);
}

model DescribeWatchTasksRequest {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  watchTaskIds?: string(name='WatchTaskIds'),
}

model DescribeWatchTasksResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        corpId?: string(name='CorpId'),
        description?: string(name='Description'),
        deviceList?: string(name='DeviceList'),
        messageReceiver?: string(name='MessageReceiver'),
        scheduleCycleDates?: string(name='ScheduleCycleDates'),
        scheduleTimes?: string(name='ScheduleTimes'),
        scheduleType?: string(name='ScheduleType'),
        taskName?: string(name='TaskName'),
        watchPolicyIds?: string(name='WatchPolicyIds'),
        watchTaskId?: string(name='WatchTaskId'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeWatchTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeWatchTasksResponseBody(name='body'),
}

async function describeWatchTasksWithOptions(request: DescribeWatchTasksRequest, runtime: Util.RuntimeOptions): DescribeWatchTasksResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.watchTaskIds)) {
    body['WatchTaskIds'] = request.watchTaskIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeWatchTasks',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeWatchTasks(request: DescribeWatchTasksRequest): DescribeWatchTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeWatchTasksWithOptions(request, runtime);
}

model DescribesDoubleVerificationGroupsRequest {
  doubleVerificationGroupIds?: string(name='DoubleVerificationGroupIds'),
  id?: string(name='Id'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model DescribesDoubleVerificationGroupsResponseBody = {
  code?: string(name='Code'),
  doubleVerificationGroups?: {
    doubleVerificationGroupList?: [ 
      {
        deviceId?: string(name='DeviceId'),
        enabled?: string(name='Enabled'),
        groupId?: string(name='GroupId'),
        interval?: long(name='Interval'),
        lastChange?: string(name='LastChange'),
        memberNumber?: long(name='MemberNumber'),
        personIdList?: [ 
          {
            personId?: string(name='PersonId'),
            personTableId?: string(name='PersonTableId'),
          }
        ](name='PersonIdList'),
      }
    ](name='DoubleVerificationGroupList'),
    pageNum?: long(name='PageNum'),
    pageSize?: long(name='PageSize'),
    totalNum?: long(name='TotalNum'),
  }(name='DoubleVerificationGroups'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model DescribesDoubleVerificationGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribesDoubleVerificationGroupsResponseBody(name='body'),
}

async function describesDoubleVerificationGroupsWithOptions(request: DescribesDoubleVerificationGroupsRequest, runtime: Util.RuntimeOptions): DescribesDoubleVerificationGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.doubleVerificationGroupIds)) {
    body['DoubleVerificationGroupIds'] = request.doubleVerificationGroupIds;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribesDoubleVerificationGroups',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describesDoubleVerificationGroups(request: DescribesDoubleVerificationGroupsRequest): DescribesDoubleVerificationGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describesDoubleVerificationGroupsWithOptions(request, runtime);
}

model GetAiotStorageInfoResponseBody = {
  aiotStorageInfo?: {
    eventAlarmMq?: {
      alarmTopic?: string(name='AlarmTopic'),
      eventTopic?: string(name='EventTopic'),
      instanceId?: string(name='InstanceId'),
      mqType?: string(name='MqType'),
      ramArnRole?: string(name='RamArnRole'),
      regionId?: string(name='RegionId'),
    }(name='EventAlarmMq'),
    eventAlarmPictureStorage?: {
      bucket?: string(name='Bucket'),
      endpoint?: string(name='Endpoint'),
      path?: string(name='Path'),
      proxy?: string(name='Proxy'),
      ramArnRole?: string(name='RamArnRole'),
      storageType?: string(name='StorageType'),
    }(name='EventAlarmPictureStorage'),
  }(name='AiotStorageInfo'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetAiotStorageInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAiotStorageInfoResponseBody(name='body'),
}

async function getAiotStorageInfoWithOptions(runtime: Util.RuntimeOptions): GetAiotStorageInfoResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetAiotStorageInfo',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAiotStorageInfo(): GetAiotStorageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAiotStorageInfoWithOptions(runtime);
}

model GetBodyOptionsRequest {
  corpId?: string(name='CorpId'),
}

model GetBodyOptionsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      key?: string(name='Key'),
      name?: string(name='Name'),
      optionList?: [ 
        {
          key?: string(name='Key'),
          name?: string(name='Name'),
        }
      ](name='OptionList'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetBodyOptionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetBodyOptionsResponseBody(name='body'),
}

async function getBodyOptionsWithOptions(request: GetBodyOptionsRequest, runtime: Util.RuntimeOptions): GetBodyOptionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetBodyOptions',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBodyOptions(request: GetBodyOptionsRequest): GetBodyOptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getBodyOptionsWithOptions(request, runtime);
}

model GetCatalogListRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
}

model GetCatalogListResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      catalogId?: long(name='CatalogId'),
      catalogName?: string(name='CatalogName'),
      isvSubId?: string(name='IsvSubId'),
      parentCatalogId?: long(name='ParentCatalogId'),
      profileCount?: long(name='ProfileCount'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetCatalogListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCatalogListResponseBody(name='body'),
}

async function getCatalogListWithOptions(request: GetCatalogListRequest, runtime: Util.RuntimeOptions): GetCatalogListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.corpId)) {
    query['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    query['IsvSubId'] = request.isvSubId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCatalogList',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCatalogList(request: GetCatalogListRequest): GetCatalogListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCatalogListWithOptions(request, runtime);
}

model GetCityCodeResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      cityAddress?: string(name='CityAddress'),
      cityCode?: string(name='CityCode'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetCityCodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetCityCodeResponseBody(name='body'),
}

async function getCityCodeWithOptions(runtime: Util.RuntimeOptions): GetCityCodeResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'GetCityCode',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCityCode(): GetCityCodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCityCodeWithOptions(runtime);
}

model GetDataSourceStatsRequest {
  corpIdList?: string(name='CorpIdList'),
  dataSourceType?: string(name='DataSourceType'),
}

model GetDataSourceStatsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      dataSourceType?: string(name='DataSourceType'),
      items?: map[string]any(name='Items'),
      total?: long(name='Total'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDataSourceStatsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDataSourceStatsResponseBody(name='body'),
}

async function getDataSourceStatsWithOptions(request: GetDataSourceStatsRequest, runtime: Util.RuntimeOptions): GetDataSourceStatsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDataSourceStats',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDataSourceStats(request: GetDataSourceStatsRequest): GetDataSourceStatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDataSourceStatsWithOptions(request, runtime);
}

model GetDeviceCaptureStrategyRequest {
  deviceCode?: string(name='DeviceCode'),
  deviceType?: string(name='DeviceType'),
}

model GetDeviceCaptureStrategyResponseBody = {
  code?: string(name='Code'),
  data?: {
    deviceCode?: string(name='DeviceCode'),
    deviceType?: string(name='DeviceType'),
    fridayCaptureStrategy?: string(name='FridayCaptureStrategy'),
    mondayCaptureStrategy?: string(name='MondayCaptureStrategy'),
    saturdayCaptureStrategy?: string(name='SaturdayCaptureStrategy'),
    sundayCaptureStrategy?: string(name='SundayCaptureStrategy'),
    thursdayCaptureStrategy?: string(name='ThursdayCaptureStrategy'),
    tuesdayCaptureStrategy?: string(name='TuesdayCaptureStrategy'),
    wednesdayCaptureStrategy?: string(name='WednesdayCaptureStrategy'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDeviceCaptureStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceCaptureStrategyResponseBody(name='body'),
}

async function getDeviceCaptureStrategyWithOptions(request: GetDeviceCaptureStrategyRequest, runtime: Util.RuntimeOptions): GetDeviceCaptureStrategyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCode)) {
    body['DeviceCode'] = request.deviceCode;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceCaptureStrategy',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceCaptureStrategy(request: GetDeviceCaptureStrategyRequest): GetDeviceCaptureStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceCaptureStrategyWithOptions(request, runtime);
}

model GetDeviceConfigRequest {
  deviceSn?: string(name='DeviceSn'),
  deviceTimeStamp?: string(name='DeviceTimeStamp'),
}

model GetDeviceConfigResponseBody = {
  audioEnable?: string(name='AudioEnable'),
  audioFormat?: string(name='AudioFormat'),
  bitRate?: string(name='BitRate'),
  channelList?: [ 
    {
      channelGbId?: string(name='ChannelGbId'),
      fridayCaptureStrategy?: string(name='FridayCaptureStrategy'),
      mondayCaptureStrategy?: string(name='MondayCaptureStrategy'),
      saturdayCaptureStrategy?: string(name='SaturdayCaptureStrategy'),
      sundayCaptureStrategy?: string(name='SundayCaptureStrategy'),
      thursdayCaptureStrategy?: string(name='ThursdayCaptureStrategy'),
      tuesdayCaptureStrategy?: string(name='TuesdayCaptureStrategy'),
      wednesdayCaptureStrategy?: string(name='WednesdayCaptureStrategy'),
    }
  ](name='ChannelList'),
  code?: string(name='Code'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceId?: string(name='DeviceId'),
  deviceName?: string(name='DeviceName'),
  encodeFormat?: string(name='EncodeFormat'),
  frameRate?: string(name='FrameRate'),
  govLength?: long(name='GovLength'),
  latitude?: string(name='Latitude'),
  longitude?: string(name='Longitude'),
  message?: string(name='Message'),
  OSDList?: [ 
    {
      leftTopX?: string(name='LeftTopX'),
      leftTopY?: string(name='LeftTopY'),
      text?: string(name='Text'),
    }
  ](name='OSDList'),
  OSDTimeEnable?: string(name='OSDTimeEnable'),
  OSDTimeType?: string(name='OSDTimeType'),
  OSDTimeX?: string(name='OSDTimeX'),
  OSDTimeY?: string(name='OSDTimeY'),
  passWord?: string(name='PassWord'),
  protocol?: string(name='Protocol'),
  requestId?: string(name='RequestId'),
  resolution?: string(name='Resolution'),
  retryInterval?: string(name='RetryInterval'),
  serverId?: string(name='ServerId'),
  serverIp?: string(name='ServerIp'),
  serverPort?: string(name='ServerPort'),
  userName?: string(name='UserName'),
}

model GetDeviceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceConfigResponseBody(name='body'),
}

async function getDeviceConfigWithOptions(request: GetDeviceConfigRequest, runtime: Util.RuntimeOptions): GetDeviceConfigResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSn)) {
    body['DeviceSn'] = request.deviceSn;
  }
  if (!Util.isUnset(request.deviceTimeStamp)) {
    body['DeviceTimeStamp'] = request.deviceTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceConfig',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceConfig(request: GetDeviceConfigRequest): GetDeviceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceConfigWithOptions(request, runtime);
}

model GetDeviceLiveUrlRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  gbId?: string(name='GbId'),
  outProtocol?: string(name='OutProtocol'),
  streamType?: string(name='StreamType'),
}

model GetDeviceLiveUrlResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  outProtocol?: string(name='OutProtocol'),
  requestId?: string(name='RequestId'),
  streamType?: long(name='StreamType'),
  url?: string(name='Url'),
}

model GetDeviceLiveUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceLiveUrlResponseBody(name='body'),
}

async function getDeviceLiveUrlWithOptions(request: GetDeviceLiveUrlRequest, runtime: Util.RuntimeOptions): GetDeviceLiveUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.outProtocol)) {
    body['OutProtocol'] = request.outProtocol;
  }
  if (!Util.isUnset(request.streamType)) {
    body['StreamType'] = request.streamType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceLiveUrl',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceLiveUrl(request: GetDeviceLiveUrlRequest): GetDeviceLiveUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceLiveUrlWithOptions(request, runtime);
}

model GetDevicePictureRequest {
  deviceId?: string(name='DeviceId'),
}

model GetDevicePictureResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDevicePictureResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevicePictureResponseBody(name='body'),
}

async function getDevicePictureWithOptions(request: GetDevicePictureRequest, runtime: Util.RuntimeOptions): GetDevicePictureResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDevicePicture',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevicePicture(request: GetDevicePictureRequest): GetDevicePictureResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevicePictureWithOptions(request, runtime);
}

model GetDeviceStatsRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceStatus?: string(name='DeviceStatus'),
  deviceType?: string(name='DeviceType'),
}

model GetDeviceStatsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      count?: long(name='Count'),
      deviceStatus?: string(name='DeviceStatus'),
      deviceType?: string(name='DeviceType'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDeviceStatsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceStatsResponseBody(name='body'),
}

async function getDeviceStatsWithOptions(request: GetDeviceStatsRequest, runtime: Util.RuntimeOptions): GetDeviceStatsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceStatus)) {
    body['DeviceStatus'] = request.deviceStatus;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceStats',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceStats(request: GetDeviceStatsRequest): GetDeviceStatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceStatsWithOptions(request, runtime);
}

model GetDeviceVideoUrlRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  endTime?: long(name='EndTime'),
  gbId?: string(name='GbId'),
  outProtocol?: string(name='OutProtocol'),
  startTime?: long(name='StartTime'),
  storageType?: string(name='StorageType'),
}

model GetDeviceVideoUrlResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  outProtocol?: string(name='OutProtocol'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetDeviceVideoUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceVideoUrlResponseBody(name='body'),
}

async function getDeviceVideoUrlWithOptions(request: GetDeviceVideoUrlRequest, runtime: Util.RuntimeOptions): GetDeviceVideoUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.outProtocol)) {
    body['OutProtocol'] = request.outProtocol;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.storageType)) {
    body['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceVideoUrl',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceVideoUrl(request: GetDeviceVideoUrlRequest): GetDeviceVideoUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceVideoUrlWithOptions(request, runtime);
}

model GetFaceModelResultRequest {
  pictureContent?: string(name='PictureContent'),
  pictureId?: string(name='PictureId'),
  pictureUrl?: string(name='PictureUrl'),
}

model GetFaceModelResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    records?: [ 
      {
        ageLowerLimit?: int32(name='AgeLowerLimit'),
        ageLowerLimitReliability?: string(name='AgeLowerLimitReliability'),
        ageUpLimit?: int32(name='AgeUpLimit'),
        ageUpLimitReliability?: string(name='AgeUpLimitReliability'),
        capColor?: int32(name='CapColor'),
        capColorReliability?: string(name='CapColorReliability'),
        capStyle?: int32(name='CapStyle'),
        capStyleReliability?: string(name='CapStyleReliability'),
        ethicCode?: int32(name='EthicCode'),
        ethicCodeReliability?: string(name='EthicCodeReliability'),
        faceStyle?: string(name='FaceStyle'),
        faceStyleReliability?: string(name='FaceStyleReliability'),
        featureData?: [ float ](name='FeatureData'),
        genderCode?: int32(name='GenderCode'),
        genderCodeReliability?: string(name='GenderCodeReliability'),
        glassColor?: int32(name='GlassColor'),
        glassColorReliability?: string(name='GlassColorReliability'),
        glassStyle?: int32(name='GlassStyle'),
        glassStyleReliability?: string(name='GlassStyleReliability'),
        hairColor?: int32(name='HairColor'),
        hairColorReliability?: string(name='HairColorReliability'),
        hairStyle?: int32(name='HairStyle'),
        hairStyleReliability?: string(name='HairStyleReliability'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        mustacheStyle?: string(name='MustacheStyle'),
        mustacheStyleReliability?: string(name='MustacheStyleReliability'),
        respiratorColor?: int32(name='RespiratorColor'),
        respiratorColorReliability?: string(name='RespiratorColorReliability'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        skinColor?: int32(name='SkinColor'),
        skinColorReliability?: string(name='SkinColorReliability'),
      }
    ](name='Records'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetFaceModelResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFaceModelResultResponseBody(name='body'),
}

async function getFaceModelResultWithOptions(request: GetFaceModelResultRequest, runtime: Util.RuntimeOptions): GetFaceModelResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pictureContent)) {
    body['PictureContent'] = request.pictureContent;
  }
  if (!Util.isUnset(request.pictureId)) {
    body['PictureId'] = request.pictureId;
  }
  if (!Util.isUnset(request.pictureUrl)) {
    body['PictureUrl'] = request.pictureUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFaceModelResult',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFaceModelResult(request: GetFaceModelResultRequest): GetFaceModelResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceModelResultWithOptions(request, runtime);
}

model GetFaceOptionsRequest {
  corpId?: string(name='CorpId'),
}

model GetFaceOptionsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      key?: string(name='Key'),
      name?: string(name='Name'),
      optionList?: [ 
        {
          key?: string(name='Key'),
          name?: string(name='Name'),
        }
      ](name='OptionList'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetFaceOptionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetFaceOptionsResponseBody(name='body'),
}

async function getFaceOptionsWithOptions(request: GetFaceOptionsRequest, runtime: Util.RuntimeOptions): GetFaceOptionsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetFaceOptions',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getFaceOptions(request: GetFaceOptionsRequest): GetFaceOptionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getFaceOptionsWithOptions(request, runtime);
}

model GetInventoryRequest {
  commodityCode?: string(name='CommodityCode'),
}

model GetInventoryResponseBody = {
  data?: {
    resultObject?: [ 
      {
        buyerId?: string(name='BuyerId'),
        commodityCode?: string(name='CommodityCode'),
        currentInventory?: string(name='CurrentInventory'),
        instanceId?: string(name='InstanceId'),
        inventoryId?: string(name='InventoryId'),
        validEndTime?: string(name='ValidEndTime'),
        validStartTime?: string(name='ValidStartTime'),
      }
    ](name='ResultObject'),
  }(name='Data'),
  success?: boolean(name='Success'),
}

model GetInventoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInventoryResponseBody(name='body'),
}

async function getInventoryWithOptions(request: GetInventoryRequest, runtime: Util.RuntimeOptions): GetInventoryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.commodityCode)) {
    body['CommodityCode'] = request.commodityCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetInventory',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInventory(request: GetInventoryRequest): GetInventoryResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInventoryWithOptions(request, runtime);
}

model GetMonitorListRequest {
  corpId?: string(name='CorpId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model GetMonitorListResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        algorithmVendor?: string(name='AlgorithmVendor'),
        attributes?: string(name='Attributes'),
        createDate?: string(name='CreateDate'),
        description?: string(name='Description'),
        deviceList?: string(name='DeviceList'),
        expression?: string(name='Expression'),
        imageMatch?: string(name='ImageMatch'),
        modifiedDate?: string(name='ModifiedDate'),
        monitorType?: string(name='MonitorType'),
        notifierExtendValues?: string(name='NotifierExtendValues'),
        notifierType?: string(name='NotifierType'),
        ruleExpression?: string(name='RuleExpression'),
        ruleName?: string(name='RuleName'),
        status?: string(name='Status'),
        taskId?: string(name='TaskId'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetMonitorListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMonitorListResponseBody(name='body'),
}

async function getMonitorListWithOptions(request: GetMonitorListRequest, runtime: Util.RuntimeOptions): GetMonitorListResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorList',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorList(request: GetMonitorListRequest): GetMonitorListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMonitorListWithOptions(request, runtime);
}

model GetMonitorResultRequest {
  algorithmVendor?: string(name='AlgorithmVendor'),
  corpId?: string(name='CorpId'),
  endTime?: long(name='EndTime'),
  minRecordId?: string(name='MinRecordId'),
  startTime?: long(name='StartTime'),
  taskId?: string(name='TaskId'),
}

model GetMonitorResultResponseBody = {
  code?: string(name='Code'),
  data?: {
    maxId?: string(name='MaxId'),
    records?: [ 
      {
        extendInfo?: {
          plateNo?: string(name='PlateNo'),
        }(name='ExtendInfo'),
        gbId?: string(name='GbId'),
        leftUpX?: string(name='LeftUpX'),
        leftUpY?: string(name='LeftUpY'),
        monitorPicUrl?: string(name='MonitorPicUrl'),
        picUrl?: string(name='PicUrl'),
        rightBottomX?: string(name='RightBottomX'),
        rightBottomY?: string(name='RightBottomY'),
        score?: string(name='Score'),
        shotTime?: string(name='ShotTime'),
        targetPicUrl?: string(name='TargetPicUrl'),
        taskId?: string(name='TaskId'),
      }
    ](name='Records'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetMonitorResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMonitorResultResponseBody(name='body'),
}

async function getMonitorResultWithOptions(request: GetMonitorResultRequest, runtime: Util.RuntimeOptions): GetMonitorResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmVendor)) {
    body['AlgorithmVendor'] = request.algorithmVendor;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.minRecordId)) {
    body['MinRecordId'] = request.minRecordId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorResult',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorResult(request: GetMonitorResultRequest): GetMonitorResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMonitorResultWithOptions(request, runtime);
}

model GetPersonDetailRequest {
  algorithmType?: string(name='AlgorithmType'),
  corpId?: string(name='CorpId'),
  personID?: string(name='PersonID'),
}

model GetPersonDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    personId?: string(name='PersonId'),
    picUrl?: string(name='PicUrl'),
    tagList?: [ 
      {
        tagCode?: string(name='TagCode'),
        tagName?: string(name='TagName'),
        tagValue?: string(name='TagValue'),
        tagValueId?: string(name='TagValueId'),
      }
    ](name='TagList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetPersonDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPersonDetailResponseBody(name='body'),
}

async function getPersonDetailWithOptions(request: GetPersonDetailRequest, runtime: Util.RuntimeOptions): GetPersonDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.personID)) {
    body['PersonID'] = request.personID;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPersonDetail',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPersonDetail(request: GetPersonDetailRequest): GetPersonDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPersonDetailWithOptions(request, runtime);
}

model GetPersonListRequest {
  corpId?: string(name='CorpId'),
  corpIdList?: map[string]any(name='CorpIdList'),
  faceMatchingRateThreshold?: string(name='FaceMatchingRateThreshold'),
  faceUrl?: string(name='FaceUrl'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personIdList?: map[string]any(name='PersonIdList'),
}

model GetPersonListShrinkRequest {
  corpId?: string(name='CorpId'),
  corpIdListShrink?: string(name='CorpIdList'),
  faceMatchingRateThreshold?: string(name='FaceMatchingRateThreshold'),
  faceUrl?: string(name='FaceUrl'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personIdListShrink?: string(name='PersonIdList'),
}

model GetPersonListResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        faceUrl?: string(name='FaceUrl'),
        firstShotTime?: long(name='FirstShotTime'),
        lastShotTime?: long(name='LastShotTime'),
        personId?: string(name='PersonId'),
        propertyTagList?: [ 
          {
            code?: string(name='Code'),
            tagCodeName?: string(name='TagCodeName'),
            tagName?: string(name='TagName'),
            value?: string(name='Value'),
          }
        ](name='PropertyTagList'),
        searchMatchingRate?: string(name='SearchMatchingRate'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetPersonListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPersonListResponseBody(name='body'),
}

async function getPersonListWithOptions(tmpReq: GetPersonListRequest, runtime: Util.RuntimeOptions): GetPersonListResponse {
  Util.validateModel(tmpReq);
  var request = new GetPersonListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.corpIdList)) {
    request.corpIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.corpIdList, 'CorpIdList', 'json');
  }
  if (!Util.isUnset(tmpReq.personIdList)) {
    request.personIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.personIdList, 'PersonIdList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.corpIdListShrink)) {
    body['CorpIdList'] = request.corpIdListShrink;
  }
  if (!Util.isUnset(request.faceMatchingRateThreshold)) {
    body['FaceMatchingRateThreshold'] = request.faceMatchingRateThreshold;
  }
  if (!Util.isUnset(request.faceUrl)) {
    body['FaceUrl'] = request.faceUrl;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personIdListShrink)) {
    body['PersonIdList'] = request.personIdListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPersonList',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPersonList(request: GetPersonListRequest): GetPersonListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPersonListWithOptions(request, runtime);
}

model GetPictureUrlRequest {
  expireTime?: string(name='ExpireTime'),
  originUrl?: string(name='OriginUrl'),
  protocol?: string(name='Protocol'),
}

model GetPictureUrlResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  url?: string(name='Url'),
}

model GetPictureUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPictureUrlResponseBody(name='body'),
}

async function getPictureUrlWithOptions(request: GetPictureUrlRequest, runtime: Util.RuntimeOptions): GetPictureUrlResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.expireTime)) {
    body['ExpireTime'] = request.expireTime;
  }
  if (!Util.isUnset(request.originUrl)) {
    body['OriginUrl'] = request.originUrl;
  }
  if (!Util.isUnset(request.protocol)) {
    body['Protocol'] = request.protocol;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetPictureUrl',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPictureUrl(request: GetPictureUrlRequest): GetPictureUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPictureUrlWithOptions(request, runtime);
}

model GetProfileDetailRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  profileId?: long(name='ProfileId'),
}

model GetProfileDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    bizId?: string(name='BizId'),
    catalogId?: int32(name='CatalogId'),
    faceUrl?: string(name='FaceUrl'),
    gender?: string(name='Gender'),
    idNumber?: string(name='IdNumber'),
    isvSubId?: string(name='IsvSubId'),
    liveAddress?: string(name='LiveAddress'),
    name?: string(name='Name'),
    personId?: string(name='PersonId'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    profileId?: int32(name='ProfileId'),
    sceneType?: string(name='SceneType'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetProfileDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProfileDetailResponseBody(name='body'),
}

async function getProfileDetailWithOptions(request: GetProfileDetailRequest, runtime: Util.RuntimeOptions): GetProfileDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.profileId)) {
    body['ProfileId'] = request.profileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProfileDetail',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProfileDetail(request: GetProfileDetailRequest): GetProfileDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProfileDetailWithOptions(request, runtime);
}

model GetProfileListRequest {
  bizId?: string(name='BizId'),
  catalogId?: long(name='CatalogId'),
  corpId?: string(name='CorpId'),
  faceImageId?: string(name='FaceImageId'),
  faceUrl?: string(name='FaceUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  liveAddress?: string(name='LiveAddress'),
  matchingRateThreshold?: string(name='MatchingRateThreshold'),
  name?: string(name='Name'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personIdList?: map[string]any(name='PersonIdList'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  profileIdList?: map[string]any(name='ProfileIdList'),
  sceneType?: string(name='SceneType'),
}

model GetProfileListShrinkRequest {
  bizId?: string(name='BizId'),
  catalogId?: long(name='CatalogId'),
  corpId?: string(name='CorpId'),
  faceImageId?: string(name='FaceImageId'),
  faceUrl?: string(name='FaceUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  liveAddress?: string(name='LiveAddress'),
  matchingRateThreshold?: string(name='MatchingRateThreshold'),
  name?: string(name='Name'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personIdListShrink?: string(name='PersonIdList'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  profileIdListShrink?: string(name='ProfileIdList'),
  sceneType?: string(name='SceneType'),
}

model GetProfileListResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        bizId?: string(name='BizId'),
        catalogId?: int32(name='CatalogId'),
        faceUrl?: string(name='FaceUrl'),
        gender?: string(name='Gender'),
        idNumber?: string(name='IdNumber'),
        isvSubId?: string(name='IsvSubId'),
        name?: string(name='Name'),
        personId?: string(name='PersonId'),
        profileId?: int32(name='ProfileId'),
        sceneType?: string(name='SceneType'),
        searchMatchingRate?: string(name='SearchMatchingRate'),
      }
    ](name='Records'),
    success?: boolean(name='Success'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetProfileListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetProfileListResponseBody(name='body'),
}

async function getProfileListWithOptions(tmpReq: GetProfileListRequest, runtime: Util.RuntimeOptions): GetProfileListResponse {
  Util.validateModel(tmpReq);
  var request = new GetProfileListShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.personIdList)) {
    request.personIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.personIdList, 'PersonIdList', 'json');
  }
  if (!Util.isUnset(tmpReq.profileIdList)) {
    request.profileIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.profileIdList, 'ProfileIdList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceImageId)) {
    body['FaceImageId'] = request.faceImageId;
  }
  if (!Util.isUnset(request.faceUrl)) {
    body['FaceUrl'] = request.faceUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.liveAddress)) {
    body['LiveAddress'] = request.liveAddress;
  }
  if (!Util.isUnset(request.matchingRateThreshold)) {
    body['MatchingRateThreshold'] = request.matchingRateThreshold;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personIdListShrink)) {
    body['PersonIdList'] = request.personIdListShrink;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.profileIdListShrink)) {
    body['ProfileIdList'] = request.profileIdListShrink;
  }
  if (!Util.isUnset(request.sceneType)) {
    body['SceneType'] = request.sceneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetProfileList',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProfileList(request: GetProfileListRequest): GetProfileListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getProfileListWithOptions(request, runtime);
}

model GetScanSubDevicesRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
}

model GetScanSubDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    subDeviceList?: [ 
      {
        associatedNvr?: string(name='AssociatedNvr'),
        deviceMac?: string(name='DeviceMac'),
        deviceModel?: string(name='DeviceModel'),
        deviceSn?: string(name='DeviceSn'),
        firmwareVersion?: string(name='FirmwareVersion'),
        manufacturer?: string(name='Manufacturer'),
        subDeviceIp?: string(name='SubDeviceIp'),
        subDevicePort?: string(name='SubDevicePort'),
      }
    ](name='SubDeviceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetScanSubDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScanSubDevicesResponseBody(name='body'),
}

async function getScanSubDevicesWithOptions(request: GetScanSubDevicesRequest, runtime: Util.RuntimeOptions): GetScanSubDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetScanSubDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScanSubDevices(request: GetScanSubDevicesRequest): GetScanSubDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScanSubDevicesWithOptions(request, runtime);
}

model GetUserDetailRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  needFaceDetail?: boolean(name='NeedFaceDetail'),
  userId?: long(name='UserId'),
}

model GetUserDetailResponseBody = {
  code?: string(name='Code'),
  data?: {
    address?: string(name='Address'),
    age?: string(name='Age'),
    attachment?: string(name='Attachment'),
    bizId?: string(name='BizId'),
    faceImageUrl?: string(name='FaceImageUrl'),
    gender?: string(name='Gender'),
    idNumber?: string(name='IdNumber'),
    isvSubId?: string(name='IsvSubId'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    userGroupId?: int32(name='UserGroupId'),
    userId?: int32(name='UserId'),
    userName?: string(name='UserName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetUserDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetUserDetailResponseBody(name='body'),
}

async function getUserDetailWithOptions(request: GetUserDetailRequest, runtime: Util.RuntimeOptions): GetUserDetailResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.needFaceDetail)) {
    body['NeedFaceDetail'] = request.needFaceDetail;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetUserDetail',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUserDetail(request: GetUserDetailRequest): GetUserDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserDetailWithOptions(request, runtime);
}

model GetVideoComposeResultRequest {
  corpId?: string(name='CorpId'),
  taskRequestId?: string(name='TaskRequestId'),
}

model GetVideoComposeResultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
  videoUrl?: string(name='VideoUrl'),
}

model GetVideoComposeResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoComposeResultResponseBody(name='body'),
}

async function getVideoComposeResultWithOptions(request: GetVideoComposeResultRequest, runtime: Util.RuntimeOptions): GetVideoComposeResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.taskRequestId)) {
    body['TaskRequestId'] = request.taskRequestId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoComposeResult',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideoComposeResult(request: GetVideoComposeResultRequest): GetVideoComposeResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoComposeResultWithOptions(request, runtime);
}

model GetVideoSummaryTaskResultRequest {
  corpId?: string(name='CorpId'),
  taskId?: string(name='TaskId'),
}

model GetVideoSummaryTaskResultResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetVideoSummaryTaskResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetVideoSummaryTaskResultResponseBody(name='body'),
}

async function getVideoSummaryTaskResultWithOptions(request: GetVideoSummaryTaskResultRequest, runtime: Util.RuntimeOptions): GetVideoSummaryTaskResultResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetVideoSummaryTaskResult',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getVideoSummaryTaskResult(request: GetVideoSummaryTaskResultRequest): GetVideoSummaryTaskResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return getVideoSummaryTaskResultWithOptions(request, runtime);
}

model InvokeMotorModelRequest {
  corpId?: string(name='CorpId'),
  picId?: string(name='PicId'),
  picPath?: string(name='PicPath'),
  picUrl?: string(name='PicUrl'),
}

model InvokeMotorModelResponseBody = {
  code?: string(name='Code'),
  data?: {
    structList?: string(name='StructList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model InvokeMotorModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InvokeMotorModelResponseBody(name='body'),
}

async function invokeMotorModelWithOptions(request: InvokeMotorModelRequest, runtime: Util.RuntimeOptions): InvokeMotorModelResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.picId)) {
    body['PicId'] = request.picId;
  }
  if (!Util.isUnset(request.picPath)) {
    body['PicPath'] = request.picPath;
  }
  if (!Util.isUnset(request.picUrl)) {
    body['PicUrl'] = request.picUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'InvokeMotorModel',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function invokeMotorModel(request: InvokeMotorModelRequest): InvokeMotorModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return invokeMotorModelWithOptions(request, runtime);
}

model ListAccessNumberRequest {
  corpIdList?: string(name='CorpIdList'),
}

model ListAccessNumberResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      count?: string(name='Count'),
      item?: string(name='Item'),
      percent?: string(name='Percent'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListAccessNumberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAccessNumberResponseBody(name='body'),
}

async function listAccessNumberWithOptions(request: ListAccessNumberRequest, runtime: Util.RuntimeOptions): ListAccessNumberResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListAccessNumber',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAccessNumber(request: ListAccessNumberRequest): ListAccessNumberResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccessNumberWithOptions(request, runtime);
}

model ListAlgorithmNamesByDeviceIdsRequest {
  gbIds?: string(name='GbIds'),
}

model ListAlgorithmNamesByDeviceIdsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      algorithmNames?: [ string ](name='AlgorithmNames'),
      gbId?: string(name='GbId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListAlgorithmNamesByDeviceIdsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlgorithmNamesByDeviceIdsResponseBody(name='body'),
}

async function listAlgorithmNamesByDeviceIdsWithOptions(request: ListAlgorithmNamesByDeviceIdsRequest, runtime: Util.RuntimeOptions): ListAlgorithmNamesByDeviceIdsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlgorithmNamesByDeviceIds',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlgorithmNamesByDeviceIds(request: ListAlgorithmNamesByDeviceIdsRequest): ListAlgorithmNamesByDeviceIdsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlgorithmNamesByDeviceIdsWithOptions(request, runtime);
}

model ListBodyAlgorithmResultsRequest {
  algorithmType?: string(name='AlgorithmType'),
  capStyle?: string(name='CapStyle'),
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model ListBodyAlgorithmResultsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        capStyle?: string(name='CapStyle'),
        coatColor?: string(name='CoatColor'),
        coatLength?: string(name='CoatLength'),
        coatStyle?: string(name='CoatStyle'),
        corpId?: string(name='CorpId'),
        dataSourceId?: string(name='DataSourceId'),
        genderCode?: string(name='GenderCode'),
        hairStyle?: string(name='HairStyle'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        maxAge?: string(name='MaxAge'),
        minAge?: string(name='MinAge'),
        personId?: string(name='PersonId'),
        picUrlPath?: string(name='PicUrlPath'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        shotTime?: string(name='ShotTime'),
        sourceId?: string(name='SourceId'),
        targetPicUrlPath?: string(name='TargetPicUrlPath'),
        trousersColor?: string(name='TrousersColor'),
        trousersLength?: string(name='TrousersLength'),
        trousersStyle?: string(name='TrousersStyle'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListBodyAlgorithmResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBodyAlgorithmResultsResponseBody(name='body'),
}

async function listBodyAlgorithmResultsWithOptions(request: ListBodyAlgorithmResultsRequest, runtime: Util.RuntimeOptions): ListBodyAlgorithmResultsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.capStyle)) {
    body['CapStyle'] = request.capStyle;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListBodyAlgorithmResults',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBodyAlgorithmResults(request: ListBodyAlgorithmResultsRequest): ListBodyAlgorithmResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listBodyAlgorithmResultsWithOptions(request, runtime);
}

model ListCorpGroupMetricsRequest {
  corpId?: string(name='CorpId'),
  deviceGroup?: string(name='DeviceGroup'),
  deviceId?: string(name='DeviceId'),
  endTime?: string(name='EndTime'),
  groupId?: string(name='GroupId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  tagCode?: string(name='TagCode'),
  userGroup?: string(name='UserGroup'),
}

model ListCorpGroupMetricsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpGroupId?: string(name='CorpGroupId'),
      corpId?: string(name='CorpId'),
      dateId?: string(name='DateId'),
      deviceGroupId?: string(name='DeviceGroupId'),
      deviceId?: string(name='DeviceId'),
      personID?: string(name='PersonID'),
      tagCode?: string(name='TagCode'),
      tagMetrics?: string(name='TagMetrics'),
      tagValue?: string(name='TagValue'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListCorpGroupMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCorpGroupMetricsResponseBody(name='body'),
}

async function listCorpGroupMetricsWithOptions(request: ListCorpGroupMetricsRequest, runtime: Util.RuntimeOptions): ListCorpGroupMetricsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceGroup)) {
    body['DeviceGroup'] = request.deviceGroup;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagCode)) {
    body['TagCode'] = request.tagCode;
  }
  if (!Util.isUnset(request.userGroup)) {
    body['UserGroup'] = request.userGroup;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCorpGroupMetrics',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCorpGroupMetrics(request: ListCorpGroupMetricsRequest): ListCorpGroupMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCorpGroupMetricsWithOptions(request, runtime);
}

model ListCorpGroupsRequest {
  corpId?: string(name='CorpId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
}

model ListCorpGroupsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ string ](name='Records'),
    totalCount?: long(name='TotalCount'),
    totalPage?: long(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListCorpGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCorpGroupsResponseBody(name='body'),
}

async function listCorpGroupsWithOptions(request: ListCorpGroupsRequest, runtime: Util.RuntimeOptions): ListCorpGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCorpGroups',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCorpGroups(request: ListCorpGroupsRequest): ListCorpGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCorpGroupsWithOptions(request, runtime);
}

model ListCorpMetricsRequest {
  corpId?: string(name='CorpId'),
  deviceGroupList?: string(name='DeviceGroupList'),
  deviceIdList?: string(name='DeviceIdList'),
  endTime?: string(name='EndTime'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  tagCode?: string(name='TagCode'),
  userGroupList?: string(name='UserGroupList'),
}

model ListCorpMetricsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpId?: string(name='CorpId'),
      dateId?: string(name='DateId'),
      deviceGroupId?: string(name='DeviceGroupId'),
      deviceId?: string(name='DeviceId'),
      personId?: string(name='PersonId'),
      tagCode?: string(name='TagCode'),
      tagMetrics?: string(name='TagMetrics'),
      tagValue?: string(name='TagValue'),
      userGroupId?: string(name='UserGroupId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListCorpMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCorpMetricsResponseBody(name='body'),
}

async function listCorpMetricsWithOptions(request: ListCorpMetricsRequest, runtime: Util.RuntimeOptions): ListCorpMetricsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceGroupList)) {
    body['DeviceGroupList'] = request.deviceGroupList;
  }
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagCode)) {
    body['TagCode'] = request.tagCode;
  }
  if (!Util.isUnset(request.userGroupList)) {
    body['UserGroupList'] = request.userGroupList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCorpMetrics',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCorpMetrics(request: ListCorpMetricsRequest): ListCorpMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCorpMetricsWithOptions(request, runtime);
}

model ListCorpsRequest {
  corpName?: string(name='CorpName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListCorpsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        acuUsed?: int32(name='AcuUsed'),
        appName?: string(name='AppName'),
        corpId?: string(name='CorpId'),
        corpName?: string(name='CorpName'),
        createDate?: string(name='CreateDate'),
        description?: string(name='Description'),
        deviceCount?: int32(name='DeviceCount'),
        iconPath?: string(name='IconPath'),
        isvSubId?: string(name='IsvSubId'),
        parentCorpId?: string(name='ParentCorpId'),
        YOfflineAcuUsed?: double(name='YOfflineAcuUsed'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListCorpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListCorpsResponseBody(name='body'),
}

async function listCorpsWithOptions(request: ListCorpsRequest, runtime: Util.RuntimeOptions): ListCorpsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpName)) {
    body['CorpName'] = request.corpName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListCorps',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCorps(request: ListCorpsRequest): ListCorpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCorpsWithOptions(request, runtime);
}

model ListDeviceGroupsRequest {
  corpIdList?: string(name='CorpIdList'),
  dataSourceType?: string(name='DataSourceType'),
  deviceCodeList?: string(name='DeviceCodeList'),
  group?: string(name='Group'),
  isPage?: int32(name='IsPage'),
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model ListDeviceGroupsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      list?: [ 
        {
          bitRate?: string(name='BitRate'),
          codingFormat?: string(name='CodingFormat'),
          dataSourceType?: string(name='DataSourceType'),
          deviceCode?: string(name='DeviceCode'),
          deviceComputeStatus?: string(name='DeviceComputeStatus'),
          deviceGroup?: string(name='DeviceGroup'),
          deviceName?: string(name='DeviceName'),
          deviceSn?: string(name='DeviceSn'),
          deviceStatus?: string(name='DeviceStatus'),
          deviceStreamStatus?: string(name='DeviceStreamStatus'),
          installAddress?: string(name='InstallAddress'),
          regionId?: string(name='RegionId'),
          regionName?: string(name='RegionName'),
          resolvingPower?: string(name='ResolvingPower'),
          type?: string(name='Type'),
        }
      ](name='List'),
      totalCount?: string(name='TotalCount'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDeviceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceGroupsResponseBody(name='body'),
}

async function listDeviceGroupsWithOptions(request: ListDeviceGroupsRequest, runtime: Util.RuntimeOptions): ListDeviceGroupsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.dataSourceType)) {
    body['DataSourceType'] = request.dataSourceType;
  }
  if (!Util.isUnset(request.deviceCodeList)) {
    body['DeviceCodeList'] = request.deviceCodeList;
  }
  if (!Util.isUnset(request.group)) {
    body['Group'] = request.group;
  }
  if (!Util.isUnset(request.isPage)) {
    body['IsPage'] = request.isPage;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceGroups',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceGroups(request: ListDeviceGroupsRequest): ListDeviceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceGroupsWithOptions(request, runtime);
}

model ListDevicesRequest {
  corpId?: string(name='CorpId'),
  deviceName?: string(name='DeviceName'),
  gbId?: string(name='GbId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model ListDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        accessProtocolType?: string(name='AccessProtocolType'),
        bitRate?: string(name='BitRate'),
        coverImageUrl?: string(name='CoverImageUrl'),
        createTime?: string(name='CreateTime'),
        deviceAddress?: string(name='DeviceAddress'),
        deviceDirection?: string(name='DeviceDirection'),
        deviceName?: string(name='DeviceName'),
        deviceSite?: string(name='DeviceSite'),
        deviceType?: string(name='DeviceType'),
        gbId?: string(name='GbId'),
        latitude?: string(name='Latitude'),
        longitude?: string(name='Longitude'),
        resolution?: string(name='Resolution'),
        sipGBId?: string(name='SipGBId'),
        sipPassword?: string(name='SipPassword'),
        sipServerIp?: string(name='SipServerIp'),
        sipServerPort?: string(name='SipServerPort'),
        status?: int32(name='Status'),
        vendor?: string(name='Vendor'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevicesResponseBody(name='body'),
}

async function listDevicesWithOptions(request: ListDevicesRequest, runtime: Util.RuntimeOptions): ListDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevices(request: ListDevicesRequest): ListDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicesWithOptions(request, runtime);
}

model ListEventAlgorithmDetailsRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  eventType?: string(name='EventType'),
  eventValue?: string(name='EventValue'),
  extendValue?: string(name='ExtendValue'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  recordId?: string(name='RecordId'),
  sourceId?: string(name='SourceId'),
  startTime?: string(name='StartTime'),
}

model ListEventAlgorithmDetailsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpId?: string(name='CorpId'),
      dataSourceId?: string(name='DataSourceId'),
      eventType?: string(name='EventType'),
      eventValue?: string(name='EventValue'),
      extendValue?: string(name='ExtendValue'),
      extraExtendValue?: string(name='ExtraExtendValue'),
      faceCount?: string(name='FaceCount'),
      leftTopX?: string(name='LeftTopX'),
      leftTopY?: string(name='LeftTopY'),
      picUrlPath?: string(name='PicUrlPath'),
      pointX?: string(name='PointX'),
      pointY?: string(name='PointY'),
      recordId?: string(name='RecordId'),
      rightBottomX?: string(name='RightBottomX'),
      rightBottomY?: string(name='RightBottomY'),
      shotTime?: string(name='ShotTime'),
      sourceId?: string(name='SourceId'),
      tagCode?: string(name='TagCode'),
      tagCodeReliability?: string(name='TagCodeReliability'),
      targetPicUrlPath?: string(name='TargetPicUrlPath'),
      uuidCode?: string(name='UuidCode'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListEventAlgorithmDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventAlgorithmDetailsResponseBody(name='body'),
}

async function listEventAlgorithmDetailsWithOptions(request: ListEventAlgorithmDetailsRequest, runtime: Util.RuntimeOptions): ListEventAlgorithmDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    body['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.eventValue)) {
    body['EventValue'] = request.eventValue;
  }
  if (!Util.isUnset(request.extendValue)) {
    body['ExtendValue'] = request.extendValue;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recordId)) {
    body['RecordId'] = request.recordId;
  }
  if (!Util.isUnset(request.sourceId)) {
    body['SourceId'] = request.sourceId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEventAlgorithmDetails',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventAlgorithmDetails(request: ListEventAlgorithmDetailsRequest): ListEventAlgorithmDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventAlgorithmDetailsWithOptions(request, runtime);
}

model ListEventAlgorithmResultsRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  eventType?: string(name='EventType'),
  extendValue?: string(name='ExtendValue'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model ListEventAlgorithmResultsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        capStyle?: string(name='CapStyle'),
        corpId?: string(name='CorpId'),
        dataSourceId?: string(name='DataSourceId'),
        eventType?: string(name='EventType'),
        extendValue?: string(name='ExtendValue'),
        extendValueThree?: string(name='ExtendValueThree'),
        extendValueTwo?: string(name='ExtendValueTwo'),
        faceCount?: string(name='FaceCount'),
        picUrlPath?: string(name='PicUrlPath'),
        recordId?: string(name='RecordId'),
        shotTime?: string(name='ShotTime'),
        tagCode?: string(name='TagCode'),
        tagCodeReliability?: string(name='TagCodeReliability'),
        targetPicUrlPath?: string(name='TargetPicUrlPath'),
        uuidCode?: string(name='UuidCode'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  extendValue?: string(name='ExtendValue'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListEventAlgorithmResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventAlgorithmResultsResponseBody(name='body'),
}

async function listEventAlgorithmResultsWithOptions(request: ListEventAlgorithmResultsRequest, runtime: Util.RuntimeOptions): ListEventAlgorithmResultsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.eventType)) {
    body['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.extendValue)) {
    body['ExtendValue'] = request.extendValue;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListEventAlgorithmResults',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventAlgorithmResults(request: ListEventAlgorithmResultsRequest): ListEventAlgorithmResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventAlgorithmResultsWithOptions(request, runtime);
}

model ListFaceAlgorithmResultsRequest {
  algorithmType?: string(name='AlgorithmType'),
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model ListFaceAlgorithmResultsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        capStyle?: string(name='CapStyle'),
        corpId?: string(name='CorpId'),
        dataSourceId?: string(name='DataSourceId'),
        faceId?: string(name='FaceId'),
        genderCode?: string(name='GenderCode'),
        hairStyle?: string(name='HairStyle'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        maxAge?: string(name='MaxAge'),
        minAge?: string(name='MinAge'),
        picUrlPath?: string(name='PicUrlPath'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        shotTime?: string(name='ShotTime'),
        sourceId?: string(name='SourceId'),
        targetPicUrlPath?: string(name='TargetPicUrlPath'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListFaceAlgorithmResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListFaceAlgorithmResultsResponseBody(name='body'),
}

async function listFaceAlgorithmResultsWithOptions(request: ListFaceAlgorithmResultsRequest, runtime: Util.RuntimeOptions): ListFaceAlgorithmResultsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListFaceAlgorithmResults',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listFaceAlgorithmResults(request: ListFaceAlgorithmResultsRequest): ListFaceAlgorithmResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listFaceAlgorithmResultsWithOptions(request, runtime);
}

model ListInstancesRequest {
  currentPage?: int32(name='CurrentPage'),
  instanceName?: string(name='InstanceName'),
  pageSize?: int32(name='PageSize'),
  projectId?: string(name='ProjectId'),
}

model ListInstancesResponseBody = {
  code?: string(name='Code'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    items?: [ 
      {
        acuUsed?: int32(name='AcuUsed'),
        algorithms?: [ 
          {
            algorithmId?: string(name='AlgorithmId'),
            algorithmName?: string(name='AlgorithmName'),
          }
        ](name='Algorithms'),
        createTime?: long(name='CreateTime'),
        deviceNumber?: int32(name='DeviceNumber'),
        instanceId?: string(name='InstanceId'),
        instanceName?: string(name='InstanceName'),
        status?: string(name='Status'),
      }
    ](name='Items'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(request: ListInstancesRequest, runtime: Util.RuntimeOptions): ListInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentPage)) {
    query['CurrentPage'] = request.currentPage;
  }
  if (!Util.isUnset(request.instanceName)) {
    query['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.projectId)) {
    query['ProjectId'] = request.projectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(request: ListInstancesRequest): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(request, runtime);
}

model ListMetricsRequest {
  aggregateType?: string(name='AggregateType'),
  corpId?: string(name='CorpId'),
  endTime?: string(name='EndTime'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
  tagCode?: string(name='TagCode'),
}

model ListMetricsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        dateTime?: string(name='DateTime'),
        tagCode?: string(name='TagCode'),
        tagMetric?: string(name='TagMetric'),
        tagValue?: string(name='TagValue'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMetricsResponseBody(name='body'),
}

async function listMetricsWithOptions(request: ListMetricsRequest, runtime: Util.RuntimeOptions): ListMetricsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregateType)) {
    body['AggregateType'] = request.aggregateType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagCode)) {
    body['TagCode'] = request.tagCode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMetrics',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMetrics(request: ListMetricsRequest): ListMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMetricsWithOptions(request, runtime);
}

model ListMotorAlgorithmResultsRequest {
  algorithmType?: string(name='AlgorithmType'),
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  plateNumber?: string(name='PlateNumber'),
  startTime?: string(name='StartTime'),
}

model ListMotorAlgorithmResultsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        calling?: string(name='Calling'),
        corpId?: string(name='CorpId'),
        dataSourceId?: string(name='DataSourceId'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        motorBrand?: string(name='MotorBrand'),
        motorClass?: string(name='MotorClass'),
        motorColor?: string(name='MotorColor'),
        motorId?: string(name='MotorId'),
        motorModel?: string(name='MotorModel'),
        motorStyle?: string(name='MotorStyle'),
        picUrlPath?: string(name='PicUrlPath'),
        plateClass?: string(name='PlateClass'),
        plateColor?: string(name='PlateColor'),
        plateNumber?: string(name='PlateNumber'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        safetyBelt?: string(name='SafetyBelt'),
        shotTime?: string(name='ShotTime'),
        sourceId?: string(name='SourceId'),
        targetPicUrlPath?: string(name='TargetPicUrlPath'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListMotorAlgorithmResultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMotorAlgorithmResultsResponseBody(name='body'),
}

async function listMotorAlgorithmResultsWithOptions(request: ListMotorAlgorithmResultsRequest, runtime: Util.RuntimeOptions): ListMotorAlgorithmResultsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.plateNumber)) {
    body['PlateNumber'] = request.plateNumber;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListMotorAlgorithmResults',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMotorAlgorithmResults(request: ListMotorAlgorithmResultsRequest): ListMotorAlgorithmResultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMotorAlgorithmResultsWithOptions(request, runtime);
}

model ListNVRChannelDeviceRequest {
  deviceCode?: string(name='DeviceCode'),
  isPage?: string(name='IsPage'),
  pageNum?: string(name='PageNum'),
  pageSize?: string(name='PageSize'),
}

model ListNVRChannelDeviceResponseBody = {
  data?: [ 
    {
      comptureStatus?: string(name='ComptureStatus'),
      corpId?: string(name='CorpId'),
      datasourceType?: string(name='DatasourceType'),
      deviceCode?: string(name='DeviceCode'),
      deviceName?: string(name='DeviceName'),
      deviceSn?: string(name='DeviceSn'),
      deviceStatus?: string(name='DeviceStatus'),
      deviceType?: string(name='DeviceType'),
      projectName?: string(name='ProjectName'),
      regionName?: string(name='RegionName'),
      sampleName?: string(name='SampleName'),
      streamStatus?: string(name='StreamStatus'),
      vap?: string(name='Vap'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model ListNVRChannelDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNVRChannelDeviceResponseBody(name='body'),
}

async function listNVRChannelDeviceWithOptions(request: ListNVRChannelDeviceRequest, runtime: Util.RuntimeOptions): ListNVRChannelDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCode)) {
    body['DeviceCode'] = request.deviceCode;
  }
  if (!Util.isUnset(request.isPage)) {
    body['IsPage'] = request.isPage;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListNVRChannelDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNVRChannelDevice(request: ListNVRChannelDeviceRequest): ListNVRChannelDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNVRChannelDeviceWithOptions(request, runtime);
}

model ListNVRDeviceRequest {
  corpIdList?: string(name='CorpIdList'),
  deviceCode?: string(name='DeviceCode'),
  isPage?: long(name='IsPage'),
  pageNum?: long(name='PageNum'),
  pageSize?: long(name='PageSize'),
}

model ListNVRDeviceResponseBody = {
  data?: [ 
    {
      accessQuota?: string(name='AccessQuota'),
      channel?: string(name='Channel'),
      comptureStatus?: string(name='ComptureStatus'),
      corpId?: string(name='CorpId'),
      datasourceType?: string(name='DatasourceType'),
      deviceCode?: string(name='DeviceCode'),
      deviceName?: string(name='DeviceName'),
      deviceSn?: string(name='DeviceSn'),
      deviceStatus?: string(name='DeviceStatus'),
      deviceType?: string(name='DeviceType'),
      projectName?: string(name='ProjectName'),
      regionName?: string(name='RegionName'),
      registrationTime?: string(name='RegistrationTime'),
      streamStatus?: string(name='StreamStatus'),
      type?: string(name='Type'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  total?: string(name='Total'),
}

model ListNVRDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNVRDeviceResponseBody(name='body'),
}

async function listNVRDeviceWithOptions(request: ListNVRDeviceRequest, runtime: Util.RuntimeOptions): ListNVRDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpIdList)) {
    body['CorpIdList'] = request.corpIdList;
  }
  if (!Util.isUnset(request.deviceCode)) {
    body['DeviceCode'] = request.deviceCode;
  }
  if (!Util.isUnset(request.isPage)) {
    body['IsPage'] = request.isPage;
  }
  if (!Util.isUnset(request.pageNum)) {
    body['PageNum'] = request.pageNum;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListNVRDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNVRDevice(request: ListNVRDeviceRequest): ListNVRDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNVRDeviceWithOptions(request, runtime);
}

model ListPersonTraceRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  groupId?: string(name='GroupId'),
  pageNumber?: string(name='PageNumber'),
  pageSize?: string(name='PageSize'),
  personId?: string(name='PersonId'),
  startTime?: string(name='StartTime'),
}

model ListPersonTraceResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpId?: string(name='CorpId'),
      date?: string(name='Date'),
      deviceId?: string(name='DeviceId'),
      endSourceImage?: string(name='EndSourceImage'),
      endTargetImage?: string(name='EndTargetImage'),
      groupId?: string(name='GroupId'),
      lastTime?: string(name='LastTime'),
      personId?: string(name='PersonId'),
      startSourceImage?: string(name='StartSourceImage'),
      startTargetImage?: string(name='StartTargetImage'),
      startTime?: string(name='StartTime'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model ListPersonTraceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPersonTraceResponseBody(name='body'),
}

async function listPersonTraceWithOptions(request: ListPersonTraceRequest, runtime: Util.RuntimeOptions): ListPersonTraceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPersonTrace',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPersonTrace(request: ListPersonTraceRequest): ListPersonTraceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPersonTraceWithOptions(request, runtime);
}

model ListPersonTraceDetailsRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personId?: string(name='PersonId'),
  startTime?: string(name='StartTime'),
  subId?: string(name='SubId'),
}

model ListPersonTraceDetailsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpId?: string(name='CorpId'),
      dataSourceId?: string(name='DataSourceId'),
      leftTopX?: string(name='LeftTopX'),
      leftTopY?: string(name='LeftTopY'),
      personId?: string(name='PersonId'),
      picUrlPath?: string(name='PicUrlPath'),
      rightBottomX?: string(name='RightBottomX'),
      rightBottomY?: string(name='RightBottomY'),
      shotTime?: string(name='ShotTime'),
      subId?: string(name='SubId'),
      targetPicUrlPath?: string(name='TargetPicUrlPath'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
}

model ListPersonTraceDetailsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPersonTraceDetailsResponseBody(name='body'),
}

async function listPersonTraceDetailsWithOptions(request: ListPersonTraceDetailsRequest, runtime: Util.RuntimeOptions): ListPersonTraceDetailsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personId)) {
    body['PersonId'] = request.personId;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.subId)) {
    body['SubId'] = request.subId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPersonTraceDetails',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPersonTraceDetails(request: ListPersonTraceDetailsRequest): ListPersonTraceDetailsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPersonTraceDetailsWithOptions(request, runtime);
}

model ListPersonVisitCountRequest {
  aggregateType?: string(name='AggregateType'),
  corpId?: string(name='CorpId'),
  countType?: string(name='CountType'),
  endTime?: string(name='EndTime'),
  maxVal?: int32(name='MaxVal'),
  minVal?: int32(name='MinVal'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  startTime?: string(name='StartTime'),
  tagCode?: string(name='TagCode'),
  timeAggregateType?: string(name='TimeAggregateType'),
}

model ListPersonVisitCountResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      corpId?: string(name='CorpId'),
      dayId?: string(name='DayId'),
      deviceId?: string(name='DeviceId'),
      groupId?: string(name='GroupId'),
      hourId?: string(name='HourId'),
      personId?: string(name='PersonId'),
      tagCode?: string(name='TagCode'),
      tagMetrics?: string(name='TagMetrics'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
  totalCount?: string(name='TotalCount'),
}

model ListPersonVisitCountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPersonVisitCountResponseBody(name='body'),
}

async function listPersonVisitCountWithOptions(request: ListPersonVisitCountRequest, runtime: Util.RuntimeOptions): ListPersonVisitCountResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.aggregateType)) {
    body['AggregateType'] = request.aggregateType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.countType)) {
    body['CountType'] = request.countType;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.maxVal)) {
    body['MaxVal'] = request.maxVal;
  }
  if (!Util.isUnset(request.minVal)) {
    body['MinVal'] = request.minVal;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tagCode)) {
    body['TagCode'] = request.tagCode;
  }
  if (!Util.isUnset(request.timeAggregateType)) {
    body['TimeAggregateType'] = request.timeAggregateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPersonVisitCount',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPersonVisitCount(request: ListPersonVisitCountRequest): ListPersonVisitCountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPersonVisitCountWithOptions(request, runtime);
}

model ListPersonsRequest {
  algorithmType?: string(name='AlgorithmType'),
  corpId?: string(name='CorpId'),
  endTime?: string(name='EndTime'),
  pageNo?: string(name='PageNo'),
  pageSize?: string(name='PageSize'),
  startTime?: string(name='StartTime'),
}

model ListPersonsResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNo?: string(name='PageNo'),
    pageSize?: string(name='PageSize'),
    records?: [ 
      {
        firstAppearTime?: string(name='FirstAppearTime'),
        personId?: string(name='PersonId'),
        picUrl?: string(name='PicUrl'),
        tagList?: [ 
          {
            tagCode?: string(name='TagCode'),
            tagName?: string(name='TagName'),
            tagValue?: string(name='TagValue'),
            tagValueId?: string(name='TagValueId'),
          }
        ](name='TagList'),
      }
    ](name='Records'),
    totalCount?: string(name='TotalCount'),
    totalPage?: string(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListPersonsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPersonsResponseBody(name='body'),
}

async function listPersonsWithOptions(request: ListPersonsRequest, runtime: Util.RuntimeOptions): ListPersonsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListPersons',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPersons(request: ListPersonsRequest): ListPersonsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPersonsWithOptions(request, runtime);
}

model ListUserGroupsRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
}

model ListUserGroupsResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      createTime?: string(name='CreateTime'),
      creator?: string(name='Creator'),
      isvSubId?: string(name='IsvSubId'),
      parentUserGroupId?: long(name='ParentUserGroupId'),
      updateTime?: string(name='UpdateTime'),
      userCount?: long(name='UserCount'),
      userGroupId?: long(name='UserGroupId'),
      userGroupName?: string(name='UserGroupName'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListUserGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserGroupsResponseBody(name='body'),
}

async function listUserGroupsWithOptions(request: ListUserGroupsRequest, runtime: Util.RuntimeOptions): ListUserGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.corpId)) {
    query['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    query['IsvSubId'] = request.isvSubId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserGroups',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserGroups(request: ListUserGroupsRequest): ListUserGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserGroupsWithOptions(request, runtime);
}

model ListUsersRequest {
  address?: string(name='Address'),
  age?: int32(name='Age'),
  attachment?: string(name='Attachment'),
  bizId?: string(name='BizId'),
  corpId?: string(name='CorpId'),
  faceImageUrl?: string(name='FaceImageUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  matchingRateThreshold?: string(name='MatchingRateThreshold'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personList?: map[string]any(name='PersonList'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  userGroupId?: long(name='UserGroupId'),
  userList?: map[string]any(name='UserList'),
  userName?: string(name='UserName'),
}

model ListUsersShrinkRequest {
  address?: string(name='Address'),
  age?: int32(name='Age'),
  attachment?: string(name='Attachment'),
  bizId?: string(name='BizId'),
  corpId?: string(name='CorpId'),
  faceImageUrl?: string(name='FaceImageUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  matchingRateThreshold?: string(name='MatchingRateThreshold'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  personListShrink?: string(name='PersonList'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  userGroupId?: long(name='UserGroupId'),
  userListShrink?: string(name='UserList'),
  userName?: string(name='UserName'),
}

model ListUsersResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        age?: string(name='Age'),
        attachment?: string(name='Attachment'),
        bizId?: string(name='BizId'),
        faceImageUrl?: string(name='FaceImageUrl'),
        gender?: string(name='Gender'),
        idNumber?: string(name='IdNumber'),
        isvSubId?: string(name='IsvSubId'),
        matchingRate?: string(name='MatchingRate'),
        personId?: string(name='PersonId'),
        userGroupId?: int32(name='UserGroupId'),
        userId?: int32(name='UserId'),
        userName?: string(name='UserName'),
      }
    ](name='Records'),
    success?: long(name='Success'),
    total?: long(name='Total'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ListUsersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsersResponseBody(name='body'),
}

async function listUsersWithOptions(tmpReq: ListUsersRequest, runtime: Util.RuntimeOptions): ListUsersResponse {
  Util.validateModel(tmpReq);
  var request = new ListUsersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.personList)) {
    request.personListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.personList, 'PersonList', 'json');
  }
  if (!Util.isUnset(tmpReq.userList)) {
    request.userListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.userList, 'UserList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.age)) {
    body['Age'] = request.age;
  }
  if (!Util.isUnset(request.attachment)) {
    body['Attachment'] = request.attachment;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceImageUrl)) {
    body['FaceImageUrl'] = request.faceImageUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.matchingRateThreshold)) {
    body['MatchingRateThreshold'] = request.matchingRateThreshold;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.personListShrink)) {
    body['PersonList'] = request.personListShrink;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.userGroupId)) {
    body['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userListShrink)) {
    body['UserList'] = request.userListShrink;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListUsers',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsers(request: ListUsersRequest): ListUsersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsersWithOptions(request, runtime);
}

model ModifyDeviceRequest {
  audioEnable?: string(name='AudioEnable'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceDirection?: string(name='DeviceDirection'),
  deviceId?: string(name='DeviceId'),
  deviceIp?: string(name='DeviceIp'),
  deviceModel?: string(name='DeviceModel'),
  deviceName?: string(name='DeviceName'),
  deviceRate?: string(name='DeviceRate'),
  deviceResolution?: string(name='DeviceResolution'),
  deviceSite?: string(name='DeviceSite'),
  deviceSubType?: string(name='DeviceSubType'),
  encodeFormat?: string(name='EncodeFormat'),
  frameRate?: string(name='FrameRate'),
  govLength?: string(name='GovLength'),
  latitude?: string(name='Latitude'),
  longitude?: string(name='Longitude'),
  OSDTimeEnable?: string(name='OSDTimeEnable'),
  OSDTimeType?: string(name='OSDTimeType'),
  OSDTimeX?: string(name='OSDTimeX'),
  OSDTimeY?: string(name='OSDTimeY'),
  password?: string(name='Password'),
  vendor?: string(name='Vendor'),
}

model ModifyDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ModifyDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDeviceResponseBody(name='body'),
}

async function modifyDeviceWithOptions(request: ModifyDeviceRequest, runtime: Util.RuntimeOptions): ModifyDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.audioEnable)) {
    body['AudioEnable'] = request.audioEnable;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceDirection)) {
    body['DeviceDirection'] = request.deviceDirection;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceIp)) {
    body['DeviceIp'] = request.deviceIp;
  }
  if (!Util.isUnset(request.deviceModel)) {
    body['DeviceModel'] = request.deviceModel;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceRate)) {
    body['DeviceRate'] = request.deviceRate;
  }
  if (!Util.isUnset(request.deviceResolution)) {
    body['DeviceResolution'] = request.deviceResolution;
  }
  if (!Util.isUnset(request.deviceSite)) {
    body['DeviceSite'] = request.deviceSite;
  }
  if (!Util.isUnset(request.deviceSubType)) {
    body['DeviceSubType'] = request.deviceSubType;
  }
  if (!Util.isUnset(request.encodeFormat)) {
    body['EncodeFormat'] = request.encodeFormat;
  }
  if (!Util.isUnset(request.frameRate)) {
    body['FrameRate'] = request.frameRate;
  }
  if (!Util.isUnset(request.govLength)) {
    body['GovLength'] = request.govLength;
  }
  if (!Util.isUnset(request.latitude)) {
    body['Latitude'] = request.latitude;
  }
  if (!Util.isUnset(request.longitude)) {
    body['Longitude'] = request.longitude;
  }
  if (!Util.isUnset(request.OSDTimeEnable)) {
    body['OSDTimeEnable'] = request.OSDTimeEnable;
  }
  if (!Util.isUnset(request.OSDTimeType)) {
    body['OSDTimeType'] = request.OSDTimeType;
  }
  if (!Util.isUnset(request.OSDTimeX)) {
    body['OSDTimeX'] = request.OSDTimeX;
  }
  if (!Util.isUnset(request.OSDTimeY)) {
    body['OSDTimeY'] = request.OSDTimeY;
  }
  if (!Util.isUnset(request.password)) {
    body['Password'] = request.password;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDevice(request: ModifyDeviceRequest): ModifyDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDeviceWithOptions(request, runtime);
}

model PeekNvrRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
}

model PeekNvrResponseBody = {
  code?: string(name='Code'),
  data?: {
    idleCount?: long(name='IdleCount'),
    subDeviceList?: [ 
      {
        associatedPlatform?: string(name='AssociatedPlatform'),
        subDeviceId?: string(name='SubDeviceId'),
        subDeviceName?: string(name='SubDeviceName'),
        subDeviceNum?: string(name='SubDeviceNum'),
        subDeviceStatus?: string(name='SubDeviceStatus'),
      }
    ](name='SubDeviceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model PeekNvrResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PeekNvrResponseBody(name='body'),
}

async function peekNvrWithOptions(request: PeekNvrRequest, runtime: Util.RuntimeOptions): PeekNvrResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'PeekNvr',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function peekNvr(request: PeekNvrRequest): PeekNvrResponse {
  var runtime = new Util.RuntimeOptions{};
  return peekNvrWithOptions(request, runtime);
}

model RaiseDevicesStorageRequest {
  json?: string(name='Json'),
}

model RaiseDevicesStorageResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RaiseDevicesStorageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RaiseDevicesStorageResponseBody(name='body'),
}

async function raiseDevicesStorageWithOptions(request: RaiseDevicesStorageRequest, runtime: Util.RuntimeOptions): RaiseDevicesStorageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.json)) {
    body['Json'] = request.json;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RaiseDevicesStorage',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function raiseDevicesStorage(request: RaiseDevicesStorageRequest): RaiseDevicesStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return raiseDevicesStorageWithOptions(request, runtime);
}

model RecognizeFaceQualityRequest {
  corpId?: string(name='CorpId'),
  picContent?: string(name='PicContent'),
  picFormat?: string(name='PicFormat'),
  picUrl?: string(name='PicUrl'),
}

model RecognizeFaceQualityResponseBody = {
  code?: string(name='Code'),
  data?: {
    attributes?: {
      faceQuality?: string(name='FaceQuality'),
      faceScore?: string(name='FaceScore'),
      faceStyle?: string(name='FaceStyle'),
      leftTopX?: int32(name='LeftTopX'),
      leftTopY?: int32(name='LeftTopY'),
      rightBottomX?: int32(name='RightBottomX'),
      rightBottomY?: int32(name='RightBottomY'),
      targetImageStoragePath?: string(name='TargetImageStoragePath'),
    }(name='Attributes'),
    description?: string(name='Description'),
    qualityScore?: string(name='QualityScore'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RecognizeFaceQualityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeFaceQualityResponseBody(name='body'),
}

async function recognizeFaceQualityWithOptions(request: RecognizeFaceQualityRequest, runtime: Util.RuntimeOptions): RecognizeFaceQualityResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.picContent)) {
    body['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picFormat)) {
    body['PicFormat'] = request.picFormat;
  }
  if (!Util.isUnset(request.picUrl)) {
    body['PicUrl'] = request.picUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeFaceQuality',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeFaceQuality(request: RecognizeFaceQualityRequest): RecognizeFaceQualityResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeFaceQualityWithOptions(request, runtime);
}

model RecognizeImageRequest {
  corpId?: string(name='CorpId'),
  picContent?: string(name='PicContent'),
  picFormat?: string(name='PicFormat'),
  picUrl?: string(name='PicUrl'),
}

model RecognizeImageResponseBody = {
  code?: string(name='Code'),
  data?: {
    bodyList?: [ 
      {
        feature?: string(name='Feature'),
        fileName?: string(name='FileName'),
        imageBaseSixFour?: string(name='ImageBaseSixFour'),
        leftTopX?: string(name='LeftTopX'),
        leftTopY?: string(name='LeftTopY'),
        localFeature?: string(name='LocalFeature'),
        respiratorColor?: string(name='RespiratorColor'),
        rightBottomX?: string(name='RightBottomX'),
        rightBottomY?: string(name='RightBottomY'),
      }
    ](name='BodyList'),
    faceList?: [ 
      {
        feature?: string(name='Feature'),
        fileName?: string(name='FileName'),
        imageBaseSixFour?: string(name='ImageBaseSixFour'),
        keyPointQuality?: float(name='KeyPointQuality'),
        leftTopX?: string(name='LeftTopX'),
        leftTopY?: string(name='LeftTopY'),
        localFeature?: string(name='LocalFeature'),
        quality?: float(name='Quality'),
        respiratorColor?: string(name='RespiratorColor'),
        rightBottomX?: string(name='RightBottomX'),
        rightBottomY?: string(name='RightBottomY'),
      }
    ](name='FaceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RecognizeImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecognizeImageResponseBody(name='body'),
}

async function recognizeImageWithOptions(request: RecognizeImageRequest, runtime: Util.RuntimeOptions): RecognizeImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.picContent)) {
    body['PicContent'] = request.picContent;
  }
  if (!Util.isUnset(request.picFormat)) {
    body['PicFormat'] = request.picFormat;
  }
  if (!Util.isUnset(request.picUrl)) {
    body['PicUrl'] = request.picUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RecognizeImage',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recognizeImage(request: RecognizeImageRequest): RecognizeImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return recognizeImageWithOptions(request, runtime);
}

model RegisterDeviceRequest {
  deviceId?: string(name='DeviceId'),
  deviceSn?: string(name='DeviceSn'),
  deviceTimeStamp?: string(name='DeviceTimeStamp'),
  serverId?: string(name='ServerId'),
}

model RegisterDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  retryInterval?: string(name='RetryInterval'),
}

model RegisterDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterDeviceResponseBody(name='body'),
}

async function registerDeviceWithOptions(request: RegisterDeviceRequest, runtime: Util.RuntimeOptions): RegisterDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.deviceSn)) {
    body['DeviceSn'] = request.deviceSn;
  }
  if (!Util.isUnset(request.deviceTimeStamp)) {
    body['DeviceTimeStamp'] = request.deviceTimeStamp;
  }
  if (!Util.isUnset(request.serverId)) {
    body['ServerId'] = request.serverId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerDevice(request: RegisterDeviceRequest): RegisterDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerDeviceWithOptions(request, runtime);
}

model RemoveCameraForInstanceRequest {
  cameraIds?: [ string ](name='CameraIds'),
  instanceId?: string(name='InstanceId'),
}

model RemoveCameraForInstanceShrinkRequest {
  cameraIdsShrink?: string(name='CameraIds'),
  instanceId?: string(name='InstanceId'),
}

model RemoveCameraForInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model RemoveCameraForInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveCameraForInstanceResponseBody(name='body'),
}

async function removeCameraForInstanceWithOptions(tmpReq: RemoveCameraForInstanceRequest, runtime: Util.RuntimeOptions): RemoveCameraForInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new RemoveCameraForInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.cameraIds)) {
    request.cameraIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.cameraIds, 'CameraIds', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.cameraIdsShrink)) {
    body['CameraIds'] = request.cameraIdsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveCameraForInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeCameraForInstance(request: RemoveCameraForInstanceRequest): RemoveCameraForInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeCameraForInstanceWithOptions(request, runtime);
}

model RemoveSearchItemsRequest {
  searchItemIds?: string(name='SearchItemIds'),
  searchTableId?: string(name='SearchTableId'),
}

model RemoveSearchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    deletedItemIds?: string(name='DeletedItemIds'),
    failedItemIds?: string(name='FailedItemIds'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: string(name='Success'),
}

model RemoveSearchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveSearchItemsResponseBody(name='body'),
}

async function removeSearchItemsWithOptions(request: RemoveSearchItemsRequest, runtime: Util.RuntimeOptions): RemoveSearchItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.searchItemIds)) {
    body['SearchItemIds'] = request.searchItemIds;
  }
  if (!Util.isUnset(request.searchTableId)) {
    body['SearchTableId'] = request.searchTableId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveSearchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeSearchItems(request: RemoveSearchItemsRequest): RemoveSearchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeSearchItemsWithOptions(request, runtime);
}

model RemoveWatchItemsRequest {
  watchItemIds?: string(name='WatchItemIds'),
  watchPolicyId?: string(name='WatchPolicyId'),
}

model RemoveWatchItemsResponseBody = {
  code?: string(name='Code'),
  data?: {
    deletedItemIds?: string(name='DeletedItemIds'),
    failedItemIds?: string(name='FailedItemIds'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RemoveWatchItemsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveWatchItemsResponseBody(name='body'),
}

async function removeWatchItemsWithOptions(request: RemoveWatchItemsRequest, runtime: Util.RuntimeOptions): RemoveWatchItemsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.watchItemIds)) {
    body['WatchItemIds'] = request.watchItemIds;
  }
  if (!Util.isUnset(request.watchPolicyId)) {
    body['WatchPolicyId'] = request.watchPolicyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemoveWatchItems',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeWatchItems(request: RemoveWatchItemsRequest): RemoveWatchItemsResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeWatchItemsWithOptions(request, runtime);
}

model SaveVideoSummaryTaskVideoRequest {
  corpId?: string(name='CorpId'),
  saveVideo?: boolean(name='SaveVideo'),
  taskId?: long(name='TaskId'),
}

model SaveVideoSummaryTaskVideoResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SaveVideoSummaryTaskVideoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SaveVideoSummaryTaskVideoResponseBody(name='body'),
}

async function saveVideoSummaryTaskVideoWithOptions(request: SaveVideoSummaryTaskVideoRequest, runtime: Util.RuntimeOptions): SaveVideoSummaryTaskVideoResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.saveVideo)) {
    body['SaveVideo'] = request.saveVideo;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SaveVideoSummaryTaskVideo',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function saveVideoSummaryTaskVideo(request: SaveVideoSummaryTaskVideoRequest): SaveVideoSummaryTaskVideoResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveVideoSummaryTaskVideoWithOptions(request, runtime);
}

model ScanSubDeviceRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
}

model ScanSubDeviceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model ScanSubDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ScanSubDeviceResponseBody(name='body'),
}

async function scanSubDeviceWithOptions(request: ScanSubDeviceRequest, runtime: Util.RuntimeOptions): ScanSubDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ScanSubDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function scanSubDevice(request: ScanSubDeviceRequest): ScanSubDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return scanSubDeviceWithOptions(request, runtime);
}

model SearchBodyRequest {
  corpId?: string(name='CorpId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  gbId?: string(name='GbId'),
  optionList?: map[string]any(name='OptionList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  startTimeStamp?: long(name='StartTimeStamp'),
}

model SearchBodyShrinkRequest {
  corpId?: string(name='CorpId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  gbId?: string(name='GbId'),
  optionListShrink?: string(name='OptionList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  startTimeStamp?: long(name='StartTimeStamp'),
}

model SearchBodyResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        gbId?: string(name='GbId'),
        imageUrl?: string(name='ImageUrl'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        score?: float(name='Score'),
        targetImageUrl?: string(name='TargetImageUrl'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SearchBodyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchBodyResponseBody(name='body'),
}

async function searchBodyWithOptions(tmpReq: SearchBodyRequest, runtime: Util.RuntimeOptions): SearchBodyResponse {
  Util.validateModel(tmpReq);
  var request = new SearchBodyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.optionList)) {
    request.optionListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.optionList, 'OptionList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    body['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.optionListShrink)) {
    body['OptionList'] = request.optionListShrink;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    body['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchBody',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchBody(request: SearchBodyRequest): SearchBodyResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchBodyWithOptions(request, runtime);
}

model SearchFaceRequest {
  corpId?: string(name='CorpId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  gbId?: string(name='GbId'),
  optionList?: map[string]any(name='OptionList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  startTimeStamp?: long(name='StartTimeStamp'),
}

model SearchFaceShrinkRequest {
  corpId?: string(name='CorpId'),
  endTimeStamp?: long(name='EndTimeStamp'),
  gbId?: string(name='GbId'),
  optionListShrink?: string(name='OptionList'),
  pageNo?: int32(name='PageNo'),
  pageSize?: int32(name='PageSize'),
  startTimeStamp?: long(name='StartTimeStamp'),
}

model SearchFaceResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNo?: int32(name='PageNo'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        gbId?: string(name='GbId'),
        imageUrl?: string(name='ImageUrl'),
        leftTopX?: float(name='LeftTopX'),
        leftTopY?: float(name='LeftTopY'),
        matchSuggestion?: string(name='MatchSuggestion'),
        rightBottomX?: float(name='RightBottomX'),
        rightBottomY?: float(name='RightBottomY'),
        score?: float(name='Score'),
        sourceId?: string(name='SourceId'),
        targetImageUrl?: string(name='TargetImageUrl'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SearchFaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchFaceResponseBody(name='body'),
}

async function searchFaceWithOptions(tmpReq: SearchFaceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  Util.validateModel(tmpReq);
  var request = new SearchFaceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.optionList)) {
    request.optionListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.optionList, 'OptionList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.endTimeStamp)) {
    body['EndTimeStamp'] = request.endTimeStamp;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.optionListShrink)) {
    body['OptionList'] = request.optionListShrink;
  }
  if (!Util.isUnset(request.pageNo)) {
    body['PageNo'] = request.pageNo;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTimeStamp)) {
    body['StartTimeStamp'] = request.startTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchFace',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchFace(request: SearchFaceRequest): SearchFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchFaceWithOptions(request, runtime);
}

model SearchItemRequest {
  itemImageData?: string(name='ItemImageData'),
  itemImageUrl?: string(name='ItemImageUrl'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  searchTableIds?: string(name='SearchTableIds'),
  similarityThreshold?: double(name='SimilarityThreshold'),
}

model SearchItemResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        itemId?: string(name='ItemId'),
        itemImageSimilarity?: double(name='ItemImageSimilarity'),
        itemImageUrl?: string(name='ItemImageUrl'),
        itemName?: string(name='ItemName'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchItemResponseBody(name='body'),
}

async function searchItemWithOptions(request: SearchItemRequest, runtime: Util.RuntimeOptions): SearchItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.itemImageData)) {
    body['ItemImageData'] = request.itemImageData;
  }
  if (!Util.isUnset(request.itemImageUrl)) {
    body['ItemImageUrl'] = request.itemImageUrl;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.searchTableIds)) {
    body['SearchTableIds'] = request.searchTableIds;
  }
  if (!Util.isUnset(request.similarityThreshold)) {
    body['SimilarityThreshold'] = request.similarityThreshold;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchItem',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchItem(request: SearchItemRequest): SearchItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchItemWithOptions(request, runtime);
}

model SearchObjectRequest {
  algorithmType?: string(name='AlgorithmType'),
  conditions?: map[string]any(name='Conditions'),
  corpId?: string(name='CorpId'),
  deviceList?: map[string]any(name='DeviceList'),
  endTime?: long(name='EndTime'),
  imagePath?: map[string]any(name='ImagePath'),
  objectType?: string(name='ObjectType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  picUrl?: string(name='PicUrl'),
  startTime?: long(name='StartTime'),
}

model SearchObjectShrinkRequest {
  algorithmType?: string(name='AlgorithmType'),
  conditionsShrink?: string(name='Conditions'),
  corpId?: string(name='CorpId'),
  deviceListShrink?: string(name='DeviceList'),
  endTime?: long(name='EndTime'),
  imagePathShrink?: string(name='ImagePath'),
  objectType?: string(name='ObjectType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  picUrl?: string(name='PicUrl'),
  startTime?: long(name='StartTime'),
}

model SearchObjectResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    records?: [ 
      {
        compareResult?: string(name='CompareResult'),
        deviceID?: string(name='DeviceID'),
        leftTopX?: int32(name='LeftTopX'),
        leftTopY?: int32(name='LeftTopY'),
        rightBtmX?: int32(name='RightBtmX'),
        rightBtmY?: int32(name='RightBtmY'),
        score?: float(name='Score'),
        shotTime?: long(name='ShotTime'),
        sourceID?: string(name='SourceID'),
        sourceImagePath?: string(name='SourceImagePath'),
        sourceImageUrl?: string(name='SourceImageUrl'),
        targetImagePath?: string(name='TargetImagePath'),
        targetImageUrl?: string(name='TargetImageUrl'),
      }
    ](name='Records'),
    totalCount?: int32(name='TotalCount'),
    totalPage?: int32(name='TotalPage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SearchObjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchObjectResponseBody(name='body'),
}

async function searchObjectWithOptions(tmpReq: SearchObjectRequest, runtime: Util.RuntimeOptions): SearchObjectResponse {
  Util.validateModel(tmpReq);
  var request = new SearchObjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.conditions)) {
    request.conditionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.conditions, 'Conditions', 'json');
  }
  if (!Util.isUnset(tmpReq.deviceList)) {
    request.deviceListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceList, 'DeviceList', 'json');
  }
  if (!Util.isUnset(tmpReq.imagePath)) {
    request.imagePathShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.imagePath, 'ImagePath', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmType)) {
    body['AlgorithmType'] = request.algorithmType;
  }
  if (!Util.isUnset(request.conditionsShrink)) {
    body['Conditions'] = request.conditionsShrink;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceListShrink)) {
    body['DeviceList'] = request.deviceListShrink;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.imagePathShrink)) {
    body['ImagePath'] = request.imagePathShrink;
  }
  if (!Util.isUnset(request.objectType)) {
    body['ObjectType'] = request.objectType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.picUrl)) {
    body['PicUrl'] = request.picUrl;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchObject',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchObject(request: SearchObjectRequest): SearchObjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchObjectWithOptions(request, runtime);
}

model SearchTargetRequest {
  beginTime?: string(name='BeginTime'),
  corpId?: string(name='CorpId'),
  deviceList?: string(name='DeviceList'),
  endTime?: string(name='EndTime'),
  modelId?: string(name='ModelId'),
  orderBy?: string(name='OrderBy'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  similarityThreshold?: double(name='SimilarityThreshold'),
  targetAttributes?: string(name='TargetAttributes'),
  targetImageData?: string(name='TargetImageData'),
  targetImageUrl?: string(name='TargetImageUrl'),
  targetType?: string(name='TargetType'),
}

model SearchTargetResponseBody = {
  code?: string(name='Code'),
  data?: {
    pageNumber?: long(name='PageNumber'),
    pageSize?: long(name='PageSize'),
    records?: [ 
      {
        dataDetail?: string(name='DataDetail'),
        deviceId?: string(name='DeviceId'),
        leftTopX?: long(name='LeftTopX'),
        leftTopY?: long(name='LeftTopY'),
        rightBottomX?: long(name='RightBottomX'),
        rightBottomY?: long(name='RightBottomY'),
        sourceImageFullUrl?: string(name='SourceImageFullUrl'),
        sourceImageUrl?: string(name='SourceImageUrl'),
        targetAttributes?: string(name='TargetAttributes'),
        targetImageFullUrl?: string(name='TargetImageFullUrl'),
        targetImageSimilarity?: double(name='TargetImageSimilarity'),
        targetImageUrl?: string(name='TargetImageUrl'),
        targetType?: string(name='TargetType'),
        timestamp?: string(name='Timestamp'),
      }
    ](name='Records'),
    totalCount?: long(name='TotalCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SearchTargetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTargetResponseBody(name='body'),
}

async function searchTargetWithOptions(request: SearchTargetRequest, runtime: Util.RuntimeOptions): SearchTargetResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.beginTime)) {
    body['BeginTime'] = request.beginTime;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.modelId)) {
    body['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.orderBy)) {
    body['OrderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.similarityThreshold)) {
    body['SimilarityThreshold'] = request.similarityThreshold;
  }
  if (!Util.isUnset(request.targetAttributes)) {
    body['TargetAttributes'] = request.targetAttributes;
  }
  if (!Util.isUnset(request.targetImageData)) {
    body['TargetImageData'] = request.targetImageData;
  }
  if (!Util.isUnset(request.targetImageUrl)) {
    body['TargetImageUrl'] = request.targetImageUrl;
  }
  if (!Util.isUnset(request.targetType)) {
    body['TargetType'] = request.targetType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SearchTarget',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTarget(request: SearchTargetRequest): SearchTargetResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchTargetWithOptions(request, runtime);
}

model SetAiotStorageInfoRequest {
  eventAlarmMq?: {
    alarmTopic?: string(name='AlarmTopic'),
    eventTopic?: string(name='EventTopic'),
    instanceId?: string(name='InstanceId'),
    mqType?: string(name='MqType'),
    ramArnRole?: string(name='RamArnRole'),
    regionId?: string(name='RegionId'),
  }(name='EventAlarmMq'),
  eventAlarmPictureStorage?: {
    bucket?: string(name='Bucket'),
    endpoint?: string(name='Endpoint'),
    path?: string(name='Path'),
    proxy?: string(name='Proxy'),
    ramArnRole?: string(name='RamArnRole'),
    storageType?: string(name='StorageType'),
  }(name='EventAlarmPictureStorage'),
}

model SetAiotStorageInfoShrinkRequest {
  eventAlarmMqShrink?: string(name='EventAlarmMq'),
  eventAlarmPictureStorageShrink?: string(name='EventAlarmPictureStorage'),
}

model SetAiotStorageInfoResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SetAiotStorageInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetAiotStorageInfoResponseBody(name='body'),
}

async function setAiotStorageInfoWithOptions(tmpReq: SetAiotStorageInfoRequest, runtime: Util.RuntimeOptions): SetAiotStorageInfoResponse {
  Util.validateModel(tmpReq);
  var request = new SetAiotStorageInfoShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.eventAlarmMq)) {
    request.eventAlarmMqShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventAlarmMq, 'EventAlarmMq', 'json');
  }
  if (!Util.isUnset(tmpReq.eventAlarmPictureStorage)) {
    request.eventAlarmPictureStorageShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.eventAlarmPictureStorage, 'EventAlarmPictureStorage', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventAlarmMqShrink)) {
    body['EventAlarmMq'] = request.eventAlarmMqShrink;
  }
  if (!Util.isUnset(request.eventAlarmPictureStorageShrink)) {
    body['EventAlarmPictureStorage'] = request.eventAlarmPictureStorageShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetAiotStorageInfo',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setAiotStorageInfo(request: SetAiotStorageInfoRequest): SetAiotStorageInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return setAiotStorageInfoWithOptions(request, runtime);
}

model SetStreamModeRequest {
  deviceIdList?: string(name='DeviceIdList'),
  streamMode?: string(name='StreamMode'),
}

model SetStreamModeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model SetStreamModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetStreamModeResponseBody(name='body'),
}

async function setStreamModeWithOptions(request: SetStreamModeRequest, runtime: Util.RuntimeOptions): SetStreamModeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  if (!Util.isUnset(request.streamMode)) {
    body['StreamMode'] = request.streamMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SetStreamMode',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setStreamMode(request: SetStreamModeRequest): SetStreamModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return setStreamModeWithOptions(request, runtime);
}

model StartModelServiceRequest {
  modelServiceId?: string(name='ModelServiceId'),
}

model StartModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceInstanceName?: int32(name='ModelServiceInstanceName'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartModelServiceResponseBody(name='body'),
}

async function startModelServiceWithOptions(request: StartModelServiceRequest, runtime: Util.RuntimeOptions): StartModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.modelServiceId)) {
    body['ModelServiceId'] = request.modelServiceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startModelService(request: StartModelServiceRequest): StartModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startModelServiceWithOptions(request, runtime);
}

model StartStreamsRequest {
  description?: string(name='Description'),
  deviceIdList?: string(name='DeviceIdList'),
}

model StartStreamsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StartStreamsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartStreamsResponseBody(name='body'),
}

async function startStreamsWithOptions(request: StartStreamsRequest, runtime: Util.RuntimeOptions): StartStreamsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StartStreams',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startStreams(request: StartStreamsRequest): StartStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  return startStreamsWithOptions(request, runtime);
}

model StopModelServiceRequest {
  modelServiceId?: string(name='ModelServiceId'),
}

model StopModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceInstanceName?: int32(name='ModelServiceInstanceName'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopModelServiceResponseBody(name='body'),
}

async function stopModelServiceWithOptions(request: StopModelServiceRequest, runtime: Util.RuntimeOptions): StopModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.modelServiceId)) {
    body['ModelServiceId'] = request.modelServiceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopModelService(request: StopModelServiceRequest): StopModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopModelServiceWithOptions(request, runtime);
}

model StopMonitorRequest {
  algorithmVendor?: string(name='AlgorithmVendor'),
  taskId?: string(name='TaskId'),
}

model StopMonitorResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopMonitorResponseBody(name='body'),
}

async function stopMonitorWithOptions(request: StopMonitorRequest, runtime: Util.RuntimeOptions): StopMonitorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmVendor)) {
    body['AlgorithmVendor'] = request.algorithmVendor;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopMonitor',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopMonitor(request: StopMonitorRequest): StopMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopMonitorWithOptions(request, runtime);
}

model StopStreamsRequest {
  description?: string(name='Description'),
  deviceIdList?: string(name='DeviceIdList'),
}

model StopStreamsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model StopStreamsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopStreamsResponseBody(name='body'),
}

async function stopStreamsWithOptions(request: StopStreamsRequest, runtime: Util.RuntimeOptions): StopStreamsResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceIdList)) {
    body['DeviceIdList'] = request.deviceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'StopStreams',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopStreams(request: StopStreamsRequest): StopStreamsResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopStreamsWithOptions(request, runtime);
}

model SyncDeviceTimeRequest {
  deviceSn?: string(name='DeviceSn'),
  deviceTimeStamp?: string(name='DeviceTimeStamp'),
}

model SyncDeviceTimeResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  NTPServer?: string(name='NTPServer'),
  requestId?: string(name='RequestId'),
  retryInterval?: string(name='RetryInterval'),
  syncInterval?: string(name='SyncInterval'),
  timeStamp?: string(name='TimeStamp'),
}

model SyncDeviceTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SyncDeviceTimeResponseBody(name='body'),
}

async function syncDeviceTimeWithOptions(request: SyncDeviceTimeRequest, runtime: Util.RuntimeOptions): SyncDeviceTimeResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSn)) {
    body['DeviceSn'] = request.deviceSn;
  }
  if (!Util.isUnset(request.deviceTimeStamp)) {
    body['DeviceTimeStamp'] = request.deviceTimeStamp;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'SyncDeviceTime',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function syncDeviceTime(request: SyncDeviceTimeRequest): SyncDeviceTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return syncDeviceTimeWithOptions(request, runtime);
}

model TryCreateAIInstanceRequest {
  algorithmId?: string(name='AlgorithmId'),
  cameraNumber?: long(name='CameraNumber'),
  computeType?: string(name='ComputeType'),
  dataSource?: string(name='DataSource'),
  dataSourceTimes?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
    }
  ](name='DataSourceTimes'),
  dataType?: string(name='DataType'),
  fps?: long(name='Fps'),
  instanceType?: string(name='InstanceType'),
  scheduleCycleDates?: [ long ](name='ScheduleCycleDates'),
  scheduleTimes?: [ 
    {
      endTime?: string(name='EndTime'),
      startTime?: string(name='StartTime'),
    }
  ](name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  spf?: long(name='Spf'),
}

model TryCreateAIInstanceShrinkRequest {
  algorithmId?: string(name='AlgorithmId'),
  cameraNumber?: long(name='CameraNumber'),
  computeType?: string(name='ComputeType'),
  dataSource?: string(name='DataSource'),
  dataSourceTimesShrink?: string(name='DataSourceTimes'),
  dataType?: string(name='DataType'),
  fps?: long(name='Fps'),
  instanceType?: string(name='InstanceType'),
  scheduleCycleDatesShrink?: string(name='ScheduleCycleDates'),
  scheduleTimesShrink?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  spf?: long(name='Spf'),
}

model TryCreateAIInstanceResponseBody = {
  code?: string(name='Code'),
  data?: {
    acuUsed?: long(name='AcuUsed'),
    storage?: string(name='Storage'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model TryCreateAIInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TryCreateAIInstanceResponseBody(name='body'),
}

async function tryCreateAIInstanceWithOptions(tmpReq: TryCreateAIInstanceRequest, runtime: Util.RuntimeOptions): TryCreateAIInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new TryCreateAIInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceTimes)) {
    request.dataSourceTimesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceTimes, 'DataSourceTimes', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleCycleDates)) {
    request.scheduleCycleDatesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleCycleDates, 'ScheduleCycleDates', 'json');
  }
  if (!Util.isUnset(tmpReq.scheduleTimes)) {
    request.scheduleTimesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.scheduleTimes, 'ScheduleTimes', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmId)) {
    body['AlgorithmId'] = request.algorithmId;
  }
  if (!Util.isUnset(request.cameraNumber)) {
    body['CameraNumber'] = request.cameraNumber;
  }
  if (!Util.isUnset(request.computeType)) {
    body['ComputeType'] = request.computeType;
  }
  if (!Util.isUnset(request.dataSource)) {
    body['DataSource'] = request.dataSource;
  }
  if (!Util.isUnset(request.dataSourceTimesShrink)) {
    body['DataSourceTimes'] = request.dataSourceTimesShrink;
  }
  if (!Util.isUnset(request.dataType)) {
    body['DataType'] = request.dataType;
  }
  if (!Util.isUnset(request.fps)) {
    body['Fps'] = request.fps;
  }
  if (!Util.isUnset(request.instanceType)) {
    body['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.scheduleCycleDatesShrink)) {
    body['ScheduleCycleDates'] = request.scheduleCycleDatesShrink;
  }
  if (!Util.isUnset(request.scheduleTimesShrink)) {
    body['ScheduleTimes'] = request.scheduleTimesShrink;
  }
  if (!Util.isUnset(request.scheduleType)) {
    body['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.spf)) {
    body['Spf'] = request.spf;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'TryCreateAIInstance',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tryCreateAIInstance(request: TryCreateAIInstanceRequest): TryCreateAIInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return tryCreateAIInstanceWithOptions(request, runtime);
}

model UnbindCorpGroupRequest {
  corpGroupId?: string(name='CorpGroupId'),
  corpId?: string(name='CorpId'),
}

model UnbindCorpGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UnbindCorpGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindCorpGroupResponseBody(name='body'),
}

async function unbindCorpGroupWithOptions(request: UnbindCorpGroupRequest, runtime: Util.RuntimeOptions): UnbindCorpGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpGroupId)) {
    body['CorpGroupId'] = request.corpGroupId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindCorpGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindCorpGroup(request: UnbindCorpGroupRequest): UnbindCorpGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindCorpGroupWithOptions(request, runtime);
}

model UnbindDevicesRequest {
  corpId?: string(name='CorpId'),
  deviceId?: string(name='DeviceId'),
  subDeviceIdList?: string(name='SubDeviceIdList'),
}

model UnbindDevicesResponseBody = {
  code?: string(name='Code'),
  data?: {
    subDeviceList?: [ 
      {
        code?: string(name='Code'),
        message?: string(name='Message'),
        subDeviceId?: string(name='SubDeviceId'),
      }
    ](name='SubDeviceList'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UnbindDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindDevicesResponseBody(name='body'),
}

async function unbindDevicesWithOptions(request: UnbindDevicesRequest, runtime: Util.RuntimeOptions): UnbindDevicesResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.subDeviceIdList)) {
    body['SubDeviceIdList'] = request.subDeviceIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindDevices',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindDevices(request: UnbindDevicesRequest): UnbindDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindDevicesWithOptions(request, runtime);
}

model UnbindPersonRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  profileId?: long(name='ProfileId'),
}

model UnbindPersonResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UnbindPersonResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindPersonResponseBody(name='body'),
}

async function unbindPersonWithOptions(request: UnbindPersonRequest, runtime: Util.RuntimeOptions): UnbindPersonResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.profileId)) {
    body['ProfileId'] = request.profileId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindPerson',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindPerson(request: UnbindPersonRequest): UnbindPersonResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindPersonWithOptions(request, runtime);
}

model UnbindUserRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  userId?: long(name='UserId'),
}

model UnbindUserResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UnbindUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnbindUserResponseBody(name='body'),
}

async function unbindUserWithOptions(request: UnbindUserRequest, runtime: Util.RuntimeOptions): UnbindUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UnbindUser',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unbindUser(request: UnbindUserRequest): UnbindUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return unbindUserWithOptions(request, runtime);
}

model UpdateAiotDeviceRequest {
  aiotDevice?: {
    IPAddr?: string(name='IPAddr'),
    latitude?: float(name='Latitude'),
    longitude?: float(name='Longitude'),
    name?: string(name='Name'),
    place?: string(name='Place'),
    port?: long(name='Port'),
  }(name='AiotDevice'),
  id?: string(name='Id'),
}

model UpdateAiotDeviceShrinkRequest {
  aiotDeviceShrink?: string(name='AiotDevice'),
  id?: string(name='Id'),
}

model UpdateAiotDeviceResponseBody = {
  aiotDevice?: {
    capDirection?: string(name='CapDirection'),
    corpId?: string(name='CorpId'),
    deviceId?: string(name='DeviceId'),
    deviceType?: string(name='DeviceType'),
    firmwareVersion?: string(name='FirmwareVersion'),
    IPAddr?: string(name='IPAddr'),
    IPV6Addr?: string(name='IPV6Addr'),
    IPv4Gateway?: string(name='IPv4Gateway'),
    IPv4Netmask?: string(name='IPv4Netmask'),
    isOnline?: string(name='IsOnline'),
    latitude?: float(name='Latitude'),
    longitude?: float(name='Longitude'),
    MAC?: string(name='MAC'),
    manufacturer?: string(name='Manufacturer'),
    model?: string(name='Model'),
    monitorAreaDesc?: string(name='MonitorAreaDesc'),
    monitorDirection?: string(name='MonitorDirection'),
    name?: string(name='Name'),
    orgCode?: string(name='OrgCode'),
    ownerApsID?: string(name='OwnerApsID'),
    password?: string(name='Password'),
    place?: string(name='Place'),
    placeCode?: string(name='PlaceCode'),
    port?: long(name='Port'),
    serialNumber?: string(name='SerialNumber'),
    userId?: string(name='UserId'),
  }(name='AiotDevice'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateAiotDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAiotDeviceResponseBody(name='body'),
}

async function updateAiotDeviceWithOptions(tmpReq: UpdateAiotDeviceRequest, runtime: Util.RuntimeOptions): UpdateAiotDeviceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAiotDeviceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.aiotDevice)) {
    request.aiotDeviceShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.aiotDevice, 'AiotDevice', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.aiotDeviceShrink)) {
    body['AiotDevice'] = request.aiotDeviceShrink;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAiotDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAiotDevice(request: UpdateAiotDeviceRequest): UpdateAiotDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAiotDeviceWithOptions(request, runtime);
}

model UpdateAiotPersonTableRequest {
  id?: string(name='Id'),
  personTable?: {
    name?: string(name='Name'),
    personTableId?: string(name='PersonTableId'),
    type?: long(name='Type'),
    verificationModelList?: [ long ](name='VerificationModelList'),
  }(name='PersonTable'),
}

model UpdateAiotPersonTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  personTable?: {
    deviceId?: string(name='DeviceId'),
    faceNum?: long(name='FaceNum'),
    lastChange?: string(name='LastChange'),
    name?: string(name='Name'),
    personNum?: long(name='PersonNum'),
    personTableId?: string(name='PersonTableId'),
    totalPersonNum?: long(name='TotalPersonNum'),
    type?: long(name='Type'),
    verificationModelList?: [ long ](name='VerificationModelList'),
  }(name='PersonTable'),
  requestId?: string(name='RequestId'),
}

model UpdateAiotPersonTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAiotPersonTableResponseBody(name='body'),
}

async function updateAiotPersonTableWithOptions(request: UpdateAiotPersonTableRequest, runtime: Util.RuntimeOptions): UpdateAiotPersonTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.personTable)) {
    bodyFlat['PersonTable'] = request.personTable;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAiotPersonTable',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAiotPersonTable(request: UpdateAiotPersonTableRequest): UpdateAiotPersonTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAiotPersonTableWithOptions(request, runtime);
}

model UpdateAiotPersonTableItemRequest {
  id?: string(name='Id'),
  personTableId?: string(name='PersonTableId'),
  personTableItem?: {
    identificationList?: [ 
      {
        number?: string(name='Number'),
        type?: long(name='Type'),
      }
    ](name='IdentificationList'),
    identificationNum?: long(name='IdentificationNum'),
    imageList?: [ 
      {
        data?: string(name='Data'),
        deviceId?: string(name='DeviceId'),
        eventSort?: string(name='EventSort'),
        featureInfo?: {
          algorithmType?: string(name='AlgorithmType'),
          algorithmVersion?: string(name='AlgorithmVersion'),
          featureData?: string(name='FeatureData'),
          imageId?: string(name='ImageId'),
          objectId?: string(name='ObjectId'),
          tabIeId?: string(name='TabIeId'),
          vendor?: string(name='Vendor'),
        }(name='FeatureInfo'),
        fileFormat?: string(name='FileFormat'),
        height?: long(name='Height'),
        imageId?: string(name='ImageId'),
        shotTime?: string(name='ShotTime'),
        size?: long(name='Size'),
        storagePath?: string(name='StoragePath'),
        type?: string(name='Type'),
        width?: long(name='Width'),
      }
    ](name='ImageList'),
    imageNum?: long(name='ImageNum'),
    personCode?: string(name='PersonCode'),
    personId?: string(name='PersonId'),
    personName?: string(name='PersonName'),
    remarks?: string(name='Remarks'),
  }(name='PersonTableItem'),
}

model UpdateAiotPersonTableItemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  personTableItem?: {
    identificationList?: [ 
      {
        number?: string(name='Number'),
        type?: long(name='Type'),
      }
    ](name='IdentificationList'),
    identificationNum?: long(name='IdentificationNum'),
    imageList?: [ 
      {
        data?: string(name='Data'),
        deviceId?: string(name='DeviceId'),
        eventSort?: string(name='EventSort'),
        featureInfo?: {
          algorithmType?: string(name='AlgorithmType'),
          algorithmVersion?: string(name='AlgorithmVersion'),
          featureData?: string(name='FeatureData'),
          imageId?: string(name='ImageId'),
          objectId?: string(name='ObjectId'),
          tabIed?: string(name='TabIed'),
          vendor?: string(name='Vendor'),
        }(name='FeatureInfo'),
        fileFormat?: string(name='FileFormat'),
        height?: long(name='Height'),
        imageId?: string(name='ImageId'),
        shotTime?: string(name='ShotTime'),
        size?: long(name='Size'),
        storagePath?: string(name='StoragePath'),
        type?: string(name='Type'),
        width?: long(name='Width'),
      }
    ](name='ImageList'),
    imageNum?: long(name='ImageNum'),
    lastChange?: string(name='LastChange'),
    personCode?: string(name='PersonCode'),
    personId?: string(name='PersonId'),
    personName?: string(name='PersonName'),
    personTableId?: string(name='PersonTableId'),
    remarks?: string(name='Remarks'),
  }(name='PersonTableItem'),
  requestId?: string(name='RequestId'),
}

model UpdateAiotPersonTableItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAiotPersonTableItemResponseBody(name='body'),
}

async function updateAiotPersonTableItemWithOptions(request: UpdateAiotPersonTableItemRequest, runtime: Util.RuntimeOptions): UpdateAiotPersonTableItemResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.personTableId)) {
    body['PersonTableId'] = request.personTableId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.personTableItem)) {
    bodyFlat['PersonTableItem'] = request.personTableItem;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAiotPersonTableItem',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAiotPersonTableItem(request: UpdateAiotPersonTableItemRequest): UpdateAiotPersonTableItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAiotPersonTableItemWithOptions(request, runtime);
}

model UpdateAiotVehicleTableItemRequest {
  id?: string(name='Id'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItem?: {
    beginTime?: string(name='BeginTime'),
    endTime?: string(name='EndTime'),
    ownerName?: string(name='OwnerName'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    remarks?: string(name='Remarks'),
    vehicleTableItemId?: string(name='VehicleTableItemId'),
  }(name='VehicleTableItem'),
}

model UpdateAiotVehicleTableItemShrinkRequest {
  id?: string(name='Id'),
  vehicleTableId?: string(name='VehicleTableId'),
  vehicleTableItemShrink?: string(name='VehicleTableItem'),
}

model UpdateAiotVehicleTableItemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  vehicleTableItem?: {
    beginTime?: string(name='BeginTime'),
    endTime?: string(name='EndTime'),
    ownerName?: string(name='OwnerName'),
    phoneNo?: string(name='PhoneNo'),
    plateNo?: string(name='PlateNo'),
    remarks?: string(name='Remarks'),
    vehicleTableId?: string(name='VehicleTableId'),
    vehicleTableItemId?: string(name='VehicleTableItemId'),
  }(name='VehicleTableItem'),
}

model UpdateAiotVehicleTableItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAiotVehicleTableItemResponseBody(name='body'),
}

async function updateAiotVehicleTableItemWithOptions(tmpReq: UpdateAiotVehicleTableItemRequest, runtime: Util.RuntimeOptions): UpdateAiotVehicleTableItemResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateAiotVehicleTableItemShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.vehicleTableItem)) {
    request.vehicleTableItemShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vehicleTableItem, 'VehicleTableItem', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  if (!Util.isUnset(request.vehicleTableId)) {
    body['VehicleTableId'] = request.vehicleTableId;
  }
  if (!Util.isUnset(request.vehicleTableItemShrink)) {
    body['VehicleTableItem'] = request.vehicleTableItemShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAiotVehicleTableItem',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAiotVehicleTableItem(request: UpdateAiotVehicleTableItemRequest): UpdateAiotVehicleTableItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAiotVehicleTableItemWithOptions(request, runtime);
}

model UpdateCorpRequest {
  appName?: string(name='AppName'),
  corpId?: string(name='CorpId'),
  corpName?: string(name='CorpName'),
  description?: string(name='Description'),
  iconPath?: string(name='IconPath'),
  isvSubId?: string(name='IsvSubId'),
  parentCorpId?: string(name='ParentCorpId'),
}

model UpdateCorpResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateCorpResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateCorpResponseBody(name='body'),
}

async function updateCorpWithOptions(request: UpdateCorpRequest, runtime: Util.RuntimeOptions): UpdateCorpResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.appName)) {
    body['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.corpName)) {
    body['CorpName'] = request.corpName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.iconPath)) {
    body['IconPath'] = request.iconPath;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.parentCorpId)) {
    body['ParentCorpId'] = request.parentCorpId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateCorp',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateCorp(request: UpdateCorpRequest): UpdateCorpResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateCorpWithOptions(request, runtime);
}

model UpdateDataSourceRequest {
  dataSourceId?: string(name='DataSourceId'),
  dataSourceName?: string(name='DataSourceName'),
  description?: string(name='Description'),
  url?: string(name='Url'),
}

model UpdateDataSourceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDataSourceResponseBody(name='body'),
}

async function updateDataSourceWithOptions(request: UpdateDataSourceRequest, runtime: Util.RuntimeOptions): UpdateDataSourceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.dataSourceName)) {
    body['DataSourceName'] = request.dataSourceName;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.url)) {
    body['Url'] = request.url;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDataSource',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDataSource(request: UpdateDataSourceRequest): UpdateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDataSourceWithOptions(request, runtime);
}

model UpdateDeviceRequest {
  bitRate?: string(name='BitRate'),
  corpId?: string(name='CorpId'),
  deviceAddress?: string(name='DeviceAddress'),
  deviceDirection?: string(name='DeviceDirection'),
  deviceName?: string(name='DeviceName'),
  deviceResolution?: string(name='DeviceResolution'),
  deviceSite?: string(name='DeviceSite'),
  deviceType?: string(name='DeviceType'),
  gbId?: string(name='GbId'),
  vendor?: string(name='Vendor'),
}

model UpdateDeviceResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceResponseBody(name='body'),
}

async function updateDeviceWithOptions(request: UpdateDeviceRequest, runtime: Util.RuntimeOptions): UpdateDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bitRate)) {
    body['BitRate'] = request.bitRate;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.deviceDirection)) {
    body['DeviceDirection'] = request.deviceDirection;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceResolution)) {
    body['DeviceResolution'] = request.deviceResolution;
  }
  if (!Util.isUnset(request.deviceSite)) {
    body['DeviceSite'] = request.deviceSite;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.gbId)) {
    body['GbId'] = request.gbId;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevice(request: UpdateDeviceRequest): UpdateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceWithOptions(request, runtime);
}

model UpdateDeviceCaptureStrategyRequest {
  deviceCode?: string(name='DeviceCode'),
  deviceType?: string(name='DeviceType'),
  mondayCaptureStrategy?: string(name='MondayCaptureStrategy'),
}

model UpdateDeviceCaptureStrategyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDeviceCaptureStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceCaptureStrategyResponseBody(name='body'),
}

async function updateDeviceCaptureStrategyWithOptions(request: UpdateDeviceCaptureStrategyRequest, runtime: Util.RuntimeOptions): UpdateDeviceCaptureStrategyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceCode)) {
    body['DeviceCode'] = request.deviceCode;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.mondayCaptureStrategy)) {
    body['MondayCaptureStrategy'] = request.mondayCaptureStrategy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceCaptureStrategy',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceCaptureStrategy(request: UpdateDeviceCaptureStrategyRequest): UpdateDeviceCaptureStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceCaptureStrategyWithOptions(request, runtime);
}

model UpdateDevicesStorageRequest {
  updateStorageRequests?: [ 
    {
      deviceIds?: string(name='DeviceIds'),
      storageDays?: [ 
        {
          storageDays?: long(name='StorageDays'),
          storageType?: string(name='StorageType'),
        }
      ](name='StorageDays'),
    }
  ](name='UpdateStorageRequests'),
}

model UpdateDevicesStorageShrinkRequest {
  updateStorageRequestsShrink?: string(name='UpdateStorageRequests'),
}

model UpdateDevicesStorageResponseBody = {
  code?: string(name='Code'),
  data?: boolean(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateDevicesStorageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevicesStorageResponseBody(name='body'),
}

async function updateDevicesStorageWithOptions(tmpReq: UpdateDevicesStorageRequest, runtime: Util.RuntimeOptions): UpdateDevicesStorageResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDevicesStorageShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.updateStorageRequests)) {
    request.updateStorageRequestsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.updateStorageRequests, 'UpdateStorageRequests', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.updateStorageRequestsShrink)) {
    body['UpdateStorageRequests'] = request.updateStorageRequestsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevicesStorage',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevicesStorage(request: UpdateDevicesStorageRequest): UpdateDevicesStorageResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevicesStorageWithOptions(request, runtime);
}

model UpdateDoubleVerificationGroupRequest {
  doubleVerificationGroup?: {
    groupId?: string(name='GroupId'),
    interval?: long(name='Interval'),
    memberNumber?: long(name='MemberNumber'),
    personIdList?: [ 
      {
        personId?: string(name='PersonId'),
        personTableId?: string(name='PersonTableId'),
      }
    ](name='PersonIdList'),
  }(name='DoubleVerificationGroup'),
  id?: string(name='Id'),
}

model UpdateDoubleVerificationGroupResponseBody = {
  code?: string(name='Code'),
  doubleVerificationGroup?: {
    deviceId?: string(name='DeviceId'),
    enabled?: string(name='Enabled'),
    groupId?: string(name='GroupId'),
    interval?: long(name='Interval'),
    lastChange?: string(name='LastChange'),
    memberNumber?: long(name='MemberNumber'),
    personIdList?: [ 
      {
        personId?: string(name='PersonId'),
        personTableId?: string(name='PersonTableId'),
      }
    ](name='PersonIdList'),
  }(name='DoubleVerificationGroup'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateDoubleVerificationGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDoubleVerificationGroupResponseBody(name='body'),
}

async function updateDoubleVerificationGroupWithOptions(request: UpdateDoubleVerificationGroupRequest, runtime: Util.RuntimeOptions): UpdateDoubleVerificationGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.doubleVerificationGroup)) {
    bodyFlat['DoubleVerificationGroup'] = request.doubleVerificationGroup;
  }
  if (!Util.isUnset(request.id)) {
    body['Id'] = request.id;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDoubleVerificationGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDoubleVerificationGroup(request: UpdateDoubleVerificationGroupRequest): UpdateDoubleVerificationGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDoubleVerificationGroupWithOptions(request, runtime);
}

model UpdateModelServiceRequest {
  clientToken?: string(name='ClientToken'),
  modelServiceId?: string(name='ModelServiceId'),
  modelServiceName?: string(name='ModelServiceName'),
  qpsRequired?: int32(name='QpsRequired'),
}

model UpdateModelServiceResponseBody = {
  code?: string(name='Code'),
  data?: {
    algorithmCode?: string(name='AlgorithmCode'),
    modelServiceInstanceId?: string(name='ModelServiceInstanceId'),
    modelServiceInstanceName?: string(name='ModelServiceInstanceName'),
    modelServiceStatus?: string(name='ModelServiceStatus'),
    qpsRequired?: int32(name='QpsRequired'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateModelServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateModelServiceResponseBody(name='body'),
}

async function updateModelServiceWithOptions(request: UpdateModelServiceRequest, runtime: Util.RuntimeOptions): UpdateModelServiceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modelServiceId)) {
    body['ModelServiceId'] = request.modelServiceId;
  }
  if (!Util.isUnset(request.modelServiceName)) {
    body['ModelServiceName'] = request.modelServiceName;
  }
  if (!Util.isUnset(request.qpsRequired)) {
    body['QpsRequired'] = request.qpsRequired;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateModelService',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateModelService(request: UpdateModelServiceRequest): UpdateModelServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateModelServiceWithOptions(request, runtime);
}

model UpdateMonitorRequest {
  algorithmVendor?: string(name='AlgorithmVendor'),
  attributeName?: string(name='AttributeName'),
  attributeOperateType?: string(name='AttributeOperateType'),
  attributeValueList?: string(name='AttributeValueList'),
  corpId?: string(name='CorpId'),
  description?: string(name='Description'),
  deviceList?: string(name='DeviceList'),
  deviceOperateType?: string(name='DeviceOperateType'),
  notifierAppSecret?: string(name='NotifierAppSecret'),
  notifierExtendValues?: string(name='NotifierExtendValues'),
  notifierTimeOut?: int32(name='NotifierTimeOut'),
  notifierType?: string(name='NotifierType'),
  notifierUrl?: string(name='NotifierUrl'),
  picList?: string(name='PicList'),
  picOperateType?: string(name='PicOperateType'),
  ruleExpression?: string(name='RuleExpression'),
  ruleName?: string(name='RuleName'),
  taskId?: string(name='TaskId'),
}

model UpdateMonitorResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateMonitorResponseBody(name='body'),
}

async function updateMonitorWithOptions(request: UpdateMonitorRequest, runtime: Util.RuntimeOptions): UpdateMonitorResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.algorithmVendor)) {
    body['AlgorithmVendor'] = request.algorithmVendor;
  }
  if (!Util.isUnset(request.attributeName)) {
    body['AttributeName'] = request.attributeName;
  }
  if (!Util.isUnset(request.attributeOperateType)) {
    body['AttributeOperateType'] = request.attributeOperateType;
  }
  if (!Util.isUnset(request.attributeValueList)) {
    body['AttributeValueList'] = request.attributeValueList;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.deviceOperateType)) {
    body['DeviceOperateType'] = request.deviceOperateType;
  }
  if (!Util.isUnset(request.notifierAppSecret)) {
    body['NotifierAppSecret'] = request.notifierAppSecret;
  }
  if (!Util.isUnset(request.notifierExtendValues)) {
    body['NotifierExtendValues'] = request.notifierExtendValues;
  }
  if (!Util.isUnset(request.notifierTimeOut)) {
    body['NotifierTimeOut'] = request.notifierTimeOut;
  }
  if (!Util.isUnset(request.notifierType)) {
    body['NotifierType'] = request.notifierType;
  }
  if (!Util.isUnset(request.notifierUrl)) {
    body['NotifierUrl'] = request.notifierUrl;
  }
  if (!Util.isUnset(request.picList)) {
    body['PicList'] = request.picList;
  }
  if (!Util.isUnset(request.picOperateType)) {
    body['PicOperateType'] = request.picOperateType;
  }
  if (!Util.isUnset(request.ruleExpression)) {
    body['RuleExpression'] = request.ruleExpression;
  }
  if (!Util.isUnset(request.ruleName)) {
    body['RuleName'] = request.ruleName;
  }
  if (!Util.isUnset(request.taskId)) {
    body['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitor',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitor(request: UpdateMonitorRequest): UpdateMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateMonitorWithOptions(request, runtime);
}

model UpdateProfileRequest {
  bizId?: string(name='BizId'),
  catalogId?: long(name='CatalogId'),
  corpId?: string(name='CorpId'),
  faceUrl?: string(name='FaceUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  liveAddress?: string(name='LiveAddress'),
  name?: string(name='Name'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  profileId?: long(name='ProfileId'),
  sceneType?: string(name='SceneType'),
}

model UpdateProfileResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateProfileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProfileResponseBody(name='body'),
}

async function updateProfileWithOptions(request: UpdateProfileRequest, runtime: Util.RuntimeOptions): UpdateProfileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceUrl)) {
    body['FaceUrl'] = request.faceUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.liveAddress)) {
    body['LiveAddress'] = request.liveAddress;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.profileId)) {
    body['ProfileId'] = request.profileId;
  }
  if (!Util.isUnset(request.sceneType)) {
    body['SceneType'] = request.sceneType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProfile',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProfile(request: UpdateProfileRequest): UpdateProfileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProfileWithOptions(request, runtime);
}

model UpdateProfileCatalogRequest {
  catalogId?: long(name='CatalogId'),
  catalogName?: string(name='CatalogName'),
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
}

model UpdateProfileCatalogResponseBody = {
  code?: string(name='Code'),
  data?: {
    catalogId?: long(name='CatalogId'),
    catalogName?: string(name='CatalogName'),
    isvSubId?: string(name='IsvSubId'),
    parentCatalogId?: string(name='ParentCatalogId'),
    profileCount?: long(name='ProfileCount'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateProfileCatalogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProfileCatalogResponseBody(name='body'),
}

async function updateProfileCatalogWithOptions(request: UpdateProfileCatalogRequest, runtime: Util.RuntimeOptions): UpdateProfileCatalogResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.catalogId)) {
    body['CatalogId'] = request.catalogId;
  }
  if (!Util.isUnset(request.catalogName)) {
    body['CatalogName'] = request.catalogName;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProfileCatalog',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProfileCatalog(request: UpdateProfileCatalogRequest): UpdateProfileCatalogResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProfileCatalogWithOptions(request, runtime);
}

model UpdateSearchTableRequest {
  searchTableId?: string(name='SearchTableId'),
  searchTableName?: string(name='SearchTableName'),
}

model UpdateSearchTableResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateSearchTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSearchTableResponseBody(name='body'),
}

async function updateSearchTableWithOptions(request: UpdateSearchTableRequest, runtime: Util.RuntimeOptions): UpdateSearchTableResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.searchTableId)) {
    body['SearchTableId'] = request.searchTableId;
  }
  if (!Util.isUnset(request.searchTableName)) {
    body['SearchTableName'] = request.searchTableName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSearchTable',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSearchTable(request: UpdateSearchTableRequest): UpdateSearchTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSearchTableWithOptions(request, runtime);
}

model UpdateUserRequest {
  address?: string(name='Address'),
  age?: int32(name='Age'),
  attachment?: string(name='Attachment'),
  bizId?: string(name='BizId'),
  corpId?: string(name='CorpId'),
  faceImageContent?: string(name='FaceImageContent'),
  faceImageUrl?: string(name='FaceImageUrl'),
  gender?: int32(name='Gender'),
  idNumber?: string(name='IdNumber'),
  isvSubId?: string(name='IsvSubId'),
  phoneNo?: string(name='PhoneNo'),
  plateNo?: string(name='PlateNo'),
  userGroupId?: long(name='UserGroupId'),
  userId?: long(name='UserId'),
  userName?: string(name='UserName'),
}

model UpdateUserResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserResponseBody(name='body'),
}

async function updateUserWithOptions(request: UpdateUserRequest, runtime: Util.RuntimeOptions): UpdateUserResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.age)) {
    body['Age'] = request.age;
  }
  if (!Util.isUnset(request.attachment)) {
    body['Attachment'] = request.attachment;
  }
  if (!Util.isUnset(request.bizId)) {
    body['BizId'] = request.bizId;
  }
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.faceImageContent)) {
    body['FaceImageContent'] = request.faceImageContent;
  }
  if (!Util.isUnset(request.faceImageUrl)) {
    body['FaceImageUrl'] = request.faceImageUrl;
  }
  if (!Util.isUnset(request.gender)) {
    body['Gender'] = request.gender;
  }
  if (!Util.isUnset(request.idNumber)) {
    body['IdNumber'] = request.idNumber;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.phoneNo)) {
    body['PhoneNo'] = request.phoneNo;
  }
  if (!Util.isUnset(request.plateNo)) {
    body['PlateNo'] = request.plateNo;
  }
  if (!Util.isUnset(request.userGroupId)) {
    body['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userId)) {
    body['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    body['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUser',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUser(request: UpdateUserRequest): UpdateUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserWithOptions(request, runtime);
}

model UpdateUserGroupRequest {
  corpId?: string(name='CorpId'),
  isvSubId?: string(name='IsvSubId'),
  userGroupId?: long(name='UserGroupId'),
  userGroupName?: string(name='UserGroupName'),
}

model UpdateUserGroupResponseBody = {
  code?: string(name='Code'),
  data?: {
    isvSubId?: string(name='IsvSubId'),
    parentUserGroupId?: string(name='ParentUserGroupId'),
    userCount?: long(name='UserCount'),
    userGroupId?: long(name='UserGroupId'),
    userGroupName?: string(name='UserGroupName'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UpdateUserGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserGroupResponseBody(name='body'),
}

async function updateUserGroupWithOptions(request: UpdateUserGroupRequest, runtime: Util.RuntimeOptions): UpdateUserGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.isvSubId)) {
    body['IsvSubId'] = request.isvSubId;
  }
  if (!Util.isUnset(request.userGroupId)) {
    body['UserGroupId'] = request.userGroupId;
  }
  if (!Util.isUnset(request.userGroupName)) {
    body['UserGroupName'] = request.userGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserGroup',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserGroup(request: UpdateUserGroupRequest): UpdateUserGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserGroupWithOptions(request, runtime);
}

model UpdateWatchPolicyRequest {
  itemMatchType?: string(name='ItemMatchType'),
  similarityThreshold?: double(name='SimilarityThreshold'),
  targetType?: string(name='TargetType'),
  watchMode?: string(name='WatchMode'),
  watchPolicyId?: string(name='WatchPolicyId'),
  watchPolicyName?: string(name='WatchPolicyName'),
}

model UpdateWatchPolicyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWatchPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWatchPolicyResponseBody(name='body'),
}

async function updateWatchPolicyWithOptions(request: UpdateWatchPolicyRequest, runtime: Util.RuntimeOptions): UpdateWatchPolicyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.itemMatchType)) {
    body['ItemMatchType'] = request.itemMatchType;
  }
  if (!Util.isUnset(request.similarityThreshold)) {
    body['SimilarityThreshold'] = request.similarityThreshold;
  }
  if (!Util.isUnset(request.targetType)) {
    body['TargetType'] = request.targetType;
  }
  if (!Util.isUnset(request.watchMode)) {
    body['WatchMode'] = request.watchMode;
  }
  if (!Util.isUnset(request.watchPolicyId)) {
    body['WatchPolicyId'] = request.watchPolicyId;
  }
  if (!Util.isUnset(request.watchPolicyName)) {
    body['WatchPolicyName'] = request.watchPolicyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWatchPolicy',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWatchPolicy(request: UpdateWatchPolicyRequest): UpdateWatchPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatchPolicyWithOptions(request, runtime);
}

model UpdateWatchTaskRequest {
  description?: string(name='Description'),
  deviceList?: string(name='DeviceList'),
  messageReceiver?: string(name='MessageReceiver'),
  scheduleCycleDates?: string(name='ScheduleCycleDates'),
  scheduleTimes?: string(name='ScheduleTimes'),
  scheduleType?: string(name='ScheduleType'),
  taskName?: string(name='TaskName'),
  watchPolicyIds?: string(name='WatchPolicyIds'),
  watchTaskId?: string(name='WatchTaskId'),
}

model UpdateWatchTaskResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateWatchTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWatchTaskResponseBody(name='body'),
}

async function updateWatchTaskWithOptions(request: UpdateWatchTaskRequest, runtime: Util.RuntimeOptions): UpdateWatchTaskResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceList)) {
    body['DeviceList'] = request.deviceList;
  }
  if (!Util.isUnset(request.messageReceiver)) {
    body['MessageReceiver'] = request.messageReceiver;
  }
  if (!Util.isUnset(request.scheduleCycleDates)) {
    body['ScheduleCycleDates'] = request.scheduleCycleDates;
  }
  if (!Util.isUnset(request.scheduleTimes)) {
    body['ScheduleTimes'] = request.scheduleTimes;
  }
  if (!Util.isUnset(request.scheduleType)) {
    body['ScheduleType'] = request.scheduleType;
  }
  if (!Util.isUnset(request.taskName)) {
    body['TaskName'] = request.taskName;
  }
  if (!Util.isUnset(request.watchPolicyIds)) {
    body['WatchPolicyIds'] = request.watchPolicyIds;
  }
  if (!Util.isUnset(request.watchTaskId)) {
    body['WatchTaskId'] = request.watchTaskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWatchTask',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWatchTask(request: UpdateWatchTaskRequest): UpdateWatchTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWatchTaskWithOptions(request, runtime);
}

model UploadFileRequest {
  corpId?: string(name='CorpId'),
  dataSourceId?: string(name='DataSourceId'),
  fileAliasName?: string(name='FileAliasName'),
  fileContent?: string(name='FileContent'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  fileType?: string(name='FileType'),
  MD5?: string(name='MD5'),
}

model UploadFileResponseBody = {
  code?: string(name='Code'),
  data?: {
    records?: [ 
      {
        ossPath?: string(name='OssPath'),
        sourceId?: string(name='SourceId'),
      }
    ](name='Records'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UploadFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadFileResponseBody(name='body'),
}

async function uploadFileWithOptions(request: UploadFileRequest, runtime: Util.RuntimeOptions): UploadFileResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.corpId)) {
    body['CorpId'] = request.corpId;
  }
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.fileAliasName)) {
    body['FileAliasName'] = request.fileAliasName;
  }
  if (!Util.isUnset(request.fileContent)) {
    body['FileContent'] = request.fileContent;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.fileType)) {
    body['FileType'] = request.fileType;
  }
  if (!Util.isUnset(request.MD5)) {
    body['MD5'] = request.MD5;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadFile',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadFile(request: UploadFileRequest): UploadFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadFileWithOptions(request, runtime);
}

model UploadImageRequest {
  imageUrl?: string(name='ImageUrl'),
}

model UploadImageResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model UploadImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UploadImageResponseBody(name='body'),
}

async function uploadImageWithOptions(request: UploadImageRequest, runtime: Util.RuntimeOptions): UploadImageResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.imageUrl)) {
    body['ImageUrl'] = request.imageUrl;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UploadImage',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uploadImage(request: UploadImageRequest): UploadImageResponse {
  var runtime = new Util.RuntimeOptions{};
  return uploadImageWithOptions(request, runtime);
}

model VerifyDeviceRequest {
  deviceAddress?: string(name='DeviceAddress'),
  filePath?: string(name='FilePath'),
  nvrExisted?: long(name='NvrExisted'),
}

model VerifyDeviceResponseBody = {
  code?: string(name='Code'),
  data?: [ 
    {
      code?: string(name='Code'),
      id?: string(name='Id'),
      message?: string(name='Message'),
      originalGbId?: string(name='OriginalGbId'),
      rowNumber?: long(name='RowNumber'),
      suggestGbId?: string(name='SuggestGbId'),
    }
  ](name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model VerifyDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: VerifyDeviceResponseBody(name='body'),
}

async function verifyDeviceWithOptions(request: VerifyDeviceRequest, runtime: Util.RuntimeOptions): VerifyDeviceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceAddress)) {
    body['DeviceAddress'] = request.deviceAddress;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.nvrExisted)) {
    body['NvrExisted'] = request.nvrExisted;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'VerifyDevice',
    version = '2020-05-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function verifyDevice(request: VerifyDeviceRequest): VerifyDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return verifyDeviceWithOptions(request, runtime);
}

