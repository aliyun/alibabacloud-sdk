/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('miniapplcdp', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model DataItemsModelDataValue = {
  id?: string(name='Id'),
  modelId?: string(name='ModelId'),
  modelName?: string(name='ModelName'),
  modelStatus?: string(name='ModelStatus'),
  modelType?: string(name='ModelType'),
  subType?: string(name='SubType'),
  moduleId?: string(name='ModuleId'),
  content?: string(name='Content'),
  appId?: string(name='AppId'),
  linked?: boolean(name='Linked'),
  linkModuleId?: string(name='LinkModuleId'),
  linkModelId?: string(name='LinkModelId'),
  schemaVersion?: string(name='SchemaVersion'),
  description?: string(name='Description'),
  props?: string(name='Props'),
  visibility?: string(name='Visibility'),
  modelDigest?: string(name='ModelDigest'),
}

model DataItemsResourceDataValue = {
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  description?: string(name='Description'),
  schemaVersion?: string(name='SchemaVersion'),
  moduleId?: string(name='ModuleId'),
  content?: map[string]any(name='Content'),
  appId?: string(name='AppId'),
  visibility?: string(name='Visibility'),
}

model BatchCreateModelRequest {
  appId?: string(name='AppId'),
  modelDataJson?: string(name='ModelDataJson'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
}

model BatchCreateModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelDigest?: string(name='ModelDigest'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchCreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateModelResponseBody(name='body'),
}

async function batchCreateModelWithOptions(request: BatchCreateModelRequest, runtime: Util.RuntimeOptions): BatchCreateModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelDataJson)) {
    query['ModelDataJson'] = request.modelDataJson;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchCreateModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchCreateModel(request: BatchCreateModelRequest): BatchCreateModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchCreateModelWithOptions(request, runtime);
}

model BatchDeleteModelRequest {
  appId?: string(name='AppId'),
  modelIdList?: string(name='ModelIdList'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model BatchDeleteModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteModelResponseBody(name='body'),
}

async function batchDeleteModelWithOptions(request: BatchDeleteModelRequest, runtime: Util.RuntimeOptions): BatchDeleteModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelIdList)) {
    query['ModelIdList'] = request.modelIdList;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteModel(request: BatchDeleteModelRequest): BatchDeleteModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteModelWithOptions(request, runtime);
}

model BatchDeleteResourcesRequest {
  appId?: string(name='AppId'),
  moduleId?: string(name='ModuleId'),
  resourceIdList?: string(name='ResourceIdList'),
  source?: string(name='Source'),
}

model BatchDeleteResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteResourcesResponseBody(name='body'),
}

async function batchDeleteResourcesWithOptions(request: BatchDeleteResourcesRequest, runtime: Util.RuntimeOptions): BatchDeleteResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceIdList)) {
    query['ResourceIdList'] = request.resourceIdList;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteResources',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteResources(request: BatchDeleteResourcesRequest): BatchDeleteResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteResourcesWithOptions(request, runtime);
}

model BatchRestoreModelRequest {
  appId?: string(name='AppId'),
  modelIdList?: string(name='ModelIdList'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model BatchRestoreModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchRestoreModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRestoreModelResponseBody(name='body'),
}

async function batchRestoreModelWithOptions(request: BatchRestoreModelRequest, runtime: Util.RuntimeOptions): BatchRestoreModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelIdList)) {
    query['ModelIdList'] = request.modelIdList;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'BatchRestoreModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchRestoreModel(request: BatchRestoreModelRequest): BatchRestoreModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchRestoreModelWithOptions(request, runtime);
}

model CheckDomainRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model CheckDomainResponseBody = {
  data?: {
    valid?: boolean(name='Valid'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDomainResponseBody(name='body'),
}

async function checkDomainWithOptions(request: CheckDomainRequest, runtime: Util.RuntimeOptions): CheckDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDomain',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDomainWithOptions(request, runtime);
}

model CloneAppRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  description?: string(name='Description'),
  icon?: string(name='Icon'),
  source?: string(name='Source'),
}

model CloneAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneAppResponseBody(name='body'),
}

async function cloneAppWithOptions(request: CloneAppRequest, runtime: Util.RuntimeOptions): CloneAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.icon)) {
    query['Icon'] = request.icon;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneApp',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneApp(request: CloneAppRequest): CloneAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneAppWithOptions(request, runtime);
}

model CloneModelFromCommitRequest {
  modelId?: string(name='ModelId'),
  source?: string(name='Source'),
  sourceCommitId?: string(name='SourceCommitId'),
  sourceModuleId?: string(name='SourceModuleId'),
  subType?: string(name='SubType'),
  targetModuleId?: string(name='TargetModuleId'),
  targetName?: string(name='TargetName'),
  targetSubType?: string(name='TargetSubType'),
}

model CloneModelFromCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneModelFromCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneModelFromCommitResponseBody(name='body'),
}

async function cloneModelFromCommitWithOptions(request: CloneModelFromCommitRequest, runtime: Util.RuntimeOptions): CloneModelFromCommitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceCommitId)) {
    query['SourceCommitId'] = request.sourceCommitId;
  }
  if (!Util.isUnset(request.sourceModuleId)) {
    query['SourceModuleId'] = request.sourceModuleId;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  if (!Util.isUnset(request.targetModuleId)) {
    query['TargetModuleId'] = request.targetModuleId;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetSubType)) {
    query['TargetSubType'] = request.targetSubType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneModelFromCommit',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneModelFromCommit(request: CloneModelFromCommitRequest): CloneModelFromCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneModelFromCommitWithOptions(request, runtime);
}

model CloneModelInModuleRequest {
  modelId?: string(name='ModelId'),
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
  targetName?: string(name='TargetName'),
  targetSubType?: string(name='TargetSubType'),
}

model CloneModelInModuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneModelInModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneModelInModuleResponseBody(name='body'),
}

async function cloneModelInModuleWithOptions(request: CloneModelInModuleRequest, runtime: Util.RuntimeOptions): CloneModelInModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.targetName)) {
    query['TargetName'] = request.targetName;
  }
  if (!Util.isUnset(request.targetSubType)) {
    query['TargetSubType'] = request.targetSubType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneModelInModule',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneModelInModule(request: CloneModelInModuleRequest): CloneModelInModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneModelInModuleWithOptions(request, runtime);
}

model CreateAppRequest {
  appName?: string(name='AppName'),
  appType?: string(name='AppType'),
  asynchronous?: boolean(name='Asynchronous'),
  categoryId?: string(name='CategoryId'),
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  icon?: string(name='Icon'),
  platformVersion?: string(name='PlatformVersion'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  sourceCommitId?: string(name='SourceCommitId'),
  templateId?: string(name='TemplateId'),
  templated?: boolean(name='Templated'),
}

model CreateAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppResponseBody(name='body'),
}

async function createAppWithOptions(request: CreateAppRequest, runtime: Util.RuntimeOptions): CreateAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.asynchronous)) {
    query['Asynchronous'] = request.asynchronous;
  }
  if (!Util.isUnset(request.categoryId)) {
    query['CategoryId'] = request.categoryId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.icon)) {
    query['Icon'] = request.icon;
  }
  if (!Util.isUnset(request.platformVersion)) {
    query['PlatformVersion'] = request.platformVersion;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceCommitId)) {
    query['SourceCommitId'] = request.sourceCommitId;
  }
  if (!Util.isUnset(request.templateId)) {
    query['TemplateId'] = request.templateId;
  }
  if (!Util.isUnset(request.templated)) {
    query['Templated'] = request.templated;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateApp',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createApp(request: CreateAppRequest): CreateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppWithOptions(request, runtime);
}

model CreateCommitRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  commitLog?: string(name='CommitLog'),
  commitType?: string(name='CommitType'),
  mainModuleCommitId?: string(name='MainModuleCommitId'),
  moduleId?: string(name='ModuleId'),
  rollbackToCommitId?: string(name='RollbackToCommitId'),
  rollbackType?: string(name='RollbackType'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model CreateCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCommitResponseBody(name='body'),
}

async function createCommitWithOptions(request: CreateCommitRequest, runtime: Util.RuntimeOptions): CreateCommitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.commitLog)) {
    query['CommitLog'] = request.commitLog;
  }
  if (!Util.isUnset(request.commitType)) {
    query['CommitType'] = request.commitType;
  }
  if (!Util.isUnset(request.mainModuleCommitId)) {
    query['MainModuleCommitId'] = request.mainModuleCommitId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.rollbackToCommitId)) {
    query['RollbackToCommitId'] = request.rollbackToCommitId;
  }
  if (!Util.isUnset(request.rollbackType)) {
    query['RollbackType'] = request.rollbackType;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCommit',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCommit(request: CreateCommitRequest): CreateCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCommitWithOptions(request, runtime);
}

model CreateDomainRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  envId?: string(name='EnvId'),
  path?: string(name='Path'),
  privateKey?: string(name='PrivateKey'),
  publicKey?: string(name='PublicKey'),
  source?: string(name='Source'),
  withCertificate?: boolean(name='WithCertificate'),
}

model CreateDomainResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    checked?: boolean(name='Checked'),
    cname?: string(name='Cname'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
    withCertificate?: boolean(name='WithCertificate'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

async function createDomainWithOptions(request: CreateDomainRequest, runtime: Util.RuntimeOptions): CreateDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.publicKey)) {
    query['PublicKey'] = request.publicKey;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.withCertificate)) {
    query['WithCertificate'] = request.withCertificate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDomain',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDomainWithOptions(request, runtime);
}

model CreateLinkEntityAndAssociationRequest {
  clientToken?: string(name='ClientToken'),
  modelData?: string(name='ModelData'),
  source?: string(name='Source'),
}

model CreateLinkEntityAndAssociationResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateLinkEntityAndAssociationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLinkEntityAndAssociationResponseBody(name='body'),
}

async function createLinkEntityAndAssociationWithOptions(request: CreateLinkEntityAndAssociationRequest, runtime: Util.RuntimeOptions): CreateLinkEntityAndAssociationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.modelData)) {
    query['ModelData'] = request.modelData;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateLinkEntityAndAssociation',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLinkEntityAndAssociation(request: CreateLinkEntityAndAssociationRequest): CreateLinkEntityAndAssociationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLinkEntityAndAssociationWithOptions(request, runtime);
}

model CreateModelRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  content?: string(name='Content'),
  description?: string(name='Description'),
  encodeType?: string(name='EncodeType'),
  linkModelId?: string(name='LinkModelId'),
  linkModuleId?: string(name='LinkModuleId'),
  linked?: boolean(name='Linked'),
  modelId?: string(name='ModelId'),
  modelName?: string(name='ModelName'),
  modelType?: string(name='ModelType'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
  visibility?: string(name='Visibility'),
}

model CreateModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelResponseBody(name='body'),
}

async function createModelWithOptions(request: CreateModelRequest, runtime: Util.RuntimeOptions): CreateModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encodeType)) {
    query['EncodeType'] = request.encodeType;
  }
  if (!Util.isUnset(request.linkModelId)) {
    query['LinkModelId'] = request.linkModelId;
  }
  if (!Util.isUnset(request.linkModuleId)) {
    query['LinkModuleId'] = request.linkModuleId;
  }
  if (!Util.isUnset(request.linked)) {
    query['Linked'] = request.linked;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.modelType)) {
    query['ModelType'] = request.modelType;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  if (!Util.isUnset(request.visibility)) {
    query['Visibility'] = request.visibility;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createModel(request: CreateModelRequest): CreateModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createModelWithOptions(request, runtime);
}

model CreateModuleRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  icon?: string(name='Icon'),
  minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
  moduleName?: string(name='ModuleName'),
  moduleType?: string(name='ModuleType'),
  platform?: string(name='Platform'),
  source?: string(name='Source'),
  sourceModuleId?: string(name='SourceModuleId'),
  targetAppSource?: string(name='TargetAppSource'),
}

model CreateModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    moduleType?: string(name='ModuleType'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
    platformVersion?: string(name='PlatformVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModuleResponseBody(name='body'),
}

async function createModuleWithOptions(request: CreateModuleRequest, runtime: Util.RuntimeOptions): CreateModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.icon)) {
    query['Icon'] = request.icon;
  }
  if (!Util.isUnset(request.minimumPlatformVersion)) {
    query['MinimumPlatformVersion'] = request.minimumPlatformVersion;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.moduleType)) {
    query['ModuleType'] = request.moduleType;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceModuleId)) {
    query['SourceModuleId'] = request.sourceModuleId;
  }
  if (!Util.isUnset(request.targetAppSource)) {
    query['TargetAppSource'] = request.targetAppSource;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateModule',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createModule(request: CreateModuleRequest): CreateModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createModuleWithOptions(request, runtime);
}

model CreateModulePublishRequest {
  clientToken?: string(name='ClientToken'),
  description?: string(name='Description'),
  moduleId?: string(name='ModuleId'),
  publishVersion?: string(name='PublishVersion'),
  source?: string(name='Source'),
}

model CreateModulePublishResponseBody = {
  data?: {
    commitId?: string(name='CommitId'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    publishId?: string(name='PublishId'),
    version?: string(name='Version'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModulePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModulePublishResponseBody(name='body'),
}

async function createModulePublishWithOptions(request: CreateModulePublishRequest, runtime: Util.RuntimeOptions): CreateModulePublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.publishVersion)) {
    query['PublishVersion'] = request.publishVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateModulePublish',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createModulePublish(request: CreateModulePublishRequest): CreateModulePublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return createModulePublishWithOptions(request, runtime);
}

model CreatePublishRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  commitId?: string(name='CommitId'),
  description?: string(name='Description'),
  envType?: string(name='EnvType'),
  publishType?: string(name='PublishType'),
  source?: string(name='Source'),
  versionNumber?: string(name='VersionNumber'),
}

model CreatePublishResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    completionTime?: string(name='CompletionTime'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    envId?: string(name='EnvId'),
    modifiedTime?: string(name='ModifiedTime'),
    publishId?: string(name='PublishId'),
    publishStatus?: string(name='PublishStatus'),
    publishType?: string(name='PublishType'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    subTasks?: [ map[string]string ](name='SubTasks'),
    versionNumber?: string(name='VersionNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreatePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublishResponseBody(name='body'),
}

async function createPublishWithOptions(request: CreatePublishRequest, runtime: Util.RuntimeOptions): CreatePublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.commitId)) {
    query['CommitId'] = request.commitId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.publishType)) {
    query['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.versionNumber)) {
    query['VersionNumber'] = request.versionNumber;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreatePublish',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPublish(request: CreatePublishRequest): CreatePublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPublishWithOptions(request, runtime);
}

model CreateResourceRequest {
  appId?: string(name='AppId'),
  clientToken?: string(name='ClientToken'),
  content?: string(name='Content'),
  description?: string(name='Description'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  visibility?: string(name='Visibility'),
}

model CreateResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceResponseBody(name='body'),
}

async function createResourceWithOptions(request: CreateResourceRequest, runtime: Util.RuntimeOptions): CreateResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.visibility)) {
    query['Visibility'] = request.visibility;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateResource',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceWithOptions(request, runtime);
}

model DeleteAppRequest {
  appId?: string(name='AppId'),
  source?: string(name='Source'),
}

model DeleteAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAppResponseBody(name='body'),
}

async function deleteAppWithOptions(request: DeleteAppRequest, runtime: Util.RuntimeOptions): DeleteAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteApp',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteApp(request: DeleteAppRequest): DeleteAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppWithOptions(request, runtime);
}

model DeleteCommitRequest {
  appId?: string(name='AppId'),
  commitId?: string(name='CommitId'),
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
}

model DeleteCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCommitResponseBody(name='body'),
}

async function deleteCommitWithOptions(request: DeleteCommitRequest, runtime: Util.RuntimeOptions): DeleteCommitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.commitId)) {
    query['CommitId'] = request.commitId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCommit',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCommit(request: DeleteCommitRequest): DeleteCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCommitWithOptions(request, runtime);
}

model DeleteDomainRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model DeleteDomainResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

async function deleteDomainWithOptions(request: DeleteDomainRequest, runtime: Util.RuntimeOptions): DeleteDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDomain',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDomainWithOptions(request, runtime);
}

model DeleteModelRequest {
  appId?: string(name='AppId'),
  modelId?: string(name='ModelId'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model DeleteModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelResponseBody(name='body'),
}

async function deleteModelWithOptions(request: DeleteModelRequest, runtime: Util.RuntimeOptions): DeleteModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteModel(request: DeleteModelRequest): DeleteModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteModelWithOptions(request, runtime);
}

model DeleteModuleRequest {
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
}

model DeleteModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModuleResponseBody(name='body'),
}

async function deleteModuleWithOptions(request: DeleteModuleRequest, runtime: Util.RuntimeOptions): DeleteModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteModule',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteModule(request: DeleteModuleRequest): DeleteModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteModuleWithOptions(request, runtime);
}

model DeleteResourceRequest {
  appId?: string(name='AppId'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  source?: string(name='Source'),
}

model DeleteResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceResponseBody(name='body'),
}

async function deleteResourceWithOptions(request: DeleteResourceRequest, runtime: Util.RuntimeOptions): DeleteResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResource',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResource(request: DeleteResourceRequest): DeleteResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceWithOptions(request, runtime);
}

model GenerateAppUserPasswordRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
  userName?: string(name='UserName'),
}

model GenerateAppUserPasswordResponseBody = {
  data?: {
    password?: string(name='Password'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateAppUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateAppUserPasswordResponseBody(name='body'),
}

async function generateAppUserPasswordWithOptions(request: GenerateAppUserPasswordRequest, runtime: Util.RuntimeOptions): GenerateAppUserPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAppUserPassword',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateAppUserPassword(request: GenerateAppUserPasswordRequest): GenerateAppUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAppUserPasswordWithOptions(request, runtime);
}

model GenerateAuthTokenRequest {
  appId?: string(name='AppId'),
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
}

model GenerateAuthTokenResponseBody = {
  data?: {
    jwtToken?: string(name='JwtToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateAuthTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateAuthTokenResponseBody(name='body'),
}

async function generateAuthTokenWithOptions(request: GenerateAuthTokenRequest, runtime: Util.RuntimeOptions): GenerateAuthTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateAuthToken',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateAuthToken(request: GenerateAuthTokenRequest): GenerateAuthTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateAuthTokenWithOptions(request, runtime);
}

model GenerateUploadTokenRequest {
  appId?: string(name='AppId'),
  materialId?: string(name='MaterialId'),
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
  uploadTokenType?: string(name='UploadTokenType'),
}

model GenerateUploadTokenResponseBody = {
  data?: {
    key?: string(name='Key'),
    ossAccessKeyId?: string(name='OssAccessKeyId'),
    policy?: string(name='Policy'),
    serverURL?: string(name='ServerURL'),
    signature?: string(name='Signature'),
    xAmzAlgorithm?: string(name='X-Amz-Algorithm'),
    xAmzCredential?: string(name='X-Amz-Credential'),
    xAmzDate?: string(name='X-Amz-Date'),
    xAmzSignature?: string(name='X-Amz-Signature'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateUploadTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateUploadTokenResponseBody(name='body'),
}

async function generateUploadTokenWithOptions(request: GenerateUploadTokenRequest, runtime: Util.RuntimeOptions): GenerateUploadTokenResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.materialId)) {
    query['MaterialId'] = request.materialId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.uploadTokenType)) {
    query['UploadTokenType'] = request.uploadTokenType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateUploadToken',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateUploadToken(request: GenerateUploadTokenRequest): GenerateUploadTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateUploadTokenWithOptions(request, runtime);
}

model GetAppRequest {
  appId?: string(name='AppId'),
  source?: string(name='Source'),
}

model GetAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppResponseBody(name='body'),
}

async function getAppWithOptions(request: GetAppRequest, runtime: Util.RuntimeOptions): GetAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetApp',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getApp(request: GetAppRequest): GetAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppWithOptions(request, runtime);
}

model GetAppModelRequest {
  appId?: string(name='AppId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
}

model GetAppModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppModelResponseBody(name='body'),
}

async function getAppModelWithOptions(request: GetAppModelRequest, runtime: Util.RuntimeOptions): GetAppModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppModel(request: GetAppModelRequest): GetAppModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppModelWithOptions(request, runtime);
}

model GetAppSecretRequest {
  appId?: string(name='AppId'),
  source?: string(name='Source'),
}

model GetAppSecretResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appSecret?: string(name='AppSecret'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppSecretResponseBody(name='body'),
}

async function getAppSecretWithOptions(request: GetAppSecretRequest, runtime: Util.RuntimeOptions): GetAppSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppSecret',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppSecretWithOptions(request, runtime);
}

model GetArtifactRequest {
  appId?: string(name='AppId'),
  artifactId?: string(name='ArtifactId'),
  source?: string(name='Source'),
}

model GetArtifactResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    artifactId?: string(name='ArtifactId'),
    artifactType?: string(name='ArtifactType'),
    available?: boolean(name='Available'),
    createTime?: string(name='CreateTime'),
    modifiedTime?: string(name='ModifiedTime'),
    url?: string(name='Url'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactResponseBody(name='body'),
}

async function getArtifactWithOptions(request: GetArtifactRequest, runtime: Util.RuntimeOptions): GetArtifactResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.artifactId)) {
    query['ArtifactId'] = request.artifactId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetArtifact',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getArtifact(request: GetArtifactRequest): GetArtifactResponse {
  var runtime = new Util.RuntimeOptions{};
  return getArtifactWithOptions(request, runtime);
}

model GetCommitRequest {
  appId?: string(name='AppId'),
  commitId?: string(name='CommitId'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model GetCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitDigest?: string(name='CommitDigest'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modelDigest?: map[string]string(name='ModelDigest'),
    modelPack?: [ any ](name='ModelPack'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    resourcePack?: [ map[string]string ](name='ResourcePack'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommitResponseBody(name='body'),
}

async function getCommitWithOptions(request: GetCommitRequest, runtime: Util.RuntimeOptions): GetCommitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.commitId)) {
    query['CommitId'] = request.commitId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetCommit',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getCommit(request: GetCommitRequest): GetCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  return getCommitWithOptions(request, runtime);
}

model GetDefaultAppUserRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model GetDefaultAppUserResponseBody = {
  data?: {
    hasPassword?: boolean(name='HasPassword'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDefaultAppUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDefaultAppUserResponseBody(name='body'),
}

async function getDefaultAppUserWithOptions(request: GetDefaultAppUserRequest, runtime: Util.RuntimeOptions): GetDefaultAppUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDefaultAppUser',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDefaultAppUser(request: GetDefaultAppUserRequest): GetDefaultAppUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDefaultAppUserWithOptions(request, runtime);
}

model GetDomainCnameRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model GetDomainCnameResponseBody = {
  data?: {
    cname?: string(name='Cname'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDomainCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainCnameResponseBody(name='body'),
}

async function getDomainCnameWithOptions(request: GetDomainCnameRequest, runtime: Util.RuntimeOptions): GetDomainCnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDomainCname',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDomainCname(request: GetDomainCnameRequest): GetDomainCnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainCnameWithOptions(request, runtime);
}

model GetDomainOverviewRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model GetDomainOverviewResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    certificate?: map[string]string(name='Certificate'),
    cname?: string(name='Cname'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
    withCertificate?: boolean(name='WithCertificate'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDomainOverviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainOverviewResponseBody(name='body'),
}

async function getDomainOverviewWithOptions(request: GetDomainOverviewRequest, runtime: Util.RuntimeOptions): GetDomainOverviewResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDomainOverview',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDomainOverview(request: GetDomainOverviewRequest): GetDomainOverviewResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDomainOverviewWithOptions(request, runtime);
}

model GetEnvironmentRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model GetEnvironmentResponseBody = {
  data?: {
    accountOpsEndpoint?: string(name='AccountOpsEndpoint'),
    appId?: string(name='AppId'),
    createTime?: string(name='CreateTime'),
    currentPublishId?: string(name='CurrentPublishId'),
    endpoint?: string(name='Endpoint'),
    envId?: string(name='EnvId'),
    envType?: string(name='EnvType'),
    modifiedTime?: string(name='ModifiedTime'),
    publishingId?: string(name='PublishingId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEnvironmentResponseBody(name='body'),
}

async function getEnvironmentWithOptions(request: GetEnvironmentRequest, runtime: Util.RuntimeOptions): GetEnvironmentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetEnvironment',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEnvironment(request: GetEnvironmentRequest): GetEnvironmentResponse {
  var runtime = new Util.RuntimeOptions{};
  return getEnvironmentWithOptions(request, runtime);
}

model GetHistoryStatsRequest {
  appId?: string(name='AppId'),
  endDate?: string(name='EndDate'),
  source?: string(name='Source'),
  startDate?: string(name='StartDate'),
}

model GetHistoryStatsResponseBody = {
  data?: {
    historyPv?: map[string]string(name='HistoryPv'),
    historyUv?: map[string]string(name='HistoryUv'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetHistoryStatsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHistoryStatsResponseBody(name='body'),
}

async function getHistoryStatsWithOptions(request: GetHistoryStatsRequest, runtime: Util.RuntimeOptions): GetHistoryStatsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.endDate)) {
    query['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.startDate)) {
    query['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistoryStats',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHistoryStats(request: GetHistoryStatsRequest): GetHistoryStatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getHistoryStatsWithOptions(request, runtime);
}

model GetLatestCommitRequest {
  appId?: string(name='AppId'),
  moduleId?: string(name='ModuleId'),
  source?: string(name='Source'),
}

model GetLatestCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetLatestCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLatestCommitResponseBody(name='body'),
}

async function getLatestCommitWithOptions(request: GetLatestCommitRequest, runtime: Util.RuntimeOptions): GetLatestCommitResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLatestCommit',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLatestCommit(request: GetLatestCommitRequest): GetLatestCommitResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLatestCommitWithOptions(request, runtime);
}

model GetModelRequest {
  appId?: string(name='AppId'),
  modelId?: string(name='ModelId'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model GetModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModelResponseBody(name='body'),
}

async function getModelWithOptions(request: GetModelRequest, runtime: Util.RuntimeOptions): GetModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getModel(request: GetModelRequest): GetModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModelWithOptions(request, runtime);
}

model GetModuleRequest {
  moduleId?: string(name='ModuleId'),
  moduleType?: string(name='ModuleType'),
  source?: string(name='Source'),
}

model GetModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
    platformVersion?: string(name='PlatformVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModuleResponseBody(name='body'),
}

async function getModuleWithOptions(request: GetModuleRequest, runtime: Util.RuntimeOptions): GetModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleType)) {
    query['ModuleType'] = request.moduleType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetModule',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getModule(request: GetModuleRequest): GetModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return getModuleWithOptions(request, runtime);
}

model GetPublishRequest {
  appId?: string(name='AppId'),
  publishId?: string(name='PublishId'),
  source?: string(name='Source'),
}

model GetPublishResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    completionTime?: string(name='CompletionTime'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    envId?: string(name='EnvId'),
    modifiedTime?: string(name='ModifiedTime'),
    publishId?: string(name='PublishId'),
    publishStatus?: string(name='PublishStatus'),
    publishType?: string(name='PublishType'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    subTasks?: [ map[string]string ](name='SubTasks'),
    versionNumber?: string(name='VersionNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetPublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublishResponseBody(name='body'),
}

async function getPublishWithOptions(request: GetPublishRequest, runtime: Util.RuntimeOptions): GetPublishResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.publishId)) {
    query['PublishId'] = request.publishId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPublish',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPublish(request: GetPublishRequest): GetPublishResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPublishWithOptions(request, runtime);
}

model GetRealtimeStatsRequest {
  appId?: string(name='AppId'),
  source?: string(name='Source'),
}

model GetRealtimeStatsResponseBody = {
  data?: {
    todayPvCount?: map[string]string(name='TodayPvCount'),
    todayUvCount?: map[string]string(name='TodayUvCount'),
    totalPvCount?: map[string]string(name='TotalPvCount'),
    totalUvCount?: map[string]string(name='TotalUvCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetRealtimeStatsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRealtimeStatsResponseBody(name='body'),
}

async function getRealtimeStatsWithOptions(request: GetRealtimeStatsRequest, runtime: Util.RuntimeOptions): GetRealtimeStatsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRealtimeStats',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRealtimeStats(request: GetRealtimeStatsRequest): GetRealtimeStatsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRealtimeStatsWithOptions(request, runtime);
}

model GetResourceRequest {
  appId?: string(name='AppId'),
  imageProcessParameter?: string(name='ImageProcessParameter'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  source?: string(name='Source'),
}

model GetResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetResourceResponseBody(name='body'),
}

async function getResourceWithOptions(request: GetResourceRequest, runtime: Util.RuntimeOptions): GetResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.imageProcessParameter)) {
    query['ImageProcessParameter'] = request.imageProcessParameter;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetResource',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getResource(request: GetResourceRequest): GetResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getResourceWithOptions(request, runtime);
}

model GetUserRequest {
  source?: string(name='Source'),
}

model GetUserResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    userSecret?: string(name='UserSecret'),
    userStatus?: string(name='UserStatus'),
    userType?: string(name='UserType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserResponseBody(name='body'),
}

async function getUserWithOptions(request: GetUserRequest, runtime: Util.RuntimeOptions): GetUserResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetUser',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getUser(request: GetUserRequest): GetUserResponse {
  var runtime = new Util.RuntimeOptions{};
  return getUserWithOptions(request, runtime);
}

model ListAppModulesRequest {
  appId?: string(name='AppId'),
  recursive?: boolean(name='Recursive'),
  source?: string(name='Source'),
}

model ListAppModulesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        description?: string(name='Description'),
        directDependency?: boolean(name='DirectDependency'),
        icon?: string(name='Icon'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppModulesResponseBody(name='body'),
}

async function listAppModulesWithOptions(request: ListAppModulesRequest, runtime: Util.RuntimeOptions): ListAppModulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppModules',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppModules(request: ListAppModulesRequest): ListAppModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppModulesWithOptions(request, runtime);
}

model ListAppTemplatesRequest {
  appType?: string(name='AppType'),
  source?: string(name='Source'),
  templateType?: string(name='TemplateType'),
}

model ListAppTemplatesResponseBody = {
  data?: {
    items?: [ 
      {
        appName?: string(name='AppName'),
        appType?: string(name='AppType'),
        categoryName?: string(name='CategoryName'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        lastEditTime?: string(name='LastEditTime'),
        mainModuleId?: string(name='MainModuleId'),
        modifiedTime?: string(name='ModifiedTime'),
        schemaVersion?: string(name='SchemaVersion'),
        source?: string(name='Source'),
        templateId?: string(name='TemplateId'),
        templateType?: string(name='TemplateType'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppTemplatesResponseBody(name='body'),
}

async function listAppTemplatesWithOptions(request: ListAppTemplatesRequest, runtime: Util.RuntimeOptions): ListAppTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.templateType)) {
    query['TemplateType'] = request.templateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAppTemplates',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAppTemplates(request: ListAppTemplatesRequest): ListAppTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppTemplatesWithOptions(request, runtime);
}

model ListAppsRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  appStatus?: string(name='AppStatus'),
  appType?: string(name='AppType'),
  customParentId?: string(name='CustomParentId'),
  description?: string(name='Description'),
  mainModuleId?: string(name='MainModuleId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
  template?: boolean(name='Template'),
}

model ListAppsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appStatus?: string(name='AppStatus'),
        appType?: string(name='AppType'),
        categories?: [ 
          {
            categoryId?: string(name='CategoryId'),
            categoryName?: string(name='CategoryName'),
            parentCategoryId?: string(name='ParentCategoryId'),
          }
        ](name='Categories'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        isTemplate?: boolean(name='IsTemplate'),
        lastEditTime?: string(name='LastEditTime'),
        mainModuleId?: string(name='MainModuleId'),
        modifiedTime?: string(name='ModifiedTime'),
        platformVersion?: string(name='PlatformVersion'),
        schemaVersion?: string(name='SchemaVersion'),
        source?: string(name='Source'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppsResponseBody(name='body'),
}

async function listAppsWithOptions(request: ListAppsRequest, runtime: Util.RuntimeOptions): ListAppsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.appStatus)) {
    query['AppStatus'] = request.appStatus;
  }
  if (!Util.isUnset(request.appType)) {
    query['AppType'] = request.appType;
  }
  if (!Util.isUnset(request.customParentId)) {
    query['CustomParentId'] = request.customParentId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.mainModuleId)) {
    query['MainModuleId'] = request.mainModuleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.template)) {
    query['Template'] = request.template;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListApps',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listApps(request: ListAppsRequest): ListAppsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAppsWithOptions(request, runtime);
}

model ListArtifactsRequest {
  appId?: string(name='AppId'),
  publishId?: string(name='PublishId'),
  source?: string(name='Source'),
}

model ListArtifactsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        artifactId?: string(name='ArtifactId'),
        artifactType?: string(name='ArtifactType'),
        available?: boolean(name='Available'),
        createTime?: string(name='CreateTime'),
        modifiedTime?: string(name='ModifiedTime'),
        url?: string(name='Url'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListArtifactsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactsResponseBody(name='body'),
}

async function listArtifactsWithOptions(request: ListArtifactsRequest, runtime: Util.RuntimeOptions): ListArtifactsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.publishId)) {
    query['PublishId'] = request.publishId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListArtifacts',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listArtifacts(request: ListArtifactsRequest): ListArtifactsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listArtifactsWithOptions(request, runtime);
}

model ListCommitsRequest {
  appId?: string(name='AppId'),
  commitLog?: string(name='CommitLog'),
  customParentId?: string(name='CustomParentId'),
  moduleId?: string(name='ModuleId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
}

model ListCommitsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitDigest?: string(name='CommitDigest'),
        commitId?: string(name='CommitId'),
        commitLog?: string(name='CommitLog'),
        commitType?: string(name='CommitType'),
        createTime?: string(name='CreateTime'),
        mainModuleCommitId?: string(name='MainModuleCommitId'),
        mainModuleId?: string(name='MainModuleId'),
        modelDataPath?: string(name='ModelDataPath'),
        modelDigest?: map[string]string(name='ModelDigest'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDataPath?: string(name='ResourceDataPath'),
        resourceDigest?: map[string]string(name='ResourceDigest'),
        rollbackToCommitId?: string(name='RollbackToCommitId'),
        rollbackType?: string(name='RollbackType'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListCommitsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCommitsResponseBody(name='body'),
}

async function listCommitsWithOptions(request: ListCommitsRequest, runtime: Util.RuntimeOptions): ListCommitsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.commitLog)) {
    query['CommitLog'] = request.commitLog;
  }
  if (!Util.isUnset(request.customParentId)) {
    query['CustomParentId'] = request.customParentId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListCommits',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listCommits(request: ListCommitsRequest): ListCommitsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listCommitsWithOptions(request, runtime);
}

model ListDomainsRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model ListDomainsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        applied?: boolean(name='Applied'),
        checked?: boolean(name='Checked'),
        cname?: string(name='Cname'),
        deleted?: boolean(name='Deleted'),
        domain?: string(name='Domain'),
        domainType?: string(name='DomainType'),
        envId?: string(name='EnvId'),
        path?: string(name='Path'),
        withCertificate?: boolean(name='WithCertificate'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

async function listDomainsWithOptions(request: ListDomainsRequest, runtime: Util.RuntimeOptions): ListDomainsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDomains',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDomainsWithOptions(request, runtime);
}

model ListEnvironmentOverviewsRequest {
  appId?: string(name='AppId'),
  source?: string(name='Source'),
}

model ListEnvironmentOverviewsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        config?: map[string]string(name='Config'),
        createTime?: string(name='CreateTime'),
        currentPublish?: map[string]string(name='CurrentPublish'),
        endpoint?: string(name='Endpoint'),
        envId?: string(name='EnvId'),
        envStatus?: string(name='EnvStatus'),
        envType?: string(name='EnvType'),
        latestAppAccessTime?: string(name='LatestAppAccessTime'),
        modifiedTime?: string(name='ModifiedTime'),
        opsRecord?: map[string]string(name='OpsRecord'),
        publishing?: map[string]string(name='Publishing'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListEnvironmentOverviewsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentOverviewsResponseBody(name='body'),
}

async function listEnvironmentOverviewsWithOptions(request: ListEnvironmentOverviewsRequest, runtime: Util.RuntimeOptions): ListEnvironmentOverviewsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironmentOverviews',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnvironmentOverviews(request: ListEnvironmentOverviewsRequest): ListEnvironmentOverviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnvironmentOverviewsWithOptions(request, runtime);
}

model ListEnvironmentsRequest {
  appId?: string(name='AppId'),
  envType?: string(name='EnvType'),
  source?: string(name='Source'),
}

model ListEnvironmentsResponseBody = {
  data?: {
    items?: [ 
      {
        accountOpsEndpoint?: string(name='AccountOpsEndpoint'),
        appId?: string(name='AppId'),
        createTime?: string(name='CreateTime'),
        currentPublishId?: string(name='CurrentPublishId'),
        endpoint?: string(name='Endpoint'),
        envId?: string(name='EnvId'),
        envType?: string(name='EnvType'),
        modifiedTime?: string(name='ModifiedTime'),
        publishingId?: string(name='PublishingId'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListEnvironmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentsResponseBody(name='body'),
}

async function listEnvironmentsWithOptions(request: ListEnvironmentsRequest, runtime: Util.RuntimeOptions): ListEnvironmentsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envType)) {
    query['EnvType'] = request.envType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvironments',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnvironments(request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEnvironmentsWithOptions(request, runtime);
}

model ListModelsRequest {
  appId?: string(name='AppId'),
  modelId?: string(name='ModelId'),
  modelName?: string(name='ModelName'),
  modelType?: string(name='ModelType'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
  withContent?: boolean(name='WithContent'),
}

model ListModelsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelDigest?: string(name='ModelDigest'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsResponseBody(name='body'),
}

async function listModelsWithOptions(request: ListModelsRequest, runtime: Util.RuntimeOptions): ListModelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.modelType)) {
    query['ModelType'] = request.modelType;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModels',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModels(request: ListModelsRequest): ListModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModelsWithOptions(request, runtime);
}

model ListModelsByPageRequest {
  appId?: string(name='AppId'),
  modelName?: string(name='ModelName'),
  modelType?: string(name='ModelType'),
  moduleId?: string(name='ModuleId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
  withContent?: boolean(name='WithContent'),
}

model ListModelsByPageResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModelsByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsByPageResponseBody(name='body'),
}

async function listModelsByPageWithOptions(request: ListModelsByPageRequest, runtime: Util.RuntimeOptions): ListModelsByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.modelType)) {
    query['ModelType'] = request.modelType;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModelsByPage',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModelsByPage(request: ListModelsByPageRequest): ListModelsByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModelsByPageWithOptions(request, runtime);
}

model ListModuleDependenciesRequest {
  moduleId?: string(name='ModuleId'),
  recursive?: boolean(name='Recursive'),
  source?: string(name='Source'),
}

model ListModuleDependenciesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        description?: string(name='Description'),
        directDependency?: boolean(name='DirectDependency'),
        icon?: string(name='Icon'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        origin?: string(name='Origin'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleDependenciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleDependenciesResponseBody(name='body'),
}

async function listModuleDependenciesWithOptions(request: ListModuleDependenciesRequest, runtime: Util.RuntimeOptions): ListModuleDependenciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.recursive)) {
    query['Recursive'] = request.recursive;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModuleDependencies',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModuleDependencies(request: ListModuleDependenciesRequest): ListModuleDependenciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModuleDependenciesWithOptions(request, runtime);
}

model ListModuleModelsRequest {
  moduleList?: string(name='ModuleList'),
  source?: string(name='Source'),
  subTypes?: string(name='SubTypes'),
  withContent?: boolean(name='WithContent'),
}

model ListModuleModelsResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        modelData?: map[string][ DataItemsModelDataValue         ](name='ModelData'),
        modelDataPath?: map[string]string(name='ModelDataPath'),
        modelDigest?: map[string]string(name='ModelDigest'),
        moduleId?: string(name='ModuleId'),
        resourceData?: map[string]string(name='ResourceData'),
        resourceDataPath?: map[string]string(name='ResourceDataPath'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleModelsResponseBody(name='body'),
}

async function listModuleModelsWithOptions(request: ListModuleModelsRequest, runtime: Util.RuntimeOptions): ListModuleModelsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleList)) {
    query['ModuleList'] = request.moduleList;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subTypes)) {
    query['SubTypes'] = request.subTypes;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModuleModels',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModuleModels(request: ListModuleModelsRequest): ListModuleModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModuleModelsWithOptions(request, runtime);
}

model ListModulePublishVersionsRequest {
  customParentId?: string(name='CustomParentId'),
  moduleId?: string(name='ModuleId'),
  moduleVersion?: string(name='ModuleVersion'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
}

model ListModulePublishVersionsResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        platformVersion?: string(name='PlatformVersion'),
        publishId?: string(name='PublishId'),
        version?: string(name='Version'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulePublishVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulePublishVersionsResponseBody(name='body'),
}

async function listModulePublishVersionsWithOptions(request: ListModulePublishVersionsRequest, runtime: Util.RuntimeOptions): ListModulePublishVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customParentId)) {
    query['CustomParentId'] = request.customParentId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleVersion)) {
    query['ModuleVersion'] = request.moduleVersion;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModulePublishVersions',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModulePublishVersions(request: ListModulePublishVersionsRequest): ListModulePublishVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModulePublishVersionsWithOptions(request, runtime);
}

model ListModuleResourcesRequest {
  moduleList?: string(name='ModuleList'),
  source?: string(name='Source'),
  types?: string(name='Types'),
  withContent?: boolean(name='WithContent'),
}

model ListModuleResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        modelData?: map[string]string(name='ModelData'),
        modelDataPath?: map[string]string(name='ModelDataPath'),
        moduleId?: string(name='ModuleId'),
        resourceData?: map[string][ DataItemsResourceDataValue         ](name='ResourceData'),
        resourceDataPath?: map[string]string(name='ResourceDataPath'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleResourcesResponseBody(name='body'),
}

async function listModuleResourcesWithOptions(request: ListModuleResourcesRequest, runtime: Util.RuntimeOptions): ListModuleResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.moduleList)) {
    query['ModuleList'] = request.moduleList;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.types)) {
    query['Types'] = request.types;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModuleResources',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModuleResources(request: ListModuleResourcesRequest): ListModuleResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModuleResourcesWithOptions(request, runtime);
}

model ListModulesRequest {
  description?: string(name='Description'),
  hasOwnerApp?: boolean(name='HasOwnerApp'),
  moduleId?: string(name='ModuleId'),
  moduleName?: string(name='ModuleName'),
  platform?: string(name='Platform'),
  source?: string(name='Source'),
}

model ListModulesResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulesResponseBody(name='body'),
}

async function listModulesWithOptions(request: ListModulesRequest, runtime: Util.RuntimeOptions): ListModulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.hasOwnerApp)) {
    query['HasOwnerApp'] = request.hasOwnerApp;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModules',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModules(request: ListModulesRequest): ListModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModulesWithOptions(request, runtime);
}

model ListModulesByPageRequest {
  customParentId?: string(name='CustomParentId'),
  description?: string(name='Description'),
  hasOwnerApp?: boolean(name='HasOwnerApp'),
  moduleId?: string(name='ModuleId'),
  moduleName?: string(name='ModuleName'),
  moduleType?: string(name='ModuleType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  platform?: string(name='Platform'),
  source?: string(name='Source'),
}

model ListModulesByPageResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        moduleType?: string(name='ModuleType'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulesByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulesByPageResponseBody(name='body'),
}

async function listModulesByPageWithOptions(request: ListModulesByPageRequest, runtime: Util.RuntimeOptions): ListModulesByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.customParentId)) {
    query['CustomParentId'] = request.customParentId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.hasOwnerApp)) {
    query['HasOwnerApp'] = request.hasOwnerApp;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.moduleType)) {
    query['ModuleType'] = request.moduleType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListModulesByPage',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listModulesByPage(request: ListModulesByPageRequest): ListModulesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listModulesByPageWithOptions(request, runtime);
}

model ListPublishVersionsRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  source?: string(name='Source'),
}

model ListPublishVersionsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitId?: string(name='CommitId'),
        completionTime?: string(name='CompletionTime'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        envId?: string(name='EnvId'),
        modifiedTime?: string(name='ModifiedTime'),
        publishId?: string(name='PublishId'),
        publishStatus?: string(name='PublishStatus'),
        publishType?: string(name='PublishType'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        subTasks?: [ map[string]string ](name='SubTasks'),
        versionNumber?: string(name='VersionNumber'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishVersionsResponseBody(name='body'),
}

async function listPublishVersionsWithOptions(request: ListPublishVersionsRequest, runtime: Util.RuntimeOptions): ListPublishVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishVersions',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublishVersions(request: ListPublishVersionsRequest): ListPublishVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishVersionsWithOptions(request, runtime);
}

model ListPublishedModulesRequest {
  description?: string(name='Description'),
  excludeAppId?: string(name='ExcludeAppId'),
  excludeModuleId?: string(name='ExcludeModuleId'),
  hasOwnerApp?: boolean(name='HasOwnerApp'),
  moduleId?: string(name='ModuleId'),
  moduleName?: string(name='ModuleName'),
  moduleType?: string(name='ModuleType'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  platform?: string(name='Platform'),
  source?: string(name='Source'),
}

model ListPublishedModulesResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        moduleType?: string(name='ModuleType'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishedModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishedModulesResponseBody(name='body'),
}

async function listPublishedModulesWithOptions(request: ListPublishedModulesRequest, runtime: Util.RuntimeOptions): ListPublishedModulesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.excludeAppId)) {
    query['ExcludeAppId'] = request.excludeAppId;
  }
  if (!Util.isUnset(request.excludeModuleId)) {
    query['ExcludeModuleId'] = request.excludeModuleId;
  }
  if (!Util.isUnset(request.hasOwnerApp)) {
    query['HasOwnerApp'] = request.hasOwnerApp;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.moduleType)) {
    query['ModuleType'] = request.moduleType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['Platform'] = request.platform;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishedModules',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublishedModules(request: ListPublishedModulesRequest): ListPublishedModulesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishedModulesWithOptions(request, runtime);
}

model ListPublishesRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  publishStatus?: string(name='PublishStatus'),
  publishType?: string(name='PublishType'),
  source?: string(name='Source'),
}

model ListPublishesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitId?: string(name='CommitId'),
        completionTime?: string(name='CompletionTime'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        envId?: string(name='EnvId'),
        modifiedTime?: string(name='ModifiedTime'),
        publishId?: string(name='PublishId'),
        publishStatus?: string(name='PublishStatus'),
        publishType?: string(name='PublishType'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        versionNumber?: string(name='VersionNumber'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishesResponseBody(name='body'),
}

async function listPublishesWithOptions(request: ListPublishesRequest, runtime: Util.RuntimeOptions): ListPublishesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.publishStatus)) {
    query['PublishStatus'] = request.publishStatus;
  }
  if (!Util.isUnset(request.publishType)) {
    query['PublishType'] = request.publishType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPublishes',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPublishes(request: ListPublishesRequest): ListPublishesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPublishesWithOptions(request, runtime);
}

model ListResourcesRequest {
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  imageProcessParameter?: string(name='ImageProcessParameter'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  source?: string(name='Source'),
  withContent?: boolean(name='WithContent'),
}

model ListResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: any(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDigest?: string(name='ResourceDigest'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesResponseBody(name='body'),
}

async function listResourcesWithOptions(request: ListResourcesRequest, runtime: Util.RuntimeOptions): ListResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageProcessParameter)) {
    query['ImageProcessParameter'] = request.imageProcessParameter;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResources',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourcesWithOptions(request, runtime);
}

model ListResourcesByPageRequest {
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  imageProcessParameter?: string(name='ImageProcessParameter'),
  moduleId?: string(name='ModuleId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  source?: string(name='Source'),
  withContent?: boolean(name='WithContent'),
}

model ListResourcesByPageResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDigest?: string(name='ResourceDigest'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListResourcesByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesByPageResponseBody(name='body'),
}

async function listResourcesByPageWithOptions(request: ListResourcesByPageRequest, runtime: Util.RuntimeOptions): ListResourcesByPageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.imageProcessParameter)) {
    query['ImageProcessParameter'] = request.imageProcessParameter;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.withContent)) {
    query['WithContent'] = request.withContent;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourcesByPage',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourcesByPage(request: ListResourcesByPageRequest): ListResourcesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourcesByPageWithOptions(request, runtime);
}

model ResetAppUserPasswordRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
  userName?: string(name='UserName'),
}

model ResetAppUserPasswordResponseBody = {
  data?: {
    password?: string(name='Password'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResetAppUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAppUserPasswordResponseBody(name='body'),
}

async function resetAppUserPasswordWithOptions(request: ResetAppUserPasswordRequest, runtime: Util.RuntimeOptions): ResetAppUserPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAppUserPassword',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetAppUserPassword(request: ResetAppUserPasswordRequest): ResetAppUserPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAppUserPasswordWithOptions(request, runtime);
}

model RestoreModelRequest {
  appId?: string(name='AppId'),
  modelId?: string(name='ModelId'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model RestoreModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RestoreModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreModelResponseBody(name='body'),
}

async function restoreModelWithOptions(request: RestoreModelRequest, runtime: Util.RuntimeOptions): RestoreModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restoreModel(request: RestoreModelRequest): RestoreModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreModelWithOptions(request, runtime);
}

model RunLogicModelRequest {
  appId?: string(name='AppId'),
  commitId?: string(name='CommitId'),
  content?: string(name='Content'),
  encodeType?: string(name='EncodeType'),
  moduleId?: string(name='ModuleId'),
  parameters?: string(name='Parameters'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
}

model RunLogicModelResponseBody = {
  data?: {
    body?: string(name='Body'),
    headers?: map[string]string(name='Headers'),
    status?: int32(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RunLogicModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunLogicModelResponseBody(name='body'),
}

async function runLogicModelWithOptions(request: RunLogicModelRequest, runtime: Util.RuntimeOptions): RunLogicModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.commitId)) {
    query['CommitId'] = request.commitId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.encodeType)) {
    query['EncodeType'] = request.encodeType;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RunLogicModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function runLogicModel(request: RunLogicModelRequest): RunLogicModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return runLogicModelWithOptions(request, runtime);
}

model SetEnvironmentDefaultDomainRequest {
  appId?: string(name='AppId'),
  domain?: string(name='Domain'),
  domainType?: string(name='DomainType'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model SetEnvironmentDefaultDomainResponseBody = {
  data?: {
    configChanged?: boolean(name='ConfigChanged'),
    defaultMasterDomain?: string(name='DefaultMasterDomain'),
    defaultStaticDomain?: string(name='DefaultStaticDomain'),
    masterDomain?: string(name='MasterDomain'),
    masterDomainApplied?: boolean(name='MasterDomainApplied'),
    staticDomain?: string(name='StaticDomain'),
    staticDomainApplied?: boolean(name='StaticDomainApplied'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SetEnvironmentDefaultDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetEnvironmentDefaultDomainResponseBody(name='body'),
}

async function setEnvironmentDefaultDomainWithOptions(request: SetEnvironmentDefaultDomainRequest, runtime: Util.RuntimeOptions): SetEnvironmentDefaultDomainResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.domain)) {
    query['Domain'] = request.domain;
  }
  if (!Util.isUnset(request.domainType)) {
    query['DomainType'] = request.domainType;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetEnvironmentDefaultDomain',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setEnvironmentDefaultDomain(request: SetEnvironmentDefaultDomainRequest): SetEnvironmentDefaultDomainResponse {
  var runtime = new Util.RuntimeOptions{};
  return setEnvironmentDefaultDomainWithOptions(request, runtime);
}

model StartAppServerRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model StartAppServerResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appServerStatus?: string(name='AppServerStatus'),
    envId?: string(name='EnvId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartAppServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartAppServerResponseBody(name='body'),
}

async function startAppServerWithOptions(request: StartAppServerRequest, runtime: Util.RuntimeOptions): StartAppServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartAppServer',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startAppServer(request: StartAppServerRequest): StartAppServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return startAppServerWithOptions(request, runtime);
}

model StopAppServerRequest {
  appId?: string(name='AppId'),
  envId?: string(name='EnvId'),
  source?: string(name='Source'),
}

model StopAppServerResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appServerStatus?: string(name='AppServerStatus'),
    envId?: string(name='EnvId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model StopAppServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopAppServerResponseBody(name='body'),
}

async function stopAppServerWithOptions(request: StopAppServerRequest, runtime: Util.RuntimeOptions): StopAppServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.envId)) {
    query['EnvId'] = request.envId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopAppServer',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopAppServer(request: StopAppServerRequest): StopAppServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopAppServerWithOptions(request, runtime);
}

model UpdateAppRequest {
  appId?: string(name='AppId'),
  appName?: string(name='AppName'),
  description?: string(name='Description'),
  icon?: string(name='Icon'),
  source?: string(name='Source'),
}

model UpdateAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppResponseBody(name='body'),
}

async function updateAppWithOptions(request: UpdateAppRequest, runtime: Util.RuntimeOptions): UpdateAppResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.appName)) {
    query['AppName'] = request.appName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.icon)) {
    query['Icon'] = request.icon;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateApp',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateApp(request: UpdateAppRequest): UpdateAppResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppWithOptions(request, runtime);
}

model UpdateAppModelRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  encodeType?: string(name='EncodeType'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
  subType?: string(name='SubType'),
}

model UpdateAppModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAppModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppModelResponseBody(name='body'),
}

async function updateAppModelWithOptions(request: UpdateAppModelRequest, runtime: Util.RuntimeOptions): UpdateAppModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.encodeType)) {
    query['EncodeType'] = request.encodeType;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.subType)) {
    query['SubType'] = request.subType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppModel(request: UpdateAppModelRequest): UpdateAppModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppModelWithOptions(request, runtime);
}

model UpdateModelRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  description?: string(name='Description'),
  encodeType?: string(name='EncodeType'),
  modelId?: string(name='ModelId'),
  modelName?: string(name='ModelName'),
  moduleId?: string(name='ModuleId'),
  schemaVersion?: string(name='SchemaVersion'),
  source?: string(name='Source'),
}

model UpdateModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModelResponseBody(name='body'),
}

async function updateModelWithOptions(request: UpdateModelRequest, runtime: Util.RuntimeOptions): UpdateModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encodeType)) {
    query['EncodeType'] = request.encodeType;
  }
  if (!Util.isUnset(request.modelId)) {
    query['ModelId'] = request.modelId;
  }
  if (!Util.isUnset(request.modelName)) {
    query['ModelName'] = request.modelName;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.schemaVersion)) {
    query['SchemaVersion'] = request.schemaVersion;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateModel',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateModel(request: UpdateModelRequest): UpdateModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateModelWithOptions(request, runtime);
}

model UpdateModuleRequest {
  description?: string(name='Description'),
  moduleId?: string(name='ModuleId'),
  moduleName?: string(name='ModuleName'),
  source?: string(name='Source'),
}

model UpdateModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModuleResponseBody(name='body'),
}

async function updateModuleWithOptions(request: UpdateModuleRequest, runtime: Util.RuntimeOptions): UpdateModuleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.moduleName)) {
    query['ModuleName'] = request.moduleName;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateModule',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateModule(request: UpdateModuleRequest): UpdateModuleResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateModuleWithOptions(request, runtime);
}

model UpdateResourceRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  description?: string(name='Description'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  source?: string(name='Source'),
}

model UpdateResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceResponseBody(name='body'),
}

async function updateResourceWithOptions(request: UpdateResourceRequest, runtime: Util.RuntimeOptions): UpdateResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResource',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResource(request: UpdateResourceRequest): UpdateResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceWithOptions(request, runtime);
}

model UpdateResourceContentRequest {
  appId?: string(name='AppId'),
  content?: string(name='Content'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  source?: string(name='Source'),
}

model UpdateResourceContentResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceContentResponseBody(name='body'),
}

async function updateResourceContentWithOptions(request: UpdateResourceContentRequest, runtime: Util.RuntimeOptions): UpdateResourceContentResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.content)) {
    query['Content'] = request.content;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceContent',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceContent(request: UpdateResourceContentRequest): UpdateResourceContentResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceContentWithOptions(request, runtime);
}

model UpdateResourceInfoRequest {
  appId?: string(name='AppId'),
  description?: string(name='Description'),
  moduleId?: string(name='ModuleId'),
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  source?: string(name='Source'),
}

model UpdateResourceInfoResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceInfoResponseBody(name='body'),
}

async function updateResourceInfoWithOptions(request: UpdateResourceInfoRequest, runtime: Util.RuntimeOptions): UpdateResourceInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.appId)) {
    query['AppId'] = request.appId;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.moduleId)) {
    query['ModuleId'] = request.moduleId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceName)) {
    query['ResourceName'] = request.resourceName;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInfo',
    version = '2020-01-13',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceInfo(request: UpdateResourceInfoRequest): UpdateResourceInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceInfoWithOptions(request, runtime);
}

