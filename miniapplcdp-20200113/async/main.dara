/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'miniapplcdp';
  @version = '2020-01-13';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model BatchCreateModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelDataJson: string(name='ModelDataJson', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType: string(name='SubType', position='Query'),
}

model BatchCreateModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelDigest?: string(name='ModelDigest'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchCreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchCreateModelResponseBody(name='body'),
}

async function batchCreateModel(request: BatchCreateModelRequest): BatchCreateModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchCreateModel', 'POST', '/', 'json', false, 'json', request);
}

model BatchDeleteModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelIdList: string(name='ModelIdList', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model BatchDeleteModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteModelResponseBody(name='body'),
}

async function batchDeleteModel(request: BatchDeleteModelRequest): BatchDeleteModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteModel', 'POST', '/', 'json', false, 'json', request);
}

model BatchDeleteResourcesRequest {
  appId?: string(name='AppId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceIdList: string(name='ResourceIdList', position='Query'),
  source?: string(name='Source', position='Query'),
}

model BatchDeleteResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchDeleteResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteResourcesResponseBody(name='body'),
}

async function batchDeleteResources(request: BatchDeleteResourcesRequest): BatchDeleteResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteResources', 'POST', '/', 'json', false, 'json', request);
}

model BatchRestoreModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelIdList: string(name='ModelIdList', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model BatchRestoreModelResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model BatchRestoreModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchRestoreModelResponseBody(name='body'),
}

async function batchRestoreModel(request: BatchRestoreModelRequest): BatchRestoreModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchRestoreModel', 'POST', '/', 'json', false, 'json', request);
}

model CheckDomainRequest {
  appId: string(name='AppId', position='Query'),
  domain: string(name='Domain', position='Query'),
  domainType: string(name='DomainType', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model CheckDomainResponseBody = {
  data?: {
    valid?: boolean(name='Valid'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CheckDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckDomainResponseBody(name='body'),
}

async function checkDomain(request: CheckDomainRequest): CheckDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDomain', 'POST', '/', 'json', false, 'json', request);
}

model CloneAppRequest {
  appId: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  description?: string(name='Description', position='Query'),
  icon?: string(name='Icon', position='Query'),
  source?: string(name='Source', position='Query'),
}

model CloneAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneAppResponseBody(name='body'),
}

async function cloneApp(request: CloneAppRequest): CloneAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneApp', 'POST', '/', 'json', false, 'json', request);
}

model CloneModelFromCommitRequest {
  modelId: string(name='ModelId', position='Query'),
  source?: string(name='Source', position='Query'),
  sourceCommitId: string(name='SourceCommitId', position='Query'),
  sourceModuleId: string(name='SourceModuleId', position='Query'),
  subType: string(name='SubType', position='Query'),
  targetModuleId: string(name='TargetModuleId', position='Query'),
  targetName?: string(name='TargetName', position='Query'),
  targetSubType?: string(name='TargetSubType', position='Query'),
}

model CloneModelFromCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneModelFromCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneModelFromCommitResponseBody(name='body'),
}

async function cloneModelFromCommit(request: CloneModelFromCommitRequest): CloneModelFromCommitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneModelFromCommit', 'POST', '/', 'json', false, 'json', request);
}

model CloneModelInModuleRequest {
  modelId: string(name='ModelId', position='Query'),
  moduleId: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
  targetName?: string(name='TargetName', position='Query'),
  targetSubType?: string(name='TargetSubType', position='Query'),
}

model CloneModelInModuleResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CloneModelInModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloneModelInModuleResponseBody(name='body'),
}

async function cloneModelInModule(request: CloneModelInModuleRequest): CloneModelInModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneModelInModule', 'POST', '/', 'json', false, 'json', request);
}

model CreateAppRequest {
  appName?: string(name='AppName', position='Query'),
  appType?: string(name='AppType', position='Query'),
  asynchronous?: boolean(name='Asynchronous', position='Query'),
  categoryId?: string(name='CategoryId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  icon?: string(name='Icon', position='Query'),
  platformVersion?: string(name='PlatformVersion', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  sourceCommitId?: string(name='SourceCommitId', position='Query'),
  templateId?: string(name='TemplateId', position='Query'),
  templated?: boolean(name='Templated', position='Query'),
}

model CreateAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppResponseBody(name='body'),
}

async function createApp(request: CreateAppRequest): CreateAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateApp', 'POST', '/', 'json', false, 'json', request);
}

model CreateCommitRequest {
  appId?: string(name='AppId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  commitLog?: string(name='CommitLog', position='Query'),
  commitType?: string(name='CommitType', position='Query'),
  mainModuleCommitId?: string(name='MainModuleCommitId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  rollbackToCommitId?: string(name='RollbackToCommitId', position='Query'),
  rollbackType?: string(name='RollbackType', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model CreateCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCommitResponseBody(name='body'),
}

async function createCommit(request: CreateCommitRequest): CreateCommitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCommit', 'POST', '/', 'json', false, 'json', request);
}

model CreateDomainRequest {
  appId: string(name='AppId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  domain: string(name='Domain', position='Query'),
  domainType: string(name='DomainType', position='Query'),
  envId: string(name='EnvId', position='Query'),
  path?: string(name='Path', position='Query'),
  privateKey?: string(name='PrivateKey', position='Query'),
  publicKey?: string(name='PublicKey', position='Query'),
  source?: string(name='Source', position='Query'),
  withCertificate?: boolean(name='WithCertificate', position='Query'),
}

model CreateDomainResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    checked?: boolean(name='Checked'),
    cname?: string(name='Cname'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
    withCertificate?: boolean(name='WithCertificate'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateDomainResponseBody(name='body'),
}

async function createDomain(request: CreateDomainRequest): CreateDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDomain', 'POST', '/', 'json', false, 'json', request);
}

model CreateLinkEntityAndAssociationRequest {
  clientToken: string(name='ClientToken', position='Query'),
  modelData: string(name='ModelData', position='Query'),
  source?: string(name='Source', position='Query'),
}

model CreateLinkEntityAndAssociationResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateLinkEntityAndAssociationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLinkEntityAndAssociationResponseBody(name='body'),
}

async function createLinkEntityAndAssociation(request: CreateLinkEntityAndAssociationRequest): CreateLinkEntityAndAssociationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLinkEntityAndAssociation', 'POST', '/', 'json', false, 'json', request);
}

model CreateModelRequest {
  appId?: string(name='AppId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  content?: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  encodeType?: string(name='EncodeType', position='Query'),
  linkModelId?: string(name='LinkModelId', position='Query'),
  linkModuleId?: string(name='LinkModuleId', position='Query'),
  linked?: boolean(name='Linked', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  modelName: string(name='ModelName', position='Query'),
  modelType: string(name='ModelType', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType: string(name='SubType', position='Query'),
  visibility?: string(name='Visibility', position='Query'),
}

model CreateModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModelResponseBody(name='body'),
}

async function createModel(request: CreateModelRequest): CreateModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateModel', 'POST', '/', 'json', false, 'json', request);
}

model CreateModuleRequest {
  clientToken: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  icon?: string(name='Icon', position='Query'),
  minimumPlatformVersion?: string(name='MinimumPlatformVersion', position='Query'),
  moduleName: string(name='ModuleName', position='Query'),
  moduleType?: string(name='ModuleType', position='Query'),
  platform: string(name='Platform', position='Query'),
  source?: string(name='Source', position='Query'),
  sourceModuleId?: string(name='SourceModuleId', position='Query'),
  targetAppSource?: string(name='TargetAppSource', position='Query'),
}

model CreateModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    moduleType?: string(name='ModuleType'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
    platformVersion?: string(name='PlatformVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModuleResponseBody(name='body'),
}

async function createModule(request: CreateModuleRequest): CreateModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateModule', 'POST', '/', 'json', false, 'json', request);
}

model CreateModulePublishRequest {
  clientToken: string(name='ClientToken', position='Query'),
  description?: string(name='Description', position='Query'),
  moduleId: string(name='ModuleId', position='Query'),
  publishVersion: string(name='PublishVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model CreateModulePublishResponseBody = {
  data?: {
    commitId?: string(name='CommitId'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    publishId?: string(name='PublishId'),
    version?: string(name='Version'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateModulePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateModulePublishResponseBody(name='body'),
}

async function createModulePublish(request: CreateModulePublishRequest): CreateModulePublishResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateModulePublish', 'POST', '/', 'json', false, 'json', request);
}

model CreatePublishRequest {
  appId: string(name='AppId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  commitId: string(name='CommitId', position='Query'),
  description?: string(name='Description', position='Query'),
  envType: string(name='EnvType', position='Query'),
  publishType: string(name='PublishType', position='Query'),
  source?: string(name='Source', position='Query'),
  versionNumber?: string(name='VersionNumber', position='Query'),
}

model CreatePublishResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    completionTime?: string(name='CompletionTime'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    envId?: string(name='EnvId'),
    modifiedTime?: string(name='ModifiedTime'),
    publishId?: string(name='PublishId'),
    publishStatus?: string(name='PublishStatus'),
    publishType?: string(name='PublishType'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    subTasks?: [ map[string]string ](name='SubTasks'),
    versionNumber?: string(name='VersionNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreatePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreatePublishResponseBody(name='body'),
}

async function createPublish(request: CreatePublishRequest): CreatePublishResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreatePublish', 'POST', '/', 'json', false, 'json', request);
}

model CreateResourceRequest {
  appId?: string(name='AppId', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  content: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceName: string(name='ResourceName', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  visibility?: string(name='Visibility', position='Query'),
}

model CreateResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model CreateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateResourceResponseBody(name='body'),
}

async function createResource(request: CreateResourceRequest): CreateResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAppRequest {
  appId: string(name='AppId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAppResponseBody(name='body'),
}

async function deleteApp(request: DeleteAppRequest): DeleteAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteApp', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCommitRequest {
  appId?: string(name='AppId', position='Query'),
  commitId: string(name='CommitId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCommitResponseBody(name='body'),
}

async function deleteCommit(request: DeleteCommitRequest): DeleteCommitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCommit', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDomainRequest {
  appId: string(name='AppId', position='Query'),
  domain: string(name='Domain', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteDomainResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteDomainResponseBody(name='body'),
}

async function deleteDomain(request: DeleteDomainRequest): DeleteDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelId: string(name='ModelId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModelResponseBody(name='body'),
}

async function deleteModel(request: DeleteModelRequest): DeleteModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteModel', 'POST', '/', 'json', false, 'json', request);
}

model DeleteModuleRequest {
  moduleId: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteModuleResponseBody(name='body'),
}

async function deleteModule(request: DeleteModuleRequest): DeleteModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteModule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteResourceRequest {
  appId?: string(name='AppId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model DeleteResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model DeleteResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteResourceResponseBody(name='body'),
}

async function deleteResource(request: DeleteResourceRequest): DeleteResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteResource', 'POST', '/', 'json', false, 'json', request);
}

model GenerateAppUserPasswordRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
  userName: string(name='UserName', position='Query'),
}

model GenerateAppUserPasswordResponseBody = {
  data?: {
    password?: string(name='Password'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateAppUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateAppUserPasswordResponseBody(name='body'),
}

async function generateAppUserPassword(request: GenerateAppUserPasswordRequest): GenerateAppUserPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateAppUserPassword', 'POST', '/', 'json', false, 'json', request);
}

model GenerateAuthTokenRequest {
  appId?: string(name='AppId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GenerateAuthTokenResponseBody = {
  data?: {
    jwtToken?: string(name='JwtToken'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateAuthTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateAuthTokenResponseBody(name='body'),
}

async function generateAuthToken(request: GenerateAuthTokenRequest): GenerateAuthTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateAuthToken', 'POST', '/', 'json', false, 'json', request);
}

model GenerateUploadTokenRequest {
  appId?: string(name='AppId', position='Query'),
  materialId?: string(name='MaterialId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
  uploadTokenType?: string(name='UploadTokenType', position='Query'),
}

model GenerateUploadTokenResponseBody = {
  data?: {
    key?: string(name='Key'),
    ossAccessKeyId?: string(name='OssAccessKeyId'),
    policy?: string(name='Policy'),
    serverURL?: string(name='ServerURL'),
    signature?: string(name='Signature'),
    xAmzAlgorithm?: string(name='X-Amz-Algorithm'),
    xAmzCredential?: string(name='X-Amz-Credential'),
    xAmzDate?: string(name='X-Amz-Date'),
    xAmzSignature?: string(name='X-Amz-Signature'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GenerateUploadTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GenerateUploadTokenResponseBody(name='body'),
}

async function generateUploadToken(request: GenerateUploadTokenRequest): GenerateUploadTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateUploadToken', 'POST', '/', 'json', false, 'json', request);
}

model GetAppRequest {
  appId: string(name='AppId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppResponseBody(name='body'),
}

async function getApp(request: GetAppRequest): GetAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetApp', 'POST', '/', 'json', false, 'json', request);
}

model GetAppModelRequest {
  appId: string(name='AppId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model GetAppModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppModelResponseBody(name='body'),
}

async function getAppModel(request: GetAppModelRequest): GetAppModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppModel', 'POST', '/', 'json', false, 'json', request);
}

model GetAppSecretRequest {
  appId: string(name='AppId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetAppSecretResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appSecret?: string(name='AppSecret'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetAppSecretResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppSecretResponseBody(name='body'),
}

async function getAppSecret(request: GetAppSecretRequest): GetAppSecretResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppSecret', 'POST', '/', 'json', false, 'json', request);
}

model GetArtifactRequest {
  appId: string(name='AppId', position='Query'),
  artifactId: string(name='ArtifactId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetArtifactResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    artifactId?: string(name='ArtifactId'),
    artifactType?: string(name='ArtifactType'),
    available?: boolean(name='Available'),
    createTime?: string(name='CreateTime'),
    modifiedTime?: string(name='ModifiedTime'),
    url?: string(name='Url'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetArtifactResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetArtifactResponseBody(name='body'),
}

async function getArtifact(request: GetArtifactRequest): GetArtifactResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetArtifact', 'POST', '/', 'json', false, 'json', request);
}

model GetCommitRequest {
  appId?: string(name='AppId', position='Query'),
  commitId: string(name='CommitId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitDigest?: string(name='CommitDigest'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modelDigest?: map[string]string(name='ModelDigest'),
    modelPack?: [ any ](name='ModelPack'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    resourcePack?: [ map[string]string ](name='ResourcePack'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCommitResponseBody(name='body'),
}

async function getCommit(request: GetCommitRequest): GetCommitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCommit', 'POST', '/', 'json', false, 'json', request);
}

model GetDefaultAppUserRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetDefaultAppUserResponseBody = {
  data?: {
    hasPassword?: boolean(name='HasPassword'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDefaultAppUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDefaultAppUserResponseBody(name='body'),
}

async function getDefaultAppUser(request: GetDefaultAppUserRequest): GetDefaultAppUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDefaultAppUser', 'POST', '/', 'json', false, 'json', request);
}

model GetDomainCnameRequest {
  appId: string(name='AppId', position='Query'),
  domain?: string(name='Domain', position='Query'),
  domainType: string(name='DomainType', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetDomainCnameResponseBody = {
  data?: {
    cname?: string(name='Cname'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDomainCnameResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainCnameResponseBody(name='body'),
}

async function getDomainCname(request: GetDomainCnameRequest): GetDomainCnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDomainCname', 'POST', '/', 'json', false, 'json', request);
}

model GetDomainOverviewRequest {
  appId: string(name='AppId', position='Query'),
  domain: string(name='Domain', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetDomainOverviewResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    applied?: boolean(name='Applied'),
    certificate?: map[string]string(name='Certificate'),
    cname?: string(name='Cname'),
    deleted?: boolean(name='Deleted'),
    domain?: string(name='Domain'),
    domainType?: string(name='DomainType'),
    envId?: string(name='EnvId'),
    path?: string(name='Path'),
    withCertificate?: boolean(name='WithCertificate'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetDomainOverviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetDomainOverviewResponseBody(name='body'),
}

async function getDomainOverview(request: GetDomainOverviewRequest): GetDomainOverviewResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDomainOverview', 'POST', '/', 'json', false, 'json', request);
}

model GetEnvironmentRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetEnvironmentResponseBody = {
  data?: {
    accountOpsEndpoint?: string(name='AccountOpsEndpoint'),
    appId?: string(name='AppId'),
    createTime?: string(name='CreateTime'),
    currentPublishId?: string(name='CurrentPublishId'),
    endpoint?: string(name='Endpoint'),
    envId?: string(name='EnvId'),
    envType?: string(name='EnvType'),
    modifiedTime?: string(name='ModifiedTime'),
    publishingId?: string(name='PublishingId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetEnvironmentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEnvironmentResponseBody(name='body'),
}

async function getEnvironment(request: GetEnvironmentRequest): GetEnvironmentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEnvironment', 'POST', '/', 'json', false, 'json', request);
}

model GetHistoryStatsRequest {
  appId: string(name='AppId', position='Query'),
  endDate?: string(name='EndDate', position='Query'),
  source?: string(name='Source', position='Query'),
  startDate?: string(name='StartDate', position='Query'),
}

model GetHistoryStatsResponseBody = {
  data?: {
    historyPv?: map[string]string(name='HistoryPv'),
    historyUv?: map[string]string(name='HistoryUv'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetHistoryStatsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetHistoryStatsResponseBody(name='body'),
}

async function getHistoryStats(request: GetHistoryStatsRequest): GetHistoryStatsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetHistoryStats', 'POST', '/', 'json', false, 'json', request);
}

model GetLatestCommitRequest {
  appId?: string(name='AppId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetLatestCommitResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    commitLog?: string(name='CommitLog'),
    commitType?: string(name='CommitType'),
    createTime?: string(name='CreateTime'),
    mainModuleCommitId?: string(name='MainModuleCommitId'),
    mainModuleId?: string(name='MainModuleId'),
    modelDataPath?: string(name='ModelDataPath'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDataPath?: string(name='ResourceDataPath'),
    resourceDigest?: map[string]string(name='ResourceDigest'),
    rollbackToCommitId?: string(name='RollbackToCommitId'),
    rollbackType?: string(name='RollbackType'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetLatestCommitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLatestCommitResponseBody(name='body'),
}

async function getLatestCommit(request: GetLatestCommitRequest): GetLatestCommitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLatestCommit', 'POST', '/', 'json', false, 'json', request);
}

model GetModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelId: string(name='ModelId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModelResponseBody(name='body'),
}

async function getModel(request: GetModelRequest): GetModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetModel', 'POST', '/', 'json', false, 'json', request);
}

model GetModuleRequest {
  moduleId: string(name='ModuleId', position='Query'),
  moduleType?: string(name='ModuleType', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
    platformVersion?: string(name='PlatformVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetModuleResponseBody(name='body'),
}

async function getModule(request: GetModuleRequest): GetModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetModule', 'POST', '/', 'json', false, 'json', request);
}

model GetPublishRequest {
  appId: string(name='AppId', position='Query'),
  publishId: string(name='PublishId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetPublishResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    commitId?: string(name='CommitId'),
    completionTime?: string(name='CompletionTime'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    envId?: string(name='EnvId'),
    modifiedTime?: string(name='ModifiedTime'),
    publishId?: string(name='PublishId'),
    publishStatus?: string(name='PublishStatus'),
    publishType?: string(name='PublishType'),
    reason?: string(name='Reason'),
    startTime?: string(name='StartTime'),
    subTasks?: [ map[string]string ](name='SubTasks'),
    versionNumber?: string(name='VersionNumber'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetPublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetPublishResponseBody(name='body'),
}

async function getPublish(request: GetPublishRequest): GetPublishResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetPublish', 'POST', '/', 'json', false, 'json', request);
}

model GetRealtimeStatsRequest {
  appId: string(name='AppId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetRealtimeStatsResponseBody = {
  data?: {
    todayPvCount?: map[string]string(name='TodayPvCount'),
    todayUvCount?: map[string]string(name='TodayUvCount'),
    totalPvCount?: map[string]string(name='TotalPvCount'),
    totalUvCount?: map[string]string(name='TotalUvCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetRealtimeStatsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetRealtimeStatsResponseBody(name='body'),
}

async function getRealtimeStats(request: GetRealtimeStatsRequest): GetRealtimeStatsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetRealtimeStats', 'POST', '/', 'json', false, 'json', request);
}

model GetResourceRequest {
  appId?: string(name='AppId', position='Query'),
  imageProcessParameter?: string(name='ImageProcessParameter', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model GetResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetResourceResponseBody(name='body'),
}

async function getResource(request: GetResourceRequest): GetResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetResource', 'POST', '/', 'json', false, 'json', request);
}

model GetUserRequest {
  source?: string(name='Source', position='Query'),
}

model GetUserResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    platformVersion?: string(name='PlatformVersion'),
    userSecret?: string(name='UserSecret'),
    userStatus?: string(name='UserStatus'),
    userType?: string(name='UserType'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model GetUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetUserResponseBody(name='body'),
}

async function getUser(request: GetUserRequest): GetUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetUser', 'POST', '/', 'json', false, 'json', request);
}

model ListAppModulesRequest {
  appId: string(name='AppId', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListAppModulesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        description?: string(name='Description'),
        directDependency?: boolean(name='DirectDependency'),
        icon?: string(name='Icon'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppModulesResponseBody(name='body'),
}

async function listAppModules(request: ListAppModulesRequest): ListAppModulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppModules', 'POST', '/', 'json', false, 'json', request);
}

model ListAppTemplatesRequest {
  appType: string(name='AppType', position='Query'),
  source?: string(name='Source', position='Query'),
  templateType?: string(name='TemplateType', position='Query'),
}

model ListAppTemplatesResponseBody = {
  data?: {
    items?: [ 
      {
        appName?: string(name='AppName'),
        appType?: string(name='AppType'),
        categoryName?: string(name='CategoryName'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        lastEditTime?: string(name='LastEditTime'),
        mainModuleId?: string(name='MainModuleId'),
        modifiedTime?: string(name='ModifiedTime'),
        schemaVersion?: string(name='SchemaVersion'),
        source?: string(name='Source'),
        templateId?: string(name='TemplateId'),
        templateType?: string(name='TemplateType'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppTemplatesResponseBody(name='body'),
}

async function listAppTemplates(request: ListAppTemplatesRequest): ListAppTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListAppTemplates', 'POST', '/', 'json', false, 'json', request);
}

model ListAppsRequest {
  appId?: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  appStatus?: string(name='AppStatus', position='Query'),
  appType?: string(name='AppType', position='Query'),
  customParentId?: string(name='CustomParentId', position='Query'),
  description?: string(name='Description', position='Query'),
  mainModuleId?: string(name='MainModuleId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  source?: string(name='Source', position='Query'),
  template?: boolean(name='Template', position='Query'),
}

model ListAppsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        appName?: string(name='AppName'),
        appStatus?: string(name='AppStatus'),
        appType?: string(name='AppType'),
        categories?: [ 
          {
            categoryId?: string(name='CategoryId'),
            categoryName?: string(name='CategoryName'),
            parentCategoryId?: string(name='ParentCategoryId'),
          }
        ](name='Categories'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        isTemplate?: boolean(name='IsTemplate'),
        lastEditTime?: string(name='LastEditTime'),
        mainModuleId?: string(name='MainModuleId'),
        modifiedTime?: string(name='ModifiedTime'),
        platformVersion?: string(name='PlatformVersion'),
        schemaVersion?: string(name='SchemaVersion'),
        source?: string(name='Source'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListAppsResponseBody(name='body'),
}

async function listApps(request: ListAppsRequest): ListAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListApps', 'POST', '/', 'json', false, 'json', request);
}

model ListArtifactsRequest {
  appId: string(name='AppId', position='Query'),
  publishId: string(name='PublishId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListArtifactsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        artifactId?: string(name='ArtifactId'),
        artifactType?: string(name='ArtifactType'),
        available?: boolean(name='Available'),
        createTime?: string(name='CreateTime'),
        modifiedTime?: string(name='ModifiedTime'),
        url?: string(name='Url'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListArtifactsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListArtifactsResponseBody(name='body'),
}

async function listArtifacts(request: ListArtifactsRequest): ListArtifactsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListArtifacts', 'POST', '/', 'json', false, 'json', request);
}

model ListCommitsRequest {
  appId?: string(name='AppId', position='Query'),
  commitLog?: string(name='CommitLog', position='Query'),
  customParentId?: string(name='CustomParentId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListCommitsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitDigest?: string(name='CommitDigest'),
        commitId?: string(name='CommitId'),
        commitLog?: string(name='CommitLog'),
        commitType?: string(name='CommitType'),
        createTime?: string(name='CreateTime'),
        mainModuleCommitId?: string(name='MainModuleCommitId'),
        mainModuleId?: string(name='MainModuleId'),
        modelDataPath?: string(name='ModelDataPath'),
        modelDigest?: map[string]string(name='ModelDigest'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDataPath?: string(name='ResourceDataPath'),
        resourceDigest?: map[string]string(name='ResourceDigest'),
        rollbackToCommitId?: string(name='RollbackToCommitId'),
        rollbackType?: string(name='RollbackType'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListCommitsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListCommitsResponseBody(name='body'),
}

async function listCommits(request: ListCommitsRequest): ListCommitsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListCommits', 'POST', '/', 'json', false, 'json', request);
}

model ListDomainsRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListDomainsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        applied?: boolean(name='Applied'),
        checked?: boolean(name='Checked'),
        cname?: string(name='Cname'),
        deleted?: boolean(name='Deleted'),
        domain?: string(name='Domain'),
        domainType?: string(name='DomainType'),
        envId?: string(name='EnvId'),
        path?: string(name='Path'),
        withCertificate?: boolean(name='WithCertificate'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListDomainsResponseBody(name='body'),
}

async function listDomains(request: ListDomainsRequest): ListDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListDomains', 'POST', '/', 'json', false, 'json', request);
}

model ListEnvironmentOverviewsRequest {
  appId: string(name='AppId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListEnvironmentOverviewsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        config?: map[string]string(name='Config'),
        createTime?: string(name='CreateTime'),
        currentPublish?: map[string]string(name='CurrentPublish'),
        endpoint?: string(name='Endpoint'),
        envId?: string(name='EnvId'),
        envStatus?: string(name='EnvStatus'),
        envType?: string(name='EnvType'),
        latestAppAccessTime?: string(name='LatestAppAccessTime'),
        modifiedTime?: string(name='ModifiedTime'),
        opsRecord?: map[string]string(name='OpsRecord'),
        publishing?: map[string]string(name='Publishing'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListEnvironmentOverviewsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentOverviewsResponseBody(name='body'),
}

async function listEnvironmentOverviews(request: ListEnvironmentOverviewsRequest): ListEnvironmentOverviewsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEnvironmentOverviews', 'POST', '/', 'json', false, 'json', request);
}

model ListEnvironmentsRequest {
  appId: string(name='AppId', position='Query'),
  envType?: string(name='EnvType', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListEnvironmentsResponseBody = {
  data?: {
    items?: [ 
      {
        accountOpsEndpoint?: string(name='AccountOpsEndpoint'),
        appId?: string(name='AppId'),
        createTime?: string(name='CreateTime'),
        currentPublishId?: string(name='CurrentPublishId'),
        endpoint?: string(name='Endpoint'),
        envId?: string(name='EnvId'),
        envType?: string(name='EnvType'),
        modifiedTime?: string(name='ModifiedTime'),
        publishingId?: string(name='PublishingId'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListEnvironmentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEnvironmentsResponseBody(name='body'),
}

async function listEnvironments(request: ListEnvironmentsRequest): ListEnvironmentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEnvironments', 'POST', '/', 'json', false, 'json', request);
}

model ListModelsRequest {
  appId?: string(name='AppId', position='Query'),
  modelId?: string(name='ModelId', position='Query'),
  modelName?: string(name='ModelName', position='Query'),
  modelType?: string(name='ModelType', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType?: string(name='SubType', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListModelsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelDigest?: string(name='ModelDigest'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsResponseBody(name='body'),
}

async function listModels(request: ListModelsRequest): ListModelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModels', 'POST', '/', 'json', false, 'json', request);
}

model ListModelsByPageRequest {
  appId?: string(name='AppId', position='Query'),
  modelName?: string(name='ModelName', position='Query'),
  modelType?: string(name='ModelType', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType?: string(name='SubType', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListModelsByPageResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        attributes?: [ map[string]string ](name='Attributes'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        id?: string(name='Id'),
        linkModelId?: string(name='LinkModelId'),
        linkModuleId?: string(name='LinkModuleId'),
        linked?: boolean(name='Linked'),
        modelId?: string(name='ModelId'),
        modelName?: string(name='ModelName'),
        modelStatus?: string(name='ModelStatus'),
        modelType?: string(name='ModelType'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        props?: map[string]string(name='Props'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
        subType?: string(name='SubType'),
        visibility?: string(name='Visibility'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModelsByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModelsByPageResponseBody(name='body'),
}

async function listModelsByPage(request: ListModelsByPageRequest): ListModelsByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModelsByPage', 'POST', '/', 'json', false, 'json', request);
}

model ListModuleDependenciesRequest {
  moduleId: string(name='ModuleId', position='Query'),
  recursive?: boolean(name='Recursive', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListModuleDependenciesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        description?: string(name='Description'),
        directDependency?: boolean(name='DirectDependency'),
        icon?: string(name='Icon'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        origin?: string(name='Origin'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        version?: string(name='Version'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleDependenciesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleDependenciesResponseBody(name='body'),
}

async function listModuleDependencies(request: ListModuleDependenciesRequest): ListModuleDependenciesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModuleDependencies', 'POST', '/', 'json', false, 'json', request);
}

model ListModuleModelsRequest {
  moduleList: string(name='ModuleList', position='Query'),
  source?: string(name='Source', position='Query'),
  subTypes: string(name='SubTypes', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListModuleModelsResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        modelData?: map[string][ DataItemsModelDataValue         ](name='ModelData'),
        modelDataPath?: map[string]string(name='ModelDataPath'),
        modelDigest?: map[string]string(name='ModelDigest'),
        moduleId?: string(name='ModuleId'),
        resourceData?: map[string]string(name='ResourceData'),
        resourceDataPath?: map[string]string(name='ResourceDataPath'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleModelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleModelsResponseBody(name='body'),
}

async function listModuleModels(request: ListModuleModelsRequest): ListModuleModelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModuleModels', 'POST', '/', 'json', false, 'json', request);
}

model ListModulePublishVersionsRequest {
  customParentId?: string(name='CustomParentId', position='Query'),
  moduleId: string(name='ModuleId', position='Query'),
  moduleVersion?: string(name='ModuleVersion', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListModulePublishVersionsResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        platformVersion?: string(name='PlatformVersion'),
        publishId?: string(name='PublishId'),
        version?: string(name='Version'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulePublishVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulePublishVersionsResponseBody(name='body'),
}

async function listModulePublishVersions(request: ListModulePublishVersionsRequest): ListModulePublishVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModulePublishVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListModuleResourcesRequest {
  moduleList: string(name='ModuleList', position='Query'),
  source?: string(name='Source', position='Query'),
  types: string(name='Types', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListModuleResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        commitId?: string(name='CommitId'),
        modelData?: map[string]string(name='ModelData'),
        modelDataPath?: map[string]string(name='ModelDataPath'),
        moduleId?: string(name='ModuleId'),
        resourceData?: map[string][ DataItemsResourceDataValue         ](name='ResourceData'),
        resourceDataPath?: map[string]string(name='ResourceDataPath'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModuleResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModuleResourcesResponseBody(name='body'),
}

async function listModuleResources(request: ListModuleResourcesRequest): ListModuleResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModuleResources', 'POST', '/', 'json', false, 'json', request);
}

model ListModulesRequest {
  description?: string(name='Description', position='Query'),
  hasOwnerApp?: boolean(name='HasOwnerApp', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  moduleName?: string(name='ModuleName', position='Query'),
  platform?: string(name='Platform', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListModulesResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulesResponseBody(name='body'),
}

async function listModules(request: ListModulesRequest): ListModulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModules', 'POST', '/', 'json', false, 'json', request);
}

model ListModulesByPageRequest {
  customParentId?: string(name='CustomParentId', position='Query'),
  description?: string(name='Description', position='Query'),
  hasOwnerApp?: boolean(name='HasOwnerApp', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  moduleName?: string(name='ModuleName', position='Query'),
  moduleType?: string(name='ModuleType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  platform?: string(name='Platform', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListModulesByPageResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        moduleType?: string(name='ModuleType'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListModulesByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListModulesByPageResponseBody(name='body'),
}

async function listModulesByPage(request: ListModulesByPageRequest): ListModulesByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListModulesByPage', 'POST', '/', 'json', false, 'json', request);
}

model ListPublishVersionsRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListPublishVersionsResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitId?: string(name='CommitId'),
        completionTime?: string(name='CompletionTime'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        envId?: string(name='EnvId'),
        modifiedTime?: string(name='ModifiedTime'),
        publishId?: string(name='PublishId'),
        publishStatus?: string(name='PublishStatus'),
        publishType?: string(name='PublishType'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        subTasks?: [ map[string]string ](name='SubTasks'),
        versionNumber?: string(name='VersionNumber'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishVersionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishVersionsResponseBody(name='body'),
}

async function listPublishVersions(request: ListPublishVersionsRequest): ListPublishVersionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublishVersions', 'POST', '/', 'json', false, 'json', request);
}

model ListPublishedModulesRequest {
  description?: string(name='Description', position='Query'),
  excludeAppId?: string(name='ExcludeAppId', position='Query'),
  excludeModuleId?: string(name='ExcludeModuleId', position='Query'),
  hasOwnerApp?: boolean(name='HasOwnerApp', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  moduleName?: string(name='ModuleName', position='Query'),
  moduleType?: string(name='ModuleType', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  platform?: string(name='Platform', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListPublishedModulesResponseBody = {
  data?: {
    items?: [ 
      {
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        icon?: string(name='Icon'),
        latestPublishedCommit?: string(name='LatestPublishedCommit'),
        latestPublishedVersion?: string(name='LatestPublishedVersion'),
        minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        moduleName?: string(name='ModuleName'),
        moduleType?: string(name='ModuleType'),
        ownerAppId?: string(name='OwnerAppId'),
        ownerUserId?: string(name='OwnerUserId'),
        platform?: string(name='Platform'),
        platformVersion?: string(name='PlatformVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishedModulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishedModulesResponseBody(name='body'),
}

async function listPublishedModules(request: ListPublishedModulesRequest): ListPublishedModulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublishedModules', 'POST', '/', 'json', false, 'json', request);
}

model ListPublishesRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  publishStatus?: string(name='PublishStatus', position='Query'),
  publishType?: string(name='PublishType', position='Query'),
  source?: string(name='Source', position='Query'),
}

model ListPublishesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        commitId?: string(name='CommitId'),
        completionTime?: string(name='CompletionTime'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        envId?: string(name='EnvId'),
        modifiedTime?: string(name='ModifiedTime'),
        publishId?: string(name='PublishId'),
        publishStatus?: string(name='PublishStatus'),
        publishType?: string(name='PublishType'),
        reason?: string(name='Reason'),
        startTime?: string(name='StartTime'),
        versionNumber?: string(name='VersionNumber'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListPublishesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPublishesResponseBody(name='body'),
}

async function listPublishes(request: ListPublishesRequest): ListPublishesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPublishes', 'POST', '/', 'json', false, 'json', request);
}

model ListResourcesRequest {
  appId?: string(name='AppId', position='Query'),
  description?: string(name='Description', position='Query'),
  imageProcessParameter?: string(name='ImageProcessParameter', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceName?: string(name='ResourceName', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  source?: string(name='Source', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListResourcesResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: any(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDigest?: string(name='ResourceDigest'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesResponseBody(name='body'),
}

async function listResources(request: ListResourcesRequest): ListResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResources', 'POST', '/', 'json', false, 'json', request);
}

model ListResourcesByPageRequest {
  appId?: string(name='AppId', position='Query'),
  description?: string(name='Description', position='Query'),
  imageProcessParameter?: string(name='ImageProcessParameter', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=1000, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=1000, position='Query'),
  resourceId?: string(name='ResourceId', position='Query'),
  resourceName?: string(name='ResourceName', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  source?: string(name='Source', position='Query'),
  withContent?: boolean(name='WithContent', position='Query'),
}

model ListResourcesByPageResponseBody = {
  data?: {
    items?: [ 
      {
        appId?: string(name='AppId'),
        content?: map[string]string(name='Content'),
        createTime?: string(name='CreateTime'),
        description?: string(name='Description'),
        modifiedTime?: string(name='ModifiedTime'),
        moduleId?: string(name='ModuleId'),
        resourceDigest?: string(name='ResourceDigest'),
        resourceId?: string(name='ResourceId'),
        resourceName?: string(name='ResourceName'),
        resourceType?: string(name='ResourceType'),
        revision?: int32(name='Revision'),
        schemaVersion?: string(name='SchemaVersion'),
      }
    ](name='Items'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ListResourcesByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListResourcesByPageResponseBody(name='body'),
}

async function listResourcesByPage(request: ListResourcesByPageRequest): ListResourcesByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListResourcesByPage', 'POST', '/', 'json', false, 'json', request);
}

model ResetAppUserPasswordRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
  userName: string(name='UserName', position='Query'),
}

model ResetAppUserPasswordResponseBody = {
  data?: {
    password?: string(name='Password'),
    userName?: string(name='UserName'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model ResetAppUserPasswordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResetAppUserPasswordResponseBody(name='body'),
}

async function resetAppUserPassword(request: ResetAppUserPasswordRequest): ResetAppUserPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAppUserPassword', 'POST', '/', 'json', false, 'json', request);
}

model RestoreModelRequest {
  appId?: string(name='AppId', position='Query'),
  modelId: string(name='ModelId', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model RestoreModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RestoreModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestoreModelResponseBody(name='body'),
}

async function restoreModel(request: RestoreModelRequest): RestoreModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreModel', 'POST', '/', 'json', false, 'json', request);
}

model RunLogicModelRequest {
  appId?: string(name='AppId', position='Query'),
  commitId?: string(name='CommitId', position='Query'),
  content: string(name='Content', position='Query'),
  encodeType?: string(name='EncodeType', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType: string(name='SubType', position='Query'),
}

model RunLogicModelResponseBody = {
  data?: {
    body?: string(name='Body'),
    headers?: map[string]string(name='Headers'),
    status?: int32(name='Status'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model RunLogicModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RunLogicModelResponseBody(name='body'),
}

async function runLogicModel(request: RunLogicModelRequest): RunLogicModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RunLogicModel', 'POST', '/', 'json', false, 'json', request);
}

model SetEnvironmentDefaultDomainRequest {
  appId: string(name='AppId', position='Query'),
  domain: string(name='Domain', position='Query'),
  domainType: string(name='DomainType', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model SetEnvironmentDefaultDomainResponseBody = {
  data?: {
    configChanged?: boolean(name='ConfigChanged'),
    defaultMasterDomain?: string(name='DefaultMasterDomain'),
    defaultStaticDomain?: string(name='DefaultStaticDomain'),
    masterDomain?: string(name='MasterDomain'),
    masterDomainApplied?: boolean(name='MasterDomainApplied'),
    staticDomain?: string(name='StaticDomain'),
    staticDomainApplied?: boolean(name='StaticDomainApplied'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model SetEnvironmentDefaultDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetEnvironmentDefaultDomainResponseBody(name='body'),
}

async function setEnvironmentDefaultDomain(request: SetEnvironmentDefaultDomainRequest): SetEnvironmentDefaultDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetEnvironmentDefaultDomain', 'POST', '/', 'json', false, 'json', request);
}

model StartAppServerRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model StartAppServerResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appServerStatus?: string(name='AppServerStatus'),
    envId?: string(name='EnvId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model StartAppServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartAppServerResponseBody(name='body'),
}

async function startAppServer(request: StartAppServerRequest): StartAppServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartAppServer', 'POST', '/', 'json', false, 'json', request);
}

model StopAppServerRequest {
  appId: string(name='AppId', position='Query'),
  envId: string(name='EnvId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model StopAppServerResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appServerStatus?: string(name='AppServerStatus'),
    envId?: string(name='EnvId'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model StopAppServerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopAppServerResponseBody(name='body'),
}

async function stopAppServer(request: StopAppServerRequest): StopAppServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopAppServer', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppRequest {
  appId: string(name='AppId', position='Query'),
  appName?: string(name='AppName', position='Query'),
  description?: string(name='Description', position='Query'),
  icon?: string(name='Icon', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateAppResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    appName?: string(name='AppName'),
    appStatus?: string(name='AppStatus'),
    appType?: string(name='AppType'),
    categories?: [ 
      {
        categoryId?: string(name='CategoryId'),
        categoryName?: string(name='CategoryName'),
        parentCategoryId?: string(name='ParentCategoryId'),
      }
    ](name='Categories'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    isTemplate?: boolean(name='IsTemplate'),
    lastEditTime?: string(name='LastEditTime'),
    mainModuleId?: string(name='MainModuleId'),
    modifiedTime?: string(name='ModifiedTime'),
    schemaVersion?: string(name='SchemaVersion'),
    source?: string(name='Source'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppResponseBody(name='body'),
}

async function updateApp(request: UpdateAppRequest): UpdateAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateApp', 'POST', '/', 'json', false, 'json', request);
}

model UpdateAppModelRequest {
  appId: string(name='AppId', position='Query'),
  content: string(name='Content', position='Query'),
  encodeType?: string(name='EncodeType', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
  subType?: string(name='SubType', position='Query'),
}

model UpdateAppModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateAppModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppModelResponseBody(name='body'),
}

async function updateAppModel(request: UpdateAppModelRequest): UpdateAppModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppModel', 'POST', '/', 'json', false, 'json', request);
}

model UpdateModelRequest {
  appId?: string(name='AppId', position='Query'),
  content?: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  encodeType?: string(name='EncodeType', position='Query'),
  modelId: string(name='ModelId', position='Query'),
  modelName?: string(name='ModelName', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  schemaVersion?: string(name='SchemaVersion', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateModelResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    attributes?: [ map[string]string ](name='Attributes'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    id?: string(name='Id'),
    linkModelId?: string(name='LinkModelId'),
    linkModuleId?: string(name='LinkModuleId'),
    linked?: boolean(name='Linked'),
    modelDigest?: string(name='ModelDigest'),
    modelId?: string(name='ModelId'),
    modelName?: string(name='ModelName'),
    modelStatus?: string(name='ModelStatus'),
    modelType?: string(name='ModelType'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    props?: map[string]string(name='Props'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
    subType?: string(name='SubType'),
    visibility?: string(name='Visibility'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateModelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModelResponseBody(name='body'),
}

async function updateModel(request: UpdateModelRequest): UpdateModelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateModel', 'POST', '/', 'json', false, 'json', request);
}

model UpdateModuleRequest {
  description?: string(name='Description', position='Query'),
  moduleId: string(name='ModuleId', position='Query'),
  moduleName?: string(name='ModuleName', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateModuleResponseBody = {
  data?: {
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    icon?: string(name='Icon'),
    latestPublishedCommit?: string(name='LatestPublishedCommit'),
    latestPublishedVersion?: string(name='LatestPublishedVersion'),
    minimumPlatformVersion?: string(name='MinimumPlatformVersion'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    moduleName?: string(name='ModuleName'),
    ownerAppId?: string(name='OwnerAppId'),
    ownerUserId?: string(name='OwnerUserId'),
    platform?: string(name='Platform'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateModuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateModuleResponseBody(name='body'),
}

async function updateModule(request: UpdateModuleRequest): UpdateModuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateModule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateResourceRequest {
  appId?: string(name='AppId', position='Query'),
  content?: string(name='Content', position='Query'),
  description?: string(name='Description', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceName?: string(name='ResourceName', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateResourceResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceDigest?: string(name='ResourceDigest'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceResponseBody(name='body'),
}

async function updateResource(request: UpdateResourceRequest): UpdateResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateResource', 'POST', '/', 'json', false, 'json', request);
}

model UpdateResourceContentRequest {
  appId?: string(name='AppId', position='Query'),
  content: string(name='Content', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateResourceContentResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceContentResponseBody(name='body'),
}

async function updateResourceContent(request: UpdateResourceContentRequest): UpdateResourceContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateResourceContent', 'POST', '/', 'json', false, 'json', request);
}

model UpdateResourceInfoRequest {
  appId?: string(name='AppId', position='Query'),
  description?: string(name='Description', position='Query'),
  moduleId?: string(name='ModuleId', position='Query'),
  resourceId: string(name='ResourceId', position='Query'),
  resourceName?: string(name='ResourceName', position='Query'),
  source?: string(name='Source', position='Query'),
}

model UpdateResourceInfoResponseBody = {
  data?: {
    appId?: string(name='AppId'),
    content?: map[string]string(name='Content'),
    createTime?: string(name='CreateTime'),
    description?: string(name='Description'),
    modifiedTime?: string(name='ModifiedTime'),
    moduleId?: string(name='ModuleId'),
    resourceId?: string(name='ResourceId'),
    resourceName?: string(name='ResourceName'),
    resourceType?: string(name='ResourceType'),
    revision?: int32(name='Revision'),
    schemaVersion?: string(name='SchemaVersion'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model UpdateResourceInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateResourceInfoResponseBody(name='body'),
}

async function updateResourceInfo(request: UpdateResourceInfoRequest): UpdateResourceInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateResourceInfo', 'POST', '/', 'json', false, 'json', request);
}

model DataItemsModelDataValue = {
  id?: string(name='Id'),
  modelId?: string(name='ModelId'),
  modelName?: string(name='ModelName'),
  modelStatus?: string(name='ModelStatus'),
  modelType?: string(name='ModelType'),
  subType?: string(name='SubType'),
  moduleId?: string(name='ModuleId'),
  content?: string(name='Content'),
  appId?: string(name='AppId'),
  linked?: boolean(name='Linked'),
  linkModuleId?: string(name='LinkModuleId'),
  linkModelId?: string(name='LinkModelId'),
  schemaVersion?: string(name='SchemaVersion'),
  description?: string(name='Description'),
  props?: string(name='Props'),
  visibility?: string(name='Visibility'),
  modelDigest?: string(name='ModelDigest'),
}

model DataItemsResourceDataValue = {
  resourceId?: string(name='ResourceId'),
  resourceName?: string(name='ResourceName'),
  resourceType?: string(name='ResourceType'),
  description?: string(name='Description'),
  schemaVersion?: string(name='SchemaVersion'),
  moduleId?: string(name='ModuleId'),
  content?: map[string]any(name='Content'),
  appId?: string(name='AppId'),
  visibility?: string(name='Visibility'),
}

