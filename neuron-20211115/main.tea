/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'neuron.aliyuncs.com',
    ap-northeast-2-pop = 'neuron.aliyuncs.com',
    ap-south-1 = 'neuron.aliyuncs.com',
    ap-southeast-1 = 'neuron.aliyuncs.com',
    ap-southeast-2 = 'neuron.aliyuncs.com',
    ap-southeast-3 = 'neuron.aliyuncs.com',
    ap-southeast-5 = 'neuron.aliyuncs.com',
    cn-beijing = 'neuron.aliyuncs.com',
    cn-beijing-finance-1 = 'neuron.aliyuncs.com',
    cn-beijing-finance-pop = 'neuron.aliyuncs.com',
    cn-beijing-gov-1 = 'neuron.aliyuncs.com',
    cn-beijing-nu16-b01 = 'neuron.aliyuncs.com',
    cn-chengdu = 'neuron.aliyuncs.com',
    cn-edge-1 = 'neuron.aliyuncs.com',
    cn-fujian = 'neuron.aliyuncs.com',
    cn-haidian-cm12-c01 = 'neuron.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'neuron.aliyuncs.com',
    cn-hangzhou-finance = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'neuron.aliyuncs.com',
    cn-hangzhou-test-306 = 'neuron.aliyuncs.com',
    cn-hongkong = 'neuron.aliyuncs.com',
    cn-hongkong-finance-pop = 'neuron.aliyuncs.com',
    cn-huhehaote = 'neuron.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'neuron.aliyuncs.com',
    cn-north-2-gov-1 = 'neuron.aliyuncs.com',
    cn-qingdao = 'neuron.aliyuncs.com',
    cn-qingdao-nebula = 'neuron.aliyuncs.com',
    cn-shanghai = 'neuron.aliyuncs.com',
    cn-shanghai-et15-b01 = 'neuron.aliyuncs.com',
    cn-shanghai-et2-b01 = 'neuron.aliyuncs.com',
    cn-shanghai-finance-1 = 'neuron.aliyuncs.com',
    cn-shanghai-inner = 'neuron.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'neuron.aliyuncs.com',
    cn-shenzhen = 'neuron.aliyuncs.com',
    cn-shenzhen-finance-1 = 'neuron.aliyuncs.com',
    cn-shenzhen-inner = 'neuron.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'neuron.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'neuron.aliyuncs.com',
    cn-wuhan = 'neuron.aliyuncs.com',
    cn-wulanchabu = 'neuron.aliyuncs.com',
    cn-yushanfang = 'neuron.aliyuncs.com',
    cn-zhangbei = 'neuron.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'neuron.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'neuron.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'neuron.aliyuncs.com',
    eu-central-1 = 'neuron.aliyuncs.com',
    eu-west-1 = 'neuron.aliyuncs.com',
    eu-west-1-oxs = 'neuron.aliyuncs.com',
    me-east-1 = 'neuron.aliyuncs.com',
    rus-west-1-pop = 'neuron.aliyuncs.com',
    us-east-1 = 'neuron.aliyuncs.com',
    us-west-1 = 'neuron.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('neuron', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AbbrevMonitorAlert {
  abbrevMonitorAlertRules?: [
    AbbrevMonitorAlertRule
  ](name='abbrevMonitorAlertRules'),
  condition?: string(name='condition', example='OR'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-08-24T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-08-24T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
  name?: string(name='name', example='报警任务1'),
  pbcId?: string(name='pbcId', example='1001'),
  remark?: string(name='remark', example='测试任务'),
  serviceId?: string(name='serviceId', example='1001'),
  type?: string(name='type', example='ARMS'),
}

model AbbrevMonitorAlertRule {
  createTime?: string(name='createTime', example='2022-06-11T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='规则1'),
  triggerContent?: string(name='triggerContent', example='最近5分钟节点机CPU使用率平均大于等于90%'),
  triggerRule?: string(name='triggerRule', example='10'),
}

model AuthorizationResource {
  authorizerId?: string(name='authorizerId', example='1'),
  authorizerType?: string(name='authorizerType', example='developer'),
}

model BatchGrantRolesCmd {
  accountId?: string(name='accountId', example='1'),
  roleIds?: [ long ](name='roleIds'),
}

model BucEnterprise {
  accountId?: string(name='accountId'),
  codeupEnterpriseId?: string(name='codeupEnterpriseId'),
  codeupNamespaceId?: long(name='codeupNamespaceId'),
  description?: string(name='description'),
  id?: long(name='id'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model BucUser {
  account?: string(name='account'),
  empId?: string(name='empId'),
  empType?: string(name='empType'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  nickName?: string(name='nickName'),
  personalPhotoUrl?: string(name='personalPhotoUrl'),
  requestId?: string(name='requestId'),
}

model BucUserEnterpriseListResult {
  data?: [
    BucEnterprise
  ](name='data'),
  requestId?: string(name='requestId'),
}

model CatalogCommonResult {
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
}

model CatalogOperatorRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  marketId?: long(name='marketId', example='1'),
  marketType?: string(name='marketType', example='inner'),
}

model CatalogPbcRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  marketId?: long(name='marketId', example='1'),
  marketResource?: string(name='marketResource', example='neuron:catalog:market'),
  name?: string(name='name'),
  pbcResource?: string(name='pbcResource', example='neuron:catalog:company'),
}

model CommonResult {
  requestId?: string(name='requestId'),
  success?: boolean(name='success'),
}

model CompanyRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  name?: string(name='name', example='多端商城'),
}

model CreateAssetWatchCmd {
  assetId?: long(name='assetId'),
  assetType?: string(name='assetType'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
}

model CreatePbcInvokeReviewResult {
  pbcInvokeReviewId?: long(name='pbcInvokeReviewId'),
  requestId?: string(name='requestId'),
}

model CreatePrivilegeCmd {
  accountId?: string(name='accountId'),
  roleId?: long(name='roleId'),
  strategyItems?: [
    StrategyItem
  ](name='strategyItems'),
  strategys?: string(name='strategys'),
}

model CreatePrivilegePopCmd {
  accountId?: string(name='accountId'),
  actions?: string(name='actions'),
  resource?: string(name='resource'),
  roleId?: long(name='roleId'),
}

model CreateTokenResult {
  requestId?: string(name='requestId'),
  token?: string(name='token'),
}

model DTO {
  id?: long(name='id'),
  requestId?: string(name='requestId'),
}

model DeployConfigInfo {
  cpu?: int32(name='cpu', example='2'),
  deploymentId?: long(name='deploymentId', example='1'),
  deploymentType?: string(name='deploymentType', example='AUTO'),
  env?: string(name='env', example='TEST'),
  finish?: boolean(name='finish', example='true'),
  instanceCount?: int32(name='instanceCount', example='3'),
  memory?: int32(name='memory', example='4'),
  pipelineId?: string(name='pipelineId', example='1234'),
  serviceId?: long(name='serviceId', example='1'),
  timeout?: int32(name='timeout', example='123'),
  times?: int32(name='times', example='1'),
}

model DeployDetailInfo {
  accountId?: string(name='accountId', example='121321412341'),
  accountName?: string(name='accountName', example='account1'),
  changeOrderId?: string(name='changeOrderId', example='cd65b247-****-475b-ad4b-7039040d625c'),
  context?: string(name='context'),
  cpu?: int32(name='cpu', example='2'),
  deploymentType?: string(name='deploymentType', example='AUTO'),
  description?: string(name='description', example='部署员工管理'),
  edasId?: string(name='edasId', example='sdad'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-2-22 11:11:2'),
  gmtModified?: string(name='gmtModified', example='2022-2-22 11:11:2'),
  id?: long(name='id', example='1'),
  imageId?: string(name='imageId', example='i-v12wpq'),
  imageTag?: string(name='imageTag', example='20220421100717_prepub'),
  instanceCount?: int32(name='instanceCount', example='3'),
  memory?: int32(name='memory', example='4'),
  message?: string(name='message'),
  orgType?: string(name='orgType', example='INNER'),
  pbcId?: long(name='pbcId', example='1'),
  pbcName?: string(name='pbcName', example='management'),
  pipelineId?: string(name='pipelineId', example='123141'),
  pipelineInfos?: [
    DeployPipelineInfo
  ](name='pipelineInfos'),
  pipelineRunId?: string(name='pipelineRunId', example='23131'),
  repositoryId?: string(name='repositoryId', example='cri-v1d49e57e8ojcwpq'),
  rollbackStatus?: string(name='rollbackStatus', example='DEPLOYMENT_PENDING'),
  serviceId?: long(name='serviceId', example='1'),
  serviceName?: string(name='serviceName', example='employee'),
  status?: string(name='status', example='DEPLOYMENT_PENDING'),
  times?: int32(name='times', example='2'),
  type?: string(name='type', example='SERVICE'),
}

model DeployInstanceInfo {
  ip?: string(name='ip', example='192.1.1.1'),
  status?: string(name='status', example='EXECUTING'),
}

model DeployPipelineInfo {
  deployInstanceInfos?: [
    DeployInstanceInfo
  ](name='deployInstanceInfos'),
  id?: string(name='id', example='528f9a66-cbe3-4cd8-91c0-bc4260a13d87'),
  name?: string(name='name', example='Batch 1 Change'),
}

model DeploymentContinueCmd {
  deploymentId?: long(name='deploymentId', example='1'),
}

model DeploymentRevertCmd {
  accountId?: string(name='accountId', example='121321412341'),
  cpu?: int32(name='cpu', example='2'),
  deploymentId?: long(name='deploymentId', example='1'),
  description?: string(name='description', example='员工管理'),
  instanceCount?: int32(name='instanceCount', example='3'),
  memory?: int32(name='memory', example='4'),
  timeout?: int32(name='timeout', example='300'),
  times?: int32(name='times', example='2'),
  type?: string(name='type', example='AUTO'),
}

model DeploymentRollbackCmd {
  deploymentId?: long(name='deploymentId', example='1'),
}

model DeploymentTriggerCmd {
  accountId?: string(name='accountId', example='121321412341'),
  cpu?: int32(name='cpu', example='2'),
  description?: string(name='description', example='员工管理'),
  env?: string(name='env', example='TEST'),
  imageTag?: string(name='imageTag', example='v0.1'),
  instanceCount?: int32(name='instanceCount', example='3'),
  memory?: int32(name='memory', example='4'),
  serviceId?: long(name='serviceId', example='1'),
  timeout?: int32(name='timeout', example='123'),
  times?: int32(name='times', example='2'),
  type?: string(name='type', example='AUTO'),
}

model Developer {
  accountId?: string(name='accountId', example='121321412341'),
  codeupAccountId?: string(name='codeupAccountId', example='121321412341'),
  email?: string(name='email', example='xxx@alibaba.com'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  name?: string(name='name', example='尚仁'),
  phone?: string(name='phone', example='15113456789'),
  requestId?: string(name='requestId'),
}

model DeveloperInfoUpdateCmd {
  accountId?: string(name='accountId', example='121321412341'),
  email?: string(name='email', example='xxx@alibaba.com'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  name?: string(name='name', example='尚仁'),
  phone?: string(name='phone', example='15113456789'),
}

model DeveloperPageResult {
  data?: [
    Developer
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model Enterprise {
  accountId?: string(name='accountId', example='121321412341'),
  description?: string(name='description', example='互联网企业'),
  id?: long(name='id'),
  name?: string(name='name', example='阿里'),
  requestId?: string(name='requestId'),
  type?: string(name='type', example='内部'),
}

model EnterpriseInfoUpdateCmd {
  description?: string(name='description', example='互联网企业'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='阿里'),
}

model EnterprisePageResult {
  data?: [
    Enterprise
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model EnterpriseTransferCmd {
  accountId?: string(name='accountId', example='121321412341'),
  id?: long(name='id', example='1'),
}

model EnvInfoDO {
  env?: string(name='env', example='TEST'),
  envType?: string(name='envType', example='TEST'),
  orgType?: string(name='orgType', example='INNER'),
  productId?: long(name='productId', example='231'),
  productName?: string(name='productName', example='yunmall'),
  region?: string(name='region', example='cn-zhangjiakou'),
}

model FeedbackReviewCmd {
  feedbackPbcAPI?: string(name='feedbackPbcAPI', example='符合规范'),
  feedbackPbcInstruction?: string(name='feedbackPbcInstruction', example='符合规范'),
  feedbackPbcSchema?: string(name='feedbackPbcSchema', example='符合规范'),
  feedbackSecurity?: string(name='feedbackSecurity', example='服务安全'),
  feedbackServiceAvailable?: string(name='feedbackServiceAvailable', example='服务可运行'),
  reviewId?: long(name='reviewId', example='1'),
  status?: string(name='status', example='REVIEW_FAILED'),
}

model ForkReview {
  applicant?: string(name='applicant', example='旭坤'),
  forkId?: long(name='forkId', example='1'),
  gitGroup?: string(name='gitGroup', example='global-mall'),
  id?: long(name='id', example='1'),
  pbcName?: string(name='pbcName', example='product'),
  repoUrls?: [ string ](name='repoUrls'),
  requestId?: string(name='requestId'),
  reviewer?: string(name='reviewer', example='中驿'),
  reviewerId?: string(name='reviewerId', example='194835334'),
  status?: string(name='status', example='待审核'),
  usage?: string(name='usage', example='商城国际化版本'),
}

model ForkReviewAuditCmd {
  approve?: boolean(name='approve', example='true'),
}

model ForkReviewCreateCmd {
  companyId?: long(name='companyId'),
  gitGroup?: string(name='gitGroup', example='global-mall'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId', example='1'),
  usage?: string(name='usage', example='商城国际版本'),
}

model ForkReviewCreateResult {
  id?: long(name='id'),
  requestId?: string(name='requestId'),
}

model ForkReviewListResult {
  forkReviews?: [
    ForkReview
  ](name='forkReviews'),
  requestId?: string(name='requestId'),
  total?: int32(name='total', example='24'),
}

model GrantedRoleListQuery {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  name?: string(name='name'),
}

model Library {
  artifactId?: string(name='artifactId'),
  assetType?: string(name='assetType'),
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  dependCount?: int32(name='dependCount'),
  description?: string(name='description'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  industry?: string(name='industry'),
  isWatched?: boolean(name='isWatched'),
  name?: string(name='name'),
  provider?: string(name='provider'),
  providerName?: string(name='providerName'),
  repoUrl?: string(name='repoUrl'),
  requestId?: string(name='requestId'),
  reviewId?: long(name='reviewId'),
  status?: string(name='status'),
  stepStatus?: string(name='stepStatus'),
  watchCount?: int32(name='watchCount'),
}

model LibraryCreateCmd {
  artifactId?: string(name='artifactId'),
  companyId?: long(name='companyId'),
  description?: string(name='description'),
  groupId?: string(name='groupId'),
  marketId?: long(name='marketId'),
  name?: string(name='name'),
  repoUrl?: string(name='repoUrl'),
}

model LibraryDeveloperRepoMetricResult {
  developerRepoMetrics?: [
    ReposDeveloperGroupMetric
  ](name='developerRepoMetrics'),
}

model LibraryInstruction {
  companyId?: long(name='companyId'),
  document?: string(name='document'),
  id?: long(name='id'),
  libraryId?: string(name='libraryId'),
  marketId?: long(name='marketId'),
  requestId?: string(name='requestId'),
}

model LibraryListResult {
  librarys?: [
    Library
  ](name='librarys'),
  requestId?: string(name='requestId'),
}

model LibraryRepoMetricResult {
  repoMetrics?: [
    RepoMetric
  ](name='repoMetrics'),
  requestId?: string(name='requestId'),
}

model LibraryReview {
  applicant?: string(name='applicant'),
  artificatId?: string(name='artificatId'),
  developerName?: string(name='developerName'),
  feedbackLibraryInstruction?: string(name='feedbackLibraryInstruction'),
  feedbackLibrarySchema?: string(name='feedbackLibrarySchema'),
  gmtCreate?: string(name='gmtCreate'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  libraryName?: string(name='libraryName'),
  libraryUrl?: string(name='libraryUrl'),
  marketId?: string(name='marketId'),
  marketName?: string(name='marketName'),
  remainTime?: string(name='remainTime'),
  requestId?: string(name='requestId'),
  reviewerId?: string(name='reviewerId'),
  status?: string(name='status'),
}

model LibraryReviewCreateCmd {
  libraryId?: long(name='libraryId'),
  libraryUrl?: string(name='libraryUrl'),
  marketId?: long(name='marketId'),
  reviewerId?: string(name='reviewerId'),
}

model LibraryReviewListResult {
  libraryReviews?: [
    LibraryReview
  ](name='libraryReviews'),
  requestId?: string(name='requestId'),
}

model LibraryReviewsListQuery {
  applicant?: string(name='applicant'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  reviewer?: string(name='reviewer'),
}

model LibrarySchema {
  artifactId?: string(name='artifactId'),
  companyId?: long(name='companyId'),
  description?: string(name='description'),
  gitGroup?: string(name='gitGroup'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  industry?: string(name='industry'),
  libraryId?: long(name='libraryId'),
  marketId?: long(name='marketId'),
  name?: string(name='name'),
  provider?: Provider(name='provider'),
  requestId?: string(name='requestId'),
}

model LibrarySchemaUpdateCmd {
  artifactId?: string(name='artifactId'),
  description?: string(name='description'),
  gitGroup?: string(name='gitGroup'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  libraryId?: long(name='libraryId'),
}

model LibraryUpdateCmd {
  artifactId?: string(name='artifactId'),
  description?: string(name='description'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  name?: string(name='name'),
  repoUrl?: string(name='repoUrl'),
}

model Market {
  id?: long(name='id'),
  name?: string(name='name', example='内部市场'),
  type?: string(name='type'),
}

model MarketInfo {
  id?: long(name='id'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model MarketListResult {
  markets?: [
    MarketInfo
  ](name='markets'),
}

model MetadataInfo {
  enterpriseId?: long(name='enterpriseId', example='1'),
  env?: string(name='env', example='test'),
  id?: long(name='id', example='1'),
  instanceId?: long(name='instanceId', example='1'),
  namespaceId?: long(name='namespaceId', example='1'),
  namespaceName?: string(name='namespaceName', example='product'),
  orgId?: int32(name='orgId', example='1'),
}

model MetadataInfoListResult {
  metadataInfos?: [
    MetadataInfo
  ](name='metadataInfos'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MetricData {
  data?: string(name='data', example='1'),
  measures?: string(name='measures', example='youngGcCount'),
  metric?: string(name='metric', example='appstat.vm'),
  time?: long(name='time', example='1654777095632'),
  type?: string(name='type', example='rootIp'),
  typeValue?: string(name='typeValue', example='192.168.1.1'),
}

model MicroServiceDigest {
  mqGroups?: MqGroup(name='MqGroups'),
  serviceId?: long(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
}

model MicroServicePageResult {
  microServiceDigests?: [
    MicroServiceDigest
  ](name='MicroServiceDigests'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorAlertHistory {
  endTime?: string(name='endTime', example='2022-10-13 13:58:42'),
  eventState?: string(name='eventState', example='已解决'),
  id?: long(name='id', example='1'),
  name?: string(name='name'),
  ruleDesc?: string(name='ruleDesc'),
  ruleName?: string(name='ruleName'),
  startTime?: string(name='startTime', example='2022-10-13 12:18:00'),
  type?: string(name='type', example='日志'),
  uuid?: string(name='uuid'),
}

model MonitorAlertHistoryPageResult {
  alertHistories?: [
    MonitorAlertHistory
  ](name='alertHistories'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorAlertRuleNamesResult {
  ruleNames?: [ string ](name='ruleNames'),
}

model MonitorArmsAlert {
  condition?: string(name='condition', example='OR'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-08-24T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-08-24T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  monitorArmsAlertRules?: [
    MonitorArmsAlertRule
  ](name='monitorArmsAlertRules'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
  name?: string(name='name', example='报警任务1'),
  pbcId?: string(name='pbcId', example='1001'),
  remark?: string(name='remark', example='测试任务'),
  serviceId?: string(name='serviceId', example='1001'),
  type?: string(name='type', example='ARMS'),
}

model MonitorArmsAlertRule {
  id?: long(name='id', example='1'),
  metricKey?: string(name='metricKey', example='appstat.jvm.gc.oldgccountinstant'),
  metricType?: string(name='metricType', example='JVM'),
  name?: string(name='name', example='规则1'),
  triggerAggregate?: string(name='triggerAggregate', example='AVG'),
  triggerInterval?: long(name='triggerInterval', example='5'),
  triggerOperator?: string(name='triggerOperator', example='CURRENT_GTE'),
  triggerThreshold?: long(name='triggerThreshold', example='10'),
}

model MonitorArmsAlertUpdateCmd {
  condition?: string(name='condition', example='OR'),
  id?: long(name='id', example='1'),
  monitorArmsAlertRules?: [
    MonitorArmsAlertRule
  ](name='monitorArmsAlertRules'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
}

model MonitorArmsAlerts {
  monitorArmsAlerts?: [
    MonitorArmsAlert
  ](name='monitorArmsAlerts'),
}

model MonitorContact {
  email?: string(name='email', example='al2i@sina.com'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  gmtCreate?: string(name='gmtCreate', example='2022-05-01T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-05-01T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  isVerify?: int32(name='isVerify', example='0'),
  name?: string(name='name', example='yani'),
  phone?: string(name='phone', example='15117923456'),
}

model MonitorContactGroup {
  accountId?: string(name='accountId', example='121321412341'),
  contacts?: [
    MonitorContact
  ](name='contacts'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  gmtCreate?: string(name='gmtCreate', example='2022-05-01T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-05-01T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='yani'),
}

model MonitorContactGroupCreateCmd {
  accountId?: string(name='accountId', example='121321412341'),
  contactIds?: [ long ](name='contactIds'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  name?: string(name='name', example='尚仁'),
}

model MonitorContactGroupPageResult {
  data?: [
    MonitorContactGroup
  ](name='data'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorContactGroupUpdateCmd {
  accountId?: string(name='accountId', example='121321412341'),
  contactIds?: [ long ](name='contactIds'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='尚仁'),
}

model MonitorContactPageResult {
  data?: [
    MonitorContact
  ](name='data'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorContactUpdateCmd {
  email?: string(name='email', example='xxx@alibaba.com'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='尚仁'),
  phone?: string(name='phone', example='15113456789'),
}

model MonitorGroupMemberCreateCmd {
  accountId?: string(name='accountId', example='121321412341'),
  contactIds?: [ long ](name='contactIds'),
}

model MonitorGroupMemberDeleteCmd {
  contactIds?: [ long ](name='contactIds'),
  groupId?: long(name='groupId', example='1'),
}

model MonitorMetricMeasureData {
  measure?: string(name='measure', example='youngGcCount'),
  measurePointData?: [
    MonitorMetricMeasurePointData
  ](name='measurePointData'),
}

model MonitorMetricMeasurePointData {
  measure?: string(name='measure', example='youngGcCount'),
  timeStamp?: string(name='timeStamp', example='08-22 17:25'),
  value?: string(name='value', example='1'),
  valueWithUnit?: string(name='valueWithUnit', example='1M'),
}

model MonitorMetricResult {
  measureData?: [
    MonitorMetricMeasureData
  ](name='measureData'),
  requestId?: string(name='requestId'),
}

model MonitorMqAlert {
  condition?: string(name='condition', example='OR'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-08-24T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-08-24T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  monitorMqAlertRules?: [
    MonitorMqAlertRule
  ](name='monitorMqAlertRules'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
  name?: string(name='name', example='报警任务1'),
  pbcId?: string(name='pbcId', example='1001'),
  remark?: string(name='remark', example='测试任务'),
  serviceId?: string(name='serviceId', example='1001'),
  type?: string(name='type', example='ARMS'),
}

model MonitorMqAlertRule {
  id?: long(name='id', example='1'),
  metricDimension?: string(name='metricDimension', example='PBC_Topic1'),
  metricKey?: string(name='metricKey', example='appstat.jvm.gc.oldgccountinstant'),
  metricType?: string(name='metricType', example='TOPIC'),
  name?: string(name='name', example='规则1'),
  triggerInterval?: long(name='triggerInterval', example='5'),
  triggerOperator?: string(name='triggerOperator', example='GreaterThanOrEqualToThreshold'),
  triggerThreshold?: long(name='triggerThreshold', example='10'),
}

model MonitorMqAlertUpdateCmd {
  condition?: string(name='condition', example='OR'),
  id?: long(name='id', example='1'),
  monitorMqAlertRules?: [
    MonitorMqAlertRule
  ](name='monitorMqAlertRules'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
}

model MonitorMqAlerts {
  monitorMqAlerts?: [
    MonitorMqAlert
  ](name='monitorMqAlerts'),
}

model MonitorNotifyAlert {
  contactGroups?: [
    MonitorContactGroup
  ](name='contactGroups'),
  contacts?: [
    MonitorContact
  ](name='contacts'),
  endTime?: string(name='endTime', example='1439'),
  id?: long(name='id', example='1'),
  name?: string(name='name'),
  notifyChannels?: [ string ](name='notifyChannels'),
  ruleNames?: [ string ](name='ruleNames'),
  startTime?: string(name='startTime', example='00:00'),
  type?: string(name='type', example='日志'),
  webhooks?: [
    MonitorWebhook
  ](name='webhooks'),
}

model MonitorNotifyAlertPageResult {
  intTotal?: int32(name='intTotal'),
  notifyAlerts?: [
    MonitorNotifyAlert
  ](name='notifyAlerts'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorNotifyObjectResult {
  contactGroups?: [
    MonitorContactGroup
  ](name='contactGroups'),
  contacts?: [
    MonitorContact
  ](name='contacts'),
  requestId?: string(name='requestId'),
  webhooks?: [
    MonitorWebhook
  ](name='webhooks'),
}

model MonitorNotifyStrategy {
  channels?: [ string ](name='channels'),
  contactGroupIds?: [ long ](name='contactGroupIds'),
  contactGroups?: [
    MonitorContactGroup
  ](name='contactGroups'),
  contactIds?: [ long ](name='contactIds'),
  contacts?: [
    MonitorContact
  ](name='contacts'),
  endTime?: string(name='endTime', example='1439'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='告警策略1'),
  requestId?: string(name='requestId'),
  startTime?: string(name='startTime', example='00:00'),
  webhookIds?: [ long ](name='webhookIds'),
  webhooks?: [
    MonitorWebhook
  ](name='webhooks'),
}

model MonitorSlsAlert {
  condition?: string(name='condition', example='OR'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-08-24T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-08-24T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
  monitorSlsAlertRules?: [
    MonitorSlsAlertRule
  ](name='monitorSlsAlertRules'),
  name?: string(name='name', example='报警任务1'),
  pbcId?: string(name='pbcId', example='1001'),
  remark?: string(name='remark', example='测试任务'),
  serviceId?: string(name='serviceId', example='1001'),
  type?: string(name='type', example='ARMS'),
}

model MonitorSlsAlertRule {
  id?: long(name='id', example='1'),
  name?: string(name='name', example='规则1'),
  queryCondition?: string(name='queryCondition', example='* | select status, count(*) as total group by status'),
  triggerInterval?: long(name='triggerInterval', example='5'),
  triggerIntervalUnit?: string(name='triggerIntervalUnit', example='MINUTE'),
  triggerOperator?: string(name='triggerOperator', example='CURRENT_GTE'),
  triggerThreshold?: long(name='triggerThreshold', example='10'),
  triggerThresholdUpper?: long(name='triggerThresholdUpper', example='100'),
}

model MonitorSlsAlertUpdateCmd {
  condition?: string(name='condition', example='OR'),
  id?: long(name='id', example='1'),
  monitorNotifyStrategy?: MonitorNotifyStrategy(name='monitorNotifyStrategy'),
  monitorSlsAlertRules?: [
    MonitorSlsAlertRule
  ](name='monitorSlsAlertRules'),
}

model MonitorSlsAlerts {
  monitorSlsAlerts?: [
    MonitorSlsAlert
  ](name='monitorSlsAlerts'),
}

model MonitorWebhook {
  enterpriseId?: long(name='enterpriseId', example='1'),
  gmtCreate?: string(name='gmtCreate', example='2022-05-01T00:00:00.000Z'),
  gmtModified?: string(name='gmtModified', example='2022-05-01T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  method?: string(name='method', example='POST'),
  name?: string(name='name', example='钉钉机器人'),
  type?: string(name='type', example='DINGDING'),
  url?: string(name='url', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
}

model MonitorWebhookPageResult {
  data?: [
    MonitorWebhook
  ](name='data'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MonitorWebhookUpdateCmd {
  id?: long(name='id', example='1'),
  method?: string(name='method', example='POST'),
  name?: string(name='name', example='钉钉机器人'),
  type?: string(name='type', example='DINGDING'),
  url?: string(name='url', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
}

model MqGroup {
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  messageType?: int32(name='messageType'),
  protocolType?: string(name='protocolType'),
  remark?: string(name='remark'),
  requestId?: string(name='requestId'),
  serviceId?: string(name='serviceId'),
}

model MqMsgDigest {
  id?: long(name='Id'),
  retryCount?: long(name='RetryCount'),
  storeSize?: int32(name='StoreSize'),
  storeTime?: string(name='StoreTime'),
  tags?: string(name='Tags'),
}

model MqMsgPageResult {
  mqMsgDigests?: [
    MqMsgDigest
  ](name='MqMsgDigests'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MqTopic {
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  id?: long(name='id'),
  messageType?: string(name='messageType'),
  name?: string(name='name'),
  pbcId?: string(name='pbcId'),
  remark?: string(name='remark'),
  requestId?: string(name='requestId'),
}

model MqTopicDigest {
  alias?: string(name='Alias'),
  createTime?: string(name='CreateTime'),
  id?: long(name='Id'),
  messageType?: string(name='MessageType'),
  name?: string(name='Name'),
  remark?: string(name='Remark'),
}

model MqTopicPageResult {
  mqTopicDigests?: [
    MqTopicDigest
  ](name='MqTopicDigests'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model MqTopicSubsDigest {
  messageModel?: string(name='MessageModel'),
  serviceId?: string(name='ServiceId'),
  serviceName?: string(name='ServiceName'),
  subsExpression?: string(name='SubsExpression'),
}

model MqTopicSubsPageResult {
  mqTopicSubsDigests?: [
    MqTopicSubsDigest
  ](name='MqTopicSubsDigests'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model NeuronAppToken {
  token?: string(name='token', example='1343424sdadsa'),
}

model NeuronBizUserTokenCreateCmd {
  bizId?: string(name='bizId', example='233131'),
  permission?: string(name='permission', example='ADMIN'),
}

model NeuronMobiTokenCreateCmd {
  appId?: long(name='appId', example='233131'),
}

model Pbc {
  alias?: string(name='alias', example='基础商品'),
  assetType?: string(name='assetType'),
  company?: string(name='company', example='企业服务'),
  companyId?: long(name='companyId', example='12'),
  description?: string(name='description', example='基础商品PBC'),
  developerId?: string(name='developerId', example='1'),
  developerName?: string(name='developerName'),
  forkCount?: int32(name='forkCount', example='1'),
  id?: long(name='id', example='1'),
  industry?: string(name='industry', example='common'),
  invorkCount?: long(name='invorkCount'),
  isWatched?: boolean(name='isWatched'),
  latestVersionId?: long(name='latestVersionId'),
  marketId?: long(name='marketId'),
  name?: string(name='name', example='product'),
  requestId?: string(name='requestId'),
  type?: string(name='type', example='foundation'),
  watchCount?: long(name='watchCount'),
}

model PbcApiSchema {
  apiSchema?: string(name='apiSchema'),
  id?: long(name='id', example='1'),
  pbcVersionId?: long(name='pbcVersionId'),
  requestId?: string(name='requestId'),
}

model PbcApiSchemaCreateCmd {
  apiSchema?: string(name='apiSchema'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  pbcVersionId?: long(name='pbcVersionId'),
}

model PbcApiSchemaUpdateCmd {
  apiSchema?: string(name='apiSchema'),
  pbcVersionId?: long(name='pbcVersionId'),
}

model PbcCreateCmd {
  alias?: string(name='alias', example='基础商品'),
  company?: string(name='company', example='企业服务'),
  companyId?: long(name='companyId', example='12'),
  description?: string(name='description', example='基础商品PBC'),
  developerId?: string(name='developerId', example='1'),
  industry?: string(name='industry', example='common'),
  marketId?: long(name='marketId'),
  name?: string(name='name', example='product'),
  type?: string(name='type', example='foundation'),
}

model PbcDeveloperRepoMetricResult {
  developerRepoMetrics?: [
    ReposDeveloperGroupMetric
  ](name='developerRepoMetrics'),
  requestId?: string(name='requestId'),
}

model PbcInstruction {
  document?: string(name='document'),
  id?: long(name='id', example='1'),
  pbcVersionId?: long(name='pbcVersionId', example='2'),
  requestId?: string(name='requestId'),
}

model PbcInstructionCreateCmd {
  companyId?: long(name='companyId'),
  document?: string(name='document'),
  id?: long(name='id'),
  marketId?: long(name='marketId'),
  pbcVersionId?: long(name='pbcVersionId'),
}

model PbcInstructionUpdateCmd {
  document?: string(name='document'),
  pbcVersionId?: long(name='pbcVersionId'),
}

model PbcInvokeCreateCmd {
  applicant?: string(name='applicant'),
  companyId?: long(name='companyId'),
  invokePbcId?: long(name='invokePbcId'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId'),
  reviewer?: string(name='reviewer'),
  usage?: string(name='usage'),
  visible?: boolean(name='visible'),
}

model PbcInvokeReview {
  applicant?: string(name='applicant'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  invokeId?: long(name='invokeId'),
  invokePbcId?: long(name='invokePbcId'),
  invokePbcName?: string(name='invokePbcName'),
  pbcId?: long(name='pbcId'),
  pbcName?: string(name='pbcName'),
  requestId?: string(name='requestId'),
  reviewer?: string(name='reviewer'),
  reviewerId?: string(name='reviewerId'),
  status?: string(name='status'),
  usage?: string(name='usage'),
}

model PbcInvokeReviewCreateCmd {
  companyId?: long(name='companyId'),
  invokePbcId?: long(name='invokePbcId'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId'),
  usage?: string(name='usage'),
}

model PbcInvokeReviewListResult {
  pbcInvokeReviews?: [
    PbcInvokeReview
  ](name='pbcInvokeReviews'),
  requestId?: string(name='requestId'),
}

model PbcListResult {
  data?: [
    Pbc
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: int32(name='total', example='24'),
}

model PbcRelationItem {
  company?: string(name='company', example='企业服务'),
  developer?: string(name='developer', example='中驿'),
  pbcName?: string(name='pbcName', example='category'),
  pbcVersion?: string(name='pbcVersion', example='2022-04-01T00:00:00.000Z'),
  summary?: string(name='summary', example='资产市场'),
}

model PbcRepoForkListResult {
  reposForks?: [
    ReposFork
  ](name='reposForks'),
  requestId?: string(name='requestId'),
}

model PbcRepoMetricResult {
  repoMetrics?: [
    RepoMetric
  ](name='repoMetrics'),
  requestId?: string(name='requestId'),
}

model PbcReview {
  developerId?: long(name='developerId', example='1'),
  developerName?: string(name='developerName'),
  feedbackPbcApi?: string(name='feedbackPbcApi', example='符合规范'),
  feedbackPbcInstruction?: string(name='feedbackPbcInstruction', example='符合规范'),
  feedbackPbcSchema?: string(name='feedbackPbcSchema', example='符合pbc规格规范'),
  feedbackSecurity?: string(name='feedbackSecurity', example='服务安全'),
  feedbackServiceAvailable?: string(name='feedbackServiceAvailable', example='服务可用'),
  id?: long(name='id', example='1'),
  marketId?: long(name='marketId', example='1'),
  marketName?: string(name='marketName'),
  pbcName?: string(name='pbcName', example='基础商品'),
  pbcUrl?: string(name='pbcUrl', example='https://catalog.e2.aliyun.com/pbc/product'),
  pbcVersion?: string(name='pbcVersion', example='2022-04-01T00:00:00.000Z'),
  remainTime?: string(name='remainTime', example='4'),
  requestId?: string(name='requestId'),
  reviewerId?: long(name='reviewerId', example='1'),
  status?: string(name='status', example='REVIEWING'),
}

model PbcReviewCreateCmd {
  marketId?: long(name='marketId', example='1'),
  pbcUrl?: string(name='pbcUrl', example='https://catalog.e2.aliyun.com/pbc/product'),
  pbcVersionId?: long(name='pbcVersionId', example='1'),
  reviewerId?: long(name='reviewerId', example='1'),
}

model PbcReviewListResult {
  data?: [
    PbcReview
  ](name='data'),
  total?: int32(name='total', description='总数量', example='24'),
}

model PbcSchema {
  id?: long(name='id', example='1'),
  pbcVersionId?: long(name='pbcVersionId', example='2'),
  requestId?: string(name='requestId'),
  schema?: string(name='schema'),
}

model PbcSchemaCreateCmd {
  companyId?: long(name='companyId'),
  id?: long(name='id'),
  marketId?: long(name='marketId'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
  schema?: string(name='schema'),
}

model PbcSubscribe {
  developerId?: string(name='developerId'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  purpose?: string(name='purpose'),
  subPbcName?: string(name='subPbcName'),
}

model PbcUpDownstreamResult {
  pbcItems?: [
    PbcRelationItem
  ](name='pbcItems'),
  requestId?: string(name='requestId'),
}

model PbcVersion {
  companyId?: long(name='companyId', example='1'),
  companyName?: string(name='companyName', example='企业服务团队'),
  developerId?: long(name='developerId', example='1'),
  id?: long(name='id', example='1'),
  isWatched?: boolean(name='isWatched'),
  name?: string(name='name', example='product'),
  pbcId?: long(name='pbcId'),
  requestId?: string(name='requestId'),
  reviewId?: long(name='reviewId', example='1'),
  status?: string(name='status', example='DEVELOPING'),
  stepStatus?: string(name='stepStatus', example='SPEC'),
  version?: string(name='version', example='\\"2022-04-01\\"'),
  visibilityLevel?: string(name='visibilityLevel', example='PUBLIC'),
}

model PbcVersionCmd {
  apiSchema?: string(name='apiSchema'),
  companyId?: long(name='companyId'),
  developerId?: long(name='developerId'),
  document?: string(name='document'),
  marketId?: long(name='marketId'),
  name?: string(name='name'),
  schema?: string(name='schema'),
  version?: string(name='version'),
}

model PbcVersionListResult {
  data?: [
    PbcVersion
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: int32(name='total', example='24'),
}

model PdpConfig {
  accountId?: string(name='accountId', example='121321412341'),
  accountName?: string(name='accountName', example='account1'),
  askId?: string(name='askId', example='1'),
  context?: string(name='context', example='{key:value}'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-2-22 11:11:2'),
  gmtModified?: string(name='gmtModified', example='2022-2-22 11:11:2'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='neuron-developer-spring-config'),
  pbcId?: long(name='pbcId', example='1'),
  requestId?: string(name='requestId'),
  serviceId?: long(name='serviceId', example='1'),
  type?: string(name='type', example='SERVICE_SYSTEM'),
}

model PdpConfigPageResult {
  data?: [
    PdpConfig
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model PdpConfigUpdateCmd {
  accountId?: string(name='accountId', example='1223435435'),
  context?: string(name='context', example='{"key":"value"}'),
  id?: long(name='id', example='2'),
}

model PdpDeploymentPageResult {
  data?: [
    PdpServiceDeployment
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model PdpHistoryConfig {
  accountId?: string(name='accountId', example='121321412341'),
  accountName?: string(name='accountName', example='account1'),
  askId?: string(name='askId', example='1'),
  configId?: long(name='configId', example='1'),
  context?: string(name='context', example='{key:value}'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-2-22 11:11:2'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='neuron-developer-spring-config'),
  pbcId?: long(name='pbcId', example='1'),
  requestId?: string(name='requestId'),
  serviceId?: long(name='serviceId', example='1'),
  type?: string(name='type', example='SERVICE_SYSTEM'),
}

model PdpHistoryConfigPageResult {
  data?: [
    PdpHistoryConfig
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model PdpImage {
  imageId?: string(name='imageId', example='i-v12wpq'),
  imageTag?: string(name='imageTag', example='20220421100717_prepub'),
}

model PdpImagePageResult {
  data?: [
    PdpImage
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model PdpListEnvInfoResult {
  data?: [
    EnvInfoDO
  ](name='data'),
  requestId?: string(name='requestId', example='121'),
}

model PdpListLogResult {
  logs?: [
    PdpLog
  ](name='logs'),
}

model PdpListTokenResult {
  data?: [
    RuntimeToken
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpLog {
  content?: string(name='content'),
  ip?: string(name='ip'),
}

model PdpMetadataRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId', example='1'),
}

model PdpPbc {
  alias?: string(name='alias', example='基础商品'),
  company?: string(name='company', example='多端商城'),
  companyId?: long(name='companyId', example='1'),
  description?: string(name='description', example='基础商品描述'),
  developerId?: string(name='developerId', example='1'),
  gitGroup?: string(name='gitGroup', example='neuron-pdp-pbc'),
  gitGroupInfo?: string(name='gitGroupInfo', example='{"path":"neuron-pdp-pbc","webUrl":"https://codeup.aliyun.com/616d751bbc23ecd311af9711/neuron-pdp-pbc","name":"neuron-pdp-pbc","id":480037,"ownerId":663171,"pathWithNamespace":"616d751bbc23ecd311af9711/neuron-pdp-pbc","parentId":330007}'),
  gmtCreate?: string(name='gmtCreate', example='2022-05-01T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='product'),
  requestId?: string(name='requestId'),
  type?: string(name='type', example='INNER'),
}

model PdpPbcListResult {
  pdpPbcs?: [
    PdpPbc
  ](name='pdpPbcs'),
  requestId?: string(name='requestId'),
  total?: int32(name='total', example='24'),
}

model PdpPbcManagerRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  name?: string(name='name', example='product'),
  pbcId?: long(name='pbcId', example='1'),
}

model PdpPbcUpdateCmd {
  alias?: string(name='alias'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model PdpService {
  accountId?: string(name='accountId', example='121321412341'),
  alias?: string(name='alias', example='员工管理'),
  codeBranch?: string(name='codeBranch', example='dev'),
  description?: string(name='description', example='员工管理'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  extraInfo?: string(name='extraInfo', example='SDK'),
  gitRepo?: string(name='gitRepo', example='git@gitlab.alibaba-inc.com:neuron/manager-developer.git'),
  gmtCreate?: string(name='gmtCreate', example='2022-2-22 11:11:2'),
  gmtModified?: string(name='gmtModified', example='2022-2-22 11:11:2'),
  id?: long(name='id', example='1'),
  jumpUrl?: string(name='jumpUrl', example='https://cd.aone.alibaba-inc.com/ec/pipelines/44156?spm=a2o8d.aone_cd_assets_pages_pipeline_index.0.0.68b81c05WLmX79&name=%E3%80%90%E6%B5%8B%E8%AF%95%E3%80%91neuron-developer%E6%9D%AD%E5%B7%9E'),
  name?: string(name='name', example='employee'),
  orgType?: string(name='orgType', example='INNER'),
  pbcId?: long(name='pbcId', example='1'),
  requestId?: string(name='requestId'),
  status?: string(name='status', example='Active'),
  type?: string(name='type', example='SDK'),
}

model PdpServiceDeployment {
  accountId?: string(name='accountId', example='121321412341'),
  changeOrderId?: string(name='changeOrderId', example='cd65b247-****-475b-ad4b-7039040d625c'),
  context?: string(name='context'),
  cpu?: int32(name='cpu', example='2'),
  deploymentType?: string(name='deploymentType', example='AUTO'),
  description?: string(name='description', example='部署员工管理'),
  edasId?: string(name='edasId', example='sdad'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  env?: string(name='env', example='TEST'),
  gmtCreate?: string(name='gmtCreate', example='2022-2-22 11:11:2'),
  gmtModified?: string(name='gmtModified', example='2022-2-22 11:11:2'),
  id?: long(name='id', example='1'),
  imageId?: string(name='imageId', example='i-v12wpq'),
  imageTag?: string(name='imageTag', example='20220421100717_prepub'),
  instanceCount?: int32(name='instanceCount', example='3'),
  memory?: int32(name='memory', example='4'),
  message?: string(name='message'),
  orgType?: string(name='orgType', example='INNER'),
  pbcId?: long(name='pbcId', example='1'),
  pbcName?: string(name='pbcName', example='management'),
  pipelineTimes?: int32(name='pipelineTimes', example='12'),
  repositoryId?: string(name='repositoryId', example='cri-v1d49e57e8ojcwpq'),
  requestId?: string(name='requestId'),
  rollbackStatus?: string(name='rollbackStatus', example='DEPLOYMENT_PENDING'),
  serviceId?: long(name='serviceId', example='1'),
  serviceName?: string(name='serviceName', example='employee'),
  status?: string(name='status', example='DEPLOYMENT_PENDING'),
  timeout?: int32(name='timeout', example='123'),
  times?: int32(name='times', example='2'),
  type?: string(name='type', example='SERVICE'),
}

model PdpServicePageResult {
  data?: [
    PdpService
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model PdpServiceRoleCreateCmd {
  companyId?: long(name='companyId', example='1'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId', example='1'),
  serviceId?: long(name='serviceId', example='1'),
}

model PdpServiceUpdateCmd {
  alias?: string(name='alias', example='员工管理'),
  codeBranch?: string(name='codeBranch', example='dev'),
  description?: string(name='description', example='员工管理'),
  extraInfo?: string(name='extraInfo', example='SDK'),
  gitRepo?: string(name='gitRepo', example='git@gitlab.alibaba-inc.com:neuron/manager-developer.git'),
  id?: long(name='id', example='1'),
  jumpUrl?: string(name='jumpUrl', example='https://aone.alibaba-inc.com/appcenter/app/onlinetask/SUBMIT_RESOURCE_APPLY?appId=195041'),
}

model PermissionAllowResource {
  requestId?: string(name='requestId'),
  resourceList?: [ string ](name='resourceList'),
}

model PermissionCheckCmd {
  action?: string(name='action', example='write'),
  operatorId?: string(name='operatorId', example='1'),
  operatorType?: string(name='operatorType', example='developer'),
  resource?: string(name='resource', example='neuron:catalog:company/1:pbc/2'),
}

model PermissionResult {
  allow?: boolean(name='allow'),
  requestId?: string(name='requestId'),
}

model Privilege {
  accountId?: string(name='accountId', example='121321412341'),
  actions?: string(name='actions', example='"write,edit"'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id', example='1'),
  requestId?: string(name='requestId'),
  resource?: string(name='resource', example='neuron:catalog:company/1:pbc/2'),
  roleId?: long(name='roleId', example='1'),
}

model PrivilegePageResult {
  data?: [
    Privilege
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model Product {
  accountId?: string(name='accountId'),
  alias?: string(name='alias', example='多端商城'),
  companyId?: long(name='companyId', example='1'),
  creator?: string(name='creator'),
  description?: string(name='description'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='yunmall'),
  requestId?: string(name='requestId'),
}

model ProductCreateCmd {
  accountId?: string(name='accountId'),
  alias?: string(name='alias', example='多端商城'),
  companyId?: long(name='companyId', example='1'),
  description?: string(name='description'),
  name?: string(name='name', example='yunmall'),
}

model ProductListResult {
  products?: [
    Product
  ](name='products'),
  requestId?: string(name='requestId'),
  total?: int32(name='total'),
}

model ProductUpdateCmd {
  alias?: string(name='alias'),
  description?: string(name='description'),
  id?: long(name='id'),
  requestId?: string(name='requestId'),
}

model Provider {
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  contact?: string(name='contact'),
  email?: string(name='email'),
  team?: string(name='team'),
  teamId?: long(name='teamId'),
}

model RegisterBucUserCmd {
  enterpriseId?: long(name='enterpriseId'),
  enterpriseName?: string(name='enterpriseName'),
}

model RepoItem {
  codeLines?: long(name='codeLines', example='2034'),
  gitProjectUrl?: string(name='gitProjectUrl', example='https://code.aone.alibaba-inc.com/yunmall/yunmall-custome'),
  owner?: string(name='owner', example='中驿'),
  repoShortUrl?: string(name='repoShortUrl', example='yunmall/product.git'),
  repoUrl?: string(name='repoUrl', example='git@gitlab.alibaba-inc.com:yunmall/product.git'),
  summary?: string(name='summary', example='类目'),
}

model RepoMetric {
  codeLines?: long(name='codeLines', example='294'),
  commitCnt?: long(name='commitCnt', example='23'),
  developerCnt?: long(name='developerCnt', example='3'),
  refreshDate?: string(name='refreshDate', example='2022-05-03T00:00:00.000Z'),
  repoShortUrl?: string(name='repoShortUrl', example='neuron/catalog.git'),
  repoUrl?: string(name='repoUrl', example='git@gitlab.alibaba-inc.com:neuron/catalog.git'),
}

model ReposDeveloperGroupMetric {
  addLines?: long(name='addLines', example='342'),
  commentLines?: long(name='commentLines', example='242'),
  commitCnt?: long(name='commitCnt', example='14'),
  delLines?: long(name='delLines', example='23'),
  modLines?: long(name='modLines', example='129'),
  showName?: string(name='showName', example='旭坤'),
  workNo?: string(name='workNo', example='64634'),
}

model ReposFork {
  gitGroup?: string(name='gitGroup', example='global-mall'),
  gmtCreate?: string(name='gmtCreate', example='2022-04-03T00:00:00.000Z'),
  id?: long(name='id', example='1'),
  isOrigin?: boolean(name='isOrigin', example='true'),
  pbcRepoItems?: [
    RepoItem
  ](name='pbcRepoItems'),
  requestId?: string(name='requestId'),
  usage?: string(name='usage', example='商城国际版本'),
}

model ReposForkCreateCmd {
  companyId?: long(name='companyId'),
  gitGroup?: string(name='gitGroup', example='global-mall'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId', example='1'),
  usage?: string(name='usage', example='商城国际化版本'),
  visible?: boolean(name='visible'),
}

model Reviewer {
  accountId?: string(name='accountId'),
  enterpriseId?: long(name='enterpriseId'),
  id?: long(name='id'),
  name?: string(name='name'),
}

model ReviewerListResult {
  requestId?: string(name='requestId'),
  reviewers?: [
    Reviewer
  ](name='reviewers'),
}

model RevokeLibraryReviewCmd {
  libraryId?: long(name='libraryId'),
}

model RevokeReviewCmd {
  pbcVersionId?: long(name='pbcVersionId'),
}

model Role {
  accountId?: string(name='accountId', example='121321412341'),
  enterpriseId?: long(name='enterpriseId', example='1'),
  gmtCreate?: string(name='gmtCreate', example='2022-04-01'),
  id?: long(name='id', example='1'),
  name?: string(name='name', example='开发者'),
  platform?: string(name='platform', example='PDP'),
  requestId?: string(name='requestId'),
  type?: string(name='type', example='CUSTOM'),
}

model RoleGrantCmd {
  accountId?: string(name='accountId', example='1'),
  authorizationResourceList?: [
    AuthorizationResource
  ](name='authorizationResourceList'),
  roleId?: long(name='roleId', example='1'),
}

model RoleInfoUpdateCmd {
  id?: long(name='id', example='1'),
  name?: string(name='name', example='开发者'),
}

model RolePageResult {
  data?: [
    Role
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model RoleRevokeCmd {
  authorizerId?: string(name='authorizerId', example='1'),
  authorizerType?: string(name='authorizerType', example='developer'),
  roleId?: long(name='roleId', example='1'),
}

model RuntimeToken {
  env?: string(name='env', example='TEST'),
  pbcId?: long(name='pbcId', example='2'),
  pbcName?: string(name='pbcName', example='yunmall-item'),
  serviceId?: long(name='serviceId', example='1'),
  serviceName?: string(name='serviceName', example='yunmall-item'),
  token?: string(name='token', example='dfsdf'),
}

model SearchTracesPageResult {
  traceInfos?: [
    TraceInfo
  ](name='traceInfos'),
}

model SendTTSVerifyLinkResult {
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
}

model ServerInstanceResult {
  intTotal?: int32(name='intTotal'),
  ips?: [ string ](name='ips'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model ServiceMetricPageResult {
  data?: [
    MetricData
  ](name='data'),
  intTotal?: int32(name='intTotal'),
  requestId?: string(name='requestId'),
  total?: long(name='total', example='24'),
}

model Settled {
  accountId?: string(name='accountId'),
  application?: string(name='application'),
  developerName?: string(name='developerName'),
  email?: string(name='email'),
  enterpriseName?: string(name='enterpriseName'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  phone?: string(name='phone'),
  requestId?: string(name='requestId'),
  status?: string(name='status'),
  type?: string(name='type'),
  usage?: string(name='usage'),
}

model SettledCreateCmd {
  accountId?: string(name='accountId'),
  application?: string(name='application'),
  developerName?: string(name='developerName'),
  email?: string(name='email'),
  enterpriseName?: string(name='enterpriseName'),
  phone?: string(name='phone'),
  usage?: string(name='usage'),
}

model SettledPageResult {
  requestId?: string(name='requestId'),
  settleds?: [
    Settled
  ](name='settleds'),
}

model SettledUpdateCmd {
  status?: string(name='status'),
}

model StackDetailResult {
  stacks?: [
    StackInfo
  ](name='stacks'),
}

model StackInfo {
  api?: string(name='api'),
  duration?: long(name='duration'),
  exception?: string(name='exception'),
  extInfo?: StackInfoExtInfo(name='extInfo'),
  line?: string(name='line'),
  rpcId?: string(name='rpcId'),
  serviceName?: string(name='serviceName'),
  startTime?: long(name='startTime'),
}

model StackInfoExtInfo {
  info?: string(name='info'),
  type?: string(name='type'),
}

model StrategyItem {
  action?: string(name='action'),
  resource?: string(name='resource'),
}

model TagEntry {
  key?: string(name='key'),
  value?: string(name='value'),
}

model TraceInfo {
  duration?: long(name='duration'),
  operationName?: string(name='operationName'),
  serviceIp?: string(name='serviceIp'),
  serviceName?: string(name='serviceName'),
  timestamp?: long(name='timestamp'),
  traceId?: string(name='traceId'),
}

model TraceInfoDetailResult {
  traceDetails?: [ 
    {
      children?: [  map[string]any ](name='children'),
      duration?: long(name='duration'),
      haveStack?: boolean(name='haveStack'),
      logEventList?: [
        TraceSpansLogEventList
      ](name='logEventList'),
      operationName?: string(name='operationName'),
      parentSpanId?: string(name='parentSpanId'),
      resultCode?: string(name='resultCode'),
      rpcId?: string(name='rpcId'),
      rpcType?: long(name='rpcType'),
      rpcTypeName?: string(name='rpcTypeName'),
      serviceIp?: string(name='serviceIp'),
      serviceName?: string(name='serviceName'),
      spanId?: string(name='spanId'),
      tagEntryList?: [
        TagEntry
      ](name='tagEntryList'),
      timestamp?: long(name='timestamp'),
      traceId?: string(name='traceId'),
    }
  ](name='traceDetails'),
}

model TraceSpansLogEventList {
  logEventTagEntryList?: [
    TagEntry
  ](name='logEventTagEntryList'),
}

model AuditForkReviewRequest {
  body?: ForkReviewAuditCmd(name='body'),
}

model AuditForkReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: string(name='result'),
}

model AuditForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuditForkReviewResponseBody(name='body'),
}

async function auditForkReviewWithOptions(reviewId: string, request: AuditForkReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuditForkReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'AuditForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/audit`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function auditForkReview(reviewId: string, request: AuditForkReviewRequest): AuditForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return auditForkReviewWithOptions(reviewId, request, headers, runtime);
}

model AuditPbcInvokeReviewRequest {
  approve?: boolean(name='approve'),
}

model AuditPbcInvokeReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model AuditPbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuditPbcInvokeReviewResponseBody(name='body'),
}

async function auditPbcInvokeReviewWithOptions(reviewId: string, request: AuditPbcInvokeReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuditPbcInvokeReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.approve)) {
    body['approve'] = request.approve;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AuditPbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/audit`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function auditPbcInvokeReview(reviewId: string, request: AuditPbcInvokeReviewRequest): AuditPbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return auditPbcInvokeReviewWithOptions(reviewId, request, headers, runtime);
}

model BatchGrantRolesToDeveloperRequest {
  body?: BatchGrantRolesCmd(name='body'),
}

model BatchGrantRolesToDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function batchGrantRolesToDeveloperWithOptions(request: BatchGrantRolesToDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGrantRolesToDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGrantRolesToDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/batch-grant-roles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function batchGrantRolesToDeveloper(request: BatchGrantRolesToDeveloperRequest): BatchGrantRolesToDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGrantRolesToDeveloperWithOptions(request, headers, runtime);
}

model CheckBucUserRoleRequest {
  accountId?: string(name='accountId', example='297541549833098645'),
  companyId?: long(name='companyId', example='4'),
  platform?: string(name='platform', example='PDP'),
  roleName?: string(name='roleName'),
}

model CheckBucUserRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function checkBucUserRoleWithOptions(request: CheckBucUserRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckBucUserRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    body['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.companyId)) {
    body['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.roleName)) {
    body['roleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckBucUserRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/commands/check-role`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkBucUserRole(request: CheckBucUserRoleRequest): CheckBucUserRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkBucUserRoleWithOptions(request, headers, runtime);
}

model CheckDeveloperRoleRequest {
  accountId?: string(name='accountId'),
  companyId?: long(name='companyId'),
  platform?: string(name='platform'),
  roleName?: string(name='roleName'),
}

model CheckDeveloperRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PermissionResult  
}

async function checkDeveloperRoleWithOptions(request: CheckDeveloperRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckDeveloperRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    body['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.companyId)) {
    body['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.platform)) {
    body['platform'] = request.platform;
  }
  if (!Util.isUnset(request.roleName)) {
    body['roleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckDeveloperRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/check-role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDeveloperRole(request: CheckDeveloperRoleRequest): CheckDeveloperRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkDeveloperRoleWithOptions(request, headers, runtime);
}

model CheckServiceReachableResponseBody = {
  requestId?: string(name='requestId'),
  result?: string(name='result'),
}

model CheckServiceReachableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceReachableResponseBody(name='body'),
}

async function checkServiceReachableWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CheckServiceReachableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceReachable',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/checkpreload.htm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceReachable(): CheckServiceReachableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkServiceReachableWithOptions(headers, runtime);
}

model CompleteRegisterLibraryRequest {
  dependIntegral?: int32(name='dependIntegral'),
  marketId?: long(name='marketId'),
}

model CompleteRegisterLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function completeRegisterLibraryWithOptions(id: string, request: CompleteRegisterLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteRegisterLibraryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dependIntegral)) {
    body['dependIntegral'] = request.dependIntegral;
  }
  if (!Util.isUnset(request.marketId)) {
    body['marketId'] = request.marketId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteRegisterLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}/commands/complete-register`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeRegisterLibrary(id: string, request: CompleteRegisterLibraryRequest): CompleteRegisterLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeRegisterLibraryWithOptions(id, request, headers, runtime);
}

model CompleteRegistrationPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function completeRegistrationPbcVersionWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteRegistrationPbcVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CompleteRegistrationPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(id)}/commands/complete-register`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function completeRegistrationPbcVersion(id: string): CompleteRegistrationPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeRegistrationPbcVersionWithOptions(id, headers, runtime);
}

model ContinueDeploymentRequest {
  body?: DeploymentContinueCmd(name='body'),
}

model ContinueDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpServiceDeployment  
}

async function continueDeploymentWithOptions(request: ContinueDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ContinueDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/commands/continue`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function continueDeployment(request: ContinueDeploymentRequest): ContinueDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return continueDeploymentWithOptions(request, headers, runtime);
}

model CreateAssetWatchRequest {
  body?: CreateAssetWatchCmd(name='body'),
}

model CreateAssetWatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function createAssetWatchWithOptions(request: CreateAssetWatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAssetWatchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateAssetWatch',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watchs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAssetWatch(request: CreateAssetWatchRequest): CreateAssetWatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAssetWatchWithOptions(request, headers, runtime);
}

model CreateBizUserTokenRequest {
  body?: NeuronBizUserTokenCreateCmd(name='body'),
}

model CreateBizUserTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: NeuronAppToken  
}

async function createBizUserTokenWithOptions(request: CreateBizUserTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateBizUserTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBizUserToken',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/appstore/v1/app/token/commands/biz-user`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBizUserToken(request: CreateBizUserTokenRequest): CreateBizUserTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createBizUserTokenWithOptions(request, headers, runtime);
}

model CreateDeveloperRequest {
  body?: Developer(name='body'),
}

model CreateDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function createDeveloperWithOptions(request: CreateDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeveloper(request: CreateDeveloperRequest): CreateDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeveloperWithOptions(request, headers, runtime);
}

model CreateEnterpriseRequest {
  body?: Enterprise(name='body'),
}

model CreateEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Enterprise  
}

async function createEnterpriseWithOptions(request: CreateEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEnterprise(request: CreateEnterpriseRequest): CreateEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnterpriseWithOptions(request, headers, runtime);
}

model CreateForkReviewRequest {
  body?: ForkReviewCreateCmd(name='body'),
}

model CreateForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForkReviewCreateResult  
}

async function createForkReviewWithOptions(request: CreateForkReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateForkReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createForkReview(request: CreateForkReviewRequest): CreateForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createForkReviewWithOptions(request, headers, runtime);
}

model CreateLibraryRequest {
  body?: LibraryCreateCmd(name='body'),
}

model CreateLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Library  
}

async function createLibraryWithOptions(request: CreateLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLibrary(request: CreateLibraryRequest): CreateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryWithOptions(request, headers, runtime);
}

model CreateLibraryInstructionRequest {
  companyId?: long(name='companyId'),
  document?: string(name='document'),
  id?: int32(name='id'),
  libraryId?: string(name='libraryId'),
  marketId?: long(name='marketId'),
}

model CreateLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryInstruction  
}

async function createLibraryInstructionWithOptions(libraryId: string, request: CreateLibraryInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryInstructionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    body['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.document)) {
    body['document'] = request.document;
  }
  if (!Util.isUnset(request.id)) {
    body['id'] = request.id;
  }
  if (!Util.isUnset(request.libraryId)) {
    body['libraryId'] = request.libraryId;
  }
  if (!Util.isUnset(request.marketId)) {
    body['marketId'] = request.marketId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/instructions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLibraryInstruction(libraryId: string, request: CreateLibraryInstructionRequest): CreateLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryInstructionWithOptions(libraryId, request, headers, runtime);
}

model CreateLibraryReviewRequest {
  body?: LibraryReviewCreateCmd(name='body'),
}

model CreateLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryReview  
}

async function createLibraryReviewWithOptions(request: CreateLibraryReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLibraryReview(request: CreateLibraryReviewRequest): CreateLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryReviewWithOptions(request, headers, runtime);
}

model CreateLibrarySchemaRequest {
  body?: LibrarySchema(name='body'),
}

model CreateLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibrarySchema  
}

async function createLibrarySchemaWithOptions(request: CreateLibrarySchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibrarySchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLibrarySchema(request: CreateLibrarySchemaRequest): CreateLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibrarySchemaWithOptions(request, headers, runtime);
}

model CreateMobiTokenRequest {
  body?: NeuronMobiTokenCreateCmd(name='body'),
}

model CreateMobiTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: NeuronAppToken  
}

async function createMobiTokenWithOptions(request: CreateMobiTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMobiTokenResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMobiToken',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/appstore/v1/app/token/commands/mobi`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMobiToken(request: CreateMobiTokenRequest): CreateMobiTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMobiTokenWithOptions(request, headers, runtime);
}

model CreateMonitorArmsAlertRequest {
  body?: MonitorArmsAlert(name='body'),
}

model CreateMonitorArmsAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorArmsAlert  
}

async function createMonitorArmsAlertWithOptions(request: CreateMonitorArmsAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorArmsAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorArmsAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorArmsAlert`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorArmsAlert(request: CreateMonitorArmsAlertRequest): CreateMonitorArmsAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorArmsAlertWithOptions(request, headers, runtime);
}

model CreateMonitorArmsAlertsRequest {
  body?: MonitorArmsAlerts(name='body'),
}

model CreateMonitorArmsAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorArmsAlerts  
}

async function createMonitorArmsAlertsWithOptions(request: CreateMonitorArmsAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorArmsAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorArmsAlerts',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorArmsAlerts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorArmsAlerts(request: CreateMonitorArmsAlertsRequest): CreateMonitorArmsAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorArmsAlertsWithOptions(request, headers, runtime);
}

model CreateMonitorContactRequest {
  body?: MonitorContact(name='body'),
}

model CreateMonitorContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContact  
}

async function createMonitorContactWithOptions(request: CreateMonitorContactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorContact',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorContact(request: CreateMonitorContactRequest): CreateMonitorContactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorContactWithOptions(request, headers, runtime);
}

model CreateMonitorContactGroupRequest {
  body?: MonitorContactGroupCreateCmd(name='body'),
}

model CreateMonitorContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContactGroupCreateCmd  
}

async function createMonitorContactGroupWithOptions(request: CreateMonitorContactGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorContactGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorContactGroup(request: CreateMonitorContactGroupRequest): CreateMonitorContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorContactGroupWithOptions(request, headers, runtime);
}

model CreateMonitorGroupMemberRequest {
  body?: MonitorGroupMemberCreateCmd(name='body'),
}

model CreateMonitorGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function createMonitorGroupMemberWithOptions(groupId: string, request: CreateMonitorGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorGroupMemberResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorGroupMember',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group/${OpenApiUtil.getEncodeParam(groupId)}/commands/create-member`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function createMonitorGroupMember(groupId: string, request: CreateMonitorGroupMemberRequest): CreateMonitorGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorGroupMemberWithOptions(groupId, request, headers, runtime);
}

model CreateMonitorMqAlertRequest {
  body?: MonitorMqAlert(name='body'),
}

model CreateMonitorMqAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorMqAlert  
}

async function createMonitorMqAlertWithOptions(request: CreateMonitorMqAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorMqAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorMqAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorMqAlert`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorMqAlert(request: CreateMonitorMqAlertRequest): CreateMonitorMqAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorMqAlertWithOptions(request, headers, runtime);
}

model CreateMonitorMqAlertsRequest {
  body?: MonitorMqAlerts(name='body'),
}

model CreateMonitorMqAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorMqAlerts  
}

async function createMonitorMqAlertsWithOptions(request: CreateMonitorMqAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorMqAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorMqAlerts',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorMqAlerts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorMqAlerts(request: CreateMonitorMqAlertsRequest): CreateMonitorMqAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorMqAlertsWithOptions(request, headers, runtime);
}

model CreateMonitorSlsAlertRequest {
  body?: MonitorSlsAlert(name='body'),
}

model CreateMonitorSlsAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorSlsAlert  
}

async function createMonitorSlsAlertWithOptions(request: CreateMonitorSlsAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorSlsAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorSlsAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorSlsAlert`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorSlsAlert(request: CreateMonitorSlsAlertRequest): CreateMonitorSlsAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorSlsAlertWithOptions(request, headers, runtime);
}

model CreateMonitorSlsAlertsRequest {
  body?: MonitorSlsAlerts(name='body'),
}

model CreateMonitorSlsAlertsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorSlsAlerts  
}

async function createMonitorSlsAlertsWithOptions(request: CreateMonitorSlsAlertsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorSlsAlertsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorSlsAlerts',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/createMonitorSlsAlerts`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorSlsAlerts(request: CreateMonitorSlsAlertsRequest): CreateMonitorSlsAlertsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorSlsAlertsWithOptions(request, headers, runtime);
}

model CreateMonitorWebhookRequest {
  body?: MonitorWebhook(name='body'),
}

model CreateMonitorWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorWebhook  
}

async function createMonitorWebhookWithOptions(request: CreateMonitorWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMonitorWebhookResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorWebhook',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/webhook`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorWebhook(request: CreateMonitorWebhookRequest): CreateMonitorWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMonitorWebhookWithOptions(request, headers, runtime);
}

model CreateMqGroupRequest {
  body?: MqGroup(name='body'),
}

model CreateMqGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqGroup  
}

async function createMqGroupWithOptions(request: CreateMqGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMqGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMqGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/group`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMqGroup(request: CreateMqGroupRequest): CreateMqGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMqGroupWithOptions(request, headers, runtime);
}

model CreateMqTopicRequest {
  body?: MqTopic(name='body'),
}

model CreateMqTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqTopic  
}

async function createMqTopicWithOptions(request: CreateMqTopicRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateMqTopicResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMqTopic',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/topic`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMqTopic(request: CreateMqTopicRequest): CreateMqTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createMqTopicWithOptions(request, headers, runtime);
}

model CreatePbcRequest {
  body?: PbcCreateCmd(name='body'),
}

model CreatePbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Pbc  
}

async function createPbcWithOptions(request: CreatePbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbc(request: CreatePbcRequest): CreatePbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcWithOptions(request, headers, runtime);
}

model CreatePbcApiSchemaRequest {
  body?: PbcApiSchemaCreateCmd(name='body'),
}

model CreatePbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcApiSchema  
}

async function createPbcApiSchemaWithOptions(request: CreatePbcApiSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcApiSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/api-schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcApiSchema(request: CreatePbcApiSchemaRequest): CreatePbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcApiSchemaWithOptions(request, headers, runtime);
}

model CreatePbcInstructionRequest {
  body?: PbcInstructionCreateCmd(name='body'),
}

model CreatePbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcInstruction  
}

async function createPbcInstructionWithOptions(request: CreatePbcInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInstructionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/instructions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcInstruction(request: CreatePbcInstructionRequest): CreatePbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInstructionWithOptions(request, headers, runtime);
}

model CreatePbcInvokeRequest {
  body?: PbcInvokeCreateCmd(name='body'),
}

model CreatePbcInvokeResponseBody = {
  pbcInvokeId?: long(name='pbcInvokeId'),
  requestId?: string(name='requestId'),
}

model CreatePbcInvokeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcInvokeResponseBody(name='body'),
}

async function createPbcInvokeWithOptions(request: CreatePbcInvokeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInvokeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInvoke',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invokes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcInvoke(request: CreatePbcInvokeRequest): CreatePbcInvokeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInvokeWithOptions(request, headers, runtime);
}

model CreatePbcInvokeReviewRequest {
  body?: PbcInvokeReviewCreateCmd(name='body'),
}

model CreatePbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcInvokeReviewResult  
}

async function createPbcInvokeReviewWithOptions(request: CreatePbcInvokeReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInvokeReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcInvokeReview(request: CreatePbcInvokeReviewRequest): CreatePbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInvokeReviewWithOptions(request, headers, runtime);
}

model CreatePbcReviewRequest {
  body?: PbcReviewCreateCmd(name='body'),
}

model CreatePbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcReview  
}

async function createPbcReviewWithOptions(request: CreatePbcReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcReview(request: CreatePbcReviewRequest): CreatePbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcReviewWithOptions(request, headers, runtime);
}

model CreatePbcSchemaRequest {
  body?: PbcSchemaCreateCmd(name='body'),
}

model CreatePbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcSchema  
}

async function createPbcSchemaWithOptions(request: CreatePbcSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcSchema(request: CreatePbcSchemaRequest): CreatePbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcSchemaWithOptions(request, headers, runtime);
}

model CreatePbcVersionRequest {
  body?: PbcVersionCmd(name='body'),
}

model CreatePbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcVersion  
}

async function createPbcVersionWithOptions(request: CreatePbcVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPbcVersion(request: CreatePbcVersionRequest): CreatePbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcVersionWithOptions(request, headers, runtime);
}

model CreatePdpConfigRequest {
  body?: PdpConfig(name='body'),
}

model CreatePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpConfig  
}

async function createPdpConfigWithOptions(request: CreatePdpConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdpConfig(request: CreatePdpConfigRequest): CreatePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpConfigWithOptions(request, headers, runtime);
}

model CreatePdpPbcRequest {
  body?: PdpPbc(name='body'),
}

model CreatePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpPbc  
}

async function createPdpPbcWithOptions(request: CreatePdpPbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpPbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdpPbc(request: CreatePdpPbcRequest): CreatePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpPbcWithOptions(request, headers, runtime);
}

model CreatePdpServiceRequest {
  body?: PdpService(name='body'),
}

model CreatePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpService  
}

async function createPdpServiceWithOptions(request: CreatePdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPdpService(request: CreatePdpServiceRequest): CreatePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpServiceWithOptions(request, headers, runtime);
}

model CreatePrivilegeRequest {
  body?: CreatePrivilegeCmd(name='body'),
}

model CreatePrivilegeResponseBody = {
  list?: [
    Privilege
  ](name='list'),
  requestId?: string(name='requestId'),
}

model CreatePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrivilegeResponseBody(name='body'),
}

async function createPrivilegeWithOptions(roleId: string, request: CreatePrivilegeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrivilegeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrivilege',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/privileges`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPrivilege(roleId: string, request: CreatePrivilegeRequest): CreatePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrivilegeWithOptions(roleId, request, headers, runtime);
}

model CreatePrivilegePopRequest {
  body?: CreatePrivilegePopCmd(name='body'),
}

model CreatePrivilegePopResponseBody = {
  list?: [
    Privilege
  ](name='list'),
  requestId?: string(name='requestId', example='sdadawqewe'),
}

model CreatePrivilegePopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrivilegePopResponseBody(name='body'),
}

async function createPrivilegePopWithOptions(roleId: string, request: CreatePrivilegePopRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrivilegePopResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrivilegePop',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/privileges/pop`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPrivilegePop(roleId: string, request: CreatePrivilegePopRequest): CreatePrivilegePopResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrivilegePopWithOptions(roleId, request, headers, runtime);
}

model CreateProductRequest {
  body?: ProductCreateCmd(name='body'),
}

model CreateProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Product  
}

async function createProductWithOptions(request: CreateProductRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateProductResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateProduct',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/products`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createProduct(request: CreateProductRequest): CreateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createProductWithOptions(request, headers, runtime);
}

model CreateRepoForkRequest {
  body?: ReposForkCreateCmd(name='body'),
}

model CreateRepoForkResponseBody = {
  requestId?: string(name='requestId'),
  result?: long(name='result'),
}

model CreateRepoForkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoForkResponseBody(name='body'),
}

async function createRepoForkWithOptions(request: CreateRepoForkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepoForkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoFork',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRepoFork(request: CreateRepoForkRequest): CreateRepoForkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepoForkWithOptions(request, headers, runtime);
}

model CreateRoleRequest {
  body?: Role(name='body'),
}

model CreateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Role  
}

async function createRoleWithOptions(request: CreateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRoleWithOptions(request, headers, runtime);
}

model CreateSettledRequest {
  body?: SettledCreateCmd(name='body'),
}

model CreateSettledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Settled  
}

async function createSettledWithOptions(request: CreateSettledRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateSettledResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSettled',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/settleds`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSettled(request: CreateSettledRequest): CreateSettledResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createSettledWithOptions(request, headers, runtime);
}

model DeleteDeveloperRequest {
  enterpriseId?: long(name='enterpriseId'),
}

model DeleteDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDeveloperWithOptions(accountId: string, request: DeleteDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeveloperResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteDeveloper(accountId: string, request: DeleteDeveloperRequest): DeleteDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeveloperWithOptions(accountId, request, headers, runtime);
}

model DeleteEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteEnterpriseWithOptions(enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteEnterprise(enterpriseId: string): DeleteEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnterpriseWithOptions(enterpriseId, headers, runtime);
}

model DeleteLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibraryWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteLibrary(id: string): DeleteLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibraryWithOptions(id, headers, runtime);
}

model DeleteLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibraryInstructionWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibraryInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/instructions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteLibraryInstruction(libraryId: string): DeleteLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibraryInstructionWithOptions(libraryId, headers, runtime);
}

model DeleteLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibrarySchemaWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibrarySchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/schemas`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteLibrarySchema(libraryId: string): DeleteLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibrarySchemaWithOptions(libraryId, headers, runtime);
}

model DeleteMonitorAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMonitorAlertWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMonitorAlertResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorAlert(id: string): DeleteMonitorAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMonitorAlertWithOptions(id, headers, runtime);
}

model DeleteMonitorContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMonitorContactWithOptions(contactId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMonitorContactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorContact',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact/${OpenApiUtil.getEncodeParam(contactId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorContact(contactId: string): DeleteMonitorContactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMonitorContactWithOptions(contactId, headers, runtime);
}

model DeleteMonitorContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMonitorContactGroupWithOptions(groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMonitorContactGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorContactGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorContactGroup(groupId: string): DeleteMonitorContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMonitorContactGroupWithOptions(groupId, headers, runtime);
}

model DeleteMonitorGroupMemberRequest {
  contactIds?: string(name='contactIds', example='[]'),
}

model DeleteMonitorGroupMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMonitorGroupMemberWithOptions(groupId: string, request: DeleteMonitorGroupMemberRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMonitorGroupMemberResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.contactIds)) {
    query['contactIds'] = request.contactIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorGroupMember',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group/${OpenApiUtil.getEncodeParam(groupId)}/commands/delete-member`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorGroupMember(groupId: string, request: DeleteMonitorGroupMemberRequest): DeleteMonitorGroupMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMonitorGroupMemberWithOptions(groupId, request, headers, runtime);
}

model DeleteMonitorWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMonitorWebhookWithOptions(webhookId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMonitorWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMonitorWebhook',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/webhook/${OpenApiUtil.getEncodeParam(webhookId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMonitorWebhook(webhookId: string): DeleteMonitorWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMonitorWebhookWithOptions(webhookId, headers, runtime);
}

model DeleteMqGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMqGroupWithOptions(groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMqGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMqGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/group/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMqGroup(groupId: string): DeleteMqGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMqGroupWithOptions(groupId, headers, runtime);
}

model DeleteMqTopicResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteMqTopicWithOptions(topicId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteMqTopicResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteMqTopic',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/topic/${OpenApiUtil.getEncodeParam(topicId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deleteMqTopic(topicId: string): DeleteMqTopicResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteMqTopicWithOptions(topicId, headers, runtime);
}

model DeletePbcInvokeRequest {
  applicant?: string(name='applicant'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId'),
}

model DeletePbcInvokeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function deletePbcInvokeWithOptions(request: DeletePbcInvokeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePbcInvokeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePbcInvoke',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invokes`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePbcInvoke(request: DeletePbcInvokeRequest): DeletePbcInvokeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePbcInvokeWithOptions(request, headers, runtime);
}

model DeletePdpConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model DeletePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpConfigResponseBody(name='body'),
}

async function deletePdpConfigWithOptions(configId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/${OpenApiUtil.getEncodeParam(configId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePdpConfig(configId: string): DeletePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpConfigWithOptions(configId, headers, runtime);
}

model DeletePdpPbcResponseBody = {
  data?: boolean(name='data'),
  requestId?: string(name='requestId'),
}

model DeletePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpPbcResponseBody(name='body'),
}

async function deletePdpPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePdpPbc(id: string): DeletePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpPbcWithOptions(id, headers, runtime);
}

model DeletePdpServiceResponseBody = {
  requestId?: string(name='requestId'),
}

model DeletePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpServiceResponseBody(name='body'),
}

async function deletePdpServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePdpService(serviceId: string): DeletePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpServiceWithOptions(serviceId, headers, runtime);
}

model DeletePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deletePrivilegeWithOptions(privilegeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePrivilegeResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePrivilege',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/privileges/${OpenApiUtil.getEncodeParam(privilegeId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function deletePrivilege(privilegeId: string): DeletePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePrivilegeWithOptions(privilegeId, headers, runtime);
}

model DeleteProductResponseBody = {
  data?: boolean(name='data', example='true'),
  requestId?: string(name='requestId', description='Id of the request', example='2dc580ca52ce43f59f890eaec37c8dad'),
}

model DeleteProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteProductResponseBody(name='body'),
}

async function deleteProductWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteProductResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteProduct',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/products/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteProduct(id: string): DeleteProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteProductWithOptions(id, headers, runtime);
}

model DeleteRoleResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRoleWithOptions(roleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRole(roleId: string): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(roleId, headers, runtime);
}

model DeleteSettledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CommonResult  
}

async function deleteSettledWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteSettledResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteSettled',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/settleds/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSettled(id: string): DeleteSettledResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteSettledWithOptions(id, headers, runtime);
}

model DependLibraryRequest {
  companyId?: long(name='companyId'),
}

model DependLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function dependLibraryWithOptions(id: string, request: DependLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DependLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DependLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}/commands/dependency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function dependLibrary(id: string, request: DependLibraryRequest): DependLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return dependLibraryWithOptions(id, request, headers, runtime);
}

model FeedbackLibraryReviewRequest {
  approve?: string(name='approve'),
  feedback?: string(name='feedback'),
  reviewId?: long(name='reviewId'),
}

model FeedbackLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryReview  
}

async function feedbackLibraryReviewWithOptions(reviewId: string, request: FeedbackLibraryReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FeedbackLibraryReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.approve)) {
    body['approve'] = request.approve;
  }
  if (!Util.isUnset(request.feedback)) {
    body['feedback'] = request.feedback;
  }
  if (!Util.isUnset(request.reviewId)) {
    body['reviewId'] = request.reviewId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FeedbackLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/feedback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function feedbackLibraryReview(reviewId: string, request: FeedbackLibraryReviewRequest): FeedbackLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return feedbackLibraryReviewWithOptions(reviewId, request, headers, runtime);
}

model FeedbackPbcReviewRequest {
  body?: FeedbackReviewCmd(name='body'),
}

model FeedbackPbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcReview  
}

async function feedbackPbcReviewWithOptions(reviewId: string, request: FeedbackPbcReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FeedbackPbcReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'FeedbackPbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/feedback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function feedbackPbcReview(reviewId: string, request: FeedbackPbcReviewRequest): FeedbackPbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return feedbackPbcReviewWithOptions(reviewId, request, headers, runtime);
}

model GetBucEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BucEnterprise  
}

async function getBucEnterpriseWithOptions(enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetBucEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetBucEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getBucEnterprise(enterpriseId: string): GetBucEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getBucEnterpriseWithOptions(enterpriseId, headers, runtime);
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployDetailInfo  
}

async function getDeploymentWithOptions(deploymentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/instance/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeployment(deploymentId: string): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeploymentWithOptions(deploymentId, headers, runtime);
}

model GetDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function getDeveloperWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeveloperResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeveloper(accountId: string): GetDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeveloperWithOptions(accountId, headers, runtime);
}

model GetDeveloperEnterpriseResponseBody = {
  enterprise?: Enterprise(name='enterprise'),
  requestId?: string(name='requestId'),
}

model GetDeveloperEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeveloperEnterpriseResponseBody(name='body'),
}

async function getDeveloperEnterpriseWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeveloperEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeveloperEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeveloperEnterprise(accountId: string): GetDeveloperEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeveloperEnterpriseWithOptions(accountId, headers, runtime);
}

model GetEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Enterprise  
}

async function getEnterpriseWithOptions(enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEnterprise(enterpriseId: string): GetEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnterpriseWithOptions(enterpriseId, headers, runtime);
}

model GetEnterpriseDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function getEnterpriseDeveloperWithOptions(accountId: string, enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnterpriseDeveloperResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnterpriseDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getEnterpriseDeveloper(accountId: string, enterpriseId: string): GetEnterpriseDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnterpriseDeveloperWithOptions(accountId, enterpriseId, headers, runtime);
}

model GetForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForkReview  
}

async function getForkReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetForkReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getForkReview(reviewId: string): GetForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getForkReviewWithOptions(reviewId, headers, runtime);
}

model GetHistoryDeveloperRequest {
  enterpriseId?: long(name='enterpriseId'),
}

model GetHistoryDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function getHistoryDeveloperWithOptions(accountId: string, request: GetHistoryDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistoryDeveloperResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistoryDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}/commonds/history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getHistoryDeveloper(accountId: string, request: GetHistoryDeveloperRequest): GetHistoryDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistoryDeveloperWithOptions(accountId, request, headers, runtime);
}

model GetLastDeploymentConfigRequest {
  env?: string(name='env'),
  serviceId?: long(name='serviceId'),
}

model GetLastDeploymentConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeployConfigInfo  
}

async function getLastDeploymentConfigWithOptions(request: GetLastDeploymentConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLastDeploymentConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLastDeploymentConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/last-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLastDeploymentConfig(request: GetLastDeploymentConfigRequest): GetLastDeploymentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLastDeploymentConfigWithOptions(request, headers, runtime);
}

model GetLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Library  
}

async function getLibraryWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibrary(id: string): GetLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryWithOptions(id, headers, runtime);
}

model GetLibraryDeveloperRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryDeveloperRepoMetricResult(name='result'),
}

model GetLibraryDeveloperRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryDeveloperRepoMetricsResponseBody(name='body'),
}

async function getLibraryDeveloperRepoMetricsWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryDeveloperRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryDeveloperRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/Librarys/${OpenApiUtil.getEncodeParam(libraryId)}/code/commands/get-developer-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibraryDeveloperRepoMetrics(libraryId: string): GetLibraryDeveloperRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryDeveloperRepoMetricsWithOptions(libraryId, headers, runtime);
}

model GetLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryInstruction  
}

async function getLibraryInstructionWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/instructions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibraryInstruction(libraryId: string): GetLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryInstructionWithOptions(libraryId, headers, runtime);
}

model GetLibraryRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryRepoMetricResult(name='result'),
}

model GetLibraryRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryRepoMetricsResponseBody(name='body'),
}

async function getLibraryRepoMetricsWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/Librarys/${OpenApiUtil.getEncodeParam(libraryId)}/code/commands/get-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibraryRepoMetrics(libraryId: string): GetLibraryRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryRepoMetricsWithOptions(libraryId, headers, runtime);
}

model GetLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryReview  
}

async function getLibraryReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibraryReview(reviewId: string): GetLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryReviewWithOptions(reviewId, headers, runtime);
}

model GetLibrarySchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibrarySchema(name='result'),
}

model GetLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibrarySchemaResponseBody(name='body'),
}

async function getLibrarySchemaWithOptions(libraryId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibrarySchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLibrarySchema(libraryId: string): GetLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibrarySchemaWithOptions(libraryId, headers, runtime);
}

model GetLoginUserInfoResponseBody = {
  result?: BucUser(name='result'),
}

model GetLoginUserInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLoginUserInfoResponseBody(name='body'),
}

async function getLoginUserInfoWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): GetLoginUserInfoResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLoginUserInfo',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/logins`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLoginUserInfo(): GetLoginUserInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLoginUserInfoWithOptions(headers, runtime);
}

model GetMonitorAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AbbrevMonitorAlert  
}

async function getMonitorAlertWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMonitorAlertResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorAlert(id: string): GetMonitorAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMonitorAlertWithOptions(id, headers, runtime);
}

model GetMonitorAlertHistoryRequest {
  alertRuleName?: string(name='alertRuleName'),
  endTime?: string(name='endTime'),
  env?: string(name='env'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcId?: string(name='pbcId'),
  serviceId?: string(name='serviceId'),
  startTime?: string(name='startTime'),
  type?: string(name='type'),
}

model GetMonitorAlertHistoryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorAlertHistoryPageResult  
}

async function getMonitorAlertHistoryWithOptions(request: GetMonitorAlertHistoryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetMonitorAlertHistoryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alertRuleName)) {
    query['alertRuleName'] = request.alertRuleName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorAlertHistory',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/getMonitorAlertHistory`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorAlertHistory(request: GetMonitorAlertHistoryRequest): GetMonitorAlertHistoryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMonitorAlertHistoryWithOptions(request, headers, runtime);
}

model GetMonitorContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContact  
}

async function getMonitorContactWithOptions(contactId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMonitorContactResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorContact',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact/${OpenApiUtil.getEncodeParam(contactId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorContact(contactId: string): GetMonitorContactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMonitorContactWithOptions(contactId, headers, runtime);
}

model GetMonitorContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContactGroup  
}

async function getMonitorContactGroupWithOptions(groupId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMonitorContactGroupResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorContactGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group/${OpenApiUtil.getEncodeParam(groupId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorContactGroup(groupId: string): GetMonitorContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMonitorContactGroupWithOptions(groupId, headers, runtime);
}

model GetMonitorWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorWebhook  
}

async function getMonitorWebhookWithOptions(webhookId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetMonitorWebhookResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorWebhook',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/webhook/${OpenApiUtil.getEncodeParam(webhookId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorWebhook(webhookId: string): GetMonitorWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getMonitorWebhookWithOptions(webhookId, headers, runtime);
}

model GetPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Pbc  
}

async function getPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbc(id: string): GetPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcWithOptions(id, headers, runtime);
}

model GetPbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcApiSchema  
}

async function getPbcApiSchemaWithOptions(pbcVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcApiSchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/api-schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcApiSchema(pbcVersionId: string): GetPbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcApiSchemaWithOptions(pbcVersionId, headers, runtime);
}

model GetPbcDeveloperRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcDeveloperRepoMetricResult  
}

async function getPbcDeveloperRepoMetricsWithOptions(pbcId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcDeveloperRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcDeveloperRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcId)}/code/commands/get-developer-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcDeveloperRepoMetrics(pbcId: string): GetPbcDeveloperRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcDeveloperRepoMetricsWithOptions(pbcId, headers, runtime);
}

model GetPbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcInstruction  
}

async function getPbcInstructionWithOptions(pbcVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/instructions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcInstruction(pbcVersionId: string): GetPbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcInstructionWithOptions(pbcVersionId, headers, runtime);
}

model GetPbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcInvokeReview  
}

async function getPbcInvokeReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcInvokeReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcInvokeReview(reviewId: string): GetPbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcInvokeReviewWithOptions(reviewId, headers, runtime);
}

model GetPbcRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcRepoMetricResult  
}

async function getPbcRepoMetricsWithOptions(pbcId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcId)}/code/commands/get-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcRepoMetrics(pbcId: string): GetPbcRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcRepoMetricsWithOptions(pbcId, headers, runtime);
}

model GetPbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcReview  
}

async function getPbcReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcReview(reviewId: string): GetPbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcReviewWithOptions(reviewId, headers, runtime);
}

model GetPbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcSchema  
}

async function getPbcSchemaWithOptions(pbcVersionId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcSchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcSchema(pbcVersionId: string): GetPbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcSchemaWithOptions(pbcVersionId, headers, runtime);
}

model GetPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcVersion  
}

async function getPbcVersionWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPbcVersion(id: string): GetPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcVersionWithOptions(id, headers, runtime);
}

model GetPdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpConfig  
}

async function getPdpConfigWithOptions(configId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/last/${OpenApiUtil.getEncodeParam(configId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPdpConfig(configId: string): GetPdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpConfigWithOptions(configId, headers, runtime);
}

model GetPdpHistoryConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpHistoryConfig  
}

async function getPdpHistoryConfigWithOptions(historyConfigId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpHistoryConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpHistoryConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/history/${OpenApiUtil.getEncodeParam(historyConfigId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPdpHistoryConfig(historyConfigId: string): GetPdpHistoryConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpHistoryConfigWithOptions(historyConfigId, headers, runtime);
}

model GetPdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpPbc  
}

async function getPdpPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPdpPbc(id: string): GetPdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpPbcWithOptions(id, headers, runtime);
}

model GetPdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpService  
}

async function getPdpServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPdpService(serviceId: string): GetPdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpServiceWithOptions(serviceId, headers, runtime);
}

model GetProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Product  
}

async function getProductWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetProductResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetProduct',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/products/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getProduct(id: string): GetProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getProductWithOptions(id, headers, runtime);
}

model GetRepoForkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReposFork  
}

async function getRepoForkWithOptions(forkId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoForkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoFork',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks/${OpenApiUtil.getEncodeParam(forkId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoFork(forkId: string): GetRepoForkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoForkWithOptions(forkId, headers, runtime);
}

model GetRepoMetricRequest {
  repoUrls?: [ string ](name='RepoUrls'),
}

model GetRepoMetricResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRepoMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoMetricResponseBody(name='body'),
}

async function getRepoMetricWithOptions(request: GetRepoMetricRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoMetricResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.repoUrls)) {
    query['RepoUrls'] = request.repoUrls;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoMetric',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/code-metric/repos-metric`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRepoMetric(request: GetRepoMetricRequest): GetRepoMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoMetricWithOptions(request, headers, runtime);
}

model GetRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Role  
}

async function getRoleWithOptions(roleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/role-id/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRole(roleId: string): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRoleWithOptions(roleId, headers, runtime);
}

model GetSlsLoginUrlRequest {
  env?: string(name='env', example='TEST'),
  serviceId?: string(name='serviceId', example='1'),
  sourceType?: string(name='sourceType', example='inner'),
}

model GetSlsLoginUrlResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='E5F6FE8A-B822-585F-949C-0803B4C4F09E'),
  slsLoginUrl?: string(name='slsLoginUrl', example='https://'),
}

model GetSlsLoginUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSlsLoginUrlResponseBody(name='body'),
}

async function getSlsLoginUrlWithOptions(request: GetSlsLoginUrlRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetSlsLoginUrlResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['sourceType'] = request.sourceType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSlsLoginUrl',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/pdp-log/commands/loginUrl`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSlsLoginUrl(request: GetSlsLoginUrlRequest): GetSlsLoginUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getSlsLoginUrlWithOptions(request, headers, runtime);
}

model GetStackDetailRequest {
  endTime?: string(name='endTime', example='2022-11-08 15:03:22'),
  env?: string(name='env', example='TEST'),
  rpcId?: string(name='rpcId', example='12'),
  serviceName?: string(name='serviceName', example='feishu-attendance-app'),
  startTime?: string(name='startTime', example='2022-12-06 10:24:44'),
}

model GetStackDetailResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='sdadawqewe'),
  result?: StackDetailResult(name='result'),
}

model GetStackDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetStackDetailResponseBody(name='body'),
}

async function getStackDetailWithOptions(traceId: string, request: GetStackDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetStackDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.rpcId)) {
    query['rpcId'] = request.rpcId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetStackDetail',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/traces/${OpenApiUtil.getEncodeParam(traceId)}/commonds/stack`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getStackDetail(traceId: string, request: GetStackDetailRequest): GetStackDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getStackDetailWithOptions(traceId, request, headers, runtime);
}

model GetTokenRequest {
  accountId?: string(name='accountId'),
  pbcId?: long(name='pbcId'),
}

model GetTokenResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTokenResult  
}

async function getTokenWithOptions(request: GetTokenRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTokenResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    body['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.pbcId)) {
    body['pbcId'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'GetToken',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs/token`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getToken(request: GetTokenRequest): GetTokenResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTokenWithOptions(request, headers, runtime);
}

model GetTraceDetailRequest {
  endTime?: string(name='endTime', example='2022-10-27 15:05:48'),
  env?: string(name='env', example='TEST'),
  startTime?: string(name='startTime', example='2022-10-28 14:36:53'),
}

model GetTraceDetailResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='sdadawqewe'),
  result?: TraceInfoDetailResult(name='result'),
}

model GetTraceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTraceDetailResponseBody(name='body'),
}

async function getTraceDetailWithOptions(traceId: string, request: GetTraceDetailRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetTraceDetailResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTraceDetail',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/traces/${OpenApiUtil.getEncodeParam(traceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTraceDetail(traceId: string, request: GetTraceDetailRequest): GetTraceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getTraceDetailWithOptions(traceId, request, headers, runtime);
}

model GrantRoleRequest {
  body?: RoleGrantCmd(name='body'),
}

model GrantRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function grantRoleWithOptions(roleId: string, request: GrantRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/commands/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function grantRole(roleId: string, request: GrantRoleRequest): GrantRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleWithOptions(roleId, request, headers, runtime);
}

model ListBucPermissionResourcePopRequest {
  action?: string(name='action', example='VIEW'),
  operatorId?: string(name='operatorId', example='1279329842'),
  operatorType?: string(name='operatorType', example='developer'),
  resourcePrefix?: string(name='resourcePrefix', example='neuron:catalog:company/1'),
}

model ListBucPermissionResourcePopResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='2C0CFF52-8A07-1B72-8037-C8EEE9A6435A'),
  resourceList?: [ string ](name='resourceList'),
}

model ListBucPermissionResourcePopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListBucPermissionResourcePopResponseBody(name='body'),
}

async function listBucPermissionResourcePopWithOptions(request: ListBucPermissionResourcePopRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBucPermissionResourcePopResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.operatorId)) {
    query['operatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorType)) {
    query['operatorType'] = request.operatorType;
  }
  if (!Util.isUnset(request.resourcePrefix)) {
    query['resourcePrefix'] = request.resourcePrefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBucPermissionResourcePop',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/permissions/commands/list-permission`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBucPermissionResourcePop(request: ListBucPermissionResourcePopRequest): ListBucPermissionResourcePopResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBucPermissionResourcePopWithOptions(request, headers, runtime);
}

model ListBucUserEnterpriseRequest {
  empId?: string(name='empId'),
}

model ListBucUserEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BucUserEnterpriseListResult  
}

async function listBucUserEnterpriseWithOptions(request: ListBucUserEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListBucUserEnterpriseResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.empId)) {
    query['empId'] = request.empId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListBucUserEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/enterprises`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listBucUserEnterprise(request: ListBucUserEnterpriseRequest): ListBucUserEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listBucUserEnterpriseWithOptions(request, headers, runtime);
}

model ListDependLibrarysRequest {
  applicant?: string(name='applicant'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListDependLibrarysResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryListResult(name='result'),
}

model ListDependLibrarysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDependLibrarysResponseBody(name='body'),
}

async function listDependLibrarysWithOptions(request: ListDependLibrarysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDependLibrarysResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDependLibrarys',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/commands/list-dependency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDependLibrarys(request: ListDependLibrarysRequest): ListDependLibrarysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDependLibrarysWithOptions(request, headers, runtime);
}

model ListDeploymentsRequest {
  env?: string(name='env'),
  excludeStatus?: [ string ](name='excludeStatus'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceId?: long(name='serviceId'),
  status?: [ string ](name='status'),
}

model ListDeploymentsShrinkRequest {
  env?: string(name='env'),
  excludeStatusShrink?: string(name='excludeStatus'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceId?: long(name='serviceId'),
  statusShrink?: string(name='status'),
}

model ListDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpDeploymentPageResult  
}

async function listDeploymentsWithOptions(tmpReq: ListDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeploymentsResponse {
  Util.validateModel(tmpReq);
  var request = new ListDeploymentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.excludeStatus)) {
    request.excludeStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.excludeStatus, 'excludeStatus', 'json');
  }
  if (!Util.isUnset(tmpReq.status)) {
    request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, 'status', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.excludeStatusShrink)) {
    query['excludeStatus'] = request.excludeStatusShrink;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.statusShrink)) {
    query['status'] = request.statusShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployments',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeployments(request: ListDeploymentsRequest): ListDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeploymentsWithOptions(request, headers, runtime);
}

model ListDeveloperEnterprisesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnterprisePageResult  
}

async function listDeveloperEnterprisesWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeveloperEnterprisesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDeveloperEnterprises',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/developers/${OpenApiUtil.getEncodeParam(accountId)}/commands/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeveloperEnterprises(accountId: string): ListDeveloperEnterprisesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeveloperEnterprisesWithOptions(accountId, headers, runtime);
}

model ListDeveloperPbcsRequest {
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
}

model ListDeveloperPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcListResult  
}

async function listDeveloperPbcsWithOptions(request: ListDeveloperPbcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeveloperPbcsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeveloperPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/commands/allow-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeveloperPbcs(request: ListDeveloperPbcsRequest): ListDeveloperPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeveloperPbcsWithOptions(request, headers, runtime);
}

model ListDeveloperRepoMetricSumRequest {
  repoUrls?: [ string ](name='RepoUrls'),
}

model ListDeveloperRepoMetricSumResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDeveloperRepoMetricSumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeveloperRepoMetricSumResponseBody(name='body'),
}

async function listDeveloperRepoMetricSumWithOptions(request: ListDeveloperRepoMetricSumRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeveloperRepoMetricSumResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.repoUrls)) {
    query['RepoUrls'] = request.repoUrls;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeveloperRepoMetricSum',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/code-metric/developer-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeveloperRepoMetricSum(request: ListDeveloperRepoMetricSumRequest): ListDeveloperRepoMetricSumResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeveloperRepoMetricSumWithOptions(request, headers, runtime);
}

model ListDevelopersRequest {
  accountIds?: [ string ](name='accountIds'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  roleId?: long(name='roleId'),
}

model ListDevelopersShrinkRequest {
  accountIdsShrink?: string(name='accountIds'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  roleId?: long(name='roleId'),
}

model ListDevelopersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeveloperPageResult  
}

async function listDevelopersWithOptions(tmpReq: ListDevelopersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDevelopersResponse {
  Util.validateModel(tmpReq);
  var request = new ListDevelopersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.accountIds)) {
    request.accountIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.accountIds, 'accountIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountIdsShrink)) {
    query['accountIds'] = request.accountIdsShrink;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleId)) {
    query['roleId'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDevelopers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevelopers(request: ListDevelopersRequest): ListDevelopersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDevelopersWithOptions(request, headers, runtime);
}

model ListDownstreamPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcUpDownstreamResult  
}

async function listDownstreamPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDownstreamPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDownstreamPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(id)}/commands/list-downstream`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDownstreamPbc(id: string): ListDownstreamPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDownstreamPbcWithOptions(id, headers, runtime);
}

model ListEnterprisesRequest {
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListEnterprisesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnterprisePageResult  
}

async function listEnterprisesWithOptions(request: ListEnterprisesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnterprisesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnterprises',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnterprises(request: ListEnterprisesRequest): ListEnterprisesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnterprisesWithOptions(request, headers, runtime);
}

model ListEnvInfosRequest {
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  region?: string(name='region'),
}

model ListEnvInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpListEnvInfoResult  
}

async function listEnvInfosWithOptions(request: ListEnvInfosRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnvInfosResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.region)) {
    query['region'] = request.region;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnvInfos',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/env/list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEnvInfos(request: ListEnvInfosRequest): ListEnvInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnvInfosWithOptions(request, headers, runtime);
}

model ListForkReviewsRequest {
  applicant?: string(name='applicant'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  reviewer?: string(name='reviewer'),
}

model ListForkReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ForkReviewListResult  
}

async function listForkReviewsWithOptions(request: ListForkReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListForkReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListForkReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listForkReviews(request: ListForkReviewsRequest): ListForkReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listForkReviewsWithOptions(request, headers, runtime);
}

model ListGrantedRolesRequest {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
}

model ListGrantedRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RolePageResult  
}

async function listGrantedRolesWithOptions(request: ListGrantedRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGrantedRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorizerId)) {
    query['authorizerId'] = request.authorizerId;
  }
  if (!Util.isUnset(request.authorizerType)) {
    query['authorizerType'] = request.authorizerType;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGrantedRoles',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/list-granted-roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGrantedRoles(request: ListGrantedRolesRequest): ListGrantedRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGrantedRolesWithOptions(request, headers, runtime);
}

model ListInvokePbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcListResult  
}

async function listInvokePbcsWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListInvokePbcsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListInvokePbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}/commands/invoke-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInvokePbcs(id: string): ListInvokePbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInvokePbcsWithOptions(id, headers, runtime);
}

model ListLibraryReviewsRequest {
  applicant?: string(name='applicant'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  reviewer?: string(name='reviewer'),
}

model ListLibraryReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryReviewListResult  
}

async function listLibraryReviewsWithOptions(request: ListLibraryReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLibraryReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLibraryReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLibraryReviews(request: ListLibraryReviewsRequest): ListLibraryReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLibraryReviewsWithOptions(request, headers, runtime);
}

model ListLibrarysRequest {
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  provider?: string(name='provider'),
}

model ListLibrarysResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryListResult(name='result'),
}

model ListLibrarysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLibrarysResponseBody(name='body'),
}

async function listLibrarysWithOptions(request: ListLibrarysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLibrarysResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.provider)) {
    query['provider'] = request.provider;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLibrarys',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLibrarys(request: ListLibrarysRequest): ListLibrarysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLibrarysWithOptions(request, headers, runtime);
}

model ListMarketsRequest {
  companyId?: long(name='companyId', example='41'),
}

model ListMarketsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MarketListResult  
}

async function listMarketsWithOptions(request: ListMarketsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMarketsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMarkets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMarkets(request: ListMarketsRequest): ListMarketsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMarketsWithOptions(request, headers, runtime);
}

model ListMetadataInfosRequest {
  env?: string(name='env'),
  namespaceId?: long(name='namespace_id'),
  namespaceName?: string(name='namespace_name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  orgId?: int32(name='org_id'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcId?: long(name='pbc_id'),
}

model ListMetadataInfosResponseBody = {
  requestId?: string(name='requestId'),
  result?: MetadataInfoListResult(name='result'),
}

model ListMetadataInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMetadataInfosResponseBody(name='body'),
}

async function listMetadataInfosWithOptions(request: ListMetadataInfosRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMetadataInfosResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['namespace_id'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['namespace_name'] = request.namespaceName;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.orgId)) {
    query['org_id'] = request.orgId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbc_id'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetadataInfos',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMetadataInfos(request: ListMetadataInfosRequest): ListMetadataInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetadataInfosWithOptions(request, headers, runtime);
}

model ListMicroServiceRequest {
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcId?: long(name='pbcId'),
  serviceIds?: string(name='serviceIds'),
}

model ListMicroServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqMsgPageResult  
}

async function listMicroServiceWithOptions(env: string, request: ListMicroServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMicroServiceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }
  if (!Util.isUnset(request.serviceIds)) {
    query['serviceIds'] = request.serviceIds;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMicroService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/group/env/${OpenApiUtil.getEncodeParam(env)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMicroService(env: string, request: ListMicroServiceRequest): ListMicroServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMicroServiceWithOptions(env, request, headers, runtime);
}

model ListMonitorContactGroupsRequest {
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListMonitorContactGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContactPageResult  
}

async function listMonitorContactGroupsWithOptions(request: ListMonitorContactGroupsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorContactGroupsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorContactGroups',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorContactGroups(request: ListMonitorContactGroupsRequest): ListMonitorContactGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorContactGroupsWithOptions(request, headers, runtime);
}

model ListMonitorContactsRequest {
  enterpriseId?: long(name='enterpriseId', example='4'),
  groupId?: long(name='groupId', example='1445'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy', example='id'),
  orderDirection?: string(name='orderDirection', example='DESC'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
}

model ListMonitorContactsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContactPageResult  
}

async function listMonitorContactsWithOptions(request: ListMonitorContactsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorContactsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.groupId)) {
    query['groupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorContacts',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorContacts(request: ListMonitorContactsRequest): ListMonitorContactsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorContactsWithOptions(request, headers, runtime);
}

model ListMonitorNotifyObjectsRequest {
  enterpriseId?: long(name='enterpriseId', example='2'),
  name?: string(name='name'),
  type?: int32(name='type', example='1'),
  webhookType?: string(name='webhookType', example='DINGDING'),
}

model ListMonitorNotifyObjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorNotifyObjectResult  
}

async function listMonitorNotifyObjectsWithOptions(request: ListMonitorNotifyObjectsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorNotifyObjectsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }
  if (!Util.isUnset(request.webhookType)) {
    query['webhookType'] = request.webhookType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorNotifyObjects',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/listMonitorNotifyObjects`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorNotifyObjects(request: ListMonitorNotifyObjectsRequest): ListMonitorNotifyObjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorNotifyObjectsWithOptions(request, headers, runtime);
}

model ListMonitorTasksRequest {
  alertName?: string(name='alertName', example='alert'),
  env?: string(name='env', example='TEST'),
  orderBy?: string(name='orderBy', example='id'),
  orderDirection?: string(name='orderDirection', example='DESC'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  pbcId?: string(name='pbcId', example='2'),
  serviceId?: string(name='serviceId', description='serviceId', example='1'),
  type?: string(name='type', example='SLS'),
}

model ListMonitorTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorNotifyAlertPageResult  
}

async function listMonitorTasksWithOptions(request: ListMonitorTasksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorTasksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.alertName)) {
    query['alertName'] = request.alertName;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorTasks',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/listMonitorTasks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorTasks(request: ListMonitorTasksRequest): ListMonitorTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorTasksWithOptions(request, headers, runtime);
}

model ListMonitorWebhooksRequest {
  enterpriseId?: long(name='enterpriseId', example='2'),
  name?: string(name='name', example='mask_detect'),
  orderBy?: string(name='orderBy', example='id'),
  orderDirection?: string(name='orderDirection', example='DESC'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  webhookType?: string(name='webhookType', example='DINGDING'),
}

model ListMonitorWebhooksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorWebhookPageResult  
}

async function listMonitorWebhooksWithOptions(request: ListMonitorWebhooksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMonitorWebhooksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.webhookType)) {
    query['webhookType'] = request.webhookType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorWebhooks',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/webhook`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorWebhooks(request: ListMonitorWebhooksRequest): ListMonitorWebhooksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMonitorWebhooksWithOptions(request, headers, runtime);
}

model ListMqGroupMsgsRequest {
  endTime?: string(name='endTime'),
  msgId?: string(name='msgId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  startTime?: string(name='startTime'),
}

model ListMqGroupMsgsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqMsgPageResult  
}

async function listMqGroupMsgsWithOptions(groupId: string, request: ListMqGroupMsgsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMqGroupMsgsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.msgId)) {
    query['msgId'] = request.msgId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMqGroupMsgs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/group/${OpenApiUtil.getEncodeParam(groupId)}/commands/msgs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMqGroupMsgs(groupId: string, request: ListMqGroupMsgsRequest): ListMqGroupMsgsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMqGroupMsgsWithOptions(groupId, request, headers, runtime);
}

model ListMqTopicMsgsRequest {
  endTime?: string(name='endTime'),
  msgId?: string(name='msgId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  startTime?: string(name='startTime'),
}

model ListMqTopicMsgsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqMsgPageResult  
}

async function listMqTopicMsgsWithOptions(topicId: string, request: ListMqTopicMsgsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMqTopicMsgsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.msgId)) {
    query['msgId'] = request.msgId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMqTopicMsgs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/topic/${OpenApiUtil.getEncodeParam(topicId)}/commands/msgs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMqTopicMsgs(topicId: string, request: ListMqTopicMsgsRequest): ListMqTopicMsgsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMqTopicMsgsWithOptions(topicId, request, headers, runtime);
}

model ListMqTopicSubsRequest {
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceName?: string(name='serviceName'),
}

model ListMqTopicSubsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqTopicSubsPageResult  
}

async function listMqTopicSubsWithOptions(topicId: string, request: ListMqTopicSubsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMqTopicSubsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMqTopicSubs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/topic/${OpenApiUtil.getEncodeParam(topicId)}/commands/subs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMqTopicSubs(topicId: string, request: ListMqTopicSubsRequest): ListMqTopicSubsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMqTopicSubsWithOptions(topicId, request, headers, runtime);
}

model ListMqTopicsRequest {
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  topicName?: string(name='topicName'),
}

model ListMqTopicsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MqTopicPageResult  
}

async function listMqTopicsWithOptions(env: string, pbcId: string, request: ListMqTopicsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMqTopicsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.topicName)) {
    query['topicName'] = request.topicName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMqTopics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/mq/topic/env/${OpenApiUtil.getEncodeParam(env)}/pbcId/${OpenApiUtil.getEncodeParam(pbcId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMqTopics(env: string, pbcId: string, request: ListMqTopicsRequest): ListMqTopicsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMqTopicsWithOptions(env, pbcId, request, headers, runtime);
}

model ListPbcInvokeReviewsRequest {
  applicant?: string(name='applicant'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderDirection?: int32(name='orderDirection'),
  orderby?: int32(name='orderby'),
  reviewer?: string(name='reviewer'),
}

model ListPbcInvokeReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcListResult  
}

async function listPbcInvokeReviewsWithOptions(request: ListPbcInvokeReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcInvokeReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.orderby)) {
    query['orderby'] = request.orderby;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcInvokeReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcInvokeReviews(request: ListPbcInvokeReviewsRequest): ListPbcInvokeReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcInvokeReviewsWithOptions(request, headers, runtime);
}

model ListPbcInvokesRequest {
  applicant?: string(name='applicant', example='223352752411587433'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  pbcId?: long(name='pbcId'),
}

model ListPbcInvokesResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='sdadawqewe'),
  result?: PbcListResult(name='result'),
}

model ListPbcInvokesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcInvokesResponseBody(name='body'),
}

async function listPbcInvokesWithOptions(request: ListPbcInvokesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcInvokesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcInvokes',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invokes`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcInvokes(request: ListPbcInvokesRequest): ListPbcInvokesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcInvokesWithOptions(request, headers, runtime);
}

model ListPbcReviewsRequest {
  applicant?: string(name='applicant'),
  marketId?: long(name='marketId'),
  orderBy?: int32(name='orderBy'),
  orderDirection?: int32(name='orderDirection'),
  pageNumber?: string(name='pageNumber'),
  pageSize?: string(name='pageSize'),
  reviewer?: string(name='reviewer'),
}

model ListPbcReviewsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcReviewListResult(name='result'),
}

model ListPbcReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcReviewsResponseBody(name='body'),
}

async function listPbcReviewsWithOptions(request: ListPbcReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcReviews(request: ListPbcReviewsRequest): ListPbcReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcReviewsWithOptions(request, headers, runtime);
}

model ListPbcSubscribeRequest {
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListPbcSubscribeResponseBody = {
  pbcListResult?: PbcListResult(name='pbcListResult'),
  requestId?: string(name='requestId'),
}

model ListPbcSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcSubscribeResponseBody(name='body'),
}

async function listPbcSubscribeWithOptions(request: ListPbcSubscribeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcSubscribeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcSubscribe',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/commands/list-subscribe`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcSubscribe(request: ListPbcSubscribeRequest): ListPbcSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcSubscribeWithOptions(request, headers, runtime);
}

model ListPbcVersionBuildRequest {
  accountId?: string(name='accountId'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListPbcVersionBuildResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcVersionListResult  
}

async function listPbcVersionBuildWithOptions(request: ListPbcVersionBuildRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcVersionBuildResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcVersionBuild',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/commands/list-build`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcVersionBuild(request: ListPbcVersionBuildRequest): ListPbcVersionBuildResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcVersionBuildWithOptions(request, headers, runtime);
}

model ListPbcVersionNumbersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcVersionListResult  
}

async function listPbcVersionNumbersWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcVersionNumbersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPbcVersionNumbers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}/commands/listPbcVersionNumbers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcVersionNumbers(id: string): ListPbcVersionNumbersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcVersionNumbersWithOptions(id, headers, runtime);
}

model ListPbcsRequest {
  companyId?: long(name='companyId'),
  developerId?: string(name='developerId'),
  marketId?: long(name='marketId', example='1'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model ListPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcListResult  
}

async function listPbcsWithOptions(request: ListPbcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.developerId)) {
    query['developerId'] = request.developerId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPbcs(request: ListPbcsRequest): ListPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcsWithOptions(request, headers, runtime);
}

model ListPdpConfigsRequest {
  env?: string(name='env'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceId?: long(name='serviceId'),
  type?: string(name='type'),
}

model ListPdpConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpConfigPageResult  
}

async function listPdpConfigsWithOptions(request: ListPdpConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpConfigs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpConfigs(request: ListPdpConfigsRequest): ListPdpConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpConfigsWithOptions(request, headers, runtime);
}

model ListPdpHistoryConfigsRequest {
  configId?: long(name='configId'),
  env?: string(name='env'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceId?: long(name='serviceId'),
  type?: string(name='type'),
}

model ListPdpHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpHistoryConfigPageResult  
}

async function listPdpHistoryConfigsWithOptions(request: ListPdpHistoryConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpHistoryConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configId)) {
    query['configId'] = request.configId;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpHistoryConfigs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpHistoryConfigs(request: ListPdpHistoryConfigsRequest): ListPdpHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpHistoryConfigsWithOptions(request, headers, runtime);
}

model ListPdpImageRequest {
  env?: string(name='env', example='TEST'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  serviceId?: long(name='serviceId'),
}

model ListPdpImageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpImagePageResult  
}

async function listPdpImageWithOptions(request: ListPdpImageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpImageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpImage',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/instance/images`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpImage(request: ListPdpImageRequest): ListPdpImageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpImageWithOptions(request, headers, runtime);
}

model ListPdpLogsRequest {
  env?: string(name='env'),
  from?: long(name='from'),
  ip?: string(name='ip'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  query?: string(name='query'),
  serviceId?: long(name='service_id'),
  sourceType?: string(name='source_type'),
  to?: long(name='to'),
}

model ListPdpLogsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfigPageResult(name='result'),
}

model ListPdpLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpLogsResponseBody(name='body'),
}

async function listPdpLogsWithOptions(request: ListPdpLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['source_type'] = request.sourceType;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpLogs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/pdp-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpLogs(request: ListPdpLogsRequest): ListPdpLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpLogsWithOptions(request, headers, runtime);
}

model ListPdpPbcsRequest {
  companyId?: long(name='companyId'),
  developerId?: string(name='developerId'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcIds?: [ long ](name='pbcIds'),
}

model ListPdpPbcsShrinkRequest {
  companyId?: long(name='companyId'),
  developerId?: string(name='developerId'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcIdsShrink?: string(name='pbcIds'),
}

model ListPdpPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpPbcListResult  
}

async function listPdpPbcsWithOptions(tmpReq: ListPdpPbcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpPbcsResponse {
  Util.validateModel(tmpReq);
  var request = new ListPdpPbcsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pbcIds)) {
    request.pbcIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pbcIds, 'pbcIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.developerId)) {
    query['developerId'] = request.developerId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcIdsShrink)) {
    query['pbcIds'] = request.pbcIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpPbcs(request: ListPdpPbcsRequest): ListPdpPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpPbcsWithOptions(request, headers, runtime);
}

model ListPdpServicesRequest {
  alias?: string(name='alias'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcId?: long(name='pbcId'),
  pdpServiceIds?: [ long ](name='pdpServiceIds'),
}

model ListPdpServicesShrinkRequest {
  alias?: string(name='alias'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  pbcId?: long(name='pbcId'),
  pdpServiceIdsShrink?: string(name='pdpServiceIds'),
}

model ListPdpServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpServicePageResult  
}

async function listPdpServicesWithOptions(tmpReq: ListPdpServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListPdpServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pdpServiceIds)) {
    request.pdpServiceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pdpServiceIds, 'pdpServiceIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.alias)) {
    query['alias'] = request.alias;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }
  if (!Util.isUnset(request.pdpServiceIdsShrink)) {
    query['pdpServiceIds'] = request.pdpServiceIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpServices',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPdpServices(request: ListPdpServicesRequest): ListPdpServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpServicesWithOptions(request, headers, runtime);
}

model ListPermissionResourceRequest {
  action?: string(name='action'),
  enterpriseId?: long(name='enterpriseId'),
  operatorId?: string(name='operatorId'),
  operatorType?: string(name='operatorType'),
  resourcePrefix?: string(name='resourcePrefix'),
}

model ListPermissionResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PermissionAllowResource  
}

async function listPermissionResourceWithOptions(request: ListPermissionResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.operatorId)) {
    query['operatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorType)) {
    query['operatorType'] = request.operatorType;
  }
  if (!Util.isUnset(request.resourcePrefix)) {
    query['resourcePrefix'] = request.resourcePrefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionResource',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/permissions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissionResource(request: ListPermissionResourceRequest): ListPermissionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionResourceWithOptions(request, headers, runtime);
}

model ListPermissionResourcePopRequest {
  action?: string(name='action'),
  operatorId?: string(name='operatorId'),
  operatorType?: string(name='operatorType'),
  resourcePrefix?: string(name='resourcePrefix'),
}

model ListPermissionResourcePopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PermissionAllowResource  
}

async function listPermissionResourcePopWithOptions(request: ListPermissionResourcePopRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionResourcePopResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.operatorId)) {
    query['operatorId'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorType)) {
    query['operatorType'] = request.operatorType;
  }
  if (!Util.isUnset(request.resourcePrefix)) {
    query['resourcePrefix'] = request.resourcePrefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionResourcePop',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/permissions/pop`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPermissionResourcePop(request: ListPermissionResourcePopRequest): ListPermissionResourcePopResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionResourcePopWithOptions(request, headers, runtime);
}

model ListPrivilegeByRoleRequest {
  accountId?: string(name='accountId'),
}

model ListPrivilegeByRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PrivilegePageResult  
}

async function listPrivilegeByRoleWithOptions(roleId: string, request: ListPrivilegeByRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrivilegeByRoleResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['accountId'] = request.accountId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPrivilegeByRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/privileges`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPrivilegeByRole(roleId: string, request: ListPrivilegeByRoleRequest): ListPrivilegeByRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrivilegeByRoleWithOptions(roleId, request, headers, runtime);
}

model ListProductsRequest {
  companyId?: long(name='companyId', example='41'),
  keyword?: string(name='keyword', description='A short description of struct', example='yunmall'),
  orderBy?: string(name='orderBy', example='gmtCreate'),
  orderDirection?: string(name='orderDirection', example='DESC'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
}

model ListProductsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ProductListResult  
}

async function listProductsWithOptions(request: ListProductsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListProductsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListProducts',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/products`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listProducts(request: ListProductsRequest): ListProductsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listProductsWithOptions(request, headers, runtime);
}

model ListRepoForksRequest {
  pbcId?: long(name='pbcId'),
}

model ListRepoForksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcRepoForkListResult  
}

async function listRepoForksWithOptions(request: ListRepoForksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepoForksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pbcId)) {
    query['pbcId'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoForks',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRepoForks(request: ListRepoForksRequest): ListRepoForksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepoForksWithOptions(request, headers, runtime);
}

model ListReviewersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReviewerListResult  
}

async function listReviewersWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListReviewersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListReviewers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/commands/listReviewers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listReviewers(): ListReviewersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReviewersWithOptions(headers, runtime);
}

model ListRolesRequest {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  platform?: string(name='platform'),
  roleIds?: [ long ](name='roleIds'),
  roleType?: string(name='roleType'),
}

model ListRolesShrinkRequest {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  platform?: string(name='platform'),
  roleIdsShrink?: string(name='roleIds'),
  roleType?: string(name='roleType'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RolePageResult  
}

async function listRolesWithOptions(tmpReq: ListRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(tmpReq);
  var request = new ListRolesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roleIds)) {
    request.roleIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roleIds, 'roleIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorizerId)) {
    query['authorizerId'] = request.authorizerId;
  }
  if (!Util.isUnset(request.authorizerType)) {
    query['authorizerType'] = request.authorizerType;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterpriseId'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }
  if (!Util.isUnset(request.roleIdsShrink)) {
    query['roleIds'] = request.roleIdsShrink;
  }
  if (!Util.isUnset(request.roleType)) {
    query['roleType'] = request.roleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRolesWithOptions(request, headers, runtime);
}

model ListRuntimeTokensRequest {
  enterpriseId?: long(name='enterprise_id', example='2'),
  env?: string(name='env', example='TEST'),
  orderBy?: string(name='order_by', example='id'),
  orderDirection?: string(name='order_direction', example='DESC'),
  pageNumber?: string(name='page_number', example='1'),
  pageSize?: string(name='page_size', example='100'),
  pbcId?: long(name='pbc_id', example='46'),
  serviceId?: long(name='service_id', example='82'),
}

model ListRuntimeTokensResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpListTokenResult  
}

async function listRuntimeTokensWithOptions(request: ListRuntimeTokensRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRuntimeTokensResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterprise_id'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbc_id'] = request.pbcId;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRuntimeTokens',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/env/tokens`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRuntimeTokens(request: ListRuntimeTokensRequest): ListRuntimeTokensResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRuntimeTokensWithOptions(request, headers, runtime);
}

model ListServerInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ServerInstanceResult  
}

async function listServerInstancesWithOptions(env: string, serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListServerInstancesResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListServerInstances',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/services/${OpenApiUtil.getEncodeParam(serviceId)}/env/${OpenApiUtil.getEncodeParam(env)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServerInstances(env: string, serviceId: string): ListServerInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServerInstancesWithOptions(env, serviceId, headers, runtime);
}

model ListServiceMetricsRequest {
  endTime?: string(name='endTime'),
  env?: string(name='env'),
  groupId?: long(name='groupId'),
  intervalInSec?: int32(name='intervalInSec'),
  ip?: string(name='ip'),
  measures?: string(name='measures'),
  serviceId?: long(name='serviceId'),
  startTime?: string(name='startTime'),
  topicId?: long(name='topicId'),
  type?: string(name='type'),
}

model ListServiceMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorMetricResult  
}

async function listServiceMetricsWithOptions(request: ListServiceMetricsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListServiceMetricsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.groupId)) {
    query['groupId'] = request.groupId;
  }
  if (!Util.isUnset(request.intervalInSec)) {
    query['intervalInSec'] = request.intervalInSec;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.measures)) {
    query['measures'] = request.measures;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }
  if (!Util.isUnset(request.topicId)) {
    query['topicId'] = request.topicId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListServiceMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listServiceMetrics(request: ListServiceMetricsRequest): ListServiceMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listServiceMetricsWithOptions(request, headers, runtime);
}

model ListSettledsRequest {
  accountId?: string(name='accountId', example='273803534812230281'),
  applicant?: string(name='applicant', example='223352752411587433'),
  enterpriseName?: string(name='enterpriseName'),
  status?: string(name='status', example='3'),
}

model ListSettledsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SettledPageResult  
}

async function listSettledsWithOptions(request: ListSettledsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListSettledsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.enterpriseName)) {
    query['enterpriseName'] = request.enterpriseName;
  }
  if (!Util.isUnset(request.status)) {
    query['status'] = request.status;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSettleds',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/settleds`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSettleds(request: ListSettledsRequest): ListSettledsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSettledsWithOptions(request, headers, runtime);
}

model ListSubscribePbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Pbc
  ](name='result'),
}

model ListSubscribePbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscribePbcsResponseBody(name='body'),
}

async function listSubscribePbcsWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubscribePbcsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSubscribePbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/subscribe-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSubscribePbcs(pbcName: string): ListSubscribePbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubscribePbcsWithOptions(pbcName, headers, runtime);
}

model ListUpstreamPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcUpDownstreamResult  
}

async function listUpstreamPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListUpstreamPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-/versions/${OpenApiUtil.getEncodeParam(id)}/commands/list-upstream`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUpstreamPbc(id: string): ListUpstreamPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUpstreamPbcWithOptions(id, headers, runtime);
}

model ListWatchAssetsRequest {
  accountId?: string(name='accountId'),
  assetType?: string(name='assetType'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
  upshelfAssetId?: long(name='upshelfAssetId'),
}

model ListWatchAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
DTO
]  
}

async function listWatchAssetsWithOptions(request: ListWatchAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWatchAssetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.assetType)) {
    query['assetType'] = request.assetType;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.upshelfAssetId)) {
    query['upshelfAssetId'] = request.upshelfAssetId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWatchAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watchs/commands/list-watch`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWatchAssets(request: ListWatchAssetsRequest): ListWatchAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWatchAssetsWithOptions(request, headers, runtime);
}

model RegisterBucUserRequest {
  body?: RegisterBucUserCmd(name='body'),
}

model RegisterBucUserResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='D372D265-81C4-5B84-8827-596F0CF768FF'),
  result?: BucUser(name='result'),
}

model RegisterBucUserResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RegisterBucUserResponseBody(name='body'),
}

async function registerBucUserWithOptions(request: RegisterBucUserRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RegisterBucUserResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RegisterBucUser',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/bucs/logins/register`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function registerBucUser(request: RegisterBucUserRequest): RegisterBucUserResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return registerBucUserWithOptions(request, headers, runtime);
}

model RemoveAssetWatchRequest {
  assetType?: string(name='assetType'),
  companyId?: long(name='companyId'),
}

model RemoveAssetWatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function removeAssetWatchWithOptions(assetId: string, request: RemoveAssetWatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveAssetWatchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.assetType)) {
    query['assetType'] = request.assetType;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAssetWatch',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watchs/${OpenApiUtil.getEncodeParam(assetId)}/commands/remove-watch`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeAssetWatch(assetId: string, request: RemoveAssetWatchRequest): RemoveAssetWatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAssetWatchWithOptions(assetId, request, headers, runtime);
}

model RemoveDependLibraryRequest {
  companyId?: long(name='companyId'),
}

model RemoveDependLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function removeDependLibraryWithOptions(id: string, request: RemoveDependLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveDependLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveDependLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}/commands/remove-dependency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeDependLibrary(id: string, request: RemoveDependLibraryRequest): RemoveDependLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeDependLibraryWithOptions(id, request, headers, runtime);
}

model RevertPdpServiceRequest {
  body?: DeploymentRevertCmd(name='body'),
}

model RevertPdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpServiceDeployment  
}

async function revertPdpServiceWithOptions(request: RevertPdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevertPdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RevertPdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/commands/revert`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revertPdpService(request: RevertPdpServiceRequest): RevertPdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revertPdpServiceWithOptions(request, headers, runtime);
}

model RevokeLibraryReviewRequest {
  body?: RevokeLibraryReviewCmd(name='body'),
}

model RevokeLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function revokeLibraryReviewWithOptions(request: RevokeLibraryReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeLibraryReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews/commands/revoke-review`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeLibraryReview(request: RevokeLibraryReviewRequest): RevokeLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeLibraryReviewWithOptions(request, headers, runtime);
}

model RevokePbcReviewRequest {
  body?: RevokeReviewCmd(name='body'),
}

model RevokePbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function revokePbcReviewWithOptions(request: RevokePbcReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokePbcReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RevokePbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/commands/revoke-review`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokePbcReview(request: RevokePbcReviewRequest): RevokePbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokePbcReviewWithOptions(request, headers, runtime);
}

model RevokeRoleRequest {
  body?: RoleRevokeCmd(name='body'),
}

model RevokeRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function revokeRoleWithOptions(roleId: string, request: RevokeRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/commands/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

async function revokeRole(roleId: string, request: RevokeRoleRequest): RevokeRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRoleWithOptions(roleId, request, headers, runtime);
}

model RollbackPdpServiceRequest {
  body?: DeploymentRollbackCmd(name='body'),
}

model RollbackPdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpServiceDeployment  
}

async function rollbackPdpServiceWithOptions(request: RollbackPdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackPdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RollbackPdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/commands/rollback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rollbackPdpService(request: RollbackPdpServiceRequest): RollbackPdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackPdpServiceWithOptions(request, headers, runtime);
}

model SearchAssetsRequest {
  assetIndustrys?: [ string ](name='assetIndustrys'),
  assetName?: string(name='assetName'),
  assetTypes?: [ string ](name='assetTypes'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model SearchAssetsShrinkRequest {
  assetIndustrysShrink?: string(name='assetIndustrys'),
  assetName?: string(name='assetName'),
  assetTypesShrink?: string(name='assetTypes'),
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='orderBy'),
  orderDirection?: string(name='orderDirection'),
  pageNumber?: int32(name='pageNumber'),
  pageSize?: int32(name='pageSize'),
}

model SearchAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: [
DTO
]  
}

async function searchAssetsWithOptions(tmpReq: SearchAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAssetsResponse {
  Util.validateModel(tmpReq);
  var request = new SearchAssetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.assetIndustrys)) {
    request.assetIndustrysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.assetIndustrys, 'assetIndustrys', 'json');
  }
  if (!Util.isUnset(tmpReq.assetTypes)) {
    request.assetTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.assetTypes, 'assetTypes', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.assetIndustrysShrink)) {
    query['assetIndustrys'] = request.assetIndustrysShrink;
  }
  if (!Util.isUnset(request.assetName)) {
    query['assetName'] = request.assetName;
  }
  if (!Util.isUnset(request.assetTypesShrink)) {
    query['assetTypes'] = request.assetTypesShrink;
  }
  if (!Util.isUnset(request.companyId)) {
    query['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets/commands/search-asset`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchAssets(request: SearchAssetsRequest): SearchAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAssetsWithOptions(request, headers, runtime);
}

model SearchPbcAssetsRequest {
  industry?: string(name='industry'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  type?: string(name='type'),
}

model SearchPbcAssetsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcListResult(name='result'),
}

model SearchPbcAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchPbcAssetsResponseBody(name='body'),
}

async function searchPbcAssetsWithOptions(request: SearchPbcAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchPbcAssetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.industry)) {
    query['industry'] = request.industry;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchPbcAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets/commands/search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchPbcAssets(request: SearchPbcAssetsRequest): SearchPbcAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchPbcAssetsWithOptions(request, headers, runtime);
}

model SearchTracesByPageRequest {
  endTime?: string(name='endTime', example='2022-11-08 15:03:21'),
  env?: string(name='env', example='TEST'),
  minDuration?: long(name='minDuration', example='100'),
  operationName?: string(name='operationName', example='/demo/queryNotExistDB/11'),
  orderBy?: string(name='orderBy', example='id'),
  orderDirection?: string(name='orderDirection', example='DESC'),
  pageNumber?: int32(name='pageNumber', example='1'),
  pageSize?: int32(name='pageSize', example='10'),
  serviceId?: long(name='serviceId'),
  serviceName?: string(name='serviceName', example='dev-sellercenter'),
  startTime?: string(name='startTime', example='2022-10-31 11:10:22'),
}

model SearchTracesByPageResponseBody = {
  requestId?: string(name='requestId', description='Id of the request', example='sdadawqewe'),
  traceInfos?: [
    TraceInfo
  ](name='traceInfos'),
}

model SearchTracesByPageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchTracesByPageResponseBody(name='body'),
}

async function searchTracesByPageWithOptions(request: SearchTracesByPageRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchTracesByPageResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    query['endTime'] = request.endTime;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.minDuration)) {
    query['minDuration'] = request.minDuration;
  }
  if (!Util.isUnset(request.operationName)) {
    query['operationName'] = request.operationName;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['orderBy'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['orderDirection'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['pageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['pageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['serviceId'] = request.serviceId;
  }
  if (!Util.isUnset(request.serviceName)) {
    query['serviceName'] = request.serviceName;
  }
  if (!Util.isUnset(request.startTime)) {
    query['startTime'] = request.startTime;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchTracesByPage',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/traces`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchTracesByPage(request: SearchTracesByPageRequest): SearchTracesByPageResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchTracesByPageWithOptions(request, headers, runtime);
}

model SendTTSVerifyLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SendTTSVerifyLinkResult  
}

async function sendTTSVerifyLinkWithOptions(contactId: string, headers: map[string]string, runtime: Util.RuntimeOptions): SendTTSVerifyLinkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'SendTTSVerifyLink',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact/commands/phoneVerify/${OpenApiUtil.getEncodeParam(contactId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function sendTTSVerifyLink(contactId: string): SendTTSVerifyLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return sendTTSVerifyLinkWithOptions(contactId, headers, runtime);
}

model SubscribePbcRequest {
  body?: PbcSubscribe(name='body'),
}

model SubscribePbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Pbc
  ](name='result'),
}

model SubscribePbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubscribePbcResponseBody(name='body'),
}

async function subscribePbcWithOptions(pbcName: string, request: SubscribePbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SubscribePbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'SubscribePbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/subscribe`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function subscribePbc(pbcName: string, request: SubscribePbcRequest): SubscribePbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return subscribePbcWithOptions(pbcName, request, headers, runtime);
}

model TransferEnterpriseRequest {
  body?: EnterpriseTransferCmd(name='body'),
}

model TransferEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Enterprise  
}

async function transferEnterpriseWithOptions(enterpriseId: string, request: TransferEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TransferEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}/commands/transfer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transferEnterprise(enterpriseId: string, request: TransferEnterpriseRequest): TransferEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferEnterpriseWithOptions(enterpriseId, request, headers, runtime);
}

model TriggerDeploymentRequest {
  body?: DeploymentTriggerCmd(name='body'),
}

model TriggerDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpServiceDeployment  
}

async function triggerDeploymentWithOptions(request: TriggerDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function triggerDeployment(request: TriggerDeploymentRequest): TriggerDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerDeploymentWithOptions(request, headers, runtime);
}

model UpShelfLibraryRequest {
  marketId?: long(name='marketId'),
}

model UpShelfLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function upShelfLibraryWithOptions(id: string, request: UpShelfLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpShelfLibraryResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpShelfLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(id)}/commands/up-shelf-library`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upShelfLibrary(id: string, request: UpShelfLibraryRequest): UpShelfLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upShelfLibraryWithOptions(id, request, headers, runtime);
}

model UpShelfPbcVersionRequest {
  marketId?: long(name='marketId'),
}

model UpShelfPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CatalogCommonResult  
}

async function upShelfPbcVersionWithOptions(id: string, request: UpShelfPbcVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpShelfPbcVersionResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpShelfPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(id)}/commands/upShelf`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upShelfPbcVersion(id: string, request: UpShelfPbcVersionRequest): UpShelfPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upShelfPbcVersionWithOptions(id, request, headers, runtime);
}

model UpdateDeveloperRequest {
  body?: DeveloperInfoUpdateCmd(name='body'),
}

model UpdateDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function updateDeveloperWithOptions(accountId: string, request: UpdateDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeveloper(accountId: string, request: UpdateDeveloperRequest): UpdateDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeveloperWithOptions(accountId, request, headers, runtime);
}

model UpdateEnterpriseRequest {
  body?: EnterpriseInfoUpdateCmd(name='body'),
}

model UpdateEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Enterprise  
}

async function updateEnterpriseWithOptions(enterpriseId: string, request: UpdateEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEnterprise(enterpriseId: string, request: UpdateEnterpriseRequest): UpdateEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnterpriseWithOptions(enterpriseId, request, headers, runtime);
}

model UpdateLibraryRequest {
  body?: LibraryUpdateCmd(name='body'),
}

model UpdateLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Library  
}

async function updateLibraryWithOptions(request: UpdateLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibraryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLibrary(request: UpdateLibraryRequest): UpdateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibraryWithOptions(request, headers, runtime);
}

model UpdateLibraryInstructionRequest {
  body?: LibraryInstruction(name='body'),
}

model UpdateLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LibraryInstruction  
}

async function updateLibraryInstructionWithOptions(libraryId: string, request: UpdateLibraryInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibraryInstructionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/instructions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLibraryInstruction(libraryId: string, request: UpdateLibraryInstructionRequest): UpdateLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibraryInstructionWithOptions(libraryId, request, headers, runtime);
}

model UpdateLibrarySchemaRequest {
  body?: LibrarySchemaUpdateCmd(name='body'),
}

model UpdateLibrarySchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibrarySchema(name='result'),
}

model UpdateLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLibrarySchemaResponseBody(name='body'),
}

async function updateLibrarySchemaWithOptions(libraryId: string, request: UpdateLibrarySchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibrarySchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryId)}/schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateLibrarySchema(libraryId: string, request: UpdateLibrarySchemaRequest): UpdateLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibrarySchemaWithOptions(libraryId, request, headers, runtime);
}

model UpdateMonitorArmsAlertRequest {
  body?: MonitorArmsAlertUpdateCmd(name='body'),
}

model UpdateMonitorArmsAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorArmsAlert  
}

async function updateMonitorArmsAlertWithOptions(request: UpdateMonitorArmsAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorArmsAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorArmsAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/updateMonitorArmsAlert`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorArmsAlert(request: UpdateMonitorArmsAlertRequest): UpdateMonitorArmsAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorArmsAlertWithOptions(request, headers, runtime);
}

model UpdateMonitorContactRequest {
  body?: MonitorContactUpdateCmd(name='body'),
}

model UpdateMonitorContactResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContact  
}

async function updateMonitorContactWithOptions(request: UpdateMonitorContactRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorContactResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorContact',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/contact`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorContact(request: UpdateMonitorContactRequest): UpdateMonitorContactResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorContactWithOptions(request, headers, runtime);
}

model UpdateMonitorContactGroupRequest {
  body?: MonitorContactGroupUpdateCmd(name='body'),
}

model UpdateMonitorContactGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorContactGroup  
}

async function updateMonitorContactGroupWithOptions(request: UpdateMonitorContactGroupRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorContactGroupResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorContactGroup',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/group`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorContactGroup(request: UpdateMonitorContactGroupRequest): UpdateMonitorContactGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorContactGroupWithOptions(request, headers, runtime);
}

model UpdateMonitorMqAlertRequest {
  body?: MonitorMqAlertUpdateCmd(name='body'),
}

model UpdateMonitorMqAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorMqAlert  
}

async function updateMonitorMqAlertWithOptions(request: UpdateMonitorMqAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorMqAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorMqAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/updateMonitorMqAlert`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorMqAlert(request: UpdateMonitorMqAlertRequest): UpdateMonitorMqAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorMqAlertWithOptions(request, headers, runtime);
}

model UpdateMonitorSlsAlertRequest {
  body?: MonitorSlsAlertUpdateCmd(name='body'),
}

model UpdateMonitorSlsAlertResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorSlsAlert  
}

async function updateMonitorSlsAlertWithOptions(request: UpdateMonitorSlsAlertRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorSlsAlertResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorSlsAlert',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/alert/commands/updateMonitorSlsAlert`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorSlsAlert(request: UpdateMonitorSlsAlertRequest): UpdateMonitorSlsAlertResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorSlsAlertWithOptions(request, headers, runtime);
}

model UpdateMonitorWebhookRequest {
  body?: MonitorWebhookUpdateCmd(name='body'),
}

model UpdateMonitorWebhookResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MonitorWebhook  
}

async function updateMonitorWebhookWithOptions(request: UpdateMonitorWebhookRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateMonitorWebhookResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateMonitorWebhook',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-monitor/v1/monitor/webhook`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateMonitorWebhook(request: UpdateMonitorWebhookRequest): UpdateMonitorWebhookResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateMonitorWebhookWithOptions(request, headers, runtime);
}

model UpdatePbcApiSchemaRequest {
  body?: PbcApiSchemaUpdateCmd(name='body'),
}

model UpdatePbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcApiSchema  
}

async function updatePbcApiSchemaWithOptions(pbcVersionId: string, request: UpdatePbcApiSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcApiSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/api-schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePbcApiSchema(pbcVersionId: string, request: UpdatePbcApiSchemaRequest): UpdatePbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcApiSchemaWithOptions(pbcVersionId, request, headers, runtime);
}

model UpdatePbcInstructionRequest {
  body?: PbcInstructionUpdateCmd(name='body'),
}

model UpdatePbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcInstruction  
}

async function updatePbcInstructionWithOptions(pbcVersionId: string, request: UpdatePbcInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcInstructionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/instructions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePbcInstruction(pbcVersionId: string, request: UpdatePbcInstructionRequest): UpdatePbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcInstructionWithOptions(pbcVersionId, request, headers, runtime);
}

model UpdatePbcSchemaRequest {
  body?: PbcSchema(name='body'),
}

model UpdatePbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcSchema  
}

async function updatePbcSchemaWithOptions(pbcVersionId: string, request: UpdatePbcSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(pbcVersionId)}/schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePbcSchema(pbcVersionId: string, request: UpdatePbcSchemaRequest): UpdatePbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcSchemaWithOptions(pbcVersionId, request, headers, runtime);
}

model UpdatePbcVersionRequest {
  body?: PbcVersionCmd(name='body'),
}

model UpdatePbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PbcVersion  
}

async function updatePbcVersionWithOptions(id: string, request: UpdatePbcVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-versions/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePbcVersion(id: string, request: UpdatePbcVersionRequest): UpdatePbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcVersionWithOptions(id, request, headers, runtime);
}

model UpdatePdpConfigRequest {
  body?: PdpConfigUpdateCmd(name='body'),
}

model UpdatePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpConfig  
}

async function updatePdpConfigWithOptions(request: UpdatePdpConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePdpConfig(request: UpdatePdpConfigRequest): UpdatePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpConfigWithOptions(request, headers, runtime);
}

model UpdatePdpPbcRequest {
  body?: PdpPbcUpdateCmd(name='body'),
}

model UpdatePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpPbc  
}

async function updatePdpPbcWithOptions(request: UpdatePdpPbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpPbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePdpPbc(request: UpdatePdpPbcRequest): UpdatePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpPbcWithOptions(request, headers, runtime);
}

model UpdatePdpServiceRequest {
  body?: PdpServiceUpdateCmd(name='body'),
}

model UpdatePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PdpService  
}

async function updatePdpServiceWithOptions(request: UpdatePdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePdpService(request: UpdatePdpServiceRequest): UpdatePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpServiceWithOptions(request, headers, runtime);
}

model UpdateProductRequest {
  body?: ProductUpdateCmd(name='body'),
}

model UpdateProductResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Product  
}

async function updateProductWithOptions(request: UpdateProductRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateProductResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProduct',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/products`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProduct(request: UpdateProductRequest): UpdateProductResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateProductWithOptions(request, headers, runtime);
}

model UpdateRoleRequest {
  body?: RoleInfoUpdateCmd(name='body'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Role  
}

async function updateRoleWithOptions(roleId: string, request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/role-id/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateRole(roleId: string, request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(roleId, request, headers, runtime);
}

model UpdateSettledRequest {
  body?: SettledUpdateCmd(name='body'),
}

model UpdateSettledResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Settled  
}

async function updateSettledWithOptions(id: string, request: UpdateSettledRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateSettledResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSettled',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/settleds/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSettled(id: string, request: UpdateSettledRequest): UpdateSettledResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateSettledWithOptions(id, request, headers, runtime);
}

