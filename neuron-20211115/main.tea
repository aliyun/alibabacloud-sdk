/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-1 = 'neuron.aliyuncs.com',
    ap-northeast-2-pop = 'neuron.aliyuncs.com',
    ap-south-1 = 'neuron.aliyuncs.com',
    ap-southeast-1 = 'neuron.aliyuncs.com',
    ap-southeast-2 = 'neuron.aliyuncs.com',
    ap-southeast-3 = 'neuron.aliyuncs.com',
    ap-southeast-5 = 'neuron.aliyuncs.com',
    cn-beijing = 'neuron.aliyuncs.com',
    cn-beijing-finance-1 = 'neuron.aliyuncs.com',
    cn-beijing-finance-pop = 'neuron.aliyuncs.com',
    cn-beijing-gov-1 = 'neuron.aliyuncs.com',
    cn-beijing-nu16-b01 = 'neuron.aliyuncs.com',
    cn-chengdu = 'neuron.aliyuncs.com',
    cn-edge-1 = 'neuron.aliyuncs.com',
    cn-fujian = 'neuron.aliyuncs.com',
    cn-haidian-cm12-c01 = 'neuron.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'neuron.aliyuncs.com',
    cn-hangzhou-finance = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'neuron.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'neuron.aliyuncs.com',
    cn-hangzhou-test-306 = 'neuron.aliyuncs.com',
    cn-hongkong = 'neuron.aliyuncs.com',
    cn-hongkong-finance-pop = 'neuron.aliyuncs.com',
    cn-huhehaote = 'neuron.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'neuron.aliyuncs.com',
    cn-north-2-gov-1 = 'neuron.aliyuncs.com',
    cn-qingdao = 'neuron.aliyuncs.com',
    cn-qingdao-nebula = 'neuron.aliyuncs.com',
    cn-shanghai = 'neuron.aliyuncs.com',
    cn-shanghai-et15-b01 = 'neuron.aliyuncs.com',
    cn-shanghai-et2-b01 = 'neuron.aliyuncs.com',
    cn-shanghai-finance-1 = 'neuron.aliyuncs.com',
    cn-shanghai-inner = 'neuron.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'neuron.aliyuncs.com',
    cn-shenzhen = 'neuron.aliyuncs.com',
    cn-shenzhen-finance-1 = 'neuron.aliyuncs.com',
    cn-shenzhen-inner = 'neuron.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'neuron.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'neuron.aliyuncs.com',
    cn-wuhan = 'neuron.aliyuncs.com',
    cn-wulanchabu = 'neuron.aliyuncs.com',
    cn-yushanfang = 'neuron.aliyuncs.com',
    cn-zhangbei = 'neuron.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'neuron.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'neuron.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'neuron.aliyuncs.com',
    eu-central-1 = 'neuron.aliyuncs.com',
    eu-west-1 = 'neuron.aliyuncs.com',
    eu-west-1-oxs = 'neuron.aliyuncs.com',
    me-east-1 = 'neuron.aliyuncs.com',
    rus-west-1-pop = 'neuron.aliyuncs.com',
    us-east-1 = 'neuron.aliyuncs.com',
    us-west-1 = 'neuron.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('neuron', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model AuthorizationResource {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
}

model BatchGrantRolesCmd {
  accountId?: string(name='accountId'),
  roleIds?: [ long ](name='roleIds'),
}

model CatalogCommonResult {
  result?: boolean(name='result'),
}

model CatalogOperatorRoleCreateCmd {
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  marketType?: string(name='marketType'),
}

model CatalogPbcRoleCreateCmd {
  companyId?: long(name='companyId'),
  marketId?: long(name='marketId'),
  marketResource?: string(name='marketResource'),
  name?: string(name='name'),
  pbcResource?: string(name='pbcResource'),
}

model CompanyRoleCreateCmd {
  companyId?: long(name='companyId'),
  name?: string(name='name'),
}

model CreatePbcInvokeReviewResult {
  pbcInvokeReviewId?: long(name='pbcInvokeReviewId'),
}

model CreatePrivilegeCmd {
  accountId?: string(name='accountId'),
  roleId?: long(name='roleId'),
  strategyItems?: [
    StrategyItem
  ](name='strategyItems'),
  strategys?: string(name='strategys'),
}

model CreatePrivilegePopCmd {
  accountId?: string(name='accountId'),
  actions?: string(name='actions'),
  resource?: string(name='resource'),
  roleId?: long(name='roleId'),
}

model DTO {
  id?: long(name='id'),
}

model DeployConfigInfo {
  cpu?: int32(name='cpu'),
  deploymentId?: long(name='deploymentId'),
  deploymentType?: string(name='deploymentType'),
  env?: string(name='env'),
  finish?: boolean(name='finish'),
  instanceCount?: int32(name='instanceCount'),
  memory?: int32(name='memory'),
  serviceId?: long(name='serviceId'),
  times?: int32(name='times'),
}

model DeployDetailInfo {
  accountId?: string(name='accountId'),
  accountName?: string(name='accountName'),
  changeOrderId?: string(name='changeOrderId'),
  context?: string(name='context'),
  cpu?: int32(name='cpu'),
  deploymentType?: string(name='deploymentType'),
  description?: string(name='description'),
  edasId?: string(name='edasId'),
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  id?: long(name='id'),
  imageId?: string(name='imageId'),
  imageTag?: string(name='imageTag'),
  instanceCount?: int32(name='instanceCount'),
  memory?: int32(name='memory'),
  message?: string(name='message'),
  orgType?: string(name='orgType'),
  pbcId?: long(name='pbcId'),
  pbcName?: string(name='pbcName'),
  pipelineInfos?: [
    DeployPipelineInfo
  ](name='pipelineInfos'),
  repositoryId?: string(name='repositoryId'),
  rollbackStatus?: string(name='rollbackStatus'),
  serviceId?: long(name='serviceId'),
  serviceName?: string(name='serviceName'),
  status?: string(name='status'),
  times?: int32(name='times'),
  type?: string(name='type'),
}

model DeployInstanceInfo {
  ip?: string(name='ip'),
  status?: string(name='status'),
}

model DeployPipelineInfo {
  deployInstanceInfos?: [
    DeployInstanceInfo
  ](name='deployInstanceInfos'),
  id?: string(name='id'),
  name?: string(name='name'),
}

model DeploymentContinueCmd {
  deploymentId?: long(name='deploymentId'),
}

model DeploymentRollbackCmd {
  deploymentId?: long(name='deploymentId'),
}

model DeploymentTriggerCmd {
  accountId?: string(name='accountId'),
  cpu?: int32(name='cpu'),
  description?: string(name='description'),
  env?: string(name='env'),
  imageTag?: string(name='imageTag'),
  instanceCount?: int32(name='instanceCount'),
  memory?: int32(name='memory'),
  serviceId?: long(name='serviceId'),
  times?: int32(name='times'),
  type?: string(name='type'),
}

model Developer {
  accountId?: string(name='accountId'),
  codeupAccountId?: string(name='codeupAccountId'),
  email?: string(name='email'),
  enterpriseId?: long(name='enterpriseId'),
  name?: string(name='name'),
  phone?: string(name='phone'),
}

model DeveloperInfoUpdateCmd {
  accountId?: string(name='accountId'),
  email?: string(name='email'),
  name?: string(name='name'),
  phone?: string(name='phone'),
}

model DeveloperPageResult {
  data?: [
    Developer
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model Enterprise {
  accountId?: string(name='accountId'),
  description?: string(name='description'),
  id?: long(name='id'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model EnterpriseInfoUpdateCmd {
  description?: string(name='description'),
  id?: long(name='id'),
  name?: string(name='name'),
}

model EnterprisePageResult {
  data?: [
    Enterprise
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model EnterpriseTransferCmd {
  accountId?: string(name='accountId'),
  id?: long(name='id'),
}

model FeedbackReviewCmd {
  feedbackPbcAPI?: string(name='feedbackPbcAPI'),
  feedbackPbcInstruction?: string(name='feedbackPbcInstruction'),
  feedbackPbcSchema?: string(name='feedbackPbcSchema'),
  feedbackSecurity?: string(name='feedbackSecurity'),
  feedbackServiceAvailable?: string(name='feedbackServiceAvailable'),
  reviewId?: long(name='reviewId'),
  status?: string(name='status'),
}

model ForkReview {
  applicant?: string(name='applicant'),
  forkId?: long(name='forkId'),
  gitGroup?: string(name='gitGroup'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  repoUrls?: [ string ](name='repoUrls'),
  reviewer?: string(name='reviewer'),
  reviewerId?: string(name='reviewerId'),
  status?: string(name='status'),
  usage?: string(name='usage'),
}

model ForkReviewAuditCmd {
  approve?: boolean(name='approve'),
}

model ForkReviewCreateCmd {
  gitGroup?: string(name='gitGroup'),
  pbcName?: string(name='pbcName'),
  usage?: string(name='usage'),
}

model ForkReviewListResult {
  forkReviews?: [
    ForkReview
  ](name='forkReviews'),
  total?: int32(name='total'),
}

model GrantedRoleListQuery {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  name?: string(name='name'),
}

model Library {
  artifactId?: string(name='artifactId'),
  assetType?: string(name='assetType'),
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  dependCount?: int32(name='dependCount'),
  description?: string(name='description'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  industry?: string(name='industry'),
  isWatched?: boolean(name='isWatched'),
  name?: string(name='name'),
  provider?: string(name='provider'),
  providerName?: string(name='providerName'),
  repoUrl?: string(name='repoUrl'),
  status?: string(name='status'),
  stepStatus?: string(name='stepStatus'),
  watchCount?: int32(name='watchCount'),
}

model LibraryDeveloperRepoMetricResult {
  developerRepoMetrics?: [
    ReposDeveloperGroupMetric
  ](name='developerRepoMetrics'),
}

model LibraryInstruction {
  document?: string(name='document'),
  id?: long(name='id'),
  libraryName?: string(name='libraryName'),
  libraryVersion?: string(name='libraryVersion'),
}

model LibraryReview {
  applicant?: string(name='applicant'),
  artificatId?: string(name='artificatId'),
  feedbackLibraryInstruction?: string(name='feedbackLibraryInstruction'),
  feedbackLibrarySchema?: string(name='feedbackLibrarySchema'),
  gmtCreate?: string(name='gmtCreate'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  libraryName?: string(name='libraryName'),
  libraryUrl?: string(name='libraryUrl'),
  marketId?: string(name='marketId'),
  remainTime?: string(name='remainTime'),
  reviewerId?: string(name='reviewerId'),
  status?: string(name='status'),
}

model LibrarySchema {
  artifactId?: string(name='artifactId'),
  description?: string(name='description'),
  gitGroup?: string(name='gitGroup'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  industry?: string(name='industry'),
  name?: string(name='name'),
  provider?: Provider(name='provider'),
  version?: string(name='version'),
}

model Market {
  id?: long(name='id'),
  name?: string(name='name'),
}

model MetadataInfo {
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  id?: long(name='id'),
  instanceId?: long(name='instanceId'),
  namespaceId?: long(name='namespaceId'),
  namespaceName?: string(name='namespaceName'),
  orgId?: int32(name='orgId'),
}

model MetadataInfoListResult {
  metadataInfos?: [
    MetadataInfo
  ](name='metadataInfos'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model Pbc {
  alias?: string(name='alias'),
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  description?: string(name='description'),
  developerId?: string(name='developerId'),
  forkCount?: int32(name='forkCount'),
  id?: long(name='id'),
  industry?: string(name='industry'),
  name?: string(name='name'),
  quoteCount?: int32(name='quoteCount'),
  type?: string(name='type'),
}

model PbcApiSchema {
  apiSchema?: string(name='apiSchema'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
}

model PbcDeveloperRepoMetricResult {
  developerRepoMetrics?: [
    ReposDeveloperGroupMetric
  ](name='developerRepoMetrics'),
}

model PbcInstruction {
  document?: string(name='document'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
}

model PbcInvokeReview {
  applicant?: string(name='applicant'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  invokeId?: long(name='invokeId'),
  invokePbcName?: string(name='invokePbcName'),
  pbcName?: string(name='pbcName'),
  reviewer?: string(name='reviewer'),
  reviewerId?: string(name='reviewerId'),
  status?: string(name='status'),
  usage?: string(name='usage'),
}

model PbcListResult {
  data?: [
    Pbc
  ](name='data'),
  total?: int32(name='total'),
}

model PbcRelationItem {
  company?: string(name='company'),
  developer?: string(name='developer'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
  summary?: string(name='summary'),
}

model PbcRepoForkListResult {
  reposForks?: [
    ReposFork
  ](name='reposForks'),
}

model PbcRepoMetricResult {
  repoMetrics?: [
    RepoMetric
  ](name='repoMetrics'),
}

model PbcReview {
  developerId?: long(name='developerId'),
  feedbackPbcApi?: string(name='feedbackPbcApi'),
  feedbackPbcInstruction?: string(name='feedbackPbcInstruction'),
  feedbackPbcSchema?: string(name='feedbackPbcSchema'),
  feedbackSecurity?: string(name='feedbackSecurity'),
  feedbackServiceAvailable?: string(name='feedbackServiceAvailable'),
  id?: long(name='id'),
  marketId?: long(name='marketId'),
  pbcName?: string(name='pbcName'),
  pbcUrl?: string(name='pbcUrl'),
  pbcVersion?: string(name='pbcVersion'),
  remainTime?: string(name='remainTime'),
  reviewerId?: long(name='reviewerId'),
  status?: string(name='status'),
}

model PbcReviewCreateCmd {
  marketId?: long(name='marketId'),
  pbcName?: string(name='pbcName'),
  pbcUrl?: string(name='pbcUrl'),
  pbcVersion?: string(name='pbcVersion'),
  reviewerId?: long(name='reviewerId'),
}

model PbcReviewListResult {
  data?: [
    PbcReview
  ](name='data'),
  total?: int32(name='total'),
}

model PbcSchema {
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
  schema?: string(name='schema'),
}

model PbcSubscribe {
  developerId?: string(name='developerId'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  purpose?: string(name='purpose'),
  subPbcName?: string(name='subPbcName'),
}

model PbcUpDownstreamResult {
  pbcItems?: [
    PbcRelationItem
  ](name='pbcItems'),
}

model PbcVersion {
  companyId?: long(name='companyId'),
  companyName?: string(name='companyName'),
  developerId?: long(name='developerId'),
  id?: long(name='id'),
  name?: string(name='name'),
  reviewId?: long(name='reviewId'),
  status?: string(name='status'),
  stepStatus?: string(name='stepStatus'),
  version?: string(name='version'),
  visibilityLevel?: string(name='visibilityLevel'),
}

model PbcVersionCmd {
  apiSchema?: string(name='apiSchema'),
  comapnayId?: long(name='comapnayId'),
  developerId?: long(name='developerId'),
  document?: string(name='document'),
  name?: string(name='name'),
  schema?: string(name='schema'),
  version?: string(name='version'),
}

model PbcVersionListResult {
  data?: [
    PbcVersion
  ](name='data'),
  total?: int32(name='total'),
}

model PdpConfig {
  accountId?: string(name='accountId'),
  accountName?: string(name='accountName'),
  askId?: string(name='askId'),
  context?: string(name='context'),
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  id?: long(name='id'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId'),
  serviceId?: long(name='serviceId'),
  type?: string(name='type'),
}

model PdpConfigPageResult {
  data?: [
    PdpConfig
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpConfigUpdateCmd {
  accountId?: string(name='accountId'),
  context?: string(name='context'),
  id?: long(name='id'),
}

model PdpDeploymentPageResult {
  data?: [
    PdpServiceDeployment
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpHistoryConfig {
  accountId?: string(name='accountId'),
  accountName?: string(name='accountName'),
  askId?: string(name='askId'),
  configId?: long(name='configId'),
  context?: string(name='context'),
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId'),
  serviceId?: long(name='serviceId'),
  type?: string(name='type'),
}

model PdpHistoryConfigPageResult {
  data?: [
    PdpHistoryConfig
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpImage {
  imageId?: string(name='imageId'),
  imageTag?: string(name='imageTag'),
}

model PdpImagePageResult {
  data?: [
    PdpImage
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpListLogResult {
  logs?: [
    PdpLog
  ](name='logs'),
}

model PdpLog {
  content?: string(name='content'),
  ip?: string(name='ip'),
}

model PdpMetadataRoleCreateCmd {
  companyId?: long(name='companyId'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId'),
}

model PdpPbc {
  alias?: string(name='alias'),
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  description?: string(name='description'),
  developerId?: string(name='developerId'),
  gitGroup?: string(name='gitGroup'),
  gitGroupInfo?: string(name='gitGroupInfo'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  name?: string(name='name'),
  type?: string(name='type'),
}

model PdpPbcListResult {
  pdpPbcs?: [
    PdpPbc
  ](name='pdpPbcs'),
  requestId?: string(name='requestId'),
  total?: int32(name='total'),
}

model PdpPbcManagerRoleCreateCmd {
  companyId?: long(name='companyId'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId'),
}

model PdpPbcUpdateCmd {
  alias?: string(name='alias'),
  description?: string(name='description'),
  name?: string(name='name'),
}

model PdpService {
  accountId?: string(name='accountId'),
  alias?: string(name='alias'),
  codeBranch?: string(name='codeBranch'),
  description?: string(name='description'),
  enterpriseId?: long(name='enterpriseId'),
  extraInfo?: string(name='extraInfo'),
  gitRepo?: string(name='gitRepo'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  id?: long(name='id'),
  jumpUrl?: string(name='jumpUrl'),
  name?: string(name='name'),
  orgType?: string(name='orgType'),
  pbcId?: long(name='pbcId'),
  status?: string(name='status'),
  type?: string(name='type'),
}

model PdpServiceDeployment {
  accountId?: string(name='accountId'),
  changeOrderId?: string(name='changeOrderId'),
  context?: string(name='context'),
  cpu?: int32(name='cpu'),
  deploymentType?: string(name='deploymentType'),
  description?: string(name='description'),
  edasId?: string(name='edasId'),
  enterpriseId?: long(name='enterpriseId'),
  env?: string(name='env'),
  gmtCreate?: string(name='gmtCreate'),
  gmtModified?: string(name='gmtModified'),
  id?: long(name='id'),
  imageId?: string(name='imageId'),
  imageTag?: string(name='imageTag'),
  instanceCount?: int32(name='instanceCount'),
  memory?: int32(name='memory'),
  message?: string(name='message'),
  orgType?: string(name='orgType'),
  pbcId?: long(name='pbcId'),
  pbcName?: string(name='pbcName'),
  repositoryId?: string(name='repositoryId'),
  rollbackStatus?: string(name='rollbackStatus'),
  serviceId?: long(name='serviceId'),
  serviceName?: string(name='serviceName'),
  status?: string(name='status'),
  times?: int32(name='times'),
  type?: string(name='type'),
}

model PdpServicePageResult {
  data?: [
    PdpService
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model PdpServiceRoleCreateCmd {
  companyId?: long(name='companyId'),
  name?: string(name='name'),
  pbcId?: long(name='pbcId'),
  serviceId?: long(name='serviceId'),
}

model PdpServiceUpdateCmd {
  alias?: string(name='alias'),
  codeBranch?: string(name='codeBranch'),
  description?: string(name='description'),
  extraInfo?: string(name='extraInfo'),
  gitRepo?: string(name='gitRepo'),
  id?: long(name='id'),
  jumpUrl?: string(name='jumpUrl'),
}

model PermissionAllowResource {
  resourceList?: [ string ](name='resourceList'),
}

model PermissionCheckCmd {
  action?: string(name='action'),
  operatorId?: string(name='operatorId'),
  operatorType?: string(name='operatorType'),
  resource?: string(name='resource'),
}

model PermissionResult {
  allow?: boolean(name='allow'),
}

model Privilege {
  accountId?: string(name='accountId'),
  actions?: string(name='actions'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  resource?: string(name='resource'),
  roleId?: long(name='roleId'),
}

model PrivilegePageResult {
  data?: [
    Privilege
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model Provider {
  company?: string(name='company'),
  companyId?: long(name='companyId'),
  contact?: string(name='contact'),
  email?: string(name='email'),
  team?: string(name='team'),
  teamId?: long(name='teamId'),
}

model RepoItem {
  codeLines?: long(name='codeLines'),
  gitProjectUrl?: string(name='gitProjectUrl'),
  owner?: string(name='owner'),
  repoShortUrl?: string(name='repoShortUrl'),
  repoUrl?: string(name='repoUrl'),
  summary?: string(name='summary'),
}

model RepoMetric {
  codeLines?: long(name='codeLines'),
  commitCnt?: long(name='commitCnt'),
  developerCnt?: long(name='developerCnt'),
  refreshDate?: string(name='refreshDate'),
  repoShortUrl?: string(name='repoShortUrl'),
  repoUrl?: string(name='repoUrl'),
}

model ReposDeveloperGroupMetric {
  addLines?: long(name='addLines'),
  commentLines?: long(name='commentLines'),
  commitCnt?: long(name='commitCnt'),
  delLines?: long(name='delLines'),
  modLines?: long(name='modLines'),
  showName?: string(name='showName'),
  workNo?: string(name='workNo'),
}

model ReposFork {
  gitGroup?: string(name='gitGroup'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  isOrigin?: boolean(name='isOrigin'),
  pbcRepoItems?: [
    RepoItem
  ](name='pbcRepoItems'),
  usage?: string(name='usage'),
}

model ReposForkCreateCmd {
  gitGroup?: string(name='gitGroup'),
  pbcName?: string(name='pbcName'),
  usage?: string(name='usage'),
}

model RevokeReviewCmd {
  name?: string(name='name'),
  version?: string(name='version'),
}

model Role {
  accountId?: string(name='accountId'),
  enterpriseId?: long(name='enterpriseId'),
  gmtCreate?: string(name='gmtCreate'),
  id?: long(name='id'),
  name?: string(name='name'),
  platform?: string(name='platform'),
  type?: string(name='type'),
}

model RoleGrantCmd {
  accountId?: string(name='accountId'),
  authorizationResourceList?: [
    AuthorizationResource
  ](name='authorizationResourceList'),
  roleId?: long(name='roleId'),
}

model RoleInfoUpdateCmd {
  id?: long(name='id'),
  name?: string(name='name'),
}

model RolePageResult {
  data?: [
    Role
  ](name='data'),
  requestId?: string(name='requestId'),
  total?: long(name='total'),
}

model RoleRevokeCmd {
  authorizerId?: string(name='authorizerId'),
  authorizerType?: string(name='authorizerType'),
  roleId?: long(name='roleId'),
}

model StrategyItem {
  action?: string(name='action'),
  resource?: string(name='resource'),
}

model AuditForkReviewRequest {
  body?: ForkReviewAuditCmd(name='body'),
}

model AuditForkReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: string(name='result'),
}

model AuditForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuditForkReviewResponseBody(name='body'),
}

async function auditForkReview(reviewId: string, request: AuditForkReviewRequest): AuditForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return auditForkReviewWithOptions(reviewId, request, headers, runtime);
}

async function auditForkReviewWithOptions(reviewId: string, request: AuditForkReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuditForkReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'AuditForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/audit`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model AuditPbcInvokeReviewRequest {
  approve?: boolean(name='approve'),
}

model AuditPbcInvokeReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model AuditPbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AuditPbcInvokeReviewResponseBody(name='body'),
}

async function auditPbcInvokeReview(reviewId: string, request: AuditPbcInvokeReviewRequest): AuditPbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return auditPbcInvokeReviewWithOptions(reviewId, request, headers, runtime);
}

async function auditPbcInvokeReviewWithOptions(reviewId: string, request: AuditPbcInvokeReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): AuditPbcInvokeReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.approve)) {
    body['approve'] = request.approve;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AuditPbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/audit`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model BatchGrantRolesToDeveloperRequest {
  body?: BatchGrantRolesCmd(name='body'),
}

model BatchGrantRolesToDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function batchGrantRolesToDeveloper(request: BatchGrantRolesToDeveloperRequest): BatchGrantRolesToDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return batchGrantRolesToDeveloperWithOptions(request, headers, runtime);
}

async function batchGrantRolesToDeveloperWithOptions(request: BatchGrantRolesToDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): BatchGrantRolesToDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'BatchGrantRolesToDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/batch-grant-roles`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model CheckDeveloperRoleRequest {
  accountId?: string(name='accountId'),
  roleName?: string(name='roleName'),
}

model CheckDeveloperRoleResponseBody = {
  requestId?: string(name='requestId'),
  result?: PermissionResult(name='result'),
}

model CheckDeveloperRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDeveloperRoleResponseBody(name='body'),
}

async function checkDeveloperRole(request: CheckDeveloperRoleRequest): CheckDeveloperRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkDeveloperRoleWithOptions(request, headers, runtime);
}

async function checkDeveloperRoleWithOptions(request: CheckDeveloperRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CheckDeveloperRoleResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    body['accountId'] = request.accountId;
  }
  if (!Util.isUnset(request.roleName)) {
    body['roleName'] = request.roleName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CheckDeveloperRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/check-role`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CheckServiceReachableResponseBody = {
  requestId?: string(name='requestId'),
  result?: string(name='result'),
}

model CheckServiceReachableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceReachableResponseBody(name='body'),
}

async function checkServiceReachable(): CheckServiceReachableResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return checkServiceReachableWithOptions(headers, runtime);
}

async function checkServiceReachableWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): CheckServiceReachableResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceReachable',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/checkpreload.htm`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CompleteRegisterLibraryRequest {
  dependIntegral?: int32(name='dependIntegral'),
}

model CompleteRegisterLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model CompleteRegisterLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteRegisterLibraryResponseBody(name='body'),
}

async function completeRegisterLibrary(libraryName: string, request: CompleteRegisterLibraryRequest): CompleteRegisterLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeRegisterLibraryWithOptions(libraryName, request, headers, runtime);
}

async function completeRegisterLibraryWithOptions(libraryName: string, request: CompleteRegisterLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteRegisterLibraryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dependIntegral)) {
    body['dependIntegral'] = request.dependIntegral;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CompleteRegisterLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/commands/complete-register`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CompleteRegistrationPbcVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
}

model CompleteRegistrationPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CompleteRegistrationPbcVersionResponseBody(name='body'),
}

async function completeRegistrationPbcVersion(pbcName: string, version: string): CompleteRegistrationPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return completeRegistrationPbcVersionWithOptions(pbcName, version, headers, runtime);
}

async function completeRegistrationPbcVersionWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): CompleteRegistrationPbcVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CompleteRegistrationPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/commands/complete-register`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ContinueDeploymentRequest {
  body?: DeploymentContinueCmd(name='body'),
}

model ContinueDeploymentResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpServiceDeployment(name='result'),
}

model ContinueDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ContinueDeploymentResponseBody(name='body'),
}

async function continueDeployment(request: ContinueDeploymentRequest): ContinueDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return continueDeploymentWithOptions(request, headers, runtime);
}

async function continueDeploymentWithOptions(request: ContinueDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ContinueDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'ContinueDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/commands/continue`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateAssetWatchRequest {
}

model CreateAssetWatchResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model CreateAssetWatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAssetWatchResponseBody(name='body'),
}

async function createAssetWatch(request: CreateAssetWatchRequest): CreateAssetWatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createAssetWatchWithOptions(request, headers, runtime);
}

async function createAssetWatchWithOptions(request: CreateAssetWatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateAssetWatchResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreateAssetWatch',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watch`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateDeveloperRequest {
  body?: Developer(name='body'),
}

model CreateDeveloperResponseBody = {
  requestId?: string(name='requestId'),
  result?: Developer(name='result'),
}

model CreateDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeveloperResponseBody(name='body'),
}

async function createDeveloper(request: CreateDeveloperRequest): CreateDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createDeveloperWithOptions(request, headers, runtime);
}

async function createDeveloperWithOptions(request: CreateDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateEnterpriseRequest {
  body?: Enterprise(name='body'),
}

model CreateEnterpriseResponseBody = {
  requestId?: string(name='requestId'),
  result?: Enterprise(name='result'),
}

model CreateEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEnterpriseResponseBody(name='body'),
}

async function createEnterprise(request: CreateEnterpriseRequest): CreateEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createEnterpriseWithOptions(request, headers, runtime);
}

async function createEnterpriseWithOptions(request: CreateEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateForkReviewRequest {
  body?: ForkReviewCreateCmd(name='body'),
}

model CreateForkReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: long(name='result'),
}

model CreateForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateForkReviewResponseBody(name='body'),
}

async function createForkReview(request: CreateForkReviewRequest): CreateForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createForkReviewWithOptions(request, headers, runtime);
}

async function createForkReviewWithOptions(request: CreateForkReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateForkReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLibraryRequest {
  artifactId?: string(name='artifactId'),
  companyId?: string(name='companyId'),
  description?: string(name='description'),
  groupId?: string(name='groupId'),
  name?: string(name='name'),
  repoUrl?: string(name='repoUrl'),
}

model CreateLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: Library(name='result'),
}

model CreateLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLibraryResponseBody(name='body'),
}

async function createLibrary(request: CreateLibraryRequest): CreateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryWithOptions(request, headers, runtime);
}

async function createLibraryWithOptions(request: CreateLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.artifactId)) {
    body['artifactId'] = request.artifactId;
  }
  if (!Util.isUnset(request.companyId)) {
    body['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['groupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.repoUrl)) {
    body['repoUrl'] = request.repoUrl;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLibraryInstructionRequest {
  document?: string(name='document'),
  id?: int32(name='id'),
  libraryName?: string(name='libraryName'),
  libraryVersion?: string(name='libraryVersion'),
}

model CreateLibraryInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryInstruction(name='result'),
}

model CreateLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLibraryInstructionResponseBody(name='body'),
}

async function createLibraryInstruction(libraryName: string, request: CreateLibraryInstructionRequest): CreateLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryInstructionWithOptions(libraryName, request, headers, runtime);
}

async function createLibraryInstructionWithOptions(libraryName: string, request: CreateLibraryInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryInstructionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.document)) {
    body['document'] = request.document;
  }
  if (!Util.isUnset(request.id)) {
    body['id'] = request.id;
  }
  if (!Util.isUnset(request.libraryName)) {
    body['libraryName'] = request.libraryName;
  }
  if (!Util.isUnset(request.libraryVersion)) {
    body['libraryVersion'] = request.libraryVersion;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/instructions`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLibraryReviewRequest {
  libraryName?: string(name='libraryName'),
  libraryUrl?: string(name='libraryUrl'),
  libraryVersion?: string(name='libraryVersion'),
  marketId?: string(name='marketId'),
  reviewerId?: string(name='reviewerId'),
}

model CreateLibraryReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryReview(name='result'),
}

model CreateLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLibraryReviewResponseBody(name='body'),
}

async function createLibraryReview(request: CreateLibraryReviewRequest): CreateLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibraryReviewWithOptions(request, headers, runtime);
}

async function createLibraryReviewWithOptions(request: CreateLibraryReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibraryReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.libraryName)) {
    body['libraryName'] = request.libraryName;
  }
  if (!Util.isUnset(request.libraryUrl)) {
    body['libraryUrl'] = request.libraryUrl;
  }
  if (!Util.isUnset(request.libraryVersion)) {
    body['libraryVersion'] = request.libraryVersion;
  }
  if (!Util.isUnset(request.marketId)) {
    body['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.reviewerId)) {
    body['reviewerId'] = request.reviewerId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateLibrarySchemaRequest {
  body?: LibrarySchema(name='body'),
}

model CreateLibrarySchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibrarySchema(name='result'),
}

model CreateLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLibrarySchemaResponseBody(name='body'),
}

async function createLibrarySchema(libraryName: string, request: CreateLibrarySchemaRequest): CreateLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createLibrarySchemaWithOptions(libraryName, request, headers, runtime);
}

async function createLibrarySchemaWithOptions(libraryName: string, request: CreateLibrarySchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateLibrarySchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcRequest {
  body?: Pbc(name='body'),
}

model CreatePbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: Pbc(name='result'),
}

model CreatePbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcResponseBody(name='body'),
}

async function createPbc(request: CreatePbcRequest): CreatePbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcWithOptions(request, headers, runtime);
}

async function createPbcWithOptions(request: CreatePbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcApiSchemaRequest {
  body?: PbcApiSchema(name='body'),
}

model CreatePbcApiSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcApiSchema(name='result'),
}

model CreatePbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcApiSchemaResponseBody(name='body'),
}

async function createPbcApiSchema(pbcName: string, version: string, request: CreatePbcApiSchemaRequest): CreatePbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcApiSchemaWithOptions(pbcName, version, request, headers, runtime);
}

async function createPbcApiSchemaWithOptions(pbcName: string, version: string, request: CreatePbcApiSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcApiSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/api-schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcInstructionRequest {
  body?: PbcInstruction(name='body'),
}

model CreatePbcInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcInstruction(name='result'),
}

model CreatePbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcInstructionResponseBody(name='body'),
}

async function createPbcInstruction(pbcName: string, version: string, request: CreatePbcInstructionRequest): CreatePbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInstructionWithOptions(pbcName, version, request, headers, runtime);
}

async function createPbcInstructionWithOptions(pbcName: string, version: string, request: CreatePbcInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInstructionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/instruction`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcInvokeRequest {
}

model CreatePbcInvokeResponseBody = {
  requestId?: string(name='requestId'),
  result?: {
    pbcInvokeId?: long(name='pbcInvokeId'),
  }(name='result'),
}

model CreatePbcInvokeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcInvokeResponseBody(name='body'),
}

async function createPbcInvoke(request: CreatePbcInvokeRequest): CreatePbcInvokeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInvokeWithOptions(request, headers, runtime);
}

async function createPbcInvokeWithOptions(request: CreatePbcInvokeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInvokeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInvoke',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invokes`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcInvokeReviewRequest {
  pbcName?: string(name='pbcName'),
}

model CreatePbcInvokeReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: CreatePbcInvokeReviewResult(name='result'),
}

model CreatePbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcInvokeReviewResponseBody(name='body'),
}

async function createPbcInvokeReview(request: CreatePbcInvokeReviewRequest): CreatePbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcInvokeReviewWithOptions(request, headers, runtime);
}

async function createPbcInvokeReviewWithOptions(request: CreatePbcInvokeReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcInvokeReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.pbcName)) {
    body['pbcName'] = request.pbcName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcReviewRequest {
  body?: PbcReviewCreateCmd(name='body'),
}

model CreatePbcReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcReview(name='result'),
}

model CreatePbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcReviewResponseBody(name='body'),
}

async function createPbcReview(request: CreatePbcReviewRequest): CreatePbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcReviewWithOptions(request, headers, runtime);
}

async function createPbcReviewWithOptions(request: CreatePbcReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcSchemaRequest {
  companyId?: long(name='companyId'),
  id?: long(name='id'),
  pbcName?: string(name='pbcName'),
  pbcVersion?: string(name='pbcVersion'),
  schema?: string(name='schema'),
}

model CreatePbcSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcSchema(name='result'),
}

model CreatePbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcSchemaResponseBody(name='body'),
}

async function createPbcSchema(pbcName: string, version: string, request: CreatePbcSchemaRequest): CreatePbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcSchemaWithOptions(pbcName, version, request, headers, runtime);
}

async function createPbcSchemaWithOptions(pbcName: string, version: string, request: CreatePbcSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcSchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    body['companyId'] = request.companyId;
  }
  if (!Util.isUnset(request.id)) {
    body['id'] = request.id;
  }
  if (!Util.isUnset(request.pbcName)) {
    body['pbcName'] = request.pbcName;
  }
  if (!Util.isUnset(request.pbcVersion)) {
    body['pbcVersion'] = request.pbcVersion;
  }
  if (!Util.isUnset(request.schema)) {
    body['schema'] = request.schema;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/schemas`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePbcVersionRequest {
  body?: PbcVersionCmd(name='body'),
}

model CreatePbcVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcVersion(name='result'),
}

model CreatePbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePbcVersionResponseBody(name='body'),
}

async function createPbcVersion(pbcName: string, version: string, request: CreatePbcVersionRequest): CreatePbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPbcVersionWithOptions(pbcName, version, request, headers, runtime);
}

async function createPbcVersionWithOptions(pbcName: string, version: string, request: CreatePbcVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePbcVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePdpConfigRequest {
  body?: PdpConfig(name='body'),
}

model CreatePdpConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfig(name='result'),
}

model CreatePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdpConfigResponseBody(name='body'),
}

async function createPdpConfig(request: CreatePdpConfigRequest): CreatePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpConfigWithOptions(request, headers, runtime);
}

async function createPdpConfigWithOptions(request: CreatePdpConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePdpPbcRequest {
  body?: PdpPbc(name='body'),
}

model CreatePdpPbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpPbc(name='result'),
}

model CreatePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdpPbcResponseBody(name='body'),
}

async function createPdpPbc(request: CreatePdpPbcRequest): CreatePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpPbcWithOptions(request, headers, runtime);
}

async function createPdpPbcWithOptions(request: CreatePdpPbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpPbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePdpServiceRequest {
  body?: PdpService(name='body'),
}

model CreatePdpServiceResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpService(name='result'),
}

model CreatePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePdpServiceResponseBody(name='body'),
}

async function createPdpService(request: CreatePdpServiceRequest): CreatePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPdpServiceWithOptions(request, headers, runtime);
}

async function createPdpServiceWithOptions(request: CreatePdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreatePrivilegeRequest {
  body?: CreatePrivilegeCmd(name='body'),
}

model CreatePrivilegeResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Privilege
  ](name='result'),
}

model CreatePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePrivilegeResponseBody(name='body'),
}

async function createPrivilege(roleId: string, request: CreatePrivilegeRequest): CreatePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createPrivilegeWithOptions(roleId, request, headers, runtime);
}

async function createPrivilegeWithOptions(roleId: string, request: CreatePrivilegeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreatePrivilegeResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePrivilege',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/privileges`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRepoForkRequest {
  body?: ReposForkCreateCmd(name='body'),
}

model CreateRepoForkResponseBody = {
  requestId?: string(name='requestId'),
  result?: string(name='result'),
}

model CreateRepoForkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRepoForkResponseBody(name='body'),
}

async function createRepoFork(request: CreateRepoForkRequest): CreateRepoForkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRepoForkWithOptions(request, headers, runtime);
}

async function createRepoForkWithOptions(request: CreateRepoForkRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRepoForkResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRepoFork',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model CreateRoleRequest {
  body?: Role(name='body'),
}

model CreateRoleResponseBody = {
  requestId?: string(name='requestId'),
  result?: Role(name='result'),
}

model CreateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRoleResponseBody(name='body'),
}

async function createRole(request: CreateRoleRequest): CreateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return createRoleWithOptions(request, headers, runtime);
}

async function createRoleWithOptions(request: CreateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): CreateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeleteDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteDeveloper(accountId: string): DeleteDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteDeveloperWithOptions(accountId, headers, runtime);
}

async function deleteDeveloperWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteDeveloperResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteEnterprise(enterpriseId: string): DeleteEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteEnterpriseWithOptions(enterpriseId, headers, runtime);
}

async function deleteEnterpriseWithOptions(enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibrary(libraryName: string): DeleteLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibraryWithOptions(libraryName, headers, runtime);
}

async function deleteLibraryWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibraryInstruction(libraryName: string): DeleteLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibraryInstructionWithOptions(libraryName, headers, runtime);
}

async function deleteLibraryInstructionWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibraryInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/instructions`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deleteLibrarySchema(libraryName: string): DeleteLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteLibrarySchemaWithOptions(libraryName, headers, runtime);
}

async function deleteLibrarySchemaWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteLibrarySchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/schemas`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeletePbcInvokeRequest {
  invokePbcName?: string(name='invoke_pbc_name'),
  pbcName?: string(name='pbc_name'),
}

model DeletePbcInvokeResponseBody = {
  requestId?: string(name='requestId'),
  reuslt?: CatalogCommonResult(name='reuslt'),
}

model DeletePbcInvokeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePbcInvokeResponseBody(name='body'),
}

async function deletePbcInvoke(request: DeletePbcInvokeRequest): DeletePbcInvokeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePbcInvokeWithOptions(request, headers, runtime);
}

async function deletePbcInvokeWithOptions(request: DeletePbcInvokeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePbcInvokeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.invokePbcName)) {
    query['invoke_pbc_name'] = request.invokePbcName;
  }
  if (!Util.isUnset(request.pbcName)) {
    query['pbc_name'] = request.pbcName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeletePbcInvoke',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invokes`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePdpConfigResponseBody = {
  requestId?: string(name='requestId'),
}

model DeletePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpConfigResponseBody(name='body'),
}

async function deletePdpConfig(configId: string): DeletePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpConfigWithOptions(configId, headers, runtime);
}

async function deletePdpConfigWithOptions(configId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/${OpenApiUtil.getEncodeParam(configId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePdpPbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
}

model DeletePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpPbcResponseBody(name='body'),
}

async function deletePdpPbc(id: string): DeletePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpPbcWithOptions(id, headers, runtime);
}

async function deletePdpPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePdpServiceResponseBody = {
  requestId?: string(name='requestId'),
}

model DeletePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePdpServiceResponseBody(name='body'),
}

async function deletePdpService(serviceId: string): DeletePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePdpServiceWithOptions(serviceId, headers, runtime);
}

async function deletePdpServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePdpServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DeletePrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function deletePrivilege(privilegeId: string): DeletePrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deletePrivilegeWithOptions(privilegeId, headers, runtime);
}

async function deletePrivilegeWithOptions(privilegeId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeletePrivilegeResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeletePrivilege',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/privileges/${OpenApiUtil.getEncodeParam(privilegeId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model DeleteRoleResponseBody = {
  requestId?: string(name='requestId'),
}

model DeleteRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRoleResponseBody(name='body'),
}

async function deleteRole(roleId: string): DeleteRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return deleteRoleWithOptions(roleId, headers, runtime);
}

async function deleteRoleWithOptions(roleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): DeleteRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DeleteRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'DELETE',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model DependLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model DependLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DependLibraryResponseBody(name='body'),
}

async function dependLibrary(libraryName: string): DependLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return dependLibraryWithOptions(libraryName, headers, runtime);
}

async function dependLibraryWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): DependLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'DependLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/commands/dependency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FeedbackLibraryReviewRequest {
  approve?: string(name='approve'),
  feedback?: string(name='feedback'),
  reviewId?: string(name='reviewId'),
}

model FeedbackLibraryReviewResponseBody = {
  requestId?: string(name='requestId'),
  resule?: LibraryReview(name='resule'),
}

model FeedbackLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FeedbackLibraryReviewResponseBody(name='body'),
}

async function feedbackLibraryReview(reviewId: string, request: FeedbackLibraryReviewRequest): FeedbackLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return feedbackLibraryReviewWithOptions(reviewId, request, headers, runtime);
}

async function feedbackLibraryReviewWithOptions(reviewId: string, request: FeedbackLibraryReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FeedbackLibraryReviewResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.approve)) {
    body['approve'] = request.approve;
  }
  if (!Util.isUnset(request.feedback)) {
    body['feedback'] = request.feedback;
  }
  if (!Util.isUnset(request.reviewId)) {
    body['reviewId'] = request.reviewId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'FeedbackLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/feedback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model FeedbackPbcReviewRequest {
  body?: FeedbackReviewCmd(name='body'),
}

model FeedbackPbcReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcReview(name='result'),
}

model FeedbackPbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: FeedbackPbcReviewResponseBody(name='body'),
}

async function feedbackPbcReview(reviewId: string, request: FeedbackPbcReviewRequest): FeedbackPbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return feedbackPbcReviewWithOptions(reviewId, request, headers, runtime);
}

async function feedbackPbcReviewWithOptions(reviewId: string, request: FeedbackPbcReviewRequest, headers: map[string]string, runtime: Util.RuntimeOptions): FeedbackPbcReviewResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'FeedbackPbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/${OpenApiUtil.getEncodeParam(reviewId)}/commands/feedback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeploymentResponseBody = {
  requestId?: string(name='requestId'),
  result?: DeployDetailInfo(name='result'),
}

model GetDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeploymentResponseBody(name='body'),
}

async function getDeployment(deploymentId: string): GetDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeploymentWithOptions(deploymentId, headers, runtime);
}

async function getDeploymentWithOptions(deploymentId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeploymentResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/instance/${OpenApiUtil.getEncodeParam(deploymentId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: Developer  
}

async function getDeveloper(accountId: string): GetDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeveloperWithOptions(accountId, headers, runtime);
}

async function getDeveloperWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeveloperResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetDeveloperEnterpriseResponseBody = {
  enterprise?: Enterprise(name='enterprise'),
  requestId?: string(name='requestId'),
}

model GetDeveloperEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeveloperEnterpriseResponseBody(name='body'),
}

async function getDeveloperEnterprise(accountId: string): GetDeveloperEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getDeveloperEnterpriseWithOptions(accountId, headers, runtime);
}

async function getDeveloperEnterpriseWithOptions(accountId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetDeveloperEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetDeveloperEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetEnterpriseResponseBody = {
  requestId?: string(name='requestId'),
  result?: Enterprise(name='result'),
}

model GetEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetEnterpriseResponseBody(name='body'),
}

async function getEnterprise(enterpriseId: string): GetEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getEnterpriseWithOptions(enterpriseId, headers, runtime);
}

async function getEnterpriseWithOptions(enterpriseId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetEnterpriseResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetForkReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: ForkReview(name='result'),
}

model GetForkReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetForkReviewResponseBody(name='body'),
}

async function getForkReview(reviewId: string): GetForkReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getForkReviewWithOptions(reviewId, headers, runtime);
}

async function getForkReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetForkReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetForkReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetHistoryDeveloperRequest {
  enterpriseId?: long(name='enterprise_id'),
}

model GetHistoryDeveloperResponseBody = {
  requestId?: string(name='requestId'),
  result?: Developer(name='result'),
}

model GetHistoryDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetHistoryDeveloperResponseBody(name='body'),
}

async function getHistoryDeveloper(accountId: string, request: GetHistoryDeveloperRequest): GetHistoryDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getHistoryDeveloperWithOptions(accountId, request, headers, runtime);
}

async function getHistoryDeveloperWithOptions(accountId: string, request: GetHistoryDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetHistoryDeveloperResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterprise_id'] = request.enterpriseId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetHistoryDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}/commonds/history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLastDeploymentConfigRequest {
  env?: string(name='env'),
  serviceId?: long(name='service_id'),
}

model GetLastDeploymentConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: DeployConfigInfo(name='result'),
}

model GetLastDeploymentConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLastDeploymentConfigResponseBody(name='body'),
}

async function getLastDeploymentConfig(request: GetLastDeploymentConfigRequest): GetLastDeploymentConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLastDeploymentConfigWithOptions(request, headers, runtime);
}

async function getLastDeploymentConfigWithOptions(request: GetLastDeploymentConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetLastDeploymentConfigResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLastDeploymentConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/last-config`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: Library(name='result'),
}

model GetLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryResponseBody(name='body'),
}

async function getLibrary(libraryName: string): GetLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryWithOptions(libraryName, headers, runtime);
}

async function getLibraryWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibraryDeveloperRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryDeveloperRepoMetricResult(name='result'),
}

model GetLibraryDeveloperRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryDeveloperRepoMetricsResponseBody(name='body'),
}

async function getLibraryDeveloperRepoMetrics(libraryName: string): GetLibraryDeveloperRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryDeveloperRepoMetricsWithOptions(libraryName, headers, runtime);
}

async function getLibraryDeveloperRepoMetricsWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryDeveloperRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryDeveloperRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/Librarys/${OpenApiUtil.getEncodeParam(libraryName)}/code/commands/get-developer-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibraryInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryInstruction(name='result'),
}

model GetLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryInstructionResponseBody(name='body'),
}

async function getLibraryInstruction(libraryName: string): GetLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryInstructionWithOptions(libraryName, headers, runtime);
}

async function getLibraryInstructionWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/instructions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibraryRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  RepoMetric
](name='result'),
}

model GetLibraryRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryRepoMetricsResponseBody(name='body'),
}

async function getLibraryRepoMetrics(libraryName: string): GetLibraryRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryRepoMetricsWithOptions(libraryName, headers, runtime);
}

async function getLibraryRepoMetricsWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/Librarys/${OpenApiUtil.getEncodeParam(libraryName)}/code/commands/get-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibraryReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryReview(name='result'),
}

model GetLibraryReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibraryReviewResponseBody(name='body'),
}

async function getLibraryReview(reviewId: string): GetLibraryReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibraryReviewWithOptions(reviewId, headers, runtime);
}

async function getLibraryReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibraryReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibraryReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetLibrarySchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibrarySchema(name='result'),
}

model GetLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLibrarySchemaResponseBody(name='body'),
}

async function getLibrarySchema(libraryName: string): GetLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getLibrarySchemaWithOptions(libraryName, headers, runtime);
}

async function getLibrarySchemaWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetLibrarySchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: Pbc(name='result'),
}

model GetPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcResponseBody(name='body'),
}

async function getPbc(pbcName: string): GetPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcWithOptions(pbcName, headers, runtime);
}

async function getPbcWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcApiSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcApiSchema(name='result'),
}

model GetPbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcApiSchemaResponseBody(name='body'),
}

async function getPbcApiSchema(pbcName: string, version: string): GetPbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcApiSchemaWithOptions(pbcName, version, headers, runtime);
}

async function getPbcApiSchemaWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcApiSchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/api-schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcDeveloperRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcDeveloperRepoMetricResult(name='result'),
}

model GetPbcDeveloperRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcDeveloperRepoMetricsResponseBody(name='body'),
}

async function getPbcDeveloperRepoMetrics(pbcName: string): GetPbcDeveloperRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcDeveloperRepoMetricsWithOptions(pbcName, headers, runtime);
}

async function getPbcDeveloperRepoMetricsWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcDeveloperRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcDeveloperRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/code/commands/get-developer-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcInstruction(name='result'),
}

model GetPbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcInstructionResponseBody(name='body'),
}

async function getPbcInstruction(pbcName: string, version: string): GetPbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcInstructionWithOptions(pbcName, version, headers, runtime);
}

async function getPbcInstructionWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/instruction`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcInvokeReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcInvokeReview(name='result'),
}

model GetPbcInvokeReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcInvokeReviewResponseBody(name='body'),
}

async function getPbcInvokeReview(reviewId: string): GetPbcInvokeReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcInvokeReviewWithOptions(reviewId, headers, runtime);
}

async function getPbcInvokeReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcInvokeReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcInvokeReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcRepoMetricsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcRepoMetricResult(name='result'),
}

model GetPbcRepoMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcRepoMetricsResponseBody(name='body'),
}

async function getPbcRepoMetrics(pbcName: string): GetPbcRepoMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcRepoMetricsWithOptions(pbcName, headers, runtime);
}

async function getPbcRepoMetricsWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcRepoMetricsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcRepoMetrics',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/code/commands/get-repo-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcReviewResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcReview(name='result'),
}

model GetPbcReviewResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcReviewResponseBody(name='body'),
}

async function getPbcReview(reviewId: string): GetPbcReviewResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcReviewWithOptions(reviewId, headers, runtime);
}

async function getPbcReviewWithOptions(reviewId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcReviewResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcReview',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/${OpenApiUtil.getEncodeParam(reviewId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcSchema(name='result'),
}

model GetPbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcSchemaResponseBody(name='body'),
}

async function getPbcSchema(pbcName: string, version: string): GetPbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcSchemaWithOptions(pbcName, version, headers, runtime);
}

async function getPbcSchemaWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcSchemaResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/schemas`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPbcVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcVersion(name='result'),
}

model GetPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPbcVersionResponseBody(name='body'),
}

async function getPbcVersion(pbcName: string, version: string): GetPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPbcVersionWithOptions(pbcName, version, headers, runtime);
}

async function getPbcVersionWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPbcVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPdpConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfig(name='result'),
}

model GetPdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPdpConfigResponseBody(name='body'),
}

async function getPdpConfig(configId: string): GetPdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpConfigWithOptions(configId, headers, runtime);
}

async function getPdpConfigWithOptions(configId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpConfigResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/last/${OpenApiUtil.getEncodeParam(configId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPdpPbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpPbc(name='result'),
}

model GetPdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPdpPbcResponseBody(name='body'),
}

async function getPdpPbc(id: string): GetPdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpPbcWithOptions(id, headers, runtime);
}

async function getPdpPbcWithOptions(id: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs/${OpenApiUtil.getEncodeParam(id)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetPdpServiceResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpService(name='result'),
}

model GetPdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPdpServiceResponseBody(name='body'),
}

async function getPdpService(serviceId: string): GetPdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getPdpServiceWithOptions(serviceId, headers, runtime);
}

async function getPdpServiceWithOptions(serviceId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetPdpServiceResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetPdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services/${OpenApiUtil.getEncodeParam(serviceId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepoForkResponseBody = {
  requestId?: string(name='requestId'),
  result?: ReposFork(name='result'),
}

model GetRepoForkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoForkResponseBody(name='body'),
}

async function getRepoFork(forkId: string): GetRepoForkResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoForkWithOptions(forkId, headers, runtime);
}

async function getRepoForkWithOptions(forkId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoForkResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRepoFork',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks/${OpenApiUtil.getEncodeParam(forkId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRepoMetricRequest {
  repoUrls?: [ string ](name='RepoUrls'),
}

model GetRepoMetricResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetRepoMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRepoMetricResponseBody(name='body'),
}

async function getRepoMetric(request: GetRepoMetricRequest): GetRepoMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRepoMetricWithOptions(request, headers, runtime);
}

async function getRepoMetricWithOptions(request: GetRepoMetricRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GetRepoMetricResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.repoUrls)) {
    query['RepoUrls'] = request.repoUrls;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRepoMetric',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/code-metric/repos-metric`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GetRoleResponseBody = {
  requestId?: string(name='requestId'),
  result?: Role(name='result'),
}

model GetRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRoleResponseBody(name='body'),
}

async function getRole(roleId: string): GetRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return getRoleWithOptions(roleId, headers, runtime);
}

async function getRoleWithOptions(roleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): GetRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'GetRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/role-id/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model GrantRoleRequest {
  body?: RoleGrantCmd(name='body'),
}

model GrantRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function grantRole(roleId: string, request: GrantRoleRequest): GrantRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return grantRoleWithOptions(roleId, request, headers, runtime);
}

async function grantRoleWithOptions(roleId: string, request: GrantRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): GrantRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'GrantRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/commands/grant`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model ListDependLibrarysRequest {
  applicant?: string(name='applicant'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListDependLibrarysResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  Library
](name='result'),
}

model ListDependLibrarysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDependLibrarysResponseBody(name='body'),
}

async function listDependLibrarys(request: ListDependLibrarysRequest): ListDependLibrarysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDependLibrarysWithOptions(request, headers, runtime);
}

async function listDependLibrarysWithOptions(request: ListDependLibrarysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDependLibrarysResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDependLibrarys',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/v1/librarys/commands/list-dependency`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeploymentsRequest {
  env?: string(name='env'),
  excludeStatus?: [ string ](name='exclude_status'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  serviceId?: long(name='service_id'),
  status?: [ string ](name='status'),
}

model ListDeploymentsShrinkRequest {
  env?: string(name='env'),
  excludeStatusShrink?: string(name='exclude_status'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  serviceId?: long(name='service_id'),
  statusShrink?: string(name='status'),
}

model ListDeploymentsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpDeploymentPageResult(name='result'),
}

model ListDeploymentsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeploymentsResponseBody(name='body'),
}

async function listDeployments(request: ListDeploymentsRequest): ListDeploymentsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeploymentsWithOptions(request, headers, runtime);
}

async function listDeploymentsWithOptions(tmpReq: ListDeploymentsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeploymentsResponse {
  Util.validateModel(tmpReq);
  var request = new ListDeploymentsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.excludeStatus)) {
    request.excludeStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.excludeStatus, 'exclude_status', 'json');
  }
  if (!Util.isUnset(tmpReq.status)) {
    request.statusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.status, 'status', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.excludeStatusShrink)) {
    query['exclude_status'] = request.excludeStatusShrink;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }
  if (!Util.isUnset(request.statusShrink)) {
    query['status'] = request.statusShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeployments',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeveloperPbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Pbc
  ](name='result'),
}

model ListDeveloperPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeveloperPbcsResponseBody(name='body'),
}

async function listDeveloperPbcs(): ListDeveloperPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeveloperPbcsWithOptions(headers, runtime);
}

async function listDeveloperPbcsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListDeveloperPbcsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDeveloperPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/commands/allow-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDeveloperRepoMetricSumRequest {
  repoUrls?: [ string ](name='RepoUrls'),
}

model ListDeveloperRepoMetricSumResponseBody = {
  code?: string(name='Code'),
  data?: [  map[string]any ](name='Data'),
  httpCode?: int32(name='HttpCode'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListDeveloperRepoMetricSumResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeveloperRepoMetricSumResponseBody(name='body'),
}

async function listDeveloperRepoMetricSum(request: ListDeveloperRepoMetricSumRequest): ListDeveloperRepoMetricSumResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDeveloperRepoMetricSumWithOptions(request, headers, runtime);
}

async function listDeveloperRepoMetricSumWithOptions(request: ListDeveloperRepoMetricSumRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDeveloperRepoMetricSumResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.repoUrls)) {
    query['RepoUrls'] = request.repoUrls;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeveloperRepoMetricSum',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/code-metric/developer-metrics`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDevelopersRequest {
  accountIds?: [ string ](name='account_ids'),
  enterpriseId?: long(name='enterprise_id'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  roleId?: long(name='role_id'),
}

model ListDevelopersShrinkRequest {
  accountIdsShrink?: string(name='account_ids'),
  enterpriseId?: long(name='enterprise_id'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  roleId?: long(name='role_id'),
}

model ListDevelopersResponseBody = {
  requestId?: string(name='requestId'),
  result?: DeveloperPageResult(name='result'),
}

model ListDevelopersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevelopersResponseBody(name='body'),
}

async function listDevelopers(request: ListDevelopersRequest): ListDevelopersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDevelopersWithOptions(request, headers, runtime);
}

async function listDevelopersWithOptions(tmpReq: ListDevelopersRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListDevelopersResponse {
  Util.validateModel(tmpReq);
  var request = new ListDevelopersShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.accountIds)) {
    request.accountIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.accountIds, 'account_ids', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountIdsShrink)) {
    query['account_ids'] = request.accountIdsShrink;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterprise_id'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.roleId)) {
    query['role_id'] = request.roleId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDevelopers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListDownstreamPbcResponseBody = {
  result?: PbcUpDownstreamResult(name='result'),
  rquestId?: string(name='rquestId'),
}

model ListDownstreamPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDownstreamPbcResponseBody(name='body'),
}

async function listDownstreamPbc(pbcName: string, version: string): ListDownstreamPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listDownstreamPbcWithOptions(pbcName, version, headers, runtime);
}

async function listDownstreamPbcWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListDownstreamPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListDownstreamPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/commands/list-downstream`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListEnterprisesRequest {
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListEnterprisesResponseBody = {
  requestId?: string(name='requestId'),
  result?: EnterprisePageResult(name='result'),
}

model ListEnterprisesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEnterprisesResponseBody(name='body'),
}

async function listEnterprises(request: ListEnterprisesRequest): ListEnterprisesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listEnterprisesWithOptions(request, headers, runtime);
}

async function listEnterprisesWithOptions(request: ListEnterprisesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListEnterprisesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEnterprises',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListForkReviewsRequest {
  applicant?: string(name='applicant'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  reviewer?: string(name='reviewer'),
}

model ListForkReviewsResponseBody = {
  requestId?: string(name='requestId'),
  result?: ForkReviewListResult(name='result'),
}

model ListForkReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListForkReviewsResponseBody(name='body'),
}

async function listForkReviews(request: ListForkReviewsRequest): ListForkReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listForkReviewsWithOptions(request, headers, runtime);
}

async function listForkReviewsWithOptions(request: ListForkReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListForkReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListForkReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/fork-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListGrantedRolesRequest {
  authorizerId?: string(name='authorizer_id'),
  authorizerType?: string(name='authorizer_type'),
  name?: string(name='name'),
}

model ListGrantedRolesResponseBody = {
  requestId?: string(name='requestId'),
  result?: RolePageResult(name='result'),
}

model ListGrantedRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGrantedRolesResponseBody(name='body'),
}

async function listGrantedRoles(request: ListGrantedRolesRequest): ListGrantedRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listGrantedRolesWithOptions(request, headers, runtime);
}

async function listGrantedRolesWithOptions(request: ListGrantedRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListGrantedRolesResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorizerId)) {
    query['authorizer_id'] = request.authorizerId;
  }
  if (!Util.isUnset(request.authorizerType)) {
    query['authorizer_type'] = request.authorizerType;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGrantedRoles',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/commands/list-granted-roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListInvokePbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcListResult(name='result'),
}

model ListInvokePbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInvokePbcsResponseBody(name='body'),
}

async function listInvokePbcs(pbcName: string): ListInvokePbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listInvokePbcsWithOptions(pbcName, headers, runtime);
}

async function listInvokePbcsWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListInvokePbcsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListInvokePbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/invoke-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLibraryReviewsRequest {
  applicant?: string(name='applicant'),
  marketId?: long(name='marketId'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  reviewer?: string(name='reviewer'),
}

model ListLibraryReviewsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  LibraryReview
](name='result'),
}

model ListLibraryReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLibraryReviewsResponseBody(name='body'),
}

async function listLibraryReviews(request: ListLibraryReviewsRequest): ListLibraryReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLibraryReviewsWithOptions(request, headers, runtime);
}

async function listLibraryReviewsWithOptions(request: ListLibraryReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLibraryReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.marketId)) {
    query['marketId'] = request.marketId;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLibraryReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/library-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListLibrarysRequest {
  companyId?: long(name='company_id'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  provider?: string(name='provider'),
}

model ListLibrarysResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  Library
](name='result'),
}

model ListLibrarysResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLibrarysResponseBody(name='body'),
}

async function listLibrarys(request: ListLibrarysRequest): ListLibrarysResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listLibrarysWithOptions(request, headers, runtime);
}

async function listLibrarysWithOptions(request: ListLibrarysRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListLibrarysResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.companyId)) {
    query['company_id'] = request.companyId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.provider)) {
    query['provider'] = request.provider;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLibrarys',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMarketsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Market
  ](name='result'),
}

model ListMarketsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMarketsResponseBody(name='body'),
}

async function listMarkets(): ListMarketsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMarketsWithOptions(headers, runtime);
}

async function listMarketsWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListMarketsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListMarkets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListMetadataInfosRequest {
  env?: string(name='env'),
  namespaceId?: long(name='namespace_id'),
  namespaceName?: string(name='namespace_name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  orgId?: int32(name='org_id'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcId?: long(name='pbc_id'),
}

model ListMetadataInfosResponseBody = {
  requestId?: string(name='requestId'),
  result?: MetadataInfoListResult(name='result'),
}

model ListMetadataInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMetadataInfosResponseBody(name='body'),
}

async function listMetadataInfos(request: ListMetadataInfosRequest): ListMetadataInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listMetadataInfosWithOptions(request, headers, runtime);
}

async function listMetadataInfosWithOptions(request: ListMetadataInfosRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListMetadataInfosResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.namespaceId)) {
    query['namespace_id'] = request.namespaceId;
  }
  if (!Util.isUnset(request.namespaceName)) {
    query['namespace_name'] = request.namespaceName;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.orgId)) {
    query['org_id'] = request.orgId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbc_id'] = request.pbcId;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMetadataInfos',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/metadata`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcInvokeReviewsRequest {
  applicant?: string(name='applicant'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  reviewer?: string(name='reviewer'),
}

model ListPbcInvokeReviewsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  PbcInvokeReview
](name='result'),
}

model ListPbcInvokeReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcInvokeReviewsResponseBody(name='body'),
}

async function listPbcInvokeReviews(request: ListPbcInvokeReviewsRequest): ListPbcInvokeReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcInvokeReviewsWithOptions(request, headers, runtime);
}

async function listPbcInvokeReviewsWithOptions(request: ListPbcInvokeReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcInvokeReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.applicant)) {
    query['applicant'] = request.applicant;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.reviewer)) {
    query['reviewer'] = request.reviewer;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcInvokeReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-invoke-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcReviewsRequest {
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListPbcReviewsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcReviewListResult(name='result'),
}

model ListPbcReviewsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcReviewsResponseBody(name='body'),
}

async function listPbcReviews(request: ListPbcReviewsRequest): ListPbcReviewsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcReviewsWithOptions(request, headers, runtime);
}

async function listPbcReviewsWithOptions(request: ListPbcReviewsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcReviewsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcReviews',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcSubscribeRequest {
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListPbcSubscribeResponseBody = {
  pbcListResult?: PbcListResult(name='pbcListResult'),
  requestId?: string(name='requestId'),
}

model ListPbcSubscribeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcSubscribeResponseBody(name='body'),
}

async function listPbcSubscribe(request: ListPbcSubscribeRequest): ListPbcSubscribeResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcSubscribeWithOptions(request, headers, runtime);
}

async function listPbcSubscribeWithOptions(request: ListPbcSubscribeRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcSubscribeResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcSubscribe',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/commands/list-subscribe`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcVersionBuildRequest {
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListPbcVersionBuildResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcVersionListResult(name='result'),
}

model ListPbcVersionBuildResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcVersionBuildResponseBody(name='body'),
}

async function listPbcVersionBuild(request: ListPbcVersionBuildRequest): ListPbcVersionBuildResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcVersionBuildWithOptions(request, headers, runtime);
}

async function listPbcVersionBuildWithOptions(request: ListPbcVersionBuildRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcVersionBuildResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcVersionBuild',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/versions/commands/list-build`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcVersionNumbersResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    PbcVersion
  ](name='result'),
}

model ListPbcVersionNumbersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcVersionNumbersResponseBody(name='body'),
}

async function listPbcVersionNumbers(pbcName: string): ListPbcVersionNumbersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcVersionNumbersWithOptions(pbcName, headers, runtime);
}

async function listPbcVersionNumbersWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcVersionNumbersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPbcVersionNumbers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/listPbcVersionNumbers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPbcsRequest {
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListPbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcListResult(name='result'),
}

model ListPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPbcsResponseBody(name='body'),
}

async function listPbcs(request: ListPbcsRequest): ListPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPbcsWithOptions(request, headers, runtime);
}

async function listPbcsWithOptions(request: ListPbcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPbcsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPdpConfigsRequest {
  env?: string(name='env'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  serviceId?: long(name='service_id'),
  type?: string(name='type'),
}

model ListPdpConfigsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfigPageResult(name='result'),
}

model ListPdpConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpConfigsResponseBody(name='body'),
}

async function listPdpConfigs(request: ListPdpConfigsRequest): ListPdpConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpConfigsWithOptions(request, headers, runtime);
}

async function listPdpConfigsWithOptions(request: ListPdpConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpConfigs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPdpHistoryConfigsRequest {
  configId?: long(name='config_id'),
  env?: string(name='env'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  serviceId?: long(name='service_id'),
  type?: string(name='type'),
}

model ListPdpHistoryConfigsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpHistoryConfigPageResult(name='result'),
}

model ListPdpHistoryConfigsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpHistoryConfigsResponseBody(name='body'),
}

async function listPdpHistoryConfigs(request: ListPdpHistoryConfigsRequest): ListPdpHistoryConfigsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpHistoryConfigsWithOptions(request, headers, runtime);
}

async function listPdpHistoryConfigsWithOptions(request: ListPdpHistoryConfigsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpHistoryConfigsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.configId)) {
    query['config_id'] = request.configId;
  }
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpHistoryConfigs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs/history`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPdpLogsRequest {
  env?: string(name='env'),
  from?: long(name='from'),
  ip?: string(name='ip'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  query?: string(name='query'),
  serviceId?: long(name='service_id'),
  to?: long(name='to'),
}

model ListPdpLogsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfigPageResult(name='result'),
}

model ListPdpLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpLogsResponseBody(name='body'),
}

async function listPdpLogs(request: ListPdpLogsRequest): ListPdpLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpLogsWithOptions(request, headers, runtime);
}

async function listPdpLogsWithOptions(request: ListPdpLogsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpLogsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.env)) {
    query['env'] = request.env;
  }
  if (!Util.isUnset(request.from)) {
    query['from'] = request.from;
  }
  if (!Util.isUnset(request.ip)) {
    query['ip'] = request.ip;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.query)) {
    query['query'] = request.query;
  }
  if (!Util.isUnset(request.serviceId)) {
    query['service_id'] = request.serviceId;
  }
  if (!Util.isUnset(request.to)) {
    query['to'] = request.to;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpLogs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/pdp-log`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPdpPbcsRequest {
  developerId?: string(name='developer_id'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcIds?: [ long ](name='pbcIds'),
}

model ListPdpPbcsShrinkRequest {
  developerId?: string(name='developer_id'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcIdsShrink?: string(name='pbcIds'),
}

model ListPdpPbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpPbcListResult(name='result'),
}

model ListPdpPbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpPbcsResponseBody(name='body'),
}

async function listPdpPbcs(request: ListPdpPbcsRequest): ListPdpPbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpPbcsWithOptions(request, headers, runtime);
}

async function listPdpPbcsWithOptions(tmpReq: ListPdpPbcsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpPbcsResponse {
  Util.validateModel(tmpReq);
  var request = new ListPdpPbcsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pbcIds)) {
    request.pbcIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pbcIds, 'pbcIds', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.developerId)) {
    query['developer_id'] = request.developerId;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcIdsShrink)) {
    query['pbcIds'] = request.pbcIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpPbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPdpServicesRequest {
  alias?: string(name='alias'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcId?: long(name='pbc_id'),
  pdpServiceIds?: [ long ](name='pdp_service_ids'),
}

model ListPdpServicesShrinkRequest {
  alias?: string(name='alias'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  pbcId?: long(name='pbc_id'),
  pdpServiceIdsShrink?: string(name='pdp_service_ids'),
}

model ListPdpServicesResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpServicePageResult(name='result'),
}

model ListPdpServicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPdpServicesResponseBody(name='body'),
}

async function listPdpServices(request: ListPdpServicesRequest): ListPdpServicesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPdpServicesWithOptions(request, headers, runtime);
}

async function listPdpServicesWithOptions(tmpReq: ListPdpServicesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPdpServicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListPdpServicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.pdpServiceIds)) {
    request.pdpServiceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.pdpServiceIds, 'pdp_service_ids', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.alias)) {
    query['alias'] = request.alias;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.pbcId)) {
    query['pbc_id'] = request.pbcId;
  }
  if (!Util.isUnset(request.pdpServiceIdsShrink)) {
    query['pdp_service_ids'] = request.pdpServiceIdsShrink;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPdpServices',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPermissionResourceRequest {
  action?: string(name='action'),
  operatorId?: string(name='operator_id'),
  operatorType?: string(name='operator_type'),
  resourcePrefix?: string(name='resource_prefix'),
}

model ListPermissionResourceResponseBody = {
  permissionAllowResource?: PermissionAllowResource(name='permissionAllowResource'),
  requestId?: string(name='requestId'),
}

model ListPermissionResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionResourceResponseBody(name='body'),
}

async function listPermissionResource(request: ListPermissionResourceRequest): ListPermissionResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionResourceWithOptions(request, headers, runtime);
}

async function listPermissionResourceWithOptions(request: ListPermissionResourceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionResourceResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.operatorId)) {
    query['operator_id'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorType)) {
    query['operator_type'] = request.operatorType;
  }
  if (!Util.isUnset(request.resourcePrefix)) {
    query['resource_prefix'] = request.resourcePrefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionResource',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/permissions`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPermissionResourcePopRequest {
  action?: string(name='action'),
  operatorId?: string(name='operator_id'),
  operatorType?: string(name='operator_type'),
  resourcePrefix?: string(name='resource_prefix'),
}

model ListPermissionResourcePopResponseBody = {
  requestId?: string(name='requestId'),
  result?: PermissionAllowResource(name='result'),
}

model ListPermissionResourcePopResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPermissionResourcePopResponseBody(name='body'),
}

async function listPermissionResourcePop(request: ListPermissionResourcePopRequest): ListPermissionResourcePopResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPermissionResourcePopWithOptions(request, headers, runtime);
}

async function listPermissionResourcePopWithOptions(request: ListPermissionResourcePopRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListPermissionResourcePopResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.action)) {
    query['action'] = request.action;
  }
  if (!Util.isUnset(request.operatorId)) {
    query['operator_id'] = request.operatorId;
  }
  if (!Util.isUnset(request.operatorType)) {
    query['operator_type'] = request.operatorType;
  }
  if (!Util.isUnset(request.resourcePrefix)) {
    query['resource_prefix'] = request.resourcePrefix;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPermissionResourcePop',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/permissions/pop`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListPrivilegeByRoleResponseBody = {
  requestId?: string(name='requestId'),
  result?: PrivilegePageResult(name='result'),
}

model ListPrivilegeByRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPrivilegeByRoleResponseBody(name='body'),
}

async function listPrivilegeByRole(roleId: string): ListPrivilegeByRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listPrivilegeByRoleWithOptions(roleId, headers, runtime);
}

async function listPrivilegeByRoleWithOptions(roleId: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListPrivilegeByRoleResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListPrivilegeByRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/privileges`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRepoForksRequest {
  pbcName?: string(name='pbc_name'),
}

model ListRepoForksResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcRepoForkListResult(name='result'),
}

model ListRepoForksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRepoForksResponseBody(name='body'),
}

async function listRepoForks(request: ListRepoForksRequest): ListRepoForksResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRepoForksWithOptions(request, headers, runtime);
}

async function listRepoForksWithOptions(request: ListRepoForksRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRepoForksResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.pbcName)) {
    query['pbc_name'] = request.pbcName;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRepoForks',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/repo-forks`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListReviewersResponseBody = {
  result?: [ 
    {
      accountId?: string(name='accountId'),
      codeupAccountId?: string(name='codeupAccountId'),
      email?: string(name='email'),
      enterpriseId?: long(name='enterpriseId'),
      name?: string(name='name'),
      phone?: string(name='phone'),
    }
  ](name='result'),
  rquestId?: string(name='rquestId'),
}

model ListReviewersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListReviewersResponseBody(name='body'),
}

async function listReviewers(): ListReviewersResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listReviewersWithOptions(headers, runtime);
}

async function listReviewersWithOptions(headers: map[string]string, runtime: Util.RuntimeOptions): ListReviewersResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListReviewers',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbc-reviews/commands/listReviewers`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListRolesRequest {
  authorizerId?: string(name='authorizer_id'),
  authorizerType?: string(name='authorizer_type'),
  enterpriseId?: long(name='enterprise_id'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  platform?: string(name='platform'),
  roleIds?: [ long ](name='role_ids'),
  roleType?: string(name='role_type'),
}

model ListRolesShrinkRequest {
  authorizerId?: string(name='authorizer_id'),
  authorizerType?: string(name='authorizer_type'),
  enterpriseId?: long(name='enterprise_id'),
  name?: string(name='name'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  platform?: string(name='platform'),
  roleIdsShrink?: string(name='role_ids'),
  roleType?: string(name='role_type'),
}

model ListRolesResponseBody = {
  requestId?: string(name='requestId'),
  result?: RolePageResult(name='result'),
}

model ListRolesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRolesResponseBody(name='body'),
}

async function listRoles(request: ListRolesRequest): ListRolesResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listRolesWithOptions(request, headers, runtime);
}

async function listRolesWithOptions(tmpReq: ListRolesRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListRolesResponse {
  Util.validateModel(tmpReq);
  var request = new ListRolesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.roleIds)) {
    request.roleIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.roleIds, 'role_ids', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.authorizerId)) {
    query['authorizer_id'] = request.authorizerId;
  }
  if (!Util.isUnset(request.authorizerType)) {
    query['authorizer_type'] = request.authorizerType;
  }
  if (!Util.isUnset(request.enterpriseId)) {
    query['enterprise_id'] = request.enterpriseId;
  }
  if (!Util.isUnset(request.name)) {
    query['name'] = request.name;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.platform)) {
    query['platform'] = request.platform;
  }
  if (!Util.isUnset(request.roleIdsShrink)) {
    query['role_ids'] = request.roleIdsShrink;
  }
  if (!Util.isUnset(request.roleType)) {
    query['role_type'] = request.roleType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListRoles',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListSubscribePbcsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Pbc
  ](name='result'),
}

model ListSubscribePbcsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSubscribePbcsResponseBody(name='body'),
}

async function listSubscribePbcs(pbcName: string): ListSubscribePbcsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listSubscribePbcsWithOptions(pbcName, headers, runtime);
}

async function listSubscribePbcsWithOptions(pbcName: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListSubscribePbcsResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListSubscribePbcs',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/subscribe-list`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListUpstreamPbcResponseBody = {
  result?: PbcUpDownstreamResult(name='result'),
  rquestId?: string(name='rquestId'),
}

model ListUpstreamPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUpstreamPbcResponseBody(name='body'),
}

async function listUpstreamPbc(pbcName: string, version: string): ListUpstreamPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listUpstreamPbcWithOptions(pbcName, version, headers, runtime);
}

async function listUpstreamPbcWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): ListUpstreamPbcResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'ListUpstreamPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/commands/list-upstream`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model ListWatchAssetsRequest {
  accountId?: string(name='account_id'),
  assetName?: string(name='asset_name'),
  assetType?: string(name='asset_type'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model ListWatchAssetsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  PbcInvokeReview
](name='result'),
}

model ListWatchAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWatchAssetsResponseBody(name='body'),
}

async function listWatchAssets(request: ListWatchAssetsRequest): ListWatchAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return listWatchAssetsWithOptions(request, headers, runtime);
}

async function listWatchAssetsWithOptions(request: ListWatchAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): ListWatchAssetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.accountId)) {
    query['account_id'] = request.accountId;
  }
  if (!Util.isUnset(request.assetName)) {
    query['asset_name'] = request.assetName;
  }
  if (!Util.isUnset(request.assetType)) {
    query['asset_type'] = request.assetType;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWatchAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watch/commands/list-watch`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveAssetWatchRequest {
  assetType?: string(name='asset_type'),
}

model RemoveAssetWatchResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model RemoveAssetWatchResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveAssetWatchResponseBody(name='body'),
}

async function removeAssetWatch(assetName: string, request: RemoveAssetWatchRequest): RemoveAssetWatchResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeAssetWatchWithOptions(assetName, request, headers, runtime);
}

async function removeAssetWatchWithOptions(assetName: string, request: RemoveAssetWatchRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveAssetWatchResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.assetType)) {
    query['asset_type'] = request.assetType;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveAssetWatch',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/asset-watch/${OpenApiUtil.getEncodeParam(assetName)}/commands/remove-watch`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RemoveDependLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model RemoveDependLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveDependLibraryResponseBody(name='body'),
}

async function removeDependLibrary(libraryName: string): RemoveDependLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return removeDependLibraryWithOptions(libraryName, headers, runtime);
}

async function removeDependLibraryWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): RemoveDependLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'RemoveDependLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/commands/remove-dependency`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model RevokeRoleRequest {
  body?: RoleRevokeCmd(name='body'),
}

model RevokeRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
}

async function revokeRole(roleId: string, request: RevokeRoleRequest): RevokeRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return revokeRoleWithOptions(roleId, request, headers, runtime);
}

async function revokeRoleWithOptions(roleId: string, request: RevokeRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RevokeRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RevokeRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/${OpenApiUtil.getEncodeParam(roleId)}/commands/revoke`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'none',
  };
  return callApi(params, req, runtime);
}

model RollbackPdpServiceRequest {
  body?: DeploymentRollbackCmd(name='body'),
}

model RollbackPdpServiceResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpServiceDeployment(name='result'),
}

model RollbackPdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RollbackPdpServiceResponseBody(name='body'),
}

async function rollbackPdpService(request: RollbackPdpServiceRequest): RollbackPdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return rollbackPdpServiceWithOptions(request, headers, runtime);
}

async function rollbackPdpServiceWithOptions(request: RollbackPdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): RollbackPdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'RollbackPdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments/commands/rollback`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchAssetsRequest {
  assetIndustrys?: [ string ](name='asset_industrys'),
  assetName?: string(name='asset_name'),
  assetTypes?: [ string ](name='asset_types'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model SearchAssetsShrinkRequest {
  assetIndustrysShrink?: string(name='asset_industrys'),
  assetName?: string(name='asset_name'),
  assetTypesShrink?: string(name='asset_types'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
}

model SearchAssetsResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
  DTO
](name='result'),
}

model SearchAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchAssetsResponseBody(name='body'),
}

async function searchAssets(request: SearchAssetsRequest): SearchAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchAssetsWithOptions(request, headers, runtime);
}

async function searchAssetsWithOptions(tmpReq: SearchAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchAssetsResponse {
  Util.validateModel(tmpReq);
  var request = new SearchAssetsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.assetIndustrys)) {
    request.assetIndustrysShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.assetIndustrys, 'asset_industrys', 'json');
  }
  if (!Util.isUnset(tmpReq.assetTypes)) {
    request.assetTypesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.assetTypes, 'asset_types', 'json');
  }
  var query : map[string]any = {};
  if (!Util.isUnset(request.assetIndustrysShrink)) {
    query['asset_industrys'] = request.assetIndustrysShrink;
  }
  if (!Util.isUnset(request.assetName)) {
    query['asset_name'] = request.assetName;
  }
  if (!Util.isUnset(request.assetTypesShrink)) {
    query['asset_types'] = request.assetTypesShrink;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets/commands/search-asset`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SearchPbcAssetsRequest {
  industry?: string(name='industry'),
  keyword?: string(name='keyword'),
  orderBy?: string(name='order_by'),
  orderDirection?: string(name='order_direction'),
  pageNumber?: int32(name='page_number'),
  pageSize?: int32(name='page_size'),
  type?: string(name='type'),
}

model SearchPbcAssetsResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcListResult(name='result'),
}

model SearchPbcAssetsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchPbcAssetsResponseBody(name='body'),
}

async function searchPbcAssets(request: SearchPbcAssetsRequest): SearchPbcAssetsResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return searchPbcAssetsWithOptions(request, headers, runtime);
}

async function searchPbcAssetsWithOptions(request: SearchPbcAssetsRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SearchPbcAssetsResponse {
  Util.validateModel(request);
  var query : map[string]any = {};
  if (!Util.isUnset(request.industry)) {
    query['industry'] = request.industry;
  }
  if (!Util.isUnset(request.keyword)) {
    query['keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.orderBy)) {
    query['order_by'] = request.orderBy;
  }
  if (!Util.isUnset(request.orderDirection)) {
    query['order_direction'] = request.orderDirection;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['page_number'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['page_size'] = request.pageSize;
  }
  if (!Util.isUnset(request.type)) {
    query['type'] = request.type;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchPbcAssets',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/markets/commands/search`,
    method = 'GET',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model SubscribePbcRequest {
  body?: PbcSubscribe(name='body'),
}

model SubscribePbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: [
    Pbc
  ](name='result'),
}

model SubscribePbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SubscribePbcResponseBody(name='body'),
}

async function subscribePbc(pbcName: string, request: SubscribePbcRequest): SubscribePbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return subscribePbcWithOptions(pbcName, request, headers, runtime);
}

async function subscribePbcWithOptions(pbcName: string, request: SubscribePbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): SubscribePbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'SubscribePbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/commands/subscribe`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TransferEnterpriseRequest {
  body?: EnterpriseTransferCmd(name='body'),
}

model TransferEnterpriseResponseBody = {
  requestId?: string(name='requestId'),
  result?: Enterprise(name='result'),
}

model TransferEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransferEnterpriseResponseBody(name='body'),
}

async function transferEnterprise(enterpriseId: string, request: TransferEnterpriseRequest): TransferEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return transferEnterpriseWithOptions(enterpriseId, request, headers, runtime);
}

async function transferEnterpriseWithOptions(enterpriseId: string, request: TransferEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TransferEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TransferEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}/commands/transfer`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model TriggerDeploymentRequest {
  body?: DeploymentTriggerCmd(name='body'),
}

model TriggerDeploymentResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpServiceDeployment(name='result'),
}

model TriggerDeploymentResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TriggerDeploymentResponseBody(name='body'),
}

async function triggerDeployment(request: TriggerDeploymentRequest): TriggerDeploymentResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return triggerDeploymentWithOptions(request, headers, runtime);
}

async function triggerDeploymentWithOptions(request: TriggerDeploymentRequest, headers: map[string]string, runtime: Util.RuntimeOptions): TriggerDeploymentResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'TriggerDeployment',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/deployments`,
    method = 'POST',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpShelfLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: CatalogCommonResult(name='result'),
}

model UpShelfLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpShelfLibraryResponseBody(name='body'),
}

async function upShelfLibrary(libraryName: string): UpShelfLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upShelfLibraryWithOptions(libraryName, headers, runtime);
}

async function upShelfLibraryWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpShelfLibraryResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpShelfLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/commands/up-shelf-library`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpShelfPbcVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: boolean(name='result'),
}

model UpShelfPbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpShelfPbcVersionResponseBody(name='body'),
}

async function upShelfPbcVersion(pbcName: string, version: string): UpShelfPbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return upShelfPbcVersionWithOptions(pbcName, version, headers, runtime);
}

async function upShelfPbcVersionWithOptions(pbcName: string, version: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpShelfPbcVersionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpShelfPbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/commands/upShelf`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateDeveloperRequest {
  body?: DeveloperInfoUpdateCmd(name='body'),
}

model UpdateDeveloperResponseBody = {
  requestId?: string(name='requestId'),
  result?: Developer(name='result'),
}

model UpdateDeveloperResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeveloperResponseBody(name='body'),
}

async function updateDeveloper(accountId: string, request: UpdateDeveloperRequest): UpdateDeveloperResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateDeveloperWithOptions(accountId, request, headers, runtime);
}

async function updateDeveloperWithOptions(accountId: string, request: UpdateDeveloperRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateDeveloperResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeveloper',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/developers/${OpenApiUtil.getEncodeParam(accountId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateEnterpriseRequest {
  body?: EnterpriseInfoUpdateCmd(name='body'),
}

model UpdateEnterpriseResponseBody = {
  requestId?: string(name='requestId'),
  result?: Enterprise(name='result'),
}

model UpdateEnterpriseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEnterpriseResponseBody(name='body'),
}

async function updateEnterprise(enterpriseId: string, request: UpdateEnterpriseRequest): UpdateEnterpriseResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateEnterpriseWithOptions(enterpriseId, request, headers, runtime);
}

async function updateEnterpriseWithOptions(enterpriseId: string, request: UpdateEnterpriseRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateEnterpriseResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEnterprise',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/enterprises/${OpenApiUtil.getEncodeParam(enterpriseId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLibraryRequest {
}

model UpdateLibraryResponseBody = {
  requestId?: string(name='requestId'),
  result?: Library(name='result'),
}

model UpdateLibraryResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLibraryResponseBody(name='body'),
}

async function updateLibrary(request: UpdateLibraryRequest): UpdateLibraryResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibraryWithOptions(request, headers, runtime);
}

async function updateLibraryWithOptions(request: UpdateLibraryRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibraryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibrary',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLibraryInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibraryInstruction(name='result'),
}

model UpdateLibraryInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLibraryInstructionResponseBody(name='body'),
}

async function updateLibraryInstruction(libraryName: string): UpdateLibraryInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibraryInstructionWithOptions(libraryName, headers, runtime);
}

async function updateLibraryInstructionWithOptions(libraryName: string, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibraryInstructionResponse {
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibraryInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/instructions`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateLibrarySchemaRequest {
  artifactId?: string(name='artifactId'),
  description?: string(name='description'),
  gitGroup?: string(name='gitGroup'),
  groupId?: string(name='groupId'),
  id?: long(name='id'),
  name?: string(name='name'),
  version?: string(name='version'),
}

model UpdateLibrarySchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: LibrarySchema(name='result'),
}

model UpdateLibrarySchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateLibrarySchemaResponseBody(name='body'),
}

async function updateLibrarySchema(libraryName: string, request: UpdateLibrarySchemaRequest): UpdateLibrarySchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateLibrarySchemaWithOptions(libraryName, request, headers, runtime);
}

async function updateLibrarySchemaWithOptions(libraryName: string, request: UpdateLibrarySchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateLibrarySchemaResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.artifactId)) {
    body['artifactId'] = request.artifactId;
  }
  if (!Util.isUnset(request.description)) {
    body['description'] = request.description;
  }
  if (!Util.isUnset(request.gitGroup)) {
    body['gitGroup'] = request.gitGroup;
  }
  if (!Util.isUnset(request.groupId)) {
    body['groupId'] = request.groupId;
  }
  if (!Util.isUnset(request.id)) {
    body['id'] = request.id;
  }
  if (!Util.isUnset(request.name)) {
    body['name'] = request.name;
  }
  if (!Util.isUnset(request.version)) {
    body['version'] = request.version;
  }

  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateLibrarySchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/librarys/${OpenApiUtil.getEncodeParam(libraryName)}/schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePbcApiSchemaRequest {
  body?: PbcApiSchema(name='body'),
}

model UpdatePbcApiSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcApiSchema(name='result'),
}

model UpdatePbcApiSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePbcApiSchemaResponseBody(name='body'),
}

async function updatePbcApiSchema(pbcName: string, version: string, request: UpdatePbcApiSchemaRequest): UpdatePbcApiSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcApiSchemaWithOptions(pbcName, version, request, headers, runtime);
}

async function updatePbcApiSchemaWithOptions(pbcName: string, version: string, request: UpdatePbcApiSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcApiSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcApiSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/api-schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePbcInstructionRequest {
  body?: PbcInstruction(name='body'),
}

model UpdatePbcInstructionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcInstruction(name='result'),
}

model UpdatePbcInstructionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePbcInstructionResponseBody(name='body'),
}

async function updatePbcInstruction(pbcName: string, version: string, request: UpdatePbcInstructionRequest): UpdatePbcInstructionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcInstructionWithOptions(pbcName, version, request, headers, runtime);
}

async function updatePbcInstructionWithOptions(pbcName: string, version: string, request: UpdatePbcInstructionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcInstructionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcInstruction',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/instruction`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePbcSchemaRequest {
  body?: PbcSchema(name='body'),
}

model UpdatePbcSchemaResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcSchema(name='result'),
}

model UpdatePbcSchemaResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePbcSchemaResponseBody(name='body'),
}

async function updatePbcSchema(pbcName: string, version: string, request: UpdatePbcSchemaRequest): UpdatePbcSchemaResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcSchemaWithOptions(pbcName, version, request, headers, runtime);
}

async function updatePbcSchemaWithOptions(pbcName: string, version: string, request: UpdatePbcSchemaRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcSchemaResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcSchema',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}/schemas`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePbcVersionRequest {
  body?: PbcVersion(name='body'),
}

model UpdatePbcVersionResponseBody = {
  requestId?: string(name='requestId'),
  result?: PbcVersion(name='result'),
}

model UpdatePbcVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePbcVersionResponseBody(name='body'),
}

async function updatePbcVersion(pbcName: string, version: string, request: UpdatePbcVersionRequest): UpdatePbcVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePbcVersionWithOptions(pbcName, version, request, headers, runtime);
}

async function updatePbcVersionWithOptions(pbcName: string, version: string, request: UpdatePbcVersionRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePbcVersionResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePbcVersion',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/catalog/v1/pbcs/${OpenApiUtil.getEncodeParam(pbcName)}/versions/${OpenApiUtil.getEncodeParam(version)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePdpConfigRequest {
  body?: PdpConfigUpdateCmd(name='body'),
}

model UpdatePdpConfigResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpConfig(name='result'),
}

model UpdatePdpConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePdpConfigResponseBody(name='body'),
}

async function updatePdpConfig(request: UpdatePdpConfigRequest): UpdatePdpConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpConfigWithOptions(request, headers, runtime);
}

async function updatePdpConfigWithOptions(request: UpdatePdpConfigRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpConfigResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpConfig',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/configs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePdpPbcRequest {
  body?: PdpPbcUpdateCmd(name='body'),
}

model UpdatePdpPbcResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpPbc(name='result'),
}

model UpdatePdpPbcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePdpPbcResponseBody(name='body'),
}

async function updatePdpPbc(request: UpdatePdpPbcRequest): UpdatePdpPbcResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpPbcWithOptions(request, headers, runtime);
}

async function updatePdpPbcWithOptions(request: UpdatePdpPbcRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpPbcResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpPbc',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-pbc/v1/pbcs`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdatePdpServiceRequest {
  body?: PdpServiceUpdateCmd(name='body'),
}

model UpdatePdpServiceResponseBody = {
  requestId?: string(name='requestId'),
  result?: PdpService(name='result'),
}

model UpdatePdpServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePdpServiceResponseBody(name='body'),
}

async function updatePdpService(request: UpdatePdpServiceRequest): UpdatePdpServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updatePdpServiceWithOptions(request, headers, runtime);
}

async function updatePdpServiceWithOptions(request: UpdatePdpServiceRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdatePdpServiceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePdpService',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/pdp-service/v1/services`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

model UpdateRoleRequest {
  body?: RoleInfoUpdateCmd(name='body'),
}

model UpdateRoleResponseBody = {
  requestId?: string(name='requestId'),
  result?: Role(name='result'),
}

model UpdateRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateRoleResponseBody(name='body'),
}

async function updateRole(roleId: string, request: UpdateRoleRequest): UpdateRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  var headers : map[string]string = {};
  return updateRoleWithOptions(roleId, request, headers, runtime);
}

async function updateRoleWithOptions(roleId: string, request: UpdateRoleRequest, headers: map[string]string, runtime: Util.RuntimeOptions): UpdateRoleResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    headers = headers,
    body = OpenApiUtil.parseToMap(request.body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateRole',
    version = '2021-11-15',
    protocol = 'HTTPS',
    pathname = `/manager/v1/roles/role-id/${OpenApiUtil.getEncodeParam(roleId)}`,
    method = 'PUT',
    authType = 'AK',
    style = 'ROA',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

