/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'schedulerx.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'schedulerx.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'schedulerx.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'schedulerx.cn-shenzhen.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('schedulerx2', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model BatchDeleteJobsRequest {
  groupId?: string(name='GroupId'),
  jobIdList?: [ long ](name='JobIdList'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model BatchDeleteJobsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteJobsResponseBody(name='body'),
}

async function batchDeleteJobsWithOptions(request: BatchDeleteJobsRequest, runtime: Util.RuntimeOptions): BatchDeleteJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteJobs(request: BatchDeleteJobsRequest): BatchDeleteJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteJobsWithOptions(request, runtime);
}

model BatchDisableJobsRequest {
  groupId?: string(name='GroupId'),
  jobIdList?: [ long ](name='JobIdList'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model BatchDisableJobsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchDisableJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDisableJobsResponseBody(name='body'),
}

async function batchDisableJobsWithOptions(request: BatchDisableJobsRequest, runtime: Util.RuntimeOptions): BatchDisableJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDisableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDisableJobs(request: BatchDisableJobsRequest): BatchDisableJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDisableJobsWithOptions(request, runtime);
}

model BatchEnableJobsRequest {
  groupId?: string(name='GroupId'),
  jobIdList?: [ long ](name='JobIdList'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model BatchEnableJobsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model BatchEnableJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchEnableJobsResponseBody(name='body'),
}

async function batchEnableJobsWithOptions(request: BatchEnableJobsRequest, runtime: Util.RuntimeOptions): BatchEnableJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchEnableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchEnableJobs(request: BatchEnableJobsRequest): BatchEnableJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchEnableJobsWithOptions(request, runtime);
}

model CreateAppGroupRequest {
  appKey?: string(name='AppKey'),
  appName?: string(name='AppName'),
  description?: string(name='Description'),
  groupId?: string(name='GroupId'),
  maxJobs?: int32(name='MaxJobs'),
  monitorConfigJson?: string(name='MonitorConfigJson'),
  monitorContactsJson?: string(name='MonitorContactsJson'),
  namespace?: string(name='Namespace'),
  namespaceName?: string(name='NamespaceName'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  scheduleBusyWorkers?: boolean(name='ScheduleBusyWorkers'),
}

model CreateAppGroupResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appGroupId?: long(name='AppGroupId'),
    appKey?: string(name='AppKey'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateAppGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppGroupResponseBody(name='body'),
}

async function createAppGroupWithOptions(request: CreateAppGroupRequest, runtime: Util.RuntimeOptions): CreateAppGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppGroupWithOptions(request, runtime);
}

model CreateJobRequest {
  attemptInterval?: int32(name='AttemptInterval'),
  calendar?: string(name='Calendar'),
  className?: string(name='ClassName'),
  consumerSize?: int32(name='ConsumerSize'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding'),
      userMail?: string(name='UserMail'),
      userName?: string(name='UserName'),
      userPhone?: string(name='UserPhone'),
    }
  ](name='ContactInfo'),
  content?: string(name='Content'),
  dataOffset?: int32(name='DataOffset'),
  description?: string(name='Description'),
  dispatcherSize?: int32(name='DispatcherSize'),
  executeMode?: string(name='ExecuteMode'),
  failEnable?: boolean(name='FailEnable'),
  groupId?: string(name='GroupId'),
  jarUrl?: string(name='JarUrl'),
  jobType?: string(name='JobType'),
  maxAttempt?: int32(name='MaxAttempt'),
  maxConcurrency?: int32(name='MaxConcurrency'),
  missWorkerEnable?: boolean(name='MissWorkerEnable'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  pageSize?: int32(name='PageSize'),
  parameters?: string(name='Parameters'),
  queueSize?: int32(name='QueueSize'),
  regionId?: string(name='RegionId'),
  sendChannel?: string(name='SendChannel'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt'),
  timeExpression?: string(name='TimeExpression'),
  timeType?: int32(name='TimeType'),
  timeout?: long(name='Timeout'),
  timeoutEnable?: boolean(name='TimeoutEnable'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable'),
}

model CreateJobResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobId?: long(name='JobId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(request: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!Util.isUnset(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!Util.isUnset(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!Util.isUnset(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!Util.isUnset(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jarUrl)) {
    body['JarUrl'] = request.jarUrl;
  }
  if (!Util.isUnset(request.jobType)) {
    body['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!Util.isUnset(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!Util.isUnset(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!Util.isUnset(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!Util.isUnset(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  description?: string(name='Description'),
  name?: string(name='Name'),
  regionId?: string(name='RegionId'),
  source?: string(name='Source'),
  uid?: string(name='Uid'),
}

model CreateNamespaceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    namespaceUid?: string(name='NamespaceUid'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model DeleteJobRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model DeleteJobResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteWorkflowRequest {
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  workflowId?: long(name='WorkflowId'),
}

model DeleteWorkflowResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWorkflowResponseBody(name='body'),
}

async function deleteWorkflowWithOptions(request: DeleteWorkflowRequest, runtime: Util.RuntimeOptions): DeleteWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWorkflow(request: DeleteWorkflowRequest): DeleteWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWorkflowWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  regions?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DesignateWorkersRequest {
  designateType?: int32(name='DesignateType', description='指定机器的类型'),
  groupId?: string(name='GroupId', description='应用分组ID'),
  jobId?: long(name='JobId', description='任务ID'),
  labels?: string(name='Labels', description='指定label列表json格式'),
  namespace?: string(name='Namespace', description='命名空间UID'),
  namespaceSource?: string(name='NamespaceSource', description='命名空间来源'),
  regionId?: string(name='RegionId'),
  transferable?: boolean(name='Transferable', description='是否故障转移'),
  workers?: string(name='Workers', description='指定机器列表json格式'),
}

model DesignateWorkersResponseBody = {
  code?: int32(name='Code', description='错误码'),
  message?: string(name='Message', description='错误信息'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='是否成功'),
}

model DesignateWorkersResponse = {
  headers: map[string]string(name='headers'),
  body: DesignateWorkersResponseBody(name='body'),
}

async function designateWorkersWithOptions(request: DesignateWorkersRequest, runtime: Util.RuntimeOptions): DesignateWorkersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DesignateWorkers',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function designateWorkers(request: DesignateWorkersRequest): DesignateWorkersResponse {
  var runtime = new Util.RuntimeOptions{};
  return designateWorkersWithOptions(request, runtime);
}

model DisableJobRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model DisableJobResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableJobResponse = {
  headers: map[string]string(name='headers'),
  body: DisableJobResponseBody(name='body'),
}

async function disableJobWithOptions(request: DisableJobRequest, runtime: Util.RuntimeOptions): DisableJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableJob(request: DisableJobRequest): DisableJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableJobWithOptions(request, runtime);
}

model DisableWorkflowRequest {
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  workflowId?: long(name='WorkflowId'),
}

model DisableWorkflowResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DisableWorkflowResponseBody(name='body'),
}

async function disableWorkflowWithOptions(request: DisableWorkflowRequest, runtime: Util.RuntimeOptions): DisableWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableWorkflow(request: DisableWorkflowRequest): DisableWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableWorkflowWithOptions(request, runtime);
}

model EnableJobRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model EnableJobResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableJobResponse = {
  headers: map[string]string(name='headers'),
  body: EnableJobResponseBody(name='body'),
}

async function enableJobWithOptions(request: EnableJobRequest, runtime: Util.RuntimeOptions): EnableJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableJob(request: EnableJobRequest): EnableJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableJobWithOptions(request, runtime);
}

model EnableWorkflowRequest {
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  workflowId?: long(name='WorkflowId'),
}

model EnableWorkflowResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: EnableWorkflowResponseBody(name='body'),
}

async function enableWorkflowWithOptions(request: EnableWorkflowRequest, runtime: Util.RuntimeOptions): EnableWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableWorkflow(request: EnableWorkflowRequest): EnableWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableWorkflowWithOptions(request, runtime);
}

model ExecuteJobRequest {
  checkJobStatus?: boolean(name='CheckJobStatus'),
  designateType?: int32(name='DesignateType', description='指定机器类型：1.workerAddr; 2. label'),
  groupId?: string(name='GroupId'),
  instanceParameters?: string(name='InstanceParameters'),
  jobId?: long(name='JobId'),
  label?: string(name='Label', description='指定机器的标签'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  worker?: string(name='Worker', description='指定机器的workerAddr'),
}

model ExecuteJobResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobInstanceId?: long(name='JobInstanceId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteJobResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteJobResponseBody(name='body'),
}

async function executeJobWithOptions(request: ExecuteJobRequest, runtime: Util.RuntimeOptions): ExecuteJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeJob(request: ExecuteJobRequest): ExecuteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeJobWithOptions(request, runtime);
}

model ExecuteWorkflowRequest {
  groupId?: string(name='GroupId'),
  instanceParameters?: string(name='InstanceParameters'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  workflowId?: long(name='WorkflowId'),
}

model ExecuteWorkflowResponseBody = {
  code?: int32(name='Code'),
  data?: {
    wfInstanceId?: long(name='WfInstanceId'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteWorkflowResponseBody(name='body'),
}

async function executeWorkflowWithOptions(request: ExecuteWorkflowRequest, runtime: Util.RuntimeOptions): ExecuteWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeWorkflow(request: ExecuteWorkflowRequest): ExecuteWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeWorkflowWithOptions(request, runtime);
}

model GetJobInfoRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  jobName?: string(name='JobName'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model GetJobInfoResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobConfigInfo?: {
      attemptInterval?: int32(name='AttemptInterval'),
      className?: string(name='ClassName'),
      content?: string(name='Content'),
      description?: string(name='Description'),
      executeMode?: string(name='ExecuteMode'),
      jarUrl?: string(name='JarUrl'),
      jobId?: long(name='JobId'),
      jobMonitorInfo?: {
        contactInfo?: [ 
          {
            ding?: string(name='Ding'),
            userMail?: string(name='UserMail'),
            userName?: string(name='UserName'),
            userPhone?: string(name='UserPhone'),
          }
        ](name='ContactInfo'),
        monitorConfig?: {
          failEnable?: boolean(name='FailEnable'),
          missWorkerEnable?: boolean(name='MissWorkerEnable'),
          sendChannel?: string(name='SendChannel'),
          timeout?: long(name='Timeout'),
          timeoutEnable?: boolean(name='TimeoutEnable'),
          timeoutKillEnable?: boolean(name='TimeoutKillEnable'),
        }(name='MonitorConfig'),
      }(name='JobMonitorInfo'),
      mapTaskXAttrs?: {
        consumerSize?: int32(name='ConsumerSize'),
        dispatcherSize?: int32(name='DispatcherSize'),
        pageSize?: int32(name='PageSize'),
        queueSize?: int32(name='QueueSize'),
        taskAttemptInterval?: int32(name='TaskAttemptInterval'),
        taskMaxAttempt?: int32(name='TaskMaxAttempt'),
      }(name='MapTaskXAttrs'),
      maxAttempt?: int32(name='MaxAttempt'),
      maxConcurrency?: string(name='MaxConcurrency'),
      name?: string(name='Name'),
      parameters?: string(name='Parameters'),
      status?: int32(name='Status'),
      timeConfig?: {
        calendar?: string(name='Calendar'),
        dataOffset?: int32(name='DataOffset'),
        timeExpression?: string(name='TimeExpression'),
        timeType?: int32(name='TimeType'),
      }(name='TimeConfig'),
    }(name='JobConfigInfo'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInfoResponseBody(name='body'),
}

async function getJobInfoWithOptions(request: GetJobInfoRequest, runtime: Util.RuntimeOptions): GetJobInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInfo',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInfoWithOptions(request, runtime);
}

model GetJobInstanceRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  jobInstanceId?: long(name='JobInstanceId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
}

model GetJobInstanceResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobInstanceDetail?: {
      dataTime?: string(name='DataTime'),
      endTime?: string(name='EndTime'),
      executor?: string(name='Executor'),
      instanceId?: long(name='InstanceId'),
      jobId?: long(name='JobId'),
      progress?: string(name='Progress'),
      result?: string(name='Result'),
      scheduleTime?: string(name='ScheduleTime'),
      startTime?: string(name='StartTime'),
      status?: int32(name='Status'),
      timeType?: int32(name='TimeType'),
      triggerType?: int32(name='TriggerType'),
      workAddr?: string(name='WorkAddr'),
    }(name='JobInstanceDetail'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInstanceResponseBody(name='body'),
}

async function getJobInstanceWithOptions(request: GetJobInstanceRequest, runtime: Util.RuntimeOptions): GetJobInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInstance(request: GetJobInstanceRequest): GetJobInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInstanceWithOptions(request, runtime);
}

model GetJobInstanceListRequest {
  groupId?: string(name='GroupId'),
  jobId?: long(name='JobId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model GetJobInstanceListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobInstanceDetails?: [ 
      {
        dataTime?: string(name='DataTime'),
        endTime?: string(name='EndTime'),
        executor?: string(name='Executor'),
        instanceId?: long(name='InstanceId'),
        jobId?: long(name='JobId'),
        progress?: string(name='Progress'),
        result?: string(name='Result'),
        scheduleTime?: string(name='ScheduleTime'),
        startTime?: string(name='StartTime'),
        status?: int32(name='Status'),
        timeType?: int32(name='TimeType'),
        triggerType?: int32(name='TriggerType'),
        workAddr?: string(name='WorkAddr'),
      }
    ](name='JobInstanceDetails'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetJobInstanceListResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInstanceListResponseBody(name='body'),
}

async function getJobInstanceListWithOptions(request: GetJobInstanceListRequest, runtime: Util.RuntimeOptions): GetJobInstanceListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInstanceList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInstanceList(request: GetJobInstanceListRequest): GetJobInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInstanceListWithOptions(request, runtime);
}

model GetWorkFlowRequest {
  groupId?: string(name='GroupId', description='应用分组ID'),
  namespace?: string(name='Namespace', description='命名空间uid'),
  namespaceSource?: string(name='NamespaceSource', description='命名空间来源'),
  regionId?: string(name='RegionId'),
  workflowId?: long(name='WorkflowId', description='工作流ID'),
}

model GetWorkFlowResponseBody = {
  code?: int32(name='Code', description='错误码'),
  data?: {
    workFlowInfo?: {
      description?: string(name='Description', description='工作流描述'),
      name?: string(name='Name', description='工作流名称'),
      status?: string(name='Status', description='工作流状态'),
      timeExpression?: string(name='TimeExpression', description='工作流时间表达式'),
      timeType?: string(name='TimeType', description='工作流时间类型'),
      workflowId?: long(name='WorkflowId', description='工作流ID'),
    }(name='WorkFlowInfo', description='工作流基本信息'),
    workFlowNodeInfo?: {
      edges?: [ 
        {
          source?: long(name='Source', description='起始任务ID'),
          target?: long(name='Target', description='目的任务ID'),
        }
      ](name='Edges', description='工作流边列表'),
      nodes?: [ 
        {
          id?: long(name='Id', description='任务ID'),
          label?: string(name='Label', description='任务名称'),
          status?: int32(name='Status', description='任务状态'),
        }
      ](name='Nodes', description='工作流节点列表'),
    }(name='WorkFlowNodeInfo', description='工作流节点信息'),
  }(name='Data', description='工作流的数据'),
  message?: string(name='Message', description='错误信息'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success', description='会否成功'),
}

model GetWorkFlowResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkFlowResponseBody(name='body'),
}

async function getWorkFlowWithOptions(request: GetWorkFlowRequest, runtime: Util.RuntimeOptions): GetWorkFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkFlow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkFlow(request: GetWorkFlowRequest): GetWorkFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkFlowWithOptions(request, runtime);
}

model GetWorkerListRequest {
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model GetWorkerListResponseBody = {
  code?: int32(name='Code'),
  data?: {
    workerInfos?: [ 
      {
        ip?: string(name='Ip'),
        label?: string(name='Label'),
        port?: int32(name='Port'),
        starter?: string(name='Starter'),
        version?: string(name='Version'),
        workerAddress?: string(name='WorkerAddress'),
      }
    ](name='WorkerInfos'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='Id of the request'),
  success?: boolean(name='Success'),
}

model GetWorkerListResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkerListResponseBody(name='body'),
}

async function getWorkerListWithOptions(request: GetWorkerListRequest, runtime: Util.RuntimeOptions): GetWorkerListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkerList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkerList(request: GetWorkerListRequest): GetWorkerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkerListWithOptions(request, runtime);
}

model GrantPermissionRequest {
  grantOption?: boolean(name='GrantOption'),
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
  userName?: string(name='UserName'),
}

model GrantPermissionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GrantPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: GrantPermissionResponseBody(name='body'),
}

async function grantPermissionWithOptions(request: GrantPermissionRequest, runtime: Util.RuntimeOptions): GrantPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.grantOption)) {
    query['GrantOption'] = request.grantOption;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantPermission(request: GrantPermissionRequest): GrantPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantPermissionWithOptions(request, runtime);
}

model ListGroupsRequest {
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model ListGroupsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    appGroups?: [ 
      {
        appKey?: string(name='AppKey'),
        appName?: string(name='AppName'),
        description?: string(name='Description'),
        groupId?: string(name='GroupId'),
      }
    ](name='AppGroups'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListJobsRequest {
  groupId?: string(name='GroupId'),
  jobName?: string(name='JobName'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  status?: string(name='Status'),
}

model ListJobsResponseBody = {
  code?: int32(name='Code'),
  data?: {
    jobs?: [ 
      {
        attemptInterval?: int32(name='AttemptInterval'),
        className?: string(name='ClassName'),
        content?: string(name='Content'),
        description?: string(name='Description'),
        executeMode?: string(name='ExecuteMode'),
        jarUrl?: string(name='JarUrl'),
        jobId?: long(name='JobId'),
        jobMonitorInfo?: {
          contactInfo?: [ 
            {
              ding?: string(name='Ding'),
              userMail?: string(name='UserMail'),
              userName?: string(name='UserName'),
              userPhone?: string(name='UserPhone'),
            }
          ](name='ContactInfo'),
          monitorConfig?: {
            failEnable?: boolean(name='FailEnable'),
            missWorkerEnable?: boolean(name='MissWorkerEnable'),
            sendChannel?: string(name='SendChannel'),
            timeout?: long(name='Timeout'),
            timeoutEnable?: boolean(name='TimeoutEnable'),
            timeoutKillEnable?: boolean(name='TimeoutKillEnable'),
          }(name='MonitorConfig'),
        }(name='JobMonitorInfo'),
        mapTaskXAttrs?: {
          consumerSize?: int32(name='ConsumerSize'),
          dispatcherSize?: int32(name='DispatcherSize'),
          pageSize?: int32(name='PageSize'),
          queueSize?: int32(name='QueueSize'),
          taskAttemptInterval?: int32(name='TaskAttemptInterval'),
          taskMaxAttempt?: int32(name='TaskMaxAttempt'),
        }(name='MapTaskXAttrs'),
        maxAttempt?: int32(name='MaxAttempt'),
        maxConcurrency?: string(name='MaxConcurrency'),
        name?: string(name='Name'),
        parameters?: string(name='Parameters'),
        status?: int32(name='Status'),
        timeConfig?: {
          calendar?: string(name='Calendar'),
          dataOffset?: int32(name='DataOffset'),
          timeExpression?: string(name='TimeExpression'),
          timeType?: int32(name='TimeType'),
        }(name='TimeConfig'),
      }
    ](name='Jobs'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListNamespacesRequest {
  regionId?: string(name='RegionId'),
}

model ListNamespacesResponseBody = {
  code?: int32(name='Code'),
  data?: {
    namespaces?: [ 
      {
        description?: string(name='Description'),
        name?: string(name='Name'),
        UId?: string(name='UId'),
      }
    ](name='Namespaces'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespacesResponseBody(name='body'),
}

async function listNamespacesWithOptions(request: ListNamespacesRequest, runtime: Util.RuntimeOptions): ListNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespaces',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNamespaces(request: ListNamespacesRequest): ListNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespacesWithOptions(request, runtime);
}

model RevokePermissionRequest {
  groupId?: string(name='GroupId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
  userId?: string(name='UserId'),
}

model RevokePermissionResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model RevokePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokePermissionResponseBody(name='body'),
}

async function revokePermissionWithOptions(request: RevokePermissionRequest, runtime: Util.RuntimeOptions): RevokePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokePermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokePermission(request: RevokePermissionRequest): RevokePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokePermissionWithOptions(request, runtime);
}

model StopInstanceRequest {
  groupId?: string(name='GroupId'),
  instanceId?: long(name='InstanceId'),
  jobId?: long(name='JobId'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  regionId?: string(name='RegionId'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model UpdateJobRequest {
  attemptInterval?: int32(name='AttemptInterval'),
  calendar?: string(name='Calendar'),
  className?: string(name='ClassName'),
  consumerSize?: int32(name='ConsumerSize'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding'),
      userMail?: string(name='UserMail'),
      userName?: string(name='UserName'),
      userPhone?: string(name='UserPhone'),
    }
  ](name='ContactInfo'),
  content?: string(name='Content'),
  dataOffset?: int32(name='DataOffset'),
  description?: string(name='Description'),
  dispatcherSize?: int32(name='DispatcherSize'),
  executeMode?: string(name='ExecuteMode'),
  failEnable?: boolean(name='FailEnable'),
  groupId?: string(name='GroupId'),
  jarUrl?: string(name='JarUrl'),
  jobId?: long(name='JobId'),
  maxAttempt?: int32(name='MaxAttempt'),
  maxConcurrency?: int32(name='MaxConcurrency'),
  missWorkerEnable?: boolean(name='MissWorkerEnable'),
  name?: string(name='Name'),
  namespace?: string(name='Namespace'),
  namespaceSource?: string(name='NamespaceSource'),
  pageSize?: int32(name='PageSize'),
  parameters?: string(name='Parameters'),
  queueSize?: int32(name='QueueSize'),
  regionId?: string(name='RegionId'),
  sendChannel?: string(name='SendChannel'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt'),
  timeExpression?: string(name='TimeExpression'),
  timeType?: int32(name='TimeType'),
  timeout?: long(name='Timeout'),
  timeoutEnable?: boolean(name='TimeoutEnable'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable'),
}

model UpdateJobResponseBody = {
  code?: int32(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateJobResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateJobResponseBody(name='body'),
}

async function updateJobWithOptions(request: UpdateJobRequest, runtime: Util.RuntimeOptions): UpdateJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!Util.isUnset(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!Util.isUnset(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!Util.isUnset(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!Util.isUnset(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jarUrl)) {
    body['JarUrl'] = request.jarUrl;
  }
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!Util.isUnset(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!Util.isUnset(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!Util.isUnset(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!Util.isUnset(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobWithOptions(request, runtime);
}

