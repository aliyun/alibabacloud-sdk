/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'schedulerx.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'schedulerx.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'schedulerx.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'schedulerx.cn-shenzhen.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('schedulerx2', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model BatchDeleteJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Multiple job IDs are separated by commas (,).', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='Schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region to which the job belongs.', example='cn-hangzhou'),
}

model BatchDeleteJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether jobs are deleted in batches. Valid values:

*   **true**: Jobs are deleted in batches.
*   **false**: Failed to delete jobs in batches.', example='true'),
}

model BatchDeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchDeleteJobsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchDeleteJobsResponse
 */
async function batchDeleteJobsWithOptions(request: BatchDeleteJobsRequest, runtime: Util.RuntimeOptions): BatchDeleteJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchDeleteJobsRequest
  * @return BatchDeleteJobsResponse
 */
async function batchDeleteJobs(request: BatchDeleteJobsRequest): BatchDeleteJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteJobsWithOptions(request, runtime);
}

model BatchDeleteRouteStrategyRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model BatchDeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='job is not existed, jobId=162837'),
  requestId?: string(name='RequestId', description='Id of the request', example='704A2A61-3681-5568-92F7-2DFCC53F33D1'),
  success?: boolean(name='Success', example='true'),
}

model BatchDeleteRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDeleteRouteStrategyResponseBody(name='body'),
}

async function batchDeleteRouteStrategyWithOptions(request: BatchDeleteRouteStrategyRequest, runtime: Util.RuntimeOptions): BatchDeleteRouteStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDeleteRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function batchDeleteRouteStrategy(request: BatchDeleteRouteStrategyRequest): BatchDeleteRouteStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDeleteRouteStrategyWithOptions(request, runtime);
}

model BatchDisableJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou'),
}

model BatchDisableJobsResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='disable failed jobs=[99341]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model BatchDisableJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchDisableJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchDisableJobsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchDisableJobsResponse
 */
async function batchDisableJobsWithOptions(request: BatchDisableJobsRequest, runtime: Util.RuntimeOptions): BatchDisableJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchDisableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchDisableJobsRequest
  * @return BatchDisableJobsResponse
 */
async function batchDisableJobs(request: BatchDisableJobsRequest): BatchDisableJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchDisableJobsWithOptions(request, runtime);
}

model BatchEnableJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou'),
}

model BatchEnableJobsResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model BatchEnableJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: BatchEnableJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchEnableJobsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return BatchEnableJobsResponse
 */
async function batchEnableJobsWithOptions(request: BatchEnableJobsRequest, runtime: Util.RuntimeOptions): BatchEnableJobsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'BatchEnableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
  * @param request BatchEnableJobsRequest
  * @return BatchEnableJobsResponse
 */
async function batchEnableJobs(request: BatchEnableJobsRequest): BatchEnableJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return batchEnableJobsWithOptions(request, runtime);
}

model CreateAppGroupRequest {
  appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviLcl****'),
  appName?: string(name='AppName', description='The name of the application.', example='DocTest'),
  appType?: int32(name='AppType'),
  description?: string(name='Description', description='The description of the application.', example='Test'),
  enableLog?: boolean(name='EnableLog'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='TestSchedulerx.defaultGroup'),
  maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs.', example='1000'),
  monitorConfigJson?: string(name='MonitorConfigJson', description='The configuration of the alert. The value is a JSON string. For more information about this parameter, see **Additional information about request parameters**.', example='{"sendChannel":"sms,ding"}'),
  monitorContactsJson?: string(name='MonitorContactsJson', description='The configuration of alert contacts. The value is a JSON string.', example='\\[{"userName":"Tom","userPhone":"89756\\*\\*\\*\\*\\*\\*"},{"userName":"Bob","ding":"http://www.example.com"}]'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='Test'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is not supported. You do not need to specify this parameter.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  scheduleBusyWorkers?: boolean(name='ScheduleBusyWorkers', description='Specifies whether to schedule a busy worker.', example='false'),
}

model CreateAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    appGroupId?: long(name='AppGroupId', description='The ID of the job group.', example='6607'),
    appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviL******'),
  }(name='Data', description='The information about the job group.'),
  message?: string(name='Message', description='The error message that is returned only if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='883AFE93-FB03-4FA9-A958-E750C6DE120C'),
  success?: boolean(name='Success', description='Indicates whether the application is created. Valid values:

*   **true**: The application is created.
*   **false**: Failed to create the application.', example='true'),
}

model CreateAppGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAppGroupResponseBody(name='body'),
}

async function createAppGroupWithOptions(request: CreateAppGroupRequest, runtime: Util.RuntimeOptions): CreateAppGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAppGroupWithOptions(request, runtime);
}

model CreateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system attempts to rerun a job. Default value: 30. Unit: seconds.', example='30'),
  calendar?: string(name='Calendar', description='When the Time type parameter is set to cron, you can specify a custom calendar.', example='This parameter is not supported. You do not need to specify this parameter.'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This field is available only when you select a java job. In this case, you must enter a full path.', example='com.alibaba.schedulerx.test.helloworld'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a single worker at a time. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot. For more information, see [DingTalk development documentation](https://open.dingtalk.com/document/org/application-types).', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the alert contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the alert contact.', example='Tom'),
      userPhone?: string(name='UserPhone', description='The mobile phone number of the alert contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information of the job contact.'),
  content?: string(name='Content', description='The script code content that is required when you set the job type to **python**, **shell**, or **go**.', example='echo \\"hello\\"'),
  dataOffset?: int32(name='DataOffset', description='When the Time type parameter is set to cron, you can specify a time offset. Unit: seconds.', example='2400'),
  description?: string(name='Description', description='The description of the job.', example='Test'),
  dispatcherSize?: int32(name='DispatcherSize', description='Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  executeMode?: string(name='ExecuteMode', description='The execution mode of the job. The following execution modes are supported:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **sharding**: The job runs in sharding mode.', example='standalone'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to turn on Failure alarm. Valid values:

*   **true**: Turn on Failure alarm.
*   **false**: Turn off Failure alarm.', example='false'),
  failTimes?: int32(name='FailTimes'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  jobType?: string(name='JobType', description='The type of the job. The following job types are supported:

*   java
*   python
*   shell
*   go
*   http
*   xxljob
*   dataworks
*   k8s
*   springschedule', example='java'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of attempts that the system can make when an error occurs on a job. You can specify this parameter based on your business requirements. Default value: 0.', example='0'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of instances that the system can run at the same time. Default value: 1. When you set this parameter to 1, if the current job does not end, the system will not run the next job even if the runtime is reached.', example='1'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to turn on No machine alarm available.

*   **true**: Turn on No machine alarm available.
*   **false**: Turn off No machine alarm available.', example='false'),
  name?: string(name='Name', description='The name of the job.', example='helloworld'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  pageSize?: int32(name='PageSize', description='The number of subtasks that can be pulled at a time. Default value: 100. This parameter is an advanced configuration item of MapReduce job.', example='100'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when the job is running.', example='test'),
  queueSize?: int32(name='QueueSize', description='The maximum number of subtask queues that you can cache. Default value: 10000. This parameter is an advanced configuration item of the MapReduce job.', example='10000'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  sendChannel?: string(name='SendChannel', description='The channel for sending alerts. Only SMS messages are supported. Set the value to sms.', example='sms'),
  status?: int32(name='Status', description='0: disabled. 1: enabled. Default value: 1.', example='1'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system can rerun the subtask when the subtask fails. Default value: 0. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries that the system can perform when the subtask fails. Default value: 0. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression according to the selected time type.

*   **cron**: Specify a standard Cron expression. You can verify the expression online after you specify the expression.
*   **api**: No time expression is available.
*   **fixed_rate**: Specify a fixed frequency value. Unit: seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   **second_delay**: Specify a delay after which you can run a job. You can specify a value from 1 to 60. Unit: seconds.
*   **one_time**: Specify a time in the format of yyyy-MM-dd HH:mm:ss or specify a timestamp in milliseconds. Example: 2022-10-10 10:10:00.', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', description='The type of time. The following time types are supported:

*   **cron**: 1
*   **fixed_rate**: 3
*   **second_delay**: 4
*   **one_time**: 5
*   **api**: 100', example='1'),
  timeout?: long(name='Timeout', description='The timeout threshold. Default value: 7200. Unit: seconds.', example='7200'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to turn on Timeout alarm. Valid values:

*   **true**: Turn on Timeout alarm.
*   **false**: Turn off Timeout alarm.', example='false'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to turn on Timeout termination. Valid values:

*   **true**: Turn on Timeout termination.
*   **false**: Turn off Timeout termination.', example='false'),
  XAttrs?: string(name='XAttrs', description='If the Task type parameter is set to k8s, this parameter is required. xxljob task: {"resource":"job"} shell task: {"image":"busybox","resource":"shell"}', example='{"resource":"job"}'),
}

model CreateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the job is created. Valid values:

*   **true**: The job is created.
*   **false**: Failed to create the job.', example='true'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateJobResponseBody(name='body'),
}

async function createJobWithOptions(request: CreateJobRequest, runtime: Util.RuntimeOptions): CreateJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!Util.isUnset(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!Util.isUnset(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!Util.isUnset(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!Util.isUnset(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!Util.isUnset(request.failTimes)) {
    body['FailTimes'] = request.failTimes;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobType)) {
    body['JobType'] = request.jobType;
  }
  if (!Util.isUnset(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!Util.isUnset(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.successNoticeEnable)) {
    body['SuccessNoticeEnable'] = request.successNoticeEnable;
  }
  if (!Util.isUnset(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!Util.isUnset(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!Util.isUnset(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  if (!Util.isUnset(request.XAttrs)) {
    body['XAttrs'] = request.XAttrs;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  description?: string(name='Description', description='The description of the namespace.', example='Test'),
  name?: string(name='Name', description='The name of the namespace.', example='test-env'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  uid?: string(name='Uid', description='The UID of the namespace, which is globally unique. We recommend that you use the UUID to generate the UID.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
}

model CreateNamespaceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    namespaceUid?: string(name='NamespaceUid', description='The unique identifier of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  }(name='Data', description='The information of the namespace.'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='namespace=test3 is existed, noting update'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether an application is created. Valid values:

*   **true**: The application is created.
*   **false**: Failed to create the application.', example='true'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: Util.RuntimeOptions): CreateNamespaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateNamespace',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRouteStrategyRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', example='54978'),
  name?: string(name='Name', example='test-strategy'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  status?: int32(name='Status', example='1'),
  strategyContent?: string(name='StrategyContent', example='[{"percentage":20,"target":"[\\"version1\\"]","targetType":"label"}]'),
  type?: int32(name='Type', example='3'),
}

model CreateRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
  }(name='Data'),
  message?: string(name='Message', example='strategy name is null or empty.'),
  requestId?: string(name='RequestId', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model CreateRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRouteStrategyResponseBody(name='body'),
}

async function createRouteStrategyWithOptions(request: CreateRouteStrategyRequest, runtime: Util.RuntimeOptions): CreateRouteStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.strategyContent)) {
    query['StrategyContent'] = request.strategyContent;
  }
  if (!Util.isUnset(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRouteStrategy(request: CreateRouteStrategyRequest): CreateRouteStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRouteStrategyWithOptions(request, runtime);
}

model CreateWorkflowRequest {
  description?: string(name='Description', example='Test'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  maxConcurrency?: int32(name='MaxConcurrency', example='1'),
  name?: string(name='Name', example='helloworld'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  timeExpression?: string(name='TimeExpression', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', example='1'),
  timezone?: string(name='Timezone', example='GMT+8'),
}

model CreateWorkflowResponseBody = {
  code?: string(name='Code', example='200'),
  data?: {
    workflowId?: long(name='WorkflowId', example='92583'),
  }(name='Data'),
  message?: string(name='Message', example='timetype is invalid'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model CreateWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWorkflowResponseBody(name='body'),
}

async function createWorkflowWithOptions(request: CreateWorkflowRequest, runtime: Util.RuntimeOptions): CreateWorkflowResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.timezone)) {
    body['Timezone'] = request.timezone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWorkflow(request: CreateWorkflowRequest): CreateWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWorkflowWithOptions(request, runtime);
}

model DeleteAppGroupRequest {
  deleteJobs?: boolean(name='DeleteJobs', example='true'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DeleteAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model DeleteAppGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAppGroupResponseBody(name='body'),
}

async function deleteAppGroupWithOptions(request: DeleteAppGroupRequest, runtime: Util.RuntimeOptions): DeleteAppGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteJobs)) {
    query['DeleteJobs'] = request.deleteJobs;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAppGroup(request: DeleteAppGroupRequest): DeleteAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAppGroupWithOptions(request, runtime);
}

model DeleteJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID on the **Task Management** page in Distributed Task Scheduling Platform.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DeleteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job is deleted.

*   **true**: The job is deleted.
*   **false**: Failed to delete the job.', example='true'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJobWithOptions(request: DeleteJobRequest, runtime: Util.RuntimeOptions): DeleteJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteRouteStrategyRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', example='92583'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model DeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='strategy is already deleted.'),
  requestId?: string(name='RequestId', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', example='true'),
}

model DeleteRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteRouteStrategyResponseBody(name='body'),
}

async function deleteRouteStrategyWithOptions(request: DeleteRouteStrategyRequest, runtime: Util.RuntimeOptions): DeleteRouteStrategyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteRouteStrategy(request: DeleteRouteStrategyRequest): DeleteRouteStrategyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteRouteStrategyWithOptions(request, runtime);
}

model DeleteWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='111'),
}

model DeleteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The unique ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is deleted. Valid values:

*   **true**: The workflow is deleted.
*   **false**: Failed to delete the workflow.', example='true'),
}

model DeleteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWorkflowResponseBody(name='body'),
}

async function deleteWorkflowWithOptions(request: DeleteWorkflowRequest, runtime: Util.RuntimeOptions): DeleteWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWorkflow(request: DeleteWorkflowRequest): DeleteWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWorkflowWithOptions(request, runtime);
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='disable failed jobs=[99341]'),
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The displayed name of the region, which varies based on the current language.', example='China (Hangzhou)'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint of the region.', example='schedulerx.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(runtime);
}

model DesignateWorkersRequest {
  designateType?: int32(name='DesignateType', description='The type of the designated machines. Valid values: 1: worker. 2: label.', example='1'),
  groupId?: string(name='GroupId', description='The ID of the application group.', example='hxm.test'),
  jobId?: long(name='JobId', description='The ID of the job.', example='144153'),
  labels?: string(name='Labels', description='The designated `labels`. The value is a `JSON` string.', example='["gray"]'),
  namespace?: string(name='Namespace', description='The ID of the namespace.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='public'),
  transferable?: boolean(name='Transferable', description='Specifies whether to allow a failover.', example='true'),
  workers?: string(name='Workers', description='The designated workers. The value is a JSON string.', example='["127.0.0.1","127.0.0.2"]'),
}

model DesignateWorkersResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='job is not existed'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='765xxx'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.', example='true'),
}

model DesignateWorkersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DesignateWorkersResponseBody(name='body'),
}

async function designateWorkersWithOptions(request: DesignateWorkersRequest, runtime: Util.RuntimeOptions): DesignateWorkersResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DesignateWorkers',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function designateWorkers(request: DesignateWorkersRequest): DesignateWorkersResponse {
  var runtime = new Util.RuntimeOptions{};
  return designateWorkersWithOptions(request, runtime);
}

model DisableJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model DisableJobResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message. The error message is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C8E5FB4A-6D8D-424D-9AAA-4FE06BB74FF9'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model DisableJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableJobResponseBody(name='body'),
}

async function disableJobWithOptions(request: DisableJobRequest, runtime: Util.RuntimeOptions): DisableJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableJob(request: DisableJobRequest): DisableJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableJobWithOptions(request, runtime);
}

model DisableWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='111'),
}

model DisableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is disabled. Valid values:

*   **true**: The workflow is disabled.
*   **false**: Failed to disable the workflow.', example='true'),
}

model DisableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableWorkflowResponseBody(name='body'),
}

async function disableWorkflowWithOptions(request: DisableWorkflowRequest, runtime: Util.RuntimeOptions): DisableWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableWorkflow(request: DisableWorkflowRequest): DisableWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableWorkflowWithOptions(request, runtime);
}

model EnableJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model EnableJobResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message. The error message is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model EnableJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableJobResponseBody(name='body'),
}

async function enableJobWithOptions(request: EnableJobRequest, runtime: Util.RuntimeOptions): EnableJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableJob(request: EnableJobRequest): EnableJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableJobWithOptions(request, runtime);
}

model EnableWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='111'),
}

model EnableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is enabled. Valid values:

*   **true**: The workflow is enabled.
*   **false**: Failed to enable the workflow.', example='true'),
}

model EnableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableWorkflowResponseBody(name='body'),
}

async function enableWorkflowWithOptions(request: EnableWorkflowRequest, runtime: Util.RuntimeOptions): EnableWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableWorkflow(request: EnableWorkflowRequest): EnableWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableWorkflowWithOptions(request, runtime);
}

model ExecuteJobRequest {
  checkJobStatus?: boolean(name='CheckJobStatus', description='Specifies whether to check the job status. Valid values: -**true**: The job can be run only if the job is enabled. -**false**: The job can be run even if the job is disabled.', example='true'),
  designateType?: int32(name='DesignateType', description='The type of the designated machine. Valid values: -**1**: worker. -**2**: label.', example='1'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  instanceParameters?: string(name='InstanceParameters', description='The parameters that are passed to trigger the job to run. The input value can be any string. The parameters that are passed are obtained by calling the `context.getInstanceParameters()` class in the `processor` code. The parameters are different from custom parameters for creating jobs.', example='test'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583'),
  label?: string(name='Label', description='The label of the worker.', example='gray'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  worker?: string(name='Worker', description='The worker address of the application. To query the worker address, call the GetWokerList operation.', example='xxxxxxx@127.0.0.1:222'),
}

model ExecuteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceId?: long(name='JobInstanceId', description='The ID of the job instance.', example='11111111'),
  }(name='Data', description='The ID of the job instance that is returned if the call is successful.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='groupid not exist groupId: testSchedulerx.defaultGroup namespace: adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   `true`: The call is successful.
*   `false`: The call fails.', example='true'),
}

model ExecuteJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteJobResponseBody(name='body'),
}

/**
  * > : The combination of the `JobID` and `ScheduleTime` parameters serves as a unique index. Therefore, after the ExecuteJob operation is called to run a job once, a sleep for one second is required before the ExecuteJob operation is called to run the job again. Otherwise, the job may fail.
  *
  * @param request ExecuteJobRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ExecuteJobResponse
 */
async function executeJobWithOptions(request: ExecuteJobRequest, runtime: Util.RuntimeOptions): ExecuteJobResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * > : The combination of the `JobID` and `ScheduleTime` parameters serves as a unique index. Therefore, after the ExecuteJob operation is called to run a job once, a sleep for one second is required before the ExecuteJob operation is called to run the job again. Otherwise, the job may fail.
  *
  * @param request ExecuteJobRequest
  * @return ExecuteJobResponse
 */
async function executeJob(request: ExecuteJobRequest): ExecuteJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeJobWithOptions(request, runtime);
}

model ExecuteWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  instanceParameters?: string(name='InstanceParameters', description='The dynamic parameter of the workflow instance. The parameter must be 1 to 1,000 bytes in length.', example='test'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='111'),
}

model ExecuteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    wfInstanceId?: long(name='WfInstanceId', description='The ID of the workflow instance.', example='111111'),
  }(name='Data', description='If the call is successful, the ID of the workflow instance is returned.'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the API call is successful.', example='true'),
}

model ExecuteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteWorkflowResponseBody(name='body'),
}

async function executeWorkflowWithOptions(request: ExecuteWorkflowRequest, runtime: Util.RuntimeOptions): ExecuteWorkflowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeWorkflow(request: ExecuteWorkflowRequest): ExecuteWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeWorkflowWithOptions(request, runtime);
}

model GetAppGroupRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model GetAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    appKey?: string(name='AppKey', example='QI4lWMZ+xk1rNB67jFUhaw=='),
    appName?: string(name='AppName', example='DocTest'),
    curJobs?: int32(name='CurJobs', example='1'),
    description?: string(name='Description', example='Test'),
    groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
    maxJobs?: int32(name='MaxJobs', example='1000'),
    monitorConfigJson?: string(name='MonitorConfigJson', example='{"sendChannel":"sms,mail,ding"}'),
  }(name='Data'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetAppGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAppGroupResponseBody(name='body'),
}

async function getAppGroupWithOptions(request: GetAppGroupRequest, runtime: Util.RuntimeOptions): GetAppGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAppGroup(request: GetAppGroupRequest): GetAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAppGroupWithOptions(request, runtime);
}

model GetJobInfoRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583'),
  jobName?: string(name='JobName', description='The name of the job.', example='simpleJob'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou'),
}

model GetJobInfoResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobConfigInfo?: {
      attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retries to run the job after a job failure. Unit: seconds. Default value: 30.', example='30'),
      className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for jobs whose job type is Java.', example='com.alibaba.test.helloword'),
      content?: string(name='Content', description='The script of a script job.', example='echo "clear" > /home/admin/edas-container/logs/catalina.out'),
      description?: string(name='Description', description='The description of the job.', example='test'),
      executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **standalone**
*   **broadcast**
*   **parallel**
*   **grid**
*   **batch**
*   **shard**', example='standalone'),
      jarUrl?: string(name='JarUrl', description='The full path that is used to upload files to Object Storage Service (OSS).

If you use a JAR package, you can upload the JAR package to this OSS path.', example='https://test.oss-cn-hangzhou.aliyuncs.com/schedulerX/test.jar'),
      jobId?: long(name='JobId', description='The ID of the job.', example='538039'),
      jobMonitorInfo?: {
        contactInfo?: [ 
          {
            ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=XXXXXX'),
            userMail?: string(name='UserMail', description='The email address of the user.', example='user@demo.com'),
            userName?: string(name='UserName', description='The name of the user.', example='userA'),
            userPhone?: string(name='UserPhone', description='The mobile number of the user.', example='1381111****'),
          }
        ](name='ContactInfo', description='The contact Information.'),
        monitorConfig?: {
          failEnable?: boolean(name='FailEnable', description='Indicates whether an alert is generated upon a failure. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
          missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether an alert is generated if no worker is available.', example='true'),
          sendChannel?: string(name='SendChannel', description='The notification method. Only Short Message Service (SMS) is supported.', example='sms'),
          timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='12300'),
          timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether an alert is generated upon a timeout. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
          timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the job is terminated upon a timeout. By default, this feature is disabled.', example='true'),
        }(name='MonitorConfig', description='The configurations of the alerting feature and alert thresholds.'),
      }(name='JobMonitorInfo', description='The monitoring information of the job.'),
      jobType?: string(name='JobType', description='The type of the job.', example='java'),
      mapTaskXAttrs?: {
        consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by an instance. Default value: 5.', example='5'),
        dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
        pageSize?: int32(name='PageSize', description='The number of tasks that are returned for a parallel job at a time. Default value: 100.', example='100'),
        queueSize?: int32(name='QueueSize', description='The maximum number of tasks that can be queued. Default value: 10000.', example='10000'),
        taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The retry interval of the task after a task failure.', example='0'),
        taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
      }(name='MapTaskXAttrs', description='The advanced configurations of the job. The parameters are returned only if the execution mode of the job is parallel, grid, or batch.'),
      maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements. Default value: 0.', example='0'),
      maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of concurrent instances. Default value: 1. A value of 1 indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the next instance is reached.', example='1'),
      name?: string(name='Name', description='The name of the job.', example='helloworld'),
      parameters?: string(name='Parameters', description='The user-defined parameters. These parameters can be obtained when the job is running.', example='test'),
      status?: int32(name='Status', description='The status of the job. Valid values:

*   **1**: The job is enabled and can be triggered.
*   **0**: The job is disabled and cannot be triggered.', example='1'),
      timeConfig?: {
        calendar?: string(name='Calendar', description='If the TimeType parameter is set to **1** (cron), you can customize the calendar.', example='Business days'),
        dataOffset?: int32(name='DataOffset', description='If the TimeType parameter is set to **1** (cron), you can configure the time offset. Unit: seconds.', example='0'),
        timeExpression?: string(name='TimeExpression', description='The time expression. The time expression varies with the time type:

*   **api**: No time expression exists.
*   **fix_rate**: a specific fixed frequency. For example, a value of 30 indicates that the job is triggered every 30 seconds.
*   **cron**: a standard Cron expression.
*   **second_delay**: a fixed delay after which the job is triggered. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
        timeType?: int32(name='TimeType', description='The time type. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
      }(name='TimeConfig', description='The time configurations.'),
      XAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
    }(name='JobConfigInfo', description='The configurations of the job.'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The error message that is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job details are obtained. Valid values:

*   **true**: The job details are obtained.
*   **false**: Failed to obtain the job details.', example='true'),
}

model GetJobInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobInfoResponseBody(name='body'),
}

async function getJobInfoWithOptions(request: GetJobInfoRequest, runtime: Util.RuntimeOptions): GetJobInfoResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInfo',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInfoWithOptions(request, runtime);
}

model GetJobInstanceRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
  jobInstanceId?: long(name='JobInstanceId', description='The ID of the job instance.', example='11111111'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
}

model GetJobInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceDetail?: {
      dataTime?: string(name='DataTime', description='The data time.', example='2020-07-27 11:52:10'),
      endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
      executor?: string(name='Executor', description='The user who executes the job.', example='A'),
      instanceId?: long(name='InstanceId', description='The ID of the job instance.', example='11111111'),
      jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
      progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
      result?: string(name='Result', description='The execution results of the job instance.', example='success'),
      scheduleTime?: string(name='ScheduleTime', description='The scheduled time of the job.', example='2020-07-27 11:52:10'),
      startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
      status?: int32(name='Status', description='The status of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance fails.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
      timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
      triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance is triggered at the scheduled time.
*   **2**: The job instance is triggered due to data update.
*   **3**: The job instance is triggered by an API call.
*   **4**: The job instance is triggered because it is manually rerun.
*   **5**: The job instance is triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
      workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
    }(name='JobInstanceDetail', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instance.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetJobInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobInstanceResponseBody(name='body'),
}

async function getJobInstanceWithOptions(request: GetJobInstanceRequest, runtime: Util.RuntimeOptions): GetJobInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInstance(request: GetJobInstanceRequest): GetJobInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInstanceWithOptions(request, runtime);
}

model GetJobInstanceListRequest {
  endTimestamp?: long(name='EndTimestamp'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the application resides.', example='cn-hangzhou'),
  startTimestamp?: long(name='StartTimestamp'),
  status?: int32(name='Status'),
}

model GetJobInstanceListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceDetails?: [ 
      {
        dataTime?: string(name='DataTime', description='The data time.', example='2020-07-27 11:52:10'),
        endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
        executor?: string(name='Executor', description='The user who executes the job.', example='A'),
        instanceId?: long(name='InstanceId', description='The ID of the job instance.', example='11111111'),
        jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
        progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
        result?: string(name='Result', description='The execution results of the job instance.', example='success'),
        scheduleTime?: string(name='ScheduleTime', description='The scheduled time of the job.', example='2020-07-27 11:52:10'),
        startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
        status?: int32(name='Status', description='The status of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance fails.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
        timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
        triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance is triggered at the scheduled time.
*   **2**: The job instance is triggered due to data update.
*   **3**: The job instance is triggered by an API call.
*   **4**: The job instance is triggered because it is manually rerun.
*   **5**: The job instance is triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
        workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
      }
    ](name='JobInstanceDetails', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instances.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetJobInstanceListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetJobInstanceListResponseBody(name='body'),
}

async function getJobInstanceListWithOptions(request: GetJobInstanceListRequest, runtime: Util.RuntimeOptions): GetJobInstanceListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetJobInstanceList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getJobInstanceList(request: GetJobInstanceListRequest): GetJobInstanceListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getJobInstanceListWithOptions(request, runtime);
}

model GetLogRequest {
  endTimestamp?: long(name='EndTimestamp', example='1675739484000'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: string(name='JobId', example='123'),
  jobInstanceId?: string(name='JobInstanceId', example='123456'),
  keyword?: string(name='Keyword', example='ERROR'),
  line?: int32(name='Line', example='50'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  offset?: int32(name='Offset', example='0'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  reverse?: boolean(name='Reverse', example='true'),
  startTimestamp?: long(name='StartTimestamp', example='1675739364000'),
}

model GetLogResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    logs?: [ string ](name='Logs'),
  }(name='Data'),
  message?: string(name='Message', example='jobid=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetLogResponseBody(name='body'),
}

async function getLogWithOptions(request: GetLogRequest, runtime: Util.RuntimeOptions): GetLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetLog',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getLog(request: GetLogRequest): GetLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getLogWithOptions(request, runtime);
}

model GetWorkFlowRequest {
  groupId?: string(name='GroupId', description='The ID of the application group.', example='hxm.test'),
  namespace?: string(name='Namespace', description='The ID of the namespace.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespcae.', example='source'),
  regionId?: string(name='RegionId', description='The region information.', example='public'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='1234'),
}

model GetWorkFlowResponseBody = {
  code?: int32(name='Code', description='The error code that is returned.', example='200'),
  data?: {
    workFlowInfo?: {
      description?: string(name='Description', description='The description of the workflow.', example='my first workflow'),
      name?: string(name='Name', description='The name of the workflow.', example='workflow_111'),
      status?: string(name='Status', description='The status of the workflow.', example='Successful'),
      timeExpression?: string(name='TimeExpression', description='The time expression of the workflow.', example='0 0 2 * * ?'),
      timeType?: string(name='TimeType', description='The time type of the workflow.', example='cron'),
      workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='1234xxx'),
    }(name='WorkFlowInfo', description='The basic information of the workflow.'),
    workFlowNodeInfo?: {
      edges?: [ 
        {
          source?: long(name='Source', description='The ID of the source job.', example='100'),
          target?: long(name='Target', description='The ID of the target job.', example='200'),
        }
      ](name='Edges', description='The workflow edges.'),
      nodes?: [ 
        {
          id?: long(name='Id', description='The ID of the job.', example='123456xxx'),
          label?: string(name='Label', description='The name of the job.', example='job_111'),
          status?: int32(name='Status', description='The status of the job.', example='1'),
        }
      ](name='Nodes', description='The list of workflow nodes.'),
    }(name='WorkFlowNodeInfo', description='The node information of the workflow.'),
  }(name='Data', description='The data of the workflow.'),
  message?: string(name='Message', description='The error message that is returned.', example='workflow is not existed'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45678xxx'),
  success?: boolean(name='Success', description='The result of the API call.', example='true'),
}

model GetWorkFlowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkFlowResponseBody(name='body'),
}

async function getWorkFlowWithOptions(request: GetWorkFlowRequest, runtime: Util.RuntimeOptions): GetWorkFlowResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkFlow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkFlow(request: GetWorkFlowRequest): GetWorkFlowResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkFlowWithOptions(request, runtime);
}

model GetWorkerListRequest {
  groupId?: string(name='GroupId', description='The ID of the permission group.', example='usercenter'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetWorkerListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    workerInfos?: [ 
      {
        ip?: string(name='Ip', description='The IP address of the worker.', example='30.225.16.49'),
        label?: string(name='Label', description='The label of the worker.', example='gray'),
        port?: int32(name='Port', description='The port number of the worker.', example='60831'),
        starter?: string(name='Starter', description='The startup method of the worker.', example='springboot'),
        version?: string(name='Version', description='The version of the worker.', example='1.3.4'),
        workerAddress?: string(name='WorkerAddress', description='The address of the worker. The address is in the format of ${worker_id}@${worker_ip}:${worker_port}.', example='030225016049_11734_25917@30.225.16.49:60831'),
      }
    ](name='WorkerInfos', description='The worker information.'),
  }(name='Data', description='The job information.'),
  message?: string(name='Message', description='The additional information that is returned.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetWorkerListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkerListResponseBody(name='body'),
}

async function getWorkerListWithOptions(request: GetWorkerListRequest, runtime: Util.RuntimeOptions): GetWorkerListResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkerList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkerList(request: GetWorkerListRequest): GetWorkerListResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkerListWithOptions(request, runtime);
}

model GetWorkflowInstanceRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  wfInstanceId?: long(name='WfInstanceId', example='123456'),
  workflowId?: long(name='WorkflowId', example='123'),
}

model GetWorkflowInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    wfInstanceDag?: {
      edges?: [ 
        {
          source?: long(name='Source', example='24058798'),
          target?: long(name='Target', example='24058796'),
        }
      ](name='Edges'),
      nodes?: [ 
        {
          attempt?: int32(name='Attempt', example='0'),
          dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
          endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
          jobId?: long(name='JobId', example='1472'),
          jobInstanceId?: long(name='JobInstanceId', example='24058796'),
          result?: string(name='Result', example='code=200'),
          scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:03'),
          startTime?: string(name='StartTime', example='2023-01-03 18:00:03'),
          workAddr?: string(name='WorkAddr', example='10.163.0.101:34027'),
        }
      ](name='Nodes'),
    }(name='WfInstanceDag'),
    wfInstanceInfo?: {
      dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
      endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
      scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:00'),
      startTime?: string(name='StartTime', example='2023-01-03 18:00:01'),
      status?: int32(name='Status', example='5'),
    }(name='WfInstanceInfo'),
  }(name='Data'),
  message?: string(name='Message', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkflowInstanceResponseBody(name='body'),
}

async function getWorkflowInstanceWithOptions(request: GetWorkflowInstanceRequest, runtime: Util.RuntimeOptions): GetWorkflowInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkflowInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkflowInstance(request: GetWorkflowInstanceRequest): GetWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkflowInstanceWithOptions(request, runtime);
}

model GrantPermissionRequest {
  grantOption?: boolean(name='GrantOption', description='Specifies whether to grant the permissions with the GRANT option. Valid values: -**true**: grants the permissions with the GRANT option. -**false**: does not grant the permissions with the GRANT option.', example='false'),
  groupId?: string(name='GroupId', description='The ID of the application group.', example='test.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  userId?: string(name='UserId', description='The user ID.', example='277641081920123456'),
  userName?: string(name='UserName', description='The username.', example='lilei'),
}

model GrantPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='400'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='false'),
}

model GrantPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantPermissionResponseBody(name='body'),
}

async function grantPermissionWithOptions(request: GrantPermissionRequest, runtime: Util.RuntimeOptions): GrantPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.grantOption)) {
    query['GrantOption'] = request.grantOption;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantPermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantPermission(request: GrantPermissionRequest): GrantPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantPermissionWithOptions(request, runtime);
}

model ListGroupsRequest {
  namespace?: string(name='Namespace', description='The namespace. You can obtain the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the application is located.', example='cn-hangzhou'),
}

model ListGroupsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned.', example='200'),
  data?: {
    appGroups?: [ 
      {
        appGroupId?: long(name='AppGroupId', description='应用分组ID', example='1'),
        appKey?: string(name='AppKey', description='The key for the application.', example='a3G77O6NZxq/lyo1NC****=='),
        appName?: string(name='AppName', description='The name of the application.', example='DocTest'),
        description?: string(name='Description', description='The application description.', example='Test'),
        groupId?: string(name='GroupId', description='The application ID.', example='DocTest.Group'),
      }
    ](name='AppGroups', description='The list of applications and details of applications.'),
  }(name='Data', description='The information about the list of applications.'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58A'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListGroupsResponseBody(name='body'),
}

/**
  * >  Before you call this operation, you must add the following dependency to the pom.xml file:
  *       <groupId>com.aliyun</groupId>
  *       <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *       <version>1.0.5</version>
  *
  * @param request ListGroupsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListGroupsResponse
 */
async function listGroupsWithOptions(request: ListGroupsRequest, runtime: Util.RuntimeOptions): ListGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListGroups',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * >  Before you call this operation, you must add the following dependency to the pom.xml file:
  *       <groupId>com.aliyun</groupId>
  *       <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *       <version>1.0.5</version>
  *
  * @param request ListGroupsRequest
  * @return ListGroupsResponse
 */
async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.', example='DocTest.Group'),
  jobName?: string(name='JobName', description='The name of the job.', example='helloword'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou'),
  status?: string(name='Status', description='Specifies whether to enable the job. Valid values:

*   **0**: disables the job.
*   **1**: enables the job.', example='1'),
}

model ListJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobs?: [ 
      {
        attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retries to run the job after a job failure. Unit: seconds. Default value: 30.', example='30'),
        className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for a Java job.', example='com.alibaba.schedulerx.test.helloworld'),
        content?: string(name='Content', description='The script of the job. This parameter is returned only for a Python, Shell, or Go job.', example='echo \\"hello\\"'),
        description?: string(name='Description', description='The description of the job.', example='Test'),
        executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **shard**: The job runs in multipart mode.', example='standalone'),
        jarUrl?: string(name='JarUrl', description='The full path to which a JAR package is uploaded in Object Storage Service (OSS).', example='https:doc***.oss-cn-hangzhou.aliyuncs.com/sc-****-D-0.0.2-SNAPSHOT.jar'),
        jobId?: long(name='JobId', description='The ID of the job.', example='99341'),
        jobMonitorInfo?: {
          contactInfo?: [ 
            {
              ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
              userMail?: string(name='UserMail', description='The email address of the user.', example='user@mail.com'),
              userName?: string(name='UserName', description='The name of the user.', example='userA'),
              userPhone?: string(name='UserPhone', description='The mobile number of the user.', example='1381111****'),
            }
          ](name='ContactInfo', description='The contact information.'),
          monitorConfig?: {
            failEnable?: boolean(name='FailEnable', description='Indicates whether the feature of generating an alert upon a failure is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether the feature of generating an alert when no machine is available for running the job is enabled.', example='true'),
            sendChannel?: string(name='SendChannel', description='The method that is used to send an alert notification. Only Short Message Service (SMS) is supported.', example='sms'),
            timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='12300'),
            timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether the feature of generating an alert upon a timeout is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the feature of stopping job triggering upon a timeout is enabled. By default, the feature is disabled.

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='false'),
          }(name='MonitorConfig', description='The configurations of the alerting feature and the alert threshold.'),
        }(name='JobMonitorInfo', description='The monitoring information of the job.'),
        jobType?: string(name='JobType', description='The type of the job.', example='java'),
        mapTaskXAttrs?: {
          consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a standalone job at a time. Default value: 5.', example='5'),
          dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
          pageSize?: int32(name='PageSize', description='The number of tasks that are pulled by a parallel job at a time. Default value: 100.', example='100'),
          queueSize?: int32(name='QueueSize', description='The maximum number of task queues that can be cached. Default value: 10000.', example='10000'),
          taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system retries to run the task after a task failure.', example='0'),
          taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
        }(name='MapTaskXAttrs', description='The advanced configurations of the job. The parameters are returned only if the value of the ExecuteMode parameter is parallel, grid, or batch.'),
        maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements. Default value: 0.', example='0'),
        maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of instances that can concurrently run for the job. Default value: 1. A value of 1 indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the instance is reached.', example='1'),
        name?: string(name='Name', description='The name of the job.', example='helloworld'),
        parameters?: string(name='Parameters', description='The user-defined parameters. These parameters can be obtained when the job is running.', example='test'),
        status?: int32(name='Status', description='The status of the job. Valid values:

*   **1**: The job is enabled and can be triggered.
*   **0**: The job is disabled and cannot be triggered.', example='1'),
        timeConfig?: {
          calendar?: string(name='Calendar', description='If the TimeType parameter is set to cron, you can specify custom calendar days.', example='Business days'),
          dataOffset?: int32(name='DataOffset', description='The time offset if the TimeType parameter is set to cron. Unit: seconds.', example='0'),
          timeExpression?: string(name='TimeExpression', description='The time expression. Valid values:

*   **api**: indicates that no time expression is used to specify the time when to schedule the job.
*   **fix_rate**: indicates that the job is triggered at a fixed frequency. For example, a value of 30 indicates that the job is triggered every 30 seconds.
*   **cron**: indicates that a standard CRON expression is used to specify the time when to schedule the job.
*   **second_delay**: indicates that the job is triggered after a fixed delay. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
          timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
        }(name='TimeConfig', description='The time configurations.'),
        XAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
      }
    ](name='Jobs', description='The jobs and their details.'),
  }(name='Data', description='The information about the jobs.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='namespace can not find namespace: 1a72ecb1-b4cc-400a-a71b-20cdec9b****, namespaceSource:null'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58B'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *           <groupId>com.aliyun</groupId>
  *           <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *           <version>1.0.5</version>
  *     </dependency>
  *
  * @param request ListJobsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListJobsResponse
 */
async function listJobsWithOptions(request: ListJobsRequest, runtime: Util.RuntimeOptions): ListJobsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *           <groupId>com.aliyun</groupId>
  *           <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *           <version>1.0.5</version>
  *     </dependency>
  *
  * @param request ListJobsRequest
  * @return ListJobsResponse
 */
async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListNamespacesRequest {
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model ListNamespacesResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    namespaces?: [ 
      {
        description?: string(name='Description', description='The description of the namespace.', example='test'),
        name?: string(name='Name', description='The name of the namespace.', example='doc'),
        UId?: string(name='UId', description='The ID of the namespace.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
      }
    ](name='Namespaces', description='The list and details of the namespaces.'),
  }(name='Data', description='The list of namespaces.'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58C'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListNamespacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNamespacesResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *         <groupId>com.aliyun</groupId>
  *         <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *         <version>1.0.5</version>
  *     </dependency>
  *
  * @param request ListNamespacesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ListNamespacesResponse
 */
async function listNamespacesWithOptions(request: ListNamespacesRequest, runtime: Util.RuntimeOptions): ListNamespacesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNamespaces',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *         <groupId>com.aliyun</groupId>
  *         <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *         <version>1.0.5</version>
  *     </dependency>
  *
  * @param request ListNamespacesRequest
  * @return ListNamespacesResponse
 */
async function listNamespaces(request: ListNamespacesRequest): ListNamespacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNamespacesWithOptions(request, runtime);
}

model ListWorkflowInstanceRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  workflowId?: string(name='WorkflowId', example='123'),
}

model ListWorkflowInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    wfInstanceInfos?: [ 
      {
        dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
        endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
        scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:00'),
        startTime?: string(name='StartTime', example='2023-01-03 18:00:01'),
        status?: int32(name='Status', example='5'),
        wfInstanceId?: long(name='WfInstanceId', example='123456'),
        workflowId?: long(name='WorkflowId', example='123'),
      }
    ](name='WfInstanceInfos'),
  }(name='Data'),
  message?: string(name='Message', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model ListWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkflowInstanceResponseBody(name='body'),
}

async function listWorkflowInstanceWithOptions(request: ListWorkflowInstanceRequest, runtime: Util.RuntimeOptions): ListWorkflowInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkflowInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWorkflowInstance(request: ListWorkflowInstanceRequest): ListWorkflowInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkflowInstanceWithOptions(request, runtime);
}

model RerunJobRequest {
  dataTime?: string(name='DataTime', example='10:00:00'),
  endDate?: long(name='EndDate', example='1645718400000'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', example='123'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  startDate?: long(name='StartDate', example='1645459200000'),
}

model RerunJobResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model RerunJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RerunJobResponseBody(name='body'),
}

async function rerunJobWithOptions(request: RerunJobRequest, runtime: Util.RuntimeOptions): RerunJobResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataTime)) {
    body['DataTime'] = request.dataTime;
  }
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RerunJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rerunJob(request: RerunJobRequest): RerunJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return rerunJobWithOptions(request, runtime);
}

model RetryJobInstanceRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', example='123'),
  jobInstanceId?: long(name='JobInstanceId', example='123456'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model RetryJobInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model RetryJobInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryJobInstanceResponseBody(name='body'),
}

async function retryJobInstanceWithOptions(request: RetryJobInstanceRequest, runtime: Util.RuntimeOptions): RetryJobInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobInstanceId)) {
    query['JobInstanceId'] = request.jobInstanceId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryJobInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryJobInstance(request: RetryJobInstanceRequest): RetryJobInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryJobInstanceWithOptions(request, runtime);
}

model RevokePermissionRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='test.defalutGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-shenzhen'),
  userId?: string(name='UserId', description='The unique ID (UID) of the RAM user.', example='277641081920123456'),
}

model RevokePermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='400'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='false'),
}

model RevokePermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokePermissionResponseBody(name='body'),
}

async function revokePermissionWithOptions(request: RevokePermissionRequest, runtime: Util.RuntimeOptions): RevokePermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokePermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokePermission(request: RevokePermissionRequest): RevokePermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokePermissionWithOptions(request, runtime);
}

model SetJobInstanceSuccessRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', example='123'),
  jobInstanceId?: long(name='JobInstanceId', example='123456'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model SetJobInstanceSuccessResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model SetJobInstanceSuccessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetJobInstanceSuccessResponseBody(name='body'),
}

async function setJobInstanceSuccessWithOptions(request: SetJobInstanceSuccessRequest, runtime: Util.RuntimeOptions): SetJobInstanceSuccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.jobInstanceId)) {
    query['JobInstanceId'] = request.jobInstanceId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetJobInstanceSuccess',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setJobInstanceSuccess(request: SetJobInstanceSuccessRequest): SetJobInstanceSuccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return setJobInstanceSuccessWithOptions(request, runtime);
}

model SetWfInstanceSuccessRequest {
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  wfInstanceId?: long(name='WfInstanceId', example='123456789'),
  workflowId?: long(name='WorkflowId', example='123'),
}

model SetWfInstanceSuccessResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='wofkflowId is not existed'),
  requestId?: string(name='RequestId', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model SetWfInstanceSuccessResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetWfInstanceSuccessResponseBody(name='body'),
}

async function setWfInstanceSuccessWithOptions(request: SetWfInstanceSuccessRequest, runtime: Util.RuntimeOptions): SetWfInstanceSuccessResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.wfInstanceId)) {
    query['WfInstanceId'] = request.wfInstanceId;
  }
  if (!Util.isUnset(request.workflowId)) {
    query['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetWfInstanceSuccess',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setWfInstanceSuccess(request: SetWfInstanceSuccessRequest): SetWfInstanceSuccessResponse {
  var runtime = new Util.RuntimeOptions{};
  return setWfInstanceSuccessWithOptions(request, runtime);
}

model StopInstanceRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  instanceId?: long(name='InstanceId', description='The ID of the job instance in the running state.', example='11111111'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region in which the application resides.', example='cn-hangzhou'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: Util.RuntimeOptions): StopInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model UpdateAppGroupRequest {
  description?: string(name='Description', example='Test'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  maxConcurrency?: int32(name='MaxConcurrency', example='1'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
}

model UpdateAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model UpdateAppGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateAppGroupResponseBody(name='body'),
}

async function updateAppGroupWithOptions(request: UpdateAppGroupRequest, runtime: Util.RuntimeOptions): UpdateAppGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    query['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateAppGroup(request: UpdateAppGroupRequest): UpdateAppGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateAppGroupWithOptions(request, runtime);
}

model UpdateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system attempts to rerun a job. Default value: 30. Unit: seconds.', example='30'),
  calendar?: string(name='Calendar', description='When the Time type parameter is set to cron, you can specify a custom calendar.', example='Business days'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This field is available only when you select a java job. In this case, you must enter a full path.', example='com.alibaba.test.helloworld'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a single worker at a time. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot. For more information, see [DingTalk development documentation](https://open.dingtalk.com/document/org/application-types).', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the contact.', example='userA'),
      userPhone?: string(name='UserPhone', description='The mobile phone number of the contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information of the job contact.'),
  content?: string(name='Content', description='The script code content that is required when you set the job type to **python**, **shell**, or **go**.', example='echo \\"hello\\"'),
  dataOffset?: int32(name='DataOffset', description='When the Time type parameter is set to cron, you can specify a time offset. Unit: seconds.', example='2400'),
  description?: string(name='Description', description='The description of the job.', example='test'),
  dispatcherSize?: int32(name='DispatcherSize', description='Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  executeMode?: string(name='ExecuteMode', description='The execution mode of the job. The following execution modes are supported:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **sharding**: The job runs in sharding mode.', example='standalone'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to turn on Failure alarm. Valid values:

*   **true**: Turn on Failure alarm.
*   **false**: Turn off Failure alarm.', example='true'),
  failTimes?: int32(name='FailTimes'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in Distributed Task Scheduling Platform.', example='92583'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of attempts that the system can make when an error occurs on a job. You can specify this parameter based on your business requirements.', example='0'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of instances that the system can run at the same time. Default value: 1. When you set this parameter to 1, if the current job does not end, the system will not run the next job even if the runtime is reached.', example='1'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to turn on No machine alarm available when no worker is available.

*   **true**: Turn on No machine alarm available when no worker is available.
*   **false**: Turn off No machine alarm available when no worker is available.', example='true'),
  name?: string(name='Name', description='The name of the job.', example='helloword'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx'),
  pageSize?: int32(name='PageSize', description='The number of subtasks that can be pulled at a time. Default value: 100. This parameter is an advanced configuration item of the MapReduce job.', example='100'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when you run the job.', example='test'),
  queueSize?: int32(name='QueueSize', description='The maximum number of subtask queues that you can cache. Default value: 10000. This parameter is an advanced configuration item of the MapReduce job.', example='10000'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
  sendChannel?: string(name='SendChannel', description='The channel for sending alerts. Only SMS messages are supported.', example='sms'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system can rerun the subtask when the subtask fails. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  taskDispatchMode?: string(name='TaskDispatchMode'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries that the system can perform when the subtask fails. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression according to the selected time type.

*   **cron**: Specify a standard Cron expression. You can verify the expression online after you specify the expression.
*   **api**: No time expression is available.
*   **fixed_rate**: Specify a fixed frequency value. Unit: seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   **second_delay**: Specify a delay after which you can run a job. You can specify a value from 1 to 60. Unit: seconds.', example='30'),
  timeType?: int32(name='TimeType', description='The type of time. The following time types are supported:

*   **cron**: 1
*   **fix_rate**: 3
*   **second_delay**: 4
*   **api**: 100', example='1'),
  timeout?: long(name='Timeout', description='The timeout threshold. Default value: 7200. Unit: seconds.', example='7200'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to turn on Timeout alarm. Valid values:

*   **true**: Turn on Timeout alarm.
*   **false**: Turn off Timeout alarm.', example='true'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to turn on Timeout termination. Valid values:

*   **true**: Turn on Timeout termination.
*   **false**: Turn off Timeout termination.', example='true'),
}

model UpdateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned only if the error occurs.', example='job type is java className can not be blank'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateJobResponseBody(name='body'),
}

async function updateJobWithOptions(request: UpdateJobRequest, runtime: Util.RuntimeOptions): UpdateJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!Util.isUnset(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!Util.isUnset(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!Util.isUnset(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!Util.isUnset(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!Util.isUnset(request.content)) {
    body['Content'] = request.content;
  }
  if (!Util.isUnset(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!Util.isUnset(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!Util.isUnset(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!Util.isUnset(request.failTimes)) {
    body['FailTimes'] = request.failTimes;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!Util.isUnset(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!Util.isUnset(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!Util.isUnset(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!Util.isUnset(request.successNoticeEnable)) {
    body['SuccessNoticeEnable'] = request.successNoticeEnable;
  }
  if (!Util.isUnset(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!Util.isUnset(request.taskDispatchMode)) {
    body['TaskDispatchMode'] = request.taskDispatchMode;
  }
  if (!Util.isUnset(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!Util.isUnset(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!Util.isUnset(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateJobWithOptions(request, runtime);
}

model UpdateWorkflowRequest {
  description?: string(name='Description', example='Test'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  name?: string(name='Name', example='helloworld'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  timeExpression?: string(name='TimeExpression', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', example='1'),
  workflowId?: string(name='WorkflowId', example='123'),
}

model UpdateWorkflowResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='timetype is invalid'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model UpdateWorkflowResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWorkflowResponseBody(name='body'),
}

async function updateWorkflowWithOptions(request: UpdateWorkflowRequest, runtime: Util.RuntimeOptions): UpdateWorkflowResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.name)) {
    body['Name'] = request.name;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!Util.isUnset(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkflow(request: UpdateWorkflowRequest): UpdateWorkflowResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkflowWithOptions(request, runtime);
}

model UpdateWorkflowDagRequest {
  dagJson?: string(name='DagJson', example='{"nodes":[{"id":2300691},{"id":10518089},{"id":1758851}],"edges":[{"source":10518089,"target":1758851},{"source":10518089,"target":2300691}]}'),
  groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx'),
  regionId?: string(name='RegionId', example='cn-hangzhou'),
  workflowId?: string(name='WorkflowId', example='123'),
}

model UpdateWorkflowDagResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='workflowId=xxxx is not existed'),
  requestId?: string(name='RequestId', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model UpdateWorkflowDagResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWorkflowDagResponseBody(name='body'),
}

async function updateWorkflowDagWithOptions(request: UpdateWorkflowDagRequest, runtime: Util.RuntimeOptions): UpdateWorkflowDagResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dagJson)) {
    body['DagJson'] = request.dagJson;
  }
  if (!Util.isUnset(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!Util.isUnset(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!Util.isUnset(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!Util.isUnset(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkflowDag',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkflowDag(request: UpdateWorkflowDagRequest): UpdateWorkflowDagResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkflowDagWithOptions(request, runtime);
}

