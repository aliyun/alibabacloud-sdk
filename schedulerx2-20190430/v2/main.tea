/**
 *
 */
import OpenApi;
import OpenApi.OpenApiUtil;

extends OpenApi;


init(config: OpenApiUtil.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-beijing' = 'schedulerx.cn-beijing.aliyuncs.com',
    'cn-hangzhou' = 'schedulerx.cn-hangzhou.aliyuncs.com',
    'cn-shanghai' = 'schedulerx.cn-shanghai.aliyuncs.com',
    'cn-shenzhen' = 'schedulerx.cn-shenzhen.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('schedulerx2', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!$isNull(endpoint)) {
    return endpoint;
  }
  
  if (!$isNull(endpointMap) && !$isNull(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return OpenApiUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model BatchDeleteJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).

This parameter is required.', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='Schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region to which the job belongs.

This parameter is required.', example='cn-hangzhou'),
}

model BatchDeleteJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether multiple jobs were deleted at a time. Valid values:

*   **true**: Multiple jobs were deleted at a time.
*   **false**: Multiple jobs were not deleted at a time.', example='true'),
}

model BatchDeleteJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteJobsResponseBody(name='body'),
}

/**
 * @summary Deletes multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchDeleteJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteJobsResponse
 */
@context("batchDeleteJobsWithContext")
async function batchDeleteJobsWithOptions(request: BatchDeleteJobsRequest, runtime: $RuntimeOptions): BatchDeleteJobsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeleteJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchDeleteJobsRequest
 * @return BatchDeleteJobsResponse
 */
async function batchDeleteJobs(request: BatchDeleteJobsRequest): BatchDeleteJobsResponse {
  var runtime = new $RuntimeOptions{};
  return batchDeleteJobsWithOptions(request, runtime);
}

model BatchDeleteRouteStrategyRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The IDs of the jobs.'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model BatchDeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='job is not existed, jobId=162837'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='704A2A61-3681-5568-92F7-2DFCC53F33D1'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

true: The request was successful.
false: The request failed.', example='true'),
}

model BatchDeleteRouteStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteRouteStrategyResponseBody(name='body'),
}

/**
 * @summary The additional information that is returned.
 *
 * @param request BatchDeleteRouteStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDeleteRouteStrategyResponse
 */
@context("batchDeleteRouteStrategyWithContext")
async function batchDeleteRouteStrategyWithOptions(request: BatchDeleteRouteStrategyRequest, runtime: $RuntimeOptions): BatchDeleteRouteStrategyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDeleteRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The additional information that is returned.
 *
 * @param request BatchDeleteRouteStrategyRequest
 * @return BatchDeleteRouteStrategyResponse
 */
async function batchDeleteRouteStrategy(request: BatchDeleteRouteStrategyRequest): BatchDeleteRouteStrategyResponse {
  var runtime = new $RuntimeOptions{};
  return batchDeleteRouteStrategyWithOptions(request, runtime);
}

model BatchDisableJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).

This parameter is required.', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region to which the job belongs.

This parameter is required.', example='cn-hangzhou'),
}

model BatchDisableJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The additional information that was returned.', example='disable failed jobs=[99341]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model BatchDisableJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDisableJobsResponseBody(name='body'),
}

/**
 * @summary Disables multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchDisableJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchDisableJobsResponse
 */
@context("batchDisableJobsWithContext")
async function batchDisableJobsWithOptions(request: BatchDisableJobsRequest, runtime: $RuntimeOptions): BatchDisableJobsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchDisableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchDisableJobsRequest
 * @return BatchDisableJobsResponse
 */
async function batchDisableJobs(request: BatchDisableJobsRequest): BatchDisableJobsResponse {
  var runtime = new $RuntimeOptions{};
  return batchDisableJobsWithOptions(request, runtime);
}

model BatchEnableJobsRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobIdList?: [ long ](name='JobIdList', description='The job IDs. Multiple job IDs are separated with commas (,).

This parameter is required.', example='99341'),
  namespace?: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region to which the job belongs.

This parameter is required.', example='cn-hangzhou'),
}

model BatchEnableJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned additional information.', example='message'),
  requestId?: string(name='RequestId', description='The request ID.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the jobs were enabled at a time. Valid values:

*   **true**
*   **false**', example='true'),
}

model BatchEnableJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchEnableJobsResponseBody(name='body'),
}

/**
 * @summary Enables multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchEnableJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return BatchEnableJobsResponse
 */
@context("batchEnableJobsWithContext")
async function batchEnableJobsWithOptions(request: BatchEnableJobsRequest, runtime: $RuntimeOptions): BatchEnableJobsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.jobIdList)) {
    body['JobIdList'] = request.jobIdList;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'BatchEnableJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables multiple jobs at a time.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.4</version>
 * </dependency>
 * ```
 *
 * @param request BatchEnableJobsRequest
 * @return BatchEnableJobsResponse
 */
async function batchEnableJobs(request: BatchEnableJobsRequest): BatchEnableJobsResponse {
  var runtime = new $RuntimeOptions{};
  return batchEnableJobsWithOptions(request, runtime);
}

model CreateAppGroupRequest {
  appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviLcl****'),
  appName?: string(name='AppName', description='The name of the application.

This parameter is required.', example='DocTest'),
  appType?: int32(name='AppType', description='The type of application. Valid values:

*   `TRACE`: Application Monitoring
*   `EBPF`: Application Monitoring eBPF Edition', example='1'),
  appVersion?: int32(name='AppVersion', description='The application version. 1: Basic version, 2: Professional version.', example='2'),
  description?: string(name='Description', description='The description of the application.', example='Test'),
  enableLog?: boolean(name='EnableLog', description='Specifies whether to enable logging. Valid values:

*   `true`: enabled
*   `false`: disabled', example='true'),
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='TestSchedulerx.defaultGroup'),
  maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs.', example='1000'),
  monitorConfigJson?: string(name='MonitorConfigJson', description='The configuration of the alert. The value is a JSON string. For more information about this parameter, see **Additional information about request parameters**.', example='{"sendChannel":"sms,ding"}'),
  monitorContactsJson?: string(name='MonitorContactsJson', description='The configuration of alert contacts. The value is a JSON string.', example='[{"userName":"Tom","userPhone":"89756******"},{"userName":"Bob","ding":"http://www.example.com"}]'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='Test'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is not supported. You do not need to specify this parameter.', example='schedulerx'),
  notificationPolicyName?: string(name='NotificationPolicyName', example='test-workday-notification'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  scheduleBusyWorkers?: boolean(name='ScheduleBusyWorkers', description='Specifies whether to schedule a busy worker.', example='false'),
}

model CreateAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    appGroupId?: long(name='AppGroupId', description='The job group ID.', example='6607'),
    appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviL******'),
  }(name='Data', description='The information about the job group.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='883AFE93-FB03-4FA9-A958-E750C6DE120C'),
  success?: boolean(name='Success', description='Indicates whether the application was created. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateAppGroupResponseBody(name='body'),
}

/**
 * @summary Creates an application group. The AppKey is returned.
 *
 * @param request CreateAppGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateAppGroupResponse
 */
@context("createAppGroupWithContext")
async function createAppGroupWithOptions(request: CreateAppGroupRequest, runtime: $RuntimeOptions): CreateAppGroupResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates an application group. The AppKey is returned.
 *
 * @param request CreateAppGroupRequest
 * @return CreateAppGroupResponse
 */
async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  return createAppGroupWithOptions(request, runtime);
}

model CreateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The time interval between retry attempts in case of a job failure. Unit: seconds. Default value: 30.', example='30'),
  calendar?: string(name='Calendar', description='If you set TimeType to 1 (cron), you can specify calendar days.', example='This parameter is not supported. You do not need to specify this parameter.'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This parameter is available only when you set JobType to java. You must enter a full path.', example='com.alibaba.schedulerx.test.helloworld'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that a single worker triggers simultaneously. You can specify this parameter for MapReduce jobs. Default value: 5.', example='5'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.[](https://open.dingtalk.com/document/org/application-types)', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the alert contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the alert contact.', example='Tom'),
      userPhone?: string(name='UserPhone', description='The mobile number of the alert contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information about the alert contact.'),
  content?: string(name='Content', description='The script content. This parameter is required when you set JobType to python, shell, go, or k8s.', example='echo \\\\"hello\\\\"'),
  dataOffset?: int32(name='DataOffset', description='If you set TimeType to 1 (cron), you can specify a time offset. Unit: seconds.', example='2400'),
  description?: string(name='Description', description='The job description.', example='Test'),
  dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. This parameter is an advanced configuration item of the MapReduce job. Default value: 5.', example='5'),
  executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **Stand-alone operation**
*   **Broadcast run**
*   **Visual MapReduce**
*   **MapReduce**
*   **Shard run**

This parameter is required.', example='standalone'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to trigger an alert when a job fails. Valid values:

*   **true**: triggers an alert when a job fails.
*   **false**: does not trigger an alert when a job fails.', example='false'),
  failTimes?: int32(name='FailTimes', description='The maximum number of consecutive failures before an alert is triggered. An alert will be triggered if the number of consecutive failures reaches the value of this parameter.', example='2'),
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobType?: string(name='JobType', description='The job type. Valid values:

*   java
*   python
*   shell
*   go
*   http
*   xxljob
*   dataworks
*   k8s
*   springschedule

This parameter is required.', example='java'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retry attempts in case of a job failure. Specify this parameter based on your business requirements. Default value: 0.', example='0'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of concurrent instances. By default, only one instance can run at a time. When an instance is running, the next instance is not triggered even if the scheduled start time arrives.', example='1'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to generate an alert if no machines are available to run the job. Valid values:

*   **true**: generates an alert if no machines are available to run the job.
*   **false**: does not generate an alert if no machines are available to run the job.', example='false'),
  name?: string(name='Name', description='The job name.

This parameter is required.', example='helloworld'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. You must specify this parameter only if the namespace is provided by a third party.', example='schedulerx'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. You can specify this parameter for MapReduce jobs. Default value: 100.', example='100'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when the job is running.', example='test'),
  priority?: int32(name='Priority'),
  queueSize?: int32(name='QueueSize', description='The maximum capacity of the task queue. You can specify this parameter for MapReduce jobs. Default value: 10000.', example='10000'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  sendChannel?: string(name='SendChannel', description='The method that is used to send alerts. Set the value to sms. Default value: sms.', example='sms'),
  status?: int32(name='Status', description='Specifies whether to enable the job. If this parameter is set to 0, the job is disabled. If this parameter is set to 1, the job is enabled. Default value: 1.', example='1'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable', description='Specifies whether to send notifications for successfully running the job.', example='false'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The time interval between retry attempts in case of a job failure. This parameter is an advanced configuration item of the MapReduce job. Default value: 0.', example='0'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The maximum number of retry attempts in case of a job failure. This parameter is an advanced configuration item of the MapReduce job. Default value: 0.', example='0'),
  timeExpression?: string(name='TimeExpression', description='The time expression. Specify the time expression based on the value of TimeType:

*   If you set TimeType to **1** (cron), specify this parameter to a standard CRON expression.
*   If you set TimeType to **100** (api), no time expression is required.
*   If you set TimeType to **3** (fixed_rate), specify this parameter to a fixed frequency in seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   If you set TimeType to **4** (second_delay), specify this parameter to a fixed delay after which the job is triggered. Valid values: 1 to 60. Unit: seconds.
*   If you set TimeType to **5** (one_time), specify this parameter to a specific time point at which the job is triggered. The time is in the format of yyyy-MM-dd HH:mm:ss, such as 2022-10-10 10:10:00, or a timestamp in milliseconds.', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', description='The time type. Valid values:

*   **1**: cron
*   **3**: fixed_rate
*   **4**: second_delay
*   **5**: one_time
*   **100**: api

This parameter is required.', example='1'),
  timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='7200'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to enable the timeout alert feature. If the feature is enabled, an alert will be triggered upon a timeout. Valid values:

*   **true**: enables the timeout alert feature.
*   **false**: disables the timeout alert feature.', example='false'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to enable the timeout termination feature. If the feature is enabled, a job will automatically be terminated if it times out. Valid values:

*   **true**: enables the timeout termination feature.
*   **false**: disables the timeout termination feature.', example='false'),
  timezone?: string(name='Timezone', description='Time zone.', example='GMT+8'),
  XAttrs?: string(name='XAttrs', description='The extended attributes. If you set JobType to k8s, this parameter is required. For a job whose resource type is Job-YAML, set this parameter to {"resource":"job"}. For a job whose resource type is Shell-Script, set this parameter to {"image":"busybox","resource":"shell"}.', example='{"resource":"job"}'),
}

model CreateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    jobId?: long(name='JobId', description='The job ID.', example='92583'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='If you set JobType to k8s, this parameter is required. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateJobResponseBody(name='body'),
}

/**
 * @summary Creates a job and obtains the job ID.
 *
 * @param request CreateJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateJobResponse
 */
@context("createJobWithContext")
async function createJobWithOptions(request: CreateJobRequest, runtime: $RuntimeOptions): CreateJobResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!$isNull(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!$isNull(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!$isNull(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!$isNull(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!$isNull(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!$isNull(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!$isNull(request.failTimes)) {
    body['FailTimes'] = request.failTimes;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobType)) {
    body['JobType'] = request.jobType;
  }
  if (!$isNull(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!$isNull(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!$isNull(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!$isNull(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!$isNull(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!$isNull(request.status)) {
    body['Status'] = request.status;
  }
  if (!$isNull(request.successNoticeEnable)) {
    body['SuccessNoticeEnable'] = request.successNoticeEnable;
  }
  if (!$isNull(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!$isNull(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!$isNull(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!$isNull(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!$isNull(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!$isNull(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!$isNull(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  if (!$isNull(request.timezone)) {
    body['Timezone'] = request.timezone;
  }
  if (!$isNull(request.XAttrs)) {
    body['XAttrs'] = request.XAttrs;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a job and obtains the job ID.
 *
 * @param request CreateJobRequest
 * @return CreateJobResponse
 */
async function createJob(request: CreateJobRequest): CreateJobResponse {
  var runtime = new $RuntimeOptions{};
  return createJobWithOptions(request, runtime);
}

model CreateNamespaceRequest {
  description?: string(name='Description', description='The description of the namespace.', example='Test'),
  name?: string(name='Name', description='The name of the namespace.

This parameter is required.', example='test-env'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  uid?: string(name='Uid', description='The unique identifier (UID) of the namespace. We recommend that you use the universally unique identifier (UUID) to generate the UID.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
}

model CreateNamespaceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    namespaceUid?: string(name='NamespaceUid', description='The UID of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  }(name='Data', description='The information about the namespace.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='namespace=test3 is existed, noting update'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the application was created. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateNamespaceResponseBody(name='body'),
}

/**
 * @summary Creates a namespace.
 *
 * @param request CreateNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateNamespaceResponse
 */
@context("createNamespaceWithContext")
async function createNamespaceWithOptions(request: CreateNamespaceRequest, runtime: $RuntimeOptions): CreateNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.uid)) {
    query['Uid'] = request.uid;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateNamespace',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a namespace.
 *
 * @param request CreateNamespaceRequest
 * @return CreateNamespaceResponse
 */
async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return createNamespaceWithOptions(request, runtime);
}

model CreateRouteStrategyRequest {
  groupId?: string(name='GroupId', description='The ID of the application group. You can obtain the ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the ID on the **Task Management** page in the SchedulerX console.', example='54978'),
  name?: string(name='Name', description='The name of the routing policy.

This parameter is required.', example='test-strategy'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  status?: int32(name='Status', description='Specifies whether to enable the routing policy. Valid values:

*   **0**: disables the routing policy.
*   **1**: enables the routing policy.', example='1'),
  strategyContent?: string(name='StrategyContent', description='The details of the routing policy. The value is a JSON string. For more information about this parameter, see **the additional information about request parameters** below this table.', example='[{"percentage":20,"target":"[\\\\"version1\\\\"]","targetType":"label"}]'),
  type?: int32(name='Type', description='The type of the routing policy. Valid value:

*   **3**: routes by proportion.', example='3'),
}

model CreateRouteStrategyResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The additional information, including errors and tips.', example='strategy name is null or empty.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model CreateRouteStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRouteStrategyResponseBody(name='body'),
}

/**
 * @summary Creates a routing policy.
 *
 * @param request CreateRouteStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateRouteStrategyResponse
 */
@context("createRouteStrategyWithContext")
async function createRouteStrategyWithOptions(request: CreateRouteStrategyRequest, runtime: $RuntimeOptions): CreateRouteStrategyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.name)) {
    query['Name'] = request.name;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.strategyContent)) {
    query['StrategyContent'] = request.strategyContent;
  }
  if (!$isNull(request.type)) {
    query['Type'] = request.type;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a routing policy.
 *
 * @param request CreateRouteStrategyRequest
 * @return CreateRouteStrategyResponse
 */
async function createRouteStrategy(request: CreateRouteStrategyRequest): CreateRouteStrategyResponse {
  var runtime = new $RuntimeOptions{};
  return createRouteStrategyWithOptions(request, runtime);
}

model CreateSchedulerxCalendarRequest {
  calendarName?: string(name='CalendarName', description='The calendar name.

This parameter is required.', example='2025workday'),
  monthDaysContent?: string(name='MonthDaysContent', description='The month and days.

This parameter is required.', example='[
  {"month":1,"days":[3,4,5,6,9,10,11,12,13,16,17,18,19,20,28,29,30,31]},
  {"month":2,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28]},
  {"month":3,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30,31]},
  {"month":4,"days":[3,4,6,7,10,11,12,13,14,17,18,19,20,21,23,24,25,26,27,28]},
  {"month":5,"days":[4,5,6,8,9,10,11,12,15,16,17,18,19,22,23,24,25,26,29,30,31]},
  {"month":6,"days":[1,2,5,6,7,8,9,12,13,14,15,16,19,20,21,25,26,27,28,29,30]},
  {"month":7,"days":[3,4,5,6,7,10,11,12,13,14,17,18,19,20,21,24,25,26,27,28,31]},
  {"month":8,"days":[1,2,3,4,7,8,9,10,11,14,15,16,17,18,21,22,23,24,25,28,29,30,31]},
  {"month":9,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28]},
  {"month":10,"days":[7,8,9,10,11,12,13,16,17,18,19,20,23,24,25,26,27,30,31]},
  {"month":11,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30]},
  {"month":12,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28,29]}
]'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  year?: int32(name='Year', description='The year.

This parameter is required.', example='2025'),
}

model CreateSchedulerxCalendarResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas: CreateSchedulerxCalendar'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='Th status code.', example='200'),
  message?: string(name='Message', description='Additional information. Returned only when an error occurs.', example='calendar \\\\"2025workday\\\\" already exists in year 2025'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateSchedulerxCalendarResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSchedulerxCalendarResponseBody(name='body'),
}

/**
 * @summary Creates a calendar.
 *
 * @param request CreateSchedulerxCalendarRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSchedulerxCalendarResponse
 */
@context("createSchedulerxCalendarWithContext")
async function createSchedulerxCalendarWithOptions(request: CreateSchedulerxCalendarRequest, runtime: $RuntimeOptions): CreateSchedulerxCalendarResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.calendarName)) {
    body['CalendarName'] = request.calendarName;
  }
  if (!$isNull(request.monthDaysContent)) {
    body['MonthDaysContent'] = request.monthDaysContent;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.year)) {
    body['Year'] = request.year;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSchedulerxCalendar',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a calendar.
 *
 * @param request CreateSchedulerxCalendarRequest
 * @return CreateSchedulerxCalendarResponse
 */
async function createSchedulerxCalendar(request: CreateSchedulerxCalendarRequest): CreateSchedulerxCalendarResponse {
  var runtime = new $RuntimeOptions{};
  return createSchedulerxCalendarWithOptions(request, runtime);
}

model CreateSchedulerxNotificationPolicyRequest {
  channelTimeRange?: string(name='ChannelTimeRange', description='The configuration for the effective time periods of notification channels.

>  Please see the detailed explanation of this parameter below.

This parameter is required.', example='{
  "sendChannel": "sms,webhook,mail,phone",
  "timezone": "UTC+08:00",
  "webhookIsAtAll": "false",
  "timeRanges": {
    "all": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [1, 2, 3, 4, 5]
      }
    ]
  }
}'),
  description?: string(name='Description', description='The description of the notification policy.', example='Monday-Friday only'),
  policyName?: string(name='PolicyName', description='The name of the notification policy.

This parameter is required.', example='test-weekdays'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model CreateSchedulerxNotificationPolicyResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:CreateSchedulerxNotificationPolicy'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='Additional information. Returned only when an error occurs.', example='Invalid parameter: Notification policy already exists: test-weekdays'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model CreateSchedulerxNotificationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateSchedulerxNotificationPolicyResponseBody(name='body'),
}

/**
 * @summary Creates a notification policy.
 *
 * @param request CreateSchedulerxNotificationPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateSchedulerxNotificationPolicyResponse
 */
@context("createSchedulerxNotificationPolicyWithContext")
async function createSchedulerxNotificationPolicyWithOptions(request: CreateSchedulerxNotificationPolicyRequest, runtime: $RuntimeOptions): CreateSchedulerxNotificationPolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.channelTimeRange)) {
    body['ChannelTimeRange'] = request.channelTimeRange;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateSchedulerxNotificationPolicy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a notification policy.
 *
 * @param request CreateSchedulerxNotificationPolicyRequest
 * @return CreateSchedulerxNotificationPolicyResponse
 */
async function createSchedulerxNotificationPolicy(request: CreateSchedulerxNotificationPolicyRequest): CreateSchedulerxNotificationPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return createSchedulerxNotificationPolicyWithOptions(request, runtime);
}

model CreateWorkflowRequest {
  description?: string(name='Description', description='The description of the workflow.', example='Test'),
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of workflow instances that can be run at the same time. Default value: 1. The value 1 indicates that only one workflow instance is allowed. In this case, if the triggered workflow instance is still ongoing, no more workflow instances can be triggered even the time to schedule the next workflow arrives.', example='1'),
  name?: string(name='Name', description='The name of the workflow.

This parameter is required.', example='helloworld'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression based on the selected method that is used to specify time.

- If you set the TimeType parameter to cron, you need to enter a standard cron expression. Online verification is supported.
- If you set the TimeType parameter to api, no time expression is required.', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', description='The method that is used to specify the time. Valid values:

- 1: cron
- 100: api

This parameter is required.', example='1'),
  timezone?: string(name='Timezone', description='The time zone.', example='GMT+8'),
}

model CreateWorkflowResponseBody = {
  code?: string(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    workflowId?: long(name='WorkflowId', description='The workflow ID.', example='92583'),
  }(name='Data', description='The data that was returned for the request.'),
  message?: string(name='Message', description='The returned error message.', example='timetype is invalid'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the workflow was created. Valid values:

- true
- false', example='true'),
}

model CreateWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateWorkflowResponseBody(name='body'),
}

/**
 * @summary Creates a workflow. By default, the created workflow is disabled. After you update the directed acyclic graph (DAG) of the workflow, you must manually or call the corresponding operation to enable the workflow. You can call this operation only in the professional edition.
 *
 * @param request CreateWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return CreateWorkflowResponse
 */
@context("createWorkflowWithContext")
async function createWorkflowWithOptions(request: CreateWorkflowRequest, runtime: $RuntimeOptions): CreateWorkflowResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!$isNull(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!$isNull(request.timezone)) {
    body['Timezone'] = request.timezone;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'CreateWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Creates a workflow. By default, the created workflow is disabled. After you update the directed acyclic graph (DAG) of the workflow, you must manually or call the corresponding operation to enable the workflow. You can call this operation only in the professional edition.
 *
 * @param request CreateWorkflowRequest
 * @return CreateWorkflowResponse
 */
async function createWorkflow(request: CreateWorkflowRequest): CreateWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return createWorkflowWithOptions(request, runtime);
}

model DeleteAppGroupRequest {
  deleteJobs?: boolean(name='DeleteJobs', description='Specifies whether to delete the jobs in the application group. Valid values:

true: deletes the jobs in the application group.
false: does not delete the jobs in the application group.', example='true'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indices whether the request was successful. Valid values:

true: The request was successful.
false: The request failed.', example='true'),
}

model DeleteAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteAppGroupResponseBody(name='body'),
}

/**
 * @summary The additional information that is returned.
 *
 * @param request DeleteAppGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteAppGroupResponse
 */
@context("deleteAppGroupWithContext")
async function deleteAppGroupWithOptions(request: DeleteAppGroupRequest, runtime: $RuntimeOptions): DeleteAppGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.deleteJobs)) {
    query['DeleteJobs'] = request.deleteJobs;
  }
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The additional information that is returned.
 *
 * @param request DeleteAppGroupRequest
 * @return DeleteAppGroupResponse
 */
async function deleteAppGroup(request: DeleteAppGroupRequest): DeleteAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  return deleteAppGroupWithOptions(request, runtime);
}

model DeleteJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID on the **Task Management** page in the SchedulerX console.

This parameter is required.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job was deleted. Valid values:

*   **true**: The job was deleted.
*   **false**: The job was not deleted.', example='true'),
}

model DeleteJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteJobResponseBody(name='body'),
}

/**
 * @summary Deletes a specified job.
 *
 * @param request DeleteJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteJobResponse
 */
@context("deleteJobWithContext")
async function deleteJobWithOptions(request: DeleteJobRequest, runtime: $RuntimeOptions): DeleteJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a specified job.
 *
 * @param request DeleteJobRequest
 * @return DeleteJobResponse
 */
async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  var runtime = new $RuntimeOptions{};
  return deleteJobWithOptions(request, runtime);
}

model DeleteNamespaceRequest {
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteNamespaceResponseBody = {
  code?: int32(name='Code', description='The returned code.', example='200'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='The system namespace cannot be deleted'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401107'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DeleteNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteNamespaceResponseBody(name='body'),
}

/**
 * @summary Deletes a namespace.
 *
 * @param request DeleteNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteNamespaceResponse
 */
@context("deleteNamespaceWithContext")
async function deleteNamespaceWithOptions(request: DeleteNamespaceRequest, runtime: $RuntimeOptions): DeleteNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteNamespace',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a namespace.
 *
 * @param request DeleteNamespaceRequest
 * @return DeleteNamespaceResponse
 */
async function deleteNamespace(request: DeleteNamespaceRequest): DeleteNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return deleteNamespaceWithOptions(request, runtime);
}

model DeleteRouteStrategyRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the **Task Management** page in the SchedulerX console.', example='92583'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='strategy is already deleted.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model DeleteRouteStrategyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRouteStrategyResponseBody(name='body'),
}

/**
 * @summary Deletes a routing policy.
 *
 * @param request DeleteRouteStrategyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteRouteStrategyResponse
 */
@context("deleteRouteStrategyWithContext")
async function deleteRouteStrategyWithOptions(request: DeleteRouteStrategyRequest, runtime: $RuntimeOptions): DeleteRouteStrategyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteRouteStrategy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a routing policy.
 *
 * @param request DeleteRouteStrategyRequest
 * @return DeleteRouteStrategyResponse
 */
async function deleteRouteStrategy(request: DeleteRouteStrategyRequest): DeleteRouteStrategyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteRouteStrategyWithOptions(request, runtime);
}

model DeleteSchedulerxCalendarRequest {
  calendarName?: string(name='CalendarName', description='The calendar name.

This parameter is required.', example='2025workday'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  year?: int32(name='Year', description='The year.

This parameter is required.', example='2025'),
}

model DeleteSchedulerxCalendarResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:DeleteSchedulerxCalendar'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='Additional information. Returned only when an error occurs.', example='calendar \\\\"2025workday\\\\" does not exist in year 2025'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DeleteSchedulerxCalendarResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSchedulerxCalendarResponseBody(name='body'),
}

/**
 * @summary Deletes a calendar.
 *
 * @param request DeleteSchedulerxCalendarRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSchedulerxCalendarResponse
 */
@context("deleteSchedulerxCalendarWithContext")
async function deleteSchedulerxCalendarWithOptions(request: DeleteSchedulerxCalendarRequest, runtime: $RuntimeOptions): DeleteSchedulerxCalendarResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.calendarName)) {
    body['CalendarName'] = request.calendarName;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.year)) {
    body['Year'] = request.year;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSchedulerxCalendar',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a calendar.
 *
 * @param request DeleteSchedulerxCalendarRequest
 * @return DeleteSchedulerxCalendarResponse
 */
async function deleteSchedulerxCalendar(request: DeleteSchedulerxCalendarRequest): DeleteSchedulerxCalendarResponse {
  var runtime = new $RuntimeOptions{};
  return deleteSchedulerxCalendarWithOptions(request, runtime);
}

model DeleteSchedulerxNotificationPolicyRequest {
  policyName?: string(name='PolicyName', description='The name of the notification policy.

This parameter is required.', example='test-weekdays'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DeleteSchedulerxNotificationPolicyResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:DeleteSchedulerxNotificationPolicy'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFoiYKaaImCmkI3QjgzNzM1LTIzQTUtNURENy1COUQ3LTBFOTIxRkRFOEM3NQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message. Returned only when an error occurs.', example='Invalid parameter: policyName cannot be null'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='C8E5FB4A-6D8D-424D-9AAA-4FE06BB74FF9'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DeleteSchedulerxNotificationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSchedulerxNotificationPolicyResponseBody(name='body'),
}

/**
 * @summary Deletes a notification policy.
 *
 * @param request DeleteSchedulerxNotificationPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteSchedulerxNotificationPolicyResponse
 */
@context("deleteSchedulerxNotificationPolicyWithContext")
async function deleteSchedulerxNotificationPolicyWithOptions(request: DeleteSchedulerxNotificationPolicyRequest, runtime: $RuntimeOptions): DeleteSchedulerxNotificationPolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteSchedulerxNotificationPolicy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a notification policy.
 *
 * @param request DeleteSchedulerxNotificationPolicyRequest
 * @return DeleteSchedulerxNotificationPolicyResponse
 */
async function deleteSchedulerxNotificationPolicy(request: DeleteSchedulerxNotificationPolicyRequest): DeleteSchedulerxNotificationPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return deleteSchedulerxNotificationPolicyWithOptions(request, runtime);
}

model DeleteWorkflowRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='111'),
}

model DeleteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow was deleted. Valid values:

*   **true**
*   **false**', example='true'),
}

model DeleteWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteWorkflowResponseBody(name='body'),
}

/**
 * @summary Deletes a workflow.
 *
 * @param request DeleteWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DeleteWorkflowResponse
 */
@context("deleteWorkflowWithContext")
async function deleteWorkflowWithOptions(request: DeleteWorkflowRequest, runtime: $RuntimeOptions): DeleteWorkflowResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DeleteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Deletes a workflow.
 *
 * @param request DeleteWorkflowRequest
 * @return DeleteWorkflowResponse
 */
async function deleteWorkflow(request: DeleteWorkflowRequest): DeleteWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return deleteWorkflowWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that was returned only if the corresponding error occurred.', example='disable failed jobs=[99341]'),
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The display name of the region, which varies based on the current language.', example='China (Hangzhou)'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint of the region.', example='schedulerx.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The available regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**: The request was successful.
*   **false**: The request failed.', example='true'),
}

model DescribeRegionsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRegionsResponseBody(name='body'),
}

/**
 * @summary Returns available regions.
 *
 * @param request DescribeRegionsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DescribeRegionsResponse
 */
@context("describeRegionsWithContext")
async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: $RuntimeOptions): DescribeRegionsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DescribeRegions',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Returns available regions.
 *
 * @param request DescribeRegionsRequest
 * @return DescribeRegionsResponse
 */
async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new $RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DesignateWorkersRequest {
  designateType?: int32(name='DesignateType', description='The type of the machines to be designated. Valid values: 1 and 2. The value 1 specifies the worker type. The value 2 specifies the label type.

This parameter is required.', example='1'),
  groupId?: string(name='GroupId', description='The application group ID.

This parameter is required.', example='hxm.test'),
  jobId?: long(name='JobId', description='The job ID.

This parameter is required.', example='144153'),
  labels?: string(name='Labels', description='The designated `labels`. Specify the value of the parameter in a `JSON` string.', example='["gray"]'),
  namespace?: string(name='Namespace', description='The unique identifier (UID) of the namespace.

This parameter is required.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='public'),
  transferable?: boolean(name='Transferable', description='Specifies whether to allow a failover.

This parameter is required.', example='true'),
  workers?: string(name='Workers', description='The designated machines. Specify the value of the parameter in a JSON string.', example='["127.0.0.1","127.0.0.2"]'),
}

model DesignateWorkersResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='job is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='765xxx'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model DesignateWorkersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DesignateWorkersResponseBody(name='body'),
}

/**
 * @summary Designates machines.
 *
 * @param request DesignateWorkersRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DesignateWorkersResponse
 */
@context("designateWorkersWithContext")
async function designateWorkersWithOptions(request: DesignateWorkersRequest, runtime: $RuntimeOptions): DesignateWorkersResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DesignateWorkers',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Designates machines.
 *
 * @param request DesignateWorkersRequest
 * @return DesignateWorkersResponse
 */
async function designateWorkers(request: DesignateWorkersRequest): DesignateWorkersResponse {
  var runtime = new $RuntimeOptions{};
  return designateWorkersWithOptions(request, runtime);
}

model DisableJobRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model DisableJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='C8E5FB4A-6D8D-424D-9AAA-4FE06BB74FF9'),
  success?: boolean(name='Success', description='Indicates whether the job was disabled. Valid values:

*   **true**
*   **false**', example='true'),
}

model DisableJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableJobResponseBody(name='body'),
}

/**
 * @summary Disables a job.
 *
 * @param request DisableJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableJobResponse
 */
@context("disableJobWithContext")
async function disableJobWithOptions(request: DisableJobRequest, runtime: $RuntimeOptions): DisableJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables a job.
 *
 * @param request DisableJobRequest
 * @return DisableJobResponse
 */
async function disableJob(request: DisableJobRequest): DisableJobResponse {
  var runtime = new $RuntimeOptions{};
  return disableJobWithOptions(request, runtime);
}

model DisableWorkflowRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='111'),
}

model DisableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow was disabled. Valid values:

*   **true**
*   **false**', example='true'),
}

model DisableWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableWorkflowResponseBody(name='body'),
}

/**
 * @summary Disables a specified workflow.
 *
 * @param request DisableWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return DisableWorkflowResponse
 */
@context("disableWorkflowWithContext")
async function disableWorkflowWithOptions(request: DisableWorkflowRequest, runtime: $RuntimeOptions): DisableWorkflowResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'DisableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Disables a specified workflow.
 *
 * @param request DisableWorkflowRequest
 * @return DisableWorkflowResponse
 */
async function disableWorkflow(request: DisableWorkflowRequest): DisableWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return disableWorkflowWithOptions(request, runtime);
}

model EnableJobRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model EnableJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model EnableJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableJobResponseBody(name='body'),
}

/**
 * @summary Enables a job.
 *
 * @param request EnableJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableJobResponse
 */
@context("enableJobWithContext")
async function enableJobWithOptions(request: EnableJobRequest, runtime: $RuntimeOptions): EnableJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables a job.
 *
 * @param request EnableJobRequest
 * @return EnableJobResponse
 */
async function enableJob(request: EnableJobRequest): EnableJobResponse {
  var runtime = new $RuntimeOptions{};
  return enableJobWithOptions(request, runtime);
}

model EnableWorkflowRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='111'),
}

model EnableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow was enabled. Valid values:

*   **true**
*   **false**', example='true'),
}

model EnableWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableWorkflowResponseBody(name='body'),
}

/**
 * @summary Enables a specified workflow.
 *
 * @param request EnableWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return EnableWorkflowResponse
 */
@context("enableWorkflowWithContext")
async function enableWorkflowWithOptions(request: EnableWorkflowRequest, runtime: $RuntimeOptions): EnableWorkflowResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'EnableWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Enables a specified workflow.
 *
 * @param request EnableWorkflowRequest
 * @return EnableWorkflowResponse
 */
async function enableWorkflow(request: EnableWorkflowRequest): EnableWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return enableWorkflowWithOptions(request, runtime);
}

model ExecuteJobRequest {
  checkJobStatus?: boolean(name='CheckJobStatus', description='Specifies whether to check the job status. Valid values: -**true**: The job can be run only if the job is enabled. -**false**: The job can be run even if the job is disabled.', example='true'),
  designateType?: int32(name='DesignateType', description='The type of the designated machine. Valid values: -**1**: worker. -**2**: label.', example='1'),
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  instanceParameters?: string(name='InstanceParameters', description='The parameters that are passed to trigger the job to run. The input value can be a random string. The parameters that are passed are obtained by calling the `context.getInstanceParameters()` class in the `processor` code. The parameters are different from custom parameters for creating jobs.', example='test'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  label?: string(name='Label', description='The label of the worker.', example='gray'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  worker?: string(name='Worker', description='The worker address of the application. To query the worker address, call the GetWokerList operation.', example='xxxxxxx@127.0.0.1:222'),
}

model ExecuteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    jobInstanceId?: long(name='JobInstanceId', description='The job instance ID.', example='11111111'),
  }(name='Data', description='The ID of the job instance that is returned if the request is successful.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='groupid not exist groupId: testSchedulerx.defaultGroup namespace: adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   `true`
*   `false`', example='true'),
}

model ExecuteJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteJobResponseBody(name='body'),
}

/**
 * @summary Triggers a job to immediately run once.
 *
 * @description > The combination of the `JobID` and `ScheduleTime` parameters serves as a unique index. Therefore, after the ExecuteJob operation is called to run a job once, a sleep for one second is required before the ExecuteJob operation is called to run the job again. Otherwise, the job may fail.
 *
 * @param request ExecuteJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteJobResponse
 */
@context("executeJobWithContext")
async function executeJobWithOptions(request: ExecuteJobRequest, runtime: $RuntimeOptions): ExecuteJobResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExecuteJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Triggers a job to immediately run once.
 *
 * @description > The combination of the `JobID` and `ScheduleTime` parameters serves as a unique index. Therefore, after the ExecuteJob operation is called to run a job once, a sleep for one second is required before the ExecuteJob operation is called to run the job again. Otherwise, the job may fail.
 *
 * @param request ExecuteJobRequest
 * @return ExecuteJobResponse
 */
async function executeJob(request: ExecuteJobRequest): ExecuteJobResponse {
  var runtime = new $RuntimeOptions{};
  return executeJobWithOptions(request, runtime);
}

model ExecuteWorkflowRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  instanceParameters?: string(name='InstanceParameters', description='The dynamic parameter of the workflow instance. The value of the parameter can be up to 1,000 bytes in length.', example='test'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region information.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='111'),
}

model ExecuteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    wfInstanceId?: long(name='WfInstanceId', description='The workflow instance ID.', example='111111'),
  }(name='Data', description='If the request is successful, the ID of the workflow instance is returned.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ExecuteWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ExecuteWorkflowResponseBody(name='body'),
}

/**
 * @summary Immediately triggers a workflow.
 *
 * @param request ExecuteWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ExecuteWorkflowResponse
 */
@context("executeWorkflowWithContext")
async function executeWorkflowWithOptions(request: ExecuteWorkflowRequest, runtime: $RuntimeOptions): ExecuteWorkflowResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ExecuteWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Immediately triggers a workflow.
 *
 * @param request ExecuteWorkflowRequest
 * @return ExecuteWorkflowResponse
 */
async function executeWorkflow(request: ExecuteWorkflowRequest): ExecuteWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return executeWorkflowWithOptions(request, runtime);
}

model GetAppGroupRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
}

model GetAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    appKey?: string(name='AppKey', description='The AppKey of the application.', example='QI4lWMZ+xk1rNB67jFUhaw=='),
    appName?: string(name='AppName', description='The name of the application.', example='DocTest'),
    appVersion?: string(name='AppVersion', description='The application version. 1: Basic version, 2: Professional version.', example='2'),
    curJobs?: int32(name='CurJobs', description='The number of jobs that are configured for the application group.', example='1'),
    description?: string(name='Description', description='The description of the application.', example='Test'),
    enableLog?: boolean(name='EnableLog'),
    groupId?: string(name='GroupId', description='The ID of the application.', example='testSchedulerx.defaultGroup'),
    maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs that can be configured for the application group.', example='1000'),
    monitorConfigJson?: string(name='MonitorConfigJson', description='The alert notification configurations.

>  For more information about this parameter, see the following **additional information about request parameters**.', example='{"sendChannel":"sms,mail,ding"}'),
    monitorContactsJson?: string(name='MonitorContactsJson', description='The alert contact configurations.

>  For more information about this parameter, see the following **additional information about request parameters**.', example='[ {"name": "Peter"}, {"name": "Paul"} ]'),
    namespace?: string(name='Namespace', description='The ID of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
    notificationPolicyName?: string(name='NotificationPolicyName', example='test-workday-notification'),
  }(name='Data', description='The information about the application group.'),
  message?: string(name='Message', description='The additional information that is returned.', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

- **true**: The request was successful.
- **false**: The request failed.', example='true'),
}

model GetAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAppGroupResponseBody(name='body'),
}

/**
 * @summary The configuration of the alert. The value is a JSON string. For more information, see \\\\*\\\\*the additional information about response parameters below this table\\\\*\\\\*.
 *
 * @param request GetAppGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetAppGroupResponse
 */
@context("getAppGroupWithContext")
async function getAppGroupWithOptions(request: GetAppGroupRequest, runtime: $RuntimeOptions): GetAppGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary The configuration of the alert. The value is a JSON string. For more information, see \\\\*\\\\*the additional information about response parameters below this table\\\\*\\\\*.
 *
 * @param request GetAppGroupRequest
 * @return GetAppGroupResponse
 */
async function getAppGroup(request: GetAppGroupRequest): GetAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  return getAppGroupWithOptions(request, runtime);
}

model GetJobInfoRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  jobName?: string(name='JobName', description='The job name.', example='simpleJob'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The namespace source. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model GetJobInfoResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    jobConfigInfo?: {
      attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retried to run the job after a job failure. Default value: 30. Unit: seconds.', example='30'),
      className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for jobs whose job type is Java.', example='com.alibaba.test.helloword'),
      content?: string(name='Content', description='The script of a script job.', example='echo "clear" > /home/admin/edas-container/logs/catalina.out'),
      description?: string(name='Description', description='The description of the job.', example='test'),
      executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **Stand-alone operation**: standalone
*   **Broadcast run**: broadcast
*   **Visual MapReduce**: parallel
*   **MapReduce**: batch
*   **Shard run**: sharding', example='standalone'),
      jarUrl?: string(name='JarUrl', description='The full path used to upload files to Object Storage Service (OSS).

If you use a JAR package, you can upload the JAR package to this OSS path.', example='https://test.oss-cn-hangzhou.aliyuncs.com/schedulerX/test.jar'),
      jobId?: long(name='JobId', description='The job ID.', example='538039'),
      jobMonitorInfo?: {
        contactInfo?: [ 
          {
            ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=XXXXXX'),
            userMail?: string(name='UserMail', description='The email address of the alert contact.', example='user@demo.com'),
            userName?: string(name='UserName', description='The name of the alert contact.', example='userA'),
            userPhone?: string(name='UserPhone', description='The mobile phone number of the alert contact.', example='1381111****'),
          }
        ](name='ContactInfo', description='The alert contact Information.'),
        monitorConfig?: {
          failEnable?: boolean(name='FailEnable', description='Indicates whether the Failure alarm switch was turned on. Valid values:

*   **true**
*   **false**', example='true'),
          missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether the No machine alarm available switch was turned on.', example='true'),
          sendChannel?: string(name='SendChannel', description='The method used to send alerts. Only Short Message Service (SMS) is supported.', example='sms'),
          timeout?: long(name='Timeout', description='The timeout threshold. Default value: 7200. Unit: seconds.', example='12300'),
          timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether the Timeout alarm switch was turned on. Valid values:

*   **true**
*   **false**', example='true'),
          timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the Timeout termination switch was turned on. The switch is turned off by default.', example='true'),
        }(name='MonitorConfig', description='The configurations of the alerting features and the alert thresholds.'),
      }(name='JobMonitorInfo', description='The monitoring information of the job.'),
      jobType?: string(name='JobType', description='The job type.', example='java'),
      mapTaskXAttrs?: {
        consumerSize?: int32(name='ConsumerSize', description='The number of threads that were triggered by a single worker at a time. Default value: 5.', example='5'),
        dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
        pageSize?: int32(name='PageSize', description='The number of tasks that were pulled by a parallel job at a time. Default value: 100.', example='100'),
        queueSize?: int32(name='QueueSize', description='The maximum number of tasks that can be queued. Default value: 10000.', example='10000'),
        taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system retried to run the task after a task failure.', example='0'),
        taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
      }(name='MapTaskXAttrs', description='The advanced configurations of the job.'),
      maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter was specified based on your business requirements. Default value: 0.', example='0'),
      maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of concurrent instances. Default value: 1. The default value indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the next instance is reached.', example='1'),
      name?: string(name='Name', description='The job name.', example='helloworld'),
      parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when the job is running.', example='test'),
      status?: int32(name='Status', description='Indicates whether the job was enabled. Valid values:

*   **1**: The job was enabled and could be triggered.
*   **0**: The job was disabled and could not be triggered.', example='1'),
      timeConfig?: {
        calendar?: string(name='Calendar', description='Custom calendar days specified if TimeType is set to **1** (cron).', example='Business days'),
        dataOffset?: int32(name='DataOffset', description='The time offset specified if TimeType is set to **1** (cron). Unit: seconds.', example='0'),
        timeExpression?: string(name='TimeExpression', description='The time expression specified based on the value of TimeType:

*   If TimeType is set to **100** (api), no time expression is required.
*   If TimeType is set to **3** (fix_rate), this parameter value indicates the specific and fixed frequency. For example, if the value is 30, the system triggers a job every 30 seconds.
*   If TimeType is set to **1** (cron), this parameter value indicates the standard CRON expression used to specify the time when to schedule the job.
*   If TimeType is set to **4** (second_delay), this parameter value indicates the fixed delay after which the job is triggered. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
        timeType?: int32(name='TimeType', description='The time type. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **5**: one_time
*   **100**: api', example='1'),
      }(name='TimeConfig', description='The time configurations.'),
      XAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
    }(name='JobConfigInfo', description='The configurations of the job.'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The error message returned only if an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job details were obtained. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetJobInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobInfoResponseBody(name='body'),
}

/**
 * @summary Queries the details of a job based on the job ID. In most cases, the obtained information is used to update jobs.
 *
 * @param request GetJobInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobInfoResponse
 */
@context("getJobInfoWithContext")
async function getJobInfoWithOptions(request: GetJobInfoRequest, runtime: $RuntimeOptions): GetJobInfoResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetJobInfo',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a job based on the job ID. In most cases, the obtained information is used to update jobs.
 *
 * @param request GetJobInfoRequest
 * @return GetJobInfoResponse
 */
async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  var runtime = new $RuntimeOptions{};
  return getJobInfoWithOptions(request, runtime);
}

model GetJobInstanceRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID.

This parameter is required.', example='92583'),
  jobInstanceId?: long(name='JobInstanceId', description='The job instance ID.

This parameter is required.', example='11111111'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='This parameter is required.', example='cn-hangzhou'),
}

model GetJobInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    jobInstanceDetail?: {
      dataTime?: string(name='DataTime', description='The data timestamp of the job instance.', example='2020-07-27 11:52:10'),
      endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
      executor?: string(name='Executor', description='The user who executes the job.', example='A'),
      instanceId?: long(name='InstanceId', description='The job instance ID.', example='11111111'),
      jobId?: long(name='JobId', description='The job ID.', example='92583'),
      jobName?: string(name='JobName', description='The job name.', example='ManualJob'),
      parameters?: string(name='Parameters', description='The parameters of the job instance.', example='{\\\\"alertId\\\\":11111}'),
      progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
      result?: string(name='Result', description='The execution results of the job instance.', example='success'),
      scheduleTime?: string(name='ScheduleTime', description='The time when the job was scheduled to run.', example='2020-07-27 11:52:10'),
      startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
      status?: int32(name='Status', description='The state of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance failed.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
      timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
      traceId?: string(name='TraceId', description='The trace ID, which can be used to query trace details.', example='210e845016596663430048015d0a2c'),
      triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance was triggered at the scheduled time.
*   **2**: The job instance was triggered due to data update.
*   **3**: The job instance was triggered by an API call.
*   **4**: The job instance was triggered because it is manually rerun.
*   **5**: The job instance was triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
      workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
    }(name='JobInstanceDetail', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instance.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetJobInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the information about a job instance. You can view the status and progress of the job instance.
 *
 * @param request GetJobInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobInstanceResponse
 */
@context("getJobInstanceWithContext")
async function getJobInstanceWithOptions(request: GetJobInstanceRequest, runtime: $RuntimeOptions): GetJobInstanceResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetJobInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information about a job instance. You can view the status and progress of the job instance.
 *
 * @param request GetJobInstanceRequest
 * @return GetJobInstanceResponse
 */
async function getJobInstance(request: GetJobInstanceRequest): GetJobInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return getJobInstanceWithOptions(request, runtime);
}

model GetJobInstanceListRequest {
  endTimestamp?: long(name='EndTimestamp', description='The end of the time range to query. Specify a UNIX timestamp.', example='1684202400000'),
  groupId?: string(name='GroupId', description='The application group ID.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID.', example='92583'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.', example='10'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  startTimestamp?: long(name='StartTimestamp', description='The beginning of the time range to query. Specify a UNIX timestamp.', example='1684116000000'),
  status?: int32(name='Status', description='The status of the job instance. Valid values:

1: The job instance is pending. 3: The job instance is running. 4: The job instance is run. 5: The job instance fails. 9: The request for running the job instance is rejected. To specify this parameter, you must declare the following enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus.', example='5'),
}

model GetJobInstanceListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    jobInstanceDetails?: [ 
      {
        dataTime?: string(name='DataTime', description='The data timestamp of the job instance.', example='2020-07-27 11:52:10'),
        endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
        executor?: string(name='Executor', description='The user who executes the job.', example='A'),
        instanceId?: long(name='InstanceId', description='The job instance ID.', example='11111111'),
        jobId?: long(name='JobId', description='The job ID.', example='92583'),
        progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
        result?: string(name='Result', description='The execution results of the job instance.', example='success'),
        scheduleTime?: string(name='ScheduleTime', description='The time when the job was scheduled to run.', example='2020-07-27 11:52:10'),
        startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
        status?: int32(name='Status', description='The state of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance failed.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
        timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
        triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance was triggered at the scheduled time.
*   **2**: The job instance was triggered due to data updates.
*   **3**: The job instance was triggered by an API call.
*   **4**: The job instance was triggered because it is manually rerun.
*   **5**: The job instance was triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
        workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
      }
    ](name='JobInstanceDetails', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instances.'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetJobInstanceListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetJobInstanceListResponseBody(name='body'),
}

/**
 * @summary Queries the most recent 10 execution instances of a job.
 *
 * @param request GetJobInstanceListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetJobInstanceListResponse
 */
@context("getJobInstanceListWithContext")
async function getJobInstanceListWithOptions(request: GetJobInstanceListRequest, runtime: $RuntimeOptions): GetJobInstanceListResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetJobInstanceList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the most recent 10 execution instances of a job.
 *
 * @param request GetJobInstanceListRequest
 * @return GetJobInstanceListResponse
 */
async function getJobInstanceList(request: GetJobInstanceListRequest): GetJobInstanceListResponse {
  var runtime = new $RuntimeOptions{};
  return getJobInstanceListWithOptions(request, runtime);
}

model GetLogRequest {
  endTimestamp?: long(name='EndTimestamp', description='The time when the job stops running. Specify a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1675739484000'),
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: string(name='JobId', description='The job ID.', example='123'),
  jobInstanceId?: string(name='JobInstanceId', description='The job instance ID.', example='123456'),
  keyword?: string(name='Keyword', description='The keyword.', example='ERROR'),
  line?: int32(name='Line', description='The number of rows to return. The maximum number is 200.', example='50'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  offset?: int32(name='Offset', description='The number of offset rows. This parameter can be used for a paged query.', example='0'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  reverse?: boolean(name='Reverse', description='Specifies whether to reverse the order. By default, the order is reversed.', example='true'),
  startTimestamp?: long(name='StartTimestamp', description='The time when the job starts to run. Specify a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.', example='1675739364000'),
}

model GetLogResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    logs?: [ string ](name='Logs', description='The logs. The value is an array of strings.'),
  }(name='Data', description='The returned data.'),
  message?: string(name='Message', description='The returned error message.', example='jobid=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetLogResponseBody(name='body'),
}

/**
 * @summary Queries the operational logs of a job. You can call this operation only in the professional edition.
 *
 * @param request GetLogRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetLogResponse
 */
@context("getLogWithContext")
async function getLogWithOptions(request: GetLogRequest, runtime: $RuntimeOptions): GetLogResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetLog',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the operational logs of a job. You can call this operation only in the professional edition.
 *
 * @param request GetLogRequest
 * @return GetLogResponse
 */
async function getLog(request: GetLogRequest): GetLogResponse {
  var runtime = new $RuntimeOptions{};
  return getLogWithOptions(request, runtime);
}

model GetOverviewRequest {
  endTime?: long(name='EndTime', description='The end of the time range to query. The value must be a UNIX timestamp (in seconds). If left empty, the current time is used.', example='1684166400'),
  groupId?: string(name='GroupId', description='The application group ID.', example='testSchedulerx.defaultGroup'),
  metricType?: int32(name='MetricType', description='The metric type. Valid values:

*   0: the basic job data.
*   1: the job running data.

This parameter is required.', example='0'),
  namespace?: string(name='Namespace', description='The unique identifier (UID) of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  operate?: string(name='Operate', description='The query type. Valid values:

*   query: queries data in a time range.
*   query_range: queries time series data in a time range.

This parameter is required.', example='query'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. The value must be a UNIX timestamp (in seconds).

This parameter is required.', example='1684166400'),
}

model GetOverviewResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  data?: string(name='Data', description='The data returned in JSON format. Valid data types:

*   Basic job data.
*   Job running data.
*   Time series data for job execution: includes triggering statistics, records of successful and failed executions, and their associated timestamps within a specific time range.', example='{"schedulerx_job_counter_disable": "4","schedulerx_job_trigger_counter_running": "0","schedulerx_job_counter_enable": "70","schedulerx_job_counter_all": "74","schedulerx_worker_counter": "2"}'),
  message?: string(name='Message', description='Additional information. Returned only if an error occurs.', example='No access permission for the namespace [***]'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model GetOverviewResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetOverviewResponseBody(name='body'),
}

/**
 * @summary Retrieves job scheduling data for Professional Edition applications.
 *
 * @param request GetOverviewRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetOverviewResponse
 */
@context("getOverviewWithContext")
async function getOverviewWithOptions(request: GetOverviewRequest, runtime: $RuntimeOptions): GetOverviewResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.operate)) {
    query['Operate'] = request.operate;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetOverview',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieves job scheduling data for Professional Edition applications.
 *
 * @param request GetOverviewRequest
 * @return GetOverviewResponse
 */
async function getOverview(request: GetOverviewRequest): GetOverviewResponse {
  var runtime = new $RuntimeOptions{};
  return getOverviewWithOptions(request, runtime);
}

model GetWorkFlowRequest {
  groupId?: string(name='GroupId', description='The ID of the application group.

This parameter is required.', example='hxm.test'),
  namespace?: string(name='Namespace', description='The ID of the namespace.

This parameter is required.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace.', example='source'),
  regionId?: string(name='RegionId', description='The region information.

This parameter is required.', example='public'),
  workflowId?: long(name='WorkflowId', description='The ID of the workflow.

This parameter is required.', example='1234'),
}

model GetWorkFlowResponseBody = {
  code?: int32(name='Code', description='Error codes', example='200'),
  data?: {
    workFlowInfo?: {
      description?: string(name='Description', description='The description of the workflow.', example='my first workflow'),
      groupId?: string(name='GroupId'),
      maxConcurrency?: string(name='MaxConcurrency'),
      name?: string(name='Name', description='The name of the workflow.', example='workflow_111'),
      namespace?: string(name='Namespace'),
      status?: string(name='Status', description='The status of the workflow.', example='Successful'),
      timeExpression?: string(name='TimeExpression', description='The time expression of the workflow.', example='0 0 2 * * ?'),
      timeType?: string(name='TimeType', description='The time type of the workflow.', example='cron'),
      workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='1234xxx'),
    }(name='WorkFlowInfo', description='The basic information of the workflow.'),
    workFlowNodeInfo?: {
      edges?: [ 
        {
          source?: long(name='Source', description='The ID of the source job.', example='100'),
          target?: long(name='Target', description='The ID of the object job.', example='200'),
        }
      ](name='Edges', description='The workflow edges.'),
      nodes?: [ 
        {
          id?: long(name='Id', description='The ID of the job.', example='123456xxx'),
          label?: string(name='Label', description='The name of the job.', example='job_111'),
          status?: int32(name='Status', description='The status of the job.', example='1'),
        }
      ](name='Nodes', description='The list of workflow nodes.'),
    }(name='WorkFlowNodeInfo', description='The node information of the workflow.'),
  }(name='Data', description='The data of the workflow.'),
  message?: string(name='Message', description='Error message', example='workflow is not existed'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45678xxx'),
  success?: boolean(name='Success', description='The result of the API call.', example='true'),
}

model GetWorkFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkFlowResponseBody(name='body'),
}

/**
 * @summary Obtains the information about a workflow.
 *
 * @param request GetWorkFlowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkFlowResponse
 */
@context("getWorkFlowWithContext")
async function getWorkFlowWithOptions(request: GetWorkFlowRequest, runtime: $RuntimeOptions): GetWorkFlowResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetWorkFlow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the information about a workflow.
 *
 * @param request GetWorkFlowRequest
 * @return GetWorkFlowResponse
 */
async function getWorkFlow(request: GetWorkFlowRequest): GetWorkFlowResponse {
  var runtime = new $RuntimeOptions{};
  return getWorkFlowWithOptions(request, runtime);
}

model GetWorkerListRequest {
  groupId?: string(name='GroupId', description='The ID of the permission group.

This parameter is required.', example='usercenter'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model GetWorkerListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    workerInfos?: [ 
      {
        ip?: string(name='Ip', description='The IP address of the worker.', example='30.225.16.49'),
        label?: string(name='Label', description='The label of the worker.', example='gray'),
        port?: int32(name='Port', description='The port number of the worker.', example='60831'),
        starter?: string(name='Starter', description='The startup method of the worker.', example='springboot'),
        version?: string(name='Version', description='The version of the worker.', example='1.3.4'),
        workerAddress?: string(name='WorkerAddress', description='The address of the worker. The address is in the format of ${worker_id}@${worker_ip}:${worker_port}.', example='030225016049_11734_25917@30.225.16.49:60831'),
      }
    ](name='WorkerInfos', description='The worker information.'),
  }(name='Data', description='The job information.'),
  message?: string(name='Message', description='The additional information that is returned.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetWorkerListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkerListResponseBody(name='body'),
}

/**
 * @summary Obtains the list of workers that are connected to an application.
 *
 * @param request GetWorkerListRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkerListResponse
 */
@context("getWorkerListWithContext")
async function getWorkerListWithOptions(request: GetWorkerListRequest, runtime: $RuntimeOptions): GetWorkerListResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetWorkerList',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Obtains the list of workers that are connected to an application.
 *
 * @param request GetWorkerListRequest
 * @return GetWorkerListResponse
 */
async function getWorkerList(request: GetWorkerListRequest): GetWorkerListResponse {
  var runtime = new $RuntimeOptions{};
  return getWorkerListWithOptions(request, runtime);
}

model GetWorkflowInstanceRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  wfInstanceId?: long(name='WfInstanceId', description='The workflow instance ID.

This parameter is required.', example='123456'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='123'),
}

model GetWorkflowInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    wfInstanceDag?: {
      edges?: [ 
        {
          source?: long(name='Source', description='The upstream job instance of the current job instance. A value of 0 indicates that the upstream job instance is the root node.', example='24058798'),
          target?: long(name='Target', description='The downstream job instance of the current job instance.', example='24058796'),
        }
      ](name='Edges', description='The dependencies between job instances.'),
      nodes?: [ 
        {
          attempt?: int32(name='Attempt', description='The number of retries when the job failed.', example='0'),
          dataTime?: string(name='DataTime', description='The data timestamp of the job.', example='2023-01-03 18:00:00'),
          endTime?: string(name='EndTime', description='The time when the job stopped running.', example='2023-01-03 18:00:21'),
          jobId?: long(name='JobId', description='The job ID.', example='1472'),
          jobInstanceId?: long(name='JobInstanceId', description='The ID of the job instance.', example='24058796'),
          jobName?: string(name='JobName', description='The job name.', example='TestJob'),
          result?: string(name='Result', description='The execution result of the job.', example='code=200'),
          scheduleTime?: string(name='ScheduleTime', description='The time when the job was scheduled.', example='2023-01-03 18:00:03'),
          startTime?: string(name='StartTime', description='The time when the job started to run.', example='2023-01-03 18:00:03'),
          status?: int32(name='Status', description='The state of the job instance. Valid values: 1: The job instance is waiting for execution. 3: The job instance is running. 4: The job instance is run. 5: The job instance failed to run. 9: The job instance is rejected. Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus.', example='4'),
          workAddr?: string(name='WorkAddr', description='The worker on which the job instance run.', example='10.163.0.101:34027'),
        }
      ](name='Nodes', description='The job instances.'),
    }(name='WfInstanceDag', description='The directed acyclic graph (DAG) of the workflow instance, including nodes and dependencies.'),
    wfInstanceInfo?: {
      dataTime?: string(name='DataTime', description='The data timestamp of the workflow instance.', example='2023-01-03 18:00:00'),
      endTime?: string(name='EndTime', description='The time when the workflow instance stopped running.', example='2023-01-03 18:00:21'),
      scheduleTime?: string(name='ScheduleTime', description='The time when the workflow instance was scheduled to run.', example='2023-01-03 18:00:00'),
      startTime?: string(name='StartTime', description='The time when the workflow instance started to run.', example='2023-01-03 18:00:01'),
      status?: int32(name='Status', description='The state of the workflow instance. Valid values:

*   1: pending
*   2: preparing
*   3: running
*   4: successful
*   5: failed', example='5'),
    }(name='WfInstanceInfo', description='The details of the workflow instance, including the state of the workflow instance, the time when the workflow instance started to run, the time when the workflow instance stopped running, the state of each job instance, and the dependencies between job instances.'),
  }(name='Data', description='The details of the workflow instance.'),
  message?: string(name='Message', description='The returned error message.', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model GetWorkflowInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetWorkflowInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the details of a specified workflow instance, including the state of the workflow instance, the state of each job instance, and the dependencies between job instances. You can call this operation only in the professional edition.
 *
 * @param request GetWorkflowInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GetWorkflowInstanceResponse
 */
@context("getWorkflowInstanceWithContext")
async function getWorkflowInstanceWithOptions(request: GetWorkflowInstanceRequest, runtime: $RuntimeOptions): GetWorkflowInstanceResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GetWorkflowInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the details of a specified workflow instance, including the state of the workflow instance, the state of each job instance, and the dependencies between job instances. You can call this operation only in the professional edition.
 *
 * @param request GetWorkflowInstanceRequest
 * @return GetWorkflowInstanceResponse
 */
async function getWorkflowInstance(request: GetWorkflowInstanceRequest): GetWorkflowInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return getWorkflowInstanceWithOptions(request, runtime);
}

model GrantPermissionRequest {
  grantOption?: boolean(name='GrantOption', description='Specifies whether to grant the permissions with the GRANT option. Valid values: -**true** -**false**', example='false'),
  groupId?: string(name='GroupId', description='The application group ID.

This parameter is required.', example='test.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
  userId?: string(name='UserId', description='The user ID.

This parameter is required.', example='277641081920123456'),
  userName?: string(name='UserName', description='The username.

This parameter is required.', example='lilei'),
}

model GrantPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='400'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='false'),
}

model GrantPermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GrantPermissionResponseBody(name='body'),
}

/**
 * @summary Grants permissions to an application group.
 *
 * @param request GrantPermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return GrantPermissionResponse
 */
@context("grantPermissionWithContext")
async function grantPermissionWithOptions(request: GrantPermissionRequest, runtime: $RuntimeOptions): GrantPermissionResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.grantOption)) {
    query['GrantOption'] = request.grantOption;
  }
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  if (!$isNull(request.userName)) {
    query['UserName'] = request.userName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'GrantPermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Grants permissions to an application group.
 *
 * @param request GrantPermissionRequest
 * @return GrantPermissionResponse
 */
async function grantPermission(request: GrantPermissionRequest): GrantPermissionResponse {
  var runtime = new $RuntimeOptions{};
  return grantPermissionWithOptions(request, runtime);
}

model ListGroupsRequest {
  appGroupName?: string(name='AppGroupName', description='The name of the application group.', example='k8s-test'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
}

model ListGroupsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    appGroups?: [ 
      {
        appGroupId?: long(name='AppGroupId', description='The application group ID.', example='1'),
        appKey?: string(name='AppKey', description='The AppKey for the application.', example='a3G77O6NZxq/lyo1NC****=='),
        appName?: string(name='AppName', description='The name of the application.', example='DocTest'),
        appVersion?: int32(name='AppVersion', description='The application version. 1: Basic version, 2: Professional version.', example='2'),
        description?: string(name='Description', description='The description of the application.', example='Test'),
        enableLog?: boolean(name='EnableLog'),
        groupId?: string(name='GroupId', description='The application ID.', example='DocTest.Group'),
        namespace?: string(name='Namespace', description='The ID of the namespace.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
      }
    ](name='AppGroups', description='The applications and their details.'),
  }(name='Data', description='The applications.'),
  message?: string(name='Message', description='The returned message.', example='message'),
  requestId?: string(name='RequestId', description='The request ID.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58A'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListGroupsResponseBody(name='body'),
}

/**
 * @summary Queries a list of applications.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.5</version>
 * </dependency>
 * ```
 *
 * @param request ListGroupsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListGroupsResponse
 */
@context("listGroupsWithContext")
async function listGroupsWithOptions(request: ListGroupsRequest, runtime: $RuntimeOptions): ListGroupsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appGroupName)) {
    query['AppGroupName'] = request.appGroupName;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListGroups',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries a list of applications.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 * ```xml
 * <dependency>
 *     <groupId>com.aliyun</groupId>
 *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *     <version>1.0.5</version>
 * </dependency>
 * ```
 *
 * @param request ListGroupsRequest
 * @return ListGroupsResponse
 */
async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  var runtime = new $RuntimeOptions{};
  return listGroupsWithOptions(request, runtime);
}

model ListJobScriptHistoryRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Applications page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Tasks page in the SchedulerX console.

This parameter is required.', example='92583'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model ListJobScriptHistoryResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  data?: {
    jobScriptHistoryInfos?: [ 
      {
        createTime?: string(name='CreateTime', description='The creation time.', example='2025-03-12 14:52:42'),
        creator?: string(name='Creator', description='The creator.', example='1272118248844842'),
        scriptContent?: string(name='ScriptContent', description='The script content.', example='#!/bin/bash

# The following are predefined variables provided by the system. You can use them to obtain information about the job run.
echo "Job parameters: #{schedulerx.jobParameters}"
echo "Shard index: #{schedulerx.shardingId}"
echo "Shard parameters: #{schedulerx.shardingParameters}"
echo "Total number of shards: #{schedulerx.shardingNum}"
echo "Current retry count: #{schedulerx.attempt}"
echo "Trigger type: #{schedulerx.triggerType}"
echo "Scheduled timestamp: #{schedulerx.scheduleTime}"
echo "Data timestamp: #{schedulerx.dataTime}"

# The output of the last line will be returned as the result
echo "hello world"

# exit 1 indicates failure
exit 0'),
        versionesDescription?: string(name='VersionesDescription', description='The description of the script version.', example='init version'),
      }
    ](name='JobScriptHistoryInfos', description='The information about the job\\\\"s historical scripts.'),
  }(name='Data', description='The information about the jobs.'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='job is not existed, jobId=302'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

true

false', example='true'),
}

model ListJobScriptHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobScriptHistoryResponseBody(name='body'),
}

/**
 * @summary Queries historical scripts of a job.
 *
 * @param request ListJobScriptHistoryRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobScriptHistoryResponse
 */
@context("listJobScriptHistoryWithContext")
async function listJobScriptHistoryWithOptions(request: ListJobScriptHistoryRequest, runtime: $RuntimeOptions): ListJobScriptHistoryResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListJobScriptHistory',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries historical scripts of a job.
 *
 * @param request ListJobScriptHistoryRequest
 * @return ListJobScriptHistoryResponse
 */
async function listJobScriptHistory(request: ListJobScriptHistoryRequest): ListJobScriptHistoryResponse {
  var runtime = new $RuntimeOptions{};
  return listJobScriptHistoryWithOptions(request, runtime);
}

model ListJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='DocTest.Group'),
  jobName?: string(name='JobName', description='The name of the job.', example='helloword'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.

This parameter is required.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
  status?: string(name='Status', description='Specifies whether to enable the job. Valid values:

*   **0**: disables the job.
*   **1**: enables the job.', example='1'),
}

model ListJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobs?: [ 
      {
        attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retries to run the job after a job failure. Unit: seconds. Default value: 30.', example='30'),
        className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for a Java job.', example='com.alibaba.schedulerx.test.helloworld'),
        content?: string(name='Content', description='The script of the job. This parameter is returned only for a Python, Shell, or Go job.', example='echo \\\\"hello\\\\"'),
        description?: string(name='Description', description='The description of the job.', example='Test'),
        executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **shard**: The job runs in multipart mode.', example='standalone'),
        jarUrl?: string(name='JarUrl', description='The full path to which a JAR package is uploaded in Object Storage Service (OSS).', example='https:doc***.oss-cn-hangzhou.aliyuncs.com/sc-****-D-0.0.2-SNAPSHOT.jar'),
        jobId?: long(name='JobId', description='The ID of the job.', example='99341'),
        jobMonitorInfo?: {
          contactInfo?: [ 
            {
              ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
              userMail?: string(name='UserMail', description='The email address of the user.', example='user@mail.com'),
              userName?: string(name='UserName', description='The username.', example='userA'),
              userPhone?: string(name='UserPhone', description='The mobile number of the user.', example='1381111****'),
            }
          ](name='ContactInfo', description='The contact information.'),
          monitorConfig?: {
            failEnable?: boolean(name='FailEnable', description='Indicates whether the feature of generating an alert upon a failure is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether the feature of generating an alert when no machine is available for running the job is enabled.', example='true'),
            sendChannel?: string(name='SendChannel', description='The method that is used to send an alert notification. Only Short Message Service (SMS) is supported.', example='sms'),
            timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='12300'),
            timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether the feature of generating an alert upon a timeout is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the feature of stopping job triggering upon a timeout is enabled. By default, the feature is disabled.

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='false'),
          }(name='MonitorConfig', description='The configurations of the alerting feature and the alert threshold.'),
        }(name='JobMonitorInfo', description='The monitoring information of the job.'),
        jobType?: string(name='JobType', description='The type of the job.', example='java'),
        mapTaskXAttrs?: {
          consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a standalone job at a time. Default value: 5.', example='5'),
          dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
          pageSize?: int32(name='PageSize', description='The number of tasks that are pulled by a parallel job at a time. Default value: 100.', example='100'),
          queueSize?: int32(name='QueueSize', description='The maximum number of task queues that can be cached. Default value: 10000.', example='10000'),
          taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system retries to run the task after a task failure.', example='0'),
          taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
        }(name='MapTaskXAttrs', description='The advanced configurations of the job. The parameters are returned only if the value of the ExecuteMode parameter is parallel, grid, or batch.'),
        maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements. Default value: 0.', example='0'),
        maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of instances that can concurrently run for the job. Default value: 1. A value of 1 indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the instance is reached.', example='1'),
        name?: string(name='Name', description='The name of the job.', example='helloworld'),
        parameters?: string(name='Parameters', description='The user-defined parameters. These parameters can be obtained when the job is running.', example='test'),
        status?: int32(name='Status', description='Indicates whether the job is enabled. Valid values:

*   **1**: The job is enabled and can be triggered.
*   **0**: The job is disabled and cannot be triggered.', example='1'),
        timeConfig?: {
          calendar?: string(name='Calendar', description='If the TimeType parameter is set to cron, you can specify custom calendar days.', example='Business days'),
          dataOffset?: int32(name='DataOffset', description='The time offset if the TimeType parameter is set to cron. Unit: seconds.', example='0'),
          timeExpression?: string(name='TimeExpression', description='The time expression. Valid values:

*   **api**: indicates that no time expression is used to specify the time when to schedule the job.
*   **fix_rate**: indicates that the job is triggered at a fixed frequency. For example, a value of 30 indicates that the job is triggered every 30 seconds.
*   **cron**: indicates that a standard CRON expression is used to specify the time when to schedule the job.
*   **second_delay**: indicates that the job is triggered after a fixed delay. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
          timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
        }(name='TimeConfig', description='The time configurations.'),
        XAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
      }
    ](name='Jobs', description='The jobs and their details.'),
  }(name='Data', description='The information about the jobs.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='namespace can not find namespace: 1a72ecb1-b4cc-400a-a71b-20cdec9b****, namespaceSource:null'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58B'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListJobsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListJobsResponseBody(name='body'),
}

/**
 * @summary Queries jobs.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 *     <dependency>
 *           <groupId>com.aliyun</groupId>
 *           <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *           <version>1.0.5</version>
 *     </dependency>
 *
 * @param request ListJobsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListJobsResponse
 */
@context("listJobsWithContext")
async function listJobsWithOptions(request: ListJobsRequest, runtime: $RuntimeOptions): ListJobsResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListJobs',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries jobs.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 *     <dependency>
 *           <groupId>com.aliyun</groupId>
 *           <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *           <version>1.0.5</version>
 *     </dependency>
 *
 * @param request ListJobsRequest
 * @return ListJobsResponse
 */
async function listJobs(request: ListJobsRequest): ListJobsResponse {
  var runtime = new $RuntimeOptions{};
  return listJobsWithOptions(request, runtime);
}

model ListNamespacesRequest {
  namespace?: string(name='Namespace', description='The namespace ID.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='schedulerx-dev'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model ListNamespacesResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    namespaces?: [ 
      {
        description?: string(name='Description', description='The description of the namespace.', example='test'),
        name?: string(name='Name', description='The name of the namespace.', example='doc'),
        UId?: string(name='UId', description='The namespace ID.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
      }
    ](name='Namespaces', description='The namespaces and their details.'),
  }(name='Data', description='The information about the namespaces.'),
  message?: string(name='Message', description='The returned message.', example='message'),
  requestId?: string(name='RequestId', description='The request ID.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='true'),
}

model ListNamespacesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListNamespacesResponseBody(name='body'),
}

/**
 * @summary Queries namespaces.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 *     <dependency>
 *         <groupId>com.aliyun</groupId>
 *         <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *         <version>1.0.5</version>
 *     </dependency>
 *
 * @param request ListNamespacesRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListNamespacesResponse
 */
@context("listNamespacesWithContext")
async function listNamespacesWithOptions(request: ListNamespacesRequest, runtime: $RuntimeOptions): ListNamespacesResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListNamespaces',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries namespaces.
 *
 * @description Before you call this operation, you must add the following dependency to the pom.xml file:
 *     <dependency>
 *         <groupId>com.aliyun</groupId>
 *         <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
 *         <version>1.0.5</version>
 *     </dependency>
 *
 * @param request ListNamespacesRequest
 * @return ListNamespacesResponse
 */
async function listNamespaces(request: ListNamespacesRequest): ListNamespacesResponse {
  var runtime = new $RuntimeOptions{};
  return listNamespacesWithOptions(request, runtime);
}

model ListWorkFlowsRequest {
  groupId?: string(name='GroupId', description='The ID of the application group.

This parameter is required.', example='hxm.test'),
  namespace?: string(name='Namespace', description='The namespace ID.

This parameter is required.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for special sources.', example='schedulerx'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  status?: int32(name='Status', description='The job status.

*   **0**: disables the job.
*   **1**: enables the routing policy.', example='1'),
  workflowName?: string(name='WorkflowName', description='The workflow name.', example='test3'),
}

model ListWorkFlowsResponseBody = {
  code?: int32(name='Code', description='The error code.', example='200'),
  data?: {
    pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
    pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
    records?: [ 
      {
        calendar?: string(name='Calendar', description='The calendar.', example='workday'),
        creator?: string(name='Creator', description='The creator.', example='1144881807903942'),
        description?: string(name='Description', description='The job description.', example='No description'),
        groupId?: string(name='GroupId', description='The application ID.', example='hxm.test'),
        maxConcurrency?: string(name='MaxConcurrency', description='The maximum concurrency.', example='1'),
        name?: string(name='Name', description='The workflow name.', example='test3'),
        namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d'),
        timeExpression?: string(name='TimeExpression', description='The time expression.'),
        timeType?: string(name='TimeType', description='The time type of the workflow.', example='cron'),
        updater?: string(name='Updater', description='The updater.', example='1144881807903942'),
        workflowId?: long(name='WorkflowId', description='The workflow ID.', example='1339'),
      }
    ](name='Records', description='The row of data.'),
    total?: int32(name='Total', description='The total number of entries returned.', example='1'),
  }(name='Data', description='The data of the workflow.'),
  message?: string(name='Message', description='The error message.', example='workflow is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='883AFE93-FB03-4FA9-A958-E750C6DE120C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ListWorkFlowsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkFlowsResponseBody(name='body'),
}

/**
 * @summary Queries the information of a workflow.
 *
 * @param request ListWorkFlowsRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkFlowsResponse
 */
@context("listWorkFlowsWithContext")
async function listWorkFlowsWithOptions(request: ListWorkFlowsRequest, runtime: $RuntimeOptions): ListWorkFlowsResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.pageNum)) {
    query['PageNum'] = request.pageNum;
  }
  if (!$isNull(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.status)) {
    query['Status'] = request.status;
  }
  if (!$isNull(request.workflowName)) {
    query['WorkflowName'] = request.workflowName;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListWorkFlows',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the information of a workflow.
 *
 * @param request ListWorkFlowsRequest
 * @return ListWorkFlowsResponse
 */
async function listWorkFlows(request: ListWorkFlowsRequest): ListWorkFlowsResponse {
  var runtime = new $RuntimeOptions{};
  return listWorkFlowsWithOptions(request, runtime);
}

model ListWorkflowInstanceRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: string(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='123'),
}

model ListWorkflowInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  data?: {
    wfInstanceInfos?: [ 
      {
        dataTime?: string(name='DataTime', description='The data timestamp of the workflow instance.', example='2023-01-03 18:00:00'),
        endTime?: string(name='EndTime', description='The time when the workflow instance stopped running.', example='2023-01-03 18:00:21'),
        scheduleTime?: string(name='ScheduleTime', description='The time when the workflow instance was scheduled to run.', example='2023-01-03 18:00:00'),
        startTime?: string(name='StartTime', description='The time when the workflow instance started to run.', example='2023-01-03 18:00:01'),
        status?: int32(name='Status', description='The state of the workflow instance. Valid values:

*   1: pending
*   2: preparing
*   3: running
*   4: successful
*   5: failed', example='5'),
        wfInstanceId?: long(name='WfInstanceId', description='The workflow instance ID.', example='123456'),
        workflowId?: long(name='WorkflowId', description='The workflow ID.', example='123'),
      }
    ](name='WfInstanceInfos', description='The workflow instances.'),
  }(name='Data', description='The information about workflow instances.'),
  message?: string(name='Message', description='The returned error message.', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model ListWorkflowInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListWorkflowInstanceResponseBody(name='body'),
}

/**
 * @summary Queries the execution history of a workflow. You can call this operation only in the professional edition.
 *
 * @param request ListWorkflowInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ListWorkflowInstanceResponse
 */
@context("listWorkflowInstanceWithContext")
async function listWorkflowInstanceWithOptions(request: ListWorkflowInstanceRequest, runtime: $RuntimeOptions): ListWorkflowInstanceResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ListWorkflowInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the execution history of a workflow. You can call this operation only in the professional edition.
 *
 * @param request ListWorkflowInstanceRequest
 * @return ListWorkflowInstanceResponse
 */
async function listWorkflowInstance(request: ListWorkflowInstanceRequest): ListWorkflowInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return listWorkflowInstanceWithOptions(request, runtime);
}

model ManageSchedulerxCalendarRequest {
  calendarName?: string(name='CalendarName', description='The calendar name.

This parameter is required.', example='2025workday'),
  incremental?: boolean(name='Incremental', description='Specifies whether to perform an incremental update. Default value: false.

*   false: Updates the specified months and removes configurations for all other months.
*   true: Updates only the specified months and preserves existing configurations for other months.', example='false'),
  monthDaysContent?: string(name='MonthDaysContent', description='The month and days.

This parameter is required.', example='[
  {"month":1,"days":[3,4,5,6,9,10,11,12,13,16,17,18,19,20,28,29,30,31]},
  {"month":2,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28]},
  {"month":3,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30,31]},
  {"month":4,"days":[3,4,6,7,10,11,12,13,14,17,18,19,20,21,23,24,25,26,27,28]},
  {"month":5,"days":[4,5,6,8,9,10,11,12,15,16,17,18,19,22,23,24,25,26,29,30,31]},
  {"month":6,"days":[1,2,5,6,7,8,9,12,13,14,15,16,19,20,21,25,26,27,28,29,30]},
  {"month":7,"days":[3,4,5,6,7,10,11,12,13,14,17,18,19,20,21,24,25,26,27,28,31]},
  {"month":8,"days":[1,2,3,4,7,8,9,10,11,14,15,16,17,18,21,22,23,24,25,28,29,30,31]},
  {"month":9,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28]},
  {"month":10,"days":[7,8,9,10,11,12,13,16,17,18,19,20,23,24,25,26,27,30,31]},
  {"month":11,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30]},
  {"month":12,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28,29]}
]'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  year?: int32(name='Year', description='The year.

This parameter is required.', example='2025'),
}

model ManageSchedulerxCalendarResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:ManageSchedulerxCalendar'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The principal name.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='Additional information. Returned only if an error occurs.', example='calendar \\\\"2025workday\\\\" does not exist in year 2025'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ManageSchedulerxCalendarResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageSchedulerxCalendarResponseBody(name='body'),
}

/**
 * @summary Updates a calendar.
 *
 * @param request ManageSchedulerxCalendarRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageSchedulerxCalendarResponse
 */
@context("manageSchedulerxCalendarWithContext")
async function manageSchedulerxCalendarWithOptions(request: ManageSchedulerxCalendarRequest, runtime: $RuntimeOptions): ManageSchedulerxCalendarResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.calendarName)) {
    body['CalendarName'] = request.calendarName;
  }
  if (!$isNull(request.incremental)) {
    body['Incremental'] = request.incremental;
  }
  if (!$isNull(request.monthDaysContent)) {
    body['MonthDaysContent'] = request.monthDaysContent;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.year)) {
    body['Year'] = request.year;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ManageSchedulerxCalendar',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a calendar.
 *
 * @param request ManageSchedulerxCalendarRequest
 * @return ManageSchedulerxCalendarResponse
 */
async function manageSchedulerxCalendar(request: ManageSchedulerxCalendarRequest): ManageSchedulerxCalendarResponse {
  var runtime = new $RuntimeOptions{};
  return manageSchedulerxCalendarWithOptions(request, runtime);
}

model ManageSchedulerxJobSyncRequest {
  jobIdList?: [ long ](name='JobIdList', description='The list of task IDs.

This parameter is required.'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. Required only for specific third-party cases.', example='schedulerx'),
  originalGroupId?: string(name='OriginalGroupId', description='The source application group to which the task belongs.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  originalNamespace?: string(name='OriginalNamespace', description='The source namespace where the task resides.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  targetGroupId?: string(name='TargetGroupId', description='The ID of the destination application group to which the task will be synchronized.

This parameter is required.', example='testSyncJobGroup'),
  targetNamespace?: string(name='TargetNamespace', description='The destination namespace to which the task will be synchronized.

This parameter is required.', example='5f56ef65-b836-493d-b40b-c4db6425****'),
}

model ManageSchedulerxJobSyncShrinkRequest {
  jobIdListShrink?: string(name='JobIdList', description='The list of task IDs.

This parameter is required.'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. Required only for specific third-party cases.', example='schedulerx'),
  originalGroupId?: string(name='OriginalGroupId', description='The source application group to which the task belongs.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  originalNamespace?: string(name='OriginalNamespace', description='The source namespace where the task resides.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  targetGroupId?: string(name='TargetGroupId', description='The ID of the destination application group to which the task will be synchronized.

This parameter is required.', example='testSyncJobGroup'),
  targetNamespace?: string(name='TargetNamespace', description='The destination namespace to which the task will be synchronized.

This parameter is required.', example='5f56ef65-b836-493d-b40b-c4db6425****'),
}

model ManageSchedulerxJobSyncResponseBody = {
  code?: int32(name='Code', description='The return code.', example='200'),
  message?: string(name='Message', description='The error message. Returned only when an error occurs.', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The unique ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ManageSchedulerxJobSyncResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageSchedulerxJobSyncResponseBody(name='body'),
}

/**
 * @summary Synchronizes tasks across namespaces.
 *
 * @param tmpReq ManageSchedulerxJobSyncRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageSchedulerxJobSyncResponse
 */
@context("manageSchedulerxJobSyncWithContext")
async function manageSchedulerxJobSyncWithOptions(tmpReq: ManageSchedulerxJobSyncRequest, runtime: $RuntimeOptions): ManageSchedulerxJobSyncResponse {
  tmpReq.validate();
  var request = new ManageSchedulerxJobSyncShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!$isNull(tmpReq.jobIdList)) {
    request.jobIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.jobIdList, 'JobIdList', 'json');
  }
  var body : map[string]any = {};
  if (!$isNull(request.jobIdListShrink)) {
    body['JobIdList'] = request.jobIdListShrink;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.originalGroupId)) {
    body['OriginalGroupId'] = request.originalGroupId;
  }
  if (!$isNull(request.originalNamespace)) {
    body['OriginalNamespace'] = request.originalNamespace;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.targetGroupId)) {
    body['TargetGroupId'] = request.targetGroupId;
  }
  if (!$isNull(request.targetNamespace)) {
    body['TargetNamespace'] = request.targetNamespace;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ManageSchedulerxJobSync',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Synchronizes tasks across namespaces.
 *
 * @param request ManageSchedulerxJobSyncRequest
 * @return ManageSchedulerxJobSyncResponse
 */
async function manageSchedulerxJobSync(request: ManageSchedulerxJobSyncRequest): ManageSchedulerxJobSyncResponse {
  var runtime = new $RuntimeOptions{};
  return manageSchedulerxJobSyncWithOptions(request, runtime);
}

model ManageSchedulerxNotificationPolicyRequest {
  channelTimeRange?: string(name='ChannelTimeRange', description='The time range configuration for notification channels.

>  See the supplementary description of ChannelTimeRange in the request parameters.', example='{
  "sendChannel": "sms,webhook,mail,phone",
  "timezone": "UTC+08:00",
  "webhookIsAtAll": "false",
  "timeRanges": {
    "all": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [1, 2, 3, 4, 5]
      }
    ]
  }
}'),
  description?: string(name='Description', description='The notification policy description.', example='Monday-Friday only'),
  policyName?: string(name='PolicyName', description='The name of the notification policy.

This parameter is required.', example='test-weekdays'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model ManageSchedulerxNotificationPolicyResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:ManageSchedulerxNotificationPolicy'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message, returned only when an error occurs.', example='Invalid parameter: policyName cannot be null'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ManageSchedulerxNotificationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ManageSchedulerxNotificationPolicyResponseBody(name='body'),
}

/**
 * @summary Updates a notification policy.
 *
 * @param request ManageSchedulerxNotificationPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ManageSchedulerxNotificationPolicyResponse
 */
@context("manageSchedulerxNotificationPolicyWithContext")
async function manageSchedulerxNotificationPolicyWithOptions(request: ManageSchedulerxNotificationPolicyRequest, runtime: $RuntimeOptions): ManageSchedulerxNotificationPolicyResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.channelTimeRange)) {
    body['ChannelTimeRange'] = request.channelTimeRange;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'ManageSchedulerxNotificationPolicy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a notification policy.
 *
 * @param request ManageSchedulerxNotificationPolicyRequest
 * @return ManageSchedulerxNotificationPolicyResponse
 */
async function manageSchedulerxNotificationPolicy(request: ManageSchedulerxNotificationPolicyRequest): ManageSchedulerxNotificationPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return manageSchedulerxNotificationPolicyWithOptions(request, runtime);
}

model ReadSchedulerxCalendarRequest {
  calendarName?: string(name='CalendarName', description='The calendar name.', example='2025workday'),
  fetchCalendarDetail?: boolean(name='FetchCalendarDetail', description='Specifies whether to retrieve calendar details. The default value is false.

*   false: Returns only basic information without the detailed list of days for each month.
*   true: Returns the detailed list of days for each month.', example='false'),
  fetchSystemCalendar?: boolean(name='FetchSystemCalendar', description='Specifies whether to retrieve system calendars. The default value is false.

*   false: Returns only user-defined calendars.
*   true: Returns both system calendars and user-defined calendars.', example='false'),
  maxResults?: int32(name='MaxResults', description='The maximum number of entries to return on this call. The default value is 20.', example='15'),
  nextToken?: string(name='NextToken', description='A token that specifies the starting position for retrieving the next page of data. You do not need to provide this parameter for the first request. An empty value indicates that all data has been read.', example='AAAAAdYzT97YjSXWT8TQmxIAI5g='),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  year?: int32(name='Year', description='The year.', example='2025'),
}

model ReadSchedulerxCalendarResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication action.', example='edas:ReadSchedulerxCalendar'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQEAAAAAaDEssEE4MDg4NTQyLTVGMTYtNTFEQy1CODJCLUFFMDY4NUVDQ0ZBQQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  data?: {
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='15'),
    nextToken?: string(name='NextToken', description='When there is more data to retrieve, the server returns a nextToken. You can use this token in a subsequent request to continue reading from where you left off.', example='O39nXKu5XafATl3/cJjSJw=='),
    records?: [ 
      {
        calendarName?: string(name='CalendarName', description='The calendar name.', example='2025workday'),
        creator?: string(name='Creator', description='The creator.', example='1827811800526xxx'),
        monthDaysContent?: string(name='MonthDaysContent', description='The months and days.', example='[
  {"month":1,"days":[3,4,5,6,9,10,11,12,13,16,17,18,19,20,28,29,30,31]},
  {"month":2,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28]},
  {"month":3,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30,31]},
  {"month":4,"days":[3,4,6,7,10,11,12,13,14,17,18,19,20,21,23,24,25,26,27,28]},
  {"month":5,"days":[4,5,6,8,9,10,11,12,15,16,17,18,19,22,23,24,25,26,29,30,31]},
  {"month":6,"days":[1,2,5,6,7,8,9,12,13,14,15,16,19,20,21,25,26,27,28,29,30]},
  {"month":7,"days":[3,4,5,6,7,10,11,12,13,14,17,18,19,20,21,24,25,26,27,28,31]},
  {"month":8,"days":[1,2,3,4,7,8,9,10,11,14,15,16,17,18,21,22,23,24,25,28,29,30,31]},
  {"month":9,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28]},
  {"month":10,"days":[7,8,9,10,11,12,13,16,17,18,19,20,23,24,25,26,27,30,31]},
  {"month":11,"days":[1,2,3,6,7,8,9,10,13,14,15,16,17,20,21,22,23,24,27,28,29,30]},
  {"month":12,"days":[1,4,5,6,7,8,11,12,13,14,15,18,19,20,21,22,25,26,27,28,29]}
]'),
        systemCalendar?: boolean(name='SystemCalendar', description='Indicates whether it is a system calendar.', example='false'),
        year?: int32(name='Year', description='The year.', example='2025'),
      }
    ](name='Records', description='*'),
    total?: long(name='Total', description='The total number of entries.', example='20'),
  }(name='Data', description='*'),
  message?: string(name='Message', description='The error message.', example='unknown exception occurred'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='C8E5FB4A-6D8D-424D-9AAA-4FE06BB74FF9'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ReadSchedulerxCalendarResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReadSchedulerxCalendarResponseBody(name='body'),
}

/**
 * @summary Retrieves the information of a calendar.
 *
 * @param request ReadSchedulerxCalendarRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReadSchedulerxCalendarResponse
 */
@context("readSchedulerxCalendarWithContext")
async function readSchedulerxCalendarWithOptions(request: ReadSchedulerxCalendarRequest, runtime: $RuntimeOptions): ReadSchedulerxCalendarResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.calendarName)) {
    query['CalendarName'] = request.calendarName;
  }
  if (!$isNull(request.fetchCalendarDetail)) {
    query['FetchCalendarDetail'] = request.fetchCalendarDetail;
  }
  if (!$isNull(request.fetchSystemCalendar)) {
    query['FetchSystemCalendar'] = request.fetchSystemCalendar;
  }
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.year)) {
    query['Year'] = request.year;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReadSchedulerxCalendar',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Retrieves the information of a calendar.
 *
 * @param request ReadSchedulerxCalendarRequest
 * @return ReadSchedulerxCalendarResponse
 */
async function readSchedulerxCalendar(request: ReadSchedulerxCalendarRequest): ReadSchedulerxCalendarResponse {
  var runtime = new $RuntimeOptions{};
  return readSchedulerxCalendarWithOptions(request, runtime);
}

model ReadSchedulerxDesignateDetailRequest {
  designateType?: int32(name='DesignateType', description='The information type of the specified workers that you want to query. Valid values: 1 and 2.

1: the IP address of the specified workers.
2: the tags of the specified workers.', example='1'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Applications page in the SchedulerX console.

This parameter is required.', example='test.defalutGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the ID on the Tasks page in the SchedulerX console.

This parameter is required.', example='368'),
  namespace?: string(name='Namespace', description='The unique identifier (UID) of the namespace. You can obtain the namespace UID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model ReadSchedulerxDesignateDetailResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication operation.', example='edas:ReadSchedulerxDesignateDetail'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='Th status code.', example='200'),
  data?: {
    designateDetailVos?: [ 
      {
        busy?: string(name='Busy', description='The status of the workers. Valid values: 

FREE: idle. 
LOAD5_BUSY: The average of the latest five values of CPU workload is too high. 
HEAP5_BUSY: The average of the latest five values of heap memory usage is too high. 
DISK_BUSY: The disk usage is too high.', example='FREE'),
        checked?: boolean(name='Checked', description='Indicates whether the workers are specified. Valid values: true and false.', example='true'),
        key?: string(name='Key', description='The information returned based on the value of the DesignateType parameter.

*   If you set the DesignateType parameter to 2, the tags of the workers are returned.
*   If you set the DesignateType parameter to 1, the IP addresses of the workers are returned.', example='10.52.169.25'),
        metrics?: {
          cpuLoad1?: double(name='CpuLoad1', description='The most recent value of CPU workload.', example='0'),
          cpuLoad5?: double(name='CpuLoad5', description='The average of the latest five values of CPU workload.', example='0'),
          cpuProcessors?: int32(name='CpuProcessors', description='The number of available CPU processors.', example='1'),
          diskMax?: int32(name='DiskMax', description='The total disk capacity in MB.', example='1024'),
          diskUsage?: double(name='DiskUsage', description='The disk usage.', example='0.19142496008515167'),
          diskUsed?: int32(name='DiskUsed', description='The used disk space in MB.', example='0.14865875'),
          execCount?: long(name='ExecCount', description='The number of job executions.', example='56'),
          heap1Usage?: double(name='Heap1Usage', description='The most recent value of heap memory usage.', example='0.06072874493927125'),
          heap1Used?: double(name='Heap1Used', description='The most recent value of used heap memory in MB.', example='14'),
          heap5Usage?: double(name='Heap5Usage', description='The average of the latest five values of heap memory usage.', example='0.06477732793522267'),
          heapMax?: int32(name='HeapMax', description='The maximum heap memory in MB.', example='500'),
          sharePoolAvailableSize?: int32(name='SharePoolAvailableSize', description='The number of available resources in the shared pool.', example='72'),
          sharePoolQueueSize?: int32(name='SharePoolQueueSize', description='The queue size in the shared pool.', example='1'),
        }(name='Metrics', description='The metric values.'),
        offline?: boolean(name='Offline', description='Indicates whether the workers are offline.', example='fasle'),
        size?: int32(name='Size', description='The number of workers.', example='1'),
        starter?: string(name='Starter', description='The startup method of the workers.', example='pod'),
        version?: string(name='Version', description='The version of the workers.', example='1.12.5'),
      }
    ](name='DesignateDetailVos', description='*'),
  }(name='Data', description='*'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='Invalid parameter: jobId=368 invalid'),
  requestId?: string(name='RequestId', description='The request ID.', example='883AFE93-FB03-4FA9-A958-E750C6DE120C'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ReadSchedulerxDesignateDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReadSchedulerxDesignateDetailResponseBody(name='body'),
}

/**
 * @summary Queries detailed information of the workers specified by a job.
 *
 * @param request ReadSchedulerxDesignateDetailRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReadSchedulerxDesignateDetailResponse
 */
@context("readSchedulerxDesignateDetailWithContext")
async function readSchedulerxDesignateDetailWithOptions(request: ReadSchedulerxDesignateDetailRequest, runtime: $RuntimeOptions): ReadSchedulerxDesignateDetailResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.designateType)) {
    query['DesignateType'] = request.designateType;
  }
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReadSchedulerxDesignateDetail',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries detailed information of the workers specified by a job.
 *
 * @param request ReadSchedulerxDesignateDetailRequest
 * @return ReadSchedulerxDesignateDetailResponse
 */
async function readSchedulerxDesignateDetail(request: ReadSchedulerxDesignateDetailRequest): ReadSchedulerxDesignateDetailResponse {
  var runtime = new $RuntimeOptions{};
  return readSchedulerxDesignateDetailWithOptions(request, runtime);
}

model ReadSchedulerxDesignateInfoRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Applications** page in the SchedulerX console.

This parameter is required.', example='test.defalutGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the ID on the Tasks page in the SchedulerX console.

This parameter is required.', example='368'),
  namespace?: string(name='Namespace', description='The unique identifier (UID) of the namespace. You can obtain the namespace UID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model ReadSchedulerxDesignateInfoResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication operation.', example='edas:ReadSchedulerxDesignateInfo'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The principal account.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The HTTP status code returned.', example='200'),
  data?: {
    designateDetailVos?: [ 
      {
        busy?: string(name='Busy', description='The status of the workers. Valid values:

*   FREE: idle.
*   LOAD5_BUSY: The average of the latest five values of CPU workload is too high.
*   HEAP5_BUSY: The average of the latest five values of heap memory usage is too high.
*   DISK_BUSY: The disk usage is too high.', example='FREE'),
        checked?: boolean(name='Checked', description='Indicates whether the workers are specified.

*   true: The workers are specified.
*   false: The workers are not specified.', example='true'),
        key?: string(name='Key', description='The information returned based on the value of the DesignateType parameter.

*   If you set the DesignateType parameter to 2, the tags of the workers are returned.
*   If you set the DesignateType parameter to 1, the IP addresses of the workers are returned.', example='10.52.169.25'),
        metrics?: {
          cpuLoad1?: double(name='CpuLoad1', description='The most recent value of CPU workload.', example='0'),
          cpuLoad5?: double(name='CpuLoad5', description='The average of the latest five values of CPU workload.', example='0'),
          cpuProcessors?: int32(name='CpuProcessors', description='The number of available CPU processors.', example='1'),
          diskMax?: int32(name='DiskMax', description='The total disk capacity in MB.', example='1024'),
          diskUsage?: double(name='DiskUsage', description='The disk usage.', example='0.19142496008515167'),
          diskUsed?: int32(name='DiskUsed', description='The used disk space in MB.', example='148'),
          execCount?: long(name='ExecCount', description='The number of job executions.', example='56'),
          heap1Usage?: double(name='Heap1Usage', description='The most recent value of heap memory usage.', example='0.06072874493927125'),
          heap1Used?: double(name='Heap1Used', description='The most recent value of used heap memory in MB.', example='14'),
          heap5Usage?: double(name='Heap5Usage', description='The average of the latest five values of heap memory usage.', example='0.06477732793522267'),
          heapMax?: int32(name='HeapMax', description='The maximum heap memory in MB.', example='500'),
          sharePoolAvailableSize?: int32(name='SharePoolAvailableSize', description='The number of available resources in the shared pool.', example='72'),
          sharePoolQueueSize?: int32(name='SharePoolQueueSize', description='The queue size in the shared pool.', example='1'),
        }(name='Metrics', description='The metric values.'),
        offline?: boolean(name='Offline', description='Indicates whether the workers are offline.', example='fasle'),
        size?: int32(name='Size', description='The number of workers.', example='1'),
        starter?: string(name='Starter', description='The startup method of the workers.', example='pod'),
        version?: string(name='Version', description='The version of the workers.', example='1.12.5'),
      }
    ](name='DesignateDetailVos', description='*'),
    designateType?: int32(name='DesignateType', description='The information type of the specified workers.

*   1: the IP address of the specified workers.
*   2: the tags of the specified workers.

>  The default value of the DesignateType parameter is 1.', example='1'),
    transferable?: boolean(name='Transferable', description='Indicates whether to enable failover for the workers. If you set this parameter to true, the job is scheduled to other workers when the specified workers go offline.

*   true: enables failover for the workers.
*   false: disables failover for the workers.

>  The default value of the Transferable parameter is false.', example='true'),
  }(name='Data', description='*'),
  message?: string(name='Message', description='The error message returned only if an error occurs.', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ReadSchedulerxDesignateInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReadSchedulerxDesignateInfoResponseBody(name='body'),
}

/**
 * @summary Queries the basic information of specified workers.
 *
 * @param request ReadSchedulerxDesignateInfoRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReadSchedulerxDesignateInfoResponse
 */
@context("readSchedulerxDesignateInfoWithContext")
async function readSchedulerxDesignateInfoWithOptions(request: ReadSchedulerxDesignateInfoRequest, runtime: $RuntimeOptions): ReadSchedulerxDesignateInfoResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReadSchedulerxDesignateInfo',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries the basic information of specified workers.
 *
 * @param request ReadSchedulerxDesignateInfoRequest
 * @return ReadSchedulerxDesignateInfoResponse
 */
async function readSchedulerxDesignateInfo(request: ReadSchedulerxDesignateInfoRequest): ReadSchedulerxDesignateInfoResponse {
  var runtime = new $RuntimeOptions{};
  return readSchedulerxDesignateInfoWithOptions(request, runtime);
}

model ReadSchedulerxNotificationPolicyRequest {
  maxResults?: int32(name='MaxResults', description='The maximum number of entries returned. Default value: 20.', example='10'),
  nextToken?: string(name='NextToken', description='The cursor for pagination. Leave this parameter empty for the first request. When the returned value is empty, all data has been retrieved.', example='O39nXKu5XafATl3/cJjSJw=='),
  policyName?: string(name='PolicyName', description='The name of the notification policy. Supports fuzzy matching.', example='test-weekdays'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model ReadSchedulerxNotificationPolicyResponseBody = {
  accessDeniedDetail?: {
    authAction?: string(name='AuthAction', description='The authentication operation.', example='edas:ReadSchedulerxNotificationPolicy'),
    authPrincipalDisplayName?: string(name='AuthPrincipalDisplayName', description='The principal name.', example='209312833131416xxx'),
    authPrincipalOwnerId?: string(name='AuthPrincipalOwnerId', description='The account of the principal.', example='1827811800526xxx'),
    authPrincipalType?: string(name='AuthPrincipalType', description='The principal type.', example='SubUser'),
    encodedDiagnosticMessage?: string(name='EncodedDiagnosticMessage', description='The encoded diagnostic message.', example='AQFn/cLPZ/3Cz0YxQkZBMjVGLTY0REUtNTlGNS05NzUwLTgyMUE4M0MwMTFDRQ=='),
    noPermissionType?: string(name='NoPermissionType', description='The permission denial type.', example='ImplicitDeny'),
    policyType?: string(name='PolicyType', description='The policy type.', example='AccountLevelIdentityBasedPolicy'),
  }(name='AccessDeniedDetail', description='The access denial details.'),
  code?: int32(name='Code', description='The status code.', example='200'),
  data?: {
    maxResults?: int32(name='MaxResults', description='The maximum number of entries returned.', example='10'),
    nextToken?: string(name='NextToken', description='When data that matches the query conditions has not been fully retrieved, the server returns nextToken. You can then use nextToken to continue retrieving the remaining data.', example='O39nXKu5XafATl3/cJjSJw=='),
    records?: [ 
      {
        channelTimeRange?: string(name='ChannelTimeRange', description='The configuration of the notification policy.', example='{
  "isUnifiedSetting": false,
  "timezone": "GMT+8",
  "webhookIsAtAll": "false",
  "timeRanges": {
    "webhook": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [
          1,
          2,
          3,
          4,
          5
        ]
      }
    ],
    "sms": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [
          1,
          2,
          3,
          4,
          5
        ]
      }
    ],
    "mail": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [
          1,
          2,
          3,
          4,
          5
        ]
      }
    ],
    "phone": [
      {
        "startTime": "08:00",
        "endTime": "18:00",
        "daysOfWeek": [
          1,
          2,
          3,
          4,
          5
        ]
      }
    ]
  }
}'),
        createTime?: string(name='CreateTime', description='The creation time.', example='2025-09-17 11:21:01'),
        creator?: string(name='Creator', description='The creator.', example='201576653956616970'),
        description?: string(name='Description', description='The description of the notification policy.', example='Monday-Friday only'),
        policyName?: string(name='PolicyName', description='The name of the notification policy.', example='test-weekdays'),
        referenceApps?: [ 
          {
            appGroupId?: long(name='AppGroupId', description='The ID of the task group.', example='123'),
            groupId?: string(name='GroupId', description='The ID of the application.', example='test-app'),
            namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='Notification strategy testing namespace'),
            namespaceUid?: string(name='NamespaceUid', description='The unique identifier of the namespace.', example='18271388-aa16-4eab-9a6f-55f65d7e4391'),
          }
        ](name='ReferenceApps', description='The list of applications associated with the notification policy.'),
        updateTime?: string(name='UpdateTime', description='The update time.', example='2025-09-17 11:21:01'),
        updater?: string(name='Updater', description='The updater.', example='1144881807903942'),
      }
    ](name='Records', description='The data records.'),
    total?: long(name='Total', description='The total number of records.', example='42'),
  }(name='Data', description='*'),
  message?: string(name='Message', description='The error message.', example='unknown exception occurred'),
  requestId?: string(name='RequestId', description='The unique request ID.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model ReadSchedulerxNotificationPolicyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ReadSchedulerxNotificationPolicyResponseBody(name='body'),
}

/**
 * @summary Queries notification policies.
 *
 * @param request ReadSchedulerxNotificationPolicyRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return ReadSchedulerxNotificationPolicyResponse
 */
@context("readSchedulerxNotificationPolicyWithContext")
async function readSchedulerxNotificationPolicyWithOptions(request: ReadSchedulerxNotificationPolicyRequest, runtime: $RuntimeOptions): ReadSchedulerxNotificationPolicyResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!$isNull(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!$isNull(request.policyName)) {
    query['PolicyName'] = request.policyName;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'ReadSchedulerxNotificationPolicy',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Queries notification policies.
 *
 * @param request ReadSchedulerxNotificationPolicyRequest
 * @return ReadSchedulerxNotificationPolicyResponse
 */
async function readSchedulerxNotificationPolicy(request: ReadSchedulerxNotificationPolicyRequest): ReadSchedulerxNotificationPolicyResponse {
  var runtime = new $RuntimeOptions{};
  return readSchedulerxNotificationPolicyWithOptions(request, runtime);
}

model RerunJobRequest {
  dataTime?: string(name='DataTime', description='The data timestamp of the job. Specify a string in the HH:mm:ss format.

This parameter is required.', example='10:00:00'),
  endDate?: long(name='EndDate', description='The time when the job stops running. Specify a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1645718400000'),
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID.

This parameter is required.', example='123'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  startDate?: long(name='StartDate', description='The time when the job starts to rerun. Specify a UNIX timestamp representing the number of milliseconds that have elapsed since January 1, 1970, 00:00:00 UTC.

This parameter is required.', example='1645459200000'),
}

model RerunJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model RerunJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RerunJobResponseBody(name='body'),
}

/**
 * @summary Reruns a job to obtain the historical data of the job. You can call this operation only in the professional edition.
 *
 * @param request RerunJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RerunJobResponse
 */
@context("rerunJobWithContext")
async function rerunJobWithOptions(request: RerunJobRequest, runtime: $RuntimeOptions): RerunJobResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.dataTime)) {
    body['DataTime'] = request.dataTime;
  }
  if (!$isNull(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'RerunJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reruns a job to obtain the historical data of the job. You can call this operation only in the professional edition.
 *
 * @param request RerunJobRequest
 * @return RerunJobResponse
 */
async function rerunJob(request: RerunJobRequest): RerunJobResponse {
  var runtime = new $RuntimeOptions{};
  return rerunJobWithOptions(request, runtime);
}

model RetryJobInstanceRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID.

This parameter is required.', example='123'),
  jobInstanceId?: long(name='JobInstanceId', description='The job instance ID.

This parameter is required.', example='123456'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model RetryJobInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model RetryJobInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RetryJobInstanceResponseBody(name='body'),
}

/**
 * @summary Reruns a successful or failed job instance. You can call this operation only in the professional edition.
 *
 * @param request RetryJobInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RetryJobInstanceResponse
 */
@context("retryJobInstanceWithContext")
async function retryJobInstanceWithOptions(request: RetryJobInstanceRequest, runtime: $RuntimeOptions): RetryJobInstanceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.jobInstanceId)) {
    query['JobInstanceId'] = request.jobInstanceId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RetryJobInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Reruns a successful or failed job instance. You can call this operation only in the professional edition.
 *
 * @param request RetryJobInstanceRequest
 * @return RetryJobInstanceResponse
 */
async function retryJobInstance(request: RetryJobInstanceRequest): RetryJobInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return retryJobInstanceWithOptions(request, runtime);
}

model RevokePermissionRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='test.defalutGroup'),
  namespace?: string(name='Namespace', description='The unique identifier (UID) of the namespace. You can obtain the namespace UID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-shenzhen'),
  userId?: string(name='UserId', description='The UID of the RAM user.

This parameter is required.', example='277641081920123456'),
}

model RevokePermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='400'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   **true**
*   **false**', example='false'),
}

model RevokePermissionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RevokePermissionResponseBody(name='body'),
}

/**
 * @summary Revokes the permissions that are granted to an Alibaba Cloud Resource Access Management (RAM) user.
 *
 * @param request RevokePermissionRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return RevokePermissionResponse
 */
@context("revokePermissionWithContext")
async function revokePermissionWithOptions(request: RevokePermissionRequest, runtime: $RuntimeOptions): RevokePermissionResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.userId)) {
    query['UserId'] = request.userId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'RevokePermission',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Revokes the permissions that are granted to an Alibaba Cloud Resource Access Management (RAM) user.
 *
 * @param request RevokePermissionRequest
 * @return RevokePermissionResponse
 */
async function revokePermission(request: RevokePermissionRequest): RevokePermissionResponse {
  var runtime = new $RuntimeOptions{};
  return revokePermissionWithOptions(request, runtime);
}

model SetJobInstanceSuccessRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID.

This parameter is required.', example='123'),
  jobInstanceId?: long(name='JobInstanceId', description='The job instance ID.

This parameter is required.', example='123456'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model SetJobInstanceSuccessResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model SetJobInstanceSuccessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetJobInstanceSuccessResponseBody(name='body'),
}

/**
 * @summary Forcibly sets the state of a job instance to successful. You can call this operation only in the professional edition.
 *
 * @param request SetJobInstanceSuccessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetJobInstanceSuccessResponse
 */
@context("setJobInstanceSuccessWithContext")
async function setJobInstanceSuccessWithOptions(request: SetJobInstanceSuccessRequest, runtime: $RuntimeOptions): SetJobInstanceSuccessResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!$isNull(request.jobInstanceId)) {
    query['JobInstanceId'] = request.jobInstanceId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetJobInstanceSuccess',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Forcibly sets the state of a job instance to successful. You can call this operation only in the professional edition.
 *
 * @param request SetJobInstanceSuccessRequest
 * @return SetJobInstanceSuccessResponse
 */
async function setJobInstanceSuccess(request: SetJobInstanceSuccessRequest): SetJobInstanceSuccessResponse {
  var runtime = new $RuntimeOptions{};
  return setJobInstanceSuccessWithOptions(request, runtime);
}

model SetWfInstanceSuccessRequest {
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  wfInstanceId?: long(name='WfInstanceId', description='The workflow instance ID.

This parameter is required.', example='123456789'),
  workflowId?: long(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='123'),
}

model SetWfInstanceSuccessResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the corresponding error occurs.', example='wofkflowId is not existed'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model SetWfInstanceSuccessResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetWfInstanceSuccessResponseBody(name='body'),
}

/**
 * @summary Forcibly sets the state of a workflow instance to successful. You can call this operation only in the professional edition.
 *
 * @param request SetWfInstanceSuccessRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return SetWfInstanceSuccessResponse
 */
@context("setWfInstanceSuccessWithContext")
async function setWfInstanceSuccessWithOptions(request: SetWfInstanceSuccessRequest, runtime: $RuntimeOptions): SetWfInstanceSuccessResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    query['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!$isNull(request.wfInstanceId)) {
    query['WfInstanceId'] = request.wfInstanceId;
  }
  if (!$isNull(request.workflowId)) {
    query['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'SetWfInstanceSuccess',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Forcibly sets the state of a workflow instance to successful. You can call this operation only in the professional edition.
 *
 * @param request SetWfInstanceSuccessRequest
 * @return SetWfInstanceSuccessResponse
 */
async function setWfInstanceSuccess(request: SetWfInstanceSuccessRequest): SetWfInstanceSuccessResponse {
  var runtime = new $RuntimeOptions{};
  return setWfInstanceSuccessWithOptions(request, runtime);
}

model StopInstanceRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  instanceId?: long(name='InstanceId', description='The ID of the job instance in the running state.

This parameter is required.', example='11111111'),
  jobId?: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model StopInstanceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopInstanceResponseBody(name='body'),
}

/**
 * @summary Stops a job instance in the running state.
 *
 * @param request StopInstanceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return StopInstanceResponse
 */
@context("stopInstanceWithContext")
async function stopInstanceWithOptions(request: StopInstanceRequest, runtime: $RuntimeOptions): StopInstanceResponse {
  request.validate();
  var query = OpenApiUtil.query(request.toMap());
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'StopInstance',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Stops a job instance in the running state.
 *
 * @param request StopInstanceRequest
 * @return StopInstanceResponse
 */
async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  var runtime = new $RuntimeOptions{};
  return stopInstanceWithOptions(request, runtime);
}

model UpdateAppGroupRequest {
  appVersion?: int32(name='AppVersion', description='The application version. 1: Basic version, 2: Professional version.', example='2'),
  description?: string(name='Description', description='The description of the application.', example='Test'),
  enableLog?: boolean(name='EnableLog'),
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of concurrent instances. Default value: 1. A value of 1 specifies that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the next instance is reached.', example='1'),
  monitorConfigJson?: string(name='MonitorConfigJson', description='The configuration of the alert. The value is a JSON string. For more information about this parameter, see **Additional information about request parameters**.', example='{
    "sendChannel": "ding,sms,mail,phone",
    "alarmType": "Contacts",
    "webhookIsAtAll": false
}'),
  monitorContactsJson?: string(name='MonitorContactsJson', description='The configuration of alert contacts. The value is a JSON string.', example='[{"userName":"Tom","userPhone":"89756******"},{"userName":"Bob","ding":"http://www.example.com"}]'),
  namespace?: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  notificationPolicyName?: string(name='NotificationPolicyName', example='test-workday-notification'),
  regionId?: string(name='RegionId', description='The ID of the region.

This parameter is required.', example='cn-hangzhou'),
}

model UpdateAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

- true: The request was successful.
- false: The request failed.', example='true'),
}

model UpdateAppGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateAppGroupResponseBody(name='body'),
}

/**
 * @summary Updates the application group.
 *
 * @param request UpdateAppGroupRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateAppGroupResponse
 */
@context("updateAppGroupWithContext")
async function updateAppGroupWithOptions(request: UpdateAppGroupRequest, runtime: $RuntimeOptions): UpdateAppGroupResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.appVersion)) {
    query['AppVersion'] = request.appVersion;
  }
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.enableLog)) {
    query['EnableLog'] = request.enableLog;
  }
  if (!$isNull(request.groupId)) {
    query['GroupId'] = request.groupId;
  }
  if (!$isNull(request.maxConcurrency)) {
    query['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!$isNull(request.monitorConfigJson)) {
    query['MonitorConfigJson'] = request.monitorConfigJson;
  }
  if (!$isNull(request.monitorContactsJson)) {
    query['MonitorContactsJson'] = request.monitorContactsJson;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.notificationPolicyName)) {
    query['NotificationPolicyName'] = request.notificationPolicyName;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateAppGroup',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the application group.
 *
 * @param request UpdateAppGroupRequest
 * @return UpdateAppGroupResponse
 */
async function updateAppGroup(request: UpdateAppGroupRequest): UpdateAppGroupResponse {
  var runtime = new $RuntimeOptions{};
  return updateAppGroupWithOptions(request, runtime);
}

model UpdateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The interval of retries after a job failure. Default value: 30. Unit: seconds.', example='30'),
  calendar?: string(name='Calendar', description='If you set TimeType to 1 (cron), you can specify calendar days.', example='Business days'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This field is available only when you set the job type to java. In this case, you must enter a full path.', example='com.alibaba.test.helloworld'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a single worker at a time. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.[](https://open.dingtalk.com/document/org/application-types)', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the alert contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the alert contact.', example='userA'),
      userPhone?: string(name='UserPhone', description='The mobile phone number of the alert contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information about the alert contact.'),
  content?: string(name='Content', description='The script content. This parameter is required when you set the job type to python, shell, go, or k8s.', example='echo \\\\"hello\\\\"'),
  dataOffset?: int32(name='DataOffset', description='If you set TimeType to 1 (cron), you can specify a time offset. Unit: seconds.', example='2400'),
  description?: string(name='Description', description='The job description.', example='test'),
  dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5'),
  executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **Stand-alone operation**: standalone
*   **Broadcast run**: broadcatst
*   **Visual MapReduce**: parallel
*   **MapReduce**: batch
*   **Shard run**: shard', example='standalone'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to turn on Failure alarm. If the switch is turned on, an alert will be generated upon a failure. Valid values:

*   **true**
*   **false**', example='true'),
  failTimes?: int32(name='FailTimes', description='The number of consecutive failures. An alert will be received if the number of consecutive failures reaches the value of this parameter.', example='1'),
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the job ID on the Task Management page in the SchedulerX console.

This parameter is required.', example='92583'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements.', example='0'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of concurrent instances. Default value: 1. The default value indicates that only one instance is allowed to run at a time. When an instance is running, another instance is not triggered even if the scheduled time for running the instance is reached.', example='1'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to turn on No machine alarm available. If the switch is turned on, an alert will be generated when no machine is available for running the job. Valid values:

*   **true**
*   **false**', example='true'),
  name?: string(name='Name', description='The job name.', example='helloword'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The namespace source. This parameter is required only for a special third party.', example='schedulerx'),
  pageSize?: int32(name='PageSize', description='The number of tasks that can be pulled at a time. Default value: 100. This parameter is an advanced configuration item of the MapReduce job.', example='100'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when the job is running.', example='test'),
  priority?: int32(name='Priority'),
  queueSize?: int32(name='QueueSize', description='The maximum number of tasks that can be queued. Default value: 10000. This parameter is an advanced configuration item of the MapReduce job.', example='10000'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  sendChannel?: string(name='SendChannel', description='The method that is used to send alerts. Only Short Message Service (SMS) is supported.', example='sms'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable', description='Specifies whether to turn on Successful notice. If the switch is turned on, a notice will be sent when a job succeeds.', example='false'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval of retries after a task failure. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  taskDispatchMode?: string(name='TaskDispatchMode', description='The job mode. Valid values: push and pull. This parameter is an advanced configuration item of the MapReduce job.', example='push'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure. This parameter is an advanced configuration item of the MapReduce job.', example='0'),
  template?: string(name='Template', description='Custom task template for the k8s task type.', example='apiVersion: v1
kind: Pod
metadata:
  name: schedulerx-node-{JOB_ID}
  namespace: {NAMESPACE}
spec:
  containers:
  - name: node-job
    image: node:16
    imagePullPolicy: IfNotPresent
    volumeMounts:
    - name: script-node
      mountPath: script/node
    command: ["node", "script/node/node-{JOB_ID}.js"]
  volumes:
  - name: script-node
    configMap:
      name: schedulerx-configmap
      items:
      - key: schedulerx-node-{JOB_ID}
        path: node-{JOB_ID}.js
  restartPolicy: Never'),
  timeExpression?: string(name='TimeExpression', description='The time expression. Specify the time expression based on the value of TimeType:

*   If you set TimeType to **1** (cron), specify this parameter to a standard CRON expression.
*   If you set TimeType to **100** (api), no time expression is required.
*   If you set TimeType to **3** (fixed_rate), specify this parameter to a fixed frequency in seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   If you set TimeType to **4** (second_delay), specify this parameter to a fixed delay after which the job is triggered. Valid values: 1 to 60. Unit: seconds.', example='30'),
  timeType?: int32(name='TimeType', description='The time type. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
  timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds.', example='7200'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to turn on Timeout alarm. If the switch is turned on, an alert will be generated upon a timeout. Valid values:

*   **true**
*   **false**', example='true'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to turn on Timeout termination. If the switch is turned on, the job will be terminated upon a timeout. Valid values:

*   **true**
*   **false**', example='true'),
  timezone?: string(name='Timezone', description='Time zone.', example='GMT+8'),
  XAttrs?: string(name='XAttrs', description='If you set JobType to k8s, this parameter is required. xxljob task: {"resource":"job"} shell task: {"image":"busybox","resource":"shell"}', example='{"resource":"shell","fileFormat":"unix","templateType":"customTemplate"}'),
}

model UpdateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='job type is java className can not be blank'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateJobResponseBody(name='body'),
}

/**
 * @summary Updates the configuration information about a job. By default, you need to call the GetJobInfo operation to obtain the original configuration of the job before you call this operation to modify the configuration as required.
 *
 * @param request UpdateJobRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJobResponse
 */
@context("updateJobWithContext")
async function updateJobWithOptions(request: UpdateJobRequest, runtime: $RuntimeOptions): UpdateJobResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.priority)) {
    query['Priority'] = request.priority;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.attemptInterval)) {
    body['AttemptInterval'] = request.attemptInterval;
  }
  if (!$isNull(request.calendar)) {
    body['Calendar'] = request.calendar;
  }
  if (!$isNull(request.className)) {
    body['ClassName'] = request.className;
  }
  if (!$isNull(request.consumerSize)) {
    body['ConsumerSize'] = request.consumerSize;
  }
  if (!$isNull(request.contactInfo)) {
    body['ContactInfo'] = request.contactInfo;
  }
  if (!$isNull(request.content)) {
    body['Content'] = request.content;
  }
  if (!$isNull(request.dataOffset)) {
    body['DataOffset'] = request.dataOffset;
  }
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.dispatcherSize)) {
    body['DispatcherSize'] = request.dispatcherSize;
  }
  if (!$isNull(request.executeMode)) {
    body['ExecuteMode'] = request.executeMode;
  }
  if (!$isNull(request.failEnable)) {
    body['FailEnable'] = request.failEnable;
  }
  if (!$isNull(request.failTimes)) {
    body['FailTimes'] = request.failTimes;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!$isNull(request.maxAttempt)) {
    body['MaxAttempt'] = request.maxAttempt;
  }
  if (!$isNull(request.maxConcurrency)) {
    body['MaxConcurrency'] = request.maxConcurrency;
  }
  if (!$isNull(request.missWorkerEnable)) {
    body['MissWorkerEnable'] = request.missWorkerEnable;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!$isNull(request.parameters)) {
    body['Parameters'] = request.parameters;
  }
  if (!$isNull(request.queueSize)) {
    body['QueueSize'] = request.queueSize;
  }
  if (!$isNull(request.sendChannel)) {
    body['SendChannel'] = request.sendChannel;
  }
  if (!$isNull(request.successNoticeEnable)) {
    body['SuccessNoticeEnable'] = request.successNoticeEnable;
  }
  if (!$isNull(request.taskAttemptInterval)) {
    body['TaskAttemptInterval'] = request.taskAttemptInterval;
  }
  if (!$isNull(request.taskDispatchMode)) {
    body['TaskDispatchMode'] = request.taskDispatchMode;
  }
  if (!$isNull(request.taskMaxAttempt)) {
    body['TaskMaxAttempt'] = request.taskMaxAttempt;
  }
  if (!$isNull(request.template)) {
    body['Template'] = request.template;
  }
  if (!$isNull(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!$isNull(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!$isNull(request.timeout)) {
    body['Timeout'] = request.timeout;
  }
  if (!$isNull(request.timeoutEnable)) {
    body['TimeoutEnable'] = request.timeoutEnable;
  }
  if (!$isNull(request.timeoutKillEnable)) {
    body['TimeoutKillEnable'] = request.timeoutKillEnable;
  }
  if (!$isNull(request.timezone)) {
    body['Timezone'] = request.timezone;
  }
  if (!$isNull(request.XAttrs)) {
    body['XAttrs'] = request.XAttrs;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateJob',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the configuration information about a job. By default, you need to call the GetJobInfo operation to obtain the original configuration of the job before you call this operation to modify the configuration as required.
 *
 * @param request UpdateJobRequest
 * @return UpdateJobResponse
 */
async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  var runtime = new $RuntimeOptions{};
  return updateJobWithOptions(request, runtime);
}

model UpdateJobScriptRequest {
  groupId?: string(name='GroupId', description='The application ID. You can obtain the application ID on the Applications page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  jobId?: long(name='JobId', description='The job ID. You can obtain the ID on the Tasks page in the SchedulerX console.

This parameter is required.', example='301'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  scriptContent?: string(name='ScriptContent', description='The script content.', example='#!/bin/bash

# The following are predefined variables provided by the system. You can use them to obtain information about the job run.
echo "Job parameters: #{schedulerx.jobParameters}"
echo "Shard index: #{schedulerx.shardingId}"
echo "Shard parameters: #{schedulerx.shardingParameters}"
echo "Total number of shards: #{schedulerx.shardingNum}"
echo "Current retry count: #{schedulerx.attempt}"
echo "Trigger type: #{schedulerx.triggerType}"
echo "Scheduled timestamp: #{schedulerx.scheduleTime}"
echo "Data timestamp: #{schedulerx.dataTime}"

# The output of the last line will be returned as the result
echo "hello world"

# exit 1 indicates failure
exit 0'),
  versionDescription?: string(name='VersionDescription', description='The description of the script version.', example='Print job running information'),
}

model UpdateJobScriptResponseBody = {
  code?: int32(name='Code', description='The returned code.', example='200'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='job is not existed, jobId=302'),
  requestId?: string(name='RequestId', description='The request ID.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateJobScriptResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateJobScriptResponseBody(name='body'),
}

/**
 * @summary Updates the execution script of a job.
 *
 * @param request UpdateJobScriptRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateJobScriptResponse
 */
@context("updateJobScriptWithContext")
async function updateJobScriptWithOptions(request: UpdateJobScriptRequest, runtime: $RuntimeOptions): UpdateJobScriptResponse {
  request.validate();
  var body : map[string]any = {};
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.regionId)) {
    body['RegionId'] = request.regionId;
  }
  if (!$isNull(request.scriptContent)) {
    body['ScriptContent'] = request.scriptContent;
  }
  if (!$isNull(request.versionDescription)) {
    body['VersionDescription'] = request.versionDescription;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateJobScript',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the execution script of a job.
 *
 * @param request UpdateJobScriptRequest
 * @return UpdateJobScriptResponse
 */
async function updateJobScript(request: UpdateJobScriptRequest): UpdateJobScriptResponse {
  var runtime = new $RuntimeOptions{};
  return updateJobScriptWithOptions(request, runtime);
}

model UpdateNamespaceRequest {
  description?: string(name='Description', description='The description of the namespace.', example='Test'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespaces page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='test'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
}

model UpdateNamespaceResponseBody = {
  code?: int32(name='Code', description='The returned code.', example='200'),
  message?: string(name='Message', description='The additional information returned only if an error occurs.', example='The system namespace cannot be modified'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateNamespaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateNamespaceResponseBody(name='body'),
}

/**
 * @summary Updates a namespace.
 *
 * @param request UpdateNamespaceRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateNamespaceResponse
 */
@context("updateNamespaceWithContext")
async function updateNamespaceWithOptions(request: UpdateNamespaceRequest, runtime: $RuntimeOptions): UpdateNamespaceResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.description)) {
    query['Description'] = request.description;
  }
  if (!$isNull(request.namespace)) {
    query['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceName)) {
    query['NamespaceName'] = request.namespaceName;
  }
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateNamespace',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates a namespace.
 *
 * @param request UpdateNamespaceRequest
 * @return UpdateNamespaceResponse
 */
async function updateNamespace(request: UpdateNamespaceRequest): UpdateNamespaceResponse {
  var runtime = new $RuntimeOptions{};
  return updateNamespaceWithOptions(request, runtime);
}

model UpdateWorkflowRequest {
  description?: string(name='Description', description='The description of the workflow.', example='Test'),
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  name?: string(name='Name', description='The name of the workflow.', example='helloworld'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression based on the selected method that is used to specify time.

*   If you set TimeType to cron, you need to enter a standard cron expression. Online verification is supported.
*   If you set TimeType to api, no time expression is required.', example='0 0/10 * * * ?'),
  timeType?: int32(name='TimeType', description='The method that is used to specify the time. Valid values:

*   1: cron
*   100: api', example='1'),
  workflowId?: string(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='123'),
}

model UpdateWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.', example='timetype is invalid'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateWorkflowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkflowResponseBody(name='body'),
}

/**
 * @summary Updates the basic information about a workflow. You can call this operation only in the professional edition.
 *
 * @param request UpdateWorkflowRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkflowResponse
 */
@context("updateWorkflowWithContext")
async function updateWorkflowWithOptions(request: UpdateWorkflowRequest, runtime: $RuntimeOptions): UpdateWorkflowResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.description)) {
    body['Description'] = request.description;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.name)) {
    body['Name'] = request.name;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.timeExpression)) {
    body['TimeExpression'] = request.timeExpression;
  }
  if (!$isNull(request.timeType)) {
    body['TimeType'] = request.timeType;
  }
  if (!$isNull(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateWorkflow',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Updates the basic information about a workflow. You can call this operation only in the professional edition.
 *
 * @param request UpdateWorkflowRequest
 * @return UpdateWorkflowResponse
 */
async function updateWorkflow(request: UpdateWorkflowRequest): UpdateWorkflowResponse {
  var runtime = new $RuntimeOptions{};
  return updateWorkflowWithOptions(request, runtime);
}

model UpdateWorkflowDagRequest {
  dagJson?: string(name='DagJson', description='The directed acyclic graph (DAG) of the workflow, including the information about the nodes and the edges. Specify the value of this parameter in the JSON format.

This parameter is required.', example='{"nodes":[{"id":2300691},{"id":10518089},{"id":1758851}],"edges":[{"source":10518089,"target":1758851},{"source":10518089,"target":2300691}]}'),
  groupId?: string(name='GroupId', description='The application group ID. You can obtain the application group ID on the Application Management page in the SchedulerX console.

This parameter is required.', example='testSchedulerx.defaultGroup'),
  namespace?: string(name='Namespace', description='The namespace ID. You can obtain the namespace ID on the Namespace page in the SchedulerX console.

This parameter is required.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx'),
  regionId?: string(name='RegionId', description='The region ID.

This parameter is required.', example='cn-hangzhou'),
  workflowId?: string(name='WorkflowId', description='The workflow ID.

This parameter is required.', example='123'),
}

model UpdateWorkflowDagResponseBody = {
  code?: int32(name='Code', description='The HTTP status code.', example='200'),
  message?: string(name='Message', description='The returned error message.'),
  requestId?: string(name='RequestId', description='The request ID.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true
*   false', example='true'),
}

model UpdateWorkflowDagResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateWorkflowDagResponseBody(name='body'),
}

/**
 * @summary Modifies the nodes and dependencies of a workflow. You can call this operation only in the professional edition.
 *
 * @param request UpdateWorkflowDagRequest
 * @param runtime runtime options for this request RuntimeOptions
 * @return UpdateWorkflowDagResponse
 */
@context("updateWorkflowDagWithContext")
async function updateWorkflowDagWithOptions(request: UpdateWorkflowDagRequest, runtime: $RuntimeOptions): UpdateWorkflowDagResponse {
  request.validate();
  var query = {};
  if (!$isNull(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var body : map[string]any = {};
  if (!$isNull(request.dagJson)) {
    body['DagJson'] = request.dagJson;
  }
  if (!$isNull(request.groupId)) {
    body['GroupId'] = request.groupId;
  }
  if (!$isNull(request.namespace)) {
    body['Namespace'] = request.namespace;
  }
  if (!$isNull(request.namespaceSource)) {
    body['NamespaceSource'] = request.namespaceSource;
  }
  if (!$isNull(request.workflowId)) {
    body['WorkflowId'] = request.workflowId;
  }
  var req = new OpenApiUtil.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApiUtil.Params{
    action = 'UpdateWorkflowDag',
    version = '2019-04-30',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
 * @summary Modifies the nodes and dependencies of a workflow. You can call this operation only in the professional edition.
 *
 * @param request UpdateWorkflowDagRequest
 * @return UpdateWorkflowDagResponse
 */
async function updateWorkflowDag(request: UpdateWorkflowDagRequest): UpdateWorkflowDagResponse {
  var runtime = new $RuntimeOptions{};
  return updateWorkflowDagWithOptions(request, runtime);
}

