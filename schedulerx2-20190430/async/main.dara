/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'schedulerx2';
  @version = '2019-04-30';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-beijing = 'schedulerx.cn-beijing.aliyuncs.com',
    cn-hangzhou = 'schedulerx.cn-hangzhou.aliyuncs.com',
    cn-shanghai = 'schedulerx.cn-shanghai.aliyuncs.com',
    cn-shenzhen = 'schedulerx.cn-shenzhen.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model BatchDeleteJobsRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  jobIdList: [ long ](name='JobIdList', description='The job IDs. Multiple job IDs are separated by commas (,).', example='99341', position='Body'),
  namespace: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='Schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region to which the job belongs.', example='cn-hangzhou', position='Query'),
}

model BatchDeleteJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether jobs are deleted in batches. Valid values:

*   **true**: Jobs are deleted in batches.
*   **false**: Failed to delete jobs in batches.', example='true'),
}

model BatchDeleteJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
 */
async function batchDeleteJobs(request: BatchDeleteJobsRequest): BatchDeleteJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteJobs', 'POST', '/', 'json', true, 'form', request);
}

model BatchDeleteRouteStrategyRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobIdList?: [ long ](name='JobIdList', position='Body'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model BatchDeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='job is not existed, jobId=162837'),
  requestId?: string(name='RequestId', description='Id of the request', example='704A2A61-3681-5568-92F7-2DFCC53F33D1'),
  success?: boolean(name='Success', example='true'),
}

model BatchDeleteRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDeleteRouteStrategyResponseBody(name='body'),
}

async function batchDeleteRouteStrategy(request: BatchDeleteRouteStrategyRequest): BatchDeleteRouteStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteRouteStrategy', 'POST', '/', 'json', true, 'form', request);
}

model BatchDisableJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobIdList: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).', example='99341', position='Body'),
  namespace: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou', position='Query'),
}

model BatchDisableJobsResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='disable failed jobs=[99341]'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model BatchDisableJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchDisableJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
 */
async function batchDisableJobs(request: BatchDisableJobsRequest): BatchDisableJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDisableJobs', 'POST', '/', 'json', true, 'form', request);
}

model BatchEnableJobsRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the **Application Management** page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobIdList: [ long ](name='JobIdList', description='The job IDs. Separate multiple job IDs with commas (,).', example='99341', position='Body'),
  namespace: string(name='Namespace', description='The ID of the namespace to which the job belongs. You can obtain the ID of the namespace on the **Namespace** page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou', position='Query'),
}

model BatchEnableJobsResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model BatchEnableJobsResponse = {
  headers: map[string]string(name='headers'),
  body: BatchEnableJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  * ```xml
  * <dependency>
  *     <groupId>com.aliyun</groupId>
  *     <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *     <version>1.0.4</version>
  * </dependency>
  * ```
  *
 */
async function batchEnableJobs(request: BatchEnableJobsRequest): BatchEnableJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchEnableJobs', 'POST', '/', 'json', true, 'form', request);
}

model CreateAppGroupRequest {
  appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviLcl****', position='Query'),
  appName: string(name='AppName', description='The name of the application.', example='DocTest', position='Query'),
  appType?: int32(name='AppType', position='Query'),
  description?: string(name='Description', description='The description of the application.', example='Test', position='Query'),
  enableLog?: boolean(name='EnableLog', position='Query'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='TestSchedulerx.defaultGroup', position='Query'),
  maxJobs?: int32(name='MaxJobs', description='The maximum number of jobs.', example='1000', position='Query'),
  monitorConfigJson?: string(name='MonitorConfigJson', description='The configuration of the alert. The value is a JSON string. For more information about this parameter, see **Additional information about request parameters**.', example='{"sendChannel":"sms,ding"}', position='Query'),
  monitorContactsJson?: string(name='MonitorContactsJson', description='The configuration of alert contacts. The value is a JSON string.', example='\\[{"userName":"Tom","userPhone":"89756\\*\\*\\*\\*\\*\\*"},{"userName":"Bob","ding":"http://www.example.com"}]', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceName?: string(name='NamespaceName', description='The name of the namespace.', example='Test', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is not supported. You do not need to specify this parameter.', example='schedulerx', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  scheduleBusyWorkers?: boolean(name='ScheduleBusyWorkers', description='Specifies whether to schedule a busy worker.', example='false', position='Query'),
}

model CreateAppGroupResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    appGroupId?: long(name='AppGroupId', description='The ID of the job group.', example='6607'),
    appKey?: string(name='AppKey', description='The AppKey for the application.', example='adcExHZviL******'),
  }(name='Data', description='The information about the job group.'),
  message?: string(name='Message', description='The error message that is returned only if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='883AFE93-FB03-4FA9-A958-E750C6DE120C'),
  success?: boolean(name='Success', description='Indicates whether the application is created. Valid values:

*   **true**: The application is created.
*   **false**: Failed to create the application.', example='true'),
}

model CreateAppGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAppGroupResponseBody(name='body'),
}

async function createAppGroup(request: CreateAppGroupRequest): CreateAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAppGroup', 'GET', '/', 'json', false, 'json', request);
}

model CreateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system attempts to rerun a job. Default value: 30. Unit: seconds.', example='30', position='Body'),
  calendar?: string(name='Calendar', description='When the Time type parameter is set to cron, you can specify a custom calendar.', example='This parameter is not supported. You do not need to specify this parameter.', position='Body'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This field is available only when you select a java job. In this case, you must enter a full path.', example='com.alibaba.schedulerx.test.helloworld', position='Body'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a single worker at a time. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5', position='Body'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot. For more information, see [DingTalk development documentation](https://open.dingtalk.com/document/org/application-types).', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the alert contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the alert contact.', example='Tom'),
      userPhone?: string(name='UserPhone', description='The mobile phone number of the alert contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information of the job contact.', position='Body'),
  content?: string(name='Content', description='The script code content that is required when you set the job type to **python**, **shell**, or **go**.', example='echo \\"hello\\"', position='Body'),
  dataOffset?: int32(name='DataOffset', description='When the Time type parameter is set to cron, you can specify a time offset. Unit: seconds.', example='2400', position='Body'),
  description?: string(name='Description', description='The description of the job.', example='Test', position='Body'),
  dispatcherSize?: int32(name='DispatcherSize', description='Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5', position='Body'),
  executeMode: string(name='ExecuteMode', description='The execution mode of the job. The following execution modes are supported:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **sharding**: The job runs in sharding mode.', example='standalone', position='Body'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to turn on Failure alarm. Valid values:

*   **true**: Turn on Failure alarm.
*   **false**: Turn off Failure alarm.', example='false', position='Body'),
  failTimes?: int32(name='FailTimes', position='Body'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Body'),
  jobType: string(name='JobType', description='The type of the job. The following job types are supported:

*   java
*   python
*   shell
*   go
*   http
*   xxljob
*   dataworks
*   k8s
*   springschedule', example='java', position='Body'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of attempts that the system can make when an error occurs on a job. You can specify this parameter based on your business requirements. Default value: 0.', example='0', position='Body'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of instances that the system can run at the same time. Default value: 1. When you set this parameter to 1, if the current job does not end, the system will not run the next job even if the runtime is reached.', example='1', minimum=1, maximum=200, position='Body'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to turn on No machine alarm available.

*   **true**: Turn on No machine alarm available.
*   **false**: Turn off No machine alarm available.', example='false', position='Body'),
  name: string(name='Name', description='The name of the job.', example='helloworld', position='Body'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of subtasks that can be pulled at a time. Default value: 100. This parameter is an advanced configuration item of MapReduce job.', example='100', position='Body'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when the job is running.', example='test', position='Body'),
  queueSize?: int32(name='QueueSize', description='The maximum number of subtask queues that you can cache. Default value: 10000. This parameter is an advanced configuration item of the MapReduce job.', example='10000', position='Body'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  sendChannel?: string(name='SendChannel', description='The channel for sending alerts. Only SMS messages are supported. Set the value to sms.', example='sms', position='Body'),
  status?: int32(name='Status', description='0: disabled. 1: enabled. Default value: 1.', example='1', position='Body'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable', position='Body'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system can rerun the subtask when the subtask fails. Default value: 0. This parameter is an advanced configuration item of the MapReduce job.', example='0', minimum=0, position='Body'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries that the system can perform when the subtask fails. Default value: 0. This parameter is an advanced configuration item of the MapReduce job.', example='0', minimum=0, maximum=10, position='Body'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression according to the selected time type.

*   **cron**: Specify a standard Cron expression. You can verify the expression online after you specify the expression.
*   **api**: No time expression is available.
*   **fixed_rate**: Specify a fixed frequency value. Unit: seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   **second_delay**: Specify a delay after which you can run a job. You can specify a value from 1 to 60. Unit: seconds.
*   **one_time**: Specify a time in the format of yyyy-MM-dd HH:mm:ss or specify a timestamp in milliseconds. Example: 2022-10-10 10:10:00.', example='0 0/10 * * * ?', position='Body'),
  timeType: int32(name='TimeType', description='The type of time. The following time types are supported:

*   **cron**: 1
*   **fixed_rate**: 3
*   **second_delay**: 4
*   **one_time**: 5
*   **api**: 100', example='1', position='Body'),
  timeout?: long(name='Timeout', description='The timeout threshold. Default value: 7200. Unit: seconds.', example='7200', position='Body'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to turn on Timeout alarm. Valid values:

*   **true**: Turn on Timeout alarm.
*   **false**: Turn off Timeout alarm.', example='false', position='Body'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to turn on Timeout termination. Valid values:

*   **true**: Turn on Timeout termination.
*   **false**: Turn off Timeout termination.', example='false', position='Body'),
  xAttrs?: string(name='XAttrs', description='If the Task type parameter is set to k8s, this parameter is required. xxljob task: {"resource":"job"} shell task: {"image":"busybox","resource":"shell"}', example='{"resource":"job"}', position='Body'),
}

model CreateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', description='Indicates whether the job is created. Valid values:

*   **true**: The job is created.
*   **false**: Failed to create the job.', example='true'),
}

model CreateJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateJobResponseBody(name='body'),
}

async function createJob(request: CreateJobRequest): CreateJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateJob', 'POST', '/', 'json', true, 'form', request);
}

model CreateNamespaceRequest {
  description?: string(name='Description', description='The description of the namespace.', example='Test', position='Query'),
  name: string(name='Name', description='The name of the namespace.', example='test-env', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  uid?: string(name='Uid', description='The UID of the namespace, which is globally unique. We recommend that you use the UUID to generate the UID.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
}

model CreateNamespaceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    namespaceUid?: string(name='NamespaceUid', description='The unique identifier of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  }(name='Data', description='The information of the namespace.'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='namespace=test3 is existed, noting update'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether an application is created. Valid values:

*   **true**: The application is created.
*   **false**: Failed to create the application.', example='true'),
}

model CreateNamespaceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateNamespaceResponseBody(name='body'),
}

async function createNamespace(request: CreateNamespaceRequest): CreateNamespaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateNamespace', 'POST', '/', 'json', false, 'json', request);
}

model CreateRouteStrategyRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobId?: long(name='JobId', example='54978', position='Query'),
  name: string(name='Name', example='test-strategy', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  status?: int32(name='Status', example='1', position='Query'),
  strategyContent?: string(name='StrategyContent', example='[{"percentage":20,"target":"[\\"version1\\"]","targetType":"label"}]', position='Query'),
  type?: int32(name='Type', example='3', position='Query'),
}

model CreateRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
  }(name='Data'),
  message?: string(name='Message', example='strategy name is null or empty.'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model CreateRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRouteStrategyResponseBody(name='body'),
}

async function createRouteStrategy(request: CreateRouteStrategyRequest): CreateRouteStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRouteStrategy', 'POST', '/', 'json', false, 'json', request);
}

model CreateWorkflowRequest {
  description?: string(name='Description', example='Test', position='Body'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Body'),
  maxConcurrency?: int32(name='MaxConcurrency', example='1', position='Body'),
  name: string(name='Name', example='helloworld', position='Body'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Body'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Body'),
  timeExpression?: string(name='TimeExpression', example='0 0/10 * * * ?', position='Body'),
  timeType?: int32(name='TimeType', example='1', position='Body'),
  timezone?: string(name='Timezone', example='GMT+8', position='Body'),
}

model CreateWorkflowResponseBody = {
  code?: string(name='Code', example='200'),
  data?: {
    workflowId?: long(name='WorkflowId', example='92583'),
  }(name='Data'),
  message?: string(name='Message', example='timetype is invalid'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model CreateWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: CreateWorkflowResponseBody(name='body'),
}

async function createWorkflow(request: CreateWorkflowRequest): CreateWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateWorkflow', 'POST', '/', 'json', true, 'form', request);
}

model DeleteAppGroupRequest {
  deleteJobs?: boolean(name='DeleteJobs', example='true', position='Query'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model DeleteAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model DeleteAppGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAppGroupResponseBody(name='body'),
}

async function deleteAppGroup(request: DeleteAppGroupRequest): DeleteAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAppGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteJobRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the ID on the **Task Management** page in Distributed Task Scheduling Platform.', example='92583', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model DeleteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job is deleted.

*   **true**: The job is deleted.
*   **false**: Failed to delete the job.', example='true'),
}

model DeleteJobResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteJobResponseBody(name='body'),
}

async function deleteJob(request: DeleteJobRequest): DeleteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteJob', 'GET', '/', 'json', false, 'json', request);
}

model DeleteRouteStrategyRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobId?: long(name='JobId', example='92583', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model DeleteRouteStrategyResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='strategy is already deleted.'),
  requestId?: string(name='RequestId', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', example='true'),
}

model DeleteRouteStrategyResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteRouteStrategyResponseBody(name='body'),
}

async function deleteRouteStrategy(request: DeleteRouteStrategyRequest): DeleteRouteStrategyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRouteStrategy', 'POST', '/', 'json', false, 'json', request);
}

model DeleteWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  workflowId: long(name='WorkflowId', description='The ID of the workflow.', example='111', position='Query'),
}

model DeleteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The unique ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is deleted. Valid values:

*   **true**: The workflow is deleted.
*   **false**: Failed to delete the workflow.', example='true'),
}

model DeleteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteWorkflowResponseBody(name='body'),
}

async function deleteWorkflow(request: DeleteWorkflowRequest): DeleteWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteWorkflow', 'GET', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  regionId?: string(name='RegionId', position='Host'),
}

model DescribeRegionsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='disable failed jobs=[99341]'),
  regions?: [ 
    {
      localName?: string(name='LocalName', description='The displayed name of the region, which varies based on the current language.', example='China (Hangzhou)'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint of the region.', example='schedulerx.cn-hangzhou.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
    }
  ](name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DesignateWorkersRequest {
  designateType: int32(name='DesignateType', description='The type of the designated machines. Valid values: 1: worker. 2: label.', example='1', position='Query'),
  groupId: string(name='GroupId', description='The ID of the application group.', example='hxm.test', position='Query'),
  jobId: long(name='JobId', description='The ID of the job.', example='144153', position='Query'),
  labels?: string(name='Labels', description='The designated `labels`. The value is a `JSON` string.', example='["gray"]', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='public', position='Query'),
  transferable: boolean(name='Transferable', description='Specifies whether to allow a failover.', example='true', position='Query'),
  workers?: string(name='Workers', description='The designated workers. The value is a JSON string.', example='["127.0.0.1","127.0.0.2"]', position='Query'),
}

model DesignateWorkersResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='job is not existed'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='765xxx'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.', example='true'),
}

model DesignateWorkersResponse = {
  headers: map[string]string(name='headers'),
  body: DesignateWorkersResponseBody(name='body'),
}

async function designateWorkers(request: DesignateWorkersRequest): DesignateWorkersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DesignateWorkers', 'GET', '/', 'json', false, 'json', request);
}

model DisableJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model DisableJobResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message. The error message is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C8E5FB4A-6D8D-424D-9AAA-4FE06BB74FF9'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model DisableJobResponse = {
  headers: map[string]string(name='headers'),
  body: DisableJobResponseBody(name='body'),
}

async function disableJob(request: DisableJobRequest): DisableJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableJob', 'GET', '/', 'json', false, 'json', request);
}

model DisableWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  workflowId: long(name='WorkflowId', description='The ID of the workflow.', example='111', position='Query'),
}

model DisableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is disabled. Valid values:

*   **true**: The workflow is disabled.
*   **false**: Failed to disable the workflow.', example='true'),
}

model DisableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: DisableWorkflowResponseBody(name='body'),
}

async function disableWorkflow(request: DisableWorkflowRequest): DisableWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableWorkflow', 'GET', '/', 'json', false, 'json', request);
}

model EnableJobRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model EnableJobResponseBody = {
  code?: int32(name='Code', description='The status code.', example='200'),
  message?: string(name='Message', description='The error message. The error message is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB5A7'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model EnableJobResponse = {
  headers: map[string]string(name='headers'),
  body: EnableJobResponseBody(name='body'),
}

async function enableJob(request: EnableJobRequest): EnableJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableJob', 'GET', '/', 'json', false, 'json', request);
}

model EnableWorkflowRequest {
  groupId?: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  workflowId: long(name='WorkflowId', description='The ID of the workflow.', example='111', position='Query'),
}

model EnableWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the workflow is enabled. Valid values:

*   **true**: The workflow is enabled.
*   **false**: Failed to enable the workflow.', example='true'),
}

model EnableWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: EnableWorkflowResponseBody(name='body'),
}

async function enableWorkflow(request: EnableWorkflowRequest): EnableWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableWorkflow', 'GET', '/', 'json', false, 'json', request);
}

model ExecuteJobRequest {
  checkJobStatus?: boolean(name='CheckJobStatus', description='Specifies whether to check the job status. Valid values: -**true**: The job can be run only if the job is enabled. -**false**: The job can be run even if the job is disabled.', example='true', position='Query'),
  designateType?: int32(name='DesignateType', description='The type of the designated machine. Valid values: -**1**: worker. -**2**: label.', example='1', position='Query'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  instanceParameters?: string(name='InstanceParameters', description='The parameters that are passed to trigger the job to run. The input value can be any string. The parameters that are passed are obtained by calling the `context.getInstanceParameters()` class in the `processor` code. The parameters are different from custom parameters for creating jobs.', example='test', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  label?: string(name='Label', description='The label of the worker.', example='gray', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  worker?: string(name='Worker', description='The worker address of the application. To query the worker address, call the GetWokerList operation.', example='xxxxxxx@127.0.0.1:222', position='Query'),
}

model ExecuteJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceId?: long(name='JobInstanceId', description='The ID of the job instance.', example='11111111'),
  }(name='Data', description='The ID of the job instance that is returned if the call is successful.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='groupid not exist groupId: testSchedulerx.defaultGroup namespace: adcfc35d-e2fe-4fe9-bbaa-20e90ffc****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   `true`: The call is successful.
*   `false`: The call fails.', example='true'),
}

model ExecuteJobResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteJobResponseBody(name='body'),
}

/**
  * > : The combination of the `JobID` and `ScheduleTime` parameters serves as a unique index. Therefore, after the ExecuteJob operation is called to run a job once, a sleep for one second is required before the ExecuteJob operation is called to run the job again. Otherwise, the job may fail.
  *
 */
async function executeJob(request: ExecuteJobRequest): ExecuteJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteJob', 'GET', '/', 'json', false, 'json', request);
}

model ExecuteWorkflowRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Query'),
  instanceParameters?: string(name='InstanceParameters', description='The dynamic parameter of the workflow instance. The parameter must be 1 to 1,000 bytes in length.', example='test', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  workflowId: long(name='WorkflowId', description='The ID of the workflow.', example='111', position='Query'),
}

model ExecuteWorkflowResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    wfInstanceId?: long(name='WfInstanceId', description='The ID of the workflow instance.', example='111111'),
  }(name='Data', description='If the call is successful, the ID of the workflow instance is returned.'),
  message?: string(name='Message', description='The error message that is returned only if the error occurs.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the API call is successful.', example='true'),
}

model ExecuteWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteWorkflowResponseBody(name='body'),
}

async function executeWorkflow(request: ExecuteWorkflowRequest): ExecuteWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteWorkflow', 'GET', '/', 'json', false, 'json', request);
}

model GetAppGroupRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId?: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model GetAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    appKey?: string(name='AppKey', example='QI4lWMZ+xk1rNB67jFUhaw=='),
    appName?: string(name='AppName', example='DocTest'),
    curJobs?: int32(name='CurJobs', example='1'),
    description?: string(name='Description', example='Test'),
    groupId?: string(name='GroupId', example='testSchedulerx.defaultGroup'),
    maxJobs?: int32(name='MaxJobs', example='1000'),
    monitorConfigJson?: string(name='MonitorConfigJson', example='{"sendChannel":"sms,mail,ding"}'),
  }(name='Data'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetAppGroupResponse = {
  headers: map[string]string(name='headers'),
  body: GetAppGroupResponseBody(name='body'),
}

async function getAppGroup(request: GetAppGroupRequest): GetAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAppGroup', 'POST', '/', 'json', false, 'json', request);
}

model GetJobInfoRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the ID of the application on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the ID of the job on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  jobName?: string(name='JobName', description='The name of the job.', example='simpleJob', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou', position='Query'),
}

model GetJobInfoResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobConfigInfo?: {
      attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retries to run the job after a job failure. Unit: seconds. Default value: 30.', example='30'),
      className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for jobs whose job type is Java.', example='com.alibaba.test.helloword'),
      content?: string(name='Content', description='The script of a script job.', example='echo "clear" > /home/admin/edas-container/logs/catalina.out'),
      description?: string(name='Description', description='The description of the job.', example='test'),
      executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **standalone**
*   **broadcast**
*   **parallel**
*   **grid**
*   **batch**
*   **shard**', example='standalone'),
      jarUrl?: string(name='JarUrl', description='The full path that is used to upload files to Object Storage Service (OSS).

If you use a JAR package, you can upload the JAR package to this OSS path.', example='https://test.oss-cn-hangzhou.aliyuncs.com/schedulerX/test.jar'),
      jobId?: long(name='JobId', description='The ID of the job.', example='538039'),
      jobMonitorInfo?: {
        contactInfo?: [ 
          {
            ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=XXXXXX'),
            userMail?: string(name='UserMail', description='The email address of the user.', example='user@demo.com'),
            userName?: string(name='UserName', description='The name of the user.', example='userA'),
            userPhone?: string(name='UserPhone', description='The mobile number of the user.', example='1381111****'),
          }
        ](name='ContactInfo', description='The contact Information.'),
        monitorConfig?: {
          failEnable?: boolean(name='FailEnable', description='Indicates whether an alert is generated upon a failure. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
          missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether an alert is generated if no worker is available.', example='true'),
          sendChannel?: string(name='SendChannel', description='The notification method. Only Short Message Service (SMS) is supported.', example='sms'),
          timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='12300'),
          timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether an alert is generated upon a timeout. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
          timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the job is terminated upon a timeout. By default, this feature is disabled.', example='true'),
        }(name='MonitorConfig', description='The configurations of the alerting feature and alert thresholds.'),
      }(name='JobMonitorInfo', description='The monitoring information of the job.'),
      jobType?: string(name='JobType', description='The type of the job.', example='java'),
      mapTaskXAttrs?: {
        consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by an instance. Default value: 5.', example='5'),
        dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
        pageSize?: int32(name='PageSize', description='The number of tasks that are returned for a parallel job at a time. Default value: 100.', example='100'),
        queueSize?: int32(name='QueueSize', description='The maximum number of tasks that can be queued. Default value: 10000.', example='10000'),
        taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The retry interval of the task after a task failure.', example='0'),
        taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
      }(name='MapTaskXAttrs', description='The advanced configurations of the job. The parameters are returned only if the execution mode of the job is parallel, grid, or batch.'),
      maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements. Default value: 0.', example='0'),
      maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of concurrent instances. Default value: 1. A value of 1 indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the next instance is reached.', example='1'),
      name?: string(name='Name', description='The name of the job.', example='helloworld'),
      parameters?: string(name='Parameters', description='The user-defined parameters. These parameters can be obtained when the job is running.', example='test'),
      status?: int32(name='Status', description='The status of the job. Valid values:

*   **1**: The job is enabled and can be triggered.
*   **0**: The job is disabled and cannot be triggered.', example='1'),
      timeConfig?: {
        calendar?: string(name='Calendar', description='If the TimeType parameter is set to **1** (cron), you can customize the calendar.', example='Business days'),
        dataOffset?: int32(name='DataOffset', description='If the TimeType parameter is set to **1** (cron), you can configure the time offset. Unit: seconds.', example='0'),
        timeExpression?: string(name='TimeExpression', description='The time expression. The time expression varies with the time type:

*   **api**: No time expression exists.
*   **fix_rate**: a specific fixed frequency. For example, a value of 30 indicates that the job is triggered every 30 seconds.
*   **cron**: a standard Cron expression.
*   **second_delay**: a fixed delay after which the job is triggered. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
        timeType?: int32(name='TimeType', description='The time type. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
      }(name='TimeConfig', description='The time configurations.'),
      xAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
    }(name='JobConfigInfo', description='The configurations of the job.'),
  }(name='Data', description='The details of the job.'),
  message?: string(name='Message', description='The error message that is returned only when an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the job details are obtained. Valid values:

*   **true**: The job details are obtained.
*   **false**: Failed to obtain the job details.', example='true'),
}

model GetJobInfoResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInfoResponseBody(name='body'),
}

async function getJobInfo(request: GetJobInfoRequest): GetJobInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobInfo', 'GET', '/', 'json', false, 'json', request);
}

model GetJobInstanceRequest {
  regionId: string(name='RegionId', example='cn-hangzhou', position='Host'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job.', example='92583', position='Query'),
  jobInstanceId: long(name='JobInstanceId', description='The ID of the job instance.', example='11111111', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
}

model GetJobInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceDetail?: {
      dataTime?: string(name='DataTime', description='The data time.', example='2020-07-27 11:52:10'),
      endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
      executor?: string(name='Executor', description='The user who executes the job.', example='A'),
      instanceId?: long(name='InstanceId', description='The ID of the job instance.', example='11111111'),
      jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
      progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
      result?: string(name='Result', description='The execution results of the job instance.', example='success'),
      scheduleTime?: string(name='ScheduleTime', description='The scheduled time of the job.', example='2020-07-27 11:52:10'),
      startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
      status?: int32(name='Status', description='The status of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance fails.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
      timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
      triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance is triggered at the scheduled time.
*   **2**: The job instance is triggered due to data update.
*   **3**: The job instance is triggered by an API call.
*   **4**: The job instance is triggered because it is manually rerun.
*   **5**: The job instance is triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
      workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
    }(name='JobInstanceDetail', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instance.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetJobInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInstanceResponseBody(name='body'),
}

async function getJobInstance(request: GetJobInstanceRequest): GetJobInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobInstance', 'GET', '/', 'json', false, 'json', request);
}

model GetJobInstanceListRequest {
  endTimestamp?: long(name='EndTimestamp', position='Query'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the application resides.', example='cn-hangzhou', position='Query'),
  startTimestamp?: long(name='StartTimestamp', position='Query'),
  status?: int32(name='Status', description='', position='Query'),
}

model GetJobInstanceListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobInstanceDetails?: [ 
      {
        dataTime?: string(name='DataTime', description='The data time.', example='2020-07-27 11:52:10'),
        endTime?: string(name='EndTime', description='The end time of the job execution.', example='2020-07-27 11:52:10'),
        executor?: string(name='Executor', description='The user who executes the job.', example='A'),
        instanceId?: long(name='InstanceId', description='The ID of the job instance.', example='11111111'),
        jobId?: long(name='JobId', description='The ID of the job.', example='92583'),
        progress?: string(name='Progress', description='The progress of the job instance.', example='complete'),
        result?: string(name='Result', description='The execution results of the job instance.', example='success'),
        scheduleTime?: string(name='ScheduleTime', description='The scheduled time of the job.', example='2020-07-27 11:52:10'),
        startTime?: string(name='StartTime', description='The start time of the job execution.', example='2020-07-27 11:52:10'),
        status?: int32(name='Status', description='The status of the job instance. Valid values:

*   **1**: The job instance is waiting for execution.
*   **3**: The job instance is running.
*   **4**: The job instance is successful.
*   **5**: The job instance fails.
*   **9**: The job instance is rejected.

Enumeration class: com.alibaba.schedulerx.common.domain.InstanceStatus', example='4'),
        timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job instance. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api

Enumeration class: com.alibaba.schedulerx.common.domain.TimeType', example='1'),
        triggerType?: int32(name='TriggerType', description='The trigger type of the job instance. Valid values:

*   **1**: The job instance is triggered at the scheduled time.
*   **2**: The job instance is triggered due to data update.
*   **3**: The job instance is triggered by an API call.
*   **4**: The job instance is triggered because it is manually rerun.
*   **5**: The job instance is triggered because the system automatically reruns the job instance upon a system exception, such as a database exception.

Enumeration class: com.alibaba.schedulerx.common.domain.TriggerType', example='3'),
        workAddr?: string(name='WorkAddr', description='The endpoint of the triggered client. The value is in the IP address:Port number format.', example='192.168.0.0:16'),
      }
    ](name='JobInstanceDetails', description='The details of the job instance.'),
  }(name='Data', description='The information about the job instances.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='jobid: 92583 not match groupId: testSchedulerx.defaultGroup'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetJobInstanceListResponse = {
  headers: map[string]string(name='headers'),
  body: GetJobInstanceListResponseBody(name='body'),
}

async function getJobInstanceList(request: GetJobInstanceListRequest): GetJobInstanceListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetJobInstanceList', 'GET', '/', 'json', false, 'json', request);
}

model GetLogRequest {
  endTimestamp?: long(name='EndTimestamp', example='1675739484000', position='Query'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobId?: string(name='JobId', example='123', position='Query'),
  jobInstanceId?: string(name='JobInstanceId', example='123456', position='Query'),
  keyword?: string(name='Keyword', example='ERROR', position='Query'),
  line?: int32(name='Line', example='50', minimum=0, maximum=200, position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  offset?: int32(name='Offset', example='0', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  reverse?: boolean(name='Reverse', example='true', position='Query'),
  startTimestamp?: long(name='StartTimestamp', example='1675739364000', position='Query'),
}

model GetLogResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    logs?: [ string ](name='Logs'),
  }(name='Data'),
  message?: string(name='Message', example='jobid=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetLogResponse = {
  headers: map[string]string(name='headers'),
  body: GetLogResponseBody(name='body'),
}

async function getLog(request: GetLogRequest): GetLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetLog', 'GET', '/', 'json', false, 'json', request);
}

model GetWorkFlowRequest {
  groupId: string(name='GroupId', description='The ID of the application group.', example='hxm.test', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace.', example='4a06d5ea-f576-4326-842c-fb14ea043d8d', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespcae.', example='source', position='Query'),
  regionId: string(name='RegionId', description='The region information.', example='public', position='Query'),
  workflowId: long(name='WorkflowId', description='The ID of the workflow.', example='1234', position='Query'),
}

model GetWorkFlowResponseBody = {
  code?: int32(name='Code', description='The error code that is returned.', example='200'),
  data?: {
    workFlowInfo?: {
      description?: string(name='Description', description='The description of the workflow.', example='my first workflow'),
      name?: string(name='Name', description='The name of the workflow.', example='workflow_111'),
      status?: string(name='Status', description='The status of the workflow.', example='Successful'),
      timeExpression?: string(name='TimeExpression', description='The time expression of the workflow.', example='0 0 2 * * ?'),
      timeType?: string(name='TimeType', description='The time type of the workflow.', example='cron'),
      workflowId?: long(name='WorkflowId', description='The ID of the workflow.', example='1234xxx'),
    }(name='WorkFlowInfo', description='The basic information of the workflow.'),
    workFlowNodeInfo?: {
      edges?: [ 
        {
          source?: long(name='Source', description='The ID of the source job.', example='100'),
          target?: long(name='Target', description='The ID of the target job.', example='200'),
        }
      ](name='Edges', description='The workflow edges.'),
      nodes?: [ 
        {
          id?: long(name='Id', description='The ID of the job.', example='123456xxx'),
          label?: string(name='Label', description='The name of the job.', example='job_111'),
          status?: int32(name='Status', description='The status of the job.', example='1'),
        }
      ](name='Nodes', description='The list of workflow nodes.'),
    }(name='WorkFlowNodeInfo', description='The node information of the workflow.'),
  }(name='Data', description='The data of the workflow.'),
  message?: string(name='Message', description='The error message that is returned.', example='workflow is not existed'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45678xxx'),
  success?: boolean(name='Success', description='The result of the API call.', example='true'),
}

model GetWorkFlowResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkFlowResponseBody(name='body'),
}

async function getWorkFlow(request: GetWorkFlowRequest): GetWorkFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWorkFlow', 'GET', '/', 'json', false, 'json', request);
}

model GetWorkerListRequest {
  groupId: string(name='GroupId', description='The ID of the permission group.', example='usercenter', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model GetWorkerListResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    workerInfos?: [ 
      {
        ip?: string(name='Ip', description='The IP address of the worker.', example='30.225.16.49'),
        label?: string(name='Label', description='The label of the worker.', example='gray'),
        port?: int32(name='Port', description='The port number of the worker.', example='60831'),
        starter?: string(name='Starter', description='The startup method of the worker.', example='springboot'),
        version?: string(name='Version', description='The version of the worker.', example='1.3.4'),
        workerAddress?: string(name='WorkerAddress', description='The address of the worker. The address is in the format of ${worker_id}@${worker_ip}:${worker_port}.', example='030225016049_11734_25917@30.225.16.49:60831'),
      }
    ](name='WorkerInfos', description='The worker information.'),
  }(name='Data', description='The job information.'),
  message?: string(name='Message', description='The additional information that is returned.', example='Cannot find product according to your domain.'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108****'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model GetWorkerListResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkerListResponseBody(name='body'),
}

async function getWorkerList(request: GetWorkerListRequest): GetWorkerListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWorkerList', 'GET', '/', 'json', false, 'json', request);
}

model GetWorkflowInstanceRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  wfInstanceId: long(name='WfInstanceId', example='123456', position='Query'),
  workflowId: long(name='WorkflowId', example='123', position='Query'),
}

model GetWorkflowInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    wfInstanceDag?: {
      edges?: [ 
        {
          source?: long(name='Source', example='24058798'),
          target?: long(name='Target', example='24058796'),
        }
      ](name='Edges'),
      nodes?: [ 
        {
          attempt?: int32(name='Attempt', example='0'),
          dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
          endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
          jobId?: long(name='JobId', example='1472'),
          jobInstanceId?: long(name='JobInstanceId', example='24058796'),
          result?: string(name='Result', example='code=200'),
          scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:03'),
          startTime?: string(name='StartTime', example='2023-01-03 18:00:03'),
          workAddr?: string(name='WorkAddr', example='10.163.0.101:34027'),
        }
      ](name='Nodes'),
    }(name='WfInstanceDag'),
    wfInstanceInfo?: {
      dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
      endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
      scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:00'),
      startTime?: string(name='StartTime', example='2023-01-03 18:00:01'),
      status?: int32(name='Status', example='5'),
    }(name='WfInstanceInfo'),
  }(name='Data'),
  message?: string(name='Message', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model GetWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetWorkflowInstanceResponseBody(name='body'),
}

async function getWorkflowInstance(request: GetWorkflowInstanceRequest): GetWorkflowInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetWorkflowInstance', 'GET', '/', 'json', false, 'json', request);
}

model GrantPermissionRequest {
  grantOption?: boolean(name='GrantOption', description='Specifies whether to grant the permissions with the GRANT option. Valid values: -**true**: grants the permissions with the GRANT option. -**false**: does not grant the permissions with the GRANT option.', example='false', position='Query'),
  groupId: string(name='GroupId', description='The ID of the application group.', example='test.defaultGroup', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  userId: string(name='UserId', description='The user ID.', example='277641081920123456', position='Query'),
  userName: string(name='UserName', description='The username.', example='lilei', position='Query'),
}

model GrantPermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='400'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='false'),
}

model GrantPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: GrantPermissionResponseBody(name='body'),
}

async function grantPermission(request: GrantPermissionRequest): GrantPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantPermission', 'POST', '/', 'json', false, 'json', request);
}

model ListGroupsRequest {
  namespace: string(name='Namespace', description='The namespace. You can obtain the namespace on the **Namespace** page in Distributed Task Scheduling Platform.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='Required only for a special third party.', example='schedulerx', position='Query'),
  regionId?: string(name='RegionId', description='The ID of the region in which the application is located.', example='cn-hangzhou', position='Query'),
}

model ListGroupsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code returned.', example='200'),
  data?: {
    appGroups?: [ 
      {
        appGroupId?: long(name='AppGroupId', description='ID', example='1'),
        appKey?: string(name='AppKey', description='The key for the application.', example='a3G77O6NZxq/lyo1NC****=='),
        appName?: string(name='AppName', description='The name of the application.', example='DocTest'),
        description?: string(name='Description', description='The application description.', example='Test'),
        groupId?: string(name='GroupId', description='The application ID.', example='DocTest.Group'),
      }
    ](name='AppGroups', description='The list of applications and details of applications.'),
  }(name='Data', description='The information about the list of applications.'),
  message?: string(name='Message', description='The additional information returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58A'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: ListGroupsResponseBody(name='body'),
}

/**
  * >  Before you call this operation, you must add the following dependency to the pom.xml file:
  *       <groupId>com.aliyun</groupId>
  *       <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *       <version>1.0.5</version>
  *
 */
async function listGroups(request: ListGroupsRequest): ListGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListGroups', 'GET', '/', 'json', false, 'json', request);
}

model ListJobsRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the **Application Management** page in the SchedulerX console.', example='DocTest.Group', position='Query'),
  jobName?: string(name='JobName', description='The name of the job.', example='helloword', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the **Namespace** page in the SchedulerX console.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the job resides.', example='cn-hangzhou', position='Query'),
  status?: string(name='Status', description='Specifies whether to enable the job. Valid values:

*   **0**: disables the job.
*   **1**: enables the job.', example='1', position='Query'),
}

model ListJobsResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    jobs?: [ 
      {
        attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system retries to run the job after a job failure. Unit: seconds. Default value: 30.', example='30'),
        className?: string(name='ClassName', description='The full path of the job interface class. This parameter is returned only for a Java job.', example='com.alibaba.schedulerx.test.helloworld'),
        content?: string(name='Content', description='The script of the job. This parameter is returned only for a Python, Shell, or Go job.', example='echo \\"hello\\"'),
        description?: string(name='Description', description='The description of the job.', example='Test'),
        executeMode?: string(name='ExecuteMode', description='The execution mode of the job. Valid values:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **shard**: The job runs in multipart mode.', example='standalone'),
        jarUrl?: string(name='JarUrl', description='The full path to which a JAR package is uploaded in Object Storage Service (OSS).', example='https:doc***.oss-cn-hangzhou.aliyuncs.com/sc-****-D-0.0.2-SNAPSHOT.jar'),
        jobId?: long(name='JobId', description='The ID of the job.', example='99341'),
        jobMonitorInfo?: {
          contactInfo?: [ 
            {
              ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
              userMail?: string(name='UserMail', description='The email address of the user.', example='user@mail.com'),
              userName?: string(name='UserName', description='The name of the user.', example='userA'),
              userPhone?: string(name='UserPhone', description='The mobile number of the user.', example='1381111****'),
            }
          ](name='ContactInfo', description='The contact information.'),
          monitorConfig?: {
            failEnable?: boolean(name='FailEnable', description='Indicates whether the feature of generating an alert upon a failure is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            missWorkerEnable?: boolean(name='MissWorkerEnable', description='Indicates whether the feature of generating an alert when no machine is available for running the job is enabled.', example='true'),
            sendChannel?: string(name='SendChannel', description='The method that is used to send an alert notification. Only Short Message Service (SMS) is supported.', example='sms'),
            timeout?: long(name='Timeout', description='The timeout threshold. Unit: seconds. Default value: 7200.', example='12300'),
            timeoutEnable?: boolean(name='TimeoutEnable', description='Indicates whether the feature of generating an alert upon a timeout is enabled. Valid values:

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='true'),
            timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Indicates whether the feature of stopping job triggering upon a timeout is enabled. By default, the feature is disabled.

*   **true**: The feature is enabled.
*   **false**: The feature is disabled.', example='false'),
          }(name='MonitorConfig', description='The configurations of the alerting feature and the alert threshold.'),
        }(name='JobMonitorInfo', description='The monitoring information of the job.'),
        jobType?: string(name='JobType', description='The type of the job.', example='java'),
        mapTaskXAttrs?: {
          consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a standalone job at a time. Default value: 5.', example='5'),
          dispatcherSize?: int32(name='DispatcherSize', description='The number of task distribution threads. Default value: 5.', example='5'),
          pageSize?: int32(name='PageSize', description='The number of tasks that are pulled by a parallel job at a time. Default value: 100.', example='100'),
          queueSize?: int32(name='QueueSize', description='The maximum number of task queues that can be cached. Default value: 10000.', example='10000'),
          taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system retries to run the task after a task failure.', example='0'),
          taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries after a task failure.', example='0'),
        }(name='MapTaskXAttrs', description='The advanced configurations of the job. The parameters are returned only if the value of the ExecuteMode parameter is parallel, grid, or batch.'),
        maxAttempt?: int32(name='MaxAttempt', description='The maximum number of retries after a job failure. This parameter is specified based on your business requirements. Default value: 0.', example='0'),
        maxConcurrency?: string(name='MaxConcurrency', description='The maximum number of instances that can concurrently run for the job. Default value: 1. A value of 1 indicates that if the last triggered instance is running, the next instance is not triggered even if the scheduled point in time for running the instance is reached.', example='1'),
        name?: string(name='Name', description='The name of the job.', example='helloworld'),
        parameters?: string(name='Parameters', description='The user-defined parameters. These parameters can be obtained when the job is running.', example='test'),
        status?: int32(name='Status', description='The status of the job. Valid values:

*   **1**: The job is enabled and can be triggered.
*   **0**: The job is disabled and cannot be triggered.', example='1'),
        timeConfig?: {
          calendar?: string(name='Calendar', description='If the TimeType parameter is set to cron, you can specify custom calendar days.', example='Business days'),
          dataOffset?: int32(name='DataOffset', description='The time offset if the TimeType parameter is set to cron. Unit: seconds.', example='0'),
          timeExpression?: string(name='TimeExpression', description='The time expression. Valid values:

*   **api**: indicates that no time expression is used to specify the time when to schedule the job.
*   **fix_rate**: indicates that the job is triggered at a fixed frequency. For example, a value of 30 indicates that the job is triggered every 30 seconds.
*   **cron**: indicates that a standard CRON expression is used to specify the time when to schedule the job.
*   **second_delay**: indicates that the job is triggered after a fixed delay. Valid values: 1 to 60. Unit: seconds.', example='0 0/10 * * * ?'),
          timeType?: int32(name='TimeType', description='The method that is used to specify the time when to schedule the job. Valid values:

*   **1**: cron
*   **3**: fix_rate
*   **4**: second_delay
*   **100**: api', example='1'),
        }(name='TimeConfig', description='The time configurations.'),
        xAttrs?: string(name='XAttrs', description='The extended fields.', example='{"pageSize":5,"queueSize":10,"consumerSize":5,"dispatcherSize":5,"taskMaxAttempt":0,"taskAttemptInterval":0,"globalConsumerSize":1000,"taskDispatchMode":"push"}'),
      }
    ](name='Jobs', description='The jobs and their details.'),
  }(name='Data', description='The information about the jobs.'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='namespace can not find namespace: 1a72ecb1-b4cc-400a-a71b-20cdec9b****, namespaceSource:null'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58B'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListJobsResponse = {
  headers: map[string]string(name='headers'),
  body: ListJobsResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *           <groupId>com.aliyun</groupId>
  *           <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *           <version>1.0.5</version>
  *     </dependency>
  *
 */
async function listJobs(request: ListJobsRequest): ListJobsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListJobs', 'GET', '/', 'json', false, 'json', request);
}

model ListNamespacesRequest {
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
}

model ListNamespacesResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  data?: {
    namespaces?: [ 
      {
        description?: string(name='Description', description='The description of the namespace.', example='test'),
        name?: string(name='Name', description='The name of the namespace.', example='doc'),
        uId?: string(name='UId', description='The ID of the namespace.', example='1a72ecb1-b4cc-400a-a71b-20cdec9b****'),
      }
    ](name='Namespaces', description='The list and details of the namespaces.'),
  }(name='Data', description='The list of namespaces.'),
  message?: string(name='Message', description='The additional information that is returned.', example='message'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='71BCC0E3-64B2-4B63-A870-AFB64EBCB58C'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model ListNamespacesResponse = {
  headers: map[string]string(name='headers'),
  body: ListNamespacesResponseBody(name='body'),
}

/**
  * Before you call this operation, you must add the following dependency to the pom.xml file:
  *     <dependency>
  *         <groupId>com.aliyun</groupId>
  *         <artifactId>aliyun-java-sdk-schedulerx2</artifactId>
  *         <version>1.0.5</version>
  *     </dependency>
  *
 */
async function listNamespaces(request: ListNamespacesRequest): ListNamespacesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListNamespaces', 'GET', '/', 'json', false, 'json', request);
}

model ListWorkflowInstanceRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  workflowId: string(name='WorkflowId', example='123', position='Query'),
}

model ListWorkflowInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  data?: {
    wfInstanceInfos?: [ 
      {
        dataTime?: string(name='DataTime', example='2023-01-03 18:00:00'),
        endTime?: string(name='EndTime', example='2023-01-03 18:00:21'),
        scheduleTime?: string(name='ScheduleTime', example='2023-01-03 18:00:00'),
        startTime?: string(name='StartTime', example='2023-01-03 18:00:01'),
        status?: int32(name='Status', example='5'),
        wfInstanceId?: long(name='WfInstanceId', example='123456'),
        workflowId?: long(name='WorkflowId', example='123'),
      }
    ](name='WfInstanceInfos'),
  }(name='Data'),
  message?: string(name='Message', example='workflowId=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model ListWorkflowInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkflowInstanceResponseBody(name='body'),
}

async function listWorkflowInstance(request: ListWorkflowInstanceRequest): ListWorkflowInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListWorkflowInstance', 'GET', '/', 'json', false, 'json', request);
}

model RerunJobRequest {
  dataTime: string(name='DataTime', example='10:00:00', position='Body'),
  endDate: long(name='EndDate', example='1645718400000', position='Body'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Body'),
  jobId: long(name='JobId', example='123', position='Body'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Body'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Body'),
  startDate: long(name='StartDate', example='1645459200000', position='Body'),
}

model RerunJobResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model RerunJobResponse = {
  headers: map[string]string(name='headers'),
  body: RerunJobResponseBody(name='body'),
}

async function rerunJob(request: RerunJobRequest): RerunJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RerunJob', 'POST', '/', 'json', true, 'form', request);
}

model RetryJobInstanceRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', example='123', position='Query'),
  jobInstanceId: long(name='JobInstanceId', example='123456', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model RetryJobInstanceResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model RetryJobInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RetryJobInstanceResponseBody(name='body'),
}

async function retryJobInstance(request: RetryJobInstanceRequest): RetryJobInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RetryJobInstance', 'POST', '/', 'json', false, 'json', request);
}

model RevokePermissionRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='test.defalutGroup', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffcdf01', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-shenzhen', position='Query'),
  userId: string(name='UserId', description='The unique ID (UID) of the RAM user.', example='277641081920123456', position='Query'),
}

model RevokePermissionResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='400'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='false'),
}

model RevokePermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokePermissionResponseBody(name='body'),
}

async function revokePermission(request: RevokePermissionRequest): RevokePermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokePermission', 'POST', '/', 'json', false, 'json', request);
}

model SetJobInstanceSuccessRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  jobId: long(name='JobId', example='123', position='Query'),
  jobInstanceId: long(name='JobInstanceId', example='123456', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model SetJobInstanceSuccessResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='jobId=xxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model SetJobInstanceSuccessResponse = {
  headers: map[string]string(name='headers'),
  body: SetJobInstanceSuccessResponseBody(name='body'),
}

async function setJobInstanceSuccess(request: SetJobInstanceSuccessRequest): SetJobInstanceSuccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetJobInstanceSuccess', 'POST', '/', 'json', false, 'json', request);
}

model SetWfInstanceSuccessRequest {
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  wfInstanceId: long(name='WfInstanceId', example='123456789', position='Query'),
  workflowId: long(name='WorkflowId', example='123', position='Query'),
}

model SetWfInstanceSuccessResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='wofkflowId is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model SetWfInstanceSuccessResponse = {
  headers: map[string]string(name='headers'),
  body: SetWfInstanceSuccessResponseBody(name='body'),
}

async function setWfInstanceSuccess(request: SetWfInstanceSuccessRequest): SetWfInstanceSuccessResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetWfInstanceSuccess', 'POST', '/', 'json', false, 'json', request);
}

model StopInstanceRequest {
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in the SchedulerX console.', example='testSchedulerx.defaultGroup', position='Query'),
  instanceId: long(name='InstanceId', description='The ID of the job instance in the running state.', example='11111111', position='Query'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in the SchedulerX console.', example='92583', position='Query'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the namespace ID on the Namespace page in the SchedulerX console.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  namespaceSource?: string(name='NamespaceSource', description='The source of the namespace. This parameter is required only for a special third party.', example='schedulerx', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region in which the application resides.', example='cn-hangzhou', position='Query'),
}

model StopInstanceResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The error message that is returned if an error occurs.', example='Your request is denied as lack of ssl protect.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   **true**: The call is successful.
*   **false**: The call fails.', example='true'),
}

model StopInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopInstanceResponseBody(name='body'),
}

async function stopInstance(request: StopInstanceRequest): StopInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopInstance', 'GET', '/', 'json', false, 'json', request);
}

model UpdateAppGroupRequest {
  description?: string(name='Description', example='Test', position='Query'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Query'),
  maxConcurrency?: int32(name='MaxConcurrency', example='1', position='Query'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Query'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
}

model UpdateAppGroupResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='app is not existed, groupId=xxxx, namesapce=xxxx'),
  requestId?: string(name='RequestId', description='Id of the request', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', example='true'),
}

model UpdateAppGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateAppGroupResponseBody(name='body'),
}

async function updateAppGroup(request: UpdateAppGroupRequest): UpdateAppGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateAppGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateJobRequest {
  attemptInterval?: int32(name='AttemptInterval', description='The interval at which the system attempts to rerun a job. Default value: 30. Unit: seconds.', example='30', position='Body'),
  calendar?: string(name='Calendar', description='When the Time type parameter is set to cron, you can specify a custom calendar.', example='Business days', position='Body'),
  className?: string(name='ClassName', description='The full path of the job interface class.

This field is available only when you select a java job. In this case, you must enter a full path.', example='com.alibaba.test.helloworld', position='Body'),
  consumerSize?: int32(name='ConsumerSize', description='The number of threads that are triggered by a single worker at a time. Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5', position='Body'),
  contactInfo?: [ 
    {
      ding?: string(name='Ding', description='The webhook URL of the DingTalk chatbot. For more information, see [DingTalk development documentation](https://open.dingtalk.com/document/org/application-types).', example='https://oapi.dingtalk.com/robot/send?access_token=**********'),
      userMail?: string(name='UserMail', description='The email address of the contact.', example='test***@***.com'),
      userName?: string(name='UserName', description='The name of the contact.', example='userA'),
      userPhone?: string(name='UserPhone', description='The mobile phone number of the contact.', example='1381111****'),
    }
  ](name='ContactInfo', description='The information of the job contact.', position='Body'),
  content?: string(name='Content', description='The script code content that is required when you set the job type to **python**, **shell**, or **go**.', example='echo \\"hello\\"', position='Body'),
  dataOffset?: int32(name='DataOffset', description='When the Time type parameter is set to cron, you can specify a time offset. Unit: seconds.', example='2400', position='Body'),
  description?: string(name='Description', description='The description of the job.', example='test', position='Body'),
  dispatcherSize?: int32(name='DispatcherSize', description='Default value: 5. This parameter is an advanced configuration item of the MapReduce job.', example='5', position='Body'),
  executeMode?: string(name='ExecuteMode', description='The execution mode of the job. The following execution modes are supported:

*   **standalone**: The job runs in standalone mode.
*   **broadcast**: The job runs in broadcast mode.
*   **parallel**: The job runs in parallel computing mode.
*   **grid**: The job runs in memory grid mode.
*   **batch**: The job runs in grid computing mode.
*   **sharding**: The job runs in sharding mode.', example='standalone', position='Body'),
  failEnable?: boolean(name='FailEnable', description='Specifies whether to turn on Failure alarm. Valid values:

*   **true**: Turn on Failure alarm.
*   **false**: Turn off Failure alarm.', example='true', position='Body'),
  failTimes?: int32(name='FailTimes', position='Body'),
  groupId: string(name='GroupId', description='The ID of the application. You can obtain the application ID on the Application Management page in Distributed Task Scheduling Platform.', example='testSchedulerx.defaultGroup', position='Body'),
  jobId: long(name='JobId', description='The ID of the job. You can obtain the job ID on the Task Management page in Distributed Task Scheduling Platform.', example='92583', position='Body'),
  maxAttempt?: int32(name='MaxAttempt', description='The maximum number of attempts that the system can make when an error occurs on a job. You can specify this parameter based on your business requirements.', example='0', position='Body'),
  maxConcurrency?: int32(name='MaxConcurrency', description='The maximum number of instances that the system can run at the same time. Default value: 1. When you set this parameter to 1, if the current job does not end, the system will not run the next job even if the runtime is reached.', example='1', minimum=1, maximum=200, position='Body'),
  missWorkerEnable?: boolean(name='MissWorkerEnable', description='Specifies whether to turn on No machine alarm available when no worker is available.

*   **true**: Turn on No machine alarm available when no worker is available.
*   **false**: Turn off No machine alarm available when no worker is available.', example='true', position='Body'),
  name?: string(name='Name', description='The name of the job.', example='helloword', position='Body'),
  namespace: string(name='Namespace', description='The ID of the namespace. You can obtain the ID of the namespace on the Namespace page in Distributed Task Scheduling Platform.', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', description='This parameter is required only for a special third party.', example='schedulerx', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of subtasks that can be pulled at a time. Default value: 100. This parameter is an advanced configuration item of the MapReduce job.', example='100', position='Body'),
  parameters?: string(name='Parameters', description='The user-defined parameters that you can obtain when you run the job.', example='test', position='Body'),
  queueSize?: int32(name='QueueSize', description='The maximum number of subtask queues that you can cache. Default value: 10000. This parameter is an advanced configuration item of the MapReduce job.', example='10000', position='Body'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  sendChannel?: string(name='SendChannel', description='The channel for sending alerts. Only SMS messages are supported.', example='sms', position='Body'),
  successNoticeEnable?: boolean(name='SuccessNoticeEnable', position='Body'),
  taskAttemptInterval?: int32(name='TaskAttemptInterval', description='The interval at which the system can rerun the subtask when the subtask fails. This parameter is an advanced configuration item of the MapReduce job.', example='0', minimum=0, position='Body'),
  taskDispatchMode?: string(name='TaskDispatchMode', position='Body'),
  taskMaxAttempt?: int32(name='TaskMaxAttempt', description='The number of retries that the system can perform when the subtask fails. This parameter is an advanced configuration item of the MapReduce job.', example='0', minimum=0, maximum=10, position='Body'),
  timeExpression?: string(name='TimeExpression', description='The time expression. You can set the time expression according to the selected time type.

*   **cron**: Specify a standard Cron expression. You can verify the expression online after you specify the expression.
*   **api**: No time expression is available.
*   **fixed_rate**: Specify a fixed frequency value. Unit: seconds. For example, if you set this parameter to 30, the system triggers a job every 30 seconds.
*   **second_delay**: Specify a delay after which you can run a job. You can specify a value from 1 to 60. Unit: seconds.', example='30', position='Body'),
  timeType?: int32(name='TimeType', description='The type of time. The following time types are supported:

*   **cron**: 1
*   **fix_rate**: 3
*   **second_delay**: 4
*   **api**: 100', example='1', position='Body'),
  timeout?: long(name='Timeout', description='The timeout threshold. Default value: 7200. Unit: seconds.', example='7200', position='Body'),
  timeoutEnable?: boolean(name='TimeoutEnable', description='Specifies whether to turn on Timeout alarm. Valid values:

*   **true**: Turn on Timeout alarm.
*   **false**: Turn off Timeout alarm.', example='true', position='Body'),
  timeoutKillEnable?: boolean(name='TimeoutKillEnable', description='Specifies whether to turn on Timeout termination. Valid values:

*   **true**: Turn on Timeout termination.
*   **false**: Turn off Timeout termination.', example='true', position='Body'),
}

model UpdateJobResponseBody = {
  code?: int32(name='Code', description='The HTTP status code that is returned.', example='200'),
  message?: string(name='Message', description='The additional information that is returned only if the error occurs.', example='job type is java className can not be blank'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4F68ABED-AC31-4412-9297-D9A8F0401108'),
  success?: boolean(name='Success', description='Indicates whether the request was successful.', example='true'),
}

model UpdateJobResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateJobResponseBody(name='body'),
}

async function updateJob(request: UpdateJobRequest): UpdateJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateJob', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWorkflowRequest {
  description?: string(name='Description', example='Test', position='Body'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Body'),
  name?: string(name='Name', example='helloworld', position='Body'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Body'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  timeExpression?: string(name='TimeExpression', example='0 0/10 * * * ?', position='Body'),
  timeType?: int32(name='TimeType', example='1', position='Body'),
  workflowId: string(name='WorkflowId', example='123', position='Body'),
}

model UpdateWorkflowResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='timetype is invalid'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model UpdateWorkflowResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkflowResponseBody(name='body'),
}

async function updateWorkflow(request: UpdateWorkflowRequest): UpdateWorkflowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWorkflow', 'POST', '/', 'json', true, 'form', request);
}

model UpdateWorkflowDagRequest {
  dagJson: string(name='DagJson', example='{"nodes":[{"id":2300691},{"id":10518089},{"id":1758851}],"edges":[{"source":10518089,"target":1758851},{"source":10518089,"target":2300691}]}', position='Body'),
  groupId: string(name='GroupId', example='testSchedulerx.defaultGroup', position='Body'),
  namespace: string(name='Namespace', example='adcfc35d-e2fe-4fe9-bbaa-20e90ffc****', position='Body'),
  namespaceSource?: string(name='NamespaceSource', example='schedulerx', position='Body'),
  regionId: string(name='RegionId', example='cn-hangzhou', position='Query'),
  workflowId: string(name='WorkflowId', example='123', position='Body'),
}

model UpdateWorkflowDagResponseBody = {
  code?: int32(name='Code', example='200'),
  message?: string(name='Message', example='workflowId=xxxx is not existed'),
  requestId?: string(name='RequestId', description='Id of the request', example='39090022-1F3B-4797-8518-6B61095F1AF0'),
  success?: boolean(name='Success', example='true'),
}

model UpdateWorkflowDagResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateWorkflowDagResponseBody(name='body'),
}

async function updateWorkflowDag(request: UpdateWorkflowDagRequest): UpdateWorkflowDagResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateWorkflowDag', 'POST', '/', 'json', true, 'form', request);
}

