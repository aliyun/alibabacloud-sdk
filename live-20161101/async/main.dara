/**
  *
  */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'live';
  @version = '2016-11-01';
  @endpointRule = 'regional';
  @endpointMap = {
    'cn-qingdao' = 'live.aliyuncs.com',
    'cn-beijing' = 'live.aliyuncs.com',
    'cn-hangzhou' = 'live.aliyuncs.com',
    'cn-shanghai' = 'live.aliyuncs.com',
    'cn-shenzhen' = 'live.aliyuncs.com',
    'ap-southeast-1' = 'live.aliyuncs.com',
    'ap-southeast-5' = 'live.aliyuncs.com',
    'ap-northeast-1' = 'live.aliyuncs.com',
    'eu-central-1' = 'live.aliyuncs.com',
    'ap-south-1' = 'live.aliyuncs.com',
    'ap-northeast-2-pop' = 'live.aliyuncs.com',
    'ap-southeast-2' = 'live.aliyuncs.com',
    'ap-southeast-3' = 'live.aliyuncs.com',
    'cn-beijing-finance-1' = 'live.aliyuncs.com',
    'cn-beijing-finance-pop' = 'live.aliyuncs.com',
    'cn-beijing-gov-1' = 'live.aliyuncs.com',
    'cn-beijing-nu16-b01' = 'live.aliyuncs.com',
    'cn-chengdu' = 'live.aliyuncs.com',
    'cn-edge-1' = 'live.aliyuncs.com',
    'cn-fujian' = 'live.aliyuncs.com',
    'cn-haidian-cm12-c01' = 'live.aliyuncs.com',
    'cn-hangzhou-bj-b01' = 'live.aliyuncs.com',
    'cn-hangzhou-finance' = 'live.aliyuncs.com',
    'cn-hangzhou-internal-prod-1' = 'live.aliyuncs.com',
    'cn-hangzhou-internal-test-1' = 'live.aliyuncs.com',
    'cn-hangzhou-internal-test-2' = 'live.aliyuncs.com',
    'cn-hangzhou-internal-test-3' = 'live.aliyuncs.com',
    'cn-hangzhou-test-306' = 'live.aliyuncs.com',
    'cn-hongkong' = 'live.aliyuncs.com',
    'cn-hongkong-finance-pop' = 'live.aliyuncs.com',
    'cn-huhehaote' = 'live.aliyuncs.com',
    'cn-huhehaote-nebula-1' = 'live.aliyuncs.com',
    'cn-north-2-gov-1' = 'live.aliyuncs.com',
    'cn-qingdao-nebula' = 'live.aliyuncs.com',
    'cn-shanghai-et15-b01' = 'live.aliyuncs.com',
    'cn-shanghai-et2-b01' = 'live.aliyuncs.com',
    'cn-shanghai-finance-1' = 'live.aliyuncs.com',
    'cn-shanghai-inner' = 'live.aliyuncs.com',
    'cn-shanghai-internal-test-1' = 'live.aliyuncs.com',
    'cn-shenzhen-finance-1' = 'live.aliyuncs.com',
    'cn-shenzhen-inner' = 'live.aliyuncs.com',
    'cn-shenzhen-st4-d01' = 'live.aliyuncs.com',
    'cn-shenzhen-su18-b01' = 'live.aliyuncs.com',
    'cn-wuhan' = 'live.aliyuncs.com',
    'cn-wulanchabu' = 'live.aliyuncs.com',
    'cn-yushanfang' = 'live.aliyuncs.com',
    'cn-zhangbei' = 'live.aliyuncs.com',
    'cn-zhangbei-na61-b01' = 'live.aliyuncs.com',
    'cn-zhangjiakou' = 'live.aliyuncs.com',
    'cn-zhangjiakou-na62-a01' = 'live.aliyuncs.com',
    'cn-zhengzhou-nebula-1' = 'live.aliyuncs.com',
    'eu-west-1' = 'live.aliyuncs.com',
    'eu-west-1-oxs' = 'live.aliyuncs.com',
    'me-east-1' = 'live.aliyuncs.com',
    'rus-west-1-pop' = 'live.aliyuncs.com',
    'us-east-1' = 'live.aliyuncs.com',
    'us-west-1' = 'live.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model AppInfoDTO {
  appName?: string(name='AppName'),
  appType?: int32(name='AppType', example='1-普通应用，2-内嵌SDK.'),
  creationTime?: string(name='CreationTime'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  itemId?: string(name='ItemId'),
  modificationTime?: string(name='ModificationTime'),
  platforms?: [ 
    {
      itemId?: string(name='ItemId'),
      licenseItemIds?: [ string ](name='LicenseItemIds'),
      pkgName?: string(name='PkgName'),
      pkgSignature?: string(name='PkgSignature'),
      platformType?: long(name='PlatformType'),
      type?: long(name='Type'),
    }
  ](name='Platforms'),
  userId?: long(name='UserId'),
}

model LicenseInstanceAppDTO {
  appId?: string(name='AppId'),
  beginOn?: string(name='BeginOn'),
  contractNo?: string(name='ContractNo'),
  creationTime?: string(name='CreationTime'),
  expiredOn?: string(name='ExpiredOn'),
  instanceId?: string(name='InstanceId'),
  itemId?: string(name='ItemId'),
  licenseConfigs?: [ 
    {
      businessType?: string(name='BusinessType'),
      featureIds?: string(name='FeatureIds'),
      isTrial?: boolean(name='IsTrial'),
      sdkId?: int32(name='SdkId'),
      sdkName?: string(name='SdkName'),
      subscription?: string(name='Subscription'),
      subscriptionImp?: string(name='SubscriptionImp'),
      subscriptionPkg?: string(name='SubscriptionPkg'),
    }
  ](name='LicenseConfigs'),
  modificationTime?: string(name='ModificationTime'),
  status?: string(name='Status'),
  userId?: long(name='UserId'),
}

model AddCasterComponentRequest {
  captionLayerContent?: string(name='CaptionLayerContent', description='The information about the caption layer. This parameter contains the following fields:

>  This parameter is required when the ComponentType parameter is set to caption.

*   **SizeNormalized**: the normalized font size. The font size is set to font_size/output_height. The value range is `[0,1]` and accurate to two decimal places. If the font size calculated by the system based on the normalization method is greater than **1024**, **1024** is used.
*   **BorderWidthNormalized**: the normalized value of the text border width, which is calculated based on the size of the text, namely "BorderWidth/FontSize". The value range is `[0,1]` and accurate to two decimal places. If the value calculated according to the normalization method exceeds **16**, **16** is used. The default value is **0**.
*   **FontName**: the font name. For more information about the value, see **Font description**. The default font name is KaiTi.
*   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is not set. In this case, the color of the text border is transparent.
*   **LocationId**: the channel ID of the source subtitle.
*   **SourceLan**: the source language of the audio in the source video. Valid values: en, cn, es, and ru, which indicate English, Chinese, Spanish, and Russian respectively. Default value: cn.
*   **TargetLan**: the target audio language in the source video. If you do not specify this field, speech recognition is used. If you specify this field, translation is used. Valid values: en, cn, es, and ru, which indicate English, Chinese, Spanish, and Russian respectively. Default value: cn.
*   **ShowSourceLan**: specifies whether to display the source language. Valid values: true: displays the source language. false: hides the source language. Default value: false.
*   **Truncation**: specifies whether to allow caption truncation. Valid values: true: specifies that the caption can be truncated. false: specifies that the caption cannot be truncated. Default value: false.
*   **SourceLanPerLineWordCount**: the number of words displayed in each line when the subtitle is in the source language. Default value: 20.
*   **TargetLanPerLineWordCount**: the number of words displayed in each line when the subtitle is in the destination language. Default value: 20.
*   **SourceLanReservePages**: the number of lines reserved when the subtitle is in the source language. This field takes effect only when the Truncation field is set to true. Default value: 2.
*   **TargetLanReservePages**: the number of lines reserved when the subtitle is in the destination language. This field takes effect only when the Truncation field is set to true. Default value: 2.

The value is a JSON string. Use upper camel case for field names.', example='{"BorderWidthNormalized":0.01,"SizeNormalized":0.05,"Color":"0x000000","LocationId":"RV01","SourceLan":"cn","FontName":"KaiTi","BorderColor":"0xffffff"}', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  componentLayer: string(name='ComponentLayer', description='The information about the component layer, such as the size and layout. This parameter contains the following fields:

*   **HeightNormalized**: the normalized value of heights for the elements in the component layer
*   **WidthNormalized**: the normalized value of widths for the elements in the component layer
*   **PositionNormalized**: the normalized value of the coordinates of the component layer
*   **PositionRefer**: the reference coordinates of the component layer.

The value is a JSON string. Use upper camel case for field names.

This parameter is required.', example='{"HeightNormalized":"1","PositionRefer":"topRight","WidthNormalized":"0","PositionNormalized":["0.1","0.2"]}', position='Query'),
  componentName?: string(name='ComponentName', description='The component name. By default, the component name is the component ID.', example='text01', position='Query'),
  componentType: string(name='ComponentType', description='The component type. Valid values:

*   **text**: a text component. If you set ComponentType to text, you must also specify TextLayerContent.
*   **image**: an image component. If you set ComponentType to image, you must also specify ImageLayerContent.
*   **caption**: a caption component. If you set ComponentType to caption, you must also specify CaptionLayerContent.

This parameter is required.', example='text', position='Query'),
  effect?: string(name='Effect', description='The effect of the component. Valid values:

*   **none (default)**
*   **animateH**: horizontal scrolling
*   **animateV**: vertical scrolling', example='animateH', position='Query'),
  htmlLayerContent?: string(name='HtmlLayerContent', description='The information about the HTML5 layer.', example='{"htmlUrl":http://caster.example.com}', position='Query'),
  imageLayerContent?: string(name='ImageLayerContent', description='The information about the image layer. This parameter contains the following fields:

>  This parameter is required when the ComponentType parameter is set to image.

MaterialId: the ID of the asset from the media asset library. The name that you set when you upload an asset is the ID of the asset.

The value is a JSON string. Use upper camel case for field names.', example='{"MaterialId":"6cf724c6ebfd4a59b5b3cec6f10d****"}', position='Query'),
  layerOrder?: string(name='LayerOrder', description='The layer stacking order of the component. Valid values:

*   cover
*   background', example='cover', position='Query'),
  locationId: string(name='LocationId', description='The location ID of the component. Each location ID can be assigned to only one component and must be in the RC[Number] format. The values specified by this parameter must be in ascending order, such as RC01 to RC99.

>  If the ComponentType parameter is set to caption, the LocationId parameter specifies the location ID of the video source referenced by the component.

This parameter is required.', example='RC01', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  textLayerContent?: string(name='TextLayerContent', description='The information about the text layer. This parameter contains the following fields:

>  This parameter is available and required only when the ComponentType parameter is set to text.

*   **SizeNormalized**: the normalized font size. The font size is set to font_size/output_height. The value range is `[0,1]`. If the font size calculated by the system based on the normalization method is greater than 1024, 1024 is used.
*   **BorderWidthNormalized**: the normalized value of the text border width. The normalized value is calculated based on the size of the text, that is, "BorderWidth/FontSize". The value range is `[0,1]`. If the value calculated based on the normalization method exceeds 16, 16 is used. The default value is 0.
*   **FontName**: the font name. For more information about the value, see **Font description**. The default value is KaiTi.
*   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is not set. In this case, the color of the text border is transparent.
*   **Text**: the content of the text. By default, this parameter is not set. In this case, the text contains no content.
*   **Color**: the color of the text. The default value is 0xff0000, which indicates that the text is in red.

The value is a JSON string. Use upper camel case for field names.', example='{"BorderWidthNormalized":"1","SizeNormalized":"0.2","Color":"0x000000","FontName":"KaiTi","BorderColor":"0x000000","Text":"hello world!"}', position='Query'),
}

model AddCasterComponentResponseBody = {
  componentId?: string(name='ComponentId', description='The component ID. The value can be used as the value of a request parameter to query, modify, or delete a production studio.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddCasterComponentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterComponentResponseBody(name='body'),
}

/**
  * @description Before you call this operation to add a component to a production studio, you must first create the production studio and learn about the production studio layouts. You can call this operation to add three types of components: image, text, and subtitle. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddCasterComponent  AddCasterComponentRequest
  * @return AddCasterComponentResponse
 */
async function addCasterComponent(request: AddCasterComponentRequest): AddCasterComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterComponent', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterEpisodeRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  componentId?: [ string ](name='ComponentId', description='The components. Components in the production studio are listed from the bottom to the top in an array.

If a component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the component ID.

*   This parameter takes effect and is required when the EpisodeType parameter is set to **Component**.
*   This parameter is optional when the EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.

>  The variable N specifies the sequence number of the component. For example, **ComponentId.1** specifies the ID of the first component and **ComponentId.2** specifies the ID of the second component.', example='["a2b8e671-2fe5-4642-a2ec-bf93880e****"]', position='Query'),
  endTime: string(name='EndTime', description='The time when the episode ends. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2016-06-29T09:10:00Z', position='Query'),
  episodeName?: string(name='EpisodeName', description='The name of the episode.', example='episode_1', position='Query'),
  episodeType: string(name='EpisodeType', description='The type of the episode. Valid values:

*   **Resource**: a video resource.
*   **Component**: a component.

This parameter is required.', example='Resource', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the video resource.

>  This parameter takes effect and is required when the EpisodeType parameter is set to Resource.

\\
If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html) operation, check the value of the response parameter ResourceId to obtain the ID.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  startTime: string(name='StartTime', description='The time when the episode starts. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2016-06-29T08:00:00Z', position='Query'),
  switchType: string(name='SwitchType', description='The policy for switching episodes. Valid values:

*   **TimeFirst**: The episode starts when the preceding episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops.
*   **ContentFirst**: The episode starts and ends as scheduled.

This parameter takes effect only when the EpisodeType parameter is set to Resource.

>  This parameter must be set to TimeFirst when the video resource is a live stream.

This parameter is required.', example='TimeFirst', position='Query'),
}

model AddCasterEpisodeResponseBody = {
  episodeId?: string(name='EpisodeId', description='The ID of the episode. You can use the ID as a request parameter in the API operation that is used to query the information about the episode list, modify the configurations of the episode, and delete the episode.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCasterEpisodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterEpisodeResponseBody(name='body'),
}

/**
  * @description To call this operation, you must obtain the production studio ID in advance. The production studio ID is generated after the production studio is created.
  * *   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
  * *   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.
  * >  You can find the ID of the production studio in the Instance ID/Name column.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddCasterEpisode  AddCasterEpisodeRequest
  * @return AddCasterEpisodeResponse
 */
async function addCasterEpisode(request: AddCasterEpisodeRequest): AddCasterEpisodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterEpisode', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterEpisodeGroupRequest {
  callbackUrl: string(name='CallbackUrl', description='The callback URL.

If you query the configurations of the production studio by calling the [DescribeCasterConfig](https://help.aliyun.com/document_detail/2848011.html) operation, check the value of the response parameter CallbackUrl to obtain the URL.

This parameter is required.', example='http://developer.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-53f0758162964516ac850f2ddc3f****', position='Query'),
  clientToken: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='8751ad99-2ddb-4aac-ad44-84b21102****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  item: [ 
    {
      itemName?: string(name='ItemName', description='The name of the episode.', example='episode1'),
      vodUrl?: string(name='VodUrl', description='The URL of the VOD file.

If you query the input sources of the production studio by calling the [DescribeCasterVideoResources](https://help.aliyun.com/document_detail/2848023.html) operation, check the value of the response parameter VodUrl to obtain the URL.

>  This parameter takes effect only when the input source is a video file that is not from the media library.\\
The video file can be in the MP4, FLV, or TS format.', example='http://learn.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****.flv?auth_key=1608953344-0-0-53f0758162964516ac850f2ddc3f****'),
    }
  ](name='Item', description='The list of episodes.

This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatNum: int32(name='RepeatNum', description='The number of times the episode list repeats after the first playback is complete. Valid values:

*   **0**: indicates that the episode list is played only once.
*   **-1**: indicates that the episode list is played in loop mode.

This parameter is required.', example='0', position='Query'),
  sideOutputUrl: string(name='SideOutputUrl', description='The custom standby URL.

If this parameter is empty, the ingest address corresponding to the output address automatically generated by Alibaba Cloud will be used by default.

This parameter is required.', example='rtmp://guide.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-53f0758162964516ac850f2ddc3f****', position='Query'),
  startTime: string(name='StartTime', description='The time when the episode list starts to play. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2018-03-06T19:00:00Z', position='Query'),
}

model AddCasterEpisodeGroupResponseBody = {
  itemIds?: {
    itemId?: [ string ](name='ItemId')
  }(name='ItemIds', description='The IDs of the episodes.'),
  programId?: string(name='ProgramId', description='The ID of the episode list that was added. Record the ID as it can be used to manage the program being added.', example='16A96B9A-F203-4EC5-8E43-CB92E68X****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCasterEpisodeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterEpisodeGroupResponseBody(name='body'),
}

/**
  * @description You need to create a production studio and obtain the production studio configurations before you call this operation to create an episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddCasterEpisodeGroup  AddCasterEpisodeGroupRequest
  * @return AddCasterEpisodeGroupResponse
 */
async function addCasterEpisodeGroup(request: AddCasterEpisodeGroupRequest): AddCasterEpisodeGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterEpisodeGroup', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterEpisodeGroupContentRequest {
  clientToken: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='8751ad99-2ddb-4aac-ad44-84b21102****', position='Query'),
  content: string(name='Content', description='The information about the episode list. The value is a JSON string. Use upper camel case for fields of the string. This parameter contains the following fields:

*   **CallbackUrl**: the callback URL.

*   **SideOutputUrl**: the custom standby URL.

*   **RepeatNum**: the number of times the episode list repeats after the first playback is complete. A value of 0 indicates that the episode list is played only once. A value of -1 indicates that the episode list is played in loop mode.

*   **DomainName**: the domain name.

*   **StartTime**: the time when the episode list starts to play. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   **Items**: the information about the episode list. It is an array of ItemName and VodUrl.

    *   **ItemName**: the name of the episode.
    *   **VodUrl**: the URL of the VOD file. This field takes effect only when the video resource is a video file that is not from the media library. The video file must be in the MP4, FLV, or TS format.

This parameter is required.', example='CallbackUrl', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddCasterEpisodeGroupContentResponseBody = {
  itemIds?: {
    itemId?: [ string ](name='ItemId')
  }(name='ItemIds', description='The IDs of the episodes.'),
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to create or add episodes, remove episodes, query episodes, edit an episode list, delete an episode list, query the information about an episode list, start playing an episode list, or stop playing an episode list.', example='16A96B9A-F203-4EC5-8E43-CB92E68X****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCasterEpisodeGroupContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterEpisodeGroupContentResponseBody(name='body'),
}

/**
  * @description You need to create a production studio and add an episode list to the production studio before you call this operation to add information about the episode list in the production studio. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddCasterEpisodeGroupContent  AddCasterEpisodeGroupContentRequest
  * @return AddCasterEpisodeGroupContentResponse
 */
async function addCasterEpisodeGroupContent(request: AddCasterEpisodeGroupContentRequest): AddCasterEpisodeGroupContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterEpisodeGroupContent', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterLayoutRequest {
  audioLayer: [ 
    {
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of audio layer N. You can use this parameter to synchronize the audio with subtitles. Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.', example='5000'),
      validChannel?: string(name='ValidChannel', description='The valid voice channels of audio layer N. Valid values:

*   **leftChannel**: the left channel.
*   **rightChannel**: the right channel.
*   **all**: both the left and right channels. This is the default value.', example='all'),
      volumeRate?: float(name='VolumeRate', description='The multiples of the original volume at which audio layer N plays audio streams. Valid values: **0 to 10.0**.

*   The default value **1.0** indicates that audio layer N plays audio streams at the original volume.
*   A value smaller than **1.0** indicates that audio layer N plays audio streams at a lower volume than the original one.
*   A value greater than **1.0** indicates that audio layer N plays audio streams at a higher volume than the original one.', example='1.0'),
    }
  ](name='AudioLayer', description='Audio layout.

This parameter is required.', position='Query'),
  blendList: [ string ](name='BlendList', description='The element represents the location ID of the video resource, i.e., LocationId. Refer to [Adding Video Source](https://help.aliyun.com/document_detail/60250.html) for LocationId, which corresponds in order with the VideoLayers elements.

This parameter is required.', example='RV01', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.

If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:

Production Studios > Production Studio Management

>  The CasterId is reflected in the Name column on the Production Studio Management page.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  mixList: [ string ](name='MixList', description='The element represents the location ID of the audio resource, i.e., LocationId.
LocationId is referred to in [Adding Video Source](https://help.aliyun.com/document_detail/60250.html), and corresponds in order with the AudioLayers elements.

This parameter is required.', example='RV01', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  videoLayer: [ 
    {
      fillMode?: string(name='FillMode', description='The scaling mode of video layer N. Valid values:

*   **none**: The image is not scaled to fill in the specified layout section. Set video layer N based on the image size of the video resource. This is the default value.
*   **fit**: The image is scaled with the original aspect ratio to fill in the specified layout section. Set video layer N based on the section size. The image is centered in the layout section with the long side of the image equaling that of the section. If the aspect ratio of the image is inconsistent with that of the section, the short side of the image may be shorter than that of the section. The area outside the image displays the next video layer or the background if no next video layer exists. By default, the background color is black.', example='fit'),
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of video layer N. You can use this parameter to synchronize the video with subtitles. Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.', example='5000'),
      heightNormalized?: float(name='HeightNormalized', description='The normalized value of the height of the image of video layer N.

*   If the FillMode parameter of video layer N is set to none, the width of the video image is scaled based on this parameter. The default value is **0**, which indicates that the video image is displayed in the original size.
*   If the FillMode parameter of video layer N is set to fit, you must set this parameter to a value greater than **0**. In this case, the video image is scaled with the original aspect ratio to fill in the specified layout section based on this parameter.', example='1'),
      positionNormalized?: [ float ](name='PositionNormalized', description='The normalized value of the `[x,y]` coordinates of video layer N in the production studio. The default coordinates are `[0,0]`.

>  The coordinates indicate the location of video layer N in the production studio. Set this parameter to the normalized value of the coordinates.', example='0.3'),
      positionRefer?: string(name='PositionRefer', description='The reference coordinates of video layer N in the production studio. Valid values:

*   **topLeft**: the upper-left corner. This is the default value.
*   **topRight**: the upper-right corner.
*   **bottomLeft**: the lower-left corner.
*   **bottomRight**: the lower-right corner.
*   **center**: the center position.
*   **topCenter**: the upper center position.
*   **bottomCenter**: the lower center position.
*   **leftCenter**: the left center position.
*   **rightCenter**: the right center position.', example='topLeft'),
      widthNormalized?: float(name='WidthNormalized', description='The normalized value of the width of the image of video layer N.

*   If the FillMode parameter of video layer N is set to none, the height of the video image is scaled based on this parameter. The default value is **0**, which indicates that the video image is displayed in the original size.
*   If the FillMode parameter of video layer N is set to fit, you must set this parameter to a value greater than **0**. In this case, the video image is scaled with the original aspect ratio to fill in the specified layout section based on this parameter.', example='1'),
    }
  ](name='VideoLayer', description='Video layout.

This parameter is required.', position='Query'),
}

model AddCasterLayoutResponseBody = {
  layoutId?: string(name='LayoutId', description='The ID of the layout.

Record the ID as it can be used to manage the layout being created.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCasterLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterLayoutResponseBody(name='body'),
}

/**
  * @description First, create a director desk and add video resources to the director desk, then call this interface to add the director desk layout. To create a director desk using the API, refer to [Create Director Desk](https://help.aliyun.com/document_detail/69338.html).
  * ## QPS Limitation 
  * The per-user QPS limit for this interface is 10 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, see [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddCasterLayout  AddCasterLayoutRequest
  * @return AddCasterLayoutResponse
 */
async function addCasterLayout(request: AddCasterLayoutRequest): AddCasterLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterLayout', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterProgramRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  episode: [ 
    {
      componentId?: [ string ](name='ComponentId', description='The components. Components in the production studio are listed from the bottom to the top in an array.

>  This parameter is required and takes effect when the Episode.N.EpisodeType parameter is set to Component.

This parameter is optional when the Episode.N.EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.', example='[ "a2b8e671-2fe5-4642-a2ec-bf931826****",  "a2b8e671-2fe5-4642-a2ec-28374657****"]'),
      endTime?: string(name='EndTime', description='The end time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T10:02:00Z'),
      episodeName?: string(name='EpisodeName', description='The name of the episode.', example='program_name_1'),
      episodeType?: string(name='EpisodeType', description='The type of the episode.

*   **Resource**: a video resource If you set this parameter to Resource, you must specify the Episode.N.ResourceId and Episode.N.SwitchType parameters.
*   **Component**: a component If you set this parameter to Component, you must specify the Episode.N.ComponentId.N parameter.', example='Resource'),
      resourceId?: string(name='ResourceId', description='The ID of the video resource.

>  This parameter takes effect and is required when the Episode.N.EpisodeType parameter is set to Resource.

\\
This parameter is invalid if you set the Episode.N.EpisodeType parameter to **Component**.

If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/60250.html) operation, check the value of the response parameter ResourceId to obtain the ID.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
      startTime?: string(name='StartTime', description='The start time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T09:00:00Z'),
      switchType?: string(name='SwitchType', description='The policy for switching episodes. Valid values:

>  This parameter takes effect only when the Episode.N.EpisodeType parameter is set to Resource.

*   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
*   **ContentFirst**: The episode starts and ends as scheduled.', example='TimeFirst'),
    }
  ](name='Episode', description='The information about episodes in the episode list.

This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddCasterProgramResponseBody = {
  episodeIds?: {
    episodeId?: [ 
    {
      episodeId?: string(name='EpisodeId', description='The ID of the episode. You can use the ID as a request parameter in the API operation that is used to modify the episode list, query the information about the episode list, delete the episode, or modify the configurations of the episode.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
    }
  ](name='EpisodeId')
  }(name='EpisodeIds', description='The IDs of the episodes. The episode IDs are listed in the same order as specified by the variable N.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCasterProgramResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterProgramResponseBody(name='body'),
}

/**
  * @description Create a production studio, add input sources to the production studio, and then call this operation to add the episode list for carousel playback in the production studio. This operation supports videos and components as episodes. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddCasterProgram  AddCasterProgramRequest
  * @return AddCasterProgramResponse
 */
async function addCasterProgram(request: AddCasterProgramRequest): AddCasterProgramResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterProgram', 'POST', '/', 'json', false, 'json', request);
}

model AddCasterVideoResourceRequest {
  beginOffset?: int32(name='BeginOffset', description='The offset of the position where the system starts to read the video source. Unit: milliseconds.

**

**Important** This parameter takes effect only if the video source is a file.

> A value greater than **0** specifies an offset from the first frame.', example='1000', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

> You can find the ID of the production studio in the Instance Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  endOffset?: int32(name='EndOffset', description='The offset of the position where the system stops reading the video source. Unit: milliseconds.

**

**Important** This parameter takes effect only if the video source is a file.

*   A value greater than **0** specifies an offset from the first frame.
*   A value less than **0** specifies an offset from the last frame.', example='10000', position='Query'),
  fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles. Unit: milliseconds. Default value: 0. Valid values: `0 to 5000`.', example='0', position='Query'),
  imageId?: string(name='ImageId', description='ID of the media library image material. 
>This parameter is only available and must be provided when the video source type is an image.', example='a089175eb5f4427684fc0715159a****', position='Query'),
  imageUrl?: string(name='ImageUrl', description='Image material URL. 
>This parameter is available only when the video source type is an image and the image file has not been imported into the material library. Supports uploading images in jpg, png formats, with a maximum file size of 10MB.', example='http://learn.aliyundoc.com/AppName/image.jpg', position='Query'),
  liveStreamUrl?: string(name='LiveStreamUrl', description='The streaming URL.

**

**Important** This parameter is required if the video source is a live stream.

> Do not specify this parameter in the request if the video source is not a live stream.', example='rtmp://guide.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-ac8c628078541d7055a170ec59a5****', position='Query'),
  locationId?: string(name='LocationId', description='The ID that is used to identify the position of the video source.

Define the reference numbers in the layout. Each reference number is associated with only one resource. The value of this parameter must be in the RV[Number] format, where Number is `01 to 99`.', example='RV01', position='Query'),
  materialId?: string(name='MaterialId', description='The ID of the material from the media library.

**

**Important** This parameter takes effect and is required only if the video source is a material.

If you query the configurations of the production studio by calling the [DescribeCasterConfig](https://help.aliyun.com/document_detail/60259.html) operation, obtain the value of the response parameter UrgentMaterialId.

> The value of the UrgentMaterialId parameter is the ID of the material from the media library.', example='f080575eb5f4427684fc0715159a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ptsCallbackInterval?: int32(name='PtsCallbackInterval', description='The interval between presentation timestamp (PTS) callbacks. Unit: milliseconds.', example='2000', minimum=0, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatNum?: int32(name='RepeatNum', description='The number of playbacks after the first playback is complete. Valid values:

**

**Important** This parameter takes effect only if the video source is a file.

*   **0**: specifies that the video source is played only once. This is the default value.
*   **-1**: specifies that the video source is played in loop mode.', example='0', minimum=-1, maximum=60, position='Query'),
  resourceName: string(name='ResourceName', description='The name of the video source.

This parameter is required.', example='test001', position='Query'),
  vodUrl?: string(name='VodUrl', description='The URL of the VOD file.

**

**Important** This parameter takes effect only if the video source is a file that is not from the media library.

> The VOD file must be in the MP4, FLV, or TS format.', example='http://learn.aliyundoc.com/AppName/StreamName.flv', position='Query'),
}

model AddCasterVideoResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
  resourceId?: string(name='ResourceId', description='The ID of the resource. This parameter can be used as a request parameter in the API operation that you can call to delete the video source in the production studio or modify the video source in the production studio.', example='e5542d98-b08c-46bf-83e9-5b09d08c****'),
}

model AddCasterVideoResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCasterVideoResourceResponseBody(name='body'),
}

/**
  * @description ##
  * Create a production studio, and then call this operation to add a video source to the production studio. The number of video sources is limited by the number of input channels of the production studio. For information about how to create a production studio by calling an API operation, see [CreateCaster](https://help.aliyun.com/document_detail/69338.html).
  * ## QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddCasterVideoResource  AddCasterVideoResourceRequest
  * @return AddCasterVideoResourceResponse
 */
async function addCasterVideoResource(request: AddCasterVideoResourceRequest): AddCasterVideoResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCasterVideoResource', 'POST', '/', 'json', false, 'json', request);
}

model AddCustomLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  audioBitrate?: int32(name='AudioBitrate', description='The bitrate of the output audio. Unit: Kbit/s. Valid values: **1 to 1000**.', example='512', position='Query'),
  audioChannelNum?: int32(name='AudioChannelNum', description='The number of sound channels. Valid values:

*   **1**: mono.
*   **2**: binaural.', example='2', position='Query'),
  audioCodec?: string(name='AudioCodec', description='The audio encoding format. Valid values:

*   **AAC**
*   **MP3**', example='AAC', position='Query'),
  audioProfile?: string(name='AudioProfile', description='The audio encoding profile. Valid values:

*   **aac_low**
*   **aac_he**
*   **aac_he_v2**
*   **aac_ld**', example='aac_low', position='Query'),
  audioRate?: int32(name='AudioRate', description='The audio sampling rate. Valid values: **22050 to 96000**.


>Notice: If you set AudioProfile to **aac_ld**, the audio sampling rate cannot exceed 44100.', example='96000', position='Query'),
  bitrateWithSource?: string(name='BitrateWithSource', description='The source-based bitrate settings. This parameter takes precedence over other bitrate settings. The following fields must be included:

*   **UpLimit**: the maximum bitrate limit. Valid values: an integer from 128 to 10000. The value must be greater than the minimum bitrate.
*   **LowerLimit int** : the minimum bitrate rate. Valid values: an integer from 128 to 10000. The value must be smaller than the maximum bitrate.
*   **Factor**: The ratio of the output bitrate to the source bitrate. Valid values: 0.1 to 1. The value is accurate to one decimal place. A value of 1 indicates that the output video has the same bitrate as the source video.', example='{"UpLimit":2500,"LowerLimit":800,"Factor":1}', position='Query'),
  deInterlaced?: boolean(name='DeInterlaced', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  encryptParameters?: string(name='EncryptParameters', description='Encryption configuration. In JSON format, the fields are explained as follows:
- **EncryptType**: Encryption type. Fixed value is aliyun.
- **KmsKeyID**: User KMS master key ID.
- **KmsKeyExpireInterval**: Key rotation period. Range: 60~3600, unit: seconds.
> If the EncryptParameters is configured, the KmsKeyID, KmsUID, and KmsKeyExpireInterval parameters cannot be empty', example='{"EncryptType": "aliyun", "KmsKeyID":"afce5722-81d2-43c3-9930-7601da11****","KmsKeyExpireInterval":"3600"}', position='Query'),
  extWithSource?: string(name='ExtWithSource', description='Other source-based settings, including the following fields:

*   **KeyFrameOpen**: specifies whether to use the key frames of the source video. Valid values: yes or no.
*   **Copyts**: specifies whether to use the presentation time stamp (PTS) of the source video. Valid values: yes or no.
*   **SeiMode**: specifies whether to pass through supplemental enhancement information (SEI) messages. Valid values: 0, 1, and 2, where 0 specifies that no SEI messages are passed through, 1 specifies that part of SEI messages are passed through, and 2 specifies that all SEI messages are passed through.', example='{"KeyFrameOpen":"yes","Copyts":"yes","SeiMode":1}', position='Query'),
  FPS?: int32(name='FPS', description='The frame rate of the output video. Unit: frames per second (FPS). Valid values: **1 to 60**.', example='30', position='Query'),
  fpsWithSource?: string(name='FpsWithSource', description='The source-based frame rate settings. This parameter takes precedence over other frame rate settings. The following fields must be included:

*   **UpLimit**: the maximum frame rate. Valid values: an integer from 1 to 60. The value must be greater than the minimum frame rate.
*   **LowerLimit**: the minimum frame rate. Valid values: an integer from 1 to 60. The value must be smaller than the maximum frame rate.', example='{"UpLimit":60,"LowerLimit":1}', position='Query'),
  gop?: string(name='Gop', description='The Group of Picture (GOP) size of the video. Unit: frames or seconds.

*   Unit: frames. Valid values: **1 to 3000**.
*   Unit: seconds. Valid value: **1 to 20**.', example='1', position='Query'),
  height?: int32(name='Height', description='The height of the output video. Unit: pixel. Valid values:

The value must comply with all the following rules:

*   **Height ≥ 100**: The height of the video is greater than or equal to 100 pixels.
*   **max(Height,Width) ≤ 2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
*   **min(Height,Width) ≤ 1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.

> The resolution of the output video that is transcoded by using the H.265 Narrowband HD™ transcoding template cannot exceed 1280 × 720 pixels.', example='720', position='Query'),
  kmsKeyExpireInterval?: string(name='KmsKeyExpireInterval', description='The rotation period of the CMK. Valid values: 60 to 3600. Unit: seconds.', example='3600', position='Query'),
  kmsKeyID?: string(name='KmsKeyID', description='The ID of the customer master key (CMK) that you created in Key Management Service (KMS).', example='afce5722-81d2-43c3-9930-7601da11****', position='Query'),
  kmsUID?: string(name='KmsUID', description='The ID of your KMS account.', example='25346073170691****', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to use the load-on-demand mechanism for transcoding. Valid values: yes and no. Default value: **yes**.', example='yes', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  profile?: int32(name='Profile', description='The video encoding profile. The profile defines a set of parameters that are used to encode a video. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values:

*   **1**: baseline. This value is suitable for mobile devices.
*   **2**: main. This value is suitable for standard-definition devices.
*   **3**: high. This value is suitable for high-definition devices.', example='2', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resWithSource?: string(name='ResWithSource', description='The source-based resolution settings. This parameter takes precedence over other resolution settings. The following fields must be included:

*   **Type**: You can set this field to short, long, or screen. short specifies that the resolution of the output video is adapted to the shorter side, long specifies that the resolution of the output video is adapted to the longer side, and screen specifies that the output video has an adaptive resolution.

*   **Value**:

    *   Set this field to 360, 480, 540, 720, or 1080 if the Type field is set to short.
    *   Set this field to 640, 848, 960, 1280, or 1920 if the Type field is set to long.
    *   Set this field to 640\\*360, 848\\*480, 960\\*540, 1280\\*720, or 1920\\*1080 if the Type field is set to screen.', example='{"Type":"short","Value":"1080"}', position='Query'),
  template: string(name='Template', description='The name of the custom transcoding template.

> The name can contain digits, letters, and hyphens (-), and must start with a letter or digit. The name must be different from the names of any default transcoding templates.

This parameter is required.', example='LiveCusTranscode****', position='Query'),
  templateType: string(name='TemplateType', description='The type of the custom transcoding template. Valid values:

*   **h264**: custom H.264 standard transcoding.
*   **h264-nbhd**: custom H.264 Narrowband HD™ transcoding.
*   **h265**: custom H.265 standard transcoding.
*   **h265-nbhd**: custom H.265 Narrowband HD™ transcoding.
*   **audio**: audio-only transcoding.

> If you set **TemplateType** to **h264**, **h264-nbhd**, **h265**, or **h265-nbhd**, the **Height**, **Width**, **FPS**, and **VideoBitrate** parameters are required.

This parameter is required.', example='h264', position='Query'),
  videoBitrate?: int32(name='VideoBitrate', description='The bitrate of the output video. Unit: Kbit/s. Valid values: **1 to 6000**.

> The bitrate of the output video may not be the same as the value that you specify, but is as close to the value as possible, especially when the value is excessively large or small.', example='720', position='Query'),
  width?: int32(name='Width', description='The width of the output video. Unit: pixel. Valid values:

The value must comply with all the following rules:

*   **Width ≥ 100**: The width of the video is greater than or equal to 100 pixels.
*   **max(Height,Width) ≤ 2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
*   **min(Height,Width) ≤ 1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.

> The resolution of the output video that is transcoded by using the H.265 Narrowband HD™ transcoding template cannot exceed 1280 × 720 pixels.', example='576', position='Query'),
}

model AddCustomLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddCustomLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddCustomLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description This operation supports the following types of custom transcoding templates:
  * *   h264: H.264
  * *   h264-nbhd: H.264 Narrowband HD™
  * *   h265: H.265
  * *   h265-nbhd: H.265 Narrowband HD™
  * *   audio: audio-only
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddCustomLiveStreamTranscode  AddCustomLiveStreamTranscodeRequest
  * @return AddCustomLiveStreamTranscodeResponse
 */
async function addCustomLiveStreamTranscode(request: AddCustomLiveStreamTranscodeRequest): AddCustomLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddCustomLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAIProduceRulesRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. The name can be up to 256 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name must be the same as the application name in the ingest URL. Otherwise, the rule does not take effect.

This parameter is required.', example='AppName', position='Query'),
  description?: string(name='Description', description='The description of the subtitle rule. The description can be up to 128 characters in length and can contain letters, digits, and special characters.', example='live AI subtitle template', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  isLazy?: boolean(name='IsLazy', description='Specifies whether to trigger the subtitle rule when stream pulling starts. Valid values:

*   true: generates live subtitles when stream pulling starts and stops generating live subtitles when no stream is pulled for 5 minutes. When stream pulling restarts, live subtitles are generated again.
*   false: generates live subtitles when stream ingest starts, regardless of whether stream pulling starts.', example='true', position='Query'),
  liveTemplate: string(name='LiveTemplate', description='The specification of the output subtitles. Valid values:

*   `lp_ld`: landscape low definition 360p (640×360)
*   `lp_ld_v`: portrait low definition 360p (360×640)
*   `lp_sd`: landscape standard definition 480p (854×480)
*   `lp_sd_v`: portrait standard definition 480p (480×854)
*   `lp_hd`: landscape high definition 720p (1280×720)
*   `lp_hd_v`: portrait high definition 720p (720×1280)
*   `lp_ud`: landscape ultra-high definition 1080p (1920×1080)
*   `lp_ud_v`: portrait ultra-high definition 1080p (1080×1920)

This parameter is required.', example='lp_ld', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  studioName?: string(name='StudioName', description='The name of the virtual background template.', example='sub02', position='Query'),
  subtitleName?: string(name='SubtitleName', description='The name of the subtitle template.', example='sub01', position='Query'),
  suffix?: string(name='Suffix', description='The suffix to match.', example='test01', position='Query'),
}

model AddLiveAIProduceRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
  rulesId?: string(name='RulesId', description='The ID of the subtitle rule.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
}

model AddLiveAIProduceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAIProduceRulesResponseBody(name='body'),
}

/**
  * @description *   After you call the [AddLiveAISubtitle](https://help.aliyun.com/document_detail/2848222.html) operation to add a subtitle template, you can call this operation to create a subtitle rule for the template.
  * *   You must add "_Subtitle template name" after the stream name in the streaming URL to play the subtitle stream.
  *     *   RTMP: rtmp://example.aliyundoc.com/app/stream_{Subtitle template name}?auth_key={Access token}
  *     *   FLV: http://example.aliyundoc.com/app/stream_{Subtitle template name}.flv?auth_key={Access token}
  *     *   M3U8: http://example.aliyundoc.com/app/stream_{Subtitle template name}.m3u8?auth_key={Access token}
  * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveAIProduceRules  AddLiveAIProduceRulesRequest
  * @return AddLiveAIProduceRulesResponse
 */
async function addLiveAIProduceRules(request: AddLiveAIProduceRulesRequest): AddLiveAIProduceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAIProduceRules', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAISubtitleRequest {
  bgColor?: string(name='BgColor', description='The background color of the subtitles, which is an RGBA value.', example='0xFF0000', position='Query'),
  bgWidthNormalized?: float(name='BgWidthNormalized', description='The background size of the subtitles. Valid values: [0,1].', example='0.09', position='Query'),
  borderWidthNormalized?: float(name='BorderWidthNormalized', description='The font weight. Valid values: [0,1].', example='0.05', position='Query'),
  copyFrom?: string(name='CopyFrom', description='The subtitle template that you copy. Set the value to the name of the subtitle template.', example='sub01', position='Query'),
  description?: string(name='Description', description='The custom description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.', example='live AI subtitle template', position='Query'),
  dstLanguage?: string(name='DstLanguage', description='The target language. Valid values:
 - en-US: English 
- zh-CN: Chinese 
- es-ES: Spanish 
- ru-RU: Russian', example='zh-CN', position='Query'),
  fontColor?: string(name='FontColor', description='The font color, which is an RGBA value.', example='0xFFFFFF', position='Query'),
  fontName?: string(name='FontName', description='The font. Valid values:
- KaiTi (default)
- AlibabaPuHuiTi-Regular
- AlibabaPuHuiTi-Bold
- AlibabaPuHuiTi-Light
- NotoSansHans-Regular
- NotoSansHans-Bold
- NotoSansHans-Light', example='KaiTi', position='Query'),
  fontSizeNormalized: float(name='FontSizeNormalized', description='The font size. Valid values: [0,1].

This parameter is required.', example='0.037', position='Query'),
  height?: string(name='Height', description='The preview height. Unit: pixels.
The following specifications of preview width × preview height are supported: 
- Landscape low definition 360p (640×360) 
- Portrait low definition 360p (360×640)
- Landscape standard definition 480p (854×480)
- Portrait standard definition 480p (480×854)
- Landscape high definition 720p (1280×720)
- Portrait high definition 720p (720×1280)
- Landscape ultra-high definition 1080p (1920×1080)
- Portrait ultra-high definition 1080p (1080×1920)', example='720', position='Query'),
  maxLines?: int32(name='MaxLines', description='The number of displayed lines.', example='2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  positionNormalized: [ float ](name='PositionNormalized', description='The position of the subtitles. The value is a pair of coordinates for which the origin of the x and y axes is the lower-left corner of the screen.

This parameter is required.', shrink='json', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showSourceLan?: boolean(name='ShowSourceLan', description='Specifies whether to display the source language. Default value: false.', example='true', position='Query'),
  srcLanguage: string(name='SrcLanguage', description='The source language. Valid values:
 - en-US: English 
- zh-CN: Chinese 
- ru-RU: Russian

This parameter is required.', example='zh-CN', position='Query'),
  subtitleName: string(name='SubtitleName', description='The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.

This parameter is required.', example='sub01', position='Query'),
  width?: string(name='Width', description='The preview width. Unit: pixels.', example='1280', position='Query'),
  wordPerLine: int32(name='WordPerLine', description='The number of words displayed per line. Valid values: integers from 1 to 500.

This parameter is required.', example='20', position='Query'),
}

model AddLiveAISubtitleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
  subtitleId?: string(name='SubtitleId', description='The ID of the subtitle template.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
}

model AddLiveAISubtitleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAISubtitleResponseBody(name='body'),
}

/**
  * @description ## Instructions
  * - This interface supports adding live caption template configurations, with templates configurable to describe caption content, layout, and more. 
  * - After adding caption templates, you also need to call the [AddLiveAIProduceRules](https://help.aliyun.com/document_detail/2799676.html) interface to add caption rules. Restarting the stream will then enable captions in the broadcast. 
  * - Real-time captions are currently supported in Beijing, Shanghai, Singapore, Indonesia, and Saudi regions.
  * >Notice: The real-time caption feature is currently in beta testing. Each user can add up to 300 caption templates. 
  * ## QPS Limit 
  * The QPS limit for this interface per user is 60 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use judiciously. For more information, refer to [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddLiveAISubtitle  AddLiveAISubtitleRequest
  * @return AddLiveAISubtitleResponse
 */
async function addLiveAISubtitle(request: AddLiveAISubtitleRequest): AddLiveAISubtitleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAISubtitle', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAppRecordConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all applications, specify an asterisk (\\*) as the value.

This parameter is required.', example='liveApp****', position='Query'),
  delayTime?: int32(name='DelayTime', description='Duration for stream concatenation. If the live streaming interruption exceeds the set concatenation duration, a new file will be generated. The concatenation duration can be set between 15 to 21600 seconds.', example='180', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='Recording end time. Format: <i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z (UTC time).
> The difference between EndTime and StartTime should not exceed 7 days; if it does, it will be calculated as 7 days. This is only valid for stream-level recording (when StreamName is not empty).', example='2018-04-16T09:57:21Z', position='Query'),
  onDemand?: int32(name='OnDemand', description='Specifies whether to enable on-demand recording. Valid values:

*   **0**: disables on-demand recording.
*   **1**: enables on-demand recording by using the HTTP callback method.
*   **2**: enables on-demand recording by parsing the stream ingest parameters.
*   **7**: By default, ApsaraVideo Live does not automatically record live streams. You can call the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/2847882.html) operation to manually start or stop recording.

>  If you set the OnDemand parameter to **1**, you need to call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847891.html) operation to configure the OnDemandUrl parameter. Otherwise, ApsaraVideo Live does not perform on-demand recording.', example='1', position='Query'),
  ossBucket: string(name='OssBucket', description='The name of the OSS bucket where live streaming recording files are stored. To store recorded files in OSS, you need to create an OSS bucket in advance. For creation method, please refer to [Configure OSS](https://help.aliyun.com/document_detail/84932.html).

This parameter is required.', example='liveBucket****', position='Query'),
  ossEndpoint: string(name='OssEndpoint', description='The endpoint of the OSS bucket. 
To store live stream recordings in OSS, you need to create an OSS bucket in advance. For more information, see Configure OSS.

This parameter is required.', example='learn.developer.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  recordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration', description='The recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.

> 

*   If a live stream is interrupted during a recording cycle but is resumed within the interruption duration threshold, the stream is recorded in the same recording before and after the interruption.

*   If a live stream is interrupted for longer than the interruption duration threshold, a new recording is generated.', example='1'),
      format?: string(name='Format', description='The recording format. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:

>  You need to specify at lease one of the RecordFormat and TranscodeRecordFormat parameters. If you set this parameter to m3u8 or cmaf, you must also specify the RecordFormat.N.SliceOssObjectPrefix and RecordFormat.N.SliceDuration parameters.

*   m3u8
*   flv
*   mp4
*   cmaf', example='m3u8'),
      ossObjectPrefix?: string(name='OssObjectPrefix', description='The naming format of a recording to store in OSS.

*   The name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
*   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.', example='record/{AppName}/{StreamName}/{Sequence}_{EscapedStartTime}_{EscapedEndTime}'),
      sliceDuration?: int32(name='SliceDuration', description='The duration of a single segment. Unit: seconds.

>  This parameter takes effect only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.

If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.', example='30'),
      sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix', description='The naming format of a segment.

>  This parameter is required only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.

*   By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence} variables.
*   The segment name must contain the {UnixTimestamp} and {Sequence} variables.', example='record/{AppName}/{StreamName}/{UnixTimestamp}_{Sequence}'),
    }
  ](name='RecordFormat', description='The recording details.', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', description='Start time of the recording. Format: <i>yyyy-MM-dd</i>T<i>HH:mm:ss</i>Z (UTC time).
> The set time must be within 7 days of the actual streaming start time, and is only valid for stream-level recording (when StreamName is not empty).', example='2018-04-10T09:57:21Z', position='Query'),
  streamName?: string(name='StreamName', description='Stream broadcast name.', example='teststream', position='Query'),
  transcodeRecordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration', description='The transcoded stream recording cycle. Unit: seconds. If you do not specify this parameter, the default value 6 hours is used.', example='21600'),
      format?: string(name='Format', description='The transcoded stream recording format. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:

>  If you set this parameter to m3u8 or cmaf, you must also specify the TranscodeRecordFormat.N.SliceOssObjectPrefix and TranscodeRecordFormat.N.SliceDuration parameters.

*   m3u8
*   flv
*   mp4
*   cmaf', example='m3u8'),
      ossObjectPrefix?: string(name='OssObjectPrefix', description='The naming format of a transcoded stream recording to store in OSS.

*   The name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {Sequence}, {StartTime}, {EndTime}, {EscapedStartTime}, and {EscapedEndTime} variables.
*   The name must contain the {StartTime} and {EndTime} variables or the {EscapedStartTime} and {EscapedEndTime} variables.', example='record/{AppName}/{StreamName}/{Sequence}_{EscapedStartTime}_{EscapedEndTime}'),
      sliceDuration?: int32(name='SliceDuration', description='The duration of a single segment in a transcoded stream recording. Unit: seconds.

>  This parameter takes effect only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.

If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.', example='30'),
      sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix', description='The naming format of a segment in a transcoded stream recording.

>  This parameter is required only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.

*   By default, the duration of a segment is 30 seconds. The segment name must be less than 256 bytes in length and can contain the {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence} variables.
*   The segment name must contain the {UnixTimestamp} and {Sequence} variables.', example='record/{AppName}/{StreamName}/{UnixTimestamp}_{Sequence}'),
    }
  ](name='TranscodeRecordFormat', description='The transcoded stream recording details.', position='Query'),
  transcodeTemplates?: [ string ](name='TranscodeTemplates', description='Transcoding stream recording template group.', example='sd', position='Query'),
}

model AddLiveAppRecordConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddLiveAppRecordConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAppRecordConfigResponseBody(name='body'),
}

/**
  * @description The live stream recording feature allows you to record a live stream and stores the recordings in a specified location. You can view the recordings whenever you want to. Recordings that are stored in OSS support multiple formats, such as Transport Stream (TS), MP4, Flash Video (FLV), and Common Media Application Format (CMAF). You can use different recording policies, including automatic recording, on-demand recording, and manual recording. By calling this operation, you can configure the recording template. For more information about live stream recording, see [Live stream recording](https://help.aliyun.com/document_detail/199357.html).
  * A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveAppRecordConfig  AddLiveAppRecordConfigRequest
  * @return AddLiveAppRecordConfigResponse
 */
async function addLiveAppRecordConfig(request: AddLiveAppRecordConfigRequest): AddLiveAppRecordConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAppRecordConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAppSnapshotConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.

This parameter is required.', example='liveApp****', position='Query'),
  callback?: string(name='Callback', description='The callback URL that is used to receive notifications about snapshot capture.', example='https://learn.aliyundoc.com', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ossBucket: string(name='OssBucket', description='The name of the OSS bucket.

After the configuration is complete, you can search for specific snapshots in the OSS console based on the callback information. You must create the OSS bucket in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).

This parameter is required.', example='liveBucket****', position='Query'),
  ossEndpoint: string(name='OssEndpoint', description='The endpoint of the OSS bucket.

After the configuration is complete, you can search for specific snapshots in the OSS console based on the callback information. You must configure the OSS endpoint in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).

This parameter is required.', example='cn-oss-****.aliyuncs.com', position='Query'),
  overwriteOssObject?: string(name='OverwriteOssObject', description='The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.

*   The name must be less than 256 bytes in length.
*   Only JPG images are supported.
*   The name can contain variables such as {AppName} and {StreamName}.', example='{AppName}/{StreamName}.jpg', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sequenceOssObject?: string(name='SequenceOssObject', description='The naming format of snapshots that are stored in sequence,

which means that a new snapshot does not overwrite the previous snapshot. You can call the [DescribeLiveStreamSnapshotInfo](https://help.aliyun.com/document_detail/2847902.html) operation to query the snapshots that were captured within a specific time period.

*   The name must be less than 256 bytes in length.
*   Only JPG images are supported.
*   The name can contain variables such as {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence}. The name must contain at least one of the {UnixTimestamp} and {Sequence} variables.', example='snapshot/{AppName}/{StreamName}/{UnixTimestamp}.jpg', position='Query'),
  timeInterval: int32(name='TimeInterval', description='The interval at which snapshots are captured. Unit: seconds. Valid values: **5 to 3600**.

This parameter is required.', example='5', minimum=5, maximum=3600, position='Query'),
}

model AddLiveAppSnapshotConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveAppSnapshotConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAppSnapshotConfigResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream snapshots in ApsaraVideo Live. For more information, see [Billing of live stream snapshots](https://help.aliyun.com/document_detail/195286.html).
  * *   Make sure that Object Storage Service (OSS) is activated and a specific bucket is created. This way, ApsaraVideo Live can store live stream snapshots in the bucket. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).
  * *   If you store snapshots in OSS, storage fees are generated. For more information, see [Storage fees](https://help.aliyun.com/document_detail/173534.html).
  * *   The OSS bucket must reside in the same region as the live center of the streaming domain. Cross-region snapshot capture is not supported.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveAppSnapshotConfig  AddLiveAppSnapshotConfigRequest
  * @return AddLiveAppSnapshotConfigResponse
 */
async function addLiveAppSnapshotConfig(request: AddLiveAppSnapshotConfigRequest): AddLiveAppSnapshotConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAppSnapshotConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAudioAuditConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The application name is case-sensitive.

This parameter is required.', example='liveApp****', position='Query'),
  bizType?: string(name='BizType', description='The business type. You can specify a model. The default value is the domain name.', example='example.edu', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ossBucket?: string(name='OssBucket', description='The name of the OSS bucket in which the recording is stored.', example='liveBucket****', position='Query'),
  ossEndpoint?: string(name='OssEndpoint', description='The endpoint of OSS.', example='cn-oss-****.aliyuncs.com', position='Query'),
  ossObject?: string(name='OssObject', description='The name of the recording stored in OSS.', example='liveObject****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. The stream name is case-sensitive.

This parameter is required.', example='liveStream****', position='Query'),
}

model AddLiveAudioAuditConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model AddLiveAudioAuditConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAudioAuditConfigResponseBody(name='body'),
}

/**
  * @description *   The content moderation feature detects undesirable sensitive content in the audio from live streams and returns callbacks to notify you of the violations. Then, you can manually review the content and take actions accordingly.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveAudioAuditConfig  AddLiveAudioAuditConfigRequest
  * @return AddLiveAudioAuditConfigResponse
 */
async function addLiveAudioAuditConfig(request: AddLiveAudioAuditConfigRequest): AddLiveAudioAuditConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAudioAuditConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveAudioAuditNotifyConfigRequest {
  callback?: string(name='Callback', description='The callback URL. This URL is used to receive callback notifications about violations in audio.', example='https://demo.aliyundoc.com/callback', position='Query'),
  callbackTemplate?: string(name='CallbackTemplate', description='The callback template. Valid values:

*   **{DomainName}**: the streaming domain.
*   **{AppName}**: the name of the application to which the live stream belongs.
*   **{StreamName}**: the name of the live stream.
*   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
*   **{Result}**: the moderation results.', example='{"domain":{DomainName},"app":{AppName},"stream":{StreamName},"timestamp":{Timestamp},"result":{Result}}', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddLiveAudioAuditNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model AddLiveAudioAuditNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveAudioAuditNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   The content moderation feature returns the audio moderation results based on the configured callback template.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveAudioAuditNotifyConfig  AddLiveAudioAuditNotifyConfigRequest
  * @return AddLiveAudioAuditNotifyConfigResponse
 */
async function addLiveAudioAuditNotifyConfig(request: AddLiveAudioAuditNotifyConfigRequest): AddLiveAudioAuditNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveAudioAuditNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveCenterTransferRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='testapp', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  dstUrl: string(name='DstUrl', description='The third-party URL to which the live stream is relayed. You can add only one URL.

>  The protocol that the URL uses must be the same as the protocol of the live stream. Only URLs over RTMP and SRT are supported.

This parameter is required.', example='rtmp://push.example2.aliyunlive.com/testapp1/teststream2', position='Query'),
  endTime?: string(name='EndTime', description='The end time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The start time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-21T10:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='teststream', position='Query'),
  transferArgs: string(name='TransferArgs', description='The validity period of stream relay. Valid values:

*   **always**: The stream can always be relayed.
*   **time**: The stream can be relayed in a specified time period.

>  If you set this parameter to **time**, **StartTime** and **EndTime** are required.

This parameter is required.', example='always', position='Query'),
}

model AddLiveCenterTransferResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7908F2FF-44F8-120F-9FD6-85AE4B6C19EC'),
}

model AddLiveCenterTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveCenterTransferResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveCenterTransfer  AddLiveCenterTransferRequest
  * @return AddLiveCenterTransferResponse
 */
async function addLiveCenterTransfer(request: AddLiveCenterTransferRequest): AddLiveCenterTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveCenterTransfer', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveDetectNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  notifyUrl: string(name='NotifyUrl', description='The callback URL that is used to receive callback notifications about violations, such as pornographic content and politically sensitive content, detected in live streams.

This parameter is required.', example='http://demo.aliyundoc.com/examplecallback.action', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model AddLiveDetectNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveDetectNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveDetectNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   The automated review feature sends notifications about violations to the callback URL in real time. Then, you can manually review the content and take actions accordingly.
  * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of AddLiveDetectNotifyConfig  AddLiveDetectNotifyConfigRequest
  * @return AddLiveDetectNotifyConfigResponse
 */
async function addLiveDetectNotifyConfig(request: AddLiveDetectNotifyConfigRequest): AddLiveDetectNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveDetectNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveDomainRequest {
  checkUrl?: string(name='CheckUrl', description='The URL that is used for health checks.', example='http://demo.aliyundoc.com/status.html', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain or streaming domain that you want to add. Wildcard domain names that start with a period (.) are supported.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  liveDomainType: string(name='LiveDomainType', description='The type of the domain name. Valid values:

*   **liveVideo**: streaming domain. This value is required if you set the DomainName parameter to a streaming domain.
*   **liveEdge**: ingest domain. This value is required if you set the DomainName parameter to an ingest domain.

This parameter is required.', example='liveVideo', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region in which the domain name resides. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-qingdao**: China (Qingdao)
*   **ap-southeast-1**: Singapore
*   **eu-central-1**: Germany (Frankfurt)
*   **ap-northeast-1**: Japan (Tokyo)
*   **ap-southeast-5**: Indonesia (Jakarta)

>  Make sure that the settings of the Region and Scope parameters do not conflict with each other.

This parameter is required.', example='cn-beijing', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).', example='rg-aekzw******', position='Query'),
  scope?: string(name='Scope', description='The edge group. This parameter is applicable to users of level 3 or higher in mainland China and users outside mainland China. Valid values:

*   **domestic**: mainland China. This is the default value.
*   **overseas**: outside mainland China.
*   **global**: regions in and outside mainland China.', example='domestic', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag', description='The tags.', position='Query'),
  topLevelDomain?: string(name='TopLevelDomain', description='The top-level domain name.', example='learn.aliyundoc.com', position='Query'),
}

model AddLiveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveDomainResponseBody(name='body'),
}

/**
  * @description *   You must activate ApsaraVideo Live before you add a domain name. For more information, see [Activate ApsaraVideo Live](https://help.aliyun.com/document_detail/195292.html).
  * *   ApsaraVideo Live verifies the ownership of a new domain name that you add. After the verification is passed, the domain name is added to ApsaraVideo Live. ApsaraVideo Live allows you to use a Domain Name System (DNS) record or a verification file to verify the ownership of a domain name. For more information, see [Verify the ownership of a domain name](https://help.aliyun.com/document_detail/184466.html).
  * *   To use ApsaraVideo Live to ingest and play streams, you must add an ingest domain and a streaming domain. You can add only one domain name at a time.
  * *   After you add a domain name, you must configure a CNAME record for the domain name. For more information, see [Add a CNAME record](https://help.aliyun.com/document_detail/84929.html).
  * *   After you add an ingest domain and a streaming domain, you must associate the streaming domain with the ingest domain. For more information, see [Associate a streaming domain with an ingest domain](https://help.aliyun.com/document_detail/199338.html).
  * >  From February 19, 2019, domain names that are added by calling the AddLiveDomain operation do not support live center ingest. Domain names that are added by using Alibaba Cloud CDN also do not support live center ingest. When you call the AddLiveDomain operation, you can set the LiveDomainType parameter to liveEdge to add an ingest domain that uses edge ingest or set the LiveDomainType parameter to liveVideo to add a streaming domain. You can associate a streaming domain with an ingest domain by calling the AddLiveDomainMapping operation. Domain names added before February 19, 2019, for which live center ingest was configured, are not affected.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveDomain  AddLiveDomainRequest
  * @return AddLiveDomainResponse
 */
async function addLiveDomain(request: AddLiveDomainRequest): AddLiveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveDomain', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveDomainMappingRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pullDomain: string(name='PullDomain', description='The streaming domain. The type of the domain name is **liveVideo**.

This parameter is required.', example='example.com', position='Query'),
  pushDomain: string(name='PushDomain', description='The ingest domain. The type of the domain name is **liveEdge**.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model AddLiveDomainMappingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveDomainMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveDomainMappingResponseBody(name='body'),
}

/**
  * @description Call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a streaming domain and an ingest domain, and then call this operation to create the mapping between the two domain names.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddLiveDomainMapping  AddLiveDomainMappingRequest
  * @return AddLiveDomainMappingResponse
 */
async function addLiveDomainMapping(request: AddLiveDomainMappingRequest): AddLiveDomainMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveDomainMapping', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveDomainPlayMappingRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  playDomain: string(name='PlayDomain', description='The sub-streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  pullDomain: string(name='PullDomain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddLiveDomainPlayMappingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveDomainPlayMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveDomainPlayMappingResponseBody(name='body'),
}

/**
  * @description You can call the [AddLiveDomain](https://help.aliyun.com/document_detail/88327.html) operation to add a main streaming domain and a sub-streaming domain and then call this operation to map the sub-streaming domain to the main streaming domain.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveDomainPlayMapping  AddLiveDomainPlayMappingRequest
  * @return AddLiveDomainPlayMappingResponse
 */
async function addLiveDomainPlayMapping(request: AddLiveDomainPlayMappingRequest): AddLiveDomainPlayMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveDomainPlayMapping', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveMessageGroupBandRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  bannedUsers: [ string ](name='BannedUsers', description='The users whom you want to mute.

This parameter is required.', shrink='simple', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.

>  Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
}

model AddLiveMessageGroupBandResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model AddLiveMessageGroupBandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveMessageGroupBandResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveMessageGroupBand  AddLiveMessageGroupBandRequest
  * @return AddLiveMessageGroupBandResponse
 */
async function addLiveMessageGroupBand(request: AddLiveMessageGroupBandRequest): AddLiveMessageGroupBandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveMessageGroupBand', 'POST', '/', 'json', false, 'json', request);
}

model AddLivePackageConfigRequest {
  appName: string(name='AppName', description='The application name. The value of this parameter must be the same as the application name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.

This parameter is required.', example='AppName', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ignoreTranscode?: boolean(name='IgnoreTranscode', description='Specifies whether to ignore the transcoded stream. Valid values:

*   **true** (default)
*   **false**', example='true', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  partDuration?: int32(name='PartDuration', description='The part length. Unit: milliseconds.

*   If the value of SegmentDuration is 1, the valid values of this parameter are 100 to 500 and the default value of this parameter is 350.
*   If the value of SegmentDuration is 2, the valid values of this parameter are 100 to 1000 and the default value of this parameter is 700.
*   This parameter takes effect only if Protocol is set to LLHLS_TS or LLHLS_CMAF.', example='350', position='Query'),
  protocol: string(name='Protocol', description='The streaming protocol and encapsulation format. Valid values:

*   **HLS_CMAF**
*   **LLHLS_TS** (low latency)
*   **LLHLS_CMAF** (low latency)
*   **DASH_CMAF**
*   **HLSDASH_CMAF**

This parameter is required.', example='HLS_CMAF', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  segmentDuration?: int32(name='SegmentDuration', description='The segment length. Unit: seconds.

*   If Protocol is set to HLS_CMAF: Valid values: 1 to 10. Default value: 5.
*   If Protocol is set to LLHLS_TS or LLHLS_CMAF: Valid values: 1 to 2. Default value: 1.', example='5', position='Query'),
  segmentNum?: int32(name='SegmentNum', description='The number of segments.

*   Valid values: 3 to 10.
*   Default value: 3.', example='3', position='Query'),
  streamName: string(name='StreamName', description='The stream name. The value of this parameter must be the same as the stream name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all streams.

This parameter is required.', example='StreamName', position='Query'),
}

model AddLivePackageConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='05D00B48-DF50-5DC0-A07D-A250DFAE****'),
}

model AddLivePackageConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLivePackageConfigResponseBody(name='body'),
}

/**
  * @description *   The first time you configure encapsulation for a domain name, domain acceleration is automatically configured and takes effect in 3 to 5 minutes.
  * *   If the streaming domain resides in a region outside China, including Singapore, Germany (Frankfurt), Japan (Tokyo), and Indonesia (Jakarta), you may encounter high latency issues. We recommend that you test and verify whether the settings meet expectations.
  * *   You can call this operation to add a live stream encapsulation configuration. The configuration takes effect only after you re-ingest the stream.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLivePackageConfig  AddLivePackageConfigRequest
  * @return AddLivePackageConfigResponse
 */
async function addLivePackageConfig(request: AddLivePackageConfigRequest): AddLivePackageConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLivePackageConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLivePullStreamInfoConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. This parameter is determined by you.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The domain name used for stream pulling. It is the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The time when stream pulling ends.

The time range specified by the StartTime and EndTime parameters cannot exceed seven days. The time specified by the EndTime parameter must be later than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sourceUrl: string(name='SourceUrl', description='The origin URL of the live stream. You can specify multiple URLs. Separate them with semicolons (;).

>  You can pull only live streams in the Real-Time Messaging Protocol (RTMP), Flash Video (FLV), HTTP Live Streaming (HLS), and Secure Reliable Transport (SRT) formats.

This parameter is required.', position='Query'),
  startTime: string(name='StartTime', description='The time when stream pulling starts.

The time range specified by the StartTime and EndTime parameters cannot exceed seven days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. This parameter is determined by you.

This parameter is required.', example='liveStream****', position='Query'),
}

model AddLivePullStreamInfoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CF8'),
}

model AddLivePullStreamInfoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLivePullStreamInfoConfigResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of stream pulling in ApsaraVideo Live. For more information, see [Billing of standard streaming](https://help.aliyun.com/document_detail/195284.html).
  * *   Stream pulling refers to the process of pulling live streams from third-party streaming URLs to a live center of ApsaraVideo Live for CDN acceleration.
  * *   You can call this operation only for regular stream pulling. That is, you can specify the start time and end time to pull live streams.
  * *   Regular stream pulling and triggered stream pulling are supported in the ApsaraVideo Live console. For more information, see [Configure stream pulling](https://help.aliyun.com/document_detail/199452.html).
  * *   You can specify custom values for the AppName and StreamName parameters. Streaming URLs that are generated vary based on different values of the AppName and StreamName parameters. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a streaming URL.
  * *   A configuration is identified by the DomainName, AppName, and StreamName parameters all together. If you try to call this operation to add a configuration that has the same DomainName, AppName, and StreamName parameters as an existing configuration, an error indicating that the configuration already exists is returned.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLivePullStreamInfoConfig  AddLivePullStreamInfoConfigRequest
  * @return AddLivePullStreamInfoConfigResponse
 */
async function addLivePullStreamInfoConfig(request: AddLivePullStreamInfoConfigRequest): AddLivePullStreamInfoConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLivePullStreamInfoConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveRecordNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  needStatusNotify?: boolean(name='NeedStatusNotify', description='Specifies whether to enable callbacks for recording status. Valid values:

*   true: enables callbacks for recording status. If you set this parameter to **true**, an example of recording status callback is returned.
*   false (default): disables callbacks for recording status.', example='false', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', minLength=16, maxLength=64, position='Query'),
  notifyReqAuth?: boolean(name='NotifyReqAuth', position='Query'),
  notifyUrl: string(name='NotifyUrl', description='The callback URL that is used to receive notifications about recording events and status.

>  The URL must start with `http://` or `https://`. For more information, see [Callbacks for live stream recording](https://help.aliyun.com/document_detail/55016.html).

This parameter is required.', example='http://demo.aliyundoc.com/examplecallback.action', position='Query'),
  onDemandUrl?: string(name='OnDemandUrl', description='The callback URL for on-demand recordings.

>  The URL must start with `http://` or `https://`. For more information, see [On-demand recording](https://help.aliyun.com/document_detail/85910.html).', example='http://learn.aliyundoc.com/ondemandcallback.action', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model AddLiveRecordNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveRecordNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveRecordNotifyConfigResponseBody(name='body'),
}

/**
  * @description Before you call this operation to configure recording callbacks for a domain name, you can query whether the domain name already has recording callbacks configured. For more information, see [DescribeLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847893.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveRecordNotifyConfig  AddLiveRecordNotifyConfigRequest
  * @return AddLiveRecordNotifyConfigResponse
 */
async function addLiveRecordNotifyConfig(request: AddLiveRecordNotifyConfigRequest): AddLiveRecordNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveRecordNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveRecordVodConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='testName', position='Query'),
  autoCompose?: string(name='AutoCompose', description='Specifies whether to enable automatic merging. If you set the value to **ON**, automatic merging is enabled and the ComposeVodTranscodeGroupId parameter is required. If you do not specify this parameter, automatic merging is disabled.

>  If you enable automatic merging, the VOD files that are created from live streams are automatically merged by using the editing and production feature of ApsaraVideo VOD. For information about the billing of the feature, see [Billing of value-added services](https://help.aliyun.com/document_detail/188310.html).', example='ON', position='Query'),
  composeVodTranscodeGroupId?: string(name='ComposeVodTranscodeGroupId', description='The ID of the transcoding template group in ApsaraVideo VOD that is used to transcode the video file. The video file is generated by merging the VOD files created from live streams.

> 

*   This parameter is required if you set the AutoCompose parameter to ON.

*   For more information about automatic merging and transcoding, see [FAQ about Live-to-VOD](https://help.aliyun.com/document_detail/99726.html).

*   For information about the billing of transcoding in ApsaraVideo VOD, see [Billing of basic services](https://help.aliyun.com/document_detail/188308.html).', example='*****', position='Query'),
  cycleDuration?: int32(name='CycleDuration', description='The recording cycle. Unit: seconds. Valid values: **300 to 21600**. Default value: **3600**.', example='300', minimum=300, maximum=21600, position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

>  Make sure that ApsaraVideo VOD is activated in the same region as the live center of the streaming domain.

This parameter is required.', example='example.com', position='Query'),
  onDemand?: int32(name='OnDemand', description='Specifies whether to enable on-demand recording. Valid values:

*   **0** (default): disables on-demand recording.
*   **1**: enables on-demand recording.', example='0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  storageLocation?: string(name='StorageLocation', description='The storage location.', example='****-tjptr2vatm.oss-cn-shanghai.aliyuncs.com', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='stream', position='Query'),
  vodTranscodeGroupId: string(name='VodTranscodeGroupId', description='The ID of the transcoding template group in ApsaraVideo VOD.

This parameter is required.', example='e2d796d3bb5fd8049d32bff62f94****', position='Query'),
}

model AddLiveRecordVodConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddLiveRecordVodConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveRecordVodConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to configure the Live-to-VOD feature to store recordings in the media library of ApsaraVideo VOD.
  * >  You cannot configure the Live-to-VOD feature by using a Finance Cloud account.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveRecordVodConfig  AddLiveRecordVodConfigRequest
  * @return AddLiveRecordVodConfigResponse
 */
async function addLiveRecordVodConfig(request: AddLiveRecordVodConfigRequest): AddLiveRecordVodConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveRecordVodConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveSnapshotDetectPornConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='testApp', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  interval?: int32(name='Interval', description='The interval at which snapshots are captured from the live stream. Valid values: **5 to 3600**. Unit: seconds.', example='10', minimum=5, maximum=3600, position='Query'),
  ossBucket: string(name='OssBucket', description='The name of the OSS bucket.

After the review is complete, you can search for specific violations in the OSS console based on the callback information. You must create the OSS bucket in advance. For more information, see [Configure content moderation](https://help.aliyun.com/document_detail/199449.html).

This parameter is required.', example='livebucket', position='Query'),
  ossEndpoint: string(name='OssEndpoint', description='The endpoint of the Object Storage Service (OSS) bucket.

After the review is complete, you can search for specific violations in the OSS console based on the callback information. You must configure the OSS endpoint in advance. For more information, see [Configure content moderation](https://help.aliyun.com/document_detail/199449.html).

This parameter is required.', example='cn-oss-****.aliyuncs.com', position='Query'),
  ossObject?: string(name='OssObject', description='The name of the snapshot that stores violations such as pornographic content and politically sensitive content.', example='record/{AppName}/{StreamName}/{Sequence}.jpg', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  scene?: [ string ](name='Scene', description='Scene list detection.', example='live', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model AddLiveSnapshotDetectPornConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddLiveSnapshotDetectPornConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveSnapshotDetectPornConfigResponseBody(name='body'),
}

/**
  * @description - The live streaming audit function identifies and reviews违规sensitive content at the domain and App level, and promptly notifies users of such violations via callbacks. Users can then review the content and take appropriate actions.
  * - Currently, only some live streaming centers support intelligent auditing. For a list of live streaming centers that support this feature, please refer to [Service Regions](https://help.aliyun.com/document_detail/193730.html).
  * ## QPS Limitation 
  * The QPS limit for this API per user is 30 requests/second. Exceeding this limit will result in API throttling, which may impact your services. Please use the API judiciously. For more information, see [QPS Limitations](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddLiveSnapshotDetectPornConfig  AddLiveSnapshotDetectPornConfigRequest
  * @return AddLiveSnapshotDetectPornConfigResponse
 */
async function addLiveSnapshotDetectPornConfig(request: AddLiveSnapshotDetectPornConfigRequest): AddLiveSnapshotDetectPornConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveSnapshotDetectPornConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveSnapshotNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='www.yourdomain***.com', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', description='The callback authentication key. The key must be 16 to 32 characters in length and can contain only letters and digits.

> This parameter is required if you set the NotifyReqAuth parameter to **yes**.', example='yourkey', position='Query'),
  notifyReqAuth?: string(name='NotifyReqAuth', description='Specifies whether to enable callback authentication. Valid values:

*   **yes**
*   **no** (default)

> This parameter is required if you set the NotifyAuthKey parameter to yes.', example='yes', position='Query'),
  notifyUrl: string(name='NotifyUrl', description='The callback URL. Specify a valid URL that is up to 500 characters in length.

This parameter is required.', example='http://callback.yourdomain***.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddLiveSnapshotNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddLiveSnapshotNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveSnapshotNotifyConfigResponseBody(name='body'),
}

/**
  * @description ### QPS Limit 
  * The QPS limit for this API per user is 30 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use the API reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddLiveSnapshotNotifyConfig  AddLiveSnapshotNotifyConfigRequest
  * @return AddLiveSnapshotNotifyConfigResponse
 */
async function addLiveSnapshotNotifyConfig(request: AddLiveSnapshotNotifyConfigRequest): AddLiveSnapshotNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveSnapshotNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveStreamMergeRequest {
  appName: string(name='AppName', description='The name of the application that generates the output stream. The value must be the same as the application name in the ingest URL of the output stream. Otherwise, the configuration does not take effect. You cannot set the value to an asterisk (\\*).

This parameter is required.', example='app', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end time of the stream mixing.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The interval between the start time and the end time must be within 7 days.

This parameter is required.', example='2020-05-29T01:00:00Z', position='Query'),
  inAppName1: string(name='InAppName1', description='The name of the application that generates the input primary stream. The value must be the same as the application name that is specified in the ingest URL of the primary stream. Otherwise, the configuration does not take effect.

This parameter is required.', example='app1', position='Query'),
  inAppName2: string(name='InAppName2', description='The name of the application that generates the input secondary stream. The value must be the same as the application name that is specified in the ingest URL of the secondary stream. Otherwise, the configuration does not take effect.

This parameter is required.', example='app2', position='Query'),
  inStreamName1: string(name='InStreamName1', description='The name of the input primary stream. The value must be the same as the stream name that is specified in the ingest URL of the primary stream. Otherwise, the configuration does not take effect.

This parameter is required.', example='InStream1', position='Query'),
  inStreamName2: string(name='InStreamName2', description='The name of the input secondary stream. The value must be the same as the stream name that is specified in the ingest URL of the secondary stream. Otherwise, the configuration does not take effect.

This parameter is required.', example='stream2', position='Query'),
  liveMerger?: string(name='LiveMerger', position='Query'),
  mergeParameters?: string(name='MergeParameters', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  protocol?: string(name='Protocol', description='The streaming protocol. Valid values:

*   **rtmp**: This is the default value.
*   **rtc**', example='rtmp', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The start time of the stream mixing.

Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2020-05-29T00:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the output stream. The value must be the same as the stream name in the ingest URL of the output stream. Otherwise, the configuration does not take effect. You cannot set the value to an asterisk (\\*).

This parameter is required.', example='StreamName', position='Query'),
}

model AddLiveStreamMergeResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model AddLiveStreamMergeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveStreamMergeResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveStreamMerge  AddLiveStreamMergeRequest
  * @return AddLiveStreamMergeResponse
 */
async function addLiveStreamMerge(request: AddLiveStreamMergeRequest): AddLiveStreamMergeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveStreamMerge', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

*   The transcoding template takes effect only if the value of this parameter is the same as the application name that is specified in the ingest URL. The name can be up to 256 characters in length and can contain digits, letters, hyphens (-), and underscores (_).
*   You can also set this parameter to an asterisk (\\*). Asterisks (\\*) can match any string, including an empty string.

>  If you configure a transcoding template for which App is set to an asterisk (\\*), the transcoding template is used only if no transcoding template for which App is set to the same value as AppName in the ingest URL exists.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The name of the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  encryptParameters?: string(name='EncryptParameters', description='The encryption configuration. The value is a JSON string. The following fields are included in the syntax:

*   EncryptType: the type of the encryption. Set the value to **aliyun**.
*   KmsKeyID: the ID of the CMK in KMS.
*   KmsKeyExpireInterval: the validity period of the CMK. Valid values: **60 to 3600**. Unit: seconds.', example='{"EncryptType": "aliyun", "KmsKeyID":"afce5722-81d2-43c3-9930-7601da11****","KmsKeyExpireInterval":"3600"}', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to use the load-on-demand mechanism for transcoding. Default value: **yes**.', example='yes', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The transcoding template. Valid values:

*   Standard transcoding template:

    *   **lld**: low definition
    *   **lsd**: standard definition
    *   **lhd**: high definition
    *   **lud**: ultra-high definition

*   Narrowband HD™ transcoding template:

    *   **ld**: low definition
    *   **sd**: standard definition
    *   **hd**: high definition
    *   **ud**: ultra-high definition

This parameter is required.', example='lsd', position='Query'),
}

model AddLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to add transcoding configurations. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
  * ## QPS limits
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of AddLiveStreamTranscode  AddLiveStreamTranscodeRequest
  * @return AddLiveStreamTranscodeResponse
 */
async function addLiveStreamTranscode(request: AddLiveStreamTranscodeRequest): AddLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveStreamWatermarkRequest {
  description?: string(name='Description', description='The description of the watermark.', example='my watermark', position='Query'),
  domain?: string(name='Domain', description='The streaming domain.', example='example.aliyundoc.com', position='Query'),
  height: int32(name='Height', description='The height of the watermark. Unit: pixels. The height of the watermark is scaled in proportion to the height of the background video.

This parameter is required.', example='200', position='Query'),
  name: string(name='Name', description='The name of the watermark.

This parameter is required.', example='livewatermark****', position='Query'),
  offsetCorner: string(name='OffsetCorner', description='The location of the watermark. Valid values:

*   TopLeft: the upper-left corner.
*   TopRight: the upper-right corner.
*   BottomLeft: the lower-left corner.
*   BottomRight: the lower-right corner.

This parameter is required.', example='TopRight', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pictureUrl: string(name='PictureUrl', description='The URL of the watermark image.

This parameter is required.', example='http://example.com', position='Query'),
  refHeight: int32(name='RefHeight', description='The height of the background video. Unit: pixels.

This parameter is required.', example='1080', position='Query'),
  refWidth: int32(name='RefWidth', description='The width of the background video. Unit: pixels.

This parameter is required.', example='1920', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  transparency: int32(name='Transparency', description='The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.

This parameter is required.', example='255', position='Query'),
  type: int32(name='Type', description='The type of the watermark. Valid values:

*   **0**: image.
*   **1**: text. Only image watermarks are supported.

This parameter is required.', example='0', position='Query'),
  xOffset: float(name='XOffset', description='The offset of the watermark along the x-axis. Unit: pixels.

>  In this case, the value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.

This parameter is required.', example='50.0', position='Query'),
  yOffset: float(name='YOffset', description='The offset of the watermark along the y-axis. Unit: pixels.

>  In this case, the value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.

This parameter is required.', example='100.0', position='Query'),
}

model AddLiveStreamWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91b96****'),
  templateId?: string(name='TemplateId', description='The ID of the watermark template.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
}

model AddLiveStreamWatermarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveStreamWatermarkResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to create a watermark template and configure information such as the watermark content and layout in the template.
  * *   After you create a watermark template, you must also call the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation to add a watermark rule. A live stream in progress can contain the watermark only after the stream is re-ingested.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddLiveStreamWatermark  AddLiveStreamWatermarkRequest
  * @return AddLiveStreamWatermarkResponse
 */
async function addLiveStreamWatermark(request: AddLiveStreamWatermarkRequest): AddLiveStreamWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveStreamWatermark', 'POST', '/', 'json', false, 'json', request);
}

model AddLiveStreamWatermarkRuleRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  description?: string(name='Description', description='The description of the custom rule.', example='my rule', position='Query'),
  domain: string(name='Domain', description='The streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  name: string(name='Name', description='The name of the custom rule.

This parameter is required.', example='WatermarkRule****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the live stream. The following rules apply:

*   A stream name can be exactly matched. Example: liveStreamA.
*   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
*   You can place the asterisk before or after an approximate string.



>*   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).
>*   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.

This parameter is required.', example='liveStreamA', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the watermark template.

>  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
}

model AddLiveStreamWatermarkRuleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
  ruleId?: string(name='RuleId', description='The ID of the watermark rule.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
}

model AddLiveStreamWatermarkRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddLiveStreamWatermarkRuleResponseBody(name='body'),
}

/**
  * @description After calling the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/469416.html) API to add a watermark template, you can use this interface to add watermark rules. 
  * ## QPS Limit
  *  The QPS limit for this interface per user is 60 times/second. Exceeding the limit will result in API calls being throttled, which may impact your business. Please use it reasonably. For more information, see [QPS Limit](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddLiveStreamWatermarkRule  AddLiveStreamWatermarkRuleRequest
  * @return AddLiveStreamWatermarkRuleResponse
 */
async function addLiveStreamWatermarkRule(request: AddLiveStreamWatermarkRuleRequest): AddLiveStreamWatermarkRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddLiveStreamWatermarkRule', 'POST', '/', 'json', false, 'json', request);
}

model AddPlaylistItemsRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

The production studio must use the following configurations:

*   **NormType**: 3****. You need to call the **CreateCaster** operation to create a production studio for lightweight carousel playback in advance.
*   **CasterTemplate**: lp_noTranscode.
*   **channelEnable**: 0.
*   **programEffect**: 1.

This parameter is required.', example='0e94d1f4-1a65-445c-9dcf-de8b3b8d****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  programConfig?: string(name='ProgramConfig', description='The configurations of the episode list. If the episode list is added to the production studio for the first time, specify this parameter to pass in the initial configurations. For more information, see the **ProgramConfig** section of this topic.', example='[{"RepeatNumber":"0","ProgramName":"my program"}]', position='Query'),
  programId?: string(name='ProgramId', description='The ID of the episode list. If you do not specify this parameter, an episode list is created by default.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  programItems: string(name='ProgramItems', description='The episodes that you want to add to the production studio. The value is a JSON string. For more information, see the **InputProgramItem** section of this topic.

This parameter is required.', example='[{"ItemName":"item1","ResourceType":"vod","ResourceValue":"5f8809f2-3352-4d1f-a8f7-86f9429f****"}, {"ItemName": "item2","ResourceType": "vod","ResourceValue": "e7411c0b-dd98-4c61-a545-f8bfba6c****"}]', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model AddPlaylistItemsResponseBody = {
  items?: {
    failedItems?: [ 
      {
        itemId?: string(name='ItemId', description='The ID of the episode.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****'),
        itemName?: string(name='ItemName', description='The name of the episode.', example='item1'),
      }
    ](name='FailedItems', description='The episodes that failed to be added.'),
    successItems?: [ 
      {
        itemId?: string(name='ItemId', description='The ID of the episode.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****'),
        itemName?: string(name='ItemName', description='The name of the episode.', example='item2'),
      }
    ](name='SuccessItems', description='The episodes that were added.'),
  }(name='Items', description='The information about the episodes.'),
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to remove episodes, query episodes, edit an episode list, delete an episode list, query the information about an episode list, start playing an episode list, or stop playing an episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model AddPlaylistItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddPlaylistItemsResponseBody(name='body'),
}

/**
  * @description Create a production studio, add a layout and components to the production studio, and then call this operation to add episodes. If no episode list exists in the production studio, this operation creates an episode list for the production studio. For more information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddPlaylistItems  AddPlaylistItemsRequest
  * @return AddPlaylistItemsResponse
 */
async function addPlaylistItems(request: AddPlaylistItemsRequest): AddPlaylistItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddPlaylistItems', 'POST', '/', 'json', false, 'json', request);
}

model AddRtsLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. Value requirements:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   We recommend that you specify a name that is more than three characters in length. The name must start with a letter or digit.

This parameter is required.', example='aliyun-test', position='Query'),
  audioBitrate?: int32(name='AudioBitrate', description='The bitrate of the output audio. Unit: Kbit/s. Valid values: **1** to **1000**.

>  This parameter is required if you set the TemplateType parameter to audio.', example='128', position='Query'),
  audioChannelNum?: int32(name='AudioChannelNum', description='The number of sound channels. Valid values:

*   **1**: mono
*   **2**: stereo', example='2', position='Query'),
  audioCodec?: string(name='AudioCodec', description='The audio encoder. Valid values:

*   **aac**
*   **mp3**

> If you want to use the Opus encoding format, set the Opus parameter to true.', example='aac', position='Query'),
  audioProfile?: string(name='AudioProfile', description='The audio codec profile. Valid values:

*   **aac_low**
*   **aac_he**
*   **aac_he_v2**
*   **aac_ld**', example='aac_low', position='Query'),
  audioRate?: int32(name='AudioRate', description='The audio sampling rate. Valid values: **22050 to 96000**. The value 44100 is commonly used. Unit: Hz.

> If you set the AudioProfile parameter to aac_ld, the audio sampling rate cannot exceed 44,100 Hz.', example='44100', position='Query'),
  deleteBframes?: boolean(name='DeleteBframes', description='Specifies whether to remove B-frames during transcoding. Valid values:

>  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.

*   **true**: removes B-frames.
*   **false**: retains B-frames. This is the default value.

> If you do not specify this parameter, the default value **false** is used.', example='false', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  FPS?: int32(name='FPS', description='The frame rate of the output video. Unit: FPS. Valid values: **1** to **60**.

>  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.', example='30', position='Query'),
  gop?: string(name='Gop', description='The group of pictures (GOP) size of the output video. This parameter is used to specify the keyframe interval. Unit: seconds. Valid values: **1** to **3**.', example='2', position='Query'),
  height?: int32(name='Height', description='The height of the output video. Unit: pixels.

>  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.

The value must comply with the following rules:****

*   **Height ≥ 100**: The height of the video is no less than 100 pixels.
*   **max(Height,Width) ≤ 2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
*   **min(Height,Width) ≤ 1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.

For example, a resolution of 1560 × 1560 pixels is invalid.

> An original quality template needs to retain the source information. Therefore, the video resolution cannot exceed 4K.', example='1280', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to trigger transcoding only when a stream is pulled. Valid values:

*   **yes**: triggers transcoding only when a stream is pulled.
*   **no**: triggers transcoding whenever a stream is ingested, no matter whether the stream is pulled.', example='no', position='Query'),
  opus?: boolean(name='Opus', description='Specifies whether to transcode audio to the Opus format to be compatible with native WebRTC. Valid values:

*   **true**: transcodes audio to the Opus format.
*   **false**: does not transcode audio to the Opus format.

> If you do not specify this parameter, the default value **false** is used.', example='true', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  profile?: int32(name='Profile', description='The codec profile. The video codec profile determines how ApsaraVideo Live performs codec on the video. In normal cases, a greater value indicates a higher image quality and requires more codec resources. Valid values:

*   **1**: baseline, which is suitable for mobile devices.
*   **2**: main, which is suitable for standard-definition devices.
*   **3**: high, which is suitable for high-definition devices.', example='2', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The name of the transcoding template. Value requirements:

*   The name can contain letters, digits, underscores (_), and hyphens (-).
*   We recommend that you specify a name that is more than three characters in length. The name must start with a letter or digit.

> The name cannot be the same as that of a default transcoding template.

This parameter is required.', example='ld', position='Query'),
  templateType: string(name='TemplateType', description='The type of the transcoding template.

If you set this parameter to h264, h264-nbhd, or h264-origin, you must also specify the Height, Width, FPS, VideoBitrate, and DeleteBframes parameters. Valid values:

*   **h264**: H.264 standard transcoding template.
*   **h264-nbhd**: H.264 Narrowband HD™ transcoding template.
*   **h264-origin**: H.264 original quality template. If you use this type of template, the same transcoding parameters of the video source are retained by default.
*   **audio**: audio-only transcoding template. If you use this type of template, images are removed from the video source and an audio-only stream is generated. In addition, you must also specify the AudioBitrate parameter.

This parameter is required.', example='h264', position='Query'),
  videoBitrate?: int32(name='VideoBitrate', description='The bitrate of the output video. Unit: Kbit/s. Valid values: **1** to **6000**.

>  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.

> The bitrate of the output video is as close to the value that you specify as possible, but not exactly the same as the value, especially when the value is excessively large or small.', example='2000', position='Query'),
  width?: int32(name='Width', description='The width of the output video. Unit: pixels.

>  This parameter is required if you set the TemplateType parameter to h264, h264-nbhd, or h264-origin.

The value must comply with the following rules:

*   **Width ≥ 100**: The width of the video is no less than 100 pixels.
*   **max(Height,Width) ≤ 2560**: The width or height of the video, whichever is greater, cannot exceed 2,560 pixels.
*   **min(Height,Width) ≤ 1440**: The width or height of the video, whichever is smaller, cannot exceed 1,440 pixels.

For example, a resolution of 1560 × 1560 pixels is invalid.

> An original quality template needs to retain the source information. Therefore, the video resolution cannot exceed 4K.', example='720', position='Query'),
}

model AddRtsLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model AddRtsLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddRtsLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description You can call this operation to add an RTS transcoding configuration. This operation supports four template types: h264, h264-nbhd, h264-origin, and audio.
  * ## QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of AddRtsLiveStreamTranscode  AddRtsLiveStreamTranscodeRequest
  * @return AddRtsLiveStreamTranscodeResponse
 */
async function addRtsLiveStreamTranscode(request: AddRtsLiveStreamTranscodeRequest): AddRtsLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddRtsLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model AddShowIntoShowListRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  duration?: long(name='Duration', description='The duration of the episode. Unit: seconds.

> You can specify only one of the **RepeatTimes** and **Duration** parameters.', example='20', position='Query'),
  liveInputType?: int32(name='LiveInputType', description='The custom type label.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatTimes?: int32(name='RepeatTimes', description='The number of times the episode repeats after the first playback is complete. The default value is 0.

> 

*   You can specify only one of the **RepeatTimes** and **Duration** parameters. - The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to -1, the episode is to be played for infinite times. If you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.', example='0', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the resource.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   live: live stream
*   vod: on-demand video
*   pic: image

> 

*   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets. - You can add a live stream from ApsaraVideo Live or by using a third-party URL. - You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL, or add an on-demand image.', example='vod', position='Query'),
  resourceUrl?: string(name='ResourceUrl', description='The URL of the resource.', position='Query'),
  showName?: string(name='ShowName', description='The name of the episode.', example='liveShow****', position='Query'),
  spot?: int32(name='Spot', description='The position of the episode in the episode list. Position indexes start from 0. By default, the episode is added to the end of the episode list.', example='1', position='Query'),
  isBatchMode?: boolean(name='isBatchMode', description='Specifies whether to add multiple episodes to the episode list at a time. Valid values:

*   true: adds multiple episodes to the episode list at a time.
*   false: adds a single episode to the episode list.

> If you do not specify this parameter or this parameter is left empty, a single episode is to be added to the episode list.', example='false', position='Query'),
  showList?: [ 
    {
      duration?: long(name='duration', description='The duration of the episode. Unit: seconds.

>  You can specify only one of the **RepeatTimes** and **Duration** parameters.', example='20'),
      liveInputType?: int32(name='liveInputType', description='The custom type label.', example='1'),
      repeatTimes?: int32(name='repeatTimes', description='The number of times the episode repeats after the first playback is complete. Default value: 0.

> 

*   You can specify only one of the **RepeatTimes** and **Duration** parameters.

*   The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.', example='0'),
      resourceId?: string(name='resourceId', description='The ID of the resource.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
      resourceType?: string(name='resourceType', description='The resource type. Valid values:

*   live: live stream
*   vod: on-demand video
*   pic: image

> 

*   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.

*   You can add a live stream from ApsaraVideo Live or by using a third-party URL.
*   You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL, or add an on-demand image.', example='vod'),
      resourceUrl?: string(name='resourceUrl', description='The URL of the resource.'),
      showName?: string(name='showName', description='The name of the episode.', example='liveShow****'),
    }
  ](name='showList', description='The episodes that you want to add to the episode list. Each episode has a unique name and resource URL.', position='Query'),
}

model AddShowIntoShowListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='987DA143-A39C-5B5D-AF5B-3B07944A0036'),
  showId?: string(name='ShowId', description='The ID of the episode.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  failedList?: string(name='failedList', description='The list of resources that failed to be added and the reason for failure.', example='failedList[Show1, Show2...]'),
  successfulShowIds?: string(name='successfulShowIds', description='The IDs of the episodes that were added.', example='f1933f16-5467-4308-b3a9-e8d451a90999,547436b8-c839-4469-a2c0-704c1ce5ce00'),
}

model AddShowIntoShowListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddShowIntoShowListResponseBody(name='body'),
}

/**
  * @description You must create a production studio in the new playlist mode and add media resources to the production studio before you can call this operation. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * You can add up to 1,000 episodes to an episode list.
  * > 
  * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
  * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddShowIntoShowList  AddShowIntoShowListRequest
  * @return AddShowIntoShowListResponse
 */
async function addShowIntoShowList(request: AddShowIntoShowListRequest): AddShowIntoShowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddShowIntoShowList', 'POST', '/', 'json', false, 'json', request);
}

model AddStudioLayoutRequest {
  bgImageConfig?: string(name='BgImageConfig', description='The background material configurations. The value is a JSON string. For more information, see **BgImageConfig**.

>  This parameter is required only if you set LayoutType to studio.', example='{ "Id":"k12kj31****", "MaterialId":"f080575eb5f4427684fc0715159a****" }', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

>  The production studio must be a virtual studio that you create in advance. You can use the ApsaraVideo Live console or call the CreateCaster operation to create a virtual studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  commonConfig?: string(name='CommonConfig', description='The common layout configurations. The value is a JSON string. For more information, see **CommonConfig**.

>  This parameter is required only if you set LayoutType to common.', example='{"ChannelId":"RV01" }', position='Query'),
  layerOrderConfigList?: string(name='LayerOrderConfigList', description='The layer sorting configurations. The value is a JSON string. For more information, see **layerOrderConfig**. You can sort layers of background and multimedia materials. The chroma key layer cannot be sorted. A layer that is in the front of the code is placed behind other layers in the layout.', example='[ 	{ 	"Type":"media", 	"Id":"k12kj31****" 	}, 	{ 	"Type":"media", 	"Id":"k12kj31****" 	} ]', position='Query'),
  layoutName: string(name='LayoutName', description='The name of the layout.

This parameter is required.', example='Test layout', position='Query'),
  layoutType: string(name='LayoutType', description='The type of the layout. Valid values:

*   **common**: If you set this parameter to common, you must specify the CommonConfig parameter.
*   **studio**: If you set this parameter to studio, you must specify the BgImageConfig and ScreenInputConfigList parameters. The MediaInputConfigList parameter is optional.

This parameter is required.', example='studio', position='Query'),
  mediaInputConfigList?: string(name='MediaInputConfigList', description='The multimedia input configurations. The value is a JSON string. For more information, see **MediaInputConfig**.

>  This parameter is optional and is valid only if you set LayoutType to studio.', example='[ 	{ 	"Id":"k12kj31****", 	"Index":"1", 	"ChannelId":"RV01", 	"FillMode":"none", 	"PositionRefer":"topLeft", 	"WidthNormalized":"0.4", 	"HeightNormalized":"0.4", 	"PositionNormalized":"[0.1, 0.2]" 	},   { 	"Id":"k12kj31****", 	"Index":"2", 	"ImageMaterialId":"lkajsdfsa8fd89asd8****", 	"FillMode":"none", 	"PositionRefer":"topLeft", 	"WidthNormalized":"0.6", 	"HeightNormalized":"0.4", 	"PositionNormalized":"[0.1, 0.2]" 	} ]', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  screenInputConfigList?: string(name='ScreenInputConfigList', description='The input configurations for chroma key. The value is a JSON string. For more information, see **ScreenInputConfig**.

>  This parameter is required only if you set LayoutType to studio.', example='[ 	{ 	"Index":"1", 	"ChannelId":"RV01", 	"Color":"green", 	"PositionX":"0.1", 	"PositionY":"0.2", 	"HeightNormalized":"0.4" 	} ]', position='Query'),
}

model AddStudioLayoutResponseBody = {
  layoutId?: string(name='LayoutId', description='The ID of the layout. You can use the ID as a request parameter in the following operations: DeleteStudioLayout, ModifyStudioLayout, and DescribeStudioLayouts.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model AddStudioLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddStudioLayoutResponseBody(name='body'),
}

/**
  * @description You can call this operation to configure a common layout or a studio layout for a virtual studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddStudioLayout  AddStudioLayoutRequest
  * @return AddStudioLayoutResponse
 */
async function addStudioLayout(request: AddStudioLayoutRequest): AddStudioLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddStudioLayout', 'POST', '/', 'json', false, 'json', request);
}

model AddTrancodeSEIRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  delay: int32(name='Delay', description='The time period after which the SEI is inserted after the request is received. Unit: milliseconds.

This parameter is required.', example='100', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pattern: string(name='Pattern', description='Specifies whether to append the SEI to each keyframe or frame. Valid values:

*   **keyframe**
*   **frame**

This parameter is required.', example='keyframe', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeat: int32(name='Repeat', description='The number of times that the SEI is repeatedly inserted. A value of -1 specifies infinite times.

This parameter is required.', example='-1', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

>  The value of this parameter must be the name of the source stream. This way, the SEI is inserted to all the transcoded streams.

This parameter is required.', example='liveStream****', position='Query'),
  text: string(name='Text', description='The SEI text. It can be up to 4,000 bytes in length.

This parameter is required.', example='liveSei****', position='Query'),
}

model AddTrancodeSEIResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4E*****43-CB92E68F4CD8'),
}

model AddTrancodeSEIResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: AddTrancodeSEIResponseBody(name='body'),
}

/**
  * @description Obtain the streaming domain, and then call this operation to insert SEI to the transcoded streams. Make sure that the stream name is the name of the source stream. This way, the SEI is inserted to all the transcoded streams.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of AddTrancodeSEI  AddTrancodeSEIRequest
  * @return AddTrancodeSEIResponse
 */
async function addTrancodeSEI(request: AddTrancodeSEIRequest): AddTrancodeSEIResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTrancodeSEI', 'POST', '/', 'json', false, 'json', request);
}

model BanLiveMessageGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.

>  Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  exceptUsers?: [ string ](name='ExceptUsers', description='The users whom you do not want to mute when the group is muted.', shrink='simple', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
}

model BanLiveMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model BanLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BanLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of BanLiveMessageGroup  BanLiveMessageGroupRequest
  * @return BanLiveMessageGroupResponse
 */
async function banLiveMessageGroup(request: BanLiveMessageGroupRequest): BanLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BanLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model BatchDeleteLiveDomainConfigsRequest {
  domainNames: string(name='DomainNames', description='The ingest domain or streaming domain. Separate multiple domain names with commas (,).

This parameter is required.', example='demo.aliyundoc.com,example.aliyundoc.com,example.com', position='Query'),
  functionNames: string(name='FunctionNames', description='The names of the features. Separate multiple features with commas (,). For more information, see **Features specified by the Functions parameter**.

This parameter is required.', example='referer_white_list_set,ip_black_list_set', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchDeleteLiveDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model BatchDeleteLiveDomainConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchDeleteLiveDomainConfigsResponseBody(name='body'),
}

/**
  * @description Obtain the domain names for which you want to delete the configurations, and then call this operation to delete the configurations of these domain domains at a time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of BatchDeleteLiveDomainConfigs  BatchDeleteLiveDomainConfigsRequest
  * @return BatchDeleteLiveDomainConfigsResponse
 */
async function batchDeleteLiveDomainConfigs(request: BatchDeleteLiveDomainConfigsRequest): BatchDeleteLiveDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchDeleteLiveDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model BatchGetOnlineUsersRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='a494caec-***-695ef345db77', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='23wcaec-***695ef', position='Body'),
  userIds: string(name='UserIds', description='The list of user IDs. Separate multiple user IDs with commas (,). You can specify a maximum of 20 user IDs.

This parameter is required.', example='de1**a0,hu**9', position='Body'),
}

model BatchGetOnlineUsersResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    onlineUsers?: [ 
      {
        joinTime?: long(name='JoinTime', description='The time when the user joined the group. The value is a UTC timestamp. Unit: milliseconds.', example='12**45'),
        online?: boolean(name='Online', description='Indicates whether the user is online. Valid values:

*   **true**
*   **false**', example='true'),
        userId?: string(name='UserId', description='The ID of the user.', example='de1**a0'),
      }
    ](name='OnlineUsers', description='The information about users.'),
  }(name='Result', description='The returned results.'),
}

model BatchGetOnlineUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchGetOnlineUsersResponseBody(name='body'),
}

/**
  * @description ## Usage notes
  * You can query whether up to 20 users are online at a time.
  * ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of BatchGetOnlineUsers  BatchGetOnlineUsersRequest
  * @return BatchGetOnlineUsersResponse
 */
async function batchGetOnlineUsers(request: BatchGetOnlineUsersRequest): BatchGetOnlineUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchGetOnlineUsers', 'POST', '/', 'json', true, 'form', request);
}

model BatchSetLiveDomainConfigsRequest {
  domainNames: string(name='DomainNames', description='The domain names that you want to batch configure. Supported domain names include ingest domains, main streaming domains, and sub-streaming domains. Separate multiple domain names with commas (,).

This parameter is required.', example='demo.aliyundoc.com,example.aliyundoc.com,example.com', position='Query'),
  functions: string(name='Functions', description='The list of features.

Some features, such as `filetype_based_ttl_set`, support multiple configuration records. To update one of the configuration records, use `configId` to identify the record. For more information, see **Format of the Functions parameter** and **Features specified by the Functions parameter**.

This parameter is required.', example='[{"functionArgs":[{"argName":"file_type","argValue":"jpg"},{"argName":"ttl","argValue":"18"},{"argName":"weight","argValue":"30"}],"functionName":"filetype_based_ttl_set","configId":506***}]', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model BatchSetLiveDomainConfigsResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model BatchSetLiveDomainConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: BatchSetLiveDomainConfigsResponseBody(name='body'),
}

/**
  * @description Obtain the domain names that you want to configure, and then call this operation to configure the domain names in batches.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of BatchSetLiveDomainConfigs  BatchSetLiveDomainConfigsRequest
  * @return BatchSetLiveDomainConfigsResponse
 */
async function batchSetLiveDomainConfigs(request: BatchSetLiveDomainConfigsRequest): BatchSetLiveDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'BatchSetLiveDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model CancelMuteAllGroupUserRequest {
  appId: string(name='AppId', description='Interactive message application ID.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='系统消息扩散类型，取值：

- 0：不扩散。

- 1：扩散到指定人。

- 2：扩散到群组。', example='2', position='Body'),
  groupId: string(name='GroupId', description='Message group ID.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId?: string(name='OperatorUserId', description='Operator\\"s UserId. > This parameter is required and the user must be the creator of the group.', example='de1**a0', position='Body'),
}

model CancelMuteAllGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the cancellation was successful, with values:
- true: Success. 
- false: Not successful.', example='true'),
  }(name='Result', description='The returned result.'),
}

model CancelMuteAllGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelMuteAllGroupUserResponseBody(name='body'),
}

/**
  * @description ## QPS限制
  * 本接口的单用户QPS限制为100次/秒。超过限制，API调用会被限流，这可能会影响您的业务，请合理调用。更多信息，请参见[QPS限制](https://help.aliyun.com/document_detail/343507.html)。
  * @param request  the request parameters of CancelMuteAllGroupUser  CancelMuteAllGroupUserRequest
  * @return CancelMuteAllGroupUserResponse
 */
async function cancelMuteAllGroupUser(request: CancelMuteAllGroupUserRequest): CancelMuteAllGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelMuteAllGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model CancelMuteGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted. This is the default value.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  cancelMuteUserList: [ string ](name='CancelMuteUserList', description='The IDs of the users.

This parameter is required.', shrink='simple', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId?: string(name='OperatorUserId', description='The ID of the user who performs the operation.', example='de1**a0', position='Body'),
}

model CancelMuteGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the members are unmuted. Valid values:

*   true: The members are unmuted.
*   false: The members failed to be unmuted.', example='false'),
  }(name='Result', description='The returned result.'),
}

model CancelMuteGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CancelMuteGroupUserResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of CancelMuteGroupUser  CancelMuteGroupUserRequest
  * @return CancelMuteGroupUserResponse
 */
async function cancelMuteGroupUser(request: CancelMuteGroupUserRequest): CancelMuteGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelMuteGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model ChangeLiveDomainResourceGroupRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain.

This parameter is required.', example='example.com', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', description='The ID of the resource group to which the domain name is moved.

This parameter is required.', example='rg-****ke6uuxw****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ChangeLiveDomainResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='******8F-F82F-10E2-BAE1-A036FD******'),
}

model ChangeLiveDomainResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ChangeLiveDomainResourceGroupResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ChangeLiveDomainResourceGroup  ChangeLiveDomainResourceGroupRequest
  * @return ChangeLiveDomainResourceGroupResponse
 */
async function changeLiveDomainResourceGroup(request: ChangeLiveDomainResourceGroupRequest): ChangeLiveDomainResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ChangeLiveDomainResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model CheckLiveMessageUsersInGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
  userIds: [ string ](name='UserIds', description='The list of users that you want to query.

This parameter is required.', shrink='simple', position='Query'),
}

model CheckLiveMessageUsersInGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F1F68D81-1543-1FE4-B56E-82200DD2****'),
  users?: [ 
    {
      online?: boolean(name='Online', description='Indicates whether the user is in the group.', example='false'),
      userId?: string(name='UserId', description='The ID of the user.', example='uid1'),
    }
  ](name='Users', description='The list of users queried.'),
}

model CheckLiveMessageUsersInGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckLiveMessageUsersInGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CheckLiveMessageUsersInGroup  CheckLiveMessageUsersInGroupRequest
  * @return CheckLiveMessageUsersInGroupResponse
 */
async function checkLiveMessageUsersInGroup(request: CheckLiveMessageUsersInGroupRequest): CheckLiveMessageUsersInGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckLiveMessageUsersInGroup', 'POST', '/', 'json', false, 'json', request);
}

model CheckLiveMessageUsersOnlineRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  userIds: [ string ](name='UserIds', description='The list of users that you want to query.

This parameter is required.', shrink='simple', position='Query'),
}

model CheckLiveMessageUsersOnlineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='178F572F-AECF-100B-937A-B8047B4D****'),
  userList?: [ 
    {
      online?: boolean(name='Online', description='Indicates whether the user is online.', example='false'),
      userId?: string(name='UserId', description='The user ID.', example='uid1'),
    }
  ](name='UserList', description='The list of users queried.'),
}

model CheckLiveMessageUsersOnlineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CheckLiveMessageUsersOnlineResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CheckLiveMessageUsersOnline  CheckLiveMessageUsersOnlineRequest
  * @return CheckLiveMessageUsersOnlineResponse
 */
async function checkLiveMessageUsersOnline(request: CheckLiveMessageUsersOnlineRequest): CheckLiveMessageUsersOnlineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckLiveMessageUsersOnline', 'POST', '/', 'json', false, 'json', request);
}

model CloseLiveShiftRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveStream****', position='Query'),
}

model CloseLiveShiftResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model CloseLiveShiftResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CloseLiveShiftResponseBody(name='body'),
}

/**
  * @description Obtain the streaming domain, and then call this operation to disable time shifting for the streaming domain or an application or a live stream under the streaming domain.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CloseLiveShift  CloseLiveShiftRequest
  * @return CloseLiveShiftResponse
 */
async function closeLiveShift(request: CloseLiveShiftRequest): CloseLiveShiftResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloseLiveShift', 'POST', '/', 'json', false, 'json', request);
}

model CopyCasterRequest {
  casterName: string(name='CasterName', description='The name of the new production studio.

This parameter is required.', example='caster001', position='Query'),
  clientToken: string(name='ClientToken', description='The user-generated request token. This token is used to ensure the idempotence of the request.

You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='53200b81-b761-4c10-842a-a0726d97****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  srcCasterId: string(name='SrcCasterId', description='The ID of the original production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
}

model CopyCasterResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the new production studio.', example='1909f043-e3d3-49e9-82d6-4329ec4a****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model CopyCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyCasterResponseBody(name='body'),
}

/**
  * @description You can call this operation to duplicate a production studio. This way, a new, identical production studio is created.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CopyCaster  CopyCasterRequest
  * @return CopyCasterResponse
 */
async function copyCaster(request: CopyCasterRequest): CopyCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyCaster', 'POST', '/', 'json', false, 'json', request);
}

model CopyCasterSceneConfigRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  fromSceneId: string(name='FromSceneId', description='The ID of the source scene, which must be a PVW scene.

This parameter is required.', example='f1a361f4-bee3-436d-ae6e-d38e6943****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  toSceneId: string(name='ToSceneId', description='The ID of the destination scene, which must be a PGM scene.

This parameter is required.', example='05ab713c-676e-49c0-96ce-cc408da1****', position='Query'),
}

model CopyCasterSceneConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A5****'),
}

model CopyCasterSceneConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CopyCasterSceneConfigResponseBody(name='body'),
}

/**
  * @description *   Streaming fees and transcoding fees are calculated based on the corresponding output resolutions and durations. For more information, see [Billing of production studios](https://help.aliyun.com/document_detail/64531.html).
  * *   You can call this operation to apply the configuration of a source scene to a destination scene. This operation takes effect only if the source scene is a PVW scene and the destination scene is a PGM scene. A PVW scene is a preview scene, and a PGM scene is a program scene.
  * *   The PVW scene and PGM scene must be in the same production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CopyCasterSceneConfig  CopyCasterSceneConfigRequest
  * @return CopyCasterSceneConfigResponse
 */
async function copyCasterSceneConfig(request: CopyCasterSceneConfigRequest): CopyCasterSceneConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyCasterSceneConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateCasterRequest {
  casterName?: string(name='CasterName', description='The name of the production studio.', example='liveCaster****', position='Query'),
  casterTemplate?: string(name='CasterTemplate', description='The preset resolution of the production studio. If the subscription billing method is used, this parameter supports the following valid values:

*   **lp_ld**: low definition
*   **lp_sd**: standard definition
*   **lp_hd**: high definition
*   **lp_ud**: ultra high definition
*   **lp_ld_v**: low definition (portrait mode)
*   **lp_sd_v**: standard definition (portrait mode)
*   **lp_hd_v**: high definition (portrait mode)
*   **lp_ud_v**: ultra high definition (portrait mode)

>  If the pay-as-you-go billing method is used, you must call the [SetCasterConfig](https://help.aliyun.com/document_detail/60271.html) operation to specify the resolution.', example='lp_sd', position='Query'),
  chargeType: string(name='ChargeType', description='The billing method. Only the pay-as-you-go billing method is supported.**** Valid values:

*   **PrePaid**: subscription. This billing method is not yet supported.
*   **PostPaid**: pay-as-you-go

This parameter is required.', example='PostPaid', position='Query'),
  clientToken: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request.

You can specify a custom value for this parameter, but you must make sure that the value is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length.

This parameter is required.', example='53200b81-b761-4c10-842a-a0726d97****', position='Query'),
  expireTime?: string(name='ExpireTime', description='The expiration time of the production studio. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  This parameter is valid only if you set the **ChargeType** parameter to **PrePaid**.', example='2017-08-22T12:10:10Z', position='Query'),
  normType: int32(name='NormType', description='The type of the production studio. Valid values:

*   **1**: general mode
*   **6**: playlist mode (for carousel playback)

This parameter is required.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  purchaseTime?: string(name='PurchaseTime', description='The time when the production studio was purchased. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  This parameter is valid only if you set the **ChargeType** parameter to **PrePaid**.', example='2017-08-20T12:10:10Z', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).', example='rg-aekzw******', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model CreateCasterResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model CreateCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCasterResponseBody(name='body'),
}

/**
  * @description You must enable the production studio feature before you can call this operation to create a production studio. For more information, see [Enable the production studio feature](https://help.aliyun.com/document_detail/60361.html).
  * You can call this operation to create production studios in general mode or playlist mode. Production studios in playlist mode can be used for carousel playback.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateCaster  CreateCasterRequest
  * @return CreateCasterResponse
 */
async function createCaster(request: CreateCasterRequest): CreateCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCaster', 'POST', '/', 'json', false, 'json', request);
}

model CreateCustomTemplateRequest {
  customTemplate: string(name='CustomTemplate', description='The configuration of the template. The value is in the following JSON format: {height:xxx,scale:xxx,gop:xxx,bframes:xxx,cdesc:xxx}. All fields are required. If any field is left empty, the call fails.

>  For more information, see **Fields of the CustomTemplate parameter**.

This parameter is required.', example='{height:1080,scale:[16:9],gop:60,bframes:30,cdesc:h264}', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The name of the template.

> Record the template name. The template name is required if you want to use, query, or delete the template.

This parameter is required.', example='TestTemplate', position='Query'),
}

model CreateCustomTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0D715397-2E66-4AE1-694h-C546628AD145'),
}

model CreateCustomTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateCustomTemplateResponseBody(name='body'),
}

/**
  * @description After you call this operation to create a custom template, record the template name. When you call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task, you can set the MixStreamTemplate parameter to the name of the custom template. This way, you can use the custom template for stream mixing.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateCustomTemplate  CreateCustomTemplateRequest
  * @return CreateCustomTemplateResponse
 */
async function createCustomTemplate(request: CreateCustomTemplateRequest): CreateCustomTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCustomTemplate', 'POST', '/', 'json', false, 'json', request);
}

model CreateEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  name: string(name='Name', description='The task name. The name can contain letters, digits, hyphens (-), and underscores (_). The name must be 255 characters in length.

This parameter is required.', example='task1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamInput: string(name='StreamInput', description='The URL of the input stream.

This parameter is required.', example='rtmp://mydomain/app/stream1', position='Query'),
  streamOutput: string(name='StreamOutput', description='The URL of the output stream.

This parameter is required.', example='rtmp://testdomain/app/stream2', position='Query'),
  templateId: string(name='TemplateId', description='The template ID.

This parameter is required.', example='****96e8864746a0b6f3****', position='Query'),
}

model CreateEdgeTranscodeJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the edge transcoding task.', example='****20b48fb04483915d4f2cd8ac****'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model CreateEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to create an edge transcoding task.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateEdgeTranscodeJob  CreateEdgeTranscodeJobRequest
  * @return CreateEdgeTranscodeJobResponse
 */
async function createEdgeTranscodeJob(request: CreateEdgeTranscodeJobRequest): CreateEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateEventSubRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='9qb1****', position='Query'),
  callbackUrl: string(name='CallbackUrl', description='The callback URL. For more information about the content of the messages that are sent to the callback URL, see the Callback section in this topic.

This parameter is required.', example='http://****.com/callback', position='Query'),
  channelId?: string(name='ChannelId', description='The channel ID. You can call the [ListEventSub](https://help.aliyun.com/document_detail/2628135.html) operation to query the channel ID.

> 

*   This parameter is required if you specify the Users.N parameter.

*   If you set this parameter to \\* or do not specify this parameter, all channels are subscribed to.

*   Each application ID allows only one all-channel subscription.', example='123333', position='Query'),
  events: [ string ](name='Events', description='Subscribe to events.

This parameter is required.', position='Query'),
  users?: [ string ](name='Users', description='The user whose events you want to subscribe to. If you leave this parameter empty, the events of all users in the channel are subscribed to, including the events of the streamer and viewers. Specify this parameter in the following format:

    Users.1=****
    Users.2=****
    ......', position='Query'),
}

model CreateEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='760bad53276431c499e30dc36f6b****'),
  subscribeId?: string(name='SubscribeId', description='The subscription ID.', example='ad53276431c****'),
}

model CreateEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateEventSubResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a callback to subscribe to channel or user events. When you create a callback, you can configure parameters such as the callback URL and event type.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateEventSub  CreateEventSubRequest
  * @return CreateEventSubResponse
 */
async function createEventSub(request: CreateEventSubRequest): CreateEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateEventSub', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveAIStudioRequest {
  backgroundResourceId?: string(name='BackgroundResourceId', description='The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.', example='d0eb493192c771efba644531858c0102', position='Query'),
  backgroundResourceUrl?: string(name='BackgroundResourceUrl', description='The URL of the background material. Specify either this parameter or the BackgroundResourceId parameter.', example='https://xxx.com/1.mp4', position='Query'),
  backgroundType?: string(name='BackgroundType', description='The type of the background material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD', position='Query'),
  description?: string(name='Description', description='The custom description.', example='template 1080', position='Query'),
  height?: int32(name='Height', description='The preview height. Unit: pixels.

The following preview specifications (width × height) are supported:

*   Landscape low definition 360p (640×360)
*   Portrait low definition 360p (360×640)
*   Landscape standard definition 480p (854×480)
*   Portrait standard definition 480p (480×854)
*   Landscape high definition 720p (1280×720)
*   Portrait high definition 720p (720×1280)
*   Landscape ultra-high definition 1080p (1920×1080)
*   Portrait ultra-high definition 1080p (1080×1920)', example='1080', position='Query'),
  mattingLayout: {
    heightNormalized?: float(name='HeightNormalized', description='The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.', example='0.5'),
    positionX?: float(name='PositionX', description='The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0.3'),
    positionY?: float(name='PositionY', description='The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0.3'),
  }(name='MattingLayout', description='The layout information of the chroma-keyed material.

This parameter is required.', shrink='json', position='Query'),
  mattingType: string(name='MattingType', description='The type of chroma key. Valid values:

*   green: green-screen chroma key
*   blue: blue-screen chroma key
*   complex: background replacement

This parameter is required.', example='complex', position='Query'),
  mediaLayout?: {
    heightNormalized?: float(name='HeightNormalized', description='The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.', example='0.5'),
    positionX?: float(name='PositionX', description='The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
    positionY?: float(name='PositionY', description='The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
  }(name='MediaLayout', description='The layout information of the multimedia material.', shrink='json', position='Query'),
  mediaResourceId?: string(name='MediaResourceId', description='The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.', example='d0eb493192c771efba644531858c0102', position='Query'),
  mediaResourceUrl?: string(name='MediaResourceUrl', description='The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.', example='https://xxx.com/2.mp4', position='Query'),
  mediaType?: string(name='MediaType', description='The type of the multimedia material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  studioName: string(name='StudioName', description='The name of the virtual studio template. The name must be unique.

This parameter is required.', example='stu02', position='Query'),
  width?: int32(name='Width', description='The preview width. Unit: pixels.', example='1920', position='Query'),
}

model CreateLiveAIStudioResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='17D7526C-69AD-5761-8037-071C27358345'),
  studioId?: string(name='StudioId', description='The ID of the virtual studio template.', example='369ced1f-c33a-49e5-91da-bdaae3d6c1c2'),
}

model CreateLiveAIStudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveAIStudioResponseBody(name='body'),
}

/**
  * @description >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
  * @param request  the request parameters of CreateLiveAIStudio  CreateLiveAIStudioRequest
  * @return CreateLiveAIStudioResponse
 */
async function createLiveAIStudio(request: CreateLiveAIStudioRequest): CreateLiveAIStudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveAIStudio', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveDelayConfigRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.

This parameter is required.', example='liveApp****', position='Query'),
  delayTime: int32(name='DelayTime', description='The duration for which the playback of the live stream is delayed. The value must be an integer. Valid values: 16 to 3600. Unit: seconds.

This parameter is required.', example='60', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.

This parameter is required.', example='liveStream****', position='Query'),
  taskTriggerMode: string(name='TaskTriggerMode', description='The trigger mode. Valid values:

*   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
*   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
*   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.

This parameter is required.', example='PUBLISH_ONLY', position='Query'),
}

model CreateLiveDelayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model CreateLiveDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveDelayConfigResponseBody(name='body'),
}

/**
  * @description Stream delay is different from latency caused by streaming protocols. Stream delay is a feature that allows you to delay the playback of a live stream that is processed in the cloud.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLiveDelayConfig  CreateLiveDelayConfigRequest
  * @return CreateLiveDelayConfigResponse
 */
async function createLiveDelayConfig(request: CreateLiveDelayConfigRequest): CreateLiveDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveMessageAppRequest {
  appName?: string(name='AppName', description='The name of the application. The name must be 2 to 16 characters in length.', example='testApp', position='Query'),
  auditType?: int32(name='AuditType', description='The content moderation method. Valid values:

*   0 (default): disables content moderation.
*   1: uses built-in content moderation.
*   2: uses custom content moderation.', example='2', position='Query'),
  auditUrl?: string(name='AuditUrl', description='The URL for content moderation. If you set AuditType to 2, you must specify this parameter. The URL must start with http:// or https:// and cannot contain a private IP address or a port number. For more information about custom content moderation, see the "Custom content moderation" section of this topic.', example='http://demo.aliyundoc.com/exampleaudit', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. Valid values:

*   cn-shanghai (default)
*   ap-southeast-1: Singapore

>  When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.', example='cn-shanghai', position='Query'),
  eventCallbackUrl?: string(name='EventCallbackUrl', description='The callback URL for events, such as logon, logoff, and joining and leaving a group. If you leave this parameter empty, event callbacks are disabled. [](~~2672836~~)The callback URL must start with http:// or https:// and cannot contain a private IP address or a port number. For information about the callback message format and authentication logic, see the "Event callbacks" and "Callback authentication" sections of this topic.', example='http://demo.aliyundoc.com/examplecallback', position='Query'),
  msgLifeCycle?: int32(name='MsgLifeCycle', description='The retention period of group messages in the application. Valid values:

*   0 (default): 30 days.
*   1: 90 days.
*   2: 180 days.', example='1', position='Query'),
}

model CreateLiveMessageAppResponseBody = {
  appId?: string(name='AppId', description='The application ID. The ID is used in subsequent operations, such as joining a group.', example='demo'),
  appKey?: string(name='AppKey', description='The AppKey for authentication of this application.', example='**********************************'),
  appSign?: string(name='AppSign', description='The application signature. The signature is required when you use the interactive messaging SDK.', example='**************************************************************************'),
  dataCenter?: string(name='DataCenter', description='The data center in which the interactive messaging application was created.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='65EEDBEB-43FE-1E15-976F-3DDD753A****'),
}

model CreateLiveMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveMessageAppResponseBody(name='body'),
}

/**
  * @description *   When you call other operations to manage the interactive messaging application, you must specify the same data center in which the application is created.
  * *   You can create up to 300 interactive messaging applications in an Alibaba Cloud account.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLiveMessageApp  CreateLiveMessageAppRequest
  * @return CreateLiveMessageAppResponse
 */
async function createLiveMessageApp(request: CreateLiveMessageAppRequest): CreateLiveMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveMessageApp', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveMessageGroupRequest {
  administrators?: [ string ](name='Administrators', description='The list of administrators.', shrink='simple', position='Query'),
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  creatorId?: string(name='CreatorId', description='The ID of the group creator. The ID can be up to 64 bytes in length and can contain letters and digits.', example='uid1', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group that you want to create. The group ID must be unique within your business. The ID can be up to 64 bytes in length and can contain letters and digits.

This parameter is required.', example='grouptest', position='Query'),
  groupInfo?: string(name='GroupInfo', description='The additional information about the group. The value can be up to 32 KB in length.', example='testgroupinfo', position='Query'),
  groupName?: string(name='GroupName', description='The name of the group. The name can be up to 128 bytes in length.', example='mytestgroup', position='Query'),
}

model CreateLiveMessageGroupResponseBody = {
  alreadyDelete?: boolean(name='AlreadyDelete', description='Indicates whether the group is deleted. If the group existed and is deleted, the group ID is unavailable. We recommend that you create a new group.', example='true'),
  alreadyExists?: boolean(name='AlreadyExists', description='Indicates whether the group already exists.', example='true'),
  groupId?: string(name='GroupId', description='The ID of the group created.', example='grouptest'),
  requestId?: string(name='RequestId', description='The request ID.', example='A8C7B033-B339-1A58-B0E0-7B9197BA****'),
}

model CreateLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging application.
  * *   You can create up to 5,000 interactive messaging groups in an interactive messaging application.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLiveMessageGroup  CreateLiveMessageGroupRequest
  * @return CreateLiveMessageGroupResponse
 */
async function createLiveMessageGroup(request: CreateLiveMessageGroupRequest): CreateLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateLivePrivateLineRequest {
  accelerationArea: string(name='AccelerationArea', description='The acceleration channel.

This parameter is required.', example='ap-southeast-1', position='Query'),
  accelerationType: string(name='AccelerationType', description='The acceleration type. Valid values:

*   play: streaming acceleration
*   publish: stream ingest acceleration

This parameter is required.', example='play', position='Query'),
  appName: string(name='AppName', description='The name of the application.

This parameter is required.', example='live', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  instanceId?: string(name='InstanceId', description='The acceleration channel that you want to reuse. This parameter is required if Reuse is set to yes.', example='ga-bp1iovsdpf01ym9su****', position='Query'),
  maxBandwidth?: string(name='MaxBandwidth', description='The accelerated bandwidth. Unit: Mbit/s. This parameter is required if Reuse is set to no.', example='200', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  reuse: string(name='Reuse', description='Specifies whether to reuse an existing acceleration channel. Valid values:

*   yes: reuses an existing acceleration channel.
*   no: creates a new acceleration channel.

This parameter is required.', example='no', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='testStream', position='Query'),
  videoCenter: string(name='VideoCenter', description='The live center. Valid values: cn-beijing, cn-shanghai, cn-shenzhen, cn-qingdao, ap-northeast-1, ap-southeast-5, eu-central-1, and ap-southeast-1, which indicate China (Beijing), China (Shanghai), China (Shenzhen), China (Qingdao), Japan (Tokyo), Indonesia (Jakarta), Germany (Frankfurt), and Singapore, respectively.

This parameter is required.', example='cn-shanghai', position='Query'),
}

model CreateLivePrivateLineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7908F2FF-44F8-120F-9FD6-85AE4B6C****'),
}

model CreateLivePrivateLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLivePrivateLineResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to create a GA instance and bind it to an acceleration circuit. The granularity is at the stream level. You need to specify the access points where the acceleration circuit starts and ends.
  * *   The settings take effect only if the value of AppName and the value of StreamName are the same as the application name and stream name that are specified in the streaming URL.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLivePrivateLine  CreateLivePrivateLineRequest
  * @return CreateLivePrivateLineResponse
 */
async function createLivePrivateLine(request: CreateLivePrivateLineRequest): CreateLivePrivateLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLivePrivateLine', 'POST', '/', 'json', false, 'json', request);
}

model CreateLivePullToPushRequest {
  callbackUrl?: string(name='CallbackUrl', description='The HTTP callback URL. By default, this parameter is left empty.

> 

*   The URL is used to receive callbacks related to the task.

*   The URL can be up to 2,000 characters in length.

*   If you do not specify this parameter, no callbacks are returned for events related to the task.', example='https://callback*****.com', position='Query'),
  dstUrl: string(name='DstUrl', description='The destination URL to which the stream is relayed.

> 

*   The supported protocol for the URL is RTMP.

*   The URL can be up to 2,000 characters in length.

This parameter is required.', example='rtmp://pushtest.********.aliyunlive.com/pulltest493/pulltest-w434', position='Query'),
  endTime: string(name='EndTime', description='The end time of the task.

> 

*   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.

*   The end time must be later than the start time.

*   The end time must be later than the current time.

This parameter is required.', example='2024-08-27T14:30:00Z', position='Query'),
  fileIndex?: int32(name='FileIndex', description='The file index, which specifies the sequence of the file where the playback starts.', example='0', position='Query'),
  offset?: int32(name='Offset', description='The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.

> 

*   This parameter indicates an offset from the first frame of the first video resource in the list.

*   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region where the task is started. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatNumber?: int32(name='RepeatNumber', description='The number of playbacks after the first playback is complete. Valid values:

*   0 (default): specifies that the video list is played only once.
*   \\-1: specifies that the video list is played in loop mode.
*   Positive integer: specifies the number of times the video list repeats after the first playback is complete.

>  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='0', position='Query'),
  retryCount?: int32(name='RetryCount', description='The number of retries allowed. Default value: 3.', example='3', position='Query'),
  retryInterval?: int32(name='RetryInterval', description='The retry interval. Unit: seconds. Valid values: [60,300]. Default value: 60.', example='60', minimum=60, maximum=300, position='Query'),
  sourceProtocol?: string(name='SourceProtocol', description='The protocol of the source stream.

Valid values:

*   rtmp
*   rtsp
*   srt
*   http-flv
*   flv

>  This parameter is required if you set the **SourceType** parameter to live, but does not take effect if you set the SourceType parameter to vod or url.', example='rtmp', position='Query'),
  sourceType: string(name='SourceType', description='The type of the source stream. Valid values:

*   live: a live stream
*   vod: a list of ApsaraVideo VOD resources
*   url: a list of video resources from a third party

This parameter is required.', example='live', position='Query'),
  sourceUrls: [ string ](name='SourceUrls', description='The source URLs.

> 

*   If SourceType is set to live, you can specify only one streaming URL.

*   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.

*   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.

*   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.

*   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.

This parameter is required.', example='testurls', shrink='json', position='Query'),
  startTime: string(name='StartTime', description='The start time of the task.

> 

*   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.

This parameter is required.', example='2024-08-26T10:30:00Z', position='Query'),
  taskName?: string(name='TaskName', description='The name of the task. Default value: "". Fuzzy search for task names is supported.', example='test', position='Query'),
}

model CreateLivePullToPushResponseBody = {
  description?: string(name='Description', description='The description of the custom rule.', example='OK'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68*****'),
  retCode?: int32(name='RetCode', description='The code that is returned for the request.

> 

*   0 is returned if the request is normal.

*   For information about codes that are returned when exceptions occur, see the following Error codes table.', example='0'),
  taskId?: string(name='TaskId', description='The task ID.', example='fd245384-4067-4f91-9d75-9666a6bc9****'),
}

model CreateLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLivePullToPushResponseBody(name='body'),
}

/**
  * @description >  The pulled-stream relay feature is in public preview. You can use it free of charge. After the public preview ends, fees will be charged. The specific end time will be announced.
  * *   You can call this operation to create a pulled-stream relay task.
  * *   The pulled source can be a live stream or video-on-demand (VOD) resources.
  * *   After a task is created, it starts at the specified start time and ends at the specified end time. A task that ends is automatically deleted.
  * *   Make sure that the destination URL specified in the task is not used by another task. Otherwise, conflicts occur and stream ingest fails.
  * *   The events for pulled-stream relay callbacks include state changes of a pulled-stream relay task and exit of a pulled-stream relay task. For more information, see [Pulled-stream relay callbacks](https://help.aliyun.com/document_detail/2846768.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLivePullToPush  CreateLivePullToPushRequest
  * @return CreateLivePullToPushResponse
 */
async function createLivePullToPush(request: CreateLivePullToPushRequest): CreateLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLivePullToPush', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveRealTimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  logstore: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.

This parameter is required.', example='test_logstore', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.

This parameter is required.', example='test_project', position='Query'),
  region: string(name='Region', description='The ID of the region where the Log Service project is deployed.

This parameter is required.', example='cn-hangzhou', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreateLiveRealTimeLogDeliveryResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='F32C57AA-7BF8-49AE-A2CC-9F42390F5A19'),
}

model CreateLiveRealTimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveRealTimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description ##
  * Obtain the streaming domain, and then call this operation to configure real-time log delivery for the streaming domain.
  * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
  * ## QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of CreateLiveRealTimeLogDelivery  CreateLiveRealTimeLogDeliveryRequest
  * @return CreateLiveRealTimeLogDeliveryResponse
 */
async function createLiveRealTimeLogDelivery(request: CreateLiveRealTimeLogDeliveryRequest): CreateLiveRealTimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveRealTimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model CreateLiveStreamMonitorRequest {
  app?: string(name='App', description='The name of the application that plays the output streams of the monitoring session.

You can specify a name. If you do not specify a name, the system uses **monitor** as the name of the application.', example='monitor****', position='Query'),
  callbackUrl?: string(name='CallbackUrl', description='Supports input of callback addresses in HTTP(S) format.', example='http://guide.aliyundoc.com/notify', position='Query'),
  dingTalkWebHookUrl?: string(name='DingTalkWebHookUrl', description='DingTalk alert monitoring sends alert notifications through a DingTalk group robot. Please set up the DingTalk group robot first and enter the HTTP(S) address of the robot here. For more details, see [Custom Robot Access](https://open.dingtalk.com/document/robots/custom-robot-access).
> Configure the custom keyword for the DingTalk group robot as \\"alert\\", otherwise, messages will not be received.', example='https://oapi.dingtalk.com/robot/send?access_token=7a7d404056eee1f2fd944ace9bcfc361dc6448583e1d3d3baa****', position='Query'),
  domain: string(name='Domain', description='The endpoint of the monitoring session.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  inputList: string(name='InputList', description='The list of input streams to monitor. For more information, see the following **InputConfig** table.

This parameter is required.', example='InputConfig', position='Query'),
  monitorConfig?: string(name='MonitorConfig', description='Alarm threshold setting for monitoring, in JSON format. For more details, please refer to the table below for MonitorConfig.', example='"{\\"fpsLowThres\\": 0.6,\\"brLowThres\\": 1.1,\\"eofDurationThresSec\\": 10}"', position='Query'),
  monitorName: string(name='MonitorName', description='The name of the monitoring session.

This parameter is required.', example='liveMonitor****', position='Query'),
  outputTemplate: string(name='OutputTemplate', description='The output template of the monitoring session. Valid values:

*   **lp_ld**: low definition.
*   **lp_sd**: standard definition.
*   **lp_hd**: high definition.
*   **lp_ud**: ultra high definition.

This parameter is required.', example='lp_ud', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream?: string(name='Stream', description='The name of the output stream of the monitoring session. If you do not specify a name, the system generates a name at random.', example='monitorStream****', position='Query'),
}

model CreateLiveStreamMonitorResponseBody = {
  monitorId?: string(name='MonitorId', description='The ID of the monitoring session.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model CreateLiveStreamMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveStreamMonitorResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a monitoring session. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLiveStreamMonitor  CreateLiveStreamMonitorRequest
  * @return CreateLiveStreamMonitorResponse
 */
async function createLiveStreamMonitor(request: CreateLiveStreamMonitorRequest): CreateLiveStreamMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveStreamMonitor', 'POST', '/', 'json', false, 'json', request);
}

model CreateLiveStreamRecordIndexFilesRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all applications, specify an asterisk (\\*) as the value.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end time of the index file. TS segments that are uploaded before the end time are included in the index file. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  endTimeIncluded?: boolean(name='EndTimeIncluded', description='Specifies whether to include the end time. If you set this parameter to true, the system attempts to include one more TS segment. The created index file covers the entire time range that is specified by the StartTime and EndTime parameters.', example='false', position='Query'),
  ossBucket: string(name='OssBucket', description='The name of the OSS bucket.

This parameter is required.', example='liveBucket****', position='Query'),
  ossEndpoint: string(name='OssEndpoint', description='The endpoint of the OSS bucket.

This parameter is required.', example='cn-oss-****.aliyuncs.com', position='Query'),
  ossObject: string(name='OssObject', description='The name of the recording that is stored in OSS.

This parameter is required.', example='{AppName}/{StreamName}/{Date}/{Hour}/{Minute}_{Second}.m3u8', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', description='The start time of the index file. TS segments that are uploaded after the start time are included in the index file. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. If you want to match all streams, specify an asterisk (\\*) as the value.

This parameter is required.', example='liveStream****', position='Query'),
}

model CreateLiveStreamRecordIndexFilesResponseBody = {
  recordInfo?: {
    appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
    createTime?: string(name='CreateTime', description='The time when the index file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-27T09:40:56Z'),
    domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    duration?: float(name='Duration', description='The recording length. Unit: seconds.', example='20'),
    endTime?: string(name='EndTime', description='The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T07:40:00Z'),
    height?: int32(name='Height', description='The height of the video.', example='480'),
    ossBucket?: string(name='OssBucket', description='The name of the OSS bucket.', example='liveBucket****'),
    ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
    ossObject?: string(name='OssObject', description='The name of the recording that is stored in OSS.', example='liveObject****.m3u8'),
    recordId?: string(name='RecordId', description='The ID of the index file.', example='c4d7f0a4-b506-43f9-8de3-07732c3f****'),
    recordUrl?: string(name='RecordUrl', description='The URL of the M3U8 index file.'),
    startTime?: string(name='StartTime', description='The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*hh:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T07:36:00Z'),
    streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    width?: int32(name='Width', description='The width of the video.', example='640'),
  }(name='RecordInfo', description='The recording configuration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='550439A3-F8EC-4CA2-BB62-B9DB43EEEF30'),
}

model CreateLiveStreamRecordIndexFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateLiveStreamRecordIndexFilesResponseBody(name='body'),
}

/**
  * @description You must have configured Object Storage Service (OSS) before you call this operation. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html). ApsaraVideo Live allows you to record a live stream in the M3U8 format and store the M3U8 file in OSS. You can edit the TS segments that are included in the stored M3U8 file in real time.
  * > 
  * *   You can create an index file only after a live stream is ingested. If no live stream is available within the specified time range or the name of the specified live stream is invalid, the index file fails to be created.
  * *   The time range that is specified by the StartTime and EndTime parameters must be the duration of at least one TS segment. The default duration of a TS segment is 30 seconds.
  * *   ApsaraVideo Live stores the information about TS segments for only three months. You can create M3U8 index files only for the recordings of the last three months.
  * *   OSS stores TS segments for a time period that is specified by the storage configuration in OSS. For more information, see [Configure lifecycle rules](https://help.aliyun.com/document_detail/31904.html).
  * *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
  * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 45 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateLiveStreamRecordIndexFiles  CreateLiveStreamRecordIndexFilesRequest
  * @return CreateLiveStreamRecordIndexFilesResponse
 */
async function createLiveStreamRecordIndexFiles(request: CreateLiveStreamRecordIndexFilesRequest): CreateLiveStreamRecordIndexFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateLiveStreamRecordIndexFiles', 'POST', '/', 'json', false, 'json', request);
}

model CreateMessageAppRequest {
  appConfig?: map[string]string(name='AppConfig', description='The configurations of the application.', shrink='json', position='Body'),
  appName: string(name='AppName', description='The name of the interactive message application. The name must be 2 to 16 characters in length.

This parameter is required.', example='test', position='Body'),
  extension?: map[string]string(name='Extension', description='The extended fields.', shrink='json', position='Body'),
}

model CreateMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***'),
  }(name='Result', description='The returned result.'),
}

model CreateMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of CreateMessageApp  CreateMessageAppRequest
  * @return CreateMessageAppResponse
 */
async function createMessageApp(request: CreateMessageAppRequest): CreateMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model CreateMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='a494caec-***-695ef345db77', position='Body'),
  creatorId: string(name='CreatorId', description='The ID of the creator. The ID can be up to 36 characters in length and can contain only letters and digits.

This parameter is required.', example='as****hs', position='Body'),
  extension?: map[string]string(name='Extension', description='The extended field.', shrink='json', position='Body'),
}

model CreateMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    extension?: map[string]any(name='Extension', description='The extended field.', example='test001'),
    groupId?: string(name='GroupId', description='The ID of the message group.', example='AE35-****-T95F'),
  }(name='Result', description='The returned result.'),
}

model CreateMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMessageGroupResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of CreateMessageGroup  CreateMessageGroupRequest
  * @return CreateMessageGroupResponse
 */
async function createMessageGroup(request: CreateMessageGroupRequest): CreateMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model CreateMixStreamRequest {
  callbackConfig?: string(name='CallbackConfig', description='The callback URL. The value is a JSON array. If a callback event is triggered, ApsaraVideo Live sends an HTTP POST request to the URL. The content is included in the HTTP request body.', example='{"CallbackUrl":"http://aliyundoc.com"}', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

>  Only domain names that reside in the China (Shanghai) and China (Beijing) regions are supported.

This parameter is required.', example='example.com', position='Query'),
  inputStreamList: string(name='InputStreamList', description='The input streams. The value is a JSON array.

For more information, see **InputStreamConfig**.

This parameter is required.', example='[{"LayoutChildId":1,"ResourceType":"live","ResourceValue":"rtmp://example.net/live/f2139ec2b8d6a191068cd****ea9064d?auth_key=1600947017-0-0-0b5645fe35d21a65ab92b394bd4d****","LayoutConfig":{"FillMode":"fit","PositionRefer":"topLeft","FillPositionNormalized":[0,0],"FillSizeNormalized":[1,1]}}]', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. Valid values:

*   **MixStreamLayout-1-1**
*   **MixStreamLayout-2-1**
*   **MixStreamLayout-2-2**
*   **MixStreamLayout-2-3**
*   **MixStreamLayout-3-1**
*   **MixStreamLayout-3-2**
*   **MixStreamLayout-4-1**
*   **USERDEFINED**: If you do not use a preset layout, set this parameter to **USERDEFINED**.

>  For more information, see [Preset layouts for stream mixing](https://help.aliyun.com/document_detail/199361.html).

This parameter is required.', example='MixStreamLayout-1-1', position='Query'),
  outputConfig: string(name='OutputConfig', description='The configuration of the output stream. The value is a JSON string.

For more information, see **OutputConfig**.

This parameter is required.', example='{"AppName":"liveApp****","StreamName":"9a78fb3f5c508be0122746f677a3****","MixStreamTemplate":"lp_hd_v","ExpireDuration":"86400"}', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model CreateMixStreamResponseBody = {
  mixStreamId?: string(name='MixStreamId', description='The ID of the stream mixing task. You can specify this parameter in a request to delete the stream mixing task or query stream mixing tasks.', example='5b2a046e-74d7-385e-253f-8a5b87e4****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0D715397-2E66-4AE1-694h-C546628AD145'),
}

model CreateMixStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateMixStreamResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a stream mixing task. This operation supports preset layouts and custom layouts.
  * If you have any questions or suggestions about the use of the stream mixing feature, you are welcome to search the group ID 34935990 in DingTalk to join the developer group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateMixStream  CreateMixStreamRequest
  * @return CreateMixStreamResponse
 */
async function createMixStream(request: CreateMixStreamRequest): CreateMixStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMixStream', 'POST', '/', 'json', false, 'json', request);
}

model CreateRTCWhipStreamAddressRequest {
  appId: string(name='AppId', description='This parameter is required.', example='6a0**6dcc-xxxx-xxxx-xxxx-e**e3exxxxxx', minLength=1, maxLength=64, position='Query'),
  channelId: string(name='ChannelId', description='This parameter is required.', example='ch00000****001', minLength=1, maxLength=64, position='Query'),
  clientToken?: string(name='ClientToken', example='58E73333-xxxx-xxxx-xxxx', position='Query'),
  displayName: string(name='DisplayName', description='This parameter is required.', minLength=1, maxLength=40, position='Query'),
  expireTime?: int32(name='ExpireTime', example='43200', position='Query'),
  userId: string(name='UserId', description='This parameter is required.', example='zb0000****0001', minLength=1, maxLength=64, position='Query'),
}

model CreateRTCWhipStreamAddressResponseBody = {
  requestId?: string(name='RequestId', example='58E7**D4-xxxx-xxxx-xxxx-6B5**6Cxxxxx'),
  whipAddress?: string(name='WhipAddress', example='https://xxxxxx.media-sh.xxxxx.com/xxxxxxxxxxxx/3723a3xxxxxxxxx223c606b***5f7a2bc7c56ea5cdd0xxxxe?auth_key=17495xxxxx-xxxx-0-f013003067c78c4053f9cd0xxxxxxx&qqzr=H4sIAAAAAAAC_6pWSlayUkrOMxxxxxxrPyCxQ0lFKQTCLlKyUjM2Nj**NDQ1TEy2Mjc3xxxxxxxxxxqRYAAAD__xxxxx__xxxxxxxx'),
}

model CreateRTCWhipStreamAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRTCWhipStreamAddressResponseBody(name='body'),
}

/**
  * @param request  the request parameters of CreateRTCWhipStreamAddress  CreateRTCWhipStreamAddressRequest
  * @return CreateRTCWhipStreamAddressResponse
 */
async function createRTCWhipStreamAddress(request: CreateRTCWhipStreamAddressRequest): CreateRTCWhipStreamAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRTCWhipStreamAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateRoomRealTimeStreamAddressRequest {
  appId: string(name='AppId', description='The ID of the ARTC application. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  channelId: string(name='ChannelId', description='The ID of the channel. You can specify only one ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourChannelId', position='Query'),
  displayName: string(name='DisplayName', description='The name of the RTMP stream. The name can be up to 40 characters in length.

This parameter is required.', example='rtmp-dname', minLength=1, maxLength=40, position='Query'),
  expireTime?: int32(name='ExpireTime', description='The validity period of the RTMP URL. Unit: seconds. The default value is 36,000 seconds, which is 10 hours.', example='43200', position='Query'),
  userId: string(name='UserId', description='The ID of the user who ingests the stream over RTMP. The user ID must be different from IDs of other users in the channel. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='rtmp-uuid', minLength=1, maxLength=64, position='Query'),
}

model CreateRoomRealTimeStreamAddressResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F8DB7E25-6A35-161A-AA41-B7A658AF****'),
  rtmpAddress?: string(name='RtmpAddress', description='The RTMP ingest URL.'),
}

model CreateRoomRealTimeStreamAddressResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRoomRealTimeStreamAddressResponseBody(name='body'),
}

/**
  * @description ### [](#)Usage notes
  * To use the interactive streaming feature, you must use ApsaraVideo Real-time Communication (ARTC) SDK to join a channel and ingest streams over Real-Time Communication (RTC). In specific scenarios, you can ingest streams over Real-Time Messaging Protocol (RTMP) by using tools such as Open Broadcaster Software (OBS). Then, ApsaraVideo Live automatically converts the RTMP streams to RTC streams and distributes the RTC streams to viewers. You can call this operation to generate an ingest URL in the RTMP format. After you ingest RTMP streams, ApsaraVideo Live automatically converts the streams to RTC streams. Do not call this operation if you require only regular live streaming. To quickly ingest RTMP streams and start live streaming, see [Get started with ApsaraVideo Live](https://help.aliyun.com/document_detail/198676.html).
  * ## [](#)Procedure
  * 1.  Call this operation to generate an ingest URL in the RTMP format.
  * 2.  Ingest a stream by using the ingest URL. Other users in the channel can watch the stream.
  * 3.  Stop ingesting the stream. Other users in the channel see that the user who ingested the stream leaves the channel.
  * > 
  * *   You can repeat Steps 2 and 3 within the validity period of the ingest URL.
  * *   We recommend that you call the [DescribeChannelParticipants](https://help.aliyun.com/document_detail/610801.html) operation to query online users in the channel at regular intervals. This way, you can check whether the user who ingests the stream is still in the channel. If the user who ingests the stream is not in the channel, the stream may be interrupted. In this case, we recommend that you stop ingesting the stream and perform Step 2.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of CreateRoomRealTimeStreamAddress  CreateRoomRealTimeStreamAddressRequest
  * @return CreateRoomRealTimeStreamAddressResponse
 */
async function createRoomRealTimeStreamAddress(request: CreateRoomRealTimeStreamAddressRequest): CreateRoomRealTimeStreamAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRoomRealTimeStreamAddress', 'GET', '/', 'json', false, 'json', request);
}

model CreateRtcAsrTaskRequest {
  authKey?: string(name='AuthKey', description='The AuthKey that is used to generate the MD5 signature in callbacks.', example='abcd', position='Query'),
  autoTerminateDelay?: long(name='AutoTerminateDelay', description='The maximum latency at which the task is automatically stopped. Unit: seconds. Valid values: 1 to 10.', example='5', position='Query'),
  autoTerminateEnabled?: boolean(name='AutoTerminateEnabled', description='Specifies whether to automatically stop the task when the latency exceeds the specified limit. Default value: false.', example='true', position='Query'),
  callbackURL: string(name='CallbackURL', description='The callback URL.

This parameter is required.', example='http://xxx.com', position='Query'),
  channelID?: string(name='ChannelID', description='The ID of the channel.

>  This parameter is required and takes effect only if you set the Mode parameter to rtc.', example='channelId', position='Query'),
  language: string(name='Language', description='The source language of the audio. Valid values:

*   ja: Japanese
*   yue: Cantonese
*   fspk: mixed Mandarin and English
*   en: English
*   cn: Mandarin

This parameter is required.', example='cn', position='Query'),
  mode: string(name='Mode', description='The type of the stream. Valid values: live and rtc. The value live specifies a regular live stream, such as a Real-Time Messaging Protocol (RTMP) stream.

This parameter is required.', example='live', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  reportInterval?: long(name='ReportInterval', description='The interval at which callbacks are returned. Unit: milliseconds. Valid values: -1 and 0 to 500.

*   \\-1: accepts callbacks only for whole sentences, but not for incomplete sentences.
*   0 or an empty value: returns callbacks in real time.
*   A value that is greater than 0 and less than or equal to 500: returns callbacks at the specified interval.', example='5', position='Query'),
  rtcUserId?: string(name='RtcUserId', description='The ID of the user who ingests the stream.

>  This parameter is required and takes effect only if you set the Mode parameter to rtc. You can specify only one user ID.', example='user1', position='Query'),
  SDKAppID?: string(name='SDKAppID', description='The ID of the ApsaraVideo Real-time Communication (ARTC) application.

>  This parameter is required and takes effect only if you set the Mode parameter to rtc.', example='appId', position='Query'),
  streamURL?: string(name='StreamURL', description='The URL of the live stream.

>  This parameter is required and takes effect only if you set the Mode parameter to live.', example='rtmp://xxx', position='Query'),
  targetLanguages?: string(name='TargetLanguages', description='The language into which the subtitles are translated. Valid values:

*   cn: Chinese
*   en: English
*   ja: Japanese', example='en', position='Query'),
  translateEnabled?: boolean(name='TranslateEnabled', description='Specifies whether to enable the translation feature.', example='true', position='Query'),
}

model CreateRtcAsrTaskResponseBody = {
  description?: string(name='Description', description='The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7FF5417D-06E9-5A2C-9A70-581F6149E6C1'),
  retCode?: long(name='RetCode', description='The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.', example='2000'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='asr-a6ac15e0-9118-4b4c-9e64-306163a0****'),
}

model CreateRtcAsrTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRtcAsrTaskResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a live subtitle task that transcribes audio in a live stream to text in real time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateRtcAsrTask  CreateRtcAsrTaskRequest
  * @return CreateRtcAsrTaskResponse
 */
async function createRtcAsrTask(request: CreateRtcAsrTaskRequest): CreateRtcAsrTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRtcAsrTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateRtcMPUEventSubRequest {
  appId: string(name='AppId', description='The ID of the application.

> The ID can be up to 64 characters in length and can contain letters, digits, underscores, and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  callbackUrl: string(name='CallbackUrl', description='The callback URL.

> The callback URL can be up to 2,083 characters in length. You can use headers such as HTTP and HTTPS in callback URLs. The URL can contain letters, digits, and the following special characters: - _ ? % = # . / +

This parameter is required.', example='http://****.com/callback', position='Query'),
  channelIds?: string(name='ChannelIds', description='The ID of the channel to which you want to send mixed-stream relay event callbacks. Separate multiple channel IDs with commas (,).

> 

*   If you leave this parameter empty, you are subscribed to mixed-stream relay events of all channels in the application.

*   You cannot specify duplicate channel IDs. You can specify up to 20 channel IDs in each call.

*   The ID can be up to 64 characters in length and contain letters, digits, underscores (_), and hyphens (-).', example='yourChannelIds', position='Query'),
}

model CreateRtcMPUEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='******3B-0E1A-586A-AC29-742247******'),
  subId?: string(name='SubId', description='The ID of the subscription.', example='Sub-******9799B2C4500******'),
}

model CreateRtcMPUEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: CreateRtcMPUEventSubResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a subscription to mixed-stream relay events. You can configure parameters such as the callback URL, application to which you want to subscribe, and channel information when you create a subscription.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of CreateRtcMPUEventSub  CreateRtcMPUEventSubRequest
  * @return CreateRtcMPUEventSubResponse
 */
async function createRtcMPUEventSub(request: CreateRtcMPUEventSubRequest): CreateRtcMPUEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRtcMPUEventSub', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to add input sources, layouts, components, or an episode list to the production studio or query the layouts of the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterResponseBody(name='body'),
}

/**
  * @description *   You can delete only production studios that are closed.
  * *   When a production studio is deleted, the scenes, components, and layouts of the production studio are also deleted.
  * *   You cannot recover a deleted production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCaster  DeleteCasterRequest
  * @return DeleteCasterResponse
 */
async function deleteCaster(request: DeleteCasterRequest): DeleteCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCaster', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterComponentRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  componentId: string(name='ComponentId', description='The component ID. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.

This parameter is required.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterComponentResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can use the ID as a request parameter in the API operation that is called to query the components in the production studio, add an episode list to the production studio, or modify a component in the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880****'),
  componentId?: string(name='ComponentId', description='The component ID. You can use the ID as a request parameter in the API operation that is called to query the component in the production studio or modify the component in the production studio.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteCasterComponentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterComponentResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete a component in the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCasterComponent  DeleteCasterComponentRequest
  * @return DeleteCasterComponentResponse
 */
async function deleteCasterComponent(request: DeleteCasterComponentRequest): DeleteCasterComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterComponent', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterEpisodeRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  episodeId: string(name='EpisodeId', description='The ID of the episode. If the episode was added by calling the [AddCasterEpisode](https://help.aliyun.com/document_detail/2848068.html) operation, check the value of the response parameter EpisodeId to obtain the ID.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf932738****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterEpisodeResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID as a parameter in the request to modify the episode in the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  episodeId?: string(name='EpisodeId', description='The ID of the episode. You can specify the ID as a parameter in the request to modify the episode in the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf932738****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteCasterEpisodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterEpisodeResponseBody(name='body'),
}

/**
  * @description Before you call this operation to delete an episode in a production studio, you must obtain the ID of the production studio and the ID of the episode.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCasterEpisode  DeleteCasterEpisodeRequest
  * @return DeleteCasterEpisodeResponse
 */
async function deleteCasterEpisode(request: DeleteCasterEpisodeRequest): DeleteCasterEpisodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterEpisode', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterEpisodeGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was added by calling the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf932738****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterEpisodeGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DeleteCasterEpisodeGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterEpisodeGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation to delete an episode list in a production studio, make sure that you have called the [AddCasterEpisodeGroup](https://help.aliyun.com/document_detail/2848071.html) operation to add the episode list in the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCasterEpisodeGroup  DeleteCasterEpisodeGroupRequest
  * @return DeleteCasterEpisodeGroupResponse
 */
async function deleteCasterEpisodeGroup(request: DeleteCasterEpisodeGroupRequest): DeleteCasterEpisodeGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterEpisodeGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterLayoutRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. If the layout was added by calling the [AddCasterLayout](https://help.aliyun.com/document_detail/60249.html) operation, check the value of the response parameter LayoutId to obtain the ID.

This parameter is required.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterLayoutResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to modify a layout in the production studio, query layouts in the production studio, add a component in the production studio, or query components in the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  layoutId?: string(name='LayoutId', description='The ID of the layout. You can use the ID as a request parameter in the API operation that is used to query layouts in the production studio.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DeleteCasterLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterLayoutResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to delete a layout in the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteCasterLayout  DeleteCasterLayoutRequest
  * @return DeleteCasterLayoutResponse
 */
async function deleteCasterLayout(request: DeleteCasterLayoutRequest): DeleteCasterLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterLayout', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterProgramRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteCasterProgramResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID as a request parameter in the API operation that is used to add, delete, or modify episodes in the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DeleteCasterProgramResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterProgramResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to delete the episode list for carousel playback in the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCasterProgram  DeleteCasterProgramRequest
  * @return DeleteCasterProgramResponse
 */
async function deleteCasterProgram(request: DeleteCasterProgramRequest): DeleteCasterProgramResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterProgram', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterSceneConfigRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='b4810848-bcf9-4aef-bd4a-e6bba2d9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This parameter is required.', example='b5f8c837-ceeb-424f-b30b-68e94e86****', position='Query'),
  type: string(name='Type', description='The type of the setting that you want to delete. Valid values:

*   **Component**: component setting
*   **Layout**: layout setting
*   **All**: component and layout settings

This parameter is required.', example='Component', position='Query'),
}

model DeleteCasterSceneConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB9*********'),
}

model DeleteCasterSceneConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterSceneConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete the settings of a scene, such as the component setting, layout setting, or both of them.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteCasterSceneConfig  DeleteCasterSceneConfigRequest
  * @return DeleteCasterSceneConfigResponse
 */
async function deleteCasterSceneConfig(request: DeleteCasterSceneConfigRequest): DeleteCasterSceneConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterSceneConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCasterVideoResourceRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', description='The resource ID. If the input source was added by calling the AddCasterVideoResource operation, check the value of the response parameter ResourceId to obtain the ID.

This parameter is required.', example='05ab713c-676e-49c0-96ce-cc408da1****', position='Query'),
}

model DeleteCasterVideoResourceResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122C*******'),
}

model DeleteCasterVideoResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCasterVideoResourceResponseBody(name='body'),
}

/**
  * @description Before you call this operation to remove an input source from a production studio, make sure that you have called the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteCasterVideoResource  DeleteCasterVideoResourceRequest
  * @return DeleteCasterVideoResourceResponse
 */
async function deleteCasterVideoResource(request: DeleteCasterVideoResourceRequest): DeleteCasterVideoResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCasterVideoResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteChannelRequest {
  appId?: string(name='AppId', description='The application ID. You can specify only one application ID.', example='eo85****', position='Query'),
  channelId?: string(name='ChannelId', description='The channel ID. You can specify only one channel ID.', example='testid', position='Query'),
}

model DeleteChannelResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CF8'),
}

model DeleteChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteChannelResponseBody(name='body'),
}

/**
  * @description ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteChannel  DeleteChannelRequest
  * @return DeleteChannelResponse
 */
async function deleteChannel(request: DeleteChannelRequest): DeleteChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteChannel', 'POST', '/', 'json', false, 'json', request);
}

model DeleteCustomTemplateRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The name of the template that you want to delete. The value is a string.

This parameter is required.', example='TestTemplate', position='Query'),
}

model DeleteCustomTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC1E78D3-FA8B-4457-DEE2-6093E1232254'),
}

model DeleteCustomTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteCustomTemplateResponseBody(name='body'),
}

/**
  * @description Obtain the name of the custom stream mixing template that you want to delete, and then call this operation to delete the template.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteCustomTemplate  DeleteCustomTemplateRequest
  * @return DeleteCustomTemplateResponse
 */
async function deleteCustomTemplate(request: DeleteCustomTemplateRequest): DeleteCustomTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteCustomTemplate', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  jobId: string(name='JobId', description='The ID of the edge transcoding task.

This parameter is required.', example='****20b48fb04483915d4f2cd8ac****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteEdgeTranscodeJobResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model DeleteEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to delete an edge transcoding task.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteEdgeTranscodeJob  DeleteEdgeTranscodeJobRequest
  * @return DeleteEdgeTranscodeJobResponse
 */
async function deleteEdgeTranscodeJob(request: DeleteEdgeTranscodeJobRequest): DeleteEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model DeleteEventSubRequest {
  appId: string(name='AppId', description='The ID of the application.

This parameter is required.', example='9qb1****', position='Query'),
  subscribeId: string(name='SubscribeId', description='The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.

This parameter is required.', example='ad53276431c****', position='Query'),
}

model DeleteEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='760bad53276431c499e30dc36f6b26be'),
}

model DeleteEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteEventSubResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateEventSubscribe](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteEventSub  DeleteEventSubRequest
  * @return DeleteEventSubResponse
 */
async function deleteEventSub(request: DeleteEventSubRequest): DeleteEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteEventSub', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAIProduceRulesRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='AppName', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  rulesId?: string(name='RulesId', description='The ID of the subtitle rule.', example='445409ec-7eaa-461d -8f29-4bec2eb9****', position='Query'),
  suffixName?: string(name='SuffixName', description='The suffix of the subtitle rule.

>  Set the value to the name of the subtitle template.', example='et', position='Query'),
}

model DeleteLiveAIProduceRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91b96****'),
}

model DeleteLiveAIProduceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAIProduceRulesResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a specified subtitle rule.
  * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveAIProduceRules  DeleteLiveAIProduceRulesRequest
  * @return DeleteLiveAIProduceRulesResponse
 */
async function deleteLiveAIProduceRules(request: DeleteLiveAIProduceRulesRequest): DeleteLiveAIProduceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAIProduceRules', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAIStudioRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  studioId: string(name='StudioId', description='The ID of the template. You can obtain the ID from the response to the CreateLiveAIStudio operation.

This parameter is required.', example='369ced1f-c33a-49e5-91da-bdaae3d6c1c2', position='Query'),
}

model DeleteLiveAIStudioResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
}

model DeleteLiveAIStudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAIStudioResponseBody(name='body'),
}

/**
  * @description To delete a virtual studio template, you must first unbind the rules. Otherwise, an error occurs.
  * >  The lightweight virtual studio feature is in invitational preview. You can add up to 300 virtual studio templates.
  * @param request  the request parameters of DeleteLiveAIStudio  DeleteLiveAIStudioRequest
  * @return DeleteLiveAIStudioResponse
 */
async function deleteLiveAIStudio(request: DeleteLiveAIStudioRequest): DeleteLiveAIStudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAIStudio', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAISubtitleRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  subtitleId: string(name='SubtitleId', description='The ID of the subtitle template.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  subtitleName?: string(name='SubtitleName', description='The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.', example='sub01', position='Query'),
}

model DeleteLiveAISubtitleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
}

model DeleteLiveAISubtitleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAISubtitleResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a specified subtitle template for live streaming.
  * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveAISubtitle  DeleteLiveAISubtitleRequest
  * @return DeleteLiveAISubtitleResponse
 */
async function deleteLiveAISubtitle(request: DeleteLiveAISubtitleRequest): DeleteLiveAISubtitleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAISubtitle', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAppRecordConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DeleteLiveAppRecordConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6EBD1AC4-C34D-4AE1-963E-B688A228BE31'),
}

model DeleteLiveAppRecordConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAppRecordConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to delete a recording configuration at the application level.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveAppRecordConfig  DeleteLiveAppRecordConfigRequest
  * @return DeleteLiveAppRecordConfigResponse
 */
async function deleteLiveAppRecordConfig(request: DeleteLiveAppRecordConfigRequest): DeleteLiveAppRecordConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAppRecordConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAppSnapshotConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveAppSnapshotConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveAppSnapshotConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAppSnapshotConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete the snapshot configuration for live streams in an application. The deletion takes effect after you restart stream ingest.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveAppSnapshotConfig  DeleteLiveAppSnapshotConfigRequest
  * @return DeleteLiveAppSnapshotConfigResponse
 */
async function deleteLiveAppSnapshotConfig(request: DeleteLiveAppSnapshotConfigRequest): DeleteLiveAppSnapshotConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAppSnapshotConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAudioAuditConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

>  A value of asterisk (\\*) specifies all applications under the domain name.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

>  A value of asterisk (\\*) specifies all live streams in the application.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteLiveAudioAuditConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E******'),
}

model DeleteLiveAudioAuditConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAudioAuditConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to delete an audio moderation configuration.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveAudioAuditConfig  DeleteLiveAudioAuditConfigRequest
  * @return DeleteLiveAudioAuditConfigResponse
 */
async function deleteLiveAudioAuditConfig(request: DeleteLiveAudioAuditConfigRequest): DeleteLiveAudioAuditConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAudioAuditConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveAudioAuditNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveAudioAuditNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model DeleteLiveAudioAuditNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveAudioAuditNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for audio moderation results.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveAudioAuditNotifyConfig  DeleteLiveAudioAuditNotifyConfigRequest
  * @return DeleteLiveAudioAuditNotifyConfigResponse
 */
async function deleteLiveAudioAuditNotifyConfig(request: DeleteLiveAudioAuditNotifyConfigRequest): DeleteLiveAudioAuditNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveAudioAuditNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveCenterTransferRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='testapp', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  dstUrl?: string(name='DstUrl', description='The third-party URL to which the live stream is relayed.', example='rtmp://push.example2.aliyundoc.com/testapp1/teststream2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='teststream', position='Query'),
}

model DeleteLiveCenterTransferResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7908F2FF-44F8-120F-9FD6-85A******'),
}

model DeleteLiveCenterTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveCenterTransferResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveCenterTransfer  DeleteLiveCenterTransferRequest
  * @return DeleteLiveCenterTransferResponse
 */
async function deleteLiveCenterTransfer(request: DeleteLiveCenterTransferRequest): DeleteLiveCenterTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveCenterTransfer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveDelayConfigRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteLiveDelayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveDelayConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveDelayConfig  DeleteLiveDelayConfigRequest
  * @return DeleteLiveDelayConfigResponse
 */
async function deleteLiveDelayConfig(request: DeleteLiveDelayConfigRequest): DeleteLiveDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveDetectNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveDetectNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveDetectNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveDetectNotifyConfigResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * *   Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for video moderation results.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveDetectNotifyConfig  DeleteLiveDetectNotifyConfigRequest
  * @return DeleteLiveDetectNotifyConfigResponse
 */
async function deleteLiveDetectNotifyConfig(request: DeleteLiveDetectNotifyConfigRequest): DeleteLiveDetectNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveDetectNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveDomainRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain that you want to delete.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='94E3559F-7B6A-4A5E-AFFD-44E2A208A249'),
}

model DeleteLiveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveDomainResponseBody(name='body'),
}

/**
  * @description *   After you successfully call the DeleteLiveDomain operation, all records of the specified domain name are deleted. Exercise caution when you perform this operation.
  * *   We recommend that you restore to an A record for the domain name at the DNS provider before you remove the domain name. Otherwise, the domain name may become inaccessible. If your domain name is registered with Alibaba Cloud, log on to the [Alibaba Cloud DNS console](https://account.aliyun.com/login/login.htm?oauth_callback=https%3A%2F%2Fdns.console.aliyun.com%2F%3Fspm%3Da2c4g.11186623.0.0.3cda841fcvk7Qs\\&lang=zh) and navigate to the **Domain Name Resolution** page. Find the domain name and then click **DNS Settings** in the Actions column. On the page that appears, change the CNAME record to an A record. If your domain name is registered with another DNS provider, configure similar settings on the platform of that DNS provider.
  * *   If you want to only suspend the use of the domain name, we recommend that you call the [StopLiveDomain](https://help.aliyun.com/document_detail/88329.html) operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveDomain  DeleteLiveDomainRequest
  * @return DeleteLiveDomainResponse
 */
async function deleteLiveDomain(request: DeleteLiveDomainRequest): DeleteLiveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveDomain', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveDomainMappingRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pullDomain: string(name='PullDomain', description='The streaming domain. The type of the domain name is **liveVideo**.

This parameter is required.', example='example.com', position='Query'),
  pushDomain: string(name='PushDomain', description='The ingest domain. The type of the domain name is **liveEdge**.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveDomainMappingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveDomainMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveDomainMappingResponseBody(name='body'),
}

/**
  * @description Make sure that the streaming domain has been mapped to the ingest domain before you call this operation to delete the mapping. For more information about how to map a streaming domain to an ingest domain, see [AddLiveDomainMapping](https://help.aliyun.com/document_detail/88782.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveDomainMapping  DeleteLiveDomainMappingRequest
  * @return DeleteLiveDomainMappingResponse
 */
async function deleteLiveDomainMapping(request: DeleteLiveDomainMappingRequest): DeleteLiveDomainMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveDomainMapping', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveDomainPlayMappingRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  playDomain: string(name='PlayDomain', description='The sub-streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  pullDomain: string(name='PullDomain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveDomainPlayMappingResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveDomainPlayMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveDomainPlayMappingResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that the mapping between the main streaming domain and the sub-streaming domain is created. For more information about how to call an operation to create the mapping between a main streaming domain and a sub-streaming domain, see [AddLiveDomainPlayMapping](https://help.aliyun.com/document_detail/173091.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveDomainPlayMapping  DeleteLiveDomainPlayMappingRequest
  * @return DeleteLiveDomainPlayMappingResponse
 */
async function deleteLiveDomainPlayMapping(request: DeleteLiveDomainPlayMappingRequest): DeleteLiveDomainPlayMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveDomainPlayMapping', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveEdgeTransferRequest {
  domainName: string(name='DomainName', description='The ingest domain. You can set only one stream relay configuration for an ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveEdgeTransferResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveEdgeTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveEdgeTransferResponseBody(name='body'),
}

/**
  * @description You can call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay for a specific domain name. Ingested streams that are already relayed based on the configuration are not affected. The following table describes the scenarios in which edge stream relay takes effect or not.
  * |Scenario|Analysis|Result|
  * |---|---|---|
  * |1\\. You ingest a stream after you call the SetLiveEdgeTransfer operation to configure edge stream relay. Then, you call the DeleteLiveEdgeTransfer operation to delete the configuration.|The configuration of edge stream relay is available when you ingest the stream.|The ingested stream is not affected, and stream relay is not interrupted.|
  * |2\\. You call the DeleteLiveEdgeTransfer operation to delete the configuration of edge stream relay after you ingest a stream. Then, you disconnect and resume the ingested stream.|The configuration of edge stream relay is not available after you resume the ingested stream.|Edge stream relay does not take effect.|
  * |3\\. You call the DeleteLiveEdgeTransfer operation before you ingest a stream.|The configuration of edge stream relay is not available.|Edge stream relay does not take effect.|
  * ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveEdgeTransfer  DeleteLiveEdgeTransferRequest
  * @return DeleteLiveEdgeTransferResponse
 */
async function deleteLiveEdgeTransfer(request: DeleteLiveEdgeTransferRequest): DeleteLiveEdgeTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveEdgeTransfer', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveLazyPullStreamInfoConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

>  If you want to delete configurations of triggered stream pulling for all applications, set the value to **ali_all_app**.

This parameter is required.', example='ali_all_app', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveLazyPullStreamInfoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveLazyPullStreamInfoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveLazyPullStreamInfoConfigResponseBody(name='body'),
}

/**
  * @description This operation is application to triggered stream pulling. You can call this operation to delete a configuration of triggered stream pulling. If you set the AppName parameter to ali_all_app, configurations of triggered stream pulling for all applications under the domain name are deleted.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveLazyPullStreamInfoConfig  DeleteLiveLazyPullStreamInfoConfigRequest
  * @return DeleteLiveLazyPullStreamInfoConfigResponse
 */
async function deleteLiveLazyPullStreamInfoConfig(request: DeleteLiveLazyPullStreamInfoConfigRequest): DeleteLiveLazyPullStreamInfoConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveLazyPullStreamInfoConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveMessageGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group that you want to delete.

This parameter is required.', example='grouptest', position='Query'),
  operatorId?: string(name='OperatorId', description='The ID of the user who performs the deletion operation. The ID can be up to 64 bytes in length and can contain only letters and digits.', example='uid1', position='Query'),
}

model DeleteLiveMessageGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the deleted or non-existent group.', example='grouptest'),
  requestId?: string(name='RequestId', description='The request ID.', example='B95BE680-5A6A-1CAD-8AB1-09DFF5D6****'),
}

model DeleteLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * *   After you delete an interactive messaging group, it is no longer available. Every user in the group is notified that the group is closed.
  * *   After you delete an interactive messaging group, messages in the group are retained for 30 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveMessageGroup  DeleteLiveMessageGroupRequest
  * @return DeleteLiveMessageGroupResponse
 */
async function deleteLiveMessageGroup(request: DeleteLiveMessageGroupRequest): DeleteLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveMessageGroupMessageRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  deleterId?: string(name='DeleterId', description='The ID of the user who deletes the message. The ID must be up to 64 bytes in length and can contain letters and digits.', example='169830****', position='Query'),
  deleterInfo?: string(name='DeleterInfo', description='The additional information about the user who performs the deletion operation. The value can be up to 512 bytes in length.', example='testname', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
  messageId: string(name='MessageId', description='The ID of the message that you want to delete. Set this parameter to the value of MsgTid that you specified when you called the SendLiveMessageGroup operation. The ID must be up to 64 bytes in length and can contain letters and digits.

This parameter is required.', example='a74a8fbd3cfe4b2daa8517e4e3******', position='Query'),
}

model DeleteLiveMessageGroupMessageResponseBody = {
  groupId?: string(name='GroupId', description='The group ID.', example='grouptest'),
  messageId?: string(name='MessageId', description='The ID of the deleted or non-existent message.', example='a74a8fbd3cfe4b2daa8517e4e3******'),
  requestId?: string(name='RequestId', description='The request ID.', example='B95BE680-5A6A-1CAD-8AB1-09DFF5D6****'),
}

model DeleteLiveMessageGroupMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveMessageGroupMessageResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveMessageGroupMessage  DeleteLiveMessageGroupMessageRequest
  * @return DeleteLiveMessageGroupMessageResponse
 */
async function deleteLiveMessageGroupMessage(request: DeleteLiveMessageGroupMessageRequest): DeleteLiveMessageGroupMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveMessageGroupMessage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveMessageUserMessageRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center where the interactive messaging application is deployed. Set this parameter to the value of DataCenter that you specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation. Valid values: cn-shanghai (Shanghai) and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  deleterId?: string(name='DeleterId', description='The ID of the user who performs the deletion operation. The ID can contain only letters and digits and can be up to 64 bytes in length.', example='169830****', position='Query'),
  deleterInfo?: string(name='DeleterInfo', description='The additional information about the user who performs the deletion operation. The value can be up to 512 bytes in length.', example='username', position='Query'),
  messageId: string(name='MessageId', description='The ID of the message that you want to delete. Set this parameter to the value of MsgTid that you specified when you called the SendLiveMessageUser operation. The ID can contain only letters and digits and can be up to 64 bytes in length.

This parameter is required.', example='**********', position='Query'),
  receiverId: string(name='ReceiverId', description='The ID of the user who received the message to delete. The ID can contain only letters and digits and can be up to 64 bytes in length.

This parameter is required.', example='169830****', position='Query'),
}

model DeleteLiveMessageUserMessageResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='6CFDE7AB-571A-14EA-B072-989FF753****'),
}

model DeleteLiveMessageUserMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveMessageUserMessageResponseBody(name='body'),
}

/**
  * @description ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveMessageUserMessage  DeleteLiveMessageUserMessageRequest
  * @return DeleteLiveMessageUserMessageResponse
 */
async function deleteLiveMessageUserMessage(request: DeleteLiveMessageUserMessageRequest): DeleteLiveMessageUserMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveMessageUserMessage', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLivePackageConfigRequest {
  appName: string(name='AppName', description='App name, `*` matches all names.

This parameter is required.', example='AppName', position='Query'),
  domainName: string(name='DomainName', description='Live streaming domain (primary playback domain).

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='Live stream name, `*` matches all streams under AppName.

This parameter is required.', example='StreamName', position='Query'),
}

model DeleteLivePackageConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='72ABAD7B-B14C-52DE-B6C6-C639FECAF5AD'),
}

model DeleteLivePackageConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivePackageConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a live stream encapsulation configuration. The deletion takes effect after you re-ingest the stream.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLivePackageConfig  DeleteLivePackageConfigRequest
  * @return DeleteLivePackageConfigResponse
 */
async function deleteLivePackageConfig(request: DeleteLivePackageConfigRequest): DeleteLivePackageConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLivePackageConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLivePrivateLineRequest {
  accelerationType: string(name='AccelerationType', description='The acceleration type. Valid values:

*   play: streaming acceleration
*   publish: stream ingest acceleration

This parameter is required.', example='play', position='Query'),
  appName: string(name='AppName', description='The name of the application.

This parameter is required.', example='live', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='testStream', position='Query'),
}

model DeleteLivePrivateLineResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7908F2FF-44F8-120F-9FD6-85AE4******'),
}

model DeleteLivePrivateLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivePrivateLineResponseBody(name='body'),
}

/**
  * @description After you unbind a GA instance from an acceleration circuit, your stream ingest and streaming are no longer accelerated by the GA instance. The GA instance still exists. If you want to release the GA instance, delete it in the GA console.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLivePrivateLine  DeleteLivePrivateLineRequest
  * @return DeleteLivePrivateLineResponse
 */
async function deleteLivePrivateLine(request: DeleteLivePrivateLineRequest): DeleteLivePrivateLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLivePrivateLine', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLivePullStreamInfoConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can call [DescribeLivePullStreamConfig](https://help.aliyun.com/document_detail/2847818.htmll) operation to query the application name.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can call [DescribeLivePullStreamConfig](https://help.aliyun.com/document_detail/2847818.htmll) operation to query the stream name.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteLivePullStreamInfoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLivePullStreamInfoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivePullStreamInfoConfigResponseBody(name='body'),
}

/**
  * @description This operation is applicable to regular stream pulling. You can call this operation to delete a configuration of regular stream pulling.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLivePullStreamInfoConfig  DeleteLivePullStreamInfoConfigRequest
  * @return DeleteLivePullStreamInfoConfigResponse
 */
async function deleteLivePullStreamInfoConfig(request: DeleteLivePullStreamInfoConfigRequest): DeleteLivePullStreamInfoConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLivePullStreamInfoConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLivePullToPushRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region where the task is started. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

This parameter is required.', example='3efb43c5-18ff-49eb-92a6-005f6521****', position='Query'),
}

model DeleteLivePullToPushResponseBody = {
  description?: string(name='Description', description='The error description.', example='OK'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68*****'),
  retCode?: int32(name='RetCode', description='The code that is returned for the request.

> 

*   0 is returned if the request is normal.

*   For information about codes that are returned when exceptions occur, see the following Error codes table.', example='0'),
}

model DeleteLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLivePullToPushResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to delete a pulled-stream relay task.
  * *   If you delete a running task, the task is immediately stopped and cannot be restarted.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLivePullToPush  DeleteLivePullToPushRequest
  * @return DeleteLivePullToPushResponse
 */
async function deleteLivePullToPush(request: DeleteLivePullToPushRequest): DeleteLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLivePullToPush', 'GET', '/', 'json', false, 'json', request);
}

model DeleteLiveRealTimeLogLogstoreRequest {
  logstore: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.

This parameter is required.', example='logstore_example', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.

This parameter is required.', example='project_example', position='Query'),
  region: string(name='Region', description='The ID of the region where the Log Service project is deployed.

This parameter is required.', example='cn-hangzhou', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveRealTimeLogLogstoreResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model DeleteLiveRealTimeLogLogstoreResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveRealTimeLogLogstoreResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to delete the Logstore that is specified by a configuration of real-time log delivery. Make sure that all parameters meet the requirements when you call this operation.
  * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveRealTimeLogLogstore  DeleteLiveRealTimeLogLogstoreRequest
  * @return DeleteLiveRealTimeLogLogstoreResponse
 */
async function deleteLiveRealTimeLogLogstore(request: DeleteLiveRealTimeLogLogstoreRequest): DeleteLiveRealTimeLogLogstoreResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveRealTimeLogLogstore', 'GET', '/', 'json', false, 'json', request);
}

model DeleteLiveRealtimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The streaming domain.

Separate multiple streaming domains with commas (,).

This parameter is required.', example='example.com,example.aliyundoc.com', position='Query'),
  logstore: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.

This parameter is required.', example='logstore_example', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.

This parameter is required.', example='project_example', position='Query'),
  region: string(name='Region', description='The ID of the region where the Log Service project is deployed.

This parameter is required.', example='cn-hangzhou', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveRealtimeLogDeliveryResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model DeleteLiveRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description *
  * *   This operation is applicable to only streaming domains. If you want to configure real-tome log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
  * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveRealtimeLogDelivery  DeleteLiveRealtimeLogDeliveryRequest
  * @return DeleteLiveRealtimeLogDeliveryResponse
 */
async function deleteLiveRealtimeLogDelivery(request: DeleteLiveRealtimeLogDeliveryRequest): DeleteLiveRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model DeleteLiveRecordNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveRecordNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveRecordNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveRecordNotifyConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to delete the configuration of callbacks for live stream recording under the main streaming domain.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveRecordNotifyConfig  DeleteLiveRecordNotifyConfigRequest
  * @return DeleteLiveRecordNotifyConfigResponse
 */
async function deleteLiveRecordNotifyConfig(request: DeleteLiveRecordNotifyConfigRequest): DeleteLiveRecordNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveRecordNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveRecordVodConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveStream****', position='Query'),
}

model DeleteLiveRecordVodConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
}

model DeleteLiveRecordVodConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveRecordVodConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to delete a Live-to-VOD configuration.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveRecordVodConfig  DeleteLiveRecordVodConfigRequest
  * @return DeleteLiveRecordVodConfigResponse
 */
async function deleteLiveRecordVodConfig(request: DeleteLiveRecordVodConfigRequest): DeleteLiveRecordVodConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveRecordVodConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveSnapshotDetectPornConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can call the [DescribeLiveSnapshotDetectPornConfig](https://help.aliyun.com/document_detail/2847918.html) operation to query the application name.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveSnapshotDetectPornConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E6*******'),
}

model DeleteLiveSnapshotDetectPornConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveSnapshotDetectPornConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to delete a video moderation configuration.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveSnapshotDetectPornConfig  DeleteLiveSnapshotDetectPornConfigRequest
  * @return DeleteLiveSnapshotDetectPornConfigResponse
 */
async function deleteLiveSnapshotDetectPornConfig(request: DeleteLiveSnapshotDetectPornConfigRequest): DeleteLiveSnapshotDetectPornConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveSnapshotDetectPornConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveSnapshotNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='www.yourdomain***.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveSnapshotNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='32A96B9A-F203-4EC5-8E43-CB92E68F4I79E'),
}

model DeleteLiveSnapshotNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveSnapshotNotifyConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveSnapshotNotifyConfig  DeleteLiveSnapshotNotifyConfigRequest
  * @return DeleteLiveSnapshotNotifyConfigResponse
 */
async function deleteLiveSnapshotNotifyConfig(request: DeleteLiveSnapshotNotifyConfigRequest): DeleteLiveSnapshotNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveSnapshotNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveSpecificStagingConfigRequest {
  configId: string(name='ConfigId', description='The ID of the configuration that you want to delete. If you want to specify multiple IDs, separate them with commas (,). You can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.

This parameter is required.', example='6295', position='Query'),
  domainName: string(name='DomainName', description='The accelerated domain name.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DeleteLiveSpecificStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model DeleteLiveSpecificStagingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveSpecificStagingConfigResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Before you call this operation to delete a domain configuration in the canary release environment, you can call the [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html) operation to obtain the configuration ID.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveSpecificStagingConfig  DeleteLiveSpecificStagingConfigRequest
  * @return DeleteLiveSpecificStagingConfigResponse
 */
async function deleteLiveSpecificStagingConfig(request: DeleteLiveSpecificStagingConfigRequest): DeleteLiveSpecificStagingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveSpecificStagingConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamBlockRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteLiveStreamBlockResponseBody = {
  description?: string(name='Description', description='The result description. If the request was successful, ok is returned. If the request failed, the failure detail is returned.', example='ok'),
  requestId?: string(name='RequestId', description='The request ID.', example='B908FF89-B03C-4831-B55B-48D2A7DA0A68'),
  status?: string(name='Status', description='The status. Valid values:

*   ok: The request was successful.
*   fail: The request failed.

>  If any parameter failed to be configured, the request failed.', example='ok'),
}

model DeleteLiveStreamBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamBlockResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a configuration of stream-level region blocking.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamBlock  DeleteLiveStreamBlockRequest
  * @return DeleteLiveStreamBlockResponse
 */
async function deleteLiveStreamBlock(request: DeleteLiveStreamBlockRequest): DeleteLiveStreamBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamBlock', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamMergeRequest {
  appName: string(name='AppName', description='The name of the application that generates the output stream. You can view the application name on the [Primary/Secondary Stream Mixing](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.

This parameter is required.', example='app', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the output stream. You can view the stream name on the [Primary/Secondary Stream Mixing](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.

This parameter is required.', example='StreamName', position='Query'),
}

model DeleteLiveStreamMergeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB9*********'),
}

model DeleteLiveStreamMergeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamMergeResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamMerge  DeleteLiveStreamMergeRequest
  * @return DeleteLiveStreamMergeResponse
 */
async function deleteLiveStreamMerge(request: DeleteLiveStreamMergeRequest): DeleteLiveStreamMergeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamMerge', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamMonitorRequest {
  monitorId: string(name='MonitorId', description='The ID of the monitoring session.

>  You can obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveStreamMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model DeleteLiveStreamMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamMonitorResponseBody(name='body'),
}

/**
  * @description Before you call this operation, obtain the monitoring session ID from the response parameter **MonitorId** of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.
  * >  You cannot delete a monitoring session that is in the started state. If you try to delete it, a 400 error is reported.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamMonitor  DeleteLiveStreamMonitorRequest
  * @return DeleteLiveStreamMonitorResponse
 */
async function deleteLiveStreamMonitor(request: DeleteLiveStreamMonitorRequest): DeleteLiveStreamMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamRecordIndexFilesRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The name of the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  recordId: [ string ](name='RecordId', description='The index file IDs.

This parameter is required.', example='c4d7f0a4-b506-43f9-8de3-07732c3f****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  removeFile: string(name='RemoveFile', description='Specifies whether to delete the corresponding file in Object Storage Service (OSS) synchronously. Valid values:

*   **true**: The corresponding file in OSS is deleted.
*   **false**: The corresponding file in OSS is not deleted.

This parameter is required.', example='true', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteLiveStreamRecordIndexFilesResponseBody = {
  code?: string(name='Code', description='The status code. A return value of 500 indicates an error. For details, see the Error codes section of this topic.', example='OK'),
  message?: string(name='Message', description='The status description. A return value of 500 indicates an error. For details, see the Error codes section of this topic.', example='OK'),
  recordDeleteInfoList?: {
    recordDeleteInfo?: [ 
    {
      message?: string(name='Message', description='The processing result of each file indicated by the file ID. Valid values:

*   **OK**: The file has been deleted.
*   **AccessDenied**: Access to the file has been denied.
*   **FileNotFound**: The file fails to be found.', example='OK'),
      recordId?: string(name='RecordId', description='The ID of the index file that is used to locate the live stream recording files to be deleted.', example='c4d7f0a4-b506-43f9-8de3-07732c3f**'),
    }
  ](name='RecordDeleteInfo')
  }(name='RecordDeleteInfoList', description='The deletion information.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='939D19EE-59A0-18E9-B458-*****'),
}

model DeleteLiveStreamRecordIndexFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamRecordIndexFilesResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamRecordIndexFiles  DeleteLiveStreamRecordIndexFilesRequest
  * @return DeleteLiveStreamRecordIndexFilesResponse
 */
async function deleteLiveStreamRecordIndexFiles(request: DeleteLiveStreamRecordIndexFilesRequest): DeleteLiveStreamRecordIndexFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamRecordIndexFiles', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  template: string(name='Template', description='The transcoding template ID. Valid values:

*   Standard transcoding:

    *   lld: low definition
    *   lsd: standard definition
    *   lhd: high definition
    *   lud : ultra-high definition

*   Narrowband HD™ transcoding:

    *   ld: low definition
    *   sd: standard definition
    *   hd: high definition
    *   ud: ultra-high definition

*   Custom transcoding: a custom ID

This parameter is required.', example='lld', position='Query'),
}

model DeleteLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DeleteLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description Standard transcoding templates, Narrowband HD™ transcoding templates, and custom transcoding templates are supported for this operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamTranscode  DeleteLiveStreamTranscodeRequest
  * @return DeleteLiveStreamTranscodeResponse
 */
async function deleteLiveStreamTranscode(request: DeleteLiveStreamTranscodeRequest): DeleteLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamWatermarkRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the watermark template.

>  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
}

model DeleteLiveStreamWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64-af62-20e91b******'),
}

model DeleteLiveStreamWatermarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamWatermarkResponseBody(name='body'),
}

/**
  * @description This interface supports deleting the watermark template with the specified TemplateId for live streaming. 
  * ## QPS Limitation
  *  The per-user QPS limit for this interface is 60 times/second. Exceeding this limit will result in API throttling, which may impact your business operations. Please use it reasonably. For more information, please refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteLiveStreamWatermark  DeleteLiveStreamWatermarkRequest
  * @return DeleteLiveStreamWatermarkResponse
 */
async function deleteLiveStreamWatermark(request: DeleteLiveStreamWatermarkRequest): DeleteLiveStreamWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamWatermark', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamWatermarkRuleRequest {
  app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ruleId?: string(name='RuleId', description='The ID of the watermark rule.

>  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.', example='445409ec-7eaa-461d -8f29-4bec2eb9****', position='Query'),
  stream?: string(name='Stream', description='The name of the stream. The following matching rules apply:

*   A stream name can be exactly matched, Example: liveStreamA.
*   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
*   You can place the asterisk before or after an approximate string.

> 

*   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).

*   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.', example='liveStreamA', position='Query'),
}

model DeleteLiveStreamWatermarkRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91******'),
}

model DeleteLiveStreamWatermarkRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamWatermarkRuleResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a watermark rule with a specified ID.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamWatermarkRule  DeleteLiveStreamWatermarkRuleRequest
  * @return DeleteLiveStreamWatermarkRuleResponse
 */
async function deleteLiveStreamWatermarkRule(request: DeleteLiveStreamWatermarkRuleRequest): DeleteLiveStreamWatermarkRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamWatermarkRule', 'POST', '/', 'json', false, 'json', request);
}

model DeleteLiveStreamsNotifyUrlConfigRequest {
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteLiveStreamsNotifyUrlConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
}

model DeleteLiveStreamsNotifyUrlConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteLiveStreamsNotifyUrlConfigResponseBody(name='body'),
}

/**
  * @description Obtain the ingest domain, and then call this operation to delete the callback configuration for stream ingest under the ingest domain.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteLiveStreamsNotifyUrlConfig  DeleteLiveStreamsNotifyUrlConfigRequest
  * @return DeleteLiveStreamsNotifyUrlConfigResponse
 */
async function deleteLiveStreamsNotifyUrlConfig(request: DeleteLiveStreamsNotifyUrlConfigRequest): DeleteLiveStreamsNotifyUrlConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteLiveStreamsNotifyUrlConfig', 'POST', '/', 'json', false, 'json', request);
}

model DeleteMessageAppRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application that you want to delete. You can specify only one ID.

This parameter is required.', example='VKL3***', position='Body'),
}

model DeleteMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the application was deleted. Valid values:

*   true: The application was deleted.
*   false: The application failed to be deleted.', example='true'),
  }(name='Result', description='The returned result.'),
}

model DeleteMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteMessageApp  DeleteMessageAppRequest
  * @return DeleteMessageAppResponse
 */
async function deleteMessageApp(request: DeleteMessageAppRequest): DeleteMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model DeleteMixStreamRequest {
  appName?: string(name='AppName', description='The name of the application.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  mixStreamId: string(name='MixStreamId', description='The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.

This parameter is required.', example='749b7594-86d6-37b1-513b-e1e19845****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the output stream.', example='liveStream****', position='Query'),
}

model DeleteMixStreamResponseBody = {
  mixStreamId?: string(name='MixStreamId', description='The ID of the stream mixing task.', example='749b7594-86d6-37b1-513b-e1e19845****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BE9407FF-F897-4DBD-338D-98A750AD805F'),
}

model DeleteMixStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteMixStreamResponseBody(name='body'),
}

/**
  * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create a stream mixing task and then call this operation to delete the stream mixing task. If you no longer need a mixed stream, be sure to delete it. Mixed streams that are not deleted are continuously ingested.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteMixStream  DeleteMixStreamRequest
  * @return DeleteMixStreamResponse
 */
async function deleteMixStream(request: DeleteMixStreamRequest): DeleteMixStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteMixStream', 'POST', '/', 'json', false, 'json', request);
}

model DeletePlaylistRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeletePlaylistResponseBody = {
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to query the information about the episode list, start the episode list, or stop the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model DeletePlaylistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePlaylistResponseBody(name='body'),
}

/**
  * @description Before you call this operation to delete an episode list, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to create the episode list.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeletePlaylist  DeletePlaylistRequest
  * @return DeletePlaylistResponse
 */
async function deletePlaylist(request: DeletePlaylistRequest): DeletePlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePlaylist', 'POST', '/', 'json', false, 'json', request);
}

model DeletePlaylistItemsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  programItemIds: string(name='ProgramItemIds', description='The IDs of the episodes that you want to remove.

This parameter is required.', example='["c09f3d63-eacf-4fbf-bd48-a07a6ba7****","c10f3d63-eacf-4fbf-bd48-a07a6ba7****"]', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeletePlaylistItemsResponseBody = {
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to query the episodes in the episode list, edit the episode list, delete the episode list, query the information about the episode list, or stop the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model DeletePlaylistItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeletePlaylistItemsResponseBody(name='body'),
}

/**
  * @description Before you call this operation to remove an episode, make sure that you have called the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add the episode.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeletePlaylistItems  DeletePlaylistItemsRequest
  * @return DeletePlaylistItemsResponse
 */
async function deletePlaylistItems(request: DeletePlaylistItemsRequest): DeletePlaylistItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeletePlaylistItems', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRtcAsrTaskRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The task ID. You can obtain the ID from the response to the [CreateRtcAsrTask](https://help.aliyun.com/document_detail/2848217.html) operation.

This parameter is required.', example='asr-51c72******', position='Query'),
}

model DeleteRtcAsrTaskResponseBody = {
  description?: string(name='Description', description='The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='85F94125-B695-1FB8-A7E7-3BE7CE07EF31'),
  retCode?: long(name='RetCode', description='The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.', example='2000'),
}

model DeleteRtcAsrTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRtcAsrTaskResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteRtcAsrTask  DeleteRtcAsrTaskRequest
  * @return DeleteRtcAsrTaskResponse
 */
async function deleteRtcAsrTask(request: DeleteRtcAsrTaskRequest): DeleteRtcAsrTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRtcAsrTask', 'POST', '/', 'json', false, 'json', request);
}

model DeleteRtcMPUEventSubRequest {
  appId: string(name='AppId', description='The ID of the application.

>  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
}

model DeleteRtcMPUEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='******3B-0E1A-586A-AC29-742247******'),
}

model DeleteRtcMPUEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteRtcMPUEventSubResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to delete a subscription to mixed-stream relay events.
  * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DeleteRtcMPUEventSub  DeleteRtcMPUEventSubRequest
  * @return DeleteRtcMPUEventSubResponse
 */
async function deleteRtcMPUEventSub(request: DeleteRtcMPUEventSubRequest): DeleteRtcMPUEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteRtcMPUEventSub', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotCallbackAuthRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteSnapshotCallbackAuthResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD5'),
}

model DeleteSnapshotCallbackAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSnapshotCallbackAuthResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete the configuration of authentication for snapshot callbacks for a main streaming domain. For an ongoing live stream, the deletion takes effect after you re-ingest the stream. Snapshot callbacks for the stream are no longer authenticated.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteSnapshotCallbackAuth  DeleteSnapshotCallbackAuthRequest
  * @return DeleteSnapshotCallbackAuthResponse
 */
async function deleteSnapshotCallbackAuth(request: DeleteSnapshotCallbackAuthRequest): DeleteSnapshotCallbackAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshotCallbackAuth', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotFilesRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  createTimestampList: [ long ](name='CreateTimestampList', description='The timestamps when the snapshots that you want to delete were captured.

This parameter is required.', example='1653641526637', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  removeFile: boolean(name='RemoveFile', description='Specifies whether to also delete the corresponding file in Object Storage Service (OSS) at the same time. Value values:

*   **true**: deletes the corresponding file in OSS.
*   **false**: does not delete the corresponding file in OSS.

>  To delete the corresponding file in OSS, you must have the permissions on the OSS bucket.

This parameter is required.', example='true', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DeleteSnapshotFilesResponseBody = {
  failureCount?: int32(name='FailureCount', description='The number of snapshots that failed to be deleted.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='90F60327-ABEC-5A93-BF1F-****'),
  snapshotDeleteInfoList?: {
    snapshotDeleteInfo?: [ 
    {
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp when the snapshot was captured. Unit: milliseconds.', example='1653641526637'),
      message?: string(name='Message', description='The processing result of the snapshot. Valid values:

*   **OK**: The snapshot was deleted.
*   **FileNotFound**: The snapshot was not found.', example='OK'),
    }
  ](name='SnapshotDeleteInfo')
  }(name='SnapshotDeleteInfoList', description='The information about the snapshots.'),
  successCount?: int32(name='SuccessCount', description='The number of successful screenshot deletions.', example='1'),
}

model DeleteSnapshotFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteSnapshotFilesResponseBody(name='body'),
}

/**
  * @description You can delete only snapshots that were captured in the last year.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteSnapshotFiles  DeleteSnapshotFilesRequest
  * @return DeleteSnapshotFilesResponse
 */
async function deleteSnapshotFiles(request: DeleteSnapshotFilesRequest): DeleteSnapshotFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshotFiles', 'POST', '/', 'json', false, 'json', request);
}

model DeleteStudioLayoutRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='5c6a2a0d-f228-4a64-af62-20e91b96****', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. If the layout was added by calling the [AddStudioLayout](https://help.aliyun.com/document_detail/2848062.html) operation, check the value of the response parameter LayoutId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteStudioLayoutResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e9*****'),
}

model DeleteStudioLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DeleteStudioLayoutResponseBody(name='body'),
}

/**
  * @description You can call this operation to delete a layout in a virtual studio. You can delete only one layout in a call.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DeleteStudioLayout  DeleteStudioLayoutRequest
  * @return DeleteStudioLayoutResponse
 */
async function deleteStudioLayout(request: DeleteStudioLayoutRequest): DeleteStudioLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteStudioLayout', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAutoShowListTasksRequest {
  casterId?: string(name='CasterId', description='The ID of the production studio for which you want to query scheduled tasks.

>  If the scheduled tasks were created by calling the [InitializeAutoShowListTask](https://help.aliyun.com/document_detail/2848056.html) operation, check the value of the response parameter CasterId to obtain the ID. If you do not specify this parameter, the system queries all the scheduled tasks that belong to the user specified by the OwnerId parameter.', example='53200b81-b761-4c10-842a-a0726d97****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeAutoShowListTasksResponseBody = {
  autoShowListTasks?: string(name='AutoShowListTasks', description='The information about the scheduled tasks. The following fields are included:

*   Status: the status of the scheduled task. Valid values: 0 and 1. A value of 0 indicates that the scheduled task is paused. A value of 1 indicates that the scheduled task is started.
*   LiveTemplate: the transcoding templates.
*   TranscodeConfig: the transcoding configuration for the source URL.
*   CasterId: the ID of the production studio.', example='{"Status":0,"TranscodeConfig":{"CasterTemplate":"lp_hd", "LiveTemplate":["lhd","lsd"]}, "CasterId":"cce04ef3-2226-4865-8704-f84b8375****"}'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeAutoShowListTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeAutoShowListTasksResponseBody(name='body'),
}

/**
  * @description You can call this operation to query scheduled tasks that are used to start and stop playing an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeAutoShowListTasks  DescribeAutoShowListTasksRequest
  * @return DescribeAutoShowListTasksResponse
 */
async function describeAutoShowListTasks(request: DescribeAutoShowListTasksRequest): DescribeAutoShowListTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAutoShowListTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterChannelsRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterChannelsResponseBody = {
  channels?: {
    channel?: [ 
    {
      channelId?: string(name='ChannelId', description='The ID of the channel.

The layout references the channel ID when the channel is enabled. You can specify up to one video resource for the channel. The value of this parameter must be in the RV[Number] format, such as RV01 and RV12.', example='RV01'),
      faceBeauty?: string(name='FaceBeauty', description='The face retouching effect. Valid values: 0 (all effects), 1 (skin smoothing), 2 (skin whitening), 3 (dark circles removal), and 4 (nasolabial folds removal).', example='0'),
      resourceId?: string(name='ResourceId', description='The ID of the video resource.', example='87642866-281E-4AEA-9582-B124879****'),
      rtmpUrl?: string(name='RtmpUrl', description='The URL in the Real-Time Messaging Protocol (RTMP) format.', example='rtmp://demo.aliyundoc.com/caster/rtmperf?auth_key=****'),
      streamUrl?: string(name='StreamUrl', description='The URL of the output content in the channel.', example='http://demo.aliyundoc.com/caster/streamwsx.flv?auth_key=YYYYY'),
    }
  ](name='Channel')
  }(name='Channels', description='The channels.'),
  requestId?: string(name='RequestId', description='The request ID.', example='83C52866-281E-4AEA-9582-B124********'),
  total?: int32(name='Total', description='The total number of channels.', example='1'),
}

model DescribeCasterChannelsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterChannelsResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the channels of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterChannels  DescribeCasterChannelsRequest
  * @return DescribeCasterChannelsResponse
 */
async function describeCasterChannels(request: DescribeCasterChannelsRequest): DescribeCasterChannelsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterChannels', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterComponentsRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  componentId?: string(name='ComponentId', description='The component ID. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterComponentsResponseBody = {
  components?: {
    component?: [ 
    {
      captionLayerContent?: {
        borderColor?: string(name='BorderColor', description='The color of the text border.

Valid values: **0x000000 to 0xffffff**. If the value of this parameter is "", this parameter does not take effect.', example='0x000000'),
        borderWidthNormalized?: float(name='BorderWidthNormalized', description='The normalized value of the width of the text border. The value of this parameter equals the border width divided by the font size.

The maximum width of the text border is **16**, even if the border width calculated based on this parameter is greater than **16**.', example='0'),
        color?: string(name='Color', description='The color of the text. Valid values: **0x000000 to 0xffffff**.', example='0x000000'),
        fontName?: string(name='FontName', description='The font of the text, which is specified by the system. Valid values:

*   **KaiTi**
*   **AlibabaPuHuiTi-Regular**
*   **AlibabaPuHuiTi-Bold**
*   **NAlibabaPuHuiTi-Light**
*   **NotoSansHans-Regular**
*   **NotoSansHans-Bold**
*   **NotoSansHans-Light**

****', example='KaiTi'),
        lineSpaceNormalized?: float(name='LineSpaceNormalized', description='The line spacing, which indicates the interval between every two lines.', example='0'),
        locationId?: string(name='LocationId', description='The location ID of the component. If the value of the ComponentType parameter is caption, the LocationId parameter indicates the channel ID of the video source that is referenced by the component.', example='RV01'),
        ptsOffset?: int32(name='PtsOffset', description='The offset between the presentation timestamps (PTS) of the subtitles and the audio.

Valid values: **-10000 to 10000**. Default value: **0**.', example='0'),
        showSourceLan?: boolean(name='ShowSourceLan', description='Indicates whether the source language of the subtitles is displayed. Valid values:

*   **true**: The source language is displayed.
*   **false**: The source language is not displayed.', example='false'),
        sizeNormalized?: float(name='SizeNormalized', description='The normalized value of the font size of the subtitles. The value of this parameter equals the font size divided by the output height.``

The maximum font size of the subtitles is **1,024**, even if the font size calculated based on this parameter is greater than **1,024**. If the value of this parameter is **-1**, this parameter does not take effect.', example='0.1'),
        sourceLan?: string(name='SourceLan', description='The source language of the audio in the video source. Valid values:

*   **en**: English
*   **cn**: Chinese
*   **es**: Spanish
*   **ru**: Russian', example='cn'),
        targetLan?: string(name='TargetLan', description='The target language of the audio in the video source. Valid values:

*   **en**: English
*   **cn**: Chinese
*   **es**: Spanish
*   **ru**: Russian', example='cn'),
        wordCountPerLine?: int32(name='WordCountPerLine', description='The maximum number of words displayed in each line.', example='15'),
        wordSpaceNormalized?: float(name='WordSpaceNormalized', description='The word spacing, which indicates the interval between every two words.', example='0'),
        wordsCount?: int32(name='WordsCount', description='The number of words displayed on the component. The value of this parameter can be specified based on the font size.

Valid values: **10 to 50**.', example='35'),
      }(name='CaptionLayerContent', description='The information about the subtitle component.'),
      componentId?: string(name='ComponentId', description='The component ID.', example='72d2ec7a-4cd7-4a01-974b-7cd53947****'),
      componentLayer?: {
        heightNormalized?: float(name='HeightNormalized', description='The normalized value for heights of the elements in the layer. The widths of the elements are proportionally scaled based on this parameter.

If the value of this parameter is **0**, the elements in the layer are not scaled.', example='0.5'),
        positionNormalizeds?: {
          position?: [ float ](name='Position')
        }(name='PositionNormalizeds', description='The normalized value of the position of the layer, in the format of `[x,y]`. Example: `[0,0]`.

>  The values of x and y need to be normalized.'),
        positionRefer?: string(name='PositionRefer', description='The reference coordinates of the layer. Valid values:

*   **topLeft**: the upper-left corner
*   **topRight**: the upper-right corner
*   **bottomLeft**: the lower-left corner
*   **bottomRight**: the lower-right corner', example='topLeft'),
        transparency?: int32(name='Transparency', description='The transparency of the layer. Valid values: 0 to 255.

A value of **0** indicates that the layer is completely transparent. A value of **255** indicates that the layer is completely opaque.', example='200'),
        widthNormalized?: float(name='WidthNormalized', description='The normalized value for widths of the elements in the layer. The heights of the elements are proportionally scaled based on this parameter. If the value of this parameter is **0**, the elements in the layer are not scaled.

>  This parameter conflicts with the HeightNormalized parameter. If both of them are specified, only the HeightNormalized parameter takes effect. If only one of them is specified, the latest specified value is used.', example='0.5'),
      }(name='ComponentLayer', description='The information about the component layer, such as the size and layout.'),
      componentName?: string(name='ComponentName', description='The name of the component. By default, the name is the ID of the component.', example='component_name'),
      componentType?: string(name='ComponentType', description='The type of the component. Valid values:

*   **text**: a text component
*   **image**: an image component
*   **caption**: a caption component', example='text'),
      effect?: string(name='Effect', description='The display effect for the component. Valid values:

*   **none**
*   **animateH**: horizontal scrolling
*   **animateV**: vertical scrolling', example='animateV'),
      imageLayerContent?: {
        materialId?: string(name='MaterialId', description='The ID of the material from the media library.', example='6cf724c6ebfd4a59b5b3cec6f10d****'),
      }(name='ImageLayerContent', description='The information about the image component. This parameter is returned only for image components.'),
      locationId?: string(name='LocationId', description='The location ID of the component.

Each location ID can be assigned to only one component and must be in the RC[Number] format. The values of this parameter are in ascending order, for example, from RC01 to RC12.', example='RC01'),
      textLayerContent?: {
        borderColor?: string(name='BorderColor', description='The color of the text border. Valid values: **0x000000 to 0xffffff**. If the value of this parameter is **""**, this parameter does not take effect.', example='0x000000'),
        borderWidthNormalized?: float(name='BorderWidthNormalized', description='The normalized value of the width of the text border. The value of this parameter equals the border width divided by the font size.****

The maximum width of the text border is **16**, even if the border width calculated based on this parameter is greater than **16**.', example='0'),
        color?: string(name='Color', description='The color of the text. Valid values: **0x000000 to 0xffffff**.', example='0xff0000'),
        fontName?: string(name='FontName', description='The font of the text, which is specified by the system. Valid values:

*   **KaiTi**
*   **AlibabaPuHuiTi-Regular**
*   **AlibabaPuHuiTi-Bold**
*   **NAlibabaPuHuiTi-Light**
*   **NotoSansHans-Regular**
*   **NotoSansHans-Bold**
*   **NotoSansHans-Light**

****', example='KaiTi'),
        sizeNormalized?: float(name='SizeNormalized', description='The normalized value of the font size of the text.

The value of this parameter equals the font size divided by the output height.**** The maximum font size of the text is **1,024**, even if the font size calculated based on this parameter is greater than **1,024**. If the value of this parameter is **-1**, this parameter does not take effect.', example='16'),
        text?: string(name='Text', description='The content of the text.', example='hello world'),
      }(name='TextLayerContent', description='The information about the text component. This parameter is returned only for text components.'),
    }
  ](name='Component')
  }(name='Components', description='The components.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3be7ade8-d907-483c-b24a-0dad45******'),
  total?: int32(name='Total', description='The total number of entries.', example='3'),
}

model DescribeCasterComponentsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterComponentsResponseBody(name='body'),
}

/**
  * @description You can call the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation to add components to a production studio and then call this operation to query the components of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterComponents  DescribeCasterComponentsRequest
  * @return DescribeCasterComponentsResponse
 */
async function describeCasterComponents(request: DescribeCasterComponentsRequest): DescribeCasterComponentsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterComponents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterConfigRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterConfigResponseBody = {
  autoSwitchUrgentConfig?: string(name='AutoSwitchUrgentConfig', description='The configuration for automatic switchover to the standby resource. The `eofThres` field specifies the duration after which the production studio automatically switches to the standby resource if a stream interruption occurs. Unit: seconds.', example='{"eofThres":3}'),
  autoSwitchUrgentOn?: string(name='AutoSwitchUrgentOn', description='Indicates whether the production studio automatically switches to the standby resource in case of a stream interruption.

*   **true**
*   **false**', example='true'),
  callbackUrl?: string(name='CallbackUrl', description='The callback URL.', example='http://learn.aliyundoc.com/callBackLive'),
  casterId?: string(name='CasterId', description='The ID of the production studio.', example='LIVEPRODUCER_POST-cn-0pp1czt****'),
  casterName?: string(name='CasterName', description='The name of the production studio.', example='coco-caster10'),
  channelEnable?: int32(name='ChannelEnable', description='Indicates whether channels are enabled for the production studio. Valid values:

*   **0**: Channels are disabled.
*   **1**: Channels are enabled.', example='1'),
  delay?: float(name='Delay', description='Indicates whether stream delay is enabled. Unit: seconds.

*   **0**: Stream delay is disabled.
*   **A value greater than 0**: Stream delay is enabled.', example='0'),
  domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
  programEffect?: int32(name='ProgramEffect', description='Indicates whether the carousel playback feature is enabled. Valid values:

*   **0**: The carousel playback feature is disabled.
*   **1**: The carousel playback feature is enabled.', example='0'),
  programName?: string(name='ProgramName', description='The name of the playlist for carousel playback.', example='program_name'),
  recordConfig?: {
    onDemand?: int32(name='OnDemand', description='On-demand recording. Values:
- 0: Off. 
- 1: Via HTTP callback. 
- 2: Parse streaming parameters for on-demand recording. 
- 7: Default to not record.', example='0'),
    ossBucket?: string(name='OssBucket', description='The OSS bucket for storage.', example='liveBucket****'),
    ossEndpoint?: string(name='OssEndpoint', description='The Object Storage Service (OSS) endpoint.', example='oss-cn-shanghai.aliyundoc.com'),
    recordFormat?: {
      recordFormat?: [ 
      {
        cycleDuration?: int32(name='CycleDuration', description='The length of the recording.', example='3600'),
        format?: string(name='Format', description='The format of the recording.', example='M3U8'),
        ossObjectPrefix?: string(name='OssObjectPrefix', description='The name of the recording.', example='record/{liveApp****}/{liveStream****}'),
        sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix', description='The name of the segment.', example='record/{liveApp****}/{liveStream****}/{UnixTimestamp****}'),
      }
    ](name='RecordFormat')
    }(name='RecordFormat', description='The recording configuration.'),
  }(name='RecordConfig', description='The recording configuration. If this parameter is empty, the recording feature is disabled.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='97df6b7f-3490-47d2-ac50-8833e1b64597'),
  sideOutputUrl?: string(name='SideOutputUrl', description='The custom stream redirect URL.', example='rtmp://sophon-developer.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-ac8c628078541d7055a170ec59a5****'),
  sideOutputUrlList?: string(name='SideOutputUrlList', description='The list of custom stream redirect URLs.', example='rtmp://sophon-developer.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-ac8c628078541d7055a170ec59a5****'),
  syncGroupsConfig?: {
    syncGroup?: [ 
    {
      hostResourceId?: string(name='HostResourceId', description='The ID of the resource in the production studio.', example='28768383240243****'),
      mode?: int32(name='Mode', description='The cache mode of the Static Page Caching policy. Valid values:

*   0: standard mode
*   1: force mode
*   2: no cache', example='0'),
      resourceIds?: {
        resourceId?: [ string ](name='ResourceId')
      }(name='ResourceIds', description='The IDs of the resources for which you want to modify the resource group. The number of resource IDs is 1 to 50.'),
    }
  ](name='SyncGroup')
  }(name='SyncGroupsConfig', description='The storage configuration.'),
  transcodeConfig?: {
    casterTemplate?: string(name='CasterTemplate', description='The transcoding template of the production studio. Valid values:

*   **lp_ld**: low definition
*   **lp_sd**: standard definition
*   **lp_hd**: high definition
*   **lp_ud**: ultra high definition
*   **lp_ld_v**: low definition (portrait mode)
*   **lp_sd_v**: standard definition (portrait mode)
*   **lp_hd_v**: high definition (portrait mode)
*   **lp_ud_v**: ultra high definition (portrait mode)', example='lp_hd'),
    customParams?: {
      video?: {
        bitrate?: int32(name='bitrate', description='The video bitrate.', example='300'),
        fps?: int32(name='fps', description='The video frame rate.', example='300'),
        height?: int32(name='height', description='The video height. Unit: pixels.', example='720'),
        width?: int32(name='width', description='The video width. Unit: pixels.', example='1080'),
      }(name='video', description='The video parameters.'),
    }(name='CustomParams', description='The custom settings.'),
    liveTemplateIds?: {
      locationId?: [ string ](name='LocationId')
    }(name='LiveTemplateIds', description='The transcoding setting for live streams.'),
  }(name='TranscodeConfig', description='The transcoding configuration.'),
  urgentImageId?: string(name='UrgentImageId', description='Prepared broadcast image media asset ID.', example='a089175eb5f4427684fc0715159a****'),
  urgentImageUrl?: string(name='UrgentImageUrl', description='URL of the standby image material.', example='http://learn.aliyundoc.com/AppName/image.jpg'),
  urgentLiveStreamUrl?: string(name='UrgentLiveStreamUrl', description='The URL of the standby live stream.', example='rtmp://demo.aliyundoc.com'),
  urgentMaterialId?: string(name='UrgentMaterialId', description='The ID of the material that is used as the standby video from the media library.', example='98646538-bcf9-4aef-bd4a-e6bb76588****'),
}

model DescribeCasterConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterConfigResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the configurations of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterConfig  DescribeCasterConfigRequest
  * @return DescribeCasterConfigResponse
 */
async function describeCasterConfig(request: DescribeCasterConfigRequest): DescribeCasterConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterLayoutsRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  layoutId?: string(name='LayoutId', description='The ID of the layout.

If you do not specify a layout ID, all layouts of the production studio are queried.', example='72d2ec7a-4cd7-4a01-974b-7cd53947****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterLayoutsResponseBody = {
  layouts?: {
    layout?: [ 
    {
      audioLayers?: {
        audioLayer?: [ 
        {
          fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles.

Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.', example='20'),
          validChannel?: string(name='ValidChannel', description='The sound channels that are used for volume input in the audio layer. Valid values:

*   **leftChannel**: the left channel
*   **rightChannel**: the right channel
*   **all** (default): both the left and right channels', example='all'),
          volumeRate?: float(name='VolumeRate', description='The normalized value of the height of the audio layer. The width of the audio layer is proportionally scaled based on this parameter.

>  The default value is **0**, which indicates that the audio layer is not scaled.', example='1'),
        }
      ](name='AudioLayer')
      }(name='AudioLayers', description='The configurations of the audio layers.'),
      blendList?: {
        locationId?: [ string ](name='LocationId')
      }(name='BlendList', description='The location IDs of the video layers, which are in the same order as the video layers.'),
      layoutId?: string(name='LayoutId', description='The ID of the layout.', example='72d2ec7a-4cd7-4a01-974b-7cd53947****'),
      mixList?: {
        locationId?: [ string ](name='LocationId')
      }(name='MixList', description='The location IDs of the audio layers, which are in the same order as the audio layers.'),
      videoLayers?: {
        videoLayer?: [ 
        {
          fillMode?: string(name='FillMode', description='The scaling mode of the video layer. Valid values:

*   **none** (default): specifies that the video layer is not scaled. The video layer is displayed based on its original size.
*   **fit**: specifies that the video layer is adapted to the fill area. The video layer is displayed based on the fill area. In this case, the video layer is scaled proportionally, with its original aspect ratio retained. The video layer is placed in the center, with its longer sides aligned with the fill area. If the aspect ratio of the video layer is different from that of the fill area, the content of the lower layer is displayed alongside the shorter sides. If there is no lower layer, black bars are displayed instead.', example='fit'),
          fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles.

Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.', example='20'),
          heightNormalized?: float(name='HeightNormalized', description='The normalized value of the height of the video layer.

*   If the FillMode parameter of the video layer is set to none, the width of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
*   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.', example='0.5'),
          positionNormalizeds?: {
            position?: [ float ](name='Position')
          }(name='PositionNormalizeds', description='The normalized value of the position of the video layer, in the format of `[x,y]`. Default value: `[0,0]`.

>  The values of x and y are normalized.'),
          positionRefer?: string(name='PositionRefer', description='The reference coordinates of the video layer. Valid values:

*   **topLeft** (default): the upper-left corner
*   **topRight**: the upper-right corner
*   **bottomLeft**: the lower-left corner
*   **bottomRight**: the lower-right corner
*   **center**: the center
*   **topCenter**: the upper center
*   **bottomCenter**: the lower center
*   **leftCenter**: the left center
*   **rightCenter**: the right center', example='topLeft'),
          widthNormalized?: float(name='WidthNormalized', description='The normalized value of the width of the video layer.

*   If the FillMode parameter of the video layer is set to none, the height of the video layer is scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
*   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.', example='0.5'),
        }
      ](name='VideoLayer')
      }(name='VideoLayers', description='The configurations of the video layers, which are in the default array sequence.'),
    }
  ](name='Layout')
  }(name='Layouts', description='The layouts.'),
  requestId?: string(name='RequestId', description='The request ID.', example='The normalized value of the width of the video layer image.

*   If the FillMode parameter of the video layer is set to none, the height of the video image is scaled based on this parameter. The default value is **0**, which indicates that the video image is displayed in the original size.
*   If the FillMode parameter of the video layer is set to fit, the value of the parameter is greater than **0**.'),
  total?: int32(name='Total', description='The total number of entries.', example='3'),
}

model DescribeCasterLayoutsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterLayoutsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query layouts of a production studio. If no layout ID is specified, the operation returns all layouts of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterLayouts  DescribeCasterLayoutsRequest
  * @return DescribeCasterLayoutsResponse
 */
async function describeCasterLayouts(request: DescribeCasterLayoutsRequest): DescribeCasterLayoutsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterLayouts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterProgramRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T10:00:00Z', position='Query'),
  episodeId?: string(name='EpisodeId', description='The ID of the episode.', example='1872639A-F203-4EC5-8E43-CB92E68F****', position='Query'),
  episodeType?: string(name='EpisodeType', description='The type of the episode. Valid values:

*   **Resource**: a video resource
*   **Component**: a component', example='Resource', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number.', example='5', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T09:00:00Z', position='Query'),
  status?: int32(name='Status', description='The status of the episode. Valid values:

*   **0**: The episode is not played.
*   **1**: The episode is being played.
*   **2**: The playback of the episode is complete.', example='0', position='Query'),
}

model DescribeCasterProgramResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio.', example='LIVEPRODUCER_POST-cn-0pp1czt****'),
  episodes?: {
    episode?: [ 
    {
      componentIds?: {
        componentId?: [ string ](name='ComponentId')
      }(name='ComponentIds', description='The components.'),
      endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-06-29T10:02:00Z'),
      episodeId?: string(name='EpisodeId', description='The ID of the episode.', example='1872639A-F203-4EC5-8E43-CB92E68F****'),
      episodeName?: string(name='EpisodeName', description='The name of the episode.', example='program_name_1'),
      episodeType?: string(name='EpisodeType', description='The type of the episode. Valid values:

*   **Resource**: a video resource
*   **Component**: a component', example='Resource'),
      resourceId?: string(name='ResourceId', description='The ID of the video resource.', example='1872639A-F203-4EC5-8E43-CB92E837****'),
      startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-06-29T09:00:00Z'),
      status?: int32(name='Status', description='The status of the episode.', example='0'),
      switchType?: string(name='SwitchType', description='The policy for switching episodes. Valid values:

*   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
*   **ContentFirst**: The episode starts and ends as scheduled.', example='TimeFirst'),
    }
  ](name='Episode')
  }(name='Episodes', description='The list of the episodes.'),
  programEffect?: int32(name='ProgramEffect', description='Indicates whether carousel playback is enabled.

*   **0**: Carousel playback is disabled.
*   **1**: Carousel playback is enabled.', example='1'),
  programName?: string(name='ProgramName', description='The name of the episode list.', example='programs_name'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  total?: int32(name='Total', description='The total number of entries.', example='1'),
}

model DescribeCasterProgramResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterProgramResponseBody(name='body'),
}

/**
  * @description You can call this operation to query episodes in the episode list for carousel playback. The supported types of episodes include video resource and component.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterProgram  DescribeCasterProgramRequest
  * @return DescribeCasterProgramResponse
 */
async function describeCasterProgram(request: DescribeCasterProgramRequest): DescribeCasterProgramResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterProgram', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterSceneAudioRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance Name column.

This parameter is required.', example='97df6b7f-3490-47d2-ac50-88338765****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This parameter is required.', example='97df6b7f-3490-47d2-ac50-88339087****', position='Query'),
}

model DescribeCasterSceneAudioResponseBody = {
  audioLayers?: {
    audioLayer?: [ 
    {
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the audio layer. Unit: milliseconds.', example='2000'),
      validChannel?: string(name='ValidChannel', description='The sound channel type of the audio layer. Valid values:

*   **left**: the left channel
*   **right**: the right channel
*   **all** (default): both the left and right channels', example='all'),
      volumeRate?: float(name='VolumeRate', description='The volume of the audio layer.', example='1'),
    }
  ](name='AudioLayer')
  }(name='AudioLayers', description='The configurations of the audio layers.'),
  casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID in a request to start a scene in the production studio.', example='97df6b7f-3490-47d2-ac50-88338765****'),
  followEnable?: int32(name='FollowEnable', description='The audio mode. By default, the audio follows video (AFV) mode is used. Valid values:

*   **0**: the audio mixing mode
*   **1**: the AFV mode', example='1'),
  mixList?: {
    locationId?: [ string ](name='LocationId')
  }(name='MixList'),
  requestId?: string(name='RequestId', description='The request ID.', example='98745637-3490-47d2-ac50-883387567098'),
}

model DescribeCasterSceneAudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterSceneAudioResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the audio configurations of a scene in the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeCasterSceneAudio  DescribeCasterSceneAudioRequest
  * @return DescribeCasterSceneAudioResponse
 */
async function describeCasterSceneAudio(request: DescribeCasterSceneAudioRequest): DescribeCasterSceneAudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterSceneAudio', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterScenesRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId?: string(name='SceneId', description='The ID of the scene.', example='b5f8c837-ceeb-424f-b30b-68e94e86****', position='Query'),
}

model DescribeCasterScenesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='The ID of the scene.'),
  sceneList?: {
    scene?: [ 
    {
      componentIds?: {
        componentId?: [ string ](name='componentId')
      }(name='ComponentIds', description='The components.'),
      layoutId?: string(name='LayoutId', description='The ID of the layout.', example='37cb2f8b-f152-4338-b928-6704f71d****'),
      outputType?: string(name='OutputType', description='Indicates whether the output video is in PVW mode or PGM mode. Valid values:

*   **0**: in PVW mode.
*   **1**: in PGM mode.', example='0'),
      sceneId?: string(name='SceneId', description='The ID of the scene. You can use the ID as a request parameter in the API operation that is used to modify the audio configurations of the scene, query the audio configurations of the scene, start the scene, or stop the scene.', example='b5f8c837-ceeb-424f-b30b-68e94e86****'),
      sceneName?: string(name='SceneName', description='The name of the scene.', example='scene1'),
      status?: int32(name='Status', description='The status of the scene. Valid values:

*   **0**: disabled
*   **1**: enabled', example='0'),
      streamInfos?: {
        streamInfo?: [ 
        {
          outputStreamUrl?: string(name='OutputStreamUrl', description='The streaming URL.', example='http://live/caster/example.net'),
          transcodeConfig?: string(name='TranscodeConfig', description='The transcoding configuration. Valid values:

*   **sd**: standard definition
*   **lld**: low definition
*   **lud**: ultra-high definition
*   **lhd**: high definition', example='lld'),
          videoFormat?: string(name='VideoFormat', description='The format. Valid values:

*   **flv**
*   **mp4**
*   **m3u8**', example='flv'),
        }
      ](name='StreamInfo')
      }(name='StreamInfos', description='The information about the stream.'),
      streamUrl?: string(name='StreamUrl', description='The URL of the output stream.', example='rtmp://developer.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-ac8c628078541d7055a170ec59a5****'),
    }
  ](name='Scene')
  }(name='SceneList', description='The scenes.'),
  total?: int32(name='Total', description='The total number of entries.', example='2'),
}

model DescribeCasterScenesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterScenesResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio and then call this operation to query the scenes of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeCasterScenes  DescribeCasterScenesRequest
  * @return DescribeCasterScenesResponse
 */
async function describeCasterScenes(request: DescribeCasterScenesRequest): DescribeCasterScenesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterScenes', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterStreamUrlRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~) interface, check the value of the CasterId parameter in the response.

If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:

Production Studios > Production Studio Management

>  The CasterId is reflected in the Name column on the Production Studio Management page.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterStreamUrlResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  casterStreams?: {
    casterStream?: [ 
    {
      outputType?: int32(name='OutputType', description='Indicates whether the output stream is in preview mode or program mode.

*   **0**: indicates that the output videos of the scene are in preview mode.
*   **1**: indicates that the output videos of the scene are in program mode.', example='1'),
      rtmpUrl?: string(name='RtmpUrl', description='The Real Time Messaging Protocol (RTMP) URL.', example='rtmp://live/caster/example.edu'),
      sceneId?: string(name='SceneId', description='The ID of the scene.', example='23ca74e0-aca3-4e7a-8561-9d96f525****'),
      streamInfos?: {
        streamInfo?: [ 
        {
          outputStreamUrl?: string(name='OutputStreamUrl', description='The streaming URL.', example='http://out/caster/example.net'),
          transcodeConfig?: string(name='TranscodeConfig', description='The resolution to which the scene transcodes the stream for playback. Valid values:

*   **lsd**: standard definition.
*   **lld**: low definition.
*   **lud**: ultra high definition.
*   **lhd**: high definition.', example='lld'),
          videoFormat?: string(name='VideoFormat', description='The format to which the scene transcodes the stream for playback. Valid values:

*   **flv**.
*   **rtmp**.
*   **m3u8**.', example='flv'),
        }
      ](name='StreamInfo')
      }(name='StreamInfos', description='The information about the stream.'),
      streamUrl?: string(name='StreamUrl', description='The streaming URL.', example='http://live/caster/example.org'),
    }
  ](name='CasterStream')
  }(name='CasterStreams', description='The information about the streams of the production studio.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  total?: int32(name='Total', description='The number of streams that were returned.', example='1'),
}

model DescribeCasterStreamUrlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterStreamUrlResponseBody(name='body'),
}

/**
  * @description You must create a production studio before calling this operation to query the information.
  * ## QPS limit
  * A single user can perform a maximum of 15 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
  * @param request  the request parameters of DescribeCasterStreamUrl  DescribeCasterStreamUrlRequest
  * @return DescribeCasterStreamUrlResponse
 */
async function describeCasterStreamUrl(request: DescribeCasterStreamUrlRequest): DescribeCasterStreamUrlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterStreamUrl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCasterVideoResourcesRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeCasterVideoResourcesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
  total?: int32(name='Total', description='The total number of returned entries.', example='2'),
  videoResources?: {
    videoResource?: [ 
    {
      beginOffset?: int32(name='BeginOffset', description='The offset of the position where the system starts to read the video resource. This parameter takes effect only if the input source is a video file. Unit: milliseconds.

A value **greater than 0** indicates an offset from the first frame.', example='1000'),
      endOffset?: int32(name='EndOffset', description='The offset of the position where the system stops reading the video file. This parameter takes effect only if the input source is a video file. Unit: milliseconds.

*   A value greater than **0** indicates an offset from the first frame.
*   A value smaller than **0** indicates an offset from the last frame.', example='10000'),
      flvUrl?: string(name='FlvUrl', description='The source URL.', example='http://guide.aliyundoc.com/example.org'),
      imageId?: string(name='ImageId', description='The image ID.', example='a089175eb5f4427684fc0715159a****'),
      imageUrl?: string(name='ImageUrl', description='The image URL.', example='http://learn.aliyundoc.com/AppName/image.jpg'),
      liveStreamUrl?: string(name='LiveStreamUrl', description='The URL of the live stream.', example='rtmp://abcLive/appName/b5447c21fcfe444c9e9b6f7ba208****'),
      locationId?: string(name='LocationId', description='The position of the video resource.', example='RV01'),
      materialId?: string(name='MaterialId', description='The material ID.', example='d2c429cd907742ee8f6e76465ad3****'),
      ptsCallbackInterval?: int32(name='PtsCallbackInterval', description='The interval between presentation timestamp (PTS) callbacks. If you set the value to 0, the PTS callback is disabled. This parameter is returned only when the video resource is a video-on-demand (VOD) file.', example='0'),
      repeatNum?: int32(name='RepeatNum', description='The number of playback times after the first playback is complete. This parameter takes effect only when the input source is a video file. Valid values:

*   **0** (default): The video file is played only once.
*   **-1**: The video file is played in loop mode.', example='0'),
      resourceId?: string(name='ResourceId', description='The resource ID.', example='b5f8c837-ceeb-424f-b30b-68e94e86****'),
      resourceName?: string(name='ResourceName', description='The resource name.', example='resource-Name1'),
      vodUrl?: string(name='VodUrl', description='The URL of the VOD file.

This parameter is returned only when the video resource is an MP4, FLV, or TS file that is not from the media library.', example='http://developer.aliyundoc.com/caster1.flv'),
    }
  ](name='VideoResource')
  }(name='VideoResources', description='The input sources.'),
}

model DescribeCasterVideoResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCasterVideoResourcesResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to query the input sources of the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasterVideoResources  DescribeCasterVideoResourcesRequest
  * @return DescribeCasterVideoResourcesResponse
 */
async function describeCasterVideoResources(request: DescribeCasterVideoResourcesRequest): DescribeCasterVideoResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasterVideoResources', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCastersRequest {
  casterId?: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the ApsaraVideo Live console and click Production Studios in the left-side navigation pane.

> 

*   You can find the ID of the production studio in the Instance ID/Name column.

*   If you leave this parameter empty, the data of all production studios is returned.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  casterName?: string(name='CasterName', description='The name of the production studio.', example='liveCaster****', position='Query'),
  chargeType?: int32(name='ChargeType', description='The billing method. Valid values:

*   0: the subscription billing method
*   1: the pay-as-you-go billing method', example='0', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2016-06-29T11:00:00Z', position='Query'),
  normType?: string(name='NormType', description='The type of the production studio. Valid values:

*   1: general mode
*   3: lightweight carousel playback mode
*   4: virtual studio
*   6: playlist mode', example='1', position='Query'),
  orderByModifyAsc?: string(name='OrderByModifyAsc', description='Specifies whether to sort the production studios in ascending order based on the modification time.

>  If you leave this parameter empty, the default value is used. Default value: false.', example='false', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The number of the page to return.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of templates to return on each page. If you leave this parameter empty, the default value is used. Default value: 100.', example='100', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).', example='rg-aekzw******', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2016-06-29T09:00:00Z', position='Query'),
  status?: int32(name='Status', description='The status of the production studio. Valid values:

*   0: idle
*   1: streaming', example='0', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model DescribeCastersResponseBody = {
  casterList?: {
    caster?: [ 
    {
      casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.', example='LIVEPRODUCER_POST-cn-0pp1czt****'),
      casterName?: string(name='CasterName', description='The name of the production studio.', example='liveCaster****'),
      casterTemplate?: string(name='CasterTemplate', description='The resolution in which the production studio plays videos. This parameter is returned if the subscription billing method is used. Valid values:

*   lp_ld: low definition
*   lp_sd: standard definition
*   lp_hd: high definition
*   lp_ud: ultra high definition.
*   lp_ld_v: low definition (portrait mode)
*   lp_sd_v: standard definition (portrait mode)
*   lp_hd_v: high definition (portrait mode)
*   lp_ud_v: ultra high definition (portrait mode)', example='lp_ld'),
      channelEnable?: int32(name='ChannelEnable', description='Indicates whether the channel is enabled for the production studio.

*   0: The channel is disabled.
*   1: The channel is enabled.', example='1'),
      chargeType?: string(name='ChargeType', description='The billing method. Valid values:

*   PrePaid: the subscription billing method
*   PostPaid: the pay-as-you-go billing method', example='PrePaid'),
      clientTokenId?: string(name='ClientTokenId', description='The client token that is used to ensure the idempotence of the request.', example='53200b81-b761-4c10-842a-a0726d97****'),
      createTime?: string(name='CreateTime', description='The time when the production studio was created.', example='2017-08-30 12:02:57.0'),
      duration?: string(name='Duration', description='The streaming duration. Format: hh:mm:ss.', example='1:02:33'),
      expireTime?: string(name='ExpireTime', description='The time when the production studio expires.', example='2018-08-30 12:02:57.0'),
      lastModified?: string(name='LastModified', description='The time when the production studio was last modified. For example, the time when the production studio was last started, stopped, or modified is returned.', example='2021-12-01T05:08:45Z'),
      normType?: int32(name='NormType', description='The type of the production studio. Valid values:

*   0: playlist mode
*   1: general mode', example='1'),
      purchaseTime?: string(name='PurchaseTime', description='The time when the production studio was purchased.', example='2017-08-30 12:02:57.0'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID. For more information about resource groups, see [Resource groups](https://help.aliyun.com/document_detail/2381067.html).', example='rg-aekzw******'),
      startTime?: string(name='StartTime', description='The time when the production studio was started. This parameter is returned if the production studio is in the streaming status.', example='2017-08-30 18:02:57.0'),
      status?: int32(name='Status', description='The status of the production studio. Valid values:

*   0: idle
*   1: streaming', example='1'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey', description='The key of the tag.', example='TestKey'),
          tagValue?: string(name='TagValue', description='The value of the tag.', example='TestValue'),
        }
      ](name='tag')
      }(name='Tags', description='The tags.'),
    }
  ](name='Caster')
  }(name='CasterList', description='The production studios.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91b9676b3'),
  total?: int32(name='Total', description='The number of production studios.', example='1'),
}

model DescribeCastersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeCastersResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848012.html) operation to create a production studio and then call this operation to query the production studio list. The status of a production studio can be idle or streaming.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeCasters  DescribeCastersRequest
  * @return DescribeCastersResponse
 */
async function describeCasters(request: DescribeCastersRequest): DescribeCastersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCasters', 'POST', '/', 'json', false, 'json', request);
}

model DescribeChannelParticipantsRequest {
  appId: string(name='AppId', description='The ID of the application. You can specify only one application ID.

This parameter is required.', example='aec****', position='Query'),
  channelId: string(name='ChannelId', description='The ID of the channel. You can specify only one channel ID.

This parameter is required.', example='testId', position='Query'),
  order?: string(name='Order', description='The sort order. Valid values:

*   **asc**: ascending order.
*   **desc**: descending order. This is the default value.', example='asc', position='Query'),
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: 10.', example='10', position='Query'),
}

model DescribeChannelParticipantsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6159ba01-6687-4fb2-a831-f0cd8d188648'),
  times?: long(name='Times', description='The time elapsed until the result was returned. Unit: seconds. The value is a UNIX timestamp.', example='1557909133'),
  totalNum?: int32(name='TotalNum', description='The number of entries returned.', example='3'),
  totalPage?: int32(name='TotalPage', description='The page number of the returned page.', example='1'),
  userList?: [ string ](name='UserList', description='The list of user IDs.'),
}

model DescribeChannelParticipantsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChannelParticipantsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query online users in a channel. The returned result does not include details about the users.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeChannelParticipants  DescribeChannelParticipantsRequest
  * @return DescribeChannelParticipantsResponse
 */
async function describeChannelParticipants(request: DescribeChannelParticipantsRequest): DescribeChannelParticipantsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeChannelParticipants', 'POST', '/', 'json', false, 'json', request);
}

model DescribeChannelUsersRequest {
  appId: string(name='AppId', description='The application ID. You can specify only one application ID in a request.

This parameter is required.', example='aec****', position='Query'),
  channelId: string(name='ChannelId', description='The channel ID. You can specify only one channel ID in a request.

This parameter is required.', example='testId', position='Query'),
}

model DescribeChannelUsersResponseBody = {
  interactiveUserList?: [ string ](name='InteractiveUserList', description='The list of streamers/co-streamers.'),
  interactiveUserNumber?: int32(name='InteractiveUserNumber', description='The number of co-streamers.', example='1'),
  isChannelExists?: boolean(name='IsChannelExists', description='Indicates whether the channel exists. Valid values:

*   **true**
*   **false**

> After all users leave the channel, the system requires a few seconds to clear the cache. If you call the operation during this period, the value of this parameter is true, and the value of InteractiveUserNumber and LiveUserNumber is 0.', example='true'),
  liveUserList?: [ string ](name='LiveUserList', description='The list of viewers.'),
  liveUserNumber?: int32(name='LiveUserNumber', description='The number of viewers.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='AD86847D-1F36-18C8-A995-5EEA340B3202'),
  timestamp?: long(name='Timestamp', description='The UTC timestamp when the response is returned.', example='1691027655'),
}

model DescribeChannelUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeChannelUsersResponseBody(name='body'),
}

/**
  * @description You can call this operation to query information about online users in a channel, such as the total number of users during live streaming.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeChannelUsers  DescribeChannelUsersRequest
  * @return DescribeChannelUsersResponse
 */
async function describeChannelUsers(request: DescribeChannelUsersRequest): DescribeChannelUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeChannelUsers', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainUsageDataRequest {
  area?: string(name='Area', description='The billable region. Valid values:

*   **CN**: Chinese mainland
*   **OverSeas**: outside the Chinese mainland
*   **AP1**: Asia Pacific 1
*   **AP2**: Asia Pacific 2
*   **AP3**: Asia Pacific 3
*   **NA**: North America
*   **SA**: South America
*   **EU**: Europe
*   **MEAA**: Middle East and Africa
*   **all**: all regions

>  If you do not specify this parameter, the default value CN is used. Alibaba Cloud supports the following countries and regions outside the Chinese mainland: - Asia Pacific 1: Hong Kong (China), Macao (China), Taiwan (China), Japan, and Southeast Asia excluding Vietnam and Indonesia. - Asia Pacific 2: Indonesia, South Korea, and Vietnam. - Asia Pacific 3: Australia and New Zealand. - North America: US and Canada. - South America: Brazil. Europe: Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany. - Middle East and Africa: South Africa, Oman, UAE, and Kuwait.', example='CN', position='Query'),
  dataProtocol?: string(name='DataProtocol', description='The protocol of the data to query. Valid values:

*   **http**: HTTP
*   **https**: HTTPS
*   **quic**: QUIC
*   **all** (default): HTTP, HTTPS, and QUIC', example='all', position='Query'),
  domainName?: string(name='DomainName', description='The domain name.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

The end time must be later than the start time. The maximum time range that you can specify is **31** days.

This parameter is required.', example='2015-12-10T21:00:00Z', position='Query'),
  field: string(name='Field', description='The category of the resource usage data to query. Valid values:

*   **bps**: streaming bandwidth
*   **traf**: streaming traffic
*   **req_traf**: stream ingest traffic if you set Type to push, or stream relay traffic if you set Type to push_proxy
*   **req_bps**: stream ingest bandwidth if you set Type to push, or stream relay bandwidth if you set Type to push_proxy

This parameter is required.', example='traf', position='Query'),
  interval?: string(name='Interval', description='The time interval between the data entries to return. Unit: seconds. Valid values: **300** (5 minutes), **3600** (1 hour), and **86400** (1 day).', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2015-12-10T20:00:00Z', position='Query'),
  type?: string(name='Type', description='The type of the resource usage data to query.

Valid values if you set **Field** to **bps** or **traf**:

*   **rts**: bandwidth or traffic for Real-Time Streaming (RTS)
*   **quic**: bandwidth or traffic for QUIC
*   **all**: all bandwidth or traffic

Valid values if you set **Field** to **req_traf** or **req_bps**:

*   **push**: stream ingest bandwidth or traffic
*   **push_proxy**: stream relay bandwidth or traffic', example='all', position='Query'),
}

model DescribeDomainUsageDataResponseBody = {
  area?: string(name='Area', description='The billable region where the resource usage data was generated.', example='CN'),
  dataInterval?: string(name='DataInterval', description='The time interval between the returned entries. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range for which the resource usage data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T21:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the resource usage data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T20:00Z'),
  type?: string(name='Type', description='The type of the resource usage data.', example='all'),
  usageDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T20:00:00Z'),
      value?: string(name='Value', description='The amount of resource usage.

*   If the value of the Field parameter is traf or req_traf, the returned data is measured in bytes.
*   If the value of the Field parameter is bps or req_bps, the returned data is measured in bit/s.
*   If the value of the Field parameter is acc, the returned data is measured by count.', example='423304182'),
    }
  ](name='DataModule')
  }(name='UsageDataPerInterval', description='The resource usage data that was collected for each time interval.'),
}

model DescribeDomainUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainUsageDataResponseBody(name='body'),
}

/**
  * @description * You can query the resource usage data of up to 100 domain names at a time. Separate multiple domain names with commas (,). If you do not specify the DomainName parameter, the resource usage data of all domain names within your Alibaba Cloud account is returned.
  * * The resource usage data includes network traffic that is measured in bytes, bandwidth that is measured in bit/s, and the number of requests.
  * * If you do not specify the Interval parameter, you can query the resource usage data in the last 12 months that spans a period of up to 31 days per call. If you specify a time range of 1 to 3 days in a call, the time interval between the entries that are returned is 1 hour. If you specify a time range of more than 3 days in a call, the time interval between the entries that are returned is 1 day.
  * * The following table describes the maximum time range per query, the time period within which historical data is available, and the data delay if you specify the Interval parameter.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|4 hours|
  * |1 day|90 days|366 days|04:00 on the next day|
  * ## QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeDomainUsageData  DescribeDomainUsageDataRequest
  * @return DescribeDomainUsageDataResponse
 */
async function describeDomainUsageData(request: DescribeDomainUsageDataRequest): DescribeDomainUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDomainWithIntegrityRequest {
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard. The time must be in UTC.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
  integrity: float(name='Integrity', description='The integrity.

This parameter is required.', example='0.95', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard. The time must be in UTC.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
}

model DescribeDomainWithIntegrityResponseBody = {
  content?: [ 
    {
      columns?: [ string ](name='Columns', description='The column names.'),
      name?: string(name='Name', description='The table name.', example='1637825700000'),
      points?: [ string ](name='Points', description='The subpoints.'),
    }
  ](name='Content', description='The verification information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DescribeDomainWithIntegrityResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeDomainWithIntegrityResponseBody(name='body'),
}

/**
  * @description You can call this operation to obtain domain integrity.
  * ## [](#qps-)QPS limits
  * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeDomainWithIntegrity  DescribeDomainWithIntegrityRequest
  * @return DescribeDomainWithIntegrityResponse
 */
async function describeDomainWithIntegrity(request: DescribeDomainWithIntegrityRequest): DescribeDomainWithIntegrityResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDomainWithIntegrity', 'GET', '/', 'json', false, 'json', request);
}

model DescribeHlsLiveStreamRealTimeBpsDataRequest {
  domainName?: string(name='DomainName', description='The domain names to query. Separate them with commas (,). A domain name cannot contain double-byte characters.', example='live.aiyun.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  time: string(name='Time', description='The timestamp.

This parameter is required.', example='2018-08-08T00:00:00Z', position='Query'),
}

model DescribeHlsLiveStreamRealTimeBpsDataResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='17C16B18-D3EA-4809-9CC3-8A2CBE14BC7B'),
  time?: string(name='Time', description='The timestamp for which the data was queried.', example='2018-08-08T00:00:00Z'),
  usageData?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      streamInfos?: [ 
        {
          infos?: [ 
            {
              downFlow?: float(name='DownFlow', description='The bandwidth. Unit: bit/s.', example='11440.88'),
              online?: float(name='Online', description='The number of online users.', example='1'),
              rate?: string(name='Rate', description='The bitrate.', example='1028'),
            }
          ](name='Infos', description='The statistics on the HLS stream.'),
          streamName?: string(name='StreamName', description='The name of the stream.', example='/live/sport.m3u8'),
        }
      ](name='StreamInfos', description='Details about the statistics on each HLS stream under the domain name.'),
    }
  ](name='UsageData', description='The usage data.'),
}

model DescribeHlsLiveStreamRealTimeBpsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeHlsLiveStreamRealTimeBpsDataResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the information about HTTP Live Streaming (HLS) streams, such as the number of online users and bandwidth.
  * *   The number of online users for an HLS stream is counted based on the universally unique identifiers (UUIDs) of users that are placed after the M3U8 URL.
  * *   You can query the data of up to 100 domain names in a single request. If the DomainName parameter is left empty, the data of all domain names under the account is queried.
  * @param request  the request parameters of DescribeHlsLiveStreamRealTimeBpsData  DescribeHlsLiveStreamRealTimeBpsDataRequest
  * @return DescribeHlsLiveStreamRealTimeBpsDataResponse
 */
async function describeHlsLiveStreamRealTimeBpsData(request: DescribeHlsLiveStreamRealTimeBpsDataRequest): DescribeHlsLiveStreamRealTimeBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHlsLiveStreamRealTimeBpsData', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveAIProduceRulesRequest {
  app?: string(name='App', description='The name of the application to which the live stream belongs.', example='AppName', position='Query'),
  domain?: string(name='Domain', description='The main streaming domain.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number. Valid values: [1,100].', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Valid values: [1,100].', example='100', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  rulesId?: string(name='RulesId', description='The ID of the subtitle rule.', example='445409ec-7eaa-461d-8f29-4bec****', position='Query'),
  suffixName?: string(name='SuffixName', description='The suffix of the subtitle rule.

> Set the value to the name of the subtitle template.', example='sub01', position='Query'),
}

model DescribeLiveAIProduceRulesResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64- af62-20e91b96****'),
  ruleInfoList?: {
    ruleInfo?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='App Name'),
      description?: string(name='Description', description='The description of the rule.', example='live AI subtitle template'),
      domain?: string(name='Domain', description='The streaming domain.', example='demo.aliyundoc.com'),
      gmtModifyTime?: string(name='GmtModifyTime', description='The last time when the rule was modified. The value is a timestamp.', example='1715594344000'),
      isLazy?: boolean(name='IsLazy', description='Indicates whether the rule takes effect when stream pulling starts.', example='true'),
      liveTemplate?: string(name='LiveTemplate', description='The specification of the exported subtitles.', example='lp_ld'),
      rulesId?: string(name='RulesId', description='The ID of the subtitle rule.', example='72fba656-2cc2-40fd-923c-2a10c3b9****'),
      studioName?: string(name='StudioName', description='The name of the virtual background template.', example='test0708'),
      subtitleName?: string(name='SubtitleName', description='The name of the subtitle template.', example='sub1'),
      suffixName?: string(name='SuffixName', description='The suffix of the subtitle rule.', example='test0506'),
    }
  ](name='RuleInfo')
  }(name='RuleInfoList', description='The subtitle rules.'),
}

model DescribeLiveAIProduceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveAIProduceRulesResponseBody(name='body'),
}

/**
  * @description You can call this operation to query subtitle rules. Make sure that the parameter settings meet the requirements.
  * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveAIProduceRules  DescribeLiveAIProduceRulesRequest
  * @return DescribeLiveAIProduceRulesResponse
 */
async function describeLiveAIProduceRules(request: DescribeLiveAIProduceRulesRequest): DescribeLiveAIProduceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveAIProduceRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveAIStudioRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Valid values: 1 to 50.', example='10', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  studioId?: string(name='StudioId', description='The ID of the virtual studio template that you want to query. This parameter is optional.', example='dbe61b87-db9a-448f-8757-a875edb3f944', position='Query'),
  studioName?: string(name='StudioName', description='The name of the virtual studio template.', example='sub02', position='Query'),
}

model DescribeLiveAIStudioResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Valid values: 1 to 50.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  studioConfigs?: {
    subtitleConfig?: [ 
    {
      backgroundResourceId?: string(name='BackgroundResourceId', description='The ID of the background material.', example='d0eb493192c771efba644531858c0102'),
      backgroundResourceUrl?: string(name='BackgroundResourceUrl', description='The URL of the background material. Make sure that the URL is accessible over the Internet. Either this parameter or the BackgroundResourceId parameter is returned.', example='https://testbucket.xx.com/2.jpg'),
      backgroundType?: string(name='BackgroundType', description='The type of the background material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD'),
      description?: string(name='Description', description='The custom description.', example='user defined description'),
      height?: string(name='Height', description='The preview height. Unit: pixels.

The following preview specifications (width × height) are supported:

*   Landscape low definition 360p (640×360)
*   Portrait low definition 360p (360×640)
*   Landscape standard definition 480p (854×480)
*   Portrait standard definition 480p (480×854)
*   Landscape high definition 720p (1280×720)
*   Portrait high definition 720p (720×1280)
*   Landscape ultra-high definition 1080p (1920×1080)
*   Portrait ultra-high definition 1080p (1080×1920)', example='1080'),
      mattingLayout?: string(name='MattingLayout', description='The layout information of the multimedia material.', example='"{\\"positionY\\":\\"0.0\\",\\"positionX\\":\\"0.0\\",\\"heightNormalized\\":\\"0.5\\"}"'),
      mattingType?: string(name='MattingType', description='The type of chroma key that is performed on ingested streams. Valid values:

*   green: green-key chroma key
*   blue: blue-screen chroma key
*   complex: background replacement', example='complex'),
      mediaLayout?: string(name='MediaLayout', description='LIVE, live streaming', example='"{\\"positionY\\":\\"0.0\\",\\"positionX\\":\\"0.0\\",\\"heightNormalized\\":\\"0.5\\"}"'),
      mediaResourceId?: string(name='MediaResourceId', description='The ID of the multimedia material in ApsaraVideo VOD.', example='d0eb493192c771efba644531858c0102'),
      mediaResourceUrl?: string(name='MediaResourceUrl', description='The URL of the multimedia material.', example='https://testbucket.xx.com/2.jpg'),
      mediaType?: string(name='MediaType', description='The type of the multimedia material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD'),
      ruleIds?: {
        ruleId?: [ string ](name='ruleId')
      }(name='RuleIds', description='The IDs of the bound rules.'),
      templateId?: string(name='TemplateId', description='The ID of the virtual studio template.', example='24654384-f5ac-40ea-823b-74e85a61dd9f'),
      templateName?: string(name='TemplateName', description='The name of the virtual studio template. The name is the same as the value of the StudioName parameter that was specified when you called the CreateLiveAiStudio operation to create the virtual studio template.', example='studio1'),
      width?: string(name='Width', description='The preview width.', example='1920'),
    }
  ](name='SubtitleConfig')
  }(name='StudioConfigs', description='The virtual studio templates.'),
  total?: int32(name='Total', description='The total number of templates.', example='100'),
}

model DescribeLiveAIStudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveAIStudioResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveAIStudio  DescribeLiveAIStudioRequest
  * @return DescribeLiveAIStudioResponse
 */
async function describeLiveAIStudio(request: DescribeLiveAIStudioRequest): DescribeLiveAIStudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveAIStudio', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveAISubtitleRequest {
  isDefault?: boolean(name='IsDefault', description='Specifies whether to query the default subtitle template. Valid values:

*   true

*   false

    **

    **Note **The default template includes the built-in parameter configurations. You can specify the copyFrom parameter when you call the AddLiveAISubtitle operation to use the default template.', example='false', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: string(name='PageNumber', description='The page number. Valid values: [1,100].', example='1', position='Query'),
  pageSize?: string(name='PageSize', description='The number of entries per page. Valid values: [1,100].', example='100', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  subtitleId?: string(name='SubtitleId', description='The ID of the subtitle template.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  subtitleName?: string(name='SubtitleName', description='The name of the subtitle template. The name can contain only digits, letters, and hyphens (-). The name cannot start with a hyphen.', example='sub01', position='Query'),
}

model DescribeLiveAISubtitleResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64- af62-20e91b96****'),
  subtitleConfigs?: {
    subtitleConfig?: [ 
    {
      bgColor?: string(name='BgColor', description='The background color of the subtitles.', example='0xFF0000'),
      bgWidthNormalized?: float(name='BgWidthNormalized', description='The size of the background image.', example='0.09'),
      borderWidthNormalized?: float(name='BorderWidthNormalized', description='The font weight.', example='0.05'),
      description?: string(name='Description', description='The description of the template.', example='live AI subtitle template'),
      dstLanguage?: string(name='DstLanguage', description='The language to which the subtitles are translated.', example='zh-CN'),
      fontColor?: string(name='FontColor', description='The font color.', example='0xFFFFFF'),
      fontName?: string(name='FontName', description='The font.', example='AlibabaPuHuiTi-Regular'),
      fontSizeNormalized?: string(name='FontSizeNormalized', description='The font size.', example='0.037'),
      height?: string(name='Height', description='The height of the preview image.', example='720'),
      maxLines?: int32(name='MaxLines', description='The number of displayed lines.', example='2'),
      positionNormalized?: {
        position?: [ float ](name='Position')
      }(name='PositionNormalized', description='The position of the subtitles.'),
      rulesRefer?: {
        rulesId?: [ string ](name='RulesId')
      }(name='RulesRefer', description='The ID of the subtitle rule.'),
      showSourceLan?: int32(name='ShowSourceLan', description='Indicates whether the source language of the subtitle is displayed.', example='true'),
      srcLanguage?: string(name='SrcLanguage', description='The source language of the subtitles.', example='zh-CN'),
      subtitleId?: string(name='SubtitleId', description='The ID of the subtitle template.', example='597991f3-6ef9-4100-9238-82951de1****'),
      subtitleName?: string(name='SubtitleName', description='The name of the subtitle template.', example='sub1'),
      width?: string(name='Width', description='The width of the preview image.', example='1280'),
      wordPerline?: int32(name='WordPerline', description='The number of words per line.', example='20'),
    }
  ](name='SubtitleConfig')
  }(name='SubtitleConfigs', description='The information about the subtitle templates.'),
}

model DescribeLiveAISubtitleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveAISubtitleResponseBody(name='body'),
}

/**
  * @description This interface supports querying the list of subtitle template information with specified pagination parameters. Ensure that the parameter settings meet the requirements when calling.
  * >Notice: The real-time subtitle function is currently in the beta testing phase, and each user can add up to 300 subtitle templates. 
  * ## QPS Limit 
  * The QPS limit for this interface per user is 60 times/second. Exceeding this limit will result in API calls being throttled, which may impact your business operations. Please use it reasonably. For more information, refer to [QPS Limitation](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveAISubtitle  DescribeLiveAISubtitleRequest
  * @return DescribeLiveAISubtitleResponse
 */
async function describeLiveAISubtitle(request: DescribeLiveAISubtitleRequest): DescribeLiveAISubtitleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveAISubtitle', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveAudioAuditConfigRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DescribeLiveAudioAuditConfigResponseBody = {
  liveAudioAuditConfigList?: {
    liveAudioAuditConfig?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      bizType?: string(name='BizType', description='The business type. You can specify a model. The default value is the domain name.', example='example.edu'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      scenes?: {
        scene?: [ string ](name='scene')
      }(name='Scenes', description='The moderation scenarios.'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    }
  ](name='LiveAudioAuditConfig')
  }(name='LiveAudioAuditConfigList', description='The list of audio moderation configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model DescribeLiveAudioAuditConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveAudioAuditConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to query audio moderation configurations.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveAudioAuditConfig  DescribeLiveAudioAuditConfigRequest
  * @return DescribeLiveAudioAuditConfigResponse
 */
async function describeLiveAudioAuditConfig(request: DescribeLiveAudioAuditConfigRequest): DescribeLiveAudioAuditConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveAudioAuditConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveAudioAuditNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveAudioAuditNotifyConfigResponseBody = {
  liveAudioAuditNotifyConfigList?: {
    liveAudioAuditNotifyConfig?: [ 
    {
      callback?: string(name='Callback', description='The callback URL.', example='http://guide.aliyundoc.com/callback'),
      callbackTemplate?: string(name='CallbackTemplate', description='The callback template. The following fields are configured:

*   **{DomainName}**: the streaming domain.
*   **{AppName}**: the name of the application to which the live stream belongs.
*   **{StreamName}**: the name of the live stream.
*   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
*   **{Result}**: the moderation results.', example='{\\"domain\\":{DomainName},\\"app\\":{AppName},\\"stream\\":{StreamName},\\"timestamp\\":{Timestamp},\\"result\\":{Result}}'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    }
  ](name='LiveAudioAuditNotifyConfig')
  }(name='LiveAudioAuditNotifyConfigList', description='The configuration of callbacks for audio moderation results.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B908FF89-B03C-4831-B55B-48D2A******'),
}

model DescribeLiveAudioAuditNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveAudioAuditNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for audio moderation results.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveAudioAuditNotifyConfig  DescribeLiveAudioAuditNotifyConfigRequest
  * @return DescribeLiveAudioAuditNotifyConfigResponse
 */
async function describeLiveAudioAuditNotifyConfig(request: DescribeLiveAudioAuditNotifyConfigRequest): DescribeLiveAudioAuditNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveAudioAuditNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveCdnDiagnoseInfoRequest {
  securityToken?: string(name='SecurityToken', position='Query'),
  app: string(name='app', description='This parameter is required.', position='Query'),
  domain: string(name='domain', description='This parameter is required.', position='Query'),
  endTime: long(name='endTime', description='This parameter is required.', position='Query'),
  intervalType?: string(name='intervalType', position='Query'),
  phase: int32(name='phase', description='This parameter is required.', position='Query'),
  requestType?: string(name='requestType', position='Query'),
  startTime: long(name='startTime', description='This parameter is required.', position='Query'),
  streamName: string(name='streamName', description='This parameter is required.', position='Query'),
  streamSuffix: string(name='streamSuffix', description='This parameter is required.', position='Query'),
}

model DescribeLiveCdnDiagnoseInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model DescribeLiveCdnDiagnoseInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveCdnDiagnoseInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveCdnDiagnoseInfo  DescribeLiveCdnDiagnoseInfoRequest
  * @return DescribeLiveCdnDiagnoseInfoResponse
 */
async function describeLiveCdnDiagnoseInfo(request: DescribeLiveCdnDiagnoseInfoRequest): DescribeLiveCdnDiagnoseInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveCdnDiagnoseInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveCenterStreamRateDataRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2024-03-05T18:01:03Z', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2024-03-05T18:00:53Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveCenterStreamRateDataResponseBody = {
  rateDatas?: [ 
    {
      audioFps?: string(name='AudioFps', description='The audio frame rate.', example='47'),
      audioRate?: string(name='AudioRate', description='The audio bitrate.', example='600'),
      time?: string(name='Time', description='The time when the data was collected. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2024-03-05T18:00:53Z'),
      videoFps?: string(name='VideoFps', description='The video frame rate.', example='30'),
      videoRate?: string(name='VideoRate', description='The video bitrate.', example='1953584'),
    }
  ](name='RateDatas', description='The list of frame rates and bitrates.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B6E125BE-E9B8-1103-8684-A3585CB632F1'),
}

model DescribeLiveCenterStreamRateDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveCenterStreamRateDataResponseBody(name='body'),
}

/**
  * @description The time granularity for the returned data is 5 seconds. The maximum time range to query is 3 hours. You can query data in the last 30 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveCenterStreamRateData  DescribeLiveCenterStreamRateDataRequest
  * @return DescribeLiveCenterStreamRateDataResponse
 */
async function describeLiveCenterStreamRateData(request: DescribeLiveCenterStreamRateDataRequest): DescribeLiveCenterStreamRateDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveCenterStreamRateData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveCenterTransferRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='testapp', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  dstUrl?: string(name='DstUrl', description='The third-party URL to which the live stream is relayed.', example='rtmp://push.example2.aliyunlive.com/testapp1/teststream2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='teststream', position='Query'),
}

model DescribeLiveCenterTransferResponseBody = {
  liveCenterTransferInfoList?: {
    liveCenterTransferInfo?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='teststream'),
      domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
      dstUrl?: string(name='DstUrl', description='The third-party URL to which the live stream is relayed.', example='rtmp://push.example2.aliyunlive.com/testapp1/teststream2'),
      endTime?: string(name='EndTime', description='The end time of stream relay.', example='2022-04-29T15:16:00Z'),
      startTime?: string(name='StartTime', description='The start time of stream relay.', example='2022-04-28T15:16:00Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='teststream'),
      transferArgs?: string(name='TransferArgs', description='The validity period of stream relay. Valid values:

*   **always**: The stream can always be relayed.
*   **time**: The stream can be relayed in a specified time period.', example='time'),
    }
  ](name='LiveCenterTransferInfo')
  }(name='LiveCenterTransferInfoList', description='The stream relay information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C4865B85-664B-19D3-BB16-C62FB83C8226'),
}

model DescribeLiveCenterTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveCenterTransferResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveCenterTransfer  DescribeLiveCenterTransferRequest
  * @return DescribeLiveCenterTransferResponse
 */
async function describeLiveCenterTransfer(request: DescribeLiveCenterTransferRequest): DescribeLiveCenterTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveCenterTransfer', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveCertificateDetailRequest {
  certName: string(name='CertName', description='The name of the certificate.

This parameter is required.', example='Cert-****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveCertificateDetailResponseBody = {
  cert?: string(name='Cert', description='The content of the certificate.', example='-----BEGIN CERTIFICATE-----****-----END CERTIFICATE-----'),
  certId?: long(name='CertId', description='The ID of the certificate.', example='23451111'),
  certName?: string(name='CertName', description='The name of the certificate.', example='Cert-****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C7C69682-7F88-40DD-A198-10D0309E439B'),
}

model DescribeLiveCertificateDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveCertificateDetailResponseBody(name='body'),
}

/**
  * @description You can obtain the certificate name on the [Certificates](https://help.aliyun.com/document_detail/2584962.html) page of the ApsaraVideo Live console and then call this operation to query the certificate details.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveCertificateDetail  DescribeLiveCertificateDetailRequest
  * @return DescribeLiveCertificateDetailResponse
 */
async function describeLiveCertificateDetail(request: DescribeLiveCertificateDetailRequest): DescribeLiveCertificateDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveCertificateDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveCertificateListRequest {
  domainName?: string(name='DomainName', description='The ingest domain or streaming domain. Separate multiple domain names with commas (,).', example='demo.aliyundoc.com,example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveCertificateListResponseBody = {
  certificateListModel?: {
    certList?: {
      cert?: [ 
      {
        certId?: long(name='CertId', description='The ID of the certificate.', example='123456'),
        certName?: string(name='CertName', description='The name of the certificate.', example='Cert-****'),
        common?: string(name='Common', description='The Common Name (CN) attribute of the certificate.', example='example.net'),
        fingerprint?: string(name='Fingerprint', description='The fingerprint of the certificate.', example='****'),
        issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the certificate.', example='*****'),
        lastTime?: long(name='LastTime', description='The time when the certificate was issued. Unit: seconds.', example='1512388659'),
      }
    ](name='Cert')
    }(name='CertList', description='The certificates.'),
    count?: int32(name='Count', description='The number of certificates.', example='2'),
  }(name='CertificateListModel', description='The details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeLiveCertificateListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveCertificateListResponseBody(name='body'),
}

/**
  * @description If you specify one or more domain names in the request, the certificates of the domain names are returned. If you do not specify a domain name in the request, all certificates within your Alibaba Cloud account are returned.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveCertificateList  DescribeLiveCertificateListRequest
  * @return DescribeLiveCertificateListResponse
 */
async function describeLiveCertificateList(request: DescribeLiveCertificateListRequest): DescribeLiveCertificateListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveCertificateList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDelayConfigRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveDelayConfigResponseBody = {
  app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
  delayTime?: string(name='DelayTime', description='The duration for which the playback of the live stream is delayed.', example='60'),
  domain?: string(name='Domain', description='The main streaming domain.', example='example.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3136B58-5876-4168-83CA-B562781981A0'),
  stream?: string(name='Stream', description='The name of the live stream.', example='liveStream****'),
  taskTriggerMode?: string(name='TaskTriggerMode', description='The trigger mode. Valid values:

*   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
*   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
*   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.', example='PUBLISH_ONLY'),
}

model DescribeLiveDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDelayConfigResponseBody(name='body'),
}

/**
  * @description ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDelayConfig  DescribeLiveDelayConfigRequest
  * @return DescribeLiveDelayConfigResponse
 */
async function describeLiveDelayConfig(request: DescribeLiveDelayConfigRequest): DescribeLiveDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDelayedStreamingUsageRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. We recommend that you specify a time range that is less than or equal to 10 hours.', example='2022-10-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   300
*   3600
*   86400

If you specify an invalid value or do not specify this parameter, the default value 3600 is used.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The ID of the region. Separate multiple region IDs with commas (,). Valid values:

*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)
*   cn-shenzhen: China (Shenzhen)
*   cn-qingdao: China (Qingdao)
*   ap-southeast-1: Singapore
*   eu-central-1: Germany (Frankfurt)
*   ap-northeast-1: Japan (Tokyo)
*   ap-southeast-5: Indonesia (Jakarta)

If you leave this parameter empty, data of all regions is aggregated and returned by default.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. If you leave this parameter empty, data is aggregated and returned. Valid values:

*   domain: The DomainName parameter in the response takes effect only if SplitBy is set to domain.
*   region: The Region parameter in the response takes effect only if SplitBy is set to region.
*   stream: The StreamName parameter in the response takes effect only if SplitBy is set to stream.

>  This parameter takes effect only if the parameter corresponding to the value of this parameter is not left empty. Otherwise, an error is returned. For example, you cannot set this parameter to domain if the DomainName parameter is left empty.', example='domain', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. By default, data in the last seven days is returned.', example='2022-10-10T20:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the stream. Separate multiple stream names with commas (,). By default, data of all streams is aggregated and returned.', example='liveStream****', position='Query'),
}

model DescribeLiveDelayedStreamingUsageResponseBody = {
  delayData?: {
    delayDataItem?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name. If SplitBy is set to domain, the data returned is grouped by domain name.', example='example.com'),
      duration?: long(name='Duration', description='The duration of stream delay.', example='84'),
      region?: string(name='Region', description='The ID of the region. If SplitBy is set to region, the data returned is grouped by region.', example='cn-shanghai'),
      streamName?: string(name='StreamName', description='The name of the stream. If SplitBy is set to stream, the data returned is grouped by stream.', example='liveStream****'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2022-10-10T20:00:00Z'),
    }
  ](name='DelayDataItem')
  }(name='DelayData', description='The details about the stream delay usage data.'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried.', example='2022-10-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='4B460F8B-993C-4F48-B98A-910811DEBFEB'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried.', example='2022-10-10T20:00:00Z'),
}

model DescribeLiveDelayedStreamingUsageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDelayedStreamingUsageResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query your stream delay usage data. The default time granularity is 1 hour.
  * *   The maximum time range for a query is 31 days.
  * *   The minimum time granularity for a query is 1 hour.
  * *   You can query the data in the last 31 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDelayedStreamingUsage  DescribeLiveDelayedStreamingUsageRequest
  * @return DescribeLiveDelayedStreamingUsageResponse
 */
async function describeLiveDelayedStreamingUsage(request: DescribeLiveDelayedStreamingUsageRequest): DescribeLiveDelayedStreamingUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDelayedStreamingUsage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDetectNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveDetectNotifyConfigResponseBody = {
  liveDetectNotifyConfig?: {
    domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    notifyUrl?: string(name='NotifyUrl', description='The callback URL.', example='http://aliyundoc.com'),
  }(name='LiveDetectNotifyConfig', description='The callback configuration.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeLiveDetectNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDetectNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for video moderation results.
  * *   Only some live centers support the automated review feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of DescribeLiveDetectNotifyConfig  DescribeLiveDetectNotifyConfigRequest
  * @return DescribeLiveDetectNotifyConfigResponse
 */
async function describeLiveDetectNotifyConfig(request: DescribeLiveDetectNotifyConfigRequest): DescribeLiveDetectNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDetectNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDetectPornDataRequest {
  app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you do not specify this parameter, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-10T09:00:00Z', position='Query'),
  fee?: string(name='Fee', description='Specifies whether a quota of free image scanning is available. Valid values:

*   **free**: specifies that a quota of free image scanning is available.
*   **charge**: specifies that a quota of free image scanning is not available and fees are charged.', example='free', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The ID of the region where the domain name resides.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  scene?: string(name='Scene', description='The moderation scenario. Valid values:

*   **porn**: pornography detection. This is the default value.
*   **terrorism**: terrorism detection
*   **ad**: ad violation detection
*   **live**: undesirable scene detection
*   **logo**: logo detection', example='porn', position='Query'),
  splitBy?: string(name='SplitBy', description='The fields based on which data is grouped. Separate multiple fields with commas (,).

> If you leave the **SplitBy** parameter empty, only the **TimeStamp** and **Count** parameters are returned.', example='liveApp****,liveStream****', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> 

*   You can query data in the last 90 days.

*   The minimum data granularity is 5 minutes. If you do not specify this parameter, data in the last 24 hours is queried.', example='2017-12-10T08:00:00Z', position='Query'),
  stream?: string(name='Stream', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DescribeLiveDetectPornDataResponseBody = {
  detectPornData?: {
    dataModule?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      count?: long(name='Count', description='The number of reviewed images.', example='2'),
      domain?: string(name='Domain', description='The main streaming domain.', example='example.com'),
      fee?: string(name='Fee', description='Indicates whether a quota of free image scanning is available. Valid values:

*   **free**
*   **charge**', example='free'),
      region?: string(name='Region', description='The region in which the domain name resides.', example='cn-shanghai'),
      scene?: string(name='Scene', description='The moderation scenario. Valid values:

*   **porn** (default): pornography
*   **terrorism**: terrorism or politically sensitive content
*   **ad**: ad violation
*   **live**: undesirable scene
*   **logo**', example='porn'),
      stream?: string(name='Stream', description='The name of the live stream.', example='liveStream****'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-10T15:00:05Z'),
    }
  ](name='DataModule')
  }(name='DetectPornData', description='The bandwidth data returned at each interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
}

model DescribeLiveDetectPornDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDetectPornDataResponseBody(name='body'),
}

/**
  * @description *   The minimum data granularity is 5 minutes. If you do not specify the `StartTime` parameter, data in the last 24 hours is queried.
  * *   You can query data in the last 90 days.
  * *   You can call this operation to query the bandwidth at each interval.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDetectPornData  DescribeLiveDetectPornDataRequest
  * @return DescribeLiveDetectPornDataResponse
 */
async function describeLiveDetectPornData(request: DescribeLiveDetectPornDataRequest): DescribeLiveDetectPornDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDetectPornData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainBpsDataRequest {
  domainName?: string(name='DomainName', description='The streaming domain. You can query one or more domain names. If you specify multiple domain names, separate them with commas (,). If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-10T09:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300** (default)
*   **3600**
*   **86400**

> 

*   If you specify an invalid value or do not specify this parameter, the default value **300** is used.

*   When the time granularity is **300** seconds, the returned bandwidth is the average bandwidth within the 300 seconds.
*   When the time granularity is **3600** or **86400** seconds, the returned bandwidth is the peak value of all average bandwidths within each 300-second period.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-10T08:00:00Z', position='Query'),
}

model DescribeLiveDomainBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      bpsValue?: string(name='BpsValue', description='The bandwidth. Unit: bit/s.', example='11288111'),
      httpBpsValue?: string(name='HttpBpsValue', description='The bandwidth over HTTP. Unit: bit/s.', example='11286111'),
      httpsBpsValue?: string(name='HttpsBpsValue', description='The bandwidth over HTTPS. Unit: bit/s.', example='2000'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T08:00:05Z'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth data returned at each interval.'),
  dataInterval?: string(name='DataInterval', description='The time granularity of the query. Unit: seconds.', example='300'),
  domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-10T09:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-10T08:00:00Z'),
}

model DescribeLiveDomainBpsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainBpsDataResponseBody(name='body'),
}

/**
  * @description *   You can specify both the StartTime and EndTime parameters to query the data in the specified period of time. If you do not specify the StartTime and EndTime parameters, the data of the last hour is queried by default.
  * *   If you specify only the StartTime parameter but not the EndTime parameter, the data of the hour following the specified start time is queried.
  * *   If you specify only the EndTime parameter but not the StartTime parameter, the data of the hour preceding the specified end time is queried.
  * *   You can query the data in the last 90 days.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainBpsData  DescribeLiveDomainBpsDataRequest
  * @return DescribeLiveDomainBpsDataResponse
 */
async function describeLiveDomainBpsData(request: DescribeLiveDomainBpsDataRequest): DescribeLiveDomainBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainBpsData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainBpsDataByLayerRequest {
  domainName?: string(name='DomainName', description='The streaming domain. You can specify multiple domain names by separating them with commas (,). If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='pull.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-ddTHH:mm:ssZ* format. The time must be displayed in UTC.', example='2022-03-16T16:59:59Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300**
*   **3600**
*   **86400**

> 

*   If the time range specified by the StartTime and EndTime parameters is smaller than or equal to 3 days, the supported time granularities include 300, 3,600, and 86,400 seconds.

*   If the time range is larger than 3 days but smaller than or equal to 31 days, the supported time granularities include 3,600 and 86,400 seconds.

*   If the time range is larger than 31 days, the supported time granularity is 86,400 seconds.

*   If you specify an invalid value or do not specify this parameter, the default time granularity of 300 seconds is used.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). If you do not specify this parameter, the data of all ISPs is returned.

>  You can call the [DescribeLiveRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query available regions and ISPs.', example='tele***', position='Query'),
  layer?: string(name='Layer', description='The layer at which you want to query the data. Valid values:

*   IPv4 and IPv6 (network layer)
*   http, https, and quic (application layer)
*   all (default)', example='all', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. If you do not specify this parameter, the data of all regions is returned.

>  You can call the [DescribeLiveRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query available regions and ISPs.', example='hangzhou', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-ddTHH:mm:ssZ* format. The time must be displayed in UTC.

>  If you do not specify this parameter, the data of the last 24 hours is returned by default. The minimum time granularity is 5 minutes.', example='2022-03-15T16:00:00Z', position='Query'),
}

model DescribeLiveDomainBpsDataByLayerResponseBody = {
  bpsDataInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2022-03-15T16:00:00Z'),
      trafficValue?: string(name='TrafficValue', description='The total traffic. Unit: bytes.', example='331'),
      value?: string(name='Value', description='The peak bandwidth. Unit: bit/s.', example='0.56'),
    }
  ](name='DataModule')
  }(name='BpsDataInterval', description='The data returned at each time interval.'),
  dataInterval?: string(name='DataInterval', description='The time interval between the data entries returned. Unit: seconds.', example='300'),
  requestId?: string(name='RequestId', description='The request ID.', example='BEA5625F-8FCF-48F4-851B-2A48566EA967'),
}

model DescribeLiveDomainBpsDataByLayerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainBpsDataByLayerResponseBody(name='body'),
}

/**
  * @description You can query data in the last 90 days. You can specify up to 500 domain names. Separate multiple domain names with commas (,). The data of multiple domain names is aggregated and returned. The following section describes the time granularities of the data entries returned depending on the time range specified by the **StartTime** and **EndTime** parameters:
  * *   If the time range is smaller than or equal to 3 days, the time granularity is 5 minutes.
  * *   If the time range is larger than 3 days but smaller than or equal to 31 days, the time granularity is 1 hour.
  * *   If the time range is larger than 31 days, the time granularity is 1 day.
  * >  If neither the **StartTime** nor the **EndTime** parameter is specified, the data of the last 24 hours is returned.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainBpsDataByLayer  DescribeLiveDomainBpsDataByLayerRequest
  * @return DescribeLiveDomainBpsDataByLayerResponse
 */
async function describeLiveDomainBpsDataByLayer(request: DescribeLiveDomainBpsDataByLayerRequest): DescribeLiveDomainBpsDataByLayerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainBpsDataByLayer', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainByCertificateRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  SSLPub: string(name='SSLPub', description='The public key of the SSL certificate. You must Base64-encode the public key before you invoke the encodeURIComponent function to encode a URI component. The public key must be in the PEM format.

This parameter is required.', example='******', position='Query'),
  SSLStatus?: boolean(name='SSLStatus', description='Specifies whether to return only domain names with HTTPS enabled or disabled.

*   **true**: returns only domain names with HTTPS enabled.
*   **false**: The rule is disabled.', example='true', position='Query'),
}

model DescribeLiveDomainByCertificateResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certCaIsLegacy?: string(name='CertCaIsLegacy', description='Indicates whether the SSL certificate is obsolete. Valid values:

*   **yes**
*   **no**', example='yes'),
      certExpireTime?: string(name='CertExpireTime', description='The time at which the certificate expires.', example='Nov 29 00:00:00 2016 GMT'),
      certExpired?: string(name='CertExpired', description='Indicates whether the SSL certificate is expired. Valid values:

*   **yes**
*   **no**', example='yes'),
      certStartTime?: string(name='CertStartTime', description='The effective time of the certificate.', example='Nov 29 23:59:59 2017 GMT'),
      certSubjectCommonName?: string(name='CertSubjectCommonName', description='The name of the SSL certificate owner.', example='owner'),
      certType?: string(name='CertType', description='The type of the certificate. Valid values: **RSA**, **DSA**, and **ECDSA**.', example='RSA'),
      domainList?: string(name='DomainList', description='The list of domain names. If a value is returned, the value matches the SSL certificate. Multiple domain names are separated by commas (,).', example='example.com,aliyundoc.com'),
      domainNames?: string(name='DomainNames', description='The domain names (DNS fields) that match the SSL certificate. Multiple domain names are separated by commas (,).', example='*.example.com,aliyundoc.com'),
      issuer?: string(name='Issuer', description='The certificate authority (CA) that issued the SSL certificate.', example='C=US, O=Symantec Corporation, OU=Symantec Trust Network, OU=Domain Validated SSL, CN=Symantec Basic DV SSL CA - G1'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The information about the certificate.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='ASAF2FDS-12SADSA-DDSAE3D-DSADCD4C-CDADS2D'),
}

model DescribeLiveDomainByCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainByCertificateResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the accelerated domain names that match a certificate.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainByCertificate  DescribeLiveDomainByCertificateRequest
  * @return DescribeLiveDomainByCertificateResponse
 */
async function describeLiveDomainByCertificate(request: DescribeLiveDomainByCertificateRequest): DescribeLiveDomainByCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainByCertificate', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainCertificateInfoRequest {
  domainName: string(name='DomainName', description='The streaming domain or ingest domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainCertificateInfoResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certDomainName?: string(name='CertDomainName', description='The streaming domain or ingest domain that matches the certificate.', example='example.com'),
      certExpireTime?: string(name='CertExpireTime', description='The expiration time of the certificate. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-06-03T22:03:39Z'),
      certLife?: string(name='CertLife', description='The validity period of the certificate.

*   If the validity period is greater than 12 months, XX years XX months is displayed. For example, 2 years 3 months indicates that the validity period is 2 years and 3 months.
*   If the validity period is less than 12 months, XX months is displayed. For example, 3 months indicates that the validity period is 3 months.', example='3 months'),
      certName?: string(name='CertName', description='The name of the certificate.', example='Cert-****'),
      certOrg?: string(name='CertOrg', description='The certificate authority (CA) that issued the certificate.', example='Let\\"s Encrypt'),
      certType?: string(name='CertType', description='The type of the certificate. Valid values:

*   **free**: a free certificate (for testing)
*   **cas**: a certificate that is purchased from Certificate Management Service
*   **upload**: a custom certificate that you uploaded', example='cas'),
      domainName?: string(name='DomainName', description='The streaming domain or ingest domain.', example='example.com'),
      SSLProtocol?: string(name='SSLProtocol', description='The status of HTTPS. Valid values:

*   **on**: HTTPS is enabled.
*   **off**: HTTPS is disabled.', example='on'),
      SSLPub?: string(name='SSLPub', description='The public key of the certificate.', example='yourSSLPub'),
      status?: string(name='Status', description='The status of the free certificate that is used for testing. Valid values:

*   **success**: The certificate is effective.
*   **checking**: The system is checking whether the domain name is mapped to the CNAME that is assigned by ApsaraVideo Live.
*   **cname_error**: The domain name is not mapped to the CNAME that is assigned by ApsaraVideo Live.
*   **domain_invalid**: The domain name contains invalid characters.
*   **unsupport_wildcard**: The domain name is a wildcard domain name, which is not supported.
*   **applying**: The certificate is in the application progress.
*   **failed**: The application for the certificate failed.

>  The **Status** parameter is valid only if the certificate is a free certificate for testing. If the certificate is not a free certificate for testing, an empty value is returned.', example='success'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The certificate information.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5C1E43DC-9E51-4771-82C0-7D5ECEB547A1'),
}

model DescribeLiveDomainCertificateInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainCertificateInfoResponseBody(name='body'),
}

/**
  * @description Obtain a domain name, and then call this operation to query certificate information about the domain name.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainCertificateInfo  DescribeLiveDomainCertificateInfoRequest
  * @return DescribeLiveDomainCertificateInfoResponse
 */
async function describeLiveDomainCertificateInfo(request: DescribeLiveDomainCertificateInfoRequest): DescribeLiveDomainCertificateInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainCertificateInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainConfigsRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  functionNames: string(name='FunctionNames', description='The names of the features. Separate multiple features with commas (,). For more information, see the **Features specified by the Functions parameter** section in this topic.

This parameter is required.', example='set_req_host_header,set_hashkey_args', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveDomainConfigsResponseBody = {
  domainConfigs?: {
    domainConfig?: [ 
    {
      configId?: string(name='ConfigId', description='The configuration ID.', example='5003576'),
      functionArgs?: {
        functionArg?: [ 
        {
          argName?: string(name='ArgName', description='The name of the attribute.', example='domain_name'),
          argValue?: string(name='ArgValue', description='The attribute value.', example='developer.aliyundoc.com'),
        }
      ](name='FunctionArg')
      }(name='FunctionArgs', description='The attributes of the feature.'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='set_req_host_header'),
      status?: string(name='Status', description='The configuration status. Valid values:

*   **success**
*   **testing**
*   **failed**
*   **configuring**', example='success'),
    }
  ](name='DomainConfig')
  }(name='DomainConfigs', description='The configurations of the domain name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F8AA0364-0FDB-4AD5-AC74-D69FAB8924ED'),
}

model DescribeLiveDomainConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainConfigsResponseBody(name='body'),
}

/**
  * @description You can call this operation to query multiple configurations at a time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainConfigs  DescribeLiveDomainConfigsRequest
  * @return DescribeLiveDomainConfigsResponse
 */
async function describeLiveDomainConfigs(request: DescribeLiveDomainConfigsRequest): DescribeLiveDomainConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainDetailRequest {
  domainName: string(name='DomainName', description='The streaming domain or ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveDomainDetailResponseBody = {
  domainDetail?: {
    certName?: string(name='CertName', description='The name of the certificate.', example='liveCert****'),
    cname?: string(name='Cname', description='The CNAME that is assigned to the domain name. You must add a CNAME record in the system of your Domain Name System (DNS) service provider to map the domain name to the CNAME.

>  A time-to-live (TTL) value is specified in the CNAME record of a domain name to indicate how long the CNAME record can be cached on the DNS resolver. If you modify the CNAME record of the domain name, the new settings take effect after the cache expires, which takes about 10 minutes. For more information, see [CNAME resolution](https://help.aliyun.com/document_detail/362010.html).', example='learn.developer.aliyundoc.com'),
    description?: string(name='Description', description='The description of the domain name.', example='test'),
    domainName?: string(name='DomainName', description='The streaming domain or ingest domain.', example='demo.aliyundoc.com'),
    domainStatus?: string(name='DomainStatus', description='The status of the domain name. Valid values:

*   **online**: The domain name is enabled.
*   **offline**: The domain name is disabled.
*   **configuring**: The domain is being configured.', example='online'),
    gmtCreated?: string(name='GmtCreated', description='The time when the domain name was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-07-27T06:51:25Z'),
    gmtModified?: string(name='GmtModified', description='The time when the domain name was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-08-07T06:51Z'),
    liveDomainType?: string(name='LiveDomainType', description='The type of the domain name. Valid values:

*   **liveVideo**: streaming domain
*   **liveEdge**: ingest domain', example='liveVideo'),
    region?: string(name='Region', description='The ID of the region where the domain name resides.', example='cn-shanghai'),
    resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek2ogvt4nwmi7i'),
    SSLProtocol?: string(name='SSLProtocol', description='Indicates whether the SSL certificate is enabled. Valid values:

*   **on**
*   **off**', example='on'),
    SSLPub?: string(name='SSLPub', description='The public key of the certificate.', example='Public Key'),
    scope?: string(name='Scope', description='The acceleration region. Valid values:

*   **domestic**: regions in the Chinese mainland.
*   **overseas**: regions outside the Chinese mainland.
*   **global**: regions in and outside the Chinese mainland.', example='domestic'),
  }(name='DomainDetail', description='The configuration details of the domain name.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='09ABE829-6CD3-4FE0-AFEE-556113E29727'),
}

model DescribeLiveDomainDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainDetailResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You can call this operation to query the basic information about an ingest domain or a streaming domain. If you want to query a newly added domain name, wait a few minutes until the configuration of the domain name is completed in ApsaraVideo Live.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainDetail  DescribeLiveDomainDetailRequest
  * @return DescribeLiveDomainDetailResponse
 */
async function describeLiveDomainDetail(request: DescribeLiveDomainDetailRequest): DescribeLiveDomainDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainEdgeLogRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeLiveDomainEdgeLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime'),
          logName?: string(name='LogName'),
          logPath?: string(name='LogPath'),
          logSize?: long(name='LogSize'),
          startTime?: string(name='StartTime'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex'),
        pageSize?: long(name='PageSize'),
        total?: long(name='Total'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails'),
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveDomainEdgeLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainEdgeLogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveDomainEdgeLog  DescribeLiveDomainEdgeLogRequest
  * @return DescribeLiveDomainEdgeLogResponse
 */
async function describeLiveDomainEdgeLog(request: DescribeLiveDomainEdgeLogRequest): DescribeLiveDomainEdgeLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainEdgeLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainFrameRateAndBitRateDataRequest {
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  queryTime: string(name='QueryTime', description='The point of time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2019-02-21T08:00:00Z', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainFrameRateAndBitRateDataResponseBody = {
  frameRateAndBitRateInfos?: {
    frameRateAndBitRateInfo?: [ 
    {
      audioFrameRate?: float(name='AudioFrameRate', description='The audio frame rate of the live stream. Unit: FPS.', example='42.9'),
      bitRate?: float(name='BitRate', description='The bitrate of the live stream. Unit: bit/s.', example='30693.96'),
      streamUrl?: string(name='StreamUrl', description='The URL of the live stream.', example='rtmp://demo.aliyundoc.com/test/liveStream****_3_4'),
      videoFrameRate?: float(name='VideoFrameRate', description='The video frame rate of the live stream. Unit: frames per second (FPS).', example='24.9'),
    }
  ](name='FrameRateAndBitRateInfo')
  }(name='FrameRateAndBitRateInfos', description='The frame rates and bitrates of the live streams that were queried.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C3F2C2C4-59BB-4B62-81FF-345BE557E3E3'),
}

model DescribeLiveDomainFrameRateAndBitRateDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainFrameRateAndBitRateDataResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the real-time bitrates and frame rates of live streams, which helps you evaluate the stream ingest quality. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
  * >  Use this operation to replace the deprecated DescribeLiveStreamsFrameRateAndBitRateData operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainFrameRateAndBitRateData  DescribeLiveDomainFrameRateAndBitRateDataRequest
  * @return DescribeLiveDomainFrameRateAndBitRateDataResponse
 */
async function describeLiveDomainFrameRateAndBitRateData(request: DescribeLiveDomainFrameRateAndBitRateDataRequest): DescribeLiveDomainFrameRateAndBitRateDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainFrameRateAndBitRateData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainLimitRequest {
  domainName: string(name='DomainName', description='The name of the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainLimitResponseBody = {
  liveDomainLimitList?: {
    liveDomainLimit?: [ 
    {
      currentNum?: int32(name='CurrentNum', description='The current number of ingested streams.', example='10'),
      currentTranscodeNum?: int32(name='CurrentTranscodeNum', description='The current number of transcoded streams.', example='10'),
      currentTransferNum?: int32(name='CurrentTransferNum', description='The current number of streams relayed from the live center.', example='10'),
      domainName?: string(name='DomainName', description='The name of the queried main streaming domain.', example='example.com'),
      limitNum?: int32(name='LimitNum', description='The maximum number of ingested streams.', example='100'),
      limitTranscodeNum?: int32(name='LimitTranscodeNum', description='The maximum number of transcoded streams.', example='50'),
      limitTransferNum?: int32(name='LimitTransferNum', description='The maximum allowed number of streams relayed from the live center.', example='50'),
    }
  ](name='LiveDomainLimit')
  }(name='LiveDomainLimitList', description='The limits.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3136B58-5876-4168-83CA-B562781981A0'),
}

model DescribeLiveDomainLimitResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainLimitResponseBody(name='body'),
}

/**
  * @description This operation applies only to main streaming domains.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainLimit  DescribeLiveDomainLimitRequest
  * @return DescribeLiveDomainLimitResponse
 */
async function describeLiveDomainLimit(request: DescribeLiveDomainLimitRequest): DescribeLiveDomainLimitResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainLimit', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainLogRequest {
  domainName: string(name='DomainName', description='The streaming domain or ingest domain.

You can specify only one domain name.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query data. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

The end time must be later than the start time. The maximum time range that can be specified is 31 days.', example='2016-10-20T05:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number.

>  If you do not specify the PageNumber parameter, the data on the first page is returned.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page.

*   Valid values: integers from **1 to 1000**.
*   Default value: **300**.
*   Maximum value: **1000**.', example='20', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-10-20T04:00:00Z', position='Query'),
}

model DescribeLiveDomainLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount', description='The total number of entries returned on the current page.', example='10'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime', description='The end of the time range for which the logs were queried.', example='2016-10-20T05:00:00Z'),
          logName?: string(name='LogName', description='The name of the log file.', example='developer.aliyundoc.com_2016_10_20_040000_050000.gz'),
          logPath?: string(name='LogPath', description='The path of the log file.', example='learn.aliyundoc.com/developer.aliyundoc.com/2016_10_20/example.aliyundoc.com_2016_10_20_040000_050000.gz?Expires=1522659931&amp;OSSAccessKeyId=LTAI******eo4ZEuA&amp;Signature=C01p%2BtA%******KP9Sru2Oxwy7Do0%3D'),
          logSize?: long(name='LogSize', description='The size of the log file.', example='10'),
          startTime?: string(name='StartTime', description='The beginning of the time range for which the logs were queried.', example='2016-10-20T04:00:00Z'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos', description='Details about the logs.'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex', description='The page number of the returned page.', example='1'),
        pageSize?: long(name='PageSize', description='The number of entries returned per page.', example='20'),
        total?: long(name='Total', description='The total number of entries returned.', example='20'),
      }(name='PageInfos', description='The page information.'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails', description='The log information.'),
  domainName?: string(name='DomainName', description='The streaming domain or ingest domain.', example='example.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeLiveDomainLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainLogResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the offline logs of a single domain name.
  * *   The StartTime and EndTime parameters are optional. You can specify both the parameters to query logs that are generated within the specified time period.
  * *   If you do not specify the StartTime and EndTime parameters, logs that are generated in the last 24 hours are queried by default.
  * ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainLog  DescribeLiveDomainLogRequest
  * @return DescribeLiveDomainLogResponse
 */
async function describeLiveDomainLog(request: DescribeLiveDomainLogRequest): DescribeLiveDomainLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainLogExTtlRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeLiveDomainLogExTtlResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime'),
          logName?: string(name='LogName'),
          logPath?: string(name='LogPath'),
          logSize?: long(name='LogSize'),
          startTime?: string(name='StartTime'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex'),
        pageSize?: long(name='PageSize'),
        total?: long(name='Total'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails'),
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveDomainLogExTtlResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainLogExTtlResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveDomainLogExTtl  DescribeLiveDomainLogExTtlRequest
  * @return DescribeLiveDomainLogExTtlResponse
 */
async function describeLiveDomainLogExTtl(request: DescribeLiveDomainLogExTtlRequest): DescribeLiveDomainLogExTtlResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainLogExTtl', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainMappingRequest {
  domainName: string(name='DomainName', description='The domain name for which you want to query the mappings. The following types of domain names are supported:

*   Ingest domain
*   Main streaming domain
*   Sub-streaming domain

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainMappingResponseBody = {
  liveDomainModels?: {
    liveDomainModel?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name to which the queried domain name is mapped.', example='example.aliyundoc.com'),
      type?: string(name='Type', description='The type of the queried domain name. Valid values:

*   **vhost**: main streaming domain
*   **publish**: ingest domain
*   **play**: sub-streaming domain', example='play'),
    }
  ](name='LiveDomainModel')
  }(name='LiveDomainModels', description='The mappings of the queried domain name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F6CD8'),
}

model DescribeLiveDomainMappingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainMappingResponseBody(name='body'),
}

/**
  * @description Obtain the ingest domain, main streaming domain, or sub-streaming domain, and then call this operation to query the mappings of the domain name.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 500 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainMapping  DescribeLiveDomainMappingRequest
  * @return DescribeLiveDomainMappingResponse
 */
async function describeLiveDomainMapping(request: DescribeLiveDomainMappingRequest): DescribeLiveDomainMappingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainMapping', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainMonitoringUsageDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.', example='2022-12-10T22:00:00Z', position='Query'),
  instanceId?: string(name='InstanceId', description='The ID of the monitoring session. If you leave this parameter empty, data of all monitoring sessions is queried by default. Separate multiple session IDs with commas (,).', example='e62af24d-a354-3b0c-9f1f-da592c4b****', position='Query'),
  interval?: string(name='Interval', description='The time granularity. Valid values: **3600** and **86400**. 3600 specifies that data is queried by hour and 86400 specifies that data is queried by day.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The region of the live center. If you leave this parameter empty, data of all regions is queried by default. Separate multiple regions with commas (,).', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. Valid values: **domain**, **region**, **instance**, and **resolution**. Default value: **resolution**. resolution specifies that data is grouped by resolution. Separate multiple values with commas (,).', example='resolution', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format.

*   The time must be in UTC.
*   The minimum data granularity is 1 hour.
*   If you leave this parameter empty, data in the previous 24 hours is queried.', example='2022-12-10T20:00:00Z', position='Query'),
}

model DescribeLiveDomainMonitoringUsageDataResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range.', example='2022-12-10T22:00:00Z'),
  instanceId?: string(name='InstanceId', description='The ID of the monitoring session.', example='e62af24d-a354-3b0c-9f1f-da592c4b****'),
  monitoringData?: {
    monitoringDataItem?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name. This field is valid only when you specify domain for the **SplitBy** parameter.', example='example.com'),
      duration?: int32(name='Duration', description='The duration. Unit: minutes.', example='2000'),
      instanceId?: string(name='InstanceId', description='The ID of the monitoring session. This field is valid only when you specify instance for the **SplitBy** parameter.', example='e62af24d-a354-3b0c-9f1f-da592c4b****'),
      region?: string(name='Region', description='The region of the live center. This field is valid only when you specify Region for the **SplitBy** parameter.', example='cn-shanghai'),
      resolution?: string(name='Resolution', description='The resolution. This field is valid only when you specify resolution for the **SplitBy** parameter.', example='720P'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2022-12-10T20:00:00Z'),
    }
  ](name='MonitoringDataItem')
  }(name='MonitoringData', description='The live monitoring data.'),
  region?: string(name='Region', description='The region of the live center.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range.', example='2022-12-10T20:00:00Z'),
}

model DescribeLiveDomainMonitoringUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainMonitoringUsageDataResponseBody(name='body'),
}

/**
  * @description *   You can specify one or more domain names. Separate multiple domain names with commas (,).
  * *   You can query data in the last 90 days.
  * *   The data is queried by hour or day.
  * *   The maximum time range for a query is 31 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainMonitoringUsageData  DescribeLiveDomainMonitoringUsageDataRequest
  * @return DescribeLiveDomainMonitoringUsageDataResponse
 */
async function describeLiveDomainMonitoringUsageData(request: DescribeLiveDomainMonitoringUsageDataRequest): DescribeLiveDomainMonitoringUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainMonitoringUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainMultiStreamConfigRequest {
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='pliveplay.gstv.com.cn', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
}

model DescribeLiveDomainMultiStreamConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='F486A44F-6B35-5A96-BF2C-************'),
  switch?: string(name='Switch', description='Indicates whether the dual-stream disaster recovery feature is enabled. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
}

model DescribeLiveDomainMultiStreamConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainMultiStreamConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveDomainMultiStreamConfig  DescribeLiveDomainMultiStreamConfigRequest
  * @return DescribeLiveDomainMultiStreamConfigResponse
 */
async function describeLiveDomainMultiStreamConfig(request: DescribeLiveDomainMultiStreamConfigRequest): DescribeLiveDomainMultiStreamConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainMultiStreamConfig', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainOnlineUserNumRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  queryTime?: string(name='QueryTime', description='The point of time to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2018-12-27T13:09:21Z', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainOnlineUserNumResponseBody = {
  onlineUserInfo?: {
    liveStreamOnlineUserNumInfo?: [ 
    {
      infos?: {
        info?: [ 
        {
          transcodeTemplate?: string(name='TranscodeTemplate', description='The transcoding template. A value of origin indicates that the stream is a source stream.', example='origin'),
          userNumber?: long(name='UserNumber', description='The number of online users for the stream, which can be a source stream or transcoded stream.', example='1'),
        }
      ](name='Info')
      }(name='Infos', description='The statistics on the stream.'),
      streamName?: string(name='StreamName', description='The name of the stream.', example='rtmp://example.com/test/liveStream****_3_1'),
    }
  ](name='LiveStreamOnlineUserNumInfo')
  }(name='OnlineUserInfo', description='The information about the streams.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3A3A8C3D-F8B2-4FBF-9319-771A11B855FA'),
  streamCount?: int32(name='StreamCount', description='The number of streams.', example='1'),
  userCount?: int32(name='UserCount', description='The total number of online users at the specified point in time for all the live streams under the main streaming domain.', example='1'),
}

model DescribeLiveDomainOnlineUserNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainOnlineUserNumResponseBody(name='body'),
}

/**
  * @description You can call this operation to collect statistics on the number of online users for only Flash Video (FLV), Real-Time Streaming (RTS), and Real-Time Messaging Protocol (RTMP) streams, but not HTTP Live Streaming (HLS) streams. A delay exists in data collection and statistics. We recommend that you query the data of more than 5 minutes ago.
  * >  Use this operation to replace the deprecated DescribeLiveStreamOnlineUserNum operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 200 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainOnlineUserNum  DescribeLiveDomainOnlineUserNumRequest
  * @return DescribeLiveDomainOnlineUserNumResponse
 */
async function describeLiveDomainOnlineUserNum(request: DescribeLiveDomainOnlineUserNumRequest): DescribeLiveDomainOnlineUserNumResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainOnlineUserNum', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainPublishErrorCodeRequest {
  appName?: string(name='AppName', description='The application name. The data is aggregated based on the application. If you specify this parameter, the DomainName parameter is required.', example='AppName', position='Query'),
  domainName?: string(name='DomainName', description='The ingest domain. If you want to specify multiple ingest domains, separate them with commas (,).

>  This parameter is required.', example='example.com,example.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you do not configure StartTime, the data within the previous hour is queried.', example='2016-06-29T09:10:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The start time. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you do not configure StartTime, the data within the previous hour is queried.', example='2016-06-29T09:00:00Z', position='Query'),
}

model DescribeLiveDomainPublishErrorCodeResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity of the query. Unit: seconds. Default value: 60.', example='60'),
  domainName?: string(name='DomainName', description='The ingest domain.', example='example.com,example.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-06-29T09:10:00Z'),
  realTimeCodeData?: [ 
    {
      codeData?: [ 
        {
          code?: string(name='Code', description='The response code. Valid values:

*   3: The data read timed out.
*   4: A data write error occurred.
*   6: The data write timed out.
*   200: The request is successful.
*   500: An unknown internal error occurred.
*   501: The stream ingest failed.
*   502: The signaling operation timed out.
*   401: A stream ingest parameter is invalid.
*   403: The stream ingest authentication failed.', example='200'),
          count?: string(name='Count', description='The number of times the HTTP status code was returned.', example='20'),
          proportion?: string(name='Proportion', description='The proportion of the HTTP status code.', example='66.04'),
        }
      ](name='CodeData', description='The proportions of error codes.'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2016-06-29T09:01:00Z'),
    }
  ](name='RealTimeCodeData', description='The proportions of error codes at each time interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-06-29T09:00:00Z'),
}

model DescribeLiveDomainPublishErrorCodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainPublishErrorCodeResponseBody(name='body'),
}

/**
  * @description *   This operation is used to monitor data. The returned data cannot be used as a reference to calculate resource usage for billing.
  * *   You can query data within the previous 90 days.
  * *   The data is delayed for 3 to 5 minutes.
  * ## [](#qps-)QPS limits
  * You can call this API operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainPublishErrorCode  DescribeLiveDomainPublishErrorCodeRequest
  * @return DescribeLiveDomainPublishErrorCodeResponse
 */
async function describeLiveDomainPublishErrorCode(request: DescribeLiveDomainPublishErrorCodeRequest): DescribeLiveDomainPublishErrorCodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainPublishErrorCode', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainPushBpsDataRequest {
  domainName?: string(name='DomainName', description='The ingest domain. You can specify multiple ingest domains and separate them with commas (,). If you do not specify this parameter, the merged data of all your ingest domains is returned.', example='demo.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. The end time must be later than the start time.', example='2017-12-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300**
*   **3600**
*   **86400**

The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. If you do not specify this parameter, the data of the last 24 hours is returned.', example='2017-12-10T20:00:00Z', position='Query'),
}

model DescribeLiveDomainPushBpsDataResponseBody = {
  bpsDataPerInterval?: {
    dataModule?: [ 
    {
      bpsValue?: string(name='BpsValue', description='The bandwidth. Unit: bit/s.', example='11288111'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T20:00:00Z'),
    }
  ](name='DataModule')
  }(name='BpsDataPerInterval', description='The bandwidth data that was collected at each interval.'),
  dataInterval?: string(name='DataInterval', description='The time granularity of the query.', example='300'),
  domainName?: string(name='DomainName', description='The ingest domain.', example='demo.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried.', example='2017-12-10T20:00:00Z'),
}

model DescribeLiveDomainPushBpsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainPushBpsDataResponseBody(name='body'),
}

/**
  * @description *   The bandwidth unit is bit/s.
  * *   You can specify multiple domain names by separating them with commas (,).
  * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainPushBpsData  DescribeLiveDomainPushBpsDataRequest
  * @return DescribeLiveDomainPushBpsDataResponse
 */
async function describeLiveDomainPushBpsData(request: DescribeLiveDomainPushBpsDataRequest): DescribeLiveDomainPushBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainPushBpsData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainPushTrafficDataRequest {
  domainName?: string(name='DomainName', description='The ingest domain. You can specify multiple ingest domains and separate them with commas (,). If you do not specify this parameter, the merged data of all your ingest domains is returned.', example='demo.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300**
*   **3600**
*   **86400**

The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. If you do not specify this parameter, the data of the last 24 hours is returned.', example='2017-12-10T20:00:00Z', position='Query'),
}

model DescribeLiveDomainPushTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  domainName?: string(name='DomainName', description='The ingest domain.', example='demo.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried.', example='2017-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried.', example='2017-12-10T20:00:00Z'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T20:05:00Z'),
      trafficValue?: string(name='TrafficValue', description='The traffic. Unit: bytes.', example='1288111'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The traffic data that was collected at each interval.'),
}

model DescribeLiveDomainPushTrafficDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainPushTrafficDataResponseBody(name='body'),
}

/**
  * @description *   The traffic unit is bytes.
  * *   You can specify multiple domain names by separating them with commas (,).
  * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainPushTrafficData  DescribeLiveDomainPushTrafficDataRequest
  * @return DescribeLiveDomainPushTrafficDataResponse
 */
async function describeLiveDomainPushTrafficData(request: DescribeLiveDomainPushTrafficDataRequest): DescribeLiveDomainPushTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainPushTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainPvUvDataRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time must be in UTC.', example='2018-03-20T16:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time must be in UTC.', example='2018-03-17T16:00:00Z', position='Query'),
}

model DescribeLiveDomainPvUvDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds. Default value: 3600.', example='3600'),
  domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.', example='2018-03-20T16:00:00Z'),
  pvUvDataInfos?: {
    pvUvDataInfo?: [ 
    {
      pv?: string(name='PV', description='The number of PVs.', example='3036'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.', example='2018-03-19T16:00:00Z'),
      uv?: string(name='UV', description='The number of UVs.', example='2'),
    }
  ](name='PvUvDataInfo')
  }(name='PvUvDataInfos', description='The data of PVs and UVs.'),
  requestId?: string(name='RequestId', description='The request ID.', example='E9D3257A-1B7C-414C-90C1-8D07AC47BCAC'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ssZ* format. The time is displayed in UTC.', example='2018-03-17T16:00:00Z'),
}

model DescribeLiveDomainPvUvDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainPvUvDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the geographical distribution of viewers, the visitor ranking of a streaming domain, and the number of independent requests from IP addresses under a streaming domain within a specified time period.
  * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
  * *   You can specify only one streaming domain in each request.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainPvUvData  DescribeLiveDomainPvUvDataRequest
  * @return DescribeLiveDomainPvUvDataResponse
 */
async function describeLiveDomainPvUvData(request: DescribeLiveDomainPvUvDataRequest): DescribeLiveDomainPvUvDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainPvUvData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainRealTimeBpsDataRequest {
  domainName: string(name='DomainName', description='The streaming domain name or names.

Separate multiple domain names with commas (,).

This parameter is required.', example='example.com,example.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you do not set this parameter, the data of the hour following the specified start time is returned.', example='2015-11-30T05:40:00Z', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

To query ISPs, call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region in which you want to query data.

To query regions, call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-11-30T05:39:00Z', position='Query'),
}

model DescribeLiveDomainRealTimeBpsDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The interval at which data was queried.', example='60'),
  domainName?: string(name='DomainName', description='The streaming domain name or names that was queried.', example='example.com,example.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-11-30T05:40:00Z'),
  realTimeBpsDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2015-11-30T05:39:00Z'),
      value?: string(name='Value', description='The bandwidth. Unit: bit/s.', example='59392614.8'),
    }
  ](name='DataModule')
  }(name='RealTimeBpsDataPerInterval', description='The bandwidth data that was collected every minute.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  startTime?: string(name='StartTime', description='The beginning of the time range in which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-11-30T05:33:00Z'),
}

model DescribeLiveDomainRealTimeBpsDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainRealTimeBpsDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the bandwidth usage of one or more specified domain names.
  * *   You can query data in the last seven days. The time range that is specified by the StartTime and EndTime parameters cannot exceed 24 hours for a query.
  * *   If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last hour is returned.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainRealTimeBpsData  DescribeLiveDomainRealTimeBpsDataRequest
  * @return DescribeLiveDomainRealTimeBpsDataResponse
 */
async function describeLiveDomainRealTimeBpsData(request: DescribeLiveDomainRealTimeBpsDataRequest): DescribeLiveDomainRealTimeBpsDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainRealTimeBpsData', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainRealTimeHttpCodeDataRequest {
  domainName: string(name='DomainName', description='The streaming domain.

Separate multiple domain names with commas (,).

This parameter is required.', example='example.com,example.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last **1** hour is returned.', example='2015-11-30T05:40:00Z', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP).

You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/448109.html) operation to query a list of available ISPs.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/448109.html) operation to query a list of available regions.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you specify neither the StartTime parameter nor the EndTime parameter, the data of the last **1** hour is returned.', example='2015-11-30T05:39:00Z', position='Query'),
}

model DescribeLiveDomainRealTimeHttpCodeDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds Default value: 60.', example='60'),
  domainName?: string(name='DomainName', description='The streaming domain.', example='example.com,example.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-11-30T05:40:00Z'),
  realTimeHttpCodeData?: {
    usageData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-11-30T05:39:00Z'),
      value?: {
        realTimeCodeProportionData?: [ 
        {
          code?: string(name='Code', description='The HTTP status code.', example='200'),
          count?: string(name='Count', description='The number of times the HTTP status code was returned.', example='20'),
          proportion?: string(name='Proportion', description='The proportion of the HTTP status code.', example='66.046511627907'),
        }
      ](name='RealTimeCodeProportionData')
      }(name='Value', description='The proportions of HTTP status codes.'),
    }
  ](name='UsageData')
  }(name='RealTimeHttpCodeData', description='The proportions of HTTP status codes at each time interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-11-30T05:33:00Z'),
}

model DescribeLiveDomainRealTimeHttpCodeDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainRealTimeHttpCodeDataResponseBody(name='body'),
}

/**
  * @description The following table describes the time granularities supported by this operation.
  * |Time granularity|Maximum time range per query|Historical data available|Data delay|
  * |---|---|---|---|
  * |1 minute|1 hour|7 days|5 minutes|
  * |5 minutes|3 days|93 days|15 minutes|
  * |1 hour|31 days|186 days|Usually 4 hours|
  * |1 day|Unlimited|366 days|After 04:00 on the next day|
  * ## QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainRealTimeHttpCodeData  DescribeLiveDomainRealTimeHttpCodeDataRequest
  * @return DescribeLiveDomainRealTimeHttpCodeDataResponse
 */
async function describeLiveDomainRealTimeHttpCodeData(request: DescribeLiveDomainRealTimeHttpCodeDataRequest): DescribeLiveDomainRealTimeHttpCodeDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainRealTimeHttpCodeData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainRealTimeTrafficDataRequest {
  domainName: string(name='DomainName', description='The streaming domain.

Separate multiple streaming domains with commas (,).

This parameter is required.', example='example.com,example.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-12-10T15:01:00Z', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the ISP.

You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region.

You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If you do not specify this parameter, the data of the last hour is returned.', example='2015-12-10T15:00:00Z', position='Query'),
}

model DescribeLiveDomainRealTimeTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time interval between the entries returned. Unit: seconds', example='60'),
  domainName?: string(name='DomainName', description='The streaming domain.', example='example.com,example.aliyundoc.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T15:01:00Z'),
  realTimeTrafficDataPerInterval?: {
    dataModule?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T15:01:00Z'),
      value?: string(name='Value', description='The traffic. Unit: bytes.', example='0'),
    }
  ](name='DataModule')
  }(name='RealTimeTrafficDataPerInterval', description='The traffic that was collected at each interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A666D44F-19D6-490E-97CF-1A64AB962C57'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-10T15:00:00Z'),
}

model DescribeLiveDomainRealTimeTrafficDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainRealTimeTrafficDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the real-time traffic in a region for an Internet service provider (ISP) within a specified period of time under one or more streaming domains.
  * *   If you do not specify the StartTime parameter or the EndTime parameter, the data of the last hour is returned. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
  * @param request  the request parameters of DescribeLiveDomainRealTimeTrafficData  DescribeLiveDomainRealTimeTrafficDataRequest
  * @return DescribeLiveDomainRealTimeTrafficDataResponse
 */
async function describeLiveDomainRealTimeTrafficData(request: DescribeLiveDomainRealTimeTrafficDataRequest): DescribeLiveDomainRealTimeTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainRealTimeTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainRealtimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainRealtimeLogDeliveryResponseBody = {
  logstore?: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.', example='logstore_example'),
  project?: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.', example='project_example'),
  region?: string(name='Region', description='The ID of the region where the Log Service project is deployed.', example='cn-shanghai'),
  requestId?: string(name='RequestId', description='The request ID.', example='2F8F3852-912F-42AC-80EB-F1CF4284DE93'),
  status?: string(name='Status', description='The status of real-time log delivery. Valid values:

*   online: Real-time log delivery is enabled.
*   offline: Real-time log delivery is disabled.', example='online'),
}

model DescribeLiveDomainRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the status of real-time log delivery for a domain name. Make sure that the parameter settings meet the requirements.
  * ## QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainRealtimeLogDelivery  DescribeLiveDomainRealtimeLogDeliveryRequest
  * @return DescribeLiveDomainRealtimeLogDeliveryResponse
 */
async function describeLiveDomainRealtimeLogDelivery(request: DescribeLiveDomainRealtimeLogDeliveryRequest): DescribeLiveDomainRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainRecordUsageDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. Value requirements:

*   The end time is later than the start time.
*   The time range between the start time and end time is up to 31 days. If the time range is more than 31 days, the request fails and an error is reported.', example='2021-05-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   60
*   300
*   3600
*   86400

> If you do not specify this parameter or specify an invalid value: The time granularity of the query for a time range that is less than or equal to 31 days is 300 seconds by default. The time granularity of the query for a time range that is more than 31 days is 86400 seconds by default.', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The ID of the region. Valid values:

*   **cn-beijing**: China (Beijing)
*   **cn-shanghai**: China (Shanghai)
*   **cn-shenzhen**: China (Shenzhen)
*   **cn-qingdao**: China (Qingdao)
*   **ap-southeast-1**: Singapore
*   **eu-central-1**: Germany (Frankfurt)
*   **ap-northeast-1**: Japan (Tokyo)
*   **ap-southeast-5**: Indonesia (Jakarta)', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. Valid values:

*   **domain**: groups results by domain name.
*   **record_fmt**: groups results by recording type.

>  You can select one option or both. If you want to select both options, separate them with a comma (,). The default value is `domain,record_fmt`. If you leave this parameter empty or set the value to `null`, this parameter is ignored.', example='domain,record_fmt', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The minimum data granularity is 5 minutes.
*   If you do not specify this parameter, the data in the last 24 hours is returned.

> The earliest start time that you can specify is 90 days back from the current time, accurate to seconds.', example='2021-05-10T20:00:00Z', position='Query'),
}

model DescribeLiveDomainRecordUsageDataResponseBody = {
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2021-05-10T21:00:00Z'),
  recordUsageData?: {
    dataModule?: [ 
    {
      count?: long(name='Count', description='The number of peak channels.', example='1'),
      domain?: string(name='Domain', description='The main streaming domain. This parameter is returned if the value of the request parameter SplitBy contains `domain`.', example='example.com'),
      duration?: long(name='Duration', description='The recording length. Unit: seconds.', example='3560'),
      region?: string(name='Region', description='The region ID.', example='cn-shanghai'),
      timeStamp?: string(name='TimeStamp', description='The time when recording started.', example='2021-05-10T20:00:00Z'),
      type?: string(name='Type', description='The recording file type. This parameter is returned if the value of the request parameter SplitBy contains `record_fmt`.', example='MP4'),
    }
  ](name='DataModule')
  }(name='RecordUsageData', description='The recording data that was collected for each interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4B460F8B-993C-4F48-B98A-910811DEBFEB'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2021-05-10T20:00:00Z'),
}

model DescribeLiveDomainRecordUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainRecordUsageDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the number of concurrent recording channels on each day and event tracking data at different time intervals. This way, you can measure the peak number of concurrent recording channels on each day or month.
  * *   The number of time shifting channels is not included in the number of recording channels.
  * *   You can query data by domain name or query data for multiple domain names at a time. If you specify multiple domain names, separate them with commas (,).
  * *   If you set the data granularity to 1 minute, the maximum time range to query is 24 hours. You can query data in the last 60 days.
  * *   If you set the data granularity to 1 hour, the maximum time range to query is 31 days. You can query data in the last 180 days.
  * *   If you set the data granularity to 1 day, the maximum time range to query is 90 days. You can query data in the last 366 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainRecordUsageData  DescribeLiveDomainRecordUsageDataRequest
  * @return DescribeLiveDomainRecordUsageDataResponse
 */
async function describeLiveDomainRecordUsageData(request: DescribeLiveDomainRecordUsageDataRequest): DescribeLiveDomainRecordUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainRecordUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainSnapshotDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2018-01-02T00:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  You can query data in the last **90** days.

This parameter is required.', example='2018-01-01T00:00:00Z', position='Query'),
}

model DescribeLiveDomainSnapshotDataResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='B955107D-E658-4E77-B913-E0AC3D31693F'),
  snapshotDataInfos?: {
    snapshotDataInfo?: [ 
    {
      date?: string(name='Date', description='The date.', example='20180209'),
      total?: int32(name='Total', description='The total number of snapshots that were captured on the day.', example='110'),
    }
  ](name='SnapshotDataInfo')
  }(name='SnapshotDataInfos', description='The daily statistics on the number of snapshots.'),
}

model DescribeLiveDomainSnapshotDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainSnapshotDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to collect statistics on the total number of snapshots on a day.
  * *   You can query data in the last 90 days.
  * ## [](#qps-)QPS limit
  * This operation does not have a queries per second (QPS) limit on a single user. You can call this operation based on your business requirements.
  * @param request  the request parameters of DescribeLiveDomainSnapshotData  DescribeLiveDomainSnapshotDataRequest
  * @return DescribeLiveDomainSnapshotDataResponse
 */
async function describeLiveDomainSnapshotData(request: DescribeLiveDomainSnapshotDataRequest): DescribeLiveDomainSnapshotDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainSnapshotData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainStagingConfigRequest {
  domainName: string(name='DomainName', description='The accelerated domain name.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  functionNames: string(name='FunctionNames', description='The feature that you want to query. Separate multiple features with commas (,).

This parameter is required.', example='aliauth', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveDomainStagingConfigResponseBody = {
  domainConfigs?: [ 
    {
      configId?: string(name='ConfigId', description='The configuration ID.', example='6295'),
      functionArgs?: [ 
        {
          argName?: string(name='ArgName', description='The name of the parameter.', example='auth_type'),
          argValue?: string(name='ArgValue', description='The configured value.', example='req_auth'),
        }
      ](name='FunctionArgs', description='The configurations of the feature.'),
      functionName?: string(name='FunctionName', description='The name of the feature.', example='aliauth'),
      status?: string(name='Status', description='The configuration status. Valid values:

*   **success**
*   **testing**
*   **failed**
*   **configuring**', example='success'),
    }
  ](name='DomainConfigs', description='The feature configurations of the accelerated domain name.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C80705BF-0F76-41FA-BAD1-5B59296A4E59'),
}

model DescribeLiveDomainStagingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainStagingConfigResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You can call this operation to query the feature configurations of an accelerated domain name in the canary release environment.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDomainStagingConfig  DescribeLiveDomainStagingConfigRequest
  * @return DescribeLiveDomainStagingConfigResponse
 */
async function describeLiveDomainStagingConfig(request: DescribeLiveDomainStagingConfigRequest): DescribeLiveDomainStagingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainStagingConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainStreamTranscodeDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-10T22:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **3600**: 1 hour
*   **86400**: 1 day

>  If you do not specify this parameter, the time granularity of 1 hour is used by default.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  precision?: string(name='Precision', description='The time precision of the query. Valid values:

*   **min** (default): in minutes.
*   **sec**: in seconds.', example='min', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  split?: string(name='Split', description='The key that is used to group data. Valid values:

*   **domain**: The DomainName parameter is available in the response only if Split is set to domain.
*   **region**: The Region parameter is available in the response only if Split is set to region.
*   **transcode_type**: The TanscodeType parameter is available in the response only if Split is set to transcode_type.
*   **resolution**: The Resolution parameter is available in the response only if Split is set to resolution.
*   **fps**: The Fps parameter is available in the response only if Split is set to fps.

You can specify one or more keys. If you specify multiple keys, separate them with commas (,).

Default value: `domain,region,transcode_type,resolution,fps`.', example='domain', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The minimum query interval is 1 hour.
*   If you do not set this parameter, the transcoding length for the last 24 hours is returned.

This parameter is required.', example='2017-12-10T20:00:00Z', position='Query'),
}

model DescribeLiveDomainStreamTranscodeDataResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='3C6CCEC4-6B88-4D4A-93E4-D47B3D92CF8F'),
  transcodeDataList?: {
    transcodeData?: [ 
    {
      domain?: string(name='Domain', description='The main streaming domain. This parameter is returned only when you add the domain key to the value of the Split parameter.', example='example.com'),
      duration?: int32(name='Duration', description='The transcoding length. Unit: minutes.', example='2000'),
      fps?: string(name='Fps', description='The frame rate of the transcoded stream. This parameter is returned only when you add the fps key to the value of the Split parameter.', example='normal'),
      region?: string(name='Region', description='The region in which the domain name resides. Valid values:

>  This parameter takes effect only when you set Split to region.

*   **cn-beijing**: China (Beijing)
*   **cn-shanghai**: China (Shanghai)
*   **cn-qingdao**: China (Qingdao)
*   **cn-shenzhen**: China (Shenzhen)
*   **ap-northeast-1**: Japan (Tokyo)
*   **ap-southeast-1**: Singapore
*   **ap-southeast-5**: Indonesia (Jakarta)
*   **eu-central-1**: Germany (Frankfurt)', example='cn-beijing'),
      resolution?: string(name='Resolution', description='The resolution of the transcoded stream. This parameter is returned only when you add the resolution key to the value of the Split parameter. Valid values:

*   **2K**
*   **4K**
*   **LD**: low definition
*   **SD**: standard definition
*   **HD**: high definition
*   **def**: audio', example='HD'),
      tanscodeType?: string(name='TanscodeType', description='The transcoding type. Valid values:

>  This parameter takes effect only if the request parameter Split is set to transcode_type.

*   **H264NBHD**: Narrowband HD™ transcoding based on H.264
*   **H265NBHD**: Narrowband HD™ transcoding based on H.265
*   **AUDIO**: audio transcoding', example='H264STD'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data entry.', example='2017-12-10T20:00:00Z'),
    }
  ](name='TranscodeData')
  }(name='TranscodeDataList', description='The transcoding usage data returned at each interval.'),
}

model DescribeLiveDomainStreamTranscodeDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainStreamTranscodeDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to collect the transcoding usage data at each time interval.
  * *   You can specify multiple domain names by separating them with commas (,).
  * *   You can query data in the last 90 days.
  * *   The time granularity of data is 1 hour or 1 day.
  * *   For information about the billing of different transcoding types and transcoding resolutions, see the description about billing of different transcoding specifications in transcoding bills in the [Billing of live stream transcoding](https://help.aliyun.com/document_detail/90424.html) section of the ApsaraVideo Live pricing page.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainStreamTranscodeData  DescribeLiveDomainStreamTranscodeDataRequest
  * @return DescribeLiveDomainStreamTranscodeDataResponse
 */
async function describeLiveDomainStreamTranscodeData(request: DescribeLiveDomainStreamTranscodeDataRequest): DescribeLiveDomainStreamTranscodeDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainStreamTranscodeData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainTimeShiftDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2021-03-03T02:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   300
*   3600
*   86400

If you do not specify this parameter or specify an invalid value, the default value 300 is used.', example='300', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

> 

*   The minimum data granularity is 5 minutes.

*   If you leave this parameter empty, data in the last 24 hours is queried.', example='2021-03-03T00:00:00Z', position='Query'),
}

model DescribeLiveDomainTimeShiftDataResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='8AE1CB3A-6510-442E-A6B9-EF03D05B3E09'),
  timeShiftData?: {
    dataModule?: [ 
    {
      size?: string(name='Size', description='The storage used for time shifting. Unit: bytes.', example='1664165660'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2021-03-03T00:00:00Z'),
      type?: string(name='Type', description='The type of time shifting. Examples: HLS_D1 and HLS_D7.', example='HLS_D7'),
    }
  ](name='DataModule')
  }(name='TimeShiftData', description='The time shifting usage data that was collected for each time interval.'),
}

model DescribeLiveDomainTimeShiftDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainTimeShiftDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the time shifting usage data at each time interval.
  * *   You can query data in the last 90 days.
  * *   The time interval is 1 hour.
  * *   The maximum time range for a query is 31 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainTimeShiftData  DescribeLiveDomainTimeShiftDataRequest
  * @return DescribeLiveDomainTimeShiftDataResponse
 */
async function describeLiveDomainTimeShiftData(request: DescribeLiveDomainTimeShiftDataRequest): DescribeLiveDomainTimeShiftDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainTimeShiftData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainTrafficDataRequest {
  domainName?: string(name='DomainName', description='The streaming domain. You can query one or more domain names. If you specify multiple domain names, separate them with commas (,). If you do not specify this parameter, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-10T15:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300** (default)
*   **3600**
*   **86400**

>  If you specify an invalid value or do not specify this parameter, the default value **300** is used.', example='300', position='Query'),
  ispNameEn?: string(name='IspNameEn', description='The name of the Internet service provider (ISP). You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available ISPs. If you do not specify this parameter, the data of all ISPs is returned.', example='alibaba', position='Query'),
  locationNameEn?: string(name='LocationNameEn', description='The name of the region. You can call the [DescribeCdnRegionAndIsp](https://help.aliyun.com/document_detail/91077.html) operation to query a list of available regions. If you do not specify this parameter, the data of all regions is returned.', example='tianjin', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  You can query data in the last **90** days.', example='2017-12-10T14:00:00Z', position='Query'),
}

model DescribeLiveDomainTrafficDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity of the query.', example='300'),
  domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-10T15:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which the data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-10T14:00:00Z'),
  trafficDataPerInterval?: {
    dataModule?: [ 
    {
      httpTrafficValue?: string(name='HttpTrafficValue', description='The traffic over HTTP. Unit: bytes.', example='0'),
      httpsTrafficValue?: string(name='HttpsTrafficValue', description='The traffic over HTTPS. Unit: bytes.', example='454680793'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2017-12-10T15:00:05Z'),
      trafficValue?: string(name='TrafficValue', description='The total traffic. Unit: bytes.', example='454680793'),
    }
  ](name='DataModule')
  }(name='TrafficDataPerInterval', description='The network traffic data that was collected at each interval.'),
}

model DescribeLiveDomainTrafficDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainTrafficDataResponseBody(name='body'),
}

/**
  * @description *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is returned.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveDomainTrafficData  DescribeLiveDomainTrafficDataRequest
  * @return DescribeLiveDomainTrafficDataResponse
 */
async function describeLiveDomainTrafficData(request: DescribeLiveDomainTrafficDataRequest): DescribeLiveDomainTrafficDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainTrafficData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDomainTranscodeParamsRequest {
  securityToken?: string(name='SecurityToken', position='Query'),
  app: string(name='app', description='This parameter is required.', position='Query'),
  pushdomain: string(name='pushdomain', description='This parameter is required.', position='Query'),
  templateName?: string(name='template_name', position='Query'),
}

model DescribeLiveDomainTranscodeParamsResponseBody = {
  requestId?: string(name='RequestId'),
}

model DescribeLiveDomainTranscodeParamsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDomainTranscodeParamsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveDomainTranscodeParams  DescribeLiveDomainTranscodeParamsRequest
  * @return DescribeLiveDomainTranscodeParamsResponse
 */
async function describeLiveDomainTranscodeParams(request: DescribeLiveDomainTranscodeParamsRequest): DescribeLiveDomainTranscodeParamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDomainTranscodeParams', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveDrmUsageDataRequest {
  domainName?: string(name='DomainName', description='The domain name.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2021-05-02T16:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   300
*   3600
*   86400

Default value: 3600.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. The following keys are supported: domain, region, and drm_type. If you want to specify multiple keys, separate them with commas (,). Default value: domain,region,drm_type. If you leave this parameter empty or set it to null, the returned data is not grouped.', example='domain,region,drm_type', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum time granularity is 5 minutes.

This parameter is required.', example='2021-05-01T16:00:00Z', position='Query'),
}

model DescribeLiveDrmUsageDataResponseBody = {
  drmUsageData?: {
    dataModule?: [ 
    {
      count?: long(name='Count', description='The number of times DRM-encrypted live streams are requested.', example='1'),
      domain?: string(name='Domain', description='The domain name. If the value of SplitBy includes domain, the returned data is grouped by domain name.', example='example.com'),
      drmType?: string(name='DrmType', description='The DRM type. If the value of SplitBy includes drm_type, the returned data is grouped by DRM type.', example='Widevine'),
      region?: string(name='Region', description='The ID of the region. If the value of SplitBy includes region, the returned data is grouped by region.', example='cn-beijing'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-05-01T16:00:00Z'),
    }
  ](name='DataModule')
  }(name='DrmUsageData', description='The usage of the DRM encryption service at each time interval.'),
  requestId?: string(name='RequestId', description='The request ID.', example='91FC2D9D-B042-4634-8A5C-7B8E7482C22D'),
}

model DescribeLiveDrmUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveDrmUsageDataResponseBody(name='body'),
}

/**
  * @description ### [](#)Usage notes
  * *   You can query data in the previous 90 days.
  * *   The maximum time range to query is 31 days.
  * ### [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveDrmUsageData  DescribeLiveDrmUsageDataRequest
  * @return DescribeLiveDrmUsageDataResponse
 */
async function describeLiveDrmUsageData(request: DescribeLiveDrmUsageDataRequest): DescribeLiveDrmUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveDrmUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveEdgeTransferRequest {
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveEdgeTransferResponseBody = {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
  domainName?: string(name='DomainName', description='The ingest domain.', example='demo.aliyundoc.com'),
  httpDns?: string(name='HttpDns', description='The HTTPDNS API that is used to obtain the destination URLs.', example='http://developer.aliyundoc.com/****'),
  requestId?: string(name='RequestId', description='The request ID.', example='53FCB985-C67C-467B-B2B3-398430A21E14'),
  streamName?: string(name='StreamName', description='The name of the ingested stream.', example='liveStream****'),
  targetDomainList?: string(name='TargetDomainList', description='The destination domain names to which the ingested stream is relayed. Multiple domain names are separated by commas (,).', example='learn.aliyundoc.com,guide.aliyundoc.com'),
  transferArgs?: string(name='TransferArgs', description='Indicates whether stream ingest parameters are passed through. Valid values:

*   **yes**: Stream ingest parameters are passed through.
*   **no**: Stream ingest parameters are not passed through.', example='yes'),
}

model DescribeLiveEdgeTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveEdgeTransferResponseBody(name='body'),
}

/**
  * @description Obtain the ingest domain, and then call this operation to query the configuration of edge stream relay.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveEdgeTransfer  DescribeLiveEdgeTransferRequest
  * @return DescribeLiveEdgeTransferResponse
 */
async function describeLiveEdgeTransfer(request: DescribeLiveEdgeTransferRequest): DescribeLiveEdgeTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveEdgeTransfer', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveGrtnDurationRequest {
  appId?: string(name='AppId', description='The ID of the application. Separate multiple application IDs with commas (,). You can specify up to 30 application IDs. By default, the aggregated data of all applications is returned.', example='4346289a-a790-4869-9e23-22766d5e****', position='Query'),
  area?: string(name='Area', description='The ID of the billable region. Valid values:

*   CN: Chinese mainland
*   OverSeas: countries and regions outside the Chinese mainland
*   AP1: Asia Pacific 1, including Hong Kong (China), Macao (China), Taiwan (China), Japan, and other Southeast Asia countries and regions except Vietnam and Indonesia
*   AP2: Asia Pacific 2, including Indonesia, South Korea, and Vietnam
*   AP3: Asia Pacific 3, including Australia and New Zealand
*   NA: North America, including US and Canada
*   SA: South America, specifically meaning Brazil
*   EU: Europe, including Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany
*   MEAA: Middle East and Africa, including South Africa, Oman, UAE, and Kuwait

If you do not specify this parameter, data of all regions is aggregated and returned by default.', example='CN', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The time range that can be specified is greater than or equal to 5 minutes and less than or equal to 31 days.

This parameter is required.', example='2022-10-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   300
*   3600
*   86400

If you specify an invalid value or do not specify this parameter, the default value 3600 is used.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2022-10-10T20:00:00Z', position='Query'),
}

model DescribeLiveGrtnDurationResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='4B460F8B-993C-4F48-B98A-910811DEBFEB'),
  streamDetailData?: {
    streamData?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='4346289a-a790-4869-9e23-22766d5e****'),
      duration?: long(name='Duration', description='The co-streaming duration. Unit: minutes.', example='30'),
      mediaProfile?: string(name='MediaProfile', description='The media specification. Valid values:

*   0: audio-only. This is a basic specification.
*   480P: standard definition (SD). The video resolution is 640 × 480 or lower.
*   720P: high definition (HD). The video resolution is 1280 × 720 or lower.
*   1080P: full HD. The video resolution is 1920 × 1080 or lower.', example='480P'),
      mediaType?: string(name='MediaType', description='The media type. Valid values:

*   audio
*   video', example='audio'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2022-12-10T20:00:00Z'),
    }
  ](name='StreamData')
  }(name='StreamDetailData', description='The details of the co-streaming usage data.'),
}

model DescribeLiveGrtnDurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveGrtnDurationResponseBody(name='body'),
}

/**
  * @description *   The maximum time range for a query is 31 days.
  * *   The minimum time granularity for a query is 5 minutes.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveGrtnDuration  DescribeLiveGrtnDurationRequest
  * @return DescribeLiveGrtnDurationResponse
 */
async function describeLiveGrtnDuration(request: DescribeLiveGrtnDurationRequest): DescribeLiveGrtnDurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveGrtnDuration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveHttpsDomainListRequest {
  keyword?: string(name='Keyword', description='The accelerated domain name.', example='demo.aliyun.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1 to 10000**.', example='5', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**.', example='20', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveHttpsDomainListResponseBody = {
  certInfos?: {
    certInfo?: [ 
    {
      certCommonName?: string(name='CertCommonName', description='The primary domain name of the certificate.', example='example.org'),
      certExpireTime?: string(name='CertExpireTime', description='The time when the certificate expires.', example='2018-12-26 14:45:09'),
      certName?: string(name='CertName', description='The name of the certificate.', example='test'),
      certStartTime?: string(name='CertStartTime', description='The time when the certificate became effective.', example='2018-11-26 14:45:09'),
      certStatus?: string(name='CertStatus', description='The status of the certificate. Valid values:

*   **ok**: The certificate is working as expected.
*   **mismatch**: The certificate does not match the specified domain name.
*   **expired**: The certificate has expired.
*   **expire_soon**: The certificate will expire soon.', example='mismatch'),
      certType?: string(name='CertType', description='The type of the certificate. Valid values:

*   **cas**: a certificate that you purchased from Certificate Management Service
*   **upload**: a custom certificate that you uploaded', example='cas'),
      certUpdateTime?: string(name='CertUpdateTime', description='The time when the certificate was updated.', example='2019-01-08 18:33:16'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
    }
  ](name='CertInfo')
  }(name='CertInfos', description='The information about the certificates.'),
  requestId?: string(name='RequestId', description='The request ID.', example='F5E8DF64-7175-4186-9B06-F002C0BBD0C5'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='16'),
}

model DescribeLiveHttpsDomainListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveHttpsDomainListResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the information about all certificates that you have configured.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveHttpsDomainList  DescribeLiveHttpsDomainListRequest
  * @return DescribeLiveHttpsDomainListResponse
 */
async function describeLiveHttpsDomainList(request: DescribeLiveHttpsDomainListRequest): DescribeLiveHttpsDomainListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveHttpsDomainList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveInteractionMetricDataRequest {
  appId: string(name='AppId', description='The ID of the application.

This parameter is required.', example='e4d7f08a-01fe-41b5-a091-fe41060a****', position='Query'),
  beginTs: long(name='BeginTs', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1698195600000', position='Query'),
  endTs: long(name='EndTs', description='The end of the time range to query. The value is a UNIX timestamp. Unit: milliseconds.

This parameter is required.', example='1698201013000', position='Query'),
  metricType: string(name='MetricType', description='The metric. Valid values:

*   JoinChannelSucRate: the success rate of joining a channel within 5 seconds.
*   VideoStuckRate: the video stuttering rate.
*   AudioStuckRate: the audio stuttering rate.
*   FirstFrameCost: the time to first frame.

This parameter is required.', example='FirstFrameCost', position='Query'),
  os?: string(name='Os', description='The operating system. Valid values: iOS and Android.', example='Android', position='Query'),
  terminalType?: string(name='TerminalType', description='The terminal type. Valid values: web and mobile.', example='mobile', position='Query'),
}

model DescribeLiveInteractionMetricDataResponseBody = {
  nodes?: [ 
    {
      timestamp?: string(name='Timestamp', description='The time when the metric was queried. The value is a UNIX timestamp. Unit: milliseconds.', example='1548670257000'),
      value?: string(name='Value', description='The value of the metric.', example='66.670000'),
    }
  ](name='Nodes', description='The node data.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A01C98C5-25AE-124A-83FE-514DF5C5BE36'),
  summaryData?: string(name='SummaryData', description='The summary data.', example='2000'),
}

model DescribeLiveInteractionMetricDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveInteractionMetricDataResponseBody(name='body'),
}

/**
  * @description *   You can query data in the last 30 days. The time range for a query cannot exceed 24 hours.
  * *   The time granularity for a query is 5 minutes.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveInteractionMetricData  DescribeLiveInteractionMetricDataRequest
  * @return DescribeLiveInteractionMetricDataResponse
 */
async function describeLiveInteractionMetricData(request: DescribeLiveInteractionMetricDataRequest): DescribeLiveInteractionMetricDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveInteractionMetricData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveIpInfoRequest {
  ip: string(name='IP', description='The IP address that you want to check. You can specify only one IP address in each call.

This parameter is required.', example='192.168.0.1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveIpInfoResponseBody = {
  ISP?: string(name='ISP', description='The Chinese name of the ISP.', example='ChinaTelecom'),
  ispEname?: string(name='IspEname', description='The English name of the Internet service provider (ISP).', example='telecom'),
  region?: string(name='Region', description='The Chinese name of the region.', example='China-Guizhou-guiyang'),
  regionEname?: string(name='RegionEname', description='The English name of the region.', example='China-Guizhou-guiyang'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1B1D0EE7-9559-489D-BC4E-279495EB8FB8'),
}

model DescribeLiveIpInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveIpInfoResponseBody(name='body'),
}

/**
  * @description ### [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveIpInfo  DescribeLiveIpInfoRequest
  * @return DescribeLiveIpInfoResponse
 */
async function describeLiveIpInfo(request: DescribeLiveIpInfoRequest): DescribeLiveIpInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveIpInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveLazyPullStreamConfigRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveLazyPullStreamConfigResponseBody = {
  liveLazyPullConfigList?: {
    liveLazyPullConfig?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='liveApp****'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      pullAppName?: string(name='PullAppName', description='The name of the application for back-to-origin stream pulling. If the application specified in the streaming URL is used, this parameter is left empty.', example='livePullApp****'),
      pullArgs?: string(name='PullArgs', description='The parameters of back-to-origin stream pulling.', example='k=v'),
      pullDomainName?: string(name='PullDomainName', description='The domain name for back-to-origin stream pulling.', example='guide.aliyundoc.com'),
      pullProtocol?: string(name='PullProtocol', description='The protocol for back-to-origin stream pulling. Valid values:

*   **rtmp**
*   **httpflv**
*   **hls**', example='RTMP'),
      transcodeLazy?: string(name='TranscodeLazy', description='Indicates whether stream pulling is triggered when the transcoded stream is played. Default value: **no**. Valid values:

*   **yes**
*   **no**', example='no'),
    }
  ](name='LiveLazyPullConfig')
  }(name='LiveLazyPullConfigList', description='The configurations of triggered stream pulling.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A3136B58-5876-4168-83CA-B562781981A0'),
}

model DescribeLiveLazyPullStreamConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveLazyPullStreamConfigResponseBody(name='body'),
}

/**
  * @description ##
  * This operation is applicable to regular stream pulling. You can call this operation to query the configurations of regular stream pulling for a domain name.
  * ## QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveLazyPullStreamConfig  DescribeLiveLazyPullStreamConfigRequest
  * @return DescribeLiveLazyPullStreamConfigResponse
 */
async function describeLiveLazyPullStreamConfig(request: DescribeLiveLazyPullStreamConfigRequest): DescribeLiveLazyPullStreamConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveLazyPullStreamConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveMessageAppRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application to query.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
}

model DescribeLiveMessageAppResponseBody = {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='demo'),
  appKey?: string(name='AppKey', description='The AppKey of the interactive messaging application. It is used to authorize operations related to the application ID.', example='**********************************'),
  appName?: string(name='AppName', description='The name of the interactive messaging application.', example='testApp'),
  appSign?: string(name='AppSign', description='The signature of the interactive messaging application. It is required by the interactive messaging SDK.', example='**************************************************************************'),
  auditType?: int32(name='AuditType', description='The content moderation method. Valid values:

*   0: Content moderation is disabled.
*   1: Built-in content moderation is used.
*   2: Custom content moderation is used.', example='2'),
  auditUrl?: string(name='AuditUrl', description='The URL for content moderation. This parameter is returned when the value of AuditType is 2.', example='http://example.aliyundoc.com/exampleaudit'),
  createTime?: long(name='CreateTime', description='The time when the interactive messaging application was created. The value is a UNIX timestamp. Unit: seconds.', example='1698305471'),
  dataCenter?: string(name='DataCenter', description='The data center.', example='cn-shanghai'),
  disable?: boolean(name='Disable', description='Indicates whether the interactive messaging application is disabled.', example='false'),
  eventCallbackUrl?: string(name='EventCallbackUrl', description='The callback URL for events such as user logon, logoff, joining a group, and leaving a group. An empty value indicates that callbacks are disabled.', example='http://example.aliyundoc.com/examplecallback'),
  modifyTime?: long(name='ModifyTime', description='The time when the interactive messaging application was modified. The value is a UNIX timestamp. Unit: seconds.', example='1698305471'),
  msgLifeCycle?: int32(name='MsgLifeCycle', description='The retention period of group messages in the application. Valid values:

*   0 (default): 30 days
*   1: 90 days
*   2: 180 days', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='9FB68B5B-ED07-18F0-A3CF-083F4E74****'),
}

model DescribeLiveMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveMessageAppResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveMessageApp  DescribeLiveMessageAppRequest
  * @return DescribeLiveMessageAppResponse
 */
async function describeLiveMessageApp(request: DescribeLiveMessageAppRequest): DescribeLiveMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveMessageApp', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveMessageGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='coims-pre', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the interactive messaging group whose information you want to query.

This parameter is required.', example='grouptest', position='Query'),
}

model DescribeLiveMessageGroupResponseBody = {
  adminList?: [ string ](name='AdminList', description='The list of the group administrators.'),
  createtime?: long(name='Createtime', description='The time when the group was created. The value is a UNIX timestamp. Unit: seconds.', example='1698305471'),
  creatorId?: string(name='CreatorId', description='The ID of the group creator.', example='uid1'),
  deletatime?: long(name='Deletatime', description='The time when the group was deleted. This parameter is returned only if the group was deleted.', example='1698299827'),
  delete?: boolean(name='Delete', description='Indicates whether the group was deleted.', example='false'),
  deletor?: string(name='Deletor', description='The ID of the user who deleted the group. This parameter is returned only if the group was deleted.', example='uid1'),
  groupId?: string(name='GroupId', description='The group ID.', example='grouptest1'),
  groupInfo?: string(name='GroupInfo', description='Additional information about the group.', example='testgroupinfo'),
  groupName?: string(name='GroupName', description='The name of the group.', example='mytestgroup'),
  msgAmount?: map[string]long(name='MsgAmount', description='The categorized message statistics. This parameter is returned only if the group exists.'),
  onlineUserCounts?: long(name='OnlineUserCounts', description='The number of online users in the group. This parameter is returned only if the group exists.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='1815A27D-BAE2-10E6-89FD-D477951C67C7'),
  superLargeGroup?: boolean(name='SuperLargeGroup', description='Indicates whether the group is a super group. Valid values:

*   True
*   False', example='False'),
  totalTimes?: long(name='TotalTimes', description='The total number of sessions. This parameter is returned only if the group exists.', example='50'),
}

model DescribeLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848162.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveMessageGroup  DescribeLiveMessageGroupRequest
  * @return DescribeLiveMessageGroupResponse
 */
async function describeLiveMessageGroup(request: DescribeLiveMessageGroupRequest): DescribeLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveMessageGroupBandRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the interactive messaging group.

This parameter is required.', example='grouptest', position='Query'),
}

model DescribeLiveMessageGroupBandResponseBody = {
  bannedUserList?: [ string ](name='BannedUserList', description='The list of users that were muted separately, but not by muting the entire group.'),
  groupId?: string(name='GroupId', description='The group ID.', example='grouptest'),
  isbannedAll?: boolean(name='IsbannedAll', description='Indicates whether all users in the interactive messaging group are muted.', example='false'),
  requestId?: string(name='RequestId', description='The request ID.', example='021D1FE7-2E87-16AC-9364-4E7EA47C****'),
  unbannedUserList?: [ string ](name='UnbannedUserList', description='The list of users who were not muted when the entire group was muted.'),
}

model DescribeLiveMessageGroupBandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveMessageGroupBandResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveMessageGroupBand  DescribeLiveMessageGroupBandRequest
  * @return DescribeLiveMessageGroupBandResponse
 */
async function describeLiveMessageGroupBand(request: DescribeLiveMessageGroupBandRequest): DescribeLiveMessageGroupBandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveMessageGroupBand', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePackageConfigRequest {
  appName?: string(name='AppName', description='The application name. If you leave this parameter empty, all applications are matched.', example='AppName', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  order?: string(name='Order', description='The sorting order. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 5 to 30. Default value: 10.', example='10', minimum=5, maximum=30, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The stream name. If you leave this parameter empty, all streams are matched.', example='StreamName', position='Query'),
}

model DescribeLivePackageConfigResponseBody = {
  livePackageConfigList?: {
    livePackageConfig?: [ 
    {
      appName?: string(name='AppName', description='The application name.', example='AppName'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      ignoreTranscode?: boolean(name='IgnoreTranscode', description='Indicates whether the transcoded stream is ignored. Valid values:

*   **true** (default)
*   **false**', example='true'),
      partDuration?: int32(name='PartDuration', description='The part length. Unit: milliseconds.', example='0'),
      protocol?: string(name='Protocol', description='The streaming protocol and encapsulation format.', example='HLS_CMAF'),
      segmentDuration?: int32(name='SegmentDuration', description='The segment length. Unit: seconds.', example='5'),
      segmentNum?: int32(name='SegmentNum', description='The number of segments.', example='3'),
      streamName?: string(name='StreamName', description='The stream name.', example='StreamName'),
    }
  ](name='LivePackageConfig')
  }(name='LivePackageConfigList', description='The live stream encapsulation configurations.'),
  order?: string(name='Order', description='The sorting order. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='1FEDCFD8-4C5D-5CB3-A5A1-0B59E5AE57B0'),
  totalNum?: int32(name='TotalNum', description='The total number of live stream encapsulation configurations.', example='1'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='10'),
}

model DescribeLivePackageConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePackageConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query live stream encapsulation configurations.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePackageConfig  DescribeLivePackageConfigRequest
  * @return DescribeLivePackageConfigResponse
 */
async function describeLivePackageConfig(request: DescribeLivePackageConfigRequest): DescribeLivePackageConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePackageConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePrivateLineAreasRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLivePrivateLineAreasResponseBody = {
  liveAreasList?: {
    liveArea?: [ 
    {
      regionType?: string(name='RegionType', description='The region type. Valid values:

*   domestic: in the Chinese mainland
*   overseas: outside the Chinese mainland', example='domestic'),
      regions?: {
        region?: [ 
        {
          localName?: string(name='LocalName', description='The region name.', example='cn-shenzhen'),
          regionId?: string(name='RegionId', description='The region ID.', example='cn-shenzhen'),
        }
      ](name='Region')
      }(name='Regions', description='The regions.'),
    }
  ](name='LiveArea')
  }(name='LiveAreasList', description='Details about the regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C4865B85-664B-19D3-BB16-C62FB83C8226'),
}

model DescribeLivePrivateLineAreasResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePrivateLineAreasResponseBody(name='body'),
}

/**
  * @description Before you call the CreateLivePrivateLine operation, you can call this operation to query available acceleration regions, which are access points where acceleration circuits start.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePrivateLineAreas  DescribeLivePrivateLineAreasRequest
  * @return DescribeLivePrivateLineAreasResponse
 */
async function describeLivePrivateLineAreas(request: DescribeLivePrivateLineAreasRequest): DescribeLivePrivateLineAreasResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePrivateLineAreas', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePrivateLineAvailGARequest {
  accelerationArea?: string(name='AccelerationArea', description='The acceleration channel.', example='ap-southeast-1', position='Query'),
  appName?: string(name='AppName', description='The name of the application.', example='live', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  isGaInstance: string(name='IsGaInstance', description='Specifies whether to query Global Accelerator (GA) instances. Valid values:

*   yes: queries the status of GA instances.
*   no: queries the binding information between GA instances and acceleration circuits.

This parameter is required.', example='no', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='testStream', position='Query'),
  videoCenter?: string(name='VideoCenter', description='The live center. Valid values: cn-beijing, cn-shanghai, cn-shenzhen, cn-qingdao, ap-northeast-1, ap-southeast-5, eu-central-1, ap-southeast-1, and ap-south-1. cn-beijing indicates China (Beijing). cn-shanghai indicates China (Shanghai). cn-shenzhen indicates China (Shenzhen). cn-qingdao indicates China (Qingdao). ap-northeast-1 indicates Japan (Tokyo). ap-southeast-5 indicates Indonesia (Jakarta). eu-central-1 indicates Germany (Frankfurt). ap-southeast-1 indicates Singapore.', example='cn-shanghai', position='Query'),
}

model DescribeLivePrivateLineAvailGAResponseBody = {
  livePrivateLineAvailGAs?: {
    livePrivateLineAvailGA?: [ 
    {
      accelerationArea?: string(name='AccelerationArea', description='The acceleration channel.', example='ap-southeast-1'),
      accelerationType?: string(name='AccelerationType', description='The acceleration type. Valid values:

*   play: streaming acceleration
*   publish: stream ingest acceleration', example='play'),
      appName?: string(name='AppName', description='The name of the application.', example='live'),
      bindingStatus?: string(name='BindingStatus', description='Indicates whether the GA instance is bound to an acceleration circuit. Valid values:

*   yes
*   no', example='yes'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='demo.aliyundoc.com'),
      ip?: string(name='IP', description='The accelerated IP address.', example='127.0.0.1'),
      instanceId?: string(name='InstanceId', description='The ID of the GA instance.', example='ga-bp1iovsdpf01ym9su****'),
      status?: string(name='Status', description='The status of the GA instance. Valid values:

*   active: The GA instance is available.
*   inactive: The GA instance is unavailable.', example='active'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='testStream'),
      uid?: string(name='Uid', description='The user ID (UID).', example='1833220971116****'),
      videoCenter?: string(name='VideoCenter', description='The live center.', example='cn-shanghai'),
    }
  ](name='LivePrivateLineAvailGA')
  }(name='LivePrivateLineAvailGAs', description='The GA instance configuration details.'),
  requestId?: string(name='RequestId', description='The request ID.', example='C4865B85-664B-19D3-BB16-C62FB83C8226'),
}

model DescribeLivePrivateLineAvailGAResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePrivateLineAvailGAResponseBody(name='body'),
}

/**
  * @description If you set the IsGaInstance parameter to yes, the status of GA instances is queried. If you set the IsGaInstance parameter to no, the binding information between GA instances and acceleration circuits is queried.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePrivateLineAvailGA  DescribeLivePrivateLineAvailGARequest
  * @return DescribeLivePrivateLineAvailGAResponse
 */
async function describeLivePrivateLineAvailGA(request: DescribeLivePrivateLineAvailGARequest): DescribeLivePrivateLineAvailGAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePrivateLineAvailGA', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveProducerUsageDataRequest {
  domainName?: string(name='DomainName', description='The streaming domain of the production studio.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2018-10-31T15:59:59Z', position='Query'),
  instance?: string(name='Instance', description='The production studio instance that you want to query. You can specify one or more production studio instances. Separate multiple instances with commas (,).

>  If you do not set this parameter, the usage data of all production studio instances is returned.', example='a17d0184-462d-4630-b2a6-8c26dde2****', position='Query'),
  interval?: string(name='Interval', description='The time granularity for a query. Valid values: 3600 and 86400. Unit: seconds.', example='3600', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The region in which the domain name resides. If you leave this parameter empty, the data of all regions is returned. You can specify multiple regions by separating them with commas (,).', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. You can specify one or more keys. Separate multiple keys with commas (,). Valid values: domain, region, instance, and type. The data for a key that you specify by using the SplitBy parameter is returned by group.

>  If you do not set this parameter, the aggregated data is returned.', example='type', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-09-30T16:00:00Z', position='Query'),
  type?: string(name='Type', description='The type of the production studio. You can specify one or more production studio types. Separate multiple types with commas (,). Valid values:

*   **slidelive**: playlist-mode studio.
*   **universal**: general studio.

>  If you do not set this parameter, the usage data of all types of production studios is returned.', example='slidelive', position='Query'),
  app?: string(name='app', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
}

model DescribeLiveProducerUsageDataResponseBody = {
  billProducerData?: {
    billProducerDataItem?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name. If domain is specified by the SplitBy parameter, the usage data is returned based on different domain names.', example='example.com'),
      instance?: string(name='Instance', description='The production studio instance. If instance is specified by the SplitBy parameter, the usage data is returned based on different production studio instances.', example='a17d0184-462d-4630-b2a6-8c26dde2****'),
      outputHdDuration?: long(name='OutputHdDuration', description='The duration of high definition streaming. Unit: minutes.', example='6000'),
      outputLdDuration?: long(name='OutputLdDuration', description='The duration of low definition streaming. Unit: minutes.', example='1001'),
      outputSdDuration?: long(name='OutputSdDuration', description='The duration of standard definition streaming. Unit: minutes.', example='500'),
      region?: string(name='Region', description='The region. If region is specified by the SplitBy parameter, the usage data is returned based on different regions.', example='cn-shanghai'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2018-09-30T00:00:00Z'),
      tranHdDuration?: long(name='TranHdDuration', description='The duration of high definition transcoding. Unit: minutes.', example='6777'),
      tranLdDuration?: long(name='TranLdDuration', description='The duration of low definition transcoding. Unit: minutes.', example='111'),
      tranSdDuration?: long(name='TranSdDuration', description='The duration of standard definition transcoding. Unit: minutes.', example='666'),
      type?: string(name='Type', description='The type of the production studio. If type is specified by the SplitBy parameter, the usage data is returned based on different types of production studios.', example='slidelive'),
    }
  ](name='BillProducerDataItem')
  }(name='BillProducerData', description='The production studio usage data.'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2018-09-30T16:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C370DAF1-C838-4288-A1A0-9A87633D248E'),
  startTime?: string(name='StartTime', description='The start of the time range for which the data was queried.', example='2018-10-31T15:59:59Z'),
}

model DescribeLiveProducerUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveProducerUsageDataResponseBody(name='body'),
}

/**
  * @description The minimum time granularity for a query is 1 hour. The maximum time range for a query is 31 days. You can query the production studio usage data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveProducerUsageData  DescribeLiveProducerUsageDataRequest
  * @return DescribeLiveProducerUsageDataResponse
 */
async function describeLiveProducerUsageData(request: DescribeLiveProducerUsageDataRequest): DescribeLiveProducerUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveProducerUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePullStreamConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLivePullStreamConfigResponseBody = {
  liveAppRecordList?: {
    liveAppRecord?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      endTime?: string(name='EndTime', description='The end of the time range for which the configurations were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-20T01:33:00Z'),
      sourceUrl?: string(name='SourceUrl', description='The origin server of the live stream.', example='guide.aliyundoc.com'),
      sourceUsing?: string(name='SourceUsing', description='The live stream origin server that you are using.', example='guide.aliyundoc.com'),
      startTime?: string(name='StartTime', description='The beginning of the time range for which the configurations were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-15T01:30:00Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    }
  ](name='LiveAppRecord')
  }(name='LiveAppRecordList', description='Details about the stream pulling configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A3136B58-5876-4168-83CA-B562781981A0'),
}

model DescribeLivePullStreamConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePullStreamConfigResponseBody(name='body'),
}

/**
  * @description ##
  * This operation is applicable to regular stream pulling. You can call this operation to query the regular stream pulling configurations for a domain name.
  * ## QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLivePullStreamConfig  DescribeLivePullStreamConfigRequest
  * @return DescribeLivePullStreamConfigResponse
 */
async function describeLivePullStreamConfig(request: DescribeLivePullStreamConfigRequest): DescribeLivePullStreamConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePullStreamConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePullToPushRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region where the task is started. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

This parameter is required.', example='fd245384-4067-4f91-9d75-9666a6bc****', position='Query'),
}

model DescribeLivePullToPushResponseBody = {
  currentFileIndex?: int32(name='CurrentFileIndex', description='The current file index.', example='0'),
  currentOffset?: int32(name='CurrentOffset', description='The current offset for video playback.', example='0'),
  description?: string(name='Description', description='The error description.', example='OK'),
  requestId?: string(name='RequestId', description='The request ID.', example='3271ACD2-F143-1204-AFDB-9A87C131****'),
  retCode?: int32(name='RetCode', description='The code that is returned for the request.

> 

*   0 is returned if the request is normal.

*   For information about codes that are returned when exceptions occur, see the following Error codes table.', example='0'),
  taskExitReason?: string(name='TaskExitReason', description='The reason why the task is stopped.

*   TriggerByUser: You proactively stopped the task.
*   OverEndTime: The specified end time was exceeded.

>  This parameter is returned only if the task is stopped.', example='TriggerByUser'),
  taskExitTime?: int32(name='TaskExitTime', description='The time when the task was exited. The value is a Unix timestamp in seconds.

>  This parameter is returned only if the task status is exited.', example='1724740200'),
  taskId?: string(name='TaskId', description='The task ID.', example='fd245384-4067-4f91-9d75-9666a6bc9****'),
  taskInfo?: {
    callbackURL?: string(name='CallbackURL', description='The HTTP callback URL.', example='https://callback*****.com'),
    dstUrl?: string(name='DstUrl', description='The destination URL to which the stream is relayed.', example='rtmp://pushtest.********.aliyunlive.com/pulltest493/pulltest-w434'),
    endTime?: string(name='EndTime', description='The end time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2024-08-27T14:30:00Z'),
    fileIndex?: int32(name='FileIndex', description='The file index, which indicates the sequence of the file where the playback starts.', example='0'),
    offset?: int32(name='Offset', description='The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.

> 

*   This parameter indicates an offset from the first frame.

*   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='2'),
    repeatNumber?: int32(name='RepeatNumber', description='The number of playbacks after the first playback is complete. Valid values:

*   0 (default): specifies that the video list is played only once.
*   \\-1: specifies that the video list is played in loop mode.
*   Positive integer: specifies the number of times the video list repeats after the first playback is complete.

>  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='0'),
    retryCount?: int32(name='RetryCount', description='The number of retries allowed.', example='3'),
    retryInterval?: int32(name='RetryInterval', description='The retry interval. Unit: seconds.', example='60'),
    sourceProtocol?: string(name='SourceProtocol', description='The protocol of the source stream.', example='RTMP'),
    sourceType?: string(name='SourceType', description='The type of the source stream. Valid values:

*   live: a live stream
*   vod: a list of ApsaraVideo VOD resources
*   url: a list of video resources from a third party', example='live'),
    sourceUrls?: [ string ](name='SourceUrls', description='The source URLs.', example='rtmp://pulltest.****.aliyunlive.com/pulltest493/pulltest-w434'),
    startTime?: string(name='StartTime', description='The start time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2024-08-26T10:30:00Z'),
    taskId?: string(name='TaskId', description='The task ID.', example='fd245384-4067-4f91-9d75-9666a6bc9****'),
    taskName?: string(name='TaskName', description='The task name.', example='test'),
  }(name='TaskInfo', description='The information about the task.'),
  taskInvalidReason?: string(name='TaskInvalidReason', description='The reason why the task was stopped.

*   PullStreamFailed: An exception occurred while pulling the source stream. A retry is in progress.
*   PushStreamFailed: An exception occurred while ingesting the stream. A retry is in progress.
*   UnknownError: An unknown exception occurred.

>  This parameter is returned only if the task status is stopped.', example='UnknownError'),
  taskStatus?: int32(name='TaskStatus', description='The current status of the task.

*   0: not started.
*   1: running. Stream pulling and stream relay are normal.
*   2: abnormal.
*   3: stopped. It may be because exceptions occur during stream pulling or stream relay or you proactively call the StopLivePullToPush operation.
*   \\-1: exited.', example='1'),
}

model DescribeLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePullToPushResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the information about a pulled-stream relay task.
  * *   This operation allows you to query the configurations and status of a task with a specified ID.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePullToPush  DescribeLivePullToPushRequest
  * @return DescribeLivePullToPushResponse
 */
async function describeLivePullToPush(request: DescribeLivePullToPushRequest): DescribeLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePullToPush', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLivePullToPushListRequest {
  dstUrl?: string(name='DstUrl', description='The destination URL. Fuzzy search is performed based on the destination URL.', example='rtmp://qd', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number.

>  The value must be greater than 0 and not greater than the maximum value of the Integer data type. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.

>  Valid values: [1,100]. Default value: 10.', example='10', minimum=1, maximum=100, position='Query'),
  region: string(name='Region', description='The region of the live center. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId?: string(name='TaskId', description='The task ID. Fuzzy search is performed based on the task ID.

>  The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).', example='861009', position='Query'),
  taskName?: string(name='TaskName', description='The task name. Fuzzy search is performed based on the task name.', example='task', position='Query'),
}

model DescribeLivePullToPushListResponseBody = {
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='a05e6b15-15af-405b-a4a2-0152245*****'),
  taskList?: [ 
    {
      currentFileIndex?: int32(name='CurrentFileIndex', description='The current file index.', example='0'),
      currentOffset?: int32(name='CurrentOffset', description='The current offset for video playback.', example='0'),
      taskExitReason?: string(name='TaskExitReason', description='The reason why the task was exited. Valid values:

*   TriggerByUser: You proactively ended the task.
*   OverEndTime: The specified end time was exceeded.

>  This parameter is returned only if the task status is exited.', example='TriggerByUser'),
      taskExitTime?: int32(name='TaskExitTime', description='The time when the task was exited. The value is a Unix timestamp in seconds.

>  This parameter is returned only if the task status is exited.', example='1726354625'),
      taskId?: string(name='TaskId', description='The task ID.', example='fb0d4ac7-c7e3-4978-9743-0bf2f6e8****'),
      taskInfo?: {
        callbackURL?: string(name='CallbackURL', description='The HTTP callback URL.', example='hahaha.com'),
        dstUrl?: string(name='DstUrl', description='The destination URL to which the stream is relayed.', example='rtmp://qd.push.lgg.alivecdn.com/testhsc/streamhsc?live_rtmp_*******'),
        endTime?: string(name='EndTime', description='The end time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2024-12-30T14:30:00Z'),
        fileIndex?: int32(name='FileIndex', description='The file index, which indicates the sequence of the file where the playback starts.', example='0'),
        offset?: int32(name='Offset', description='The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.

> 

*   This parameter indicates an offset from the first frame.

*   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='0'),
        repeatNumber?: int32(name='RepeatNumber', description='The number of playbacks after the first playback is complete. Valid values:

*   0 (default): specifies that the video list is played only once.
*   \\-1: specifies that the video list is played in loop mode.
*   Positive integer: specifies the number of times the video list repeats after the first playback is complete.

>  This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.', example='0'),
        retryCount?: int32(name='RetryCount', description='The number of retries allowed.', example='3'),
        retryInterval?: int32(name='RetryInterval', description='The retry interval. Unit: seconds.', example='60'),
        sourceProtocol?: string(name='SourceProtocol', description='The protocol of the source stream.', example='flv'),
        sourceType?: string(name='SourceType', description='The type of the source stream. Valid values:

*   live: a live stream
*   vod: a list of ApsaraVideo VOD resources
*   url: a list of video resources from a third party', example='vod'),
        sourceUrls?: [ string ](name='SourceUrls', description='The source URLs.'),
        startTime?: string(name='StartTime', description='The start time of the task. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2024-12-04T09:16:00Z'),
        taskId?: string(name='TaskId', description='The task ID.', example='fb0d4ac7-c7e3-4978-9743-0bf2f6e8****'),
        taskName?: string(name='TaskName', description='The task name.', example='taskname'),
      }(name='TaskInfo', description='The information about the task.'),
      taskInvalidReason?: string(name='TaskInvalidReason', description='The reason why the task was stopped.

*   PullStreamFailed: An exception occurred while pulling the source stream. A retry is in progress.
*   PushStreamFailed: An exception occurred while ingesting the stream. A retry is in progress.
*   UnknownError: An unknown exception occurred.

>  This parameter is returned only if the task status is stopped.', example='PullStreamFailed'),
      taskStatus?: int32(name='TaskStatus', description='The task status. Valid values:

*   0: not started.
*   1: running. Stream pulling and stream relay are normal.
*   2: abnormal.
*   3: stopped. It may be because exceptions occur during stream pulling or stream relay or you proactively call the StopLivePullToPush operation.
*   \\-1: exited.', example='0'),
    }
  ](name='TaskList', description='The tasks.'),
  total?: int32(name='Total', description='The total number of entries returned.', example='3'),
}

model DescribeLivePullToPushListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePullToPushListResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query pulled-stream relay tasks.
  * *   You can query tasks by page. Fuzzy search is supported based on task IDs, task names, and destination URLs.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePullToPushList  DescribeLivePullToPushListRequest
  * @return DescribeLivePullToPushListResponse
 */
async function describeLivePullToPushList(request: DescribeLivePullToPushListRequest): DescribeLivePullToPushListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePullToPushList', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLivePushProxyLogRequest {
  domainName: string(name='DomainName', description='The ingest domain. You can specify only one domain in each request.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='Get the log end time.
Date format follows the ISO8601 representation and uses UTC+0 time, formatted as yyyy-MM-ddTHH:mm:ssZ.', example='2023-09-20T09:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Default value: 1.', example='2', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: [1,1000]. Default value: 300.', example='300', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='Get the log start time in ISO8601 format with UTC+0 timezone, formatted as yyyy-MM-ddTHH:mm:ssZ.', example='2023-09-20T08:00:00Z', position='Query'),
}

model DescribeLivePushProxyLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount', description='The total number of entries returned on the current page.', example='10'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime', description='The end of the time range during which data was queried.

The value is a UNIX timestamp.', example='1695189600'),
          logName?: string(name='LogName', description='The name of the log file.', example='example.com
_2023_09_20_160000_170000.****.gz'),
          logPath?: string(name='LogPath', description='The path of the log file.'),
          logSize?: long(name='LogSize', description='The size of the log file.', example='512'),
          startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.

The value is a UNIX timestamp.', example='1695193200'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos', description='Details about the logs.'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex', description='The page number.', example='1'),
        pageSize?: long(name='PageSize', description='The number of entries per page.', example='20'),
        total?: long(name='Total', description='The total number of entries returned.', example='20'),
      }(name='PageInfos', description='The page information.'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails', description='The log information.'),
  domainName?: string(name='DomainName', description='Push domain.', example='example.com'),
  requestId?: string(name='RequestId', description='Request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model DescribeLivePushProxyLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePushProxyLogResponseBody(name='body'),
}

/**
  * @description *   The time granularity of the data is 1 hour.
  * *   You can query data in the last 31 days.
  * *   If you do not specify the StartTime or EndTime parameter, the data of the last 24 hours is queried. You can specify both the StartTime and EndTime parameters to query the data of a specific time range.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePushProxyLog  DescribeLivePushProxyLogRequest
  * @return DescribeLivePushProxyLogResponse
 */
async function describeLivePushProxyLog(request: DescribeLivePushProxyLogRequest): DescribeLivePushProxyLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePushProxyLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLivePushProxyUsageDataRequest {
  domainName?: string(name='DomainName', description='The main streaming domain to query.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time.', example='2022-10-10T21:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', description='The ID of the region. Separate multiple region IDs with commas (,). Valid values:

*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)
*   cn-shenzhen: China (Shenzhen)
*   cn-qingdao: China (Qingdao)
*   ap-southeast-1: Singapore
*   eu-central-1: Germany (Frankfurt)
*   ap-northeast-1: Japan (Tokyo)
*   ap-southeast-5: Indonesia (Jakarta)

If you do not specify this parameter, data of all regions is aggregated and returned by default.', example='cn-beijing', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitBy?: string(name='SplitBy', description='The key that is used to group data. If you do not specify this parameter, the default value region is used. Data is aggregated and returned. Separate multiple keys with commas (,). Valid values:

*   domain: The value of DomainName in the response takes effect only if SplitBy is set to domain.
*   region: This is the default value. The value of Region in the response takes effect only if SplitBy is set to region.', example='region', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. By default, data in the last seven days is returned.', example='2022-10-10T20:00:00Z', position='Query'),
}

model DescribeLivePushProxyUsageDataResponseBody = {
  endTime?: string(name='EndTime', description='The end time.', example='2022-10-10T21:00:00Z'),
  pushProxyData?: {
    pushProxyDataItem?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name. If the value of SplitBy includes domain, the returned data is grouped by domain name.', example='example.com'),
      region?: string(name='Region', description='The ID of the region. If the value of SplitBy includes region, the returned data is grouped by region.', example='cn-beijing'),
      streamCount?: long(name='StreamCount', description='The peak number of live center stream relay channels.', example='8'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2022-10-10T20:00:00Z'),
    }
  ](name='PushProxyDataItem')
  }(name='PushProxyData', description='The usage data of live center stream relay.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4B460F8B-993C-4F48-B98A-910811DEBFEB'),
  startTime?: string(name='StartTime', description='The start time.', example='2022-10-10T20:00:00Z'),
}

model DescribeLivePushProxyUsageDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLivePushProxyUsageDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the usage data of live center stream relay.
  * *   The maximum time range for a query is 31 days.
  * *   The minimum time granularity for a query is 1 day.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLivePushProxyUsageData  DescribeLivePushProxyUsageDataRequest
  * @return DescribeLivePushProxyUsageDataResponse
 */
async function describeLivePushProxyUsageData(request: DescribeLivePushProxyUsageDataRequest): DescribeLivePushProxyUsageDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLivePushProxyUsageData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveRealtimeDeliveryAccRequest {
  domainName?: string(name='DomainName', description='The streaming domain.

*   You can query one or more domain names. If you specify multiple domain names, separate them with commas (,).
*   If you leave this parameter empty, the data of all domain names within your Alibaba Cloud account is returned.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

The end time must be later than the start time. The maximum time range that can be specified is one year.', example='2015-12-10T21:05:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   **300**
*   **3600**
*   **86400**

If you specify an invalid value or do not specify this parameter, the default value is used. If the specified time range is no more than three days, the default value is 300. If the specified time range is more than three days and no more than 30 days, the default value is 3600. If the specified time range is more than 30 days, the default value is 86400.', example='3600', position='Query'),
  logStore?: string(name='LogStore', description='The name of the Logstore to which log entries are delivered. If you leave this parameter empty, the data of all Logstores is returned.', example='logstore_example', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project?: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery. If you leave this parameter empty, the data of all Log Service projects is returned.', example='project_example', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2015-12-10T20:00:00Z', position='Query'),
}

model DescribeLiveRealtimeDeliveryAccResponseBody = {
  realTimeDeliveryAccData?: {
    accData?: [ 
    {
      failedNum?: int32(name='FailedNum', description='The number of failed real-time log deliveries.', example='0'),
      successNum?: int32(name='SuccessNum', description='The number of successful real-time log deliveries.', example='321321'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the data returned.', example='2015-12-10T20:00:00Z'),
    }
  ](name='AccData')
  }(name='RealTimeDeliveryAccData', description='The information about real-time log deliveries.'),
  requestId?: string(name='RequestId', description='The request ID.', example='684306D2-2511-4977-991D-CE97E91FD7C0'),
}

model DescribeLiveRealtimeDeliveryAccResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRealtimeDeliveryAccResponseBody(name='body'),
}

/**
  * @description *   You can collect statistics on the number of real-time log deliveries. The number of failed real-time log deliveries and the number of successful real-time log deliveries are counted.
  * *   You can query the data by UID.
  * *   You are charged for both successful and failed real-time log deliveries.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveRealtimeDeliveryAcc  DescribeLiveRealtimeDeliveryAccRequest
  * @return DescribeLiveRealtimeDeliveryAccResponse
 */
async function describeLiveRealtimeDeliveryAcc(request: DescribeLiveRealtimeDeliveryAccRequest): DescribeLiveRealtimeDeliveryAccResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRealtimeDeliveryAcc', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveRealtimeLogAuthorizedRequest {
  liveOpenapiReserve?: string(name='LiveOpenapiReserve', description='This parameter has no practical significance.', example='none', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveRealtimeLogAuthorizedResponseBody = {
  authorizedStatus?: string(name='AuthorizedStatus', description='The authorization status. **true**: authorized **false**: not authorized', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91b******'),
}

model DescribeLiveRealtimeLogAuthorizedResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRealtimeLogAuthorizedResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the status of authorization for real-time log delivery.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveRealtimeLogAuthorized  DescribeLiveRealtimeLogAuthorizedRequest
  * @return DescribeLiveRealtimeLogAuthorizedResponse
 */
async function describeLiveRealtimeLogAuthorized(request: DescribeLiveRealtimeLogAuthorizedRequest): DescribeLiveRealtimeLogAuthorizedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRealtimeLogAuthorized', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveRecordConfigRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The name of the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  order?: string(name='Order', description='The order in which the entries are sorted based on creation time. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **5 to 30**. Default value: **10**.', example='5', minimum=5, maximum=30, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DescribeLiveRecordConfigResponseBody = {
  liveAppRecordList?: {
    liveAppRecord?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      createTime?: string(name='CreateTime', description='The time when the recording configuration was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-20T09:33:38Z'),
      delayTime?: int32(name='DelayTime', description='The maximum interruption duration of the live stream. If the actual interruption duration exceeds the threshold, a new recording is generated. Valid values: 15 to 21600. Unit: seconds.', example='180'),
      domainName?: string(name='DomainName', description='The name of the main streaming domain.', example='example.com'),
      endTime?: string(name='EndTime', description='The end time of the recording. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-11-08T03:49:18Z'),
      onDemond?: int32(name='OnDemond', description='The configuration of on-demand recording. Valid values:

*   **0**: disables on-demand recording.
*   **1**: enables on-demand recording that is triggered by HTTP callbacks.
*   **2**: enables on-demand recording that is triggered by stream ingest parameters.
*   **7**: enables on-demand recording by calling the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/85907.html) operation to manually start or stop recording.

>  If you set OnDemand to **1**, you must call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/51831.html) operation to configure OnDemandUrl. Otherwise, the configuration of on-demand recording is invalid.', example='0'),
      ossBucket?: string(name='OssBucket', description='The name of the Object Storage Service (OSS) bucket in which the recordings are stored.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
      recordFormatList?: {
        recordFormat?: [ 
        {
          cycleDuration?: int32(name='CycleDuration', description='The duration of a recording file. Unit: seconds.', example='3600'),
          format?: string(name='Format', description='The format of recording files.', example='M3U8'),
          ossObjectPrefix?: string(name='OssObjectPrefix', description='The naming format of a recording file.', example='record/{liveApp****}/{liveStream****}'),
          sliceDuration?: int32(name='SliceDuration', description='The duration of a segment file. Unit: seconds.', example='30'),
          sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix', description='The naming format of a segment file.', example='record/{liveApp****}/{liveStream****}/{UnixTimestamp}'),
        }
      ](name='RecordFormat')
      }(name='RecordFormatList', description='The recording formats of original streams.'),
      startTime?: string(name='StartTime', description='The start time of the recording. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2018-11-08T02:49:18Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      transcodeRecordFormatList?: {
        recordFormat?: [ 
        {
          cycleDuration?: int32(name='CycleDuration', description='The duration of a recording file. Unit: seconds.', example='3600'),
          format?: string(name='Format', description='The format of recording files.', example='M3U8'),
          ossObjectPrefix?: string(name='OssObjectPrefix', description='The naming format of a recording file.', example='record/{liveApp****}/{liveStream****}'),
          sliceDuration?: int32(name='SliceDuration', description='The duration of a segment file. Unit: seconds.', example='30'),
          sliceOssObjectPrefix?: string(name='SliceOssObjectPrefix', description='The naming format of a segment file.', example='record/{liveApp****}/{liveStream****}/{UnixTimestamp}'),
        }
      ](name='RecordFormat')
      }(name='TranscodeRecordFormatList', description='The recording formats of transcoded streams.'),
      transcodeTemplates?: {
        templates?: [ string ](name='Templates')
      }(name='TranscodeTemplates', description='The transcoding templates.'),
    }
  ](name='LiveAppRecord')
  }(name='LiveAppRecordList', description='The list of recording configurations.'),
  order?: string(name='Order', description='The sorting order of recording configurations by creation time.', example='desc'),
  pageNum?: int32(name='PageNum', description='The page number.', example='5'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='5056369B-D337-499E-B8B7-B761BD37B08A'),
  totalNum?: int32(name='TotalNum', description='The total number of recording configurations that meet the specified conditions.', example='12'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='20'),
}

model DescribeLiveRecordConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRecordConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the recording configurations of all applications under the main streaming domain.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveRecordConfig  DescribeLiveRecordConfigRequest
  * @return DescribeLiveRecordConfigResponse
 */
async function describeLiveRecordConfig(request: DescribeLiveRecordConfigRequest): DescribeLiveRecordConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRecordConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveRecordNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveRecordNotifyConfigResponseBody = {
  liveRecordNotifyConfig?: {
    domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    needStatusNotify?: boolean(name='NeedStatusNotify', description='Indicates whether recording status callbacks are enabled. Valid values:

*   **true**
*   **false** (default)', example='false'),
    notifyAuthKey?: string(name='NotifyAuthKey'),
    notifyReqAuth?: boolean(name='NotifyReqAuth'),
    notifyUrl?: string(name='NotifyUrl', description='The recording callback URL.', example='http://learn.aliyundoc.com/examplecallback.action'),
    onDemandUrl?: string(name='OnDemandUrl', description='The callback URL for on-demand recording.', example='http://guide.aliyundoc.com/ondemandcallback.action'),
  }(name='LiveRecordNotifyConfig', description='The configuration of callbacks for live stream recording.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5056369B-D337-499E-B8B7-B761BD37B08A'),
}

model DescribeLiveRecordNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRecordNotifyConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the configuration of callbacks for live stream recording under the domain name.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveRecordNotifyConfig  DescribeLiveRecordNotifyConfigRequest
  * @return DescribeLiveRecordNotifyConfigResponse
 */
async function describeLiveRecordNotifyConfig(request: DescribeLiveRecordNotifyConfigRequest): DescribeLiveRecordNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRecordNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveRecordNotifyRecordsRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2023-02-10T21:03:47Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber: long(name='PageNumber', description='The page number. Default value: 1. Valid values: 1 to 100000.

This parameter is required.', example='1', position='Query'),
  pageSize: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 500. Default value: 20.

This parameter is required.', example='10', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  You can query data within the last seven days.

This parameter is required.', example='2023-02-10T21:03:47Z', position='Query'),
  status?: string(name='Status', description='Specifies whether the callback is successful. Valid values:

*   success
*   failed', example='success', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DescribeLiveRecordNotifyRecordsResponseBody = {
  callbackList?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      description?: string(name='Description', description='The description of the result. A value of success indicates that the request is successful. If the request fails, an error message is returned.', example='success'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      notifyContent?: string(name='NotifyContent', description='The callback content.', example='July 26,  16:14{"domain":"al.xxxx.com","stream":"livestream01","pull _stream_result":true,"cdn":"al"}'),
      notifyHeader?: string(name='NotifyHeader'),
      notifyResponse?: string(name='NotifyResponse'),
      notifyResult?: string(name='NotifyResult', description='The callback result. Valid values:

*   success
*   failed', example='success'),
      notifyTime?: string(name='NotifyTime', description='The time when the callback was returned. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-10-19T19:09:28Z'),
      notifyType?: string(name='NotifyType', description='The callback type. Valid values:

*   file_created: The recording file is created.
*   record_error: A recording error occurs.
*   record_started: Recording is started.
*   record_paused: Recording is paused.
*   record_resumed: Recording is resumed.
*   record_force_transcode_fail: The recording task fails to trigger transcoding.
*   transformat_error: An error occurs when the live stream is parsed.', example='record_started'),
      notifyUrl?: string(name='NotifyUrl', description='The recording callback URL.', example='http://learn.aliyundoc.com/examplecallback.action'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    }
  ](name='CallbackList', description='The callback records.'),
  code?: int32(name='Code', description='The error code.', example='0'),
  msg?: string(name='Msg', description='The returned message.', example='ok'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='180FA0D2-1A02-5158-A36B-115DBF7B218D'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='20'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='20'),
}

model DescribeLiveRecordNotifyRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRecordNotifyRecordsResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveRecordNotifyRecords  DescribeLiveRecordNotifyRecordsRequest
  * @return DescribeLiveRecordNotifyRecordsResponse
 */
async function describeLiveRecordNotifyRecords(request: DescribeLiveRecordNotifyRecordsRequest): DescribeLiveRecordNotifyRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRecordNotifyRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveRecordVodConfigsRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: long(name='PageNum', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Default value: **10**. Valid values: **5 to 100**.', example='10', minimum=5, maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
}

model DescribeLiveRecordVodConfigsResponseBody = {
  liveRecordVodConfigs?: {
    liveRecordVodConfig?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      autoCompose?: string(name='AutoCompose', description='Indicates whether automatic merging is enabled. Valid values:

*   **ON**
*   **OFF**', example='ON'),
      composeVodTranscodeGroupId?: string(name='ComposeVodTranscodeGroupId', description='The ID of the transcoding template group that was used to automatically merge the VOD files created from the live streams.

>  This parameter is returned if the value of the AutoCompose parameter is ON.', example='dadfcaadde****'),
      createTime?: string(name='CreateTime', description='The time when the live stream was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T17:37:00Z'),
      cycleDuration?: int32(name='CycleDuration', description='The recording cycle. Unit: seconds. Default value: **3600**. Valid values: **300 to 21600**.', example='360'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      onDemand?: int32(name='OnDemand', description='Indicates whether on-demand recording is enabled. Valid values:

*   **0** (default): On-demand recording is disabled.
*   **1**: On-demand recording is enabled by using the HTTP callback method.', example='0'),
      storageLocation?: string(name='StorageLocation', description='The storage location.', example='****-tjptr2vatm.oss-cn-shanghai.aliyuncs.com'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      vodTranscodeGroupId?: string(name='VodTranscodeGroupId', description='The ID of the transcoding template group in ApsaraVideo VOD.', example='e2d796d3bb5fd8049d32bff62f94****'),
    }
  ](name='LiveRecordVodConfig')
  }(name='LiveRecordVodConfigs', description='The configurations.'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='1'),
  requestId?: string(name='RequestId', description='The request ID.', example='5056369B-D337-499E-B8B7-B761BD37B08A'),
  total?: string(name='Total', description='The total number of entries returned.', example='100'),
}

model DescribeLiveRecordVodConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveRecordVodConfigsResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Obtain the streaming domain, and then call this operation to query the Live-to-VOD configurations.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveRecordVodConfigs  DescribeLiveRecordVodConfigsRequest
  * @return DescribeLiveRecordVodConfigsResponse
 */
async function describeLiveRecordVodConfigs(request: DescribeLiveRecordVodConfigsRequest): DescribeLiveRecordVodConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveRecordVodConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveShiftConfigsRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveShiftConfigsResponseBody = {
  content?: {
    config?: [ 
    {
      appName?: string(name='AppName', description='The application for which you configure time shifting.', example='liveApp****'),
      domainName?: string(name='DomainName', description='The domain name for which you configure time shifting.', example='example.com'),
      ignoreTranscode?: boolean(name='IgnoreTranscode', description='Whether to ignore time shift generation for the transcode stream.

*   true: Ignore time shifting generation.
*   false: Generate time shifting.

The default value is true.', example='true'),
      streamName?: string(name='StreamName', description='The name of the live stream for which you configure time shifting.', example='liveStream****'),
      vision?: int32(name='Vision', description='The number of days for which the time shifting configurations are retained.', example='7'),
    }
  ](name='Config')
  }(name='Content', description='The time shifting configurations.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B49E6DDA-F413-422B-B58E-2FA23F286726'),
}

model DescribeLiveShiftConfigsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveShiftConfigsResponseBody(name='body'),
}

/**
  * @description This operation is applicable to the streaming domains.
  * ## QPS limit
  * A single user can perform a maximum of 10 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
  * @param request  the request parameters of DescribeLiveShiftConfigs  DescribeLiveShiftConfigsRequest
  * @return DescribeLiveShiftConfigsResponse
 */
async function describeLiveShiftConfigs(request: DescribeLiveShiftConfigsRequest): DescribeLiveShiftConfigsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveShiftConfigs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveSnapshotConfigRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  order?: string(name='Order', description='The sort order. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **5 to 30**. Default value: **10**.', example='10', minimum=5, maximum=30, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveSnapshotConfigResponseBody = {
  liveStreamSnapshotConfigList?: {
    liveStreamSnapshotConfig?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      callback?: string(name='Callback', description='The callback URL that is used to receive notifications about snapshot capture.', example='https://learn.aliyundoc.com'),
      createTime?: string(name='CreateTime', description='The time when the configuration was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-20T01:33:38Z'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      ossBucket?: string(name='OssBucket', description='The name of the Object Storage Service (OSS) bucket.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
      overwriteOssObject?: string(name='OverwriteOssObject', description='The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.', example='{liveApp****}/{liveStream****}.jpg'),
      sequenceOssObject?: string(name='SequenceOssObject', description='The naming format of snapshots that are stored in sequence, which means that a new snapshot does not overwrite the previous snapshot.', example='snapshot/{liveApp****}/{liveStream****}/{UnixTimestamp}.jpg'),
      timeInterval?: int32(name='TimeInterval', description='The interval at which snapshots are captured. Unit: seconds.', example='10'),
    }
  ](name='LiveStreamSnapshotConfig')
  }(name='LiveStreamSnapshotConfigList', description='The snapshot configurations.'),
  order?: string(name='Order', description='The sort order.', example='asc'),
  pageNum?: int32(name='PageNum', description='The page number.', example='2'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='11'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3136B58-5876-4168-83CA-B562781981A0'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='6'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='10'),
}

model DescribeLiveSnapshotConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveSnapshotConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the snapshot configurations.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveSnapshotConfig  DescribeLiveSnapshotConfigRequest
  * @return DescribeLiveSnapshotConfigResponse
 */
async function describeLiveSnapshotConfig(request: DescribeLiveSnapshotConfigRequest): DescribeLiveSnapshotConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveSnapshotConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveSnapshotDetectPornConfigRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  order?: string(name='Order', description='The order in which the entries are sorted based on creation time. Valid values:

*   **Asc** (default): ascending order
*   **Desc**: descending order

Enumerated values:

*   asc
*   desc', example='Asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **5 to 30**. Default value: **10**.', example='10', minimum=5, maximum=30, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveSnapshotDetectPornConfigResponseBody = {
  liveSnapshotDetectPornConfigList?: {
    liveSnapshotDetectPornConfig?: [ 
    {
      appName?: string(name='AppName', description='The application name.', example='liveApp****'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      interval?: int32(name='Interval', description='The interval at which snapshots are captured from the live stream. Unit: seconds.', example='80'),
      ossBucket?: string(name='OssBucket', description='The name of the OSS bucket.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
      ossObject?: string(name='OssObject', description='The name of the storage file in Object Storage Service (OSS).', example='{liveApp****}/{liveStream****}/{Date}/{Hour}/{Minute}_{Second}.jpg'),
      scenes?: {
        scene?: [ string ](name='scene')
      }(name='Scenes', description='The moderation scenario array.'),
    }
  ](name='LiveSnapshotDetectPornConfig')
  }(name='LiveSnapshotDetectPornConfigList', description='The list of video moderation configurations.'),
  order?: string(name='Order', description='The sort order.', example='Asc'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='2'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='6'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='11'),
}

model DescribeLiveSnapshotDetectPornConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveSnapshotDetectPornConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to query video moderation configurations. The configurations can be sorted in ascending or descending order.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveSnapshotDetectPornConfig  DescribeLiveSnapshotDetectPornConfigRequest
  * @return DescribeLiveSnapshotDetectPornConfigResponse
 */
async function describeLiveSnapshotDetectPornConfig(request: DescribeLiveSnapshotDetectPornConfigRequest): DescribeLiveSnapshotDetectPornConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveSnapshotDetectPornConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveSnapshotNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='www.yourdomain***.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveSnapshotNotifyConfigResponseBody = {
  domainName?: string(name='DomainName', description='The main streaming domain.', example='www.yourdomain***.com'),
  notifyAuthKey?: string(name='NotifyAuthKey', description='The callback authentication key.', example='yourkey'),
  notifyReqAuth?: string(name='NotifyReqAuth', description='Indicates whether callback authentication is enabled. Valid values:

*   **yes**: Callback authentication is enabled.
*   **no**: Callback authentication is disabled.', example='yes'),
  notifyUrl?: string(name='NotifyUrl', description='The callback URL.', example='http://callback.yourdomain***.com'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5056369B-D337-499E-B8B7-B761BD37B08A'),
}

model DescribeLiveSnapshotNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveSnapshotNotifyConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveSnapshotNotifyConfig  DescribeLiveSnapshotNotifyConfigRequest
  * @return DescribeLiveSnapshotNotifyConfigResponse
 */
async function describeLiveSnapshotNotifyConfig(request: DescribeLiveSnapshotNotifyConfigRequest): DescribeLiveSnapshotNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveSnapshotNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamAuthCheckingRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  url: string(name='Url', description='The complete ingest URL or streaming URL. You can use the [URL generator](https://help.aliyun.com/document_detail/197400.html) to generate a URL.

This parameter is required.', example='http://example.com/live/test.flv?auth_key=1664248******', position='Query'),
}

model DescribeLiveStreamAuthCheckingResponseBody = {
  description?: string(name='Description', description='The error message for failed authentication.', example='INVALID AUTH_KEY'),
  requestId?: string(name='RequestId', description='The request ID.', example='16F08B4E-14FD-5D72-AB2F-BAFA4C4D57F1'),
  status?: string(name='Status', description='Indicates whether the signed URL is valid. Valid values:

*   pass: valid.
*   false: invalid.', example='pass'),
}

model DescribeLiveStreamAuthCheckingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamAuthCheckingResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamAuthChecking  DescribeLiveStreamAuthCheckingRequest
  * @return DescribeLiveStreamAuthCheckingResponse
 */
async function describeLiveStreamAuthChecking(request: DescribeLiveStreamAuthCheckingRequest): DescribeLiveStreamAuthCheckingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamAuthChecking', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamBitRateDataRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamBitRateDataResponseBody = {
  frameRateAndBitRateInfos?: {
    frameRateAndBitRateInfo?: [ 
    {
      audioFrameRate?: float(name='AudioFrameRate', description='The audio frame rate of the live stream. Unit: FPS.', example='100'),
      bitRate?: float(name='BitRate', description='The bitrate of the live stream. Unit: bit/s.', example='600'),
      streamUrl?: string(name='StreamUrl', description='The URL of the live stream.'),
      time?: string(name='Time', description='The time when the data was collected. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-09-13T16:04:00Z'),
      videoFrameRate?: float(name='VideoFrameRate', description='The video frame rate of the live stream. Unit: frames per second (FPS).', example='30'),
    }
  ](name='FrameRateAndBitRateInfo')
  }(name='FrameRateAndBitRateInfos', description='The frame rates and bitrates of the live stream.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeLiveStreamBitRateDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamBitRateDataResponseBody(name='body'),
}

/**
  * @description This operation allows you to query the frame rates and bitrates of an RTMP stream within a specified time period. You can call this operation to query historical data.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamBitRateData  DescribeLiveStreamBitRateDataRequest
  * @return DescribeLiveStreamBitRateDataResponse
 */
async function describeLiveStreamBitRateData(request: DescribeLiveStreamBitRateDataRequest): DescribeLiveStreamBitRateDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamBitRateData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamCountRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamCountResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='FCFFE4A4-F34F-4EEF-B401-36A01689AFBC'),
  streamCountInfos?: {
    streamCountInfo?: [ 
    {
      count?: long(name='Count', description='The number of online streams.', example='3'),
      limit?: long(name='Limit', description='The maximum allowed number of concurrently ingested streams. This parameter is available only to users in the whitelist.', example='10'),
      streamCountDetails?: {
        streamCountDetail?: [ 
        {
          count?: long(name='Count', description='The number of online streams.', example='2'),
          format?: string(name='Format', description='The video codec. Valid values:

*   **h264**
*   **h265**', example='h264'),
          videoDataRate?: long(name='VideoDataRate', description='The video bitrate. This parameter is returned only for transcoded streams.', example='390'),
        }
      ](name='StreamCountDetail')
      }(name='StreamCountDetails', description='The information about the live streams.'),
      type?: string(name='Type', description='The type of the live stream. Valid values:

*   **raw**: source streams
*   **trans**: transcoded streams', example='raw'),
    }
  ](name='StreamCountInfo')
  }(name='StreamCountInfos', description='The statistics of the live streams.'),
}

model DescribeLiveStreamCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamCountResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the numbers of online source streams and transcoded streams. The streams that are returned by calling this operation are encoded in H.264 or H.265.
  * ## [](#qps-)QPS limit
  * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamCount  DescribeLiveStreamCountRequest
  * @return DescribeLiveStreamCountResponse
 */
async function describeLiveStreamCount(request: DescribeLiveStreamCountRequest): DescribeLiveStreamCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamCount', 'GET', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamDelayConfigRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamDelayConfigResponseBody = {
  liveStreamFlvDelayConfig?: {
    delay?: int32(name='Delay', description='The playback latency. Unit: seconds.', example='5'),
    level?: string(name='Level', description='The latency level. Valid values:

*   **short**: The latency is less than or equal to 4 seconds.
*   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
*   **long**: The latency is greater than 8 seconds.', example='medium'),
  }(name='LiveStreamFlvDelayConfig', description='The latency of FLV-based playback.'),
  liveStreamHlsDelayConfig?: {
    delay?: int32(name='Delay', description='The playback latency. Unit: seconds.', example='3'),
    level?: string(name='Level', description='The latency level. Valid values:

*   **short**: The latency is less than or equal to 4 seconds.
*   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
*   **long**: The latency is greater than 8 seconds.', example='short'),
  }(name='LiveStreamHlsDelayConfig', description='The latency of HLS-based playback.'),
  liveStreamRtmpDelayConfig?: {
    delay?: int32(name='Delay', description='The playback latency. Unit: seconds.', example='4'),
    level?: string(name='Level', description='The latency level. Valid values:

*   **short**: The latency is less than or equal to 4 seconds.
*   **medium**: The latency is greater than 4 seconds, and less than or equal to 8 seconds.
*   **long**: The latency is greater than 8 seconds.', example='short'),
  }(name='LiveStreamRtmpDelayConfig', description='The latency of RTMP-based playback.'),
  requestId?: string(name='RequestId', description='The request ID.', example='785C9CB0-EB8A-4912-BBF2-966BEFD32DC3'),
}

model DescribeLiveStreamDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamDelayConfigResponseBody(name='body'),
}

/**
  * @description Obtain the streaming domain, and then call this operation to query the live streaming latency.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamDelayConfig  DescribeLiveStreamDelayConfigRequest
  * @return DescribeLiveStreamDelayConfigResponse
 */
async function describeLiveStreamDelayConfig(request: DescribeLiveStreamDelayConfigRequest): DescribeLiveStreamDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamDetailFrameRateAndBitRateDataRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='AppName', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain or streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  If the StartTime and EndTime parameters are invalid, or if the StartTime and EndTime parameters are not specified, data in the last hour is queried by default.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='exampleStreamName', position='Query'),
}

model DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody = {
  frameRateAndBitRateInfos?: [ 
    {
      audioBitRate?: float(name='AudioBitRate', description='The audio bitrate of the live stream. Unit: bit/s.', example='200'),
      audioFrameRate?: float(name='AudioFrameRate', description='The audio frame rate of the live stream. Unit: FPS.', example='60'),
      bitRate?: float(name='BitRate', description='The bitrate of the live stream. Unit: bit/s.', example='1420'),
      streamUrl?: string(name='StreamUrl', description='The URL of the live stream.', example='rtmp://example.com/AppName/exampleStreamName'),
      time?: string(name='Time', description='The time when the data was collected. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-09-13T16:04:00Z'),
      videoBitRate?: float(name='VideoBitRate', description='The video bitrate of the live stream. Unit: bit/s.', example='1200'),
      videoFrameRate?: float(name='VideoFrameRate', description='The video frame rate of the live stream. Unit: frames per second (FPS).', example='30'),
    }
  ](name='FrameRateAndBitRateInfos', description='The audio and video frame rates and bitrates at each time granularity.'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
}

model DescribeLiveStreamDetailFrameRateAndBitRateDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamDetailFrameRateAndBitRateDataResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query a set of audio and video frame rates and bitrates of an RTMP stream within a specified time range.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * *   You can query data in the last 90 days.
  * *   The data is delayed for 3 to 5 minutes.
  * *   The maximum time range that you can specify is 1 hour.
  * @param request  the request parameters of DescribeLiveStreamDetailFrameRateAndBitRateData  DescribeLiveStreamDetailFrameRateAndBitRateDataRequest
  * @return DescribeLiveStreamDetailFrameRateAndBitRateDataResponse
 */
async function describeLiveStreamDetailFrameRateAndBitRateData(request: DescribeLiveStreamDetailFrameRateAndBitRateDataRequest): DescribeLiveStreamDetailFrameRateAndBitRateDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamDetailFrameRateAndBitRateData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamHistoryUserNumRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  The time range specified by the StartTime and EndTime parameters cannot exceed one day. The end time must not be later than the current time.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  You can query data in the last **30** days.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamHistoryUserNumResponseBody = {
  liveStreamUserNumInfos?: {
    liveStreamUserNumInfo?: [ 
    {
      streamTime?: string(name='StreamTime', description='The time when the stream started. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-10-20T06:20:00Z'),
      userNum?: string(name='UserNum', description='The number of users at the current point in time.', example='1'),
    }
  ](name='LiveStreamUserNumInfo')
  }(name='LiveStreamUserNumInfos', description='The number of historical online users for the live stream.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F5FF8'),
}

model DescribeLiveStreamHistoryUserNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamHistoryUserNumResponseBody(name='body'),
}

/**
  * @description *   The data returned by this operation is delayed for an average of 2 to 5 minutes.
  * *   This operation queries the number of historical online users for only Flash Video (FLV) and Real-Time Messaging Protocol (RTMP) streams.
  * *   This operation does not query the number of viewers that are watching transcoded streams.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamHistoryUserNum  DescribeLiveStreamHistoryUserNumRequest
  * @return DescribeLiveStreamHistoryUserNumResponse
 */
async function describeLiveStreamHistoryUserNum(request: DescribeLiveStreamHistoryUserNumRequest): DescribeLiveStreamHistoryUserNumResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamHistoryUserNum', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamMergeRequest {
  appName?: string(name='AppName', description='The name of the application that generates the output stream. You can view the application name on the [Primary/Secondary Stream Mixing Settings](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.', example='app', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  protocol?: string(name='Protocol', description='The streaming protocol. Valid values:

*   **rtmp**: This is the default value.
*   **rtc**', example='rtmp', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the output stream. You can view the stream name on the [Primary/Secondary Stream Mixing Settings](https://help.aliyun.com/document_detail/606583.html) page of the ApsaraVideo Live console.', example='StreamName', position='Query'),
}

model DescribeLiveStreamMergeResponseBody = {
  liveStreamMergeList?: {
    liveStreamMerge?: [ 
    {
      appName?: string(name='AppName', description='The name of the application that generates the output stream.', example='app'),
      appUsing?: string(name='AppUsing', description='The application that is being used.', example='app1'),
      domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
      endTime?: string(name='EndTime', description='The end time of the stream mixing.', example='2020-05-29T01:00:00Z'),
      extraInAppStreams?: string(name='ExtraInAppStreams', description='The names of the applications that generate the input additional streams other than the primary stream and secondary stream, and the names of these additional streams.', example='app3/stream3,app4/stream4,app5/stream5,…,appN/streamN'),
      inAppName1?: string(name='InAppName1', description='The name of the application that generates the input primary stream.', example='app1'),
      inAppName2?: string(name='InAppName2', description='The name of the application that generates the input secondary stream.', example='app2'),
      inStreamName1?: string(name='InStreamName1', description='The name of the input primary stream.', example='InStream1'),
      inStreamName2?: string(name='InStreamName2', description='The name of the input secondary stream.', example='stream2'),
      liveMerger?: string(name='LiveMerger'),
      mergeParameters?: string(name='MergeParameters'),
      protocol?: string(name='Protocol', description='The streaming protocol.', example='rtmp'),
      startTime?: string(name='StartTime', description='The start time of the stream mixing.', example='2020-05-29T00:00:00Z'),
      streamName?: string(name='StreamName', description='The name of the output stream.', example='StreamName'),
      streamUsing?: string(name='StreamUsing', description='The stream that is being used.', example='InStream1'),
    }
  ](name='LiveStreamMerge')
  }(name='LiveStreamMergeList', description='Live stream information list.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model DescribeLiveStreamMergeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamMergeResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamMerge  DescribeLiveStreamMergeRequest
  * @return DescribeLiveStreamMergeResponse
 */
async function describeLiveStreamMerge(request: DescribeLiveStreamMergeRequest): DescribeLiveStreamMergeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamMerge', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamMetricDetailDataRequest {
  appName?: string(name='AppName', description='The name of the application for which you want to query the monitoring data of streams.

>  If you specify the StreamName parameter, you must also specify the AppName parameter.', example='liveApp****', position='Query'),
  domainName?: string(name='DomainName', description='*   The accelerated domain name. You can specify only one domain name. If you specify multiple domain names, an error occurs.
*   If you do not specify the AppName and StreamName parameters, monitoring data of all streams for the domain name is returned.
*   If you leave this parameter empty, monitoring data of streams under all domain names is returned.
*   If you specify the DomainName parameter and set both the AppName and StreamName parameters to all, monitoring data of all streams in all applications under the specified domain name is returned.
*   When you specify the DomainName parameter, make sure that the domain name is a domain name used for live streaming and that you have the permissions on the domain name.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time, and the maximum time range that can be specified is one day. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2015-12-10T21:00:00Z', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='The token used to query data by page. Up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, a token that determines the start point of the next query is provided in the response. If you specify this parameter, data continues to be obtained from the end of the previous query.', example='UjsM9x3aVcJi9a0-ArwJUTTC67CIBKLw*****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  protocol?: string(name='Protocol', description='The streaming protocol. Valid values: **flv**, **hls**, **rtmp**, **rts**, and **p2p**.

You can specify multiple protocols. Separate multiple protocols with commas (,). However, data over multiple protocols is not aggregated and is returned based on the stream.', example='flv', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2015-12-10T20:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the stream. The stream must belong to the application that is specified by the AppName parameter.

>  If you specify the StreamName parameter, you must also specify the AppName parameter.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamMetricDetailDataResponseBody = {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried.', example='2015-12-10T21:00:00Z'),
  nextPageToken?: string(name='NextPageToken', description='The token that determines the start point of the next query. This parameter is returned if more data results are available.', example='UjsM9x3aVcJi9a0-ArwJUTTC67C***37C0='),
  pageSize?: int32(name='PageSize', description='The number of rows returned.', example='5000'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B955107D-E658-4E77-B913-E0AC3D31693E'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried.', example='2015-12-10T20:00:00Z'),
  streamDetailData?: {
    streamData?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='app'),
      bps?: float(name='Bps', description='The total bandwidth consumed by the stream per minute. Unit: bit/s.', example='423304182.66'),
      count?: long(name='Count', description='The total number of online viewers for the stream per minute.', example='423304182'),
      flvBps?: float(name='FlvBps', description='The bandwidth over the Flash Video (FLV) protocol. Unit: bit/s.

>  This parameter is not returned if no traffic is generated over the protocol.', example='454'),
      flvCount?: long(name='FlvCount', description='The number of online viewers over the FLV protocol.

>  This parameter is not returned if no traffic is generated over the protocol.', example='32'),
      flvTraffic?: long(name='FlvTraffic', description='The amount of traffic over the FLV protocol. Unit: bytes.

>  This parameter is not returned if no traffic is generated over the protocol.', example='1254'),
      hlsBps?: float(name='HlsBps', description='The bandwidth over the HTTP Live Streaming (HLS) protocol. Unit: bit/s.

>  This parameter is not returned if no traffic is generated over the protocol.', example='4456'),
      hlsCount?: long(name='HlsCount', description='The number of online viewers over the HLS protocol.

>  Currently, this parameter is not supported.', example='56'),
      hlsTraffic?: long(name='HlsTraffic', description='The amount of traffic over the HLS protocol. Unit: bytes.

>  This parameter is not returned if no traffic is generated over the protocol.', example='568'),
      newConns?: string(name='NewConns', description='Number of new connections established per minute.', example='450'),
      p2pBps?: float(name='P2pBps', description='The bandwidth over the P2P protocol. Unit: bit/s.

>  This parameter is not returned if no traffic is generated over the protocol.', example='6845'),
      p2pCount?: long(name='P2pCount', description='The number of online viewers over the P2P protocol.

>  This parameter is not returned if no traffic is generated over the protocol.', example='78'),
      p2pTraffic?: long(name='P2pTraffic', description='The amount of traffic over the peer-to-peer (P2P) protocol. Unit: bytes.

>  This parameter is not returned if no traffic is generated over the protocol.', example='4102'),
      rtmpBps?: float(name='RtmpBps', description='The bandwidth over the Real-Time Messaging Protocol (RTMP) protocol. Unit: bit/s.

>  This parameter is not returned if no traffic is generated over the protocol.', example='3323'),
      rtmpCount?: long(name='RtmpCount', description='The number of online viewers over the RTMP protocol.

>  This parameter is not returned if no traffic is generated over the protocol.', example='63'),
      rtmpTraffic?: long(name='RtmpTraffic', description='The amount of traffic over the RTMP protocol. Unit: bytes.

>  This parameter is not returned if no traffic is generated over the protocol.', example='5568'),
      rtsBps?: float(name='RtsBps', description='The bandwidth over the RTS protocol. Unit: bit/s.

>  This parameter is not returned if no traffic is generated over the protocol.', example='2361'),
      rtsCount?: long(name='RtsCount', description='The number of online viewers over the Real-Time Streaming (RTS) protocol.

>  This parameter is not returned if no traffic is generated over the protocol.', example='89'),
      rtsTraffic?: long(name='RtsTraffic', description='The amount of traffic over the RTS protocol. Unit: bytes.

>  This parameter is not returned if no traffic is generated over the protocol.', example='2322'),
      streamName?: string(name='StreamName', description='The name of the stream.', example='test.flv'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2015-12-10T20:00:00Z'),
      traffic?: long(name='Traffic', description='The total amount of traffic consumed by the stream per minute. Unit: bytes.', example='423304182'),
    }
  ](name='StreamData')
  }(name='StreamDetailData', description='The data array returned.'),
}

model DescribeLiveStreamMetricDetailDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamMetricDetailDataResponseBody(name='body'),
}

/**
  * @description If you call this operation to query the monitoring data of streams under a domain name for the first time, you must [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex) for backend configuration. Provide the following information in the ticket:
  * *   The domain name that you want to query
  * *   The maximum number of concurrent streams under the domain name
  * *   The maximum number of concurrent online users in each stream
  * *   The protocols used for the client requests
  * >  The review is expected to be completed within one business day after you submit the ticket.
  * ## [](#)Usage limits
  * *   By default, statistics on the number of viewers who watch streams over the HTTP Live Streaming (HLS) protocol cannot be collected.
  * *   You can specify only one domain name in each call.
  * *   The maximum time range to query is 24 hours.
  * *   The minimum data granularity to query is 1 minute.
  * *   You can query data in the last 31 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamMetricDetailData  DescribeLiveStreamMetricDetailDataRequest
  * @return DescribeLiveStreamMetricDetailDataResponse
 */
async function describeLiveStreamMetricDetailData(request: DescribeLiveStreamMetricDetailDataRequest): DescribeLiveStreamMetricDetailDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamMetricDetailData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamMonitorListRequest {
  monitorId?: string(name='MonitorId', description='The ID of the monitoring session.

>  You can obtain the monitoring session ID from the response parameter MonitorId of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation. If you leave this parameter empty, the data of all monitoring sessions is returned.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  orderRule?: int32(name='OrderRule', description='The sorting order of monitoring sessions. Valid values:

*   0: Monitoring sessions are sorted by status.
*   1: Monitoring sessions are sorted by start time in descending order.
*   2: Monitoring sessions are sorted by start time in ascending order.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number.', example='2', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of monitoring sessions to return per page.', example='10', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  status?: int32(name='Status', description='The status of the monitoring session. Valid values:

*   1: Monitoring
*   0: Unmonitored', example='1', position='Query'),
}

model DescribeLiveStreamMonitorListResponseBody = {
  liveStreamMonitorList?: [ 
    {
      audioFrom?: int32(name='AudioFrom', description='The audio source in the layout.', example='1'),
      callbackUrl?: string(name='CallbackUrl', description='The callback URL that sends monitoring alerts.', example='http://guide.aliyundoc.com/notify'),
      dingTalkWebHookUrl?: string(name='DingTalkWebHookUrl', description='The URL of the DingTalk chatbot.', example='https://oapi.dingtalk.com/robot/send?access_token=7a7d404056eee1f2fd944ace9bcfc361dc6448583e1d3d3baa****'),
      domain?: string(name='Domain', description='The domain name.', example='demo.aliyundoc.com'),
      inputList?: [ 
        {
          index?: int32(name='Index', description='The index.', example='1'),
          inputUrl?: string(name='InputUrl', description='The URL of the input stream.', example='demo.aliyundoc.com'),
          layoutConfig?: {
            fillMode?: string(name='FillMode', description='The fill type. Set this value to none.', example='none'),
            positionNormalized?: [ float ](name='PositionNormalized', description='The position of the layer, in the format of [unk][x,y][unk]. The values of x and y need to be normalized.'),
            positionRefer?: string(name='PositionRefer', description='The reference position of the element. Valid values:

*   topLeft
*   topRight
*   bottomLeft
*   bottomRight', example='topLeft'),
            sizeNormalized?: [ float ](name='SizeNormalized', description='The size of the layer. Unit: bytes.'),
          }(name='LayoutConfig', description='The layout information.'),
          layoutId?: int32(name='LayoutId', description='The layout ID, which must start from 1.', example='1'),
          playConfig?: {
            volumeRate?: float(name='VolumeRate', description='The volume. Valid values: 0 to 1. The value is rounded to two decimal places.', example='0.50'),
          }(name='PlayConfig', description='The playback configurations.'),
          streamName?: string(name='StreamName', description='The display name of the monitored stream.', example='monitorStream****'),
        }
      ](name='InputList', description='The list of monitored input streams.'),
      monitorConfig?: string(name='MonitorConfig', description='The monitoring alert thresholds. The following fields are included:

*   fpsLowThres: the video frame rate alert threshold. The value is a floating-point number.
*   brHighThres: the audio/video bitrate alert threshold. The value is a floating-point number.
*   eofDurationThresSec: the interruption duration alert threshold. The value is a floating-point number.', example='"{\\"fpsLowThres\\": 0.6,\\"brLowThres\\": 1.1,\\"eofDurationThresSec\\": 10}"'),
      monitorId?: string(name='MonitorId', description='The ID of the monitoring session.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
      monitorName?: string(name='MonitorName', description='The name of the monitoring session.', example='liveMonito****'),
      outputTemplate?: string(name='OutputTemplate', description='The output resolution template. Valid values:

*   **lp_ld**: low definition
*   **lp_sd**: standard definition
*   **lp_hd**: high definition
*   **lp_ud**: ultra-high definition', example='lp_ud'),
      outputUrls?: {
        flvUrl?: string(name='FlvUrl', description='The output URL in the Flash Video (FLV) format.', example='http://demo.aliyundoc.com/monitor/445409ec-7eaa-461d-8f29-4bec2eb9****.flv'),
        rtmpUrl?: string(name='RtmpUrl', description='The output URL in the Real-Time Messaging Protocol (RTMP) format.', example='rtmp://demo.aliyundoc.com/monitor/445409ec-7eaa-461d-8f29-4bec2eb9****'),
      }(name='OutputUrls', description='The output URLs.'),
      region?: string(name='Region', description='The ID of the region. Valid values:

*   cn-shanghai: China (Shanghai)
*   cn-beijing: China (Beijing)
*   ap-southeast-1: Singapore', example='cn-shanghai'),
      startTime?: string(name='StartTime', description='The start time of live monitoring. The time is displayed in UTC.', example='2017-01-11T12:00:00Z'),
      status?: int32(name='Status', description='The status of the monitoring session. Valid values:

*   1: Monitoring
*   0: Unmonitored', example='1'),
      stopTime?: string(name='StopTime', description='The end time of live monitoring. The time is displayed in UTC.', example='2017-01-11T12:00:00Z'),
    }
  ](name='LiveStreamMonitorList', description='The list of monitoring sessions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='2234baba-a586-46ea-8bd4-c8f7891abcdef'),
  total?: int32(name='Total', description='The number of monitoring sessions.', example='1'),
}

model DescribeLiveStreamMonitorListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamMonitorListResponseBody(name='body'),
}

/**
  * @description [Create monitoring sessions](https://help.aliyun.com/document_detail/2848129.html) before you call this operation to query the monitoring session list. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamMonitorList  DescribeLiveStreamMonitorListRequest
  * @return DescribeLiveStreamMonitorListResponse
 */
async function describeLiveStreamMonitorList(request: DescribeLiveStreamMonitorListRequest): DescribeLiveStreamMonitorListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamMonitorList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamPreloadTasksRequest {
  domainName: string(name='DomainName', description='The streaming domain name.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-30T19:00:00Z. The interval between the start time and end time cannot exceed three days.', example='2016-06-30T19:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.', example='10', position='Query'),
  playUrl?: string(name='PlayUrl', description='The streaming URL. You can specify up to 100 streaming URLs in a request. Separate multiple streaming URLs with commas (,).', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-29T19:00:00Z. You can query only data in the previous three days.', example='2016-06-29T19:00:00Z', position='Query'),
  status?: string(name='Status', description='The status of the prefetch task. Valid values:

*   complete
*   pending
*   preloading
*   failed', example='complete', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the prefetch task. The task ID is returned when you call the [SetLiveStreamPreloadTasks](https://help.aliyun.com/document_detail/2519938.html) operation to configure the prefetch task.', example='yourTaskId', position='Query'),
}

model DescribeLiveStreamPreloadTasksResponseBody = {
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='2'),
  preloadTasks?: {
    preloadTask?: [ 
    {
      area?: string(name='Area', description='The acceleration region where the live content is prefetched. Valid values:

*   domestic: regions in the Chinese mainland.
*   overseas: regions outside the Chinese mainland.
*   global: regions in and outside the Chinese mainland.

>  If this parameter is left empty, the acceleration region configured for the domain name is returned.', example='domestic'),
      createTime?: string(name='CreateTime', description='The time when the prefetch task was created.', example='2016-06-29T19:00:00Z'),
      description?: string(name='Description', description='Indicates whether the prefetch task is successful. Valid values:

*   Successfully
*   InternalError', example='Successfully'),
      domainName?: string(name='DomainName', description='The streaming domain name.', example='example.com'),
      playUrl?: string(name='PlayUrl', description='The streaming URL.'),
      preloadedEndTime?: string(name='PreloadedEndTime', description='The time when the prefetch task ended.', example='2016-06-30T19:00:00Z'),
      preloadedStartTime?: string(name='PreloadedStartTime', description='The time when the prefetch task started.', example='2016-06-29T19:00:00Z'),
      process?: string(name='Process', description='The progress of the prefetch task.', example='100%'),
      status?: string(name='Status', description='The status of the prefetch task. Valid values:

*   Success
*   Failed

>  Success is returned only if the prefetch task is configured for all streaming URLs.', example='Success'),
      taskId?: string(name='TaskId', description='The ID of the prefetch task.', example='yourTaskId'),
    }
  ](name='PreloadTask')
  }(name='PreloadTasks', description='The details of the prefetch task.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E1564CBC-DCFE-5E1B-8B78-8DED9A39F334'),
  totalNum?: int32(name='TotalNum', description='The total number of entries returned.', example='1'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='1'),
}

model DescribeLiveStreamPreloadTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamPreloadTasksResponseBody(name='body'),
}

/**
  * @description You can call this operation to query prefetch tasks in the last three days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamPreloadTasks  DescribeLiveStreamPreloadTasksRequest
  * @return DescribeLiveStreamPreloadTasksResponse
 */
async function describeLiveStreamPreloadTasks(request: DescribeLiveStreamPreloadTasksRequest): DescribeLiveStreamPreloadTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamPreloadTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamPushMetricDetailDataRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. The stream-level data of this application is returned.', example='app', position='Query'),
  domainName: string(name='DomainName', description='*   The accelerated domain name. You can specify only one domain name. If you specify multiple domain names, an error occurs.
*   If you do not specify the AppName and StreamName parameters, data of all streams under the specified domain name is returned. The data is not aggregated.
*   If you specify the DomainName parameter and set both the AppName and StreamName parameters to all, data of all streams in all applications under the specified domain name is aggregated and returned.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time, and the maximum time range that can be specified is one day. Specify the time in the ISO 8601 standard

in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2022-09-10T21:00:00Z', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.

When you specify the token in the next query, data continues to be obtained from the end of the previous query.', example='UjsM9x3aVcJi9a0-ArwJUTTC67C***37C0=', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the YYYY-MM-DDThh:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2022-09-10T20:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. The data of the stream in the specified application is returned. If the StreamName parameter is specified, the AppName parameter must also be specified.', example='test', position='Query'),
}

model DescribeLiveStreamPushMetricDetailDataResponseBody = {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range that was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-09-10T21:00:00Z'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.

When you specify the token in the next query, data continues to be obtained from the end of the previous query.', example='UjsM9x3aVcJi9a0-ArwJUTTC67C***37C0='),
  pageSize?: int32(name='PageSize', description='The number of rows returned.', example='5000'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5EBF2AC3-4B73-40A5-8B32-83F49D5F035E'),
  startTime?: string(name='StartTime', description='The beginning of the time range that was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2022-09-10T20:00:00Z'),
  streamDetailData?: {
    streamData?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='app'),
      reqBps?: float(name='ReqBps', description='The total bandwidth consumed by the stream per minute. Unit: bit/s.', example='423304182'),
      reqTraffic?: long(name='ReqTraffic', description='The total amount of traffic consumed by the stream per minute. Unit: bytes.', example='423304182.66'),
      streamName?: string(name='StreamName', description='The name of the stream.', example='test.flv'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2022-09-10T20:00:00Z'),
    }
  ](name='StreamData')
  }(name='StreamDetailData', description='The data array returned.'),
}

model DescribeLiveStreamPushMetricDetailDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamPushMetricDetailDataResponseBody(name='body'),
}

/**
  * @description *   You can query data of a single domain name in each request. If you specify multiple domain names, an error is returned.
  * *   The maximum time range to query is 24 hours.
  * *   The minimum data granularity to query is 1 minute.
  * *   You can query data in the last 31 days.
  * *   This operation is used to monitor data. The data returned by this operation cannot be used as a reference to calculate resource usage for billing.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamPushMetricDetailData  DescribeLiveStreamPushMetricDetailDataRequest
  * @return DescribeLiveStreamPushMetricDetailDataResponse
 */
async function describeLiveStreamPushMetricDetailData(request: DescribeLiveStreamPushMetricDetailDataRequest): DescribeLiveStreamPushMetricDetailDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamPushMetricDetailData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamRecordContentRequest {
  appName: string(name='AppName', description='The main streaming domain.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The operation that you want to perform. Set the value to **DescribeLiveStreamRecordContent**.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The beginning of the time range to query. You can only query the recordings in the last 6 months. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', description='The name of the live stream.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamRecordContentResponseBody = {
  recordContentInfoList?: {
    recordContentInfo?: [ 
    {
      duration?: float(name='Duration', description='The beginning of the time range for which the recordings were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='10'),
      endTime?: string(name='EndTime', description='The recordings.', example='2015-12-01T07:46:00Z'),
      ossBucket?: string(name='OssBucket', description='The recording length. Unit: seconds.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The naming rule of recordings in OSS.', example='cn-oss-****.aliyuncs.com'),
      ossObjectPrefix?: string(name='OssObjectPrefix', description='The name of the Object Storage Service (OSS) bucket.', example='record/{Date}/{UnixTimestamp}_{Sequence}'),
      startTime?: string(name='StartTime', description='The end of the time range for which the recordings were queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T07:36:00Z'),
    }
  ](name='RecordContentInfo')
  }(name='RecordContentInfoList', description='The ID of the request.'),
  requestId?: string(name='RequestId', description='The end of the time range to query. The time range that is specified by the StartTime and EndTime parameters cannot exceed 4 days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='62136AE6-7793-45ED-B14A-60D19A9486D3'),
}

model DescribeLiveStreamRecordContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamRecordContentResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the recordings of the live stream.
  * ## QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of DescribeLiveStreamRecordContent  DescribeLiveStreamRecordContentRequest
  * @return DescribeLiveStreamRecordContentResponse
 */
async function describeLiveStreamRecordContent(request: DescribeLiveStreamRecordContentRequest): DescribeLiveStreamRecordContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamRecordContent', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamRecordIndexFileRequest {
  appName: string(name='AppName', description='System-defined parameter. Value: **DescribeLiveStreamRecordIndexFile**.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='## [](#)Usage notes

ApsaraVideo Live stores the configuration information of an M3U8 index file for six months. You can query only index files created in the previous six months. M3U8 index files are stored in Object Storage Service (OSS) buckets. The retention period is determined by the storage configuration of the OSS buckets.

## [](#qps-)QPS limit

You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  recordId: string(name='RecordId', description='The ID of the index file.

>  You can call the [DescribeLiveStreamRecordIndexFiles](https://help.aliyun.com/document_detail/2847890.html) operation to query the ID.

This parameter is required.', example='c4d7f0a4-b506-43f9-8de3-07732c3f****', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName: string(name='StreamName', description='The main domain of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamRecordIndexFileResponseBody = {
  recordIndexInfo?: {
    appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
    createTime?: string(name='CreateTime', description='The time when the index file was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-27T09:40:56Z'),
    domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    duration?: float(name='Duration', description='The recording length. Unit: seconds.', example='588.849'),
    endTime?: string(name='EndTime', description='The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2016-05-25T05:47:11Z'),
    format?: string(name='Format', description='The video format.', example='mp4'),
    height?: int32(name='Height', description='The video height.', example='480'),
    ossBucket?: string(name='OssBucket', description='The name of the Object Storage Service (OSS) bucket.', example='liveBucket****'),
    ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
    ossObject?: string(name='OssObject', description='The name of the storage file in OSS.', example='liveObject****'),
    recordId?: string(name='RecordId', description='The ID of the index file.', example='c4d7f0a4-b506-43f9-8de3-07732c3f****'),
    recordUrl?: string(name='RecordUrl', description='The URL of the index file.'),
    startTime?: string(name='StartTime', description='The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T05:36:00Z'),
    streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    width?: int32(name='Width', description='The video width.', example='640'),
  }(name='RecordIndexInfo', description='The information about the index file.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5EBF2AC3-4B73-40A5-8B32-83F49D5F035E'),
}

model DescribeLiveStreamRecordIndexFileResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamRecordIndexFileResponseBody(name='body'),
}

/**
  * @description ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months. OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamRecordIndexFile  DescribeLiveStreamRecordIndexFileRequest
  * @return DescribeLiveStreamRecordIndexFileResponse
 */
async function describeLiveStreamRecordIndexFile(request: DescribeLiveStreamRecordIndexFileRequest): DescribeLiveStreamRecordIndexFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamRecordIndexFile', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamRecordIndexFilesRequest {
  appName: string(name='AppName', description='System-defined parameter. Value: **DescribeLiveStreamRecordIndexFiles**.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='## [](#)Usage notes

*   ApsaraVideo Live stores the information about an M3U8 index file for six months. You can query only the information of index files created in the previous six months.
*   M3U8 index files are stored in Object Storage Service (OSS) buckets. The retention period is determined by the storage configuration of the OSS buckets.

## [](#qps-)QPS limit

You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The name of the live stream.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  order?: string(name='Order', description='The order in which the entries are sorted based on creation time. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **5 to 30**. Default value: **10**.', example='10', minimum=5, maximum=30, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', description='The name of the application to which the live stream belongs.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The main streaming domain.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamRecordIndexFilesResponseBody = {
  order?: string(name='Order', description='The sort order.', example='asc'),
  pageNum?: int32(name='PageNum', description='The page number.', example='10'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='5'),
  recordIndexInfoList?: {
    recordIndexInfo?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      createTime?: string(name='CreateTime', description='The time when the index file was created.', example='2016-05-27T09:40:56Z'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      duration?: float(name='Duration', description='The recording length. Unit: seconds.', example='588.849'),
      endTime?: string(name='EndTime', description='The end time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T07:46:00Z'),
      format?: string(name='Format', description='The video format.', example='HLS'),
      height?: int32(name='Height', description='The video height.', example='480'),
      ossBucket?: string(name='OssBucket', description='The name of the Object Storage Service (OSS) bucket.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
      ossObject?: string(name='OssObject', description='The name of the storage file in OSS.', example='liveObject****'),
      recordId?: string(name='RecordId', description='The ID of the index file.', example='c4d7f0a4-b506-43f9-8de3-07732c3f****'),
      recordUrl?: string(name='RecordUrl', description='The URL of the index file.'),
      startTime?: string(name='StartTime', description='The start time of the index file. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T07:36:00Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      width?: int32(name='Width', description='The video width.', example='640'),
    }
  ](name='RecordIndexInfo')
  }(name='RecordIndexInfoList', description='The index files.'),
  requestId?: string(name='RequestId', description='The request ID.', example='DE24625C-7C0F-4020-8448-9C31A50C1556'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='12'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='20'),
}

model DescribeLiveStreamRecordIndexFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamRecordIndexFilesResponseBody(name='body'),
}

/**
  * @description *   ApsaraVideo Live stores the information about M3U8 index files for six months. You can query the information about only the M3U8 index files that were created in the last six months.
  * *   OSS stores M3U8 index files for a time period that is specified by the storage configuration in OSS.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamRecordIndexFiles  DescribeLiveStreamRecordIndexFilesRequest
  * @return DescribeLiveStreamRecordIndexFilesResponse
 */
async function describeLiveStreamRecordIndexFiles(request: DescribeLiveStreamRecordIndexFilesRequest): DescribeLiveStreamRecordIndexFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamRecordIndexFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamSnapshotInfoRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The time range specified by the EndTime and StartTime parameters cannot exceed **one** day. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  limit?: int32(name='Limit', description='The number of snapshots to return per call. Valid values: **1 to 100**. Default value: **10**.', example='10', minimum=1, maximum=100, position='Query'),
  order?: string(name='Order', description='The sort order. Valid values:

*   **asc** (default): ascending order
*   **desc**: descending order', example='asc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamSnapshotInfoResponseBody = {
  liveStreamSnapshotInfoList?: {
    liveStreamSnapshotInfo?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the snapshot was captured. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T17:36:00Z'),
      createTimestamp?: long(name='CreateTimestamp', description='The timestamp when the snapshot file was created. Unit: milliseconds.', example='1653641526637'),
      isOverlay?: boolean(name='IsOverlay', description='The snapshot mode. Valid values:

*   **true**: overwrite mode, which means that a new snapshot overwrites the previous snapshot.
*   **false**: sequence mode, which means that a new snapshot does not overwrite the previous snapshot.', example='false'),
      ossBucket?: string(name='OssBucket', description='The name of the OSS bucket.', example='liveBucket****'),
      ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com'),
      ossObject?: string(name='OssObject', description='The name of the snapshot stored in Object Storage Service (OSS).', example='{liveApp****}/{liveStream****}.jpg'),
    }
  ](name='LiveStreamSnapshotInfo')
  }(name='LiveStreamSnapshotInfoList', description='The snapshots.'),
  nextStartTime?: string(name='NextStartTime', description='The time when the next call occurred. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.

>  If the number of snapshots that were captured within the specified time period exceeds the value of the Limit parameter, this parameter is returned. It indicates the time when the DescribeLiveStreamSnapshotInfo operation was called again. If this parameter is not returned, the number of snapshots that are captured within the specified time period does not exceed the specified limit.', example='2015-12-01T17:36:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='62136AE6-7793-45ED-B14A-60D19A9486D3'),
}

model DescribeLiveStreamSnapshotInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamSnapshotInfoResponseBody(name='body'),
}

/**
  * @description You can query only snapshots that were captured in the last year.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamSnapshotInfo  DescribeLiveStreamSnapshotInfoRequest
  * @return DescribeLiveStreamSnapshotInfoResponse
 */
async function describeLiveStreamSnapshotInfo(request: DescribeLiveStreamSnapshotInfoRequest): DescribeLiveStreamSnapshotInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamSnapshotInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamStateRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain or ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeLiveStreamStateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CE6CD79D-0A98-1F22-A15F-FADA74DF2729'),
  streamState?: string(name='StreamState', description='The status of the stream. Valid values:

*   online: The stream is being ingested.
*   offline: The stream is offline. This may be caused by failed or completed stream ingest. For the specific reason, check the stream ingest callback. This operation does not provide detailed information.', example='online'),
  type?: string(name='Type', description='The mode of the stream. Valid values:

*   push: stream ingest
*   pull: triggered stream pulling', example='push'),
}

model DescribeLiveStreamStateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamStateResponseBody(name='body'),
}

/**
  * @description Obtain the streaming domain, and then call this operation to query the status of a stream in real time. If the stream is in the offline status, you can check the stream ingest callback to learn about the reason that causes the offline status. This operation does not provide detailed information.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamState  DescribeLiveStreamStateRequest
  * @return DescribeLiveStreamStateResponse
 */
async function describeLiveStreamState(request: DescribeLiveStreamStateRequest): DescribeLiveStreamStateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamState', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamTranscodeInfoRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='myapp', position='Query'),
  domainTranscodeName: string(name='DomainTranscodeName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamTranscodeInfoResponseBody = {
  domainTranscodeList?: {
    domainTranscodeInfo?: [ 
    {
      customTranscodeParameters?: {
        audioBitrate?: int32(name='AudioBitrate', description='The bitrate of the output audio. Unit: Kbit/s. Valid values: **1 to 1000**.', example='64'),
        audioChannelNum?: int32(name='AudioChannelNum', description='The number of sound channels. Valid values:

*   **1**: mono
*   **2**: binaural', example='2'),
        audioCodec?: string(name='AudioCodec', description='The audio encoding format.', example='ACC'),
        audioProfile?: string(name='AudioProfile', description='The audio encoding profile. Valid values:

*   **aac_low**
*   **aac_he**
*   **aac_he_v2**
*   **aac_ld**', example='aac_low'),
        audioRate?: int32(name='AudioRate', description='The audio sampling rate. Valid values: **22050 to 96000**.

>  If the value of AudioProfile is **aac_ld**, the audio sampling rate cannot exceed 44100.', example='44100'),
        bframes?: string(name='Bframes', description='Indicates whether B-frame removal is enabled. Fixed value: **0**.', example='0'),
        bitrateWithSource?: map[string]any(name='BitrateWithSource', description='The source-based bitrate settings.', example='{\\"UpLimit\\":2500,\\"LowerLimit\\":800,\\"Factor\\":1}'),
        deInterlaced?: boolean(name='DeInterlaced'),
        extWithSource?: map[string]any(name='ExtWithSource', description='Other source-based settings.', example='{\\"KeyFrameOpen\\":\\"yes\\",\\"Copyts\\":\\"yes\\",\\"SeiMode\\":1}'),
        FPS?: int32(name='FPS', description='The frame rate of the output video. Unit: frames per second (FPS).', example='15'),
        fpsWithSource?: map[string]any(name='FpsWithSource', description='The source-based frame rate settings.', example='{\\"UpLimit\\":60,\\"LowerLimit\\":1}'),
        gop?: string(name='Gop', description='The group of pictures (GOP) size of the output video. Unit: frames. Valid values: **1 to 3000**.', example='10'),
        height?: int32(name='Height', description='The height of the output video.', example='1200'),
        resWithSource?: map[string]any(name='ResWithSource', description='The source-based resolution settings.', example='{\\"Type\\":\\"short\\",\\"Value\\":\\"1080\\"}'),
        rtsFlag?: string(name='RtsFlag', description='The Real-Time Transcoding (RTS) flag. Fixed value: **true**.

>  This parameter is returned only if RTS is used for transcoding.', example='true'),
        templateType?: string(name='TemplateType', description='The type of the custom transcoding template. Valid values:

*   **h264**: custom H.264 standard transcoding
*   **h264-nbhd**: custom H.264 Narrowband HD™ transcoding
*   **h265**: custom H.265 standard transcoding
*   **h265-nbhd**: custom H.265 Narrowband HD™ transcoding
*   **audio**: audio-only transcoding', example='h264'),
        videoBitrate?: int32(name='VideoBitrate', description='The bitrate of the output video. Unit: Kbit/s.', example='3000'),
        videoProfile?: string(name='VideoProfile', description='The video encoding profile. Valid values:

*   **baseline**: suitable for mobile devices.
*   **main**: suitable for standard-definition devices.
*   **high**: suitable for high-definition devices.', example='high'),
        width?: int32(name='Width', description='The width of the output video.', example='1000'),
      }(name='CustomTranscodeParameters', description='The custom transcoding configuration.'),
      encryptParameters?: {
        encryptType?: string(name='EncryptType', description='The type of encryption. Fixed value: **aliyun**.', example='aliyun'),
        kmsKeyExpireInterval?: string(name='KmsKeyExpireInterval', description='The rotation period of the CMK. Valid values: **60 to 3600**. Unit: seconds.', example='3600'),
        kmsKeyID?: string(name='KmsKeyID', description='The ID of the customer master key (CMK) in Key Management Service (KMS).', example='afce5722-81d2-43c3-9930-7601da11****'),
      }(name='EncryptParameters', description='The encryption settings.'),
      isLazy?: boolean(name='IsLazy', description='Indicates whether forcible transcoding is used. Valid values:

*   **true**: Delayed transcoding is used.
*   **false**: Forcible transcoding is used.', example='true'),
      transcodeApp?: string(name='TranscodeApp', description='The application name.', example='liveApp****'),
      transcodeName?: string(name='TranscodeName', description='The main streaming domain.', example='example.com'),
      transcodeTemplate?: string(name='TranscodeTemplate', description='The transcoding template ID. Valid values:

*   **Standard transcoding**:

    *   **lld**: low definition
    *   **lsd**: standard definition
    *   **lhd**: high definition
    *   **lud**: ultra-high definition

*   **Narrowband HD™ transcoding**:

    *   **ld**: low definition
    *   **sd**: standard definition
    *   **hd**: high definition
    *   **ud**: ultra-high definition', example='lld'),
    }
  ](name='DomainTranscodeInfo')
  }(name='DomainTranscodeList', description='The transcoding configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='62136AE6-7793-45ED-B14A-60D19A9486D3'),
}

model DescribeLiveStreamTranscodeInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamTranscodeInfoResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to query the transcoding configurations.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamTranscodeInfo  DescribeLiveStreamTranscodeInfoRequest
  * @return DescribeLiveStreamTranscodeInfoResponse
 */
async function describeLiveStreamTranscodeInfo(request: DescribeLiveStreamTranscodeInfoRequest): DescribeLiveStreamTranscodeInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamTranscodeInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamTranscodeMetricDataRequest {
  appName?: string(name='AppName', description='The name of the application.', example='app', position='Query'),
  domainName: string(name='DomainName', description='The domain name. You can specify only one domain name in each request.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2023-06-11T03:46:40Z', position='Query'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.

When you specify the token in the next query, data continues to be obtained from the end of the previous query.', example='UjsM9x3aVcJi9a0-ArwJUTTC67C***37C0=', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2023-06-11T02:46:40Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the stream.', example='stream', position='Query'),
}

model DescribeLiveStreamTranscodeMetricDataResponseBody = {
  domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
  endTime?: string(name='EndTime', description='The end of the time range during which data was queried. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2023-06-11T02:46:40Z'),
  nextPageToken?: string(name='NextPageToken', description='A pagination token. When you call this operation, up to 5,000 rows of data can be returned per query. If the number of rows exceeds 5,000, the response includes a pagination token that is used in the next request to retrieve a new page of results.

When you specify the token in the next query, data continues to be obtained from the end of the previous query.', example='UjsM9x3aVcJi9a0-ArwJUTTC67C***37C0='),
  pageSize?: int32(name='PageSize', description='The number of rows returned.', example='5000'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  startTime?: string(name='StartTime', description='The beginning of the time range during which data was queried. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-06-11T03:46:40Z'),
  streamDetailData?: {
    streamData?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='app'),
      duration?: long(name='Duration', description='The duration. Unit: seconds.', example='300'),
      fps?: string(name='Fps', description='The frame rate.

Valid values:

*   <!-- -->

    <!-- -->

    normal

    <!-- -->

*   <!-- -->

    <!-- -->

    high

    <!-- -->

*   <!-- -->

    <!-- -->

    def

    <!-- -->', example='high'),
      region?: string(name='Region', description='The region.', example='cn-shanghai'),
      resolution?: string(name='Resolution', description='The resolution. Valid values:

*   2K: 2K resolution
*   4K: 4K resolution
*   LD: low definition
*   SD: standard definition
*   HD: high definition
*   def: audio', example='4K'),
      streamName?: string(name='StreamName', description='The name of the stream.', example='stream'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2023-06-11T02:45:00Z'),
      transcodeType?: string(name='TranscodeType', description='The transcoding type. Valid values:

*   H264STD: standard transcoding based on H.264
*   H264NBHD: Narrowband HD™ transcoding based on H.264
*   H265STD: standard transcoding based on H.265
*   AUDIO: audio transcoding', example='H264STD'),
    }
  ](name='StreamData')
  }(name='StreamDetailData', description='The data array returned.'),
}

model DescribeLiveStreamTranscodeMetricDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamTranscodeMetricDataResponseBody(name='body'),
}

/**
  * @description *   The maximum time range for a query is 24 hours.
  * *   The minimum time granularity for a query is 5 minutes.
  * *   You can query data in the last 31 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamTranscodeMetricData  DescribeLiveStreamTranscodeMetricDataRequest
  * @return DescribeLiveStreamTranscodeMetricDataResponse
 */
async function describeLiveStreamTranscodeMetricData(request: DescribeLiveStreamTranscodeMetricDataRequest): DescribeLiveStreamTranscodeMetricDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamTranscodeMetricData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamTranscodeStreamNumRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  splitType?: string(name='SplitType', description='The grouping method.

*   Domain name (default)
*   Template

Valid values:

*   domain
*   template', example='domain', position='Query'),
}

model DescribeLiveStreamTranscodeStreamNumResponseBody = {
  lazyTranscodedNumber?: long(name='LazyTranscodedNumber', description='The number of streams for which transcoding is triggered by stream pulling.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='150191A4-DD88-5941-B48C-9DF59E0A8B1F'),
  total?: long(name='Total', description='The total number of streams.', example='57'),
  transcodeStreamCountDetails?: [ 
    {
      count?: int32(name='Count', description='The number of streams that use the transcoding template.', example='30'),
      template?: string(name='Template', description='The name of the transcoding template.', example='template_name'),
    }
  ](name='TranscodeStreamCountDetails', description='The details about the transcoding templates.'),
  transcodedNumber?: long(name='TranscodedNumber', description='The number of streams that are transcoded.', example='30'),
  untranscodeNumber?: long(name='UntranscodeNumber', description='The number of streams that are not transcoded.', example='27'),
}

model DescribeLiveStreamTranscodeStreamNumResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamTranscodeStreamNumResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamTranscodeStreamNum  DescribeLiveStreamTranscodeStreamNumRequest
  * @return DescribeLiveStreamTranscodeStreamNumResponse
 */
async function describeLiveStreamTranscodeStreamNum(request: DescribeLiveStreamTranscodeStreamNumRequest): DescribeLiveStreamTranscodeStreamNumResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamTranscodeStreamNum', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamWatermarkRulesRequest {
  domain?: string(name='Domain', description='The main streaming domain.', example='live.yourdomain.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. If you do not specify this parameter, the default value 1 is used.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. If you do not specify this parameter, the default value 100 is used.', example='100', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamWatermarkRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64- af62-20e91b9676b3'),
  ruleInfoList?: {
    ruleInfo?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      description?: string(name='Description', description='The description of the custom rule.', example='my rule'),
      domain?: string(name='Domain', description='The streaming domain.', example='example.aliyundoc.com'),
      name?: string(name='Name', description='The name of the custom rule.', example='WatermarkRule****'),
      ruleId?: string(name='RuleId', description='The ID of the watermark rule.

>  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.', example='445409ec-7eaa-461d -8f29-4bec2eb9****'),
      stream?: string(name='Stream', description='The name of the live stream. The following matching rules apply:

*   A stream name can be exactly matched. Example: liveStreamA.
*   Fuzzy match is also supported. The use of an asterisk (`*`) allows all approximate matches to be found.
*   You can place the asterisk before or after an approximate string.

> 

*   Fuzzy match: Only one asterisk (`*`) before or after an approximate string is allowed. The approximate string must be enclosed in `()`. Separate multiple strings with vertical bars (`|`).

*   For example, `*(t1|t2)` matches all streams whose name has the `t1` or `t2` suffix, and `(abc|123)*` matches all streams whose name has the `abc` or `123` prefix.', example='liveStreamA'),
      templateId?: string(name='TemplateId', description='The ID of the watermark template.

>  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/2848096.html) operation.', example='445409ec-7eaa-461d-8f29-4bec2eb9 ****'),
    }
  ](name='RuleInfo')
  }(name='RuleInfoList', description='The watermark rules.'),
  total?: int32(name='Total', description='The total number of entries that meet the specified conditions.', example='100'),
}

model DescribeLiveStreamWatermarkRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamWatermarkRulesResponseBody(name='body'),
}

/**
  * @description When you call this operation, you can specify the PageNumber and PageSize parameters to view watermark rules on separate pages. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamWatermarkRules  DescribeLiveStreamWatermarkRulesRequest
  * @return DescribeLiveStreamWatermarkRulesResponse
 */
async function describeLiveStreamWatermarkRules(request: DescribeLiveStreamWatermarkRulesRequest): DescribeLiveStreamWatermarkRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamWatermarkRules', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamWatermarksRequest {
  domain?: string(name='Domain', description='The name of the main streaming domain.', example='live.yourdomain.com', position='Query'),
  keyWord?: string(name='KeyWord', description='The keyword used in the query. You can specify the template ID or name. Fuzzy search is supported for the name.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of templates per page. Default value: 100.', example='100', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamWatermarksResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64- af62-20e91b9676b3'),
  total?: int32(name='Total', description='The total number of watermark templates that meet the specified conditions.', example='100'),
  watermarkList?: {
    watermark?: [ 
    {
      description?: string(name='Description', description='The description of the watermark.', example='my watermark'),
      height?: int32(name='Height', description='The height of the watermark. Unit: pixels.', example='200'),
      name?: string(name='Name', description='The name of the watermark.', example='livewatermark****'),
      offsetCorner?: string(name='OffsetCorner', description='The position of the watermark.

*   TopLeft: the upper-left corner.
*   TopRight: the upper-right corner.
*   BottomLeft: the lower-left corner.
*   BottomRight: the lower-right corner.', example='TopRight'),
      pictureUrl?: string(name='PictureUrl', description='The URL of the watermark image.', example='http://example.com'),
      refHeight?: int32(name='RefHeight', description='The height of the background video. Unit: pixels.', example='1080'),
      refWidth?: int32(name='RefWidth', description='The width of the background video. Unit: pixels.', example='1920'),
      ruleCount?: int32(name='RuleCount', description='The number of watermark rules configured for the domain name.', example='12'),
      templateId?: string(name='TemplateId', description='The ID of the watermark template.', example='445409ec-7eaa-4 61d-8f29-4bec2eb9 ****'),
      transparency?: int32(name='Transparency', description='The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.', example='255'),
      type?: int32(name='Type', description='The watermark type.

*   0: image. Only image watermarks are supported.
*   1: text.', example='0'),
      xOffset?: float(name='XOffset', description='The offset of the watermark along the x-axis. Unit: pixels.

>  The value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.', example='50.0'),
      yOffset?: float(name='YOffset', description='The offset of the watermark along the y-axis. Unit: pixels.

>  The value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.', example='100.0'),
    }
  ](name='Watermark')
  }(name='WatermarkList', description='Details of the watermark templates.'),
}

model DescribeLiveStreamWatermarksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamWatermarksResponseBody(name='body'),
}

/**
  * @description You can call this operation to query watermark templates. You can use the PageNumber parameter to view results on separate pages. Make sure that you configure parameters properly when you call this operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamWatermarks  DescribeLiveStreamWatermarksRequest
  * @return DescribeLiveStreamWatermarksResponse
 */
async function describeLiveStreamWatermarks(request: DescribeLiveStreamWatermarksRequest): DescribeLiveStreamWatermarksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamWatermarks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsBlockListRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: **1**.', example='2', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 3000. Default value: 2000.', example='10', minimum=1, maximum=3000, position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeLiveStreamsBlockListResponseBody = {
  domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
  pageNum?: int32(name='PageNum', description='The page number of the returned page.', example='2'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9D855EC8-CF71-4615-B164-F7DFCB23B41D'),
  streamUrls?: {
    streamUrl?: [ string ](name='StreamUrl')
  }(name='StreamUrls', description='The complete URL of each live stream.'),
  totalNum?: int32(name='TotalNum', description='The total number of live stream URLs that meet the specified conditions.', example='11'),
  totalPage?: int32(name='TotalPage', description='The total number of returned pages.', example='2'),
}

model DescribeLiveStreamsBlockListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsBlockListResponseBody(name='body'),
}

/**
  * @description The stream URLs refer to the URLs for playing in particular.
  * ## QPS limit
  * A single user can perform a maximum of 50 queries per second (QPS). Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
  * @param request  the request parameters of DescribeLiveStreamsBlockList  DescribeLiveStreamsBlockListRequest
  * @return DescribeLiveStreamsBlockListResponse
 */
async function describeLiveStreamsBlockList(request: DescribeLiveStreamsBlockListRequest): DescribeLiveStreamsBlockListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsBlockList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsControlHistoryRequest {
  appName?: string(name='AppName', description='The application name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  The time range specified by the StartTime and EndTime parameters cannot exceed seven days.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
}

model DescribeLiveStreamsControlHistoryResponseBody = {
  controlInfo?: {
    liveStreamControlInfo?: [ 
    {
      action?: string(name='Action', description='The name of the operation performed.', example='DescribeLiveStreamsControlHistory'),
      clientIP?: string(name='ClientIP', description='The IP address that is used by the client for live streaming.', example='10.207.XX.XX'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      timeStamp?: string(name='TimeStamp', description='The time when the operation was performed. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-01T16:36:18Z'),
    }
  ](name='LiveStreamControlInfo')
  }(name='ControlInfo', description='The operation records.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9C31856F-386D-4DB3-BE79-A0AA493D702A'),
}

model DescribeLiveStreamsControlHistoryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsControlHistoryResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the operation history of live streams under a domain name or in an application. The operations include all API operations that were called on live streams.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamsControlHistory  DescribeLiveStreamsControlHistoryRequest
  * @return DescribeLiveStreamsControlHistoryResponse
 */
async function describeLiveStreamsControlHistory(request: DescribeLiveStreamsControlHistoryRequest): DescribeLiveStreamsControlHistoryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsControlHistory', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsNotifyRecordsRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='app', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='push.example1.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2017-12-10T09:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 20. Maximum value: 500. Valid values: integers from 1 to 500.', example='20', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The start time must be in the last seven days.

This parameter is required.', example='2017-12-10T08:00:00Z', position='Query'),
  status?: string(name='Status', description='Specifies whether to return the records of successful or failed callbacks. Valid values:

*   success
*   failed', example='success', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='stream', position='Query'),
}

model DescribeLiveStreamsNotifyRecordsResponseBody = {
  notifyRecordsInfo?: {
    liveStreamNotifyRecordsInfo?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='app'),
      description?: string(name='Description', description='The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.', example='success'),
      domainName?: string(name='DomainName', description='The ingest domain.', example='push.example1.com'),
      notifyContent?: string(name='NotifyContent', description='The callback content.', example='{\\"action\\":\\"publish_done\\",\\"app\\":\\"push.example1.com\\"}'),
      notifyResponse?: string(name='NotifyResponse'),
      notifyResult?: string(name='NotifyResult', description='The callback result. Valid values:

*   success
*   failed', example='success'),
      notifyTime?: string(name='NotifyTime', description='The time when the callback was invoked. The time is displayed in UTC.', example='2022-10-19T19:09:28Z'),
      notifyType?: string(name='NotifyType', description='The event. Valid values:

*   publish: The stream ingest starts.
*   publish_done: The stream ingest is interrupted.', example='publish_done'),
      notifyUrl?: string(name='NotifyUrl', description='The callback URL.', example='http://xx.xx.xx.xx/callbacks'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='stream'),
    }
  ](name='LiveStreamNotifyRecordsInfo')
  }(name='NotifyRecordsInfo', description='The stream ingest callback records.'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20'),
  requestId?: string(name='RequestId', description='The request ID.', example='F675E4B4-125D-1533-901B-11A724644285'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='20'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='20'),
}

model DescribeLiveStreamsNotifyRecordsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsNotifyRecordsResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamsNotifyRecords  DescribeLiveStreamsNotifyRecordsRequest
  * @return DescribeLiveStreamsNotifyRecordsResponse
 */
async function describeLiveStreamsNotifyRecords(request: DescribeLiveStreamsNotifyRecordsRequest): DescribeLiveStreamsNotifyRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsNotifyRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsNotifyUrlConfigRequest {
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveStreamsNotifyUrlConfigResponseBody = {
  liveStreamsNotifyConfig?: {
    domainName?: string(name='DomainName', description='The ingest domain.', example='demo.aliyundoc.com'),
    exceptionNotifyUrl?: string(name='ExceptionNotifyUrl', description='Exception event callback URL.', example='https://4a7e5f08.r37.cpolar.top/live/Record/call-back/streamException'),
    notifyAuthKey?: string(name='NotifyAuthKey', description='The authentication key.', example='123456'),
    notifyReqAuth?: string(name='NotifyReqAuth', description='Indicates whether callback authentication is enabled. Valid values:

*   yes
*   no', example='yes'),
    notifyUrl?: string(name='NotifyUrl', description='The callback URL.', example='http://guide.aliyundoc.com/notify'),
  }(name='LiveStreamsNotifyConfig', description='The callback configuration.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
}

model DescribeLiveStreamsNotifyUrlConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsNotifyUrlConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveStreamsNotifyUrlConfig  DescribeLiveStreamsNotifyUrlConfigRequest
  * @return DescribeLiveStreamsNotifyUrlConfigResponse
 */
async function describeLiveStreamsNotifyUrlConfig(request: DescribeLiveStreamsNotifyUrlConfigRequest): DescribeLiveStreamsNotifyUrlConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsNotifyUrlConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsOnlineListRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  onlyStream?: string(name='OnlyStream', description='Specifies whether to return only specific parameters. Valid values:

*   **yes**: returns only the DomainName, AppName, StreamName, and PublishTime parameters.
*   **no**: returns all parameters. This is the default value.', example='no', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 3000. Default value: 2000.', example='1500', position='Query'),
  queryType?: string(name='QueryType', description='The mode in which stream names are matched. Valid values:

*   **fuzzy** (default): fuzzy match
*   **strict**: exact match', example='fuzzy', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can specify only one live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveStream****', position='Query'),
  streamType?: string(name='StreamType', description='The type of the streams to query. Valid values:

*   **all** (default): all streams
*   **raw**: source streams
*   **trans**: transcoded streams', example='all', position='Query'),
}

model DescribeLiveStreamsOnlineListResponseBody = {
  onlineInfo?: {
    liveStreamOnlineInfo?: [ 
    {
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      audioCodecId?: int32(name='AudioCodecId', description='The ID of the audio codec.', example='10'),
      audioDataRate?: int32(name='AudioDataRate', description='The audio bitrate of the live stream. Unit: Kbit/s.

>  This parameter can be returned after you submit a ticket for whitelist configuration. For more information about how to submit a ticket, see Contact us.', example='600'),
      clientIp?: string(name='ClientIp', description='The IP address of the client for stream ingest.', example='106.11.XX.XX'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      frameRate?: int32(name='FrameRate', description='The frame rate. Unit: FPS.', example='15'),
      height?: int32(name='Height', description='The height of the video resolution. Unit: pixels.', example='720'),
      publishDomain?: string(name='PublishDomain', description='The ingest domain. If live center ingest was used, the streaming domain is returned.', example='demo.aliyundoc.com'),
      publishTime?: string(name='PublishTime', description='The start time of stream ingest. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2021-08-09T02:37:59Z'),
      publishType?: string(name='PublishType', description='The ingest type. Valid values:

*   **edge**: edge ingest.
*   **center**: live center ingest.', example='edge'),
      publishUrl?: string(name='PublishUrl', description='The complete URL that was used to ingest the stream.', example='rtmp://demo.aliyundoc.com/live/test****'),
      serverIp?: string(name='ServerIp', description='The IP address of the ingest node.', example='120.221.XX.XX'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      transcoded?: string(name='Transcoded', description='Indicates whether the stream was transcoded. Valid values:

*   **yes**
*   **no**', example='no'),
      videoCodecId?: int32(name='VideoCodecId', description='The ID of the video codec.', example='7'),
      videoDataRate?: int32(name='VideoDataRate', description='The video bitrate of the live stream. Unit: Kbit/s.

>  This parameter can be returned after you submit a ticket for whitelist configuration. For more information about how to submit a ticket, see Contact us.', example='600'),
      width?: int32(name='Width', description='The width of the video resolution. Unit: pixels.', example='1280'),
    }
  ](name='LiveStreamOnlineInfo')
  }(name='OnlineInfo', description='The information about the live streams that are being ingested.'),
  pageNum?: int32(name='PageNum', description='The page number of the returned page.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64- af62-20e91b9676b3'),
  totalNum?: int32(name='TotalNum', description='The total number of streams that meet the specified conditions.', example='11'),
  totalPage?: int32(name='TotalPage', description='The total number of pages returned.', example='2'),
}

model DescribeLiveStreamsOnlineListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsOnlineListResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the following types of streams.
  * *   all: all streams.
  * *   raw: source streams.
  * *   trans: transcoded streams.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamsOnlineList  DescribeLiveStreamsOnlineListRequest
  * @return DescribeLiveStreamsOnlineListResponse
 */
async function describeLiveStreamsOnlineList(request: DescribeLiveStreamsOnlineListRequest): DescribeLiveStreamsOnlineListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsOnlineList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsPublishListRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain or main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The time range specified by the StartTime and EndTime parameters cannot exceed 30 days.

Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  orderBy?: string(name='OrderBy', description='The sorting method. Valid values:

*   **stream_name_desc**: sorts the entries in descending order by stream name.
*   **stream_name_asc**: sorts the entries in ascending order by stream name.
*   **publish_time_desc**: sorts the entries in descending order by stream ingest time.
*   **publish_time_asc** (default): sorts the entries in ascending order by stream ingest time.', example='publish_time_desc', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: **1 to 3000**. Default value: **2000**.', example='1500', position='Query'),
  queryType?: string(name='QueryType', description='The mode in which stream names are matched. Valid values:

*   **fuzzy** (default): fuzzy match
*   **strict**: exact match', example='fuzzy', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query.

Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****', position='Query'),
  streamType?: string(name='StreamType', description='The type of the streams to query. Valid values:

*   An empty value****: source streams
*   **all**: all streams
*   **trans**: transcoded streams', example='all', position='Query'),
}

model DescribeLiveStreamsPublishListResponseBody = {
  pageNum?: int32(name='PageNum', description='The page number.', example='2'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  publishInfo?: {
    liveStreamPublishInfo?: [ 
    {
      aliInnerErrorFlags?: string(name='AliInnerErrorFlags', description='Internal error', example='3000001'),
      appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      clientAddr?: string(name='ClientAddr', description='The IP address of the client that ingested the live stream.', example='10.175.XX.XX'),
      domainName?: string(name='DomainName', description='The ingest domain or main streaming domain.', example='example.com'),
      edgeNodeAddr?: string(name='EdgeNodeAddr', description='The IP address of the CDN point of presence (POP) to which the stream was ingested.', example='10.175.XX.XX'),
      publishDomain?: string(name='PublishDomain', description='The ingest domain.', example='demo.aliyundoc.com'),
      publishTime?: string(name='PublishTime', description='The time when the stream ingest was started. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-02T03:05:53Z'),
      publishType?: string(name='PublishType', description='The type of the stream ingest. Valid values:

*   **edge**: edge ingest
*   **center**: live center ingest', example='edge'),
      publishUrl?: string(name='PublishUrl', description='The complete ingest URL.'),
      stopTime?: string(name='StopTime', description='The time when the stream ingest was stopped. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2015-12-02T03:11:19Z'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      streamUrl?: string(name='StreamUrl', description='The streaming URL.'),
      transcodeId?: string(name='TranscodeId', description='The ID of the transcoding template.

>  This parameter is not returned if the value of the Transcoded parameter is no.', example='ld'),
      transcoded?: string(name='Transcoded', description='Indicates whether the stream was a transcoded stream.', example='yes'),
    }
  ](name='LiveStreamPublishInfo')
  }(name='PublishInfo', description='The information about the stream ingest records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
  totalNum?: int32(name='TotalNum', description='The total number of entries that meet the specified conditions.', example='11'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='2'),
}

model DescribeLiveStreamsPublishListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsPublishListResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * This operation allows you to query streams in the last 30 days. The information of active streams during the queried period is returned. This operation supports the following sorting methods.
  * *   stream_name_desc: sorts the entries in descending order by stream name.
  * *   stream_name_asc: sorts the entries in ascending order by stream name.
  * *   publish_time_desc: sorts the entries in descending order by stream ingest time.
  * *   publish_time_asc: sorts the entries in ascending order by stream ingest time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 3 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveStreamsPublishList  DescribeLiveStreamsPublishListRequest
  * @return DescribeLiveStreamsPublishListResponse
 */
async function describeLiveStreamsPublishList(request: DescribeLiveStreamsPublishListRequest): DescribeLiveStreamsPublishListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsPublishList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveStreamsTotalCountRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain. This parameter is required if you want to query data based on domain names. You can specify up to 10 domain names. Separate multiple domain names with commas (,).

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The maximum time range for a query is 15 days. The end time must be earlier than the current time. Data of the current day can be queried on the next day.

This parameter is required.', example='2023-07-25T16:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  You can query data in the last 18 months.

This parameter is required.', example='2023-07-24T16:00:00Z', position='Query'),
  typ?: string(name='Typ', description='The type of data that you want to query. If you leave this parameter empty, data is returned by domain name. If you want to query data by UID, specify the UID for this parameter.', example='aliuid', position='Query'),
}

model DescribeLiveStreamsTotalCountResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='String	FCFFE4A4-F34F-4EEF-B401-36A01689AFBC'),
  streamCountList?: {
    streamCountInfos?: [ 
    {
      count?: int32(name='Count', description='The total number of live streams.', example='934'),
      timestamp?: string(name='Timestamp', description='The timestamp.', example='2023-07-24T16:00:00Z'),
    }
  ](name='StreamCountInfos')
  }(name='StreamCountList', description='The statistics about the live streams.'),
}

model DescribeLiveStreamsTotalCountResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveStreamsTotalCountResponseBody(name='body'),
}

/**
  * @description *   The maximum time range for a query is 15 days.
  * *   You can query data in the last 18 months.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveStreamsTotalCount  DescribeLiveStreamsTotalCountRequest
  * @return DescribeLiveStreamsTotalCountResponse
 */
async function describeLiveStreamsTotalCount(request: DescribeLiveStreamsTotalCountRequest): DescribeLiveStreamsTotalCountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveStreamsTotalCount', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveTopDomainsByFlowRequest {
  endTime?: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2018-03-20T16:00:00Z', position='Query'),
  limit?: long(name='Limit', description='The maximum number of domain names that you want to retrieve. Valid values: 1 to 100. Default value: 20.', example='20', minimum=1, maximum=100, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The minimum data granularity is 5 minutes. If you do not specify this parameter, the data of the current month is returned.', example='2018-03-17T16:00:00Z', position='Query'),
}

model DescribeLiveTopDomainsByFlowResponseBody = {
  domainCount?: long(name='DomainCount', description='The total number of domain names in your account.', example='1'),
  domainOnlineCount?: long(name='DomainOnlineCount', description='The total number of domain names that are in the Enabled state in your account.', example='1'),
  endTime?: string(name='EndTime', description='The end of the time range for which data was queried.', example='2018-03-20T16:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='33834C3E-388E-5FFE-A8AE-63575035C064'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which data was queried.', example='2018-03-17T16:00:00Z'),
  topDomains?: {
    topDomain?: [ 
    {
      domainName?: string(name='DomainName', description='The domain name.', example='example.com'),
      maxBps?: long(name='MaxBps', description='The peak bandwidth of the domain name.', example='22139626'),
      maxBpsTime?: string(name='MaxBpsTime', description='The time when the bandwidth reached the peak value.', example='1457111400'),
      rank?: long(name='Rank', description='The ranking of the domain name.', example='1'),
      totalAccess?: long(name='TotalAccess', description='The number of visits to the domain name.', example='107784230'),
      totalTraffic?: string(name='TotalTraffic', description='The total traffic.', example='2043859876683.9001'),
      trafficPercent?: string(name='TrafficPercent', description='The traffic share of the domain name relative to the total traffic.', example='30.64191989360235'),
    }
  ](name='TopDomain')
  }(name='TopDomains', description='The top domain names ranked by traffic.'),
}

model DescribeLiveTopDomainsByFlowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveTopDomainsByFlowResponseBody(name='body'),
}

/**
  * @description *   If you do not specify the StartTime or EndTime parameter, data of the current month is queried by default. To query data within a specific time range, you must specify both the StartTime and EndTime parameters.
  * *   You can query data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeLiveTopDomainsByFlow  DescribeLiveTopDomainsByFlowRequest
  * @return DescribeLiveTopDomainsByFlowResponse
 */
async function describeLiveTopDomainsByFlow(request: DescribeLiveTopDomainsByFlowRequest): DescribeLiveTopDomainsByFlowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveTopDomainsByFlow', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveTrafficDomainLogRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeLiveTrafficDomainLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime'),
          logName?: string(name='LogName'),
          logPath?: string(name='LogPath'),
          logSize?: long(name='LogSize'),
          startTime?: string(name='StartTime'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex'),
        pageSize?: long(name='PageSize'),
        total?: long(name='Total'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails'),
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveTrafficDomainLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveTrafficDomainLogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveTrafficDomainLog  DescribeLiveTrafficDomainLogRequest
  * @return DescribeLiveTrafficDomainLogResponse
 */
async function describeLiveTrafficDomainLog(request: DescribeLiveTrafficDomainLogRequest): DescribeLiveTrafficDomainLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveTrafficDomainLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUpVideoAudioInfoRequest {
  endTime?: string(name='EndTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-10T15:10:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The name of the stream that you want to query. Specify this parameter in the following format: `rtmp://Ingest domain/Application name/Stream name`.', example='2015-12-10T15:00:00Z', position='Query'),
  stream: string(name='Stream', description='The operation that you want to perform. Set the value to **DescribeLiveUpVideoAudioInfo**.

This parameter is required.', example='rtmp://example.com/AppName/StreamName', position='Query'),
}

model DescribeLiveUpVideoAudioInfoResponseBody = {
  requestId?: string(name='RequestId', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  upItems?: {
    publishItem?: [ 
    {
      aacHeaders?: {
        aacHeaders?: [ 
        {
          time?: long(name='Time', description='The number of AAC headers in the audio.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='20'),
        }
      ](name='AacHeaders')
      }(name='AacHeaders', description='The details about the audio and video data of the stream ingest occurrences.'),
      appName?: string(name='AppName', description='The metric value at a granularity of seconds at the query time.', example='AppName'),
      audioBitRate?: {
        audioBitRate?: [ 
        {
          time?: long(name='Time', description='The bitrate of the audio. Unit: bit/s.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='24552'),
        }
      ](name='AudioBitRate')
      }(name='AudioBitRate', description='The name of the application to which the ingested stream belongs.'),
      audioFrames?: {
        audioFrames?: [ 
        {
          time?: long(name='Time', description='The frame rate of the audio. Unit: frames.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='23'),
        }
      ](name='AudioFrames')
      }(name='AudioFrames', description='The metric value at a granularity of seconds at the query time.'),
      audioInterval?: {
        audioInterval?: [ 
        {
          time?: long(name='Time', description='The maximum audio frame interval. Unit: milliseconds.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='254'),
        }
      ](name='AudioInterval')
      }(name='AudioInterval', description='The metric value at a granularity of seconds at the query time.'),
      audioStamps?: {
        audioStamps?: [ 
        {
          time?: long(name='Time', description='The audio timestamp. Unit: milliseconds.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='725053422'),
        }
      ](name='AudioStamps')
      }(name='AudioStamps', description='The metric value at a granularity of seconds at the query time.'),
      avcHeaders?: {
        avcHeaders?: [ 
        {
          time?: long(name='Time', description='The number of AVC headers in the audio.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='11'),
        }
      ](name='AvcHeaders')
      }(name='AvcHeaders', description='The metric value at a granularity of seconds at the query time.'),
      codecInfo?: string(name='CodecInfo', description='The metric value at a granularity of seconds at the query time.', example='H264/AAC'),
      domainName?: string(name='DomainName', description='The audio and video encoding information.', example='example.com'),
      errorFlags?: {
        errorFlags?: [ 
        {
          time?: long(name='Time', description='The number of times the error code that indicates interrupted stream ingest was returned.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='0'),
        }
      ](name='ErrorFlags')
      }(name='ErrorFlags', description='The ingest domain.'),
      publishInterval?: string(name='PublishInterval', description='The metric value at a granularity of seconds at the query time.', example='-'),
      publishIp?: string(name='PublishIp', description='The stream ingest duration. Unit: seconds. A hyphen (-) indicates that the stream is being ingested and the duration cannot be returned.', example='cn397'),
      publishStatus?: string(name='PublishStatus', description='The IP address of the stream ingest client.', example='1'),
      publishTime?: string(name='PublishTime', description='The stream ingest status. A value of 1 indicates that the stream is being ingested. A value of 0 indicates that the stream was ingested.', example='2015-12-10T15:00:00Z'),
      stopTime?: string(name='StopTime', description='The start time of stream ingest. The time is displayed in UTC.', example='2015-12-10T15:10:00Z'),
      streamName?: string(name='StreamName', description='The end time of stream ingest. The time is displayed in UTC.', example='StreamName'),
      uniqueId?: string(name='UniqueId', description='The name of the stream.', example='2.-395_37261_9848098_1538080899396'),
      videoAndAudioStamp?: {
        vAStamp?: [ 
        {
          time?: long(name='Time', description='The difference between the audio and video timestamps. Unit: milliseconds.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='359'),
        }
      ](name='V_AStamp')
      }(name='VideoAndAudioStamp', description='The unique ID of each stream ingest occurrence.'),
      videoBitRate?: {
        videoBitRate?: [ 
        {
          time?: long(name='Time', description='The bitrate of the video. Unit: bit/s.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='3970160'),
        }
      ](name='VideoBitRate')
      }(name='VideoBitRate', description='The metric value at a granularity of seconds at the query time.'),
      videoFrames?: {
        videoFrames?: [ 
        {
          time?: long(name='Time', description='The frame rate of the video. Unit: frames.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='29'),
        }
      ](name='VideoFrames')
      }(name='VideoFrames', description='The metric value at a granularity of seconds at the query time.'),
      videoInterval?: {
        videoInterval?: [ 
        {
          time?: long(name='Time', description='The maximum video frame interval. Unit: milliseconds.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='278'),
        }
      ](name='VideoInterval')
      }(name='VideoInterval', description='The metric value at a granularity of seconds at the query time.'),
      videoStamps?: {
        videoStamps?: [ 
        {
          time?: long(name='Time', description='The video timestamp. Unit: milliseconds.', example='1538134750408'),
          value?: int32(name='Value', description='The query time. The value is a UNIX timestamp in milliseconds.', example='725053781'),
        }
      ](name='VideoStamps')
      }(name='VideoStamps', description='The metric value at a granularity of seconds at the query time.'),
    }
  ](name='PublishItem')
  }(name='UpItems', description='The request ID.'),
}

model DescribeLiveUpVideoAudioInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUpVideoAudioInfoResponseBody(name='body'),
}

/**
  * @description ### Usage notes
  * - The maximum time range for a query is 24 hours. 
  * - The minimum time range for a query is 1 hour. 
  * - You can query data in the last 31 days. 
  * ### QPS limit
  * You can call this operation up to 10 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveUpVideoAudioInfo  DescribeLiveUpVideoAudioInfoRequest
  * @return DescribeLiveUpVideoAudioInfoResponse
 */
async function describeLiveUpVideoAudioInfo(request: DescribeLiveUpVideoAudioInfoRequest): DescribeLiveUpVideoAudioInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUpVideoAudioInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUserBillPredictionRequest {
  endTime?: string(name='EndTime', description='The end time. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2015-12-01T05:45:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd**THH:mm:ssZ* format. The time must be in UTC.', example='2015-12-01T05:40:00Z', position='Query'),
}

model DescribeLiveUserBillPredictionResponseBody = {
  billPredictionData?: {
    billPredictionDataItem?: [ 
    {
      area?: string(name='Area', description='The billable region. Valid values:

*   CN: Chinese mainland
*   OverSeas: countries and regions outside the Chinese mainland
*   AP1: Asia Pacific 1, including Hong Kong (China), Macao (China), Taiwan (China), Japan, and other Southeast Asia countries and regions except Vietnam and Indonesia
*   AP2: Asia Pacific 2, including Indonesia, South Korea, and Vietnam
*   AP3: Asia Pacific 3, including Australia and New Zealand
*   NA: North America, including US and Canada
*   SA: South America, specifically meaning Brazil
*   EU: Europe, including Ukraine, UK, France, Netherlands, Spain, Italy, Sweden, and Germany
*   MEAA: Middle East and Africa, including South Africa, Oman, UAE, and Kuwait

By default, data of all regions is aggregated and returned.', example='CN'),
      timeStp?: string(name='TimeStp', description='The time at which the estimated value occurs. This parameter is returned only if the metering method is pay by 95th percentile bandwidth, pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00, or pay by 4th peak bandwidth per month.', example='2018-10-15T16:00:00Z'),
      value?: float(name='Value', description='The estimated value.', example='10000'),
    }
  ](name='BillPredictionDataItem')
  }(name='BillPredictionData', description='The estimated bill data.'),
  billType?: string(name='BillType', description='The metering method. Valid values:

*   hour_flow: pay by hourly data transfer
*   day_bandwidth: pay by daily bandwidth
*   month_95: pay by monthly 95th percentile bandwidth
*   month_avg_day_bandwidth: pay by average daily peak bandwidth per month
*   month_4th_day_bandwidth: pay by 4th peak bandwidth per month
*   month_avg_day_95: pay by average daily 95th percentile bandwidth per month
*   month_95_night_half: pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00
*   hour_vas: pay by value-added services per hour
*   day_count: pay by daily requests', example='day_bandwidth'),
  endTime?: string(name='EndTime', description='The end time. If you do not specify the request parameter EndTime, the end time is the current time by default. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2018-10-25T10:00:00Z'),
  requestId?: string(name='RequestId', description='The request ID.', example='B95BE680-5A6A-1CAD-8AB1-09DFF5D6****'),
  startTime?: string(name='StartTime', description='The start time. If you do not specify the request parameter StartTime, the start time is 00:00 on the first day of the month by default. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2018-09-30T16:00:00Z'),
}

model DescribeLiveUserBillPredictionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUserBillPredictionResponseBody(name='body'),
}

/**
  * @description You can call this operation to estimate resource usage of the current month based on the metering method that is specified on the first day of the month. You can call this operation to estimate resource usage of only the current month within your Alibaba Cloud account. The time range used for the estimation starts at 00:00 on the first day of the month and ends 2 hours earlier than the current time.
  * *   Pay by monthly 95th percentile bandwidth: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
  * *   Pay by average daily peak bandwidth per month: Estimated value = Sum of daily peak bandwidth values/Number of days. The current day is excluded.
  * *   Pay by 4th peak bandwidth per month: The estimated value is the 4th peak bandwidth value between the start time and end time. If the time range is less than four days, the estimated value is 0.
  * *   Pay by average daily 95th percentile bandwidth per month: Estimated value = Sum of daily 95th percentile bandwidth values/Number of days. The current day is excluded.
  * *   Pay by 95th percentile bandwidth with 50% off from 00:00 to 08:00: The top 5% values between the start time and end time are excluded. The highest value among the remaining values is the estimated value.
  * ## [](#qps-)QPS limit
  * You can call this operation once per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveUserBillPrediction  DescribeLiveUserBillPredictionRequest
  * @return DescribeLiveUserBillPredictionResponse
 */
async function describeLiveUserBillPrediction(request: DescribeLiveUserBillPredictionRequest): DescribeLiveUserBillPredictionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUserBillPrediction', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUserDomainsRequest {
  domainName?: string(name='DomainName', description='The domain name that is used as a keyword to filter domain names. Fuzzy match is supported.

> 

*   If you set LiveDomainType to liveVideo and leave this parameter empty, the streaming domains are queried. - If you set LiveDomainType to liveEdge and leave this parameter empty, the ingest domains are queried.', example='*.aliyundoc.com', position='Query'),
  domainSearchType?: string(name='DomainSearchType', description='The search mode. Valid values:

*   **fuzzy_match** (default): fuzzy match
*   **pre_match**: prefix match
*   **suf_match**: suffix match
*   **full_match**: exact match', example='fuzzy_match', position='Query'),
  domainStatus?: string(name='DomainStatus', description='The status of the domain name. Valid values:

*   **online**
*   **offline**
*   **configuring**', example='online', position='Query'),
  liveDomainType?: string(name='LiveDomainType', description='The type of the domain name. Valid values:

*   **liveVideo**: streaming domain
*   **liveEdge**: ingest domain

>  If you leave this parameter empty, all ingest domains and streaming domains within your Alibaba Cloud account are queried by default.', example='liveVideo', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: **1 to 100000**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: **20**. Maximum value: **50**.', example='20', maximum=500, position='Query'),
  regionName?: string(name='RegionName', description='The ID of the region in which the domain name resides.', example='cn-beijing', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aek2egyoep3jp7a', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='TestKey'),
      value?: string(name='Value', description='The value of the tag.', example='TestValue'),
    }
  ](name='Tag', description='The tags.', position='Query'),
}

model DescribeLiveUserDomainsResponseBody = {
  domains?: {
    pageData?: [ 
    {
      cname?: string(name='Cname', description='The CNAME generated for the domain name.', example='learn.developer.aliyundoc.com'),
      description?: string(name='Description', description='The description.', example='test'),
      domainName?: string(name='DomainName', description='The domain name.', example='demo.aliyundoc.com'),
      gmtCreated?: string(name='GmtCreated', description='The time when the domain name was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-08-29T12:15:36Z'),
      gmtModified?: string(name='GmtModified', description='The time when the domain name was last modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2017-12-29T12:15:36Z'),
      liveDomainStatus?: string(name='LiveDomainStatus', description='The status of the domain name. Valid values:

*   **online**
*   **offline**
*   **configuring**', example='online'),
      liveDomainType?: string(name='LiveDomainType', description='The type of the domain name. Valid values:

*   **liveVideo**: streaming domain
*   **liveEdge**: ingest domain', example='liveVideo'),
      regionName?: string(name='RegionName', description='The ID of the region in which the domain name resides.', example='cn-beijing'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aekzvyjetyjjmla'),
    }
  ](name='PageData')
  }(name='Domains', description='The domain names.'),
  pageNumber?: long(name='PageNumber', description='The page number.', example='1'),
  pageSize?: long(name='PageSize', description='The number of entries per page.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='E4EBD2BF-5EB0-4476-8829-9D94E1B15267'),
  totalCount?: long(name='TotalCount', description='The total number of entries.', example='1'),
}

model DescribeLiveUserDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUserDomainsResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You can call this operation to query all domain names of ApsaraVideo Live within your Alibaba Cloud account. The supported types of domain names are streaming domains and edge ingest domains.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeLiveUserDomains  DescribeLiveUserDomainsRequest
  * @return DescribeLiveUserDomainsResponse
 */
async function describeLiveUserDomains(request: DescribeLiveUserDomainsRequest): DescribeLiveUserDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUserDomains', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUserStreamMetricDataRequest {
  appName?: string(name='AppName', example='app', position='Query'),
  domainName?: string(name='DomainName', example='test.com', position='Query'),
  endTime: string(name='EndTime', description='This parameter is required.', example='2015-12-10T21:00:00Z', position='Query'),
  pageNumber: long(name='PageNumber', description='This parameter is required.', example='1', position='Query'),
  pageSize: long(name='PageSize', description='This parameter is required.', example='10', position='Query'),
  protocol?: string(name='Protocol', example='flv', position='Query'),
  startTime: string(name='StartTime', description='This parameter is required.', example='2015-12-10T20:00:00Z', position='Query'),
  streamName?: string(name='StreamName', example='test.flv', position='Query'),
}

model DescribeLiveUserStreamMetricDataResponseBody = {
  domainName?: string(name='DomainName', example='test.com'),
  endTime?: string(name='EndTime', description='YYYY-MM-DDThh:mm:ssZ', example='2015-12-10T21:00:00Z'),
  pageNumber?: long(name='PageNumber', example='1'),
  pageSize?: long(name='PageSize', example='10'),
  requestId?: string(name='RequestId', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
  startTime?: string(name='StartTime', example='2015-12-10T20:00:00Z'),
  streamDetailData?: [ 
    {
      appName?: string(name='AppName', example='app'),
      bps?: float(name='Bps', example='423304182.66'),
      count?: long(name='Count', example='423304182'),
      flvBps?: float(name='FlvBps', example='454'),
      flvCount?: long(name='FlvCount', example='32'),
      flvTraffic?: double(name='FlvTraffic', example='1254'),
      hlsBps?: float(name='HlsBps', example='4456'),
      hlsCount?: long(name='HlsCount', example='56'),
      hlsTraffic?: double(name='HlsTraffic', example='568'),
      newConns?: long(name='NewConns', example='450'),
      p2pBps?: float(name='P2pBps', example='6845'),
      p2pCount?: long(name='P2pCount', example='78'),
      p2pTraffic?: double(name='P2pTraffic', example='4102'),
      rtmpBps?: float(name='RtmpBps', example='3323'),
      rtmpCount?: long(name='RtmpCount', example='63'),
      rtmpTraffic?: double(name='RtmpTraffic', example='5568'),
      rtsBps?: double(name='RtsBps', example='2361'),
      rtsCount?: long(name='RtsCount', example='89'),
      rtsTraffic?: double(name='RtsTraffic', example='2322'),
      streamName?: string(name='StreamName', example='test.flv'),
      timeStamp?: string(name='TimeStamp', example='2015-12-10T20:00:00Z'),
      traffic?: double(name='Traffic', example='423304182'),
    }
  ](name='StreamDetailData'),
  totalCount?: long(name='TotalCount', example='50'),
}

model DescribeLiveUserStreamMetricDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUserStreamMetricDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveUserStreamMetricData  DescribeLiveUserStreamMetricDataRequest
  * @return DescribeLiveUserStreamMetricDataResponse
 */
async function describeLiveUserStreamMetricData(request: DescribeLiveUserStreamMetricDataRequest): DescribeLiveUserStreamMetricDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUserStreamMetricData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUserTagsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveUserTagsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6B0256B6-2442-5BEF-B8D6-A0C28A801DFC'),
  tags?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='key1'),
      value?: [ string ](name='Value', description='The value of the tag.'),
    }
  ](name='Tags', description='The tags.'),
}

model DescribeLiveUserTagsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUserTagsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveUserTags  DescribeLiveUserTagsRequest
  * @return DescribeLiveUserTagsResponse
 */
async function describeLiveUserTags(request: DescribeLiveUserTagsRequest): DescribeLiveUserTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUserTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveUserTrafficLogRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeLiveUserTrafficLogResponseBody = {
  domainLogDetails?: {
    domainLogDetail?: [ 
    {
      logCount?: long(name='LogCount'),
      logInfos?: {
        logInfoDetail?: [ 
        {
          endTime?: string(name='EndTime'),
          logName?: string(name='LogName'),
          logPath?: string(name='LogPath'),
          logSize?: long(name='LogSize'),
          startTime?: string(name='StartTime'),
        }
      ](name='LogInfoDetail')
      }(name='LogInfos'),
      pageInfos?: {
        pageIndex?: long(name='PageIndex'),
        pageSize?: long(name='PageSize'),
        total?: long(name='Total'),
      }(name='PageInfos'),
    }
  ](name='DomainLogDetail')
  }(name='DomainLogDetails'),
  domainName?: string(name='DomainName'),
  requestId?: string(name='RequestId'),
}

model DescribeLiveUserTrafficLogResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveUserTrafficLogResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeLiveUserTrafficLog  DescribeLiveUserTrafficLogRequest
  * @return DescribeLiveUserTrafficLogResponse
 */
async function describeLiveUserTrafficLog(request: DescribeLiveUserTrafficLogRequest): DescribeLiveUserTrafficLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveUserTrafficLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLiveVerifyContentRequest {
  domainName: string(name='DomainName', description='The domain name. You can specify only one domain name.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeLiveVerifyContentResponseBody = {
  content?: string(name='Content', description='The verification content.', example='verify_dffeb6610035dcb77b413******'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DescribeLiveVerifyContentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeLiveVerifyContentResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * *   You can call this operation to query the ownership verification content of a single domain name.
  * *   You can call this operation up to 30 times per second per account.
  * *   When you call this operation, you need to specify a domain name as a request parameter.
  * *   After a successful call, the verification content and request ID are returned, which can be used for subsequent operations.
  * @param request  the request parameters of DescribeLiveVerifyContent  DescribeLiveVerifyContentRequest
  * @return DescribeLiveVerifyContentResponse
 */
async function describeLiveVerifyContent(request: DescribeLiveVerifyContentRequest): DescribeLiveVerifyContentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLiveVerifyContent', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMeterLiveBypassDurationRequest {
  appId: string(name='AppId', description='The ID of the application. You can view the application ID on the [Applications](https://help.aliyun.com/document_detail/2355593.html) page in the ApsaraVideo Real-time Communication (ARTC) section of the ApsaraVideo Live console.

This parameter is required.', example='4346289a-a790-4869-9e23-22766d5e****', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The time range that can be specified is greater than or equal to 5 minutes and less than or equal to 31 days.

This parameter is required.', example='2022-10-10T21:00:00Z', position='Query'),
  interval?: string(name='Interval', description='The time granularity of the query. Unit: seconds. Valid values:

*   300
*   3600
*   86400

If you specify an invalid value or do not specify this parameter, the default value 3600 is used.', example='86400', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2022-10-10T20:00:00Z', position='Query'),
}

model DescribeMeterLiveBypassDurationResponseBody = {
  audioSummaryDuration?: long(name='AudioSummaryDuration', description='The total audio-only duration. Audio-only is a basic specification. Unit: minutes.', example='20'),
  data?: [ 
    {
      audioDuration?: long(name='AudioDuration', description='The audio-only duration. Audio-only is a basic specification. Unit: minutes.', example='20'),
      singleAudio?: long(name='Single_Audio', description='The single-stream relay duration for audio. Unit: minutes.', example='20'),
      singleVideo?: long(name='Single_Video', description='The single-stream relay duration for video. Unit: minutes.', example='30'),
      timestamp?: string(name='Timestamp', description='The timestamp of the data returned.', example='2022-10-10T20:00:00Z'),
      totalDuration?: long(name='TotalDuration', description='The duration. Unit: minutes.', example='150'),
      v1080Duration?: long(name='V1080Duration', description='The Full HD duration. The video resolution is 1920 × 1080 or lower. Unit: minutes.', example='10'),
      v480Duration?: long(name='V480Duration', description='The SD duration. The video resolution is 640 × 480 or lower. Unit: minutes.', example='30'),
      v720Duration?: long(name='V720Duration', description='The HD duration. The video resolution is 1280 × 720 or lower. Unit: minutes.', example='40'),
    }
  ](name='Data', description='The usage statistics for each time granularity.'),
  requestId?: string(name='RequestId', description='The request ID.', example='4B460F8B-993C-4F48-B98A-910811DEBFEB'),
  singleAudioSummaryDuration?: long(name='SingleAudioSummaryDuration', description='The total single-stream relay duration for audio. Unit: minutes.', example='20'),
  singleVideoSummaryDuration?: long(name='SingleVideoSummaryDuration', description='The total single-stream relay duration for video. Unit: minutes.', example='30'),
  totalSummaryDuration?: long(name='TotalSummaryDuration', description='The total duration. Unit: minutes.', example='150'),
  v1080SummaryDuration?: long(name='V1080SummaryDuration', description='The total Full HD duration. The video resolution is 1920 × 1080 or lower. Unit: minutes.', example='10'),
  v480SummaryDuration?: long(name='V480SummaryDuration', description='The total standard definition (SD) duration. The video resolution is 640 × 480 or lower. Unit: minutes.', example='30'),
  v720SummaryDuration?: long(name='V720SummaryDuration', description='The total high definition (HD) duration. The video resolution is 1280 × 720 or lower. Unit: minutes.', example='40'),
}

model DescribeMeterLiveBypassDurationResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMeterLiveBypassDurationResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * *   The maximum time range for a query is 31 days.
  * *   The minimum time granularity for a query is 5 minutes.
  * *   You can query the data in the last 90 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeMeterLiveBypassDuration  DescribeMeterLiveBypassDurationRequest
  * @return DescribeMeterLiveBypassDurationResponse
 */
async function describeMeterLiveBypassDuration(request: DescribeMeterLiveBypassDurationRequest): DescribeMeterLiveBypassDurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMeterLiveBypassDuration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMixStreamListRequest {
  appName?: string(name='AppName', description='The name of the application.', example='liveApp****', position='Query'),
  domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2020-09-20T13:00:00Z', position='Query'),
  mixStreamId?: string(name='MixStreamId', description='The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.', example='5b2a046e-74d7-385e-d2d7-8a5b87e4****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='The number of the page to return. Valid values: an integer that is greater than **0** and does not exceed the maximum value of the INTEGER data type. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Default value: **1000**.', example='1000', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2020-09-11T12:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the output stream.', example='liveStream****', position='Query'),
}

model DescribeMixStreamListResponseBody = {
  mixStreamList?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='liveApp****'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      gmtCreate?: string(name='GmtCreate', description='The time when the stream mixing task was created. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2020-09-17T08:39:14Z'),
      gmtModified?: string(name='GmtModified', description='The time when the stream mixing task was modified. The time follows the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time is displayed in UTC.', example='2020-09-17T08:39:15Z'),
      inputStreamNumber?: int32(name='InputStreamNumber', description='The number of input streams.', example='2'),
      layoutId?: string(name='LayoutId', description='The ID of the layout.', example='USERDEFINED'),
      mixStreamTemplate?: string(name='MixStreamTemplate', description='The stream mixing template.', example='lp_ld'),
      mixstreamId?: string(name='MixstreamId', description='The ID of the stream mixing task. You can specify this parameter in a request to delete the steam mixing task.', example='aaf9a50f-c460-3a9b-f180-38dd8f05****'),
      streamName?: string(name='StreamName', description='The name of the output stream.', example='liveStream****'),
    }
  ](name='MixStreamList', description='Details about the stream mixing tasks.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC1E78D3-FA8B-4457-DEE2-6093E1232254'),
  total?: int32(name='Total', description='The total number of tasks.', example='1'),
}

model DescribeMixStreamListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeMixStreamListResponseBody(name='body'),
}

/**
  * @description You can call the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation to create stream mixing tasks and then call this operation to query the list of stream mixing tasks.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeMixStreamList  DescribeMixStreamListRequest
  * @return DescribeMixStreamListResponse
 */
async function describeMixStreamList(request: DescribeMixStreamListRequest): DescribeMixStreamListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMixStreamList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRTSNativeSDKFirstFrameCostRequest {
  dataInterval?: string(name='DataInterval', description='The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  domainNameList?: [ string ](name='DomainNameList', description='From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.', shrink='json', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T21:00:00Z', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T20:00:00Z', position='Query'),
}

model DescribeRTSNativeSDKFirstFrameCostResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  endTime?: string(name='EndTime', description='The end of the time range for which the data was queried.', example='2021-12-10T21:00:00Z'),
  firstFrameCostData?: [ 
    {
      connected?: string(name='Connected', description='The time elapsed from initialization to connection establishment.', example='100'),
      finishGetStreamInfo?: string(name='FinishGetStreamInfo', description='The time elapsed from connection establishment to subscription.', example='89'),
      firstFrameComplete?: string(name='FirstFrameComplete', description='The time elapsed from first packet processing to display of the first frame.', example='32'),
      firstPacket?: string(name='FirstPacket', description='The time elapsed from subscription to first packet processing.', example='132'),
      initialized?: string(name='Initialized', description='The time consumed by initialization.', example='1100'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-12-10T20:00:00Z'),
    }
  ](name='FirstFrameCostData', description='The average latency of first frames at each interval. Unit: milliseconds.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='BC858082-736F-4A25-867B-E5B67C85ACF7'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the data was queried.', example='2021-12-10T20:00:00Z'),
}

model DescribeRTSNativeSDKFirstFrameCostResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRTSNativeSDKFirstFrameCostResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the information about the factors that cause latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
  * @param request  the request parameters of DescribeRTSNativeSDKFirstFrameCost  DescribeRTSNativeSDKFirstFrameCostRequest
  * @return DescribeRTSNativeSDKFirstFrameCostResponse
 */
async function describeRTSNativeSDKFirstFrameCost(request: DescribeRTSNativeSDKFirstFrameCostRequest): DescribeRTSNativeSDKFirstFrameCostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRTSNativeSDKFirstFrameCost', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRTSNativeSDKFirstFrameDelayRequest {
  dataInterval?: string(name='DataInterval', description='The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  domainNameList?: [ string ](name='DomainNameList', description='From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.', shrink='json', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T21:00:00Z', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T20:00:00Z', position='Query'),
}

model DescribeRTSNativeSDKFirstFrameDelayResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  endTime?: string(name='EndTime', description='The end of the time range for which the data was queried.', example='2021-12-10T21:00:00Z'),
  frameDelayData?: [ 
    {
      frameDelay?: string(name='FrameDelay', description='The average latency of first frames within the period of time.', example='400'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-12-10T20:00:00Z'),
    }
  ](name='FrameDelayData', description='The average latency of first frames at each interval. Unit: milliseconds.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the data was queried.', example='2021-12-10T20:00:00Z'),
}

model DescribeRTSNativeSDKFirstFrameDelayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRTSNativeSDKFirstFrameDelayResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the average latency of first frames within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
  * @param request  the request parameters of DescribeRTSNativeSDKFirstFrameDelay  DescribeRTSNativeSDKFirstFrameDelayRequest
  * @return DescribeRTSNativeSDKFirstFrameDelayResponse
 */
async function describeRTSNativeSDKFirstFrameDelay(request: DescribeRTSNativeSDKFirstFrameDelayRequest): DescribeRTSNativeSDKFirstFrameDelayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRTSNativeSDKFirstFrameDelay', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRTSNativeSDKPlayFailStatusRequest {
  dataInterval?: string(name='DataInterval', description='The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  domainNameList?: [ string ](name='DomainNameList', description='From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.', shrink='json', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T21:00:00Z', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T20:00:00Z', position='Query'),
}

model DescribeRTSNativeSDKPlayFailStatusResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  endTime?: string(name='EndTime', description='The end of the time range for which the data was queried.', example='2021-12-10T21:00:00Z'),
  playFailStatus?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-12-10T20:00:00Z'),
      v20001?: string(name='V20001', description='The status code that indicates failed DNS resolution.', example='1'),
      v20002?: string(name='V20002', description='The status code that indicates failed authentication.', example='2'),
      v20011?: string(name='V20011', description='The status code that indicates a connection signaling timeout.', example='3'),
      v20012?: string(name='V20012', description='The status code that indicates a subscription signaling error.', example='4'),
      v20013?: string(name='V20013', description='The status code indicating that the stream to subscribe to does not exist.', example='5'),
      v20052?: string(name='V20052', description='The status code that indicates a media packet collection timeout.', example='6'),
    }
  ](name='PlayFailStatus', description='The number of error status codes at each interval.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the data was queried.', example='2021-12-10T20:00:00Z'),
}

model DescribeRTSNativeSDKPlayFailStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRTSNativeSDKPlayFailStatusResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the causes of playback failures that occurred within a specified period of time. The causes are returned in the form of status codes. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
  * @param request  the request parameters of DescribeRTSNativeSDKPlayFailStatus  DescribeRTSNativeSDKPlayFailStatusRequest
  * @return DescribeRTSNativeSDKPlayFailStatusResponse
 */
async function describeRTSNativeSDKPlayFailStatus(request: DescribeRTSNativeSDKPlayFailStatusRequest): DescribeRTSNativeSDKPlayFailStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRTSNativeSDKPlayFailStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRTSNativeSDKPlayTimeRequest {
  dataInterval?: string(name='DataInterval', description='The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  domainNameList?: [ string ](name='DomainNameList', description='From V2.1.0, all domain names are queried by default. You can also specify specific domain names that you want to query. In this case, separate the domain names with commas (,). You can specify up to 500 domain names in each call.', shrink='json', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T21:00:00Z', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T20:00:00Z', position='Query'),
}

model DescribeRTSNativeSDKPlayTimeResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  endTime?: string(name='EndTime', description='The end of the time range for which the data was queried.', example='2021-12-10T21:00:00Z'),
  playTimeData?: [ 
    {
      playTime?: string(name='PlayTime', description='The average playback duration within the period of time.', example='1000'),
      stallTime?: string(name='StallTime', description='The average stuttering duration within the period of time.', example='100'),
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-12-10T20:00:00Z'),
    }
  ](name='PlayTimeData', description='The average playback duration and average stuttering duration at each interval. Unit: milliseconds.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the data was queried.', example='2021-12-10T20:00:00Z'),
}

model DescribeRTSNativeSDKPlayTimeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRTSNativeSDKPlayTimeResponseBody(name='body'),
}

/**
  * @description You can query the playback duration within a specified period of time. You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
  * @param request  the request parameters of DescribeRTSNativeSDKPlayTime  DescribeRTSNativeSDKPlayTimeRequest
  * @return DescribeRTSNativeSDKPlayTimeResponse
 */
async function describeRTSNativeSDKPlayTime(request: DescribeRTSNativeSDKPlayTimeRequest): DescribeRTSNativeSDKPlayTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRTSNativeSDKPlayTime', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRTSNativeSDKVvDataRequest {
  dataInterval?: string(name='DataInterval', description='The time granularity. Valid values: 300, 3600, 14400, 28800, and 86400. Unit: seconds. The default value is 300. If you specify an invalid value or do not specify this parameter, the default value is used.', example='300', position='Query'),
  domainNameList?: [ string ](name='DomainNameList', description='The array of domain names.', shrink='json', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T21:00:00Z', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2021-12-10T20:00:00Z', position='Query'),
}

model DescribeRTSNativeSDKVvDataResponseBody = {
  dataInterval?: string(name='DataInterval', description='The time granularity.', example='300'),
  endTime?: string(name='EndTime', description='The end of the time range for which the data was queried.', example='2021-12-10T21:00:00Z'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  startTime?: string(name='StartTime', description='The beginning of the time range for which the data was queried.', example='2021-12-10T20:00:00Z'),
  vvData?: [ 
    {
      timeStamp?: string(name='TimeStamp', description='The timestamp of the returned data.', example='2021-12-10T20:00:00Z'),
      vvSuccess?: string(name='VvSuccess', description='The number of successful playbacks within the period of time.', example='99'),
      vvTotal?: string(name='VvTotal', description='The total number of playbacks within the period of time.', example='100'),
    }
  ](name='VvData', description='The total number of playbacks and the number of successful playbacks at each interval.'),
}

model DescribeRTSNativeSDKVvDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRTSNativeSDKVvDataResponseBody(name='body'),
}

/**
  * @description QPS limit You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see QPS limit.
  * @param request  the request parameters of DescribeRTSNativeSDKVvData  DescribeRTSNativeSDKVvDataRequest
  * @return DescribeRTSNativeSDKVvDataResponse
 */
async function describeRTSNativeSDKVvData(request: DescribeRTSNativeSDKVvDataRequest): DescribeRTSNativeSDKVvDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRTSNativeSDKVvData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRtcCloudRecordingFilesRequest {
  taskId: string(name='TaskId', description='This parameter is required.', example='******73-8501-****-8ac1-72295a******', position='Query'),
}

model DescribeRtcCloudRecordingFilesResponseBody = {
  requestId?: string(name='RequestId', example='******58-5876-****-83CA-B56278******'),
  taskInfo?: {
    recordFileList?: {
      hlsFileList?: [ string ](name='HlsFileList'),
      mp3FileList?: [ string ](name='Mp3FileList'),
      mp4FileList?: [ string ](name='Mp4FileList'),
      vodMediaList?: [ 
        {
          mediaIds?: [ string ](name='MediaIds'),
          mergedIds?: [ string ](name='MergedIds'),
          stream?: string(name='Stream'),
        }
      ](name='VodMediaList'),
    }(name='RecordFileList'),
    status?: string(name='Status', example='RUNNING'),
    taskId?: string(name='TaskId', example='******73-8501-****-8ac1-72295a******'),
  }(name='TaskInfo'),
}

model DescribeRtcCloudRecordingFilesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRtcCloudRecordingFilesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeRtcCloudRecordingFiles  DescribeRtcCloudRecordingFilesRequest
  * @return DescribeRtcCloudRecordingFilesResponse
 */
async function describeRtcCloudRecordingFiles(request: DescribeRtcCloudRecordingFilesRequest): DescribeRtcCloudRecordingFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRtcCloudRecordingFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRtcMPUEventSubRequest {
  appId: string(name='AppId', description='The ID of your application.

> The ID can be up to 64 characters in length and can contain letters, digits, underscores, and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
}

model DescribeRtcMPUEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
  subInfo?: {
    appId?: string(name='AppId', description='The application ID. You can specify only one application ID.', example='yourAppId'),
    callbackUrl?: string(name='CallbackUrl', description='The callback URL.', example='http://testcallback***.com/callback'),
    channelIds?: string(name='ChannelIds', description='The ID of the channel to which mixed-stream relay event callbacks are sent. Multiple channel IDs are separated by commas (,). If this parameter is not returned, mixed-stream relay event callbacks are sent to all channels.', example='yourCh1,yourCh2'),
    createTime?: string(name='CreateTime', description='The time when the event callback was fired. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='2024-04-09 18:00:00Z'),
    subId?: string(name='SubId', description='The ID of the subscription.', example='Sub-******9799B2C4500******'),
  }(name='SubInfo', description='The information about the subscription.'),
}

model DescribeRtcMPUEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeRtcMPUEventSubResponseBody(name='body'),
}

/**
  * @description ### Usage notes
  * - You can call this operation to query information about a subscription to mixed-stream relay events. 
  * - Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription. 
  * ### QPS limit
  * - You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeRtcMPUEventSub  DescribeRtcMPUEventSubRequest
  * @return DescribeRtcMPUEventSubResponse
 */
async function describeRtcMPUEventSub(request: DescribeRtcMPUEventSubRequest): DescribeRtcMPUEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRtcMPUEventSub', 'POST', '/', 'json', false, 'json', request);
}

model DescribeShowListRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeShowListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  showList?: string(name='ShowList', description='****Details of the episode list.

Show indicates the information about a specific episode. For more information, see the **Show** parameter.', example='ShowList[Show1, Show2, Show3...]'),
  showListInfo?: {
    background?: string(name='Background', description='The background of the episode list.', example='{\\"MaterialId\\":\\"a2b8e671-2fe5-4642-a2ec-bf93880e****\\",\\"resourceType\\":\\"VOD\\"}'),
    currentShowId?: string(name='CurrentShowId', description='The ID of the episode that is playing.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
    highPriorityShowId?: string(name='HighPriorityShowId', description='The episode of the highest priority.

> You can configure this parameter only before the episode list starts playing.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
    highPriorityShowStartTime?: string(name='HighPriorityShowStartTime', description='The time at which the episode of the highest priority is played. Format: yyyy-MM-dd\\"T\\"HH:mm:ss.

> You can configure this parameter only before the episode list starts playing. After you configure this parameter, when the specified point in time is reached, any episode that is playing stops and the episode of the highest priority in the episode list starts to play.', example='2021-11-23T12:30:00'),
    showList?: {
      show?: [ 
      {
        duration?: long(name='Duration', description='The duration of the episode. Unit: seconds.', example='20'),
        repeatTimes?: int32(name='RepeatTimes', description='The number of times the episode repeats after the first playback is complete.

For example, if you set the value to 0, the episode is to be played once. If you set the value to 1, the episode is to be played twice.', example='5'),
        resourceInfo?: {
          liveInputType?: int32(name='LiveInputType', description='The custom type label.', example='1'),
          resourceId?: string(name='ResourceId', description='The ID of the video-on-demand (VOD) file.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
          resourceType?: string(name='ResourceType', description='The type of the resource.', example='vod'),
          resourceUrl?: string(name='ResourceUrl', description='The URL of the resource.'),
        }(name='ResourceInfo', description='The resource information.'),
        showId?: string(name='ShowId', description='The ID of the episode.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
        showName?: string(name='ShowName', description='The name of the episode.', example='liveShow****'),
      }
    ](name='Show')
    }(name='ShowList', description='The episodes in the episode list.'),
    showListRepeatTimes?: int32(name='ShowListRepeatTimes', description='The number of additional times the episode list is played by default. The value is 0.', example='0'),
    totalShowListRepeatTimes?: int32(name='TotalShowListRepeatTimes', description='The number of additional times the episode list is played.', example='1'),
  }(name='ShowListInfo', description='The information about the episode list.'),
}

model DescribeShowListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeShowListResponseBody(name='body'),
}

/**
  * @description You cannot call this operation if the episode list is empty. For information about how to add episodes to the episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeShowList  DescribeShowListRequest
  * @return DescribeShowListResponse
 */
async function describeShowList(request: DescribeShowListRequest): DescribeShowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeShowList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStreamLocationBlockRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs.', example='liveApp****', position='Query'),
  blockType?: string(name='BlockType', description='The blocking type. Valid values:

*   blacklist
*   whitelist', example='blacklist', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: integers from 1 to 100.', example='5', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='stream', position='Query'),
}

model DescribeStreamLocationBlockResponseBody = {
  count?: int32(name='Count', description='The total number of entries that meet the specified conditions.', example='2'),
  pageNum?: int32(name='PageNum', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='5'),
  requestId?: string(name='RequestId', description='The request ID.', example='C7C69682-7F88-40DD-A198-10D0309E439B'),
  streamBlockList?: {
    streamBlock?: [ 
    {
      appName?: string(name='AppName', description='The name of the application in which the blocking applies.', example='liveApp****'),
      blockType?: string(name='BlockType', description='The blocking type. Valid values:

*   blacklist
*   whitelist', example='blacklist'),
      domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com'),
      locationList?: string(name='LocationList', description='The blocked region. If multiple regions are specified, such as CN and AS, they are separated by commas (,).', example='CN'),
      releaseTime?: string(name='ReleaseTime', description='The time when the blocking ends. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-08-13T09:27Z'),
      status?: int32(name='Status', description='The blocking status. Valid values: 0 (not started), 1 (blocking), 2 (successful), 3 (failed), 4 (expired), and 5 (deleting).', example='0'),
      streamName?: string(name='StreamName', description='The name of the stream.', example='stream'),
      updateTime?: string(name='UpdateTime', description='The time when the configuration was last modified. The time follows the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time is displayed in UTC.', example='2023-08-14T09:27Z'),
    }
  ](name='StreamBlock')
  }(name='StreamBlockList', description='The configurations.'),
  totalPage?: int32(name='TotalPage', description='The total number of pages.', example='1'),
}

model DescribeStreamLocationBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStreamLocationBlockResponseBody(name='body'),
}

/**
  * @description Queries configurations of stream-level region blocking.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DescribeStreamLocationBlock  DescribeStreamLocationBlockRequest
  * @return DescribeStreamLocationBlockResponse
 */
async function describeStreamLocationBlock(request: DescribeStreamLocationBlockRequest): DescribeStreamLocationBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStreamLocationBlock', 'POST', '/', 'json', false, 'json', request);
}

model DescribeStudioLayoutsRequest {
  casterId: string(name='CasterId', description='The ID of the production studio instance.

*   If you call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio instance, you can obtain the instance ID from the CasterId parameter in the response.
*   If you create a production studio instance in the ApsaraVideo Live console, perform the following operations to obtain the instance ID: Log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane. Then, view the instance ID on the **Production Studio Management** page.

>  The value displayed in the Name column for an instance on the Production Studio Management page is the ID of the instance.

This parameter is required.', example='5c6a2a0d-f228-4a64-af62-20e91b96****', position='Query'),
  layoutId?: string(name='LayoutId', description='The ID of the layout.

You can specify multiple layout IDs and separate them with commas (,). If you leave this parameter empty, all layouts of the production studio are returned.

If you call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure a layout for a virtual studio, you can obtain the ID of the layout from the LayoutId parameter in the response.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeStudioLayoutsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
  studioLayouts?: [ 
    {
      bgImageConfig?: {
        id?: string(name='Id', description='The unique ID of the material.', example='k12kj31****'),
        imageUrl?: string(name='ImageUrl', description='The URL of the material.', example='http://example.org'),
        locationId?: string(name='LocationId', description='The position ID.', example='RV01'),
        materialId?: string(name='MaterialId', description='The ID of the material in ApsaraVideo VOD.', example='asdfas9df89asd8f9****'),
      }(name='BgImageConfig', description='The background material configurations.'),
      commonConfig?: {
        channelId?: string(name='ChannelId', description='The ID of the channel that is bound to the video resource.', example='RV01'),
        videoResourceId?: string(name='VideoResourceId', description='The ID of the video resource.', example='asdfasdfasdfasdfa****'),
      }(name='CommonConfig', description='The common layout configurations. This parameter is returned only for a common layout.'),
      layerOrderConfigList?: [ 
        {
          id?: string(name='Id', description='The unique ID of the resource.', example='k12kj31****'),
          type?: string(name='Type', description='The type of the resource. Valid values:

*   **background**: background material
*   **media**: multimedia material', example='media'),
        }
      ](name='LayerOrderConfigList', description='The layer sorting configurations.'),
      layoutId?: string(name='LayoutId', description='The ID of the layout.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
      layoutName?: string(name='LayoutName', description='The name of the layout.', example='测试布局'),
      layoutType?: string(name='LayoutType', description='The type of the layout. Valid values:

*   **common**
*   **studio**', example='studio'),
      mediaInputConfigList?: [ 
        {
          channelId?: string(name='ChannelId', description='The ID of the channel that is bound to the video resource.', example='RV01'),
          fillMode?: string(name='FillMode', description='The fill type. Default value: none.', example='none'),
          heightNormalized?: float(name='HeightNormalized', description='The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.', example='0.4'),
          id?: string(name='Id', description='The unique ID of the multimedia material.', example='k12kj31****'),
          imageMaterialId?: string(name='ImageMaterialId', description='The ID of the image in ApsaraVideo VOD.', example='lkajsdfsa8fd89asd8****'),
          index?: int32(name='Index', description='The sequence number of the multimedia material. This parameter is displayed on the frontend but not used in the operation logic.', example='1'),
          positionNormalized?: [ float ](name='PositionNormalized', description='The normalized value of the position of the material, in the format of [unk][x,y][unk]. Valid values of x and y: **0 to 1**. For example, [unk][0.1,0.2][unk] indicates that the material is horizontally offset by 10% and vertically offset by 20% towards the upper-left corner.'),
          positionRefer?: string(name='PositionRefer', description='The coordinate origin for the material. Default value: topLeft. topLeft indicates that the upper-left corner is used as the coordinate origin.', example='topLeft'),
          videoResourceId?: string(name='VideoResourceId', description='The ID of the video resource.', example='asdfasdfasdfasdfa****'),
          widthNormalized?: float(name='WidthNormalized', description='The normalized value of the material width. The value indicates the ratio of the material width to the width of the background. Valid values: **0 to 1**.', example='0.4'),
        }
      ](name='MediaInputConfigList', description='The multimedia input configurations.'),
      screenInputConfigList?: [ 
        {
          audioConfig?: {
            validChannel?: string(name='ValidChannel', description='The corresponding channel.', example='1'),
            volumeRate?: float(name='VolumeRate', description='The volume.', example='1.0'),
          }(name='AudioConfig', description='The audio configurations.'),
          channelId?: string(name='ChannelId', description='The ID of the channel that is bound to the video resource.', example='RV01'),
          color?: string(name='Color', description='The color gamut for chroma key. Valid values:

*   **blue**
*   **green**
*   **auto**: automatic recognition
*   **complex**: background replacement', example='green'),
          heightNormalized?: float(name='HeightNormalized', description='The normalized value of the height. The value indicates the ratio of the height of the keyed portrait to the height of the background. Valid values: **0 to 1**.', example='0.4'),
          id?: string(name='Id', description='The unique ID of the chroma key source.', example='k12kj31****'),
          index?: int32(name='Index', description='The sequence number of the chroma key source. This parameter is displayed on the frontend but not used in the operation logic.', example='1'),
          onlyAudio?: boolean(name='OnlyAudio', description='Indicates whether only audio exists.', example='true'),
          portraitType?: int32(name='PortraitType', description='The portrait type. Valid values:

*   **0**: half body
*   **1**: full body', example='0'),
          positionX?: string(name='PositionX', description='The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0.1'),
          positionY?: string(name='PositionY', description='The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0.2'),
          videoResourceId?: string(name='VideoResourceId', description='The ID of the video resource.', example='asdfasdfasdfasdfa****'),
        }
      ](name='ScreenInputConfigList', description='The input configurations for chroma key.'),
    }
  ](name='StudioLayouts', description='The layout information.'),
  total?: int32(name='Total', description='The total number of layouts.', example='1'),
}

model DescribeStudioLayoutsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeStudioLayoutsResponseBody(name='body'),
}

/**
  * @description You must call the [AddStudioLayout](https://help.aliyun.com/document_detail/215388.html) operation to configure layouts for a virtual studio before you call this operation to query layouts.
  * ## QPS limits
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of DescribeStudioLayouts  DescribeStudioLayoutsRequest
  * @return DescribeStudioLayoutsResponse
 */
async function describeStudioLayouts(request: DescribeStudioLayoutsRequest): DescribeStudioLayoutsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeStudioLayouts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeToutiaoLivePlayRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. The end time must be later than the start time. The time span cannot be greater than 10 hours. If you do not configure StartTime and EndTime, the data within the previous hour is queried. Specify the time in the ISO 8601 standard. The time must be in UTC.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard. The time must be in UTC.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
  stream: string(name='Stream', description='The name of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeToutiaoLivePlayResponseBody = {
  content?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      bandwidth?: float(name='Bandwidth', description='The bandwidth. Unit: Mbit/s.', example='0.0801239013671875'),
      cdnName?: string(name='CdnName', description='The Content Delivery Network (CDN) name.', example='ali'),
      domain?: string(name='Domain', description='The streaming domain.', example='example.com'),
      playNum?: long(name='PlayNum', description='The number of viewers.', example='452'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1625484600'),
    }
  ](name='Content', description='The information about the live stream.'),
  description?: string(name='Description', description='The description of the response status.', example='OK'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DescribeToutiaoLivePlayResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeToutiaoLivePlayResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the stream pulling information about a live stream of a headline.
  * ## [](#qps-)QPS limits
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeToutiaoLivePlay  DescribeToutiaoLivePlayRequest
  * @return DescribeToutiaoLivePlayResponse
 */
async function describeToutiaoLivePlay(request: DescribeToutiaoLivePlayRequest): DescribeToutiaoLivePlayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeToutiaoLivePlay', 'POST', '/', 'json', false, 'json', request);
}

model DescribeToutiaoLivePublishRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The ingest domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified is 10 hours. If you specify neither StartTime nor EndTime, the data of the last hour is queried by default.

This parameter is required.', example='2017-10-10T21:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
  stream: string(name='Stream', description='The name of the ingested stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model DescribeToutiaoLivePublishResponseBody = {
  content?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      bitrate?: float(name='Bitrate', description='The bitrate. Unit: bit/s.', example='261587'),
      bwDiff?: float(name='BwDiff', description='The bitrate difference.', example='0'),
      cdnName?: string(name='CdnName', description='The name of the content delivery network (CDN) service.', example='ali'),
      domain?: string(name='Domain', description='The ingest domain.', example='example.com'),
      flr?: float(name='Flr', description='The number of dropped frames.', example='0'),
      fps?: float(name='Fps', description='The frame rate.', example='74.4'),
      streamName?: string(name='StreamName', description='The name of the ingested stream.', example='liveStream****'),
      timestamp?: long(name='Timestamp', description='The timestamp.', example='1624358970'),
    }
  ](name='Content', description='The stream ingest details.'),
  description?: string(name='Description', description='The description of the response status.', example='OK'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DescribeToutiaoLivePublishResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeToutiaoLivePublishResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the ingest information of a specified live stream that is ingested to Toutiao.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeToutiaoLivePublish  DescribeToutiaoLivePublishRequest
  * @return DescribeToutiaoLivePublishResponse
 */
async function describeToutiaoLivePublish(request: DescribeToutiaoLivePublishRequest): DescribeToutiaoLivePublishResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeToutiaoLivePublish', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUidOnlineStreamsRequest {
  appName?: string(name='AppName', position='Query'),
  domainName?: string(name='DomainName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeUidOnlineStreamsResponseBody = {
  data?: [ 
    {
      appName?: string(name='AppName'),
      domainName?: string(name='DomainName'),
      streamName?: string(name='StreamName'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  totalNum?: long(name='TotalNum'),
}

model DescribeUidOnlineStreamsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUidOnlineStreamsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of DescribeUidOnlineStreams  DescribeUidOnlineStreamsRequest
  * @return DescribeUidOnlineStreamsResponse
 */
async function describeUidOnlineStreams(request: DescribeUidOnlineStreamsRequest): DescribeUidOnlineStreamsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUidOnlineStreams', 'GET', '/', 'json', false, 'json', request);
}

model DescribeUpBpsPeakDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com', position='Query'),
  domainSwitch?: string(name='DomainSwitch', description='Specifies whether to collect statistics at the domain name level. Valid values:

*   on: collects statistics at the domain name level.
*   off: collects statistics at the user level. This is the default value.', example='on', position='Query'),
  endTime: string(name='EndTime', description='The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T21:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
}

model DescribeUpBpsPeakDataResponseBody = {
  describeUpPeakTraffics?: {
    describeUpPeakTraffic?: [ 
    {
      bandWidth?: string(name='BandWidth', description='The daily peak inbound bandwidth.', example='777.2727083333333'),
      peakTime?: string(name='PeakTime', description='The time when the daily peak bandwidth is reached.', example='1522180000000'),
      queryTime?: string(name='QueryTime', description='The time queried on the day.', example='1522080000000'),
      statName?: string(name='StatName', description='The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.', example='push-live.aliyuncs.com'),
    }
  ](name='DescribeUpPeakTraffic')
  }(name='DescribeUpPeakTraffics', description='The information about peak inbound bandwidth on each day.'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****'),
}

model DescribeUpBpsPeakDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUpBpsPeakDataResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the daily peak inbound bandwidth.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeUpBpsPeakData  DescribeUpBpsPeakDataRequest
  * @return DescribeUpBpsPeakDataResponse
 */
async function describeUpBpsPeakData(request: DescribeUpBpsPeakDataRequest): DescribeUpBpsPeakDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpBpsPeakData', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUpBpsPeakOfLineRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com', position='Query'),
  domainSwitch?: string(name='DomainSwitch', description='Specifies whether to collect statistics at the domain name level. Valid values:

*   on: collects statistics at the domain name level.
*   off (default): collects statistics at the user level.', example='on', position='Query'),
  endTime: string(name='EndTime', description='The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T21:00:00Z', position='Query'),
  line: string(name='Line', description='The leased line. Valid values: integers from 0 to 9.

This parameter is required.', example='3', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
}

model DescribeUpBpsPeakOfLineResponseBody = {
  describeUpBpsPeakOfLines?: {
    describeUpBpsPeakOfLine?: [ 
    {
      bandWidth?: float(name='BandWidth', description='The daily peak inbound bandwidth of the leased line.', example='777.2727083333333'),
      peakTime?: string(name='PeakTime', description='The time when the daily peak bandwidth of the leased line is reached.', example='1522180000000'),
      queryTime?: string(name='QueryTime', description='The time queried on the day.', example='1522080000000'),
      statName?: string(name='StatName', description='The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.', example='push-live.aliyuncs.com'),
    }
  ](name='DescribeUpBpsPeakOfLine')
  }(name='DescribeUpBpsPeakOfLines', description='The information about peak inbound bandwidth of the leased line on each day.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6CFDE7AB-571A-14EA-B072-989FF753****'),
}

model DescribeUpBpsPeakOfLineResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUpBpsPeakOfLineResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the daily peak inbound bandwidth of a leased line.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 5 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeUpBpsPeakOfLine  DescribeUpBpsPeakOfLineRequest
  * @return DescribeUpBpsPeakOfLineResponse
 */
async function describeUpBpsPeakOfLine(request: DescribeUpBpsPeakOfLineRequest): DescribeUpBpsPeakOfLineResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpBpsPeakOfLine', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUpPeakPublishStreamDataRequest {
  domainName?: string(name='DomainName', description='The accelerated domain name.', example='example.com', position='Query'),
  domainSwitch?: string(name='DomainSwitch', description='Specifies whether to collect statistics at the domain name level. Valid values:

*   on: collects statistics at the domain name level.
*   off (default): collects statistics at the user level.', example='on', position='Query'),
  endTime: string(name='EndTime', description='The end time of stream pulling. The time must be in UTC. The end time must be later than the start time. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T21:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='The start time of stream pulling. The time must be in UTC. The maximum time range that can be specified by StartTime and EndTime is 30 days.

This parameter is required.', example='2017-10-10T20:00:00Z', position='Query'),
}

model DescribeUpPeakPublishStreamDataResponseBody = {
  describeUpPeakPublishStreamDatas?: {
    describeUpPeakPublishStreamData?: [ 
    {
      bandWidth?: string(name='BandWidth', description='The daily peak inbound bandwidth.', example='777.2727083333333'),
      peakTime?: string(name='PeakTime', description='The time when the daily peak number of concurrently ingested streams is reached.', example='1522180000000'),
      publishStreamNum?: int32(name='PublishStreamNum', description='The daily peak number of concurrently ingested streams.', example='36'),
      queryTime?: string(name='QueryTime', description='The time queried on the day.', example='1522080000000'),
      statName?: string(name='StatName', description='The category of the statistical data. If the DomainSwitch parameter is set to on, the value of this parameter is the domain name. If the DomainSwitch parameter is set to off or not specified, the value of this parameter is the user ID.', example='push-live.aliyuncs.com'),
    }
  ](name='DescribeUpPeakPublishStreamData')
  }(name='DescribeUpPeakPublishStreamDatas', description='The information about the peak number of concurrently ingested streams on each day.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6CFDE7AB-571A-14EA-B072-989FF753****'),
}

model DescribeUpPeakPublishStreamDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DescribeUpPeakPublishStreamDataResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the daily peak number of concurrently ingested streams.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of DescribeUpPeakPublishStreamData  DescribeUpPeakPublishStreamDataRequest
  * @return DescribeUpPeakPublishStreamDataResponse
 */
async function describeUpPeakPublishStreamData(request: DescribeUpPeakPublishStreamDataRequest): DescribeUpPeakPublishStreamDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpPeakPublishStreamData', 'POST', '/', 'json', false, 'json', request);
}

model DisableLiveRealtimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The streaming domain for which you want to suspend real-time log delivery. Separate multiple streaming domains with commas (,).

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DisableLiveRealtimeLogDeliveryResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model DisableLiveRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DisableLiveRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description Obtain a domain name for which real-time log delivery is enabled, and then call this operation to suspend real-time log delivery for the domain name.
  * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DisableLiveRealtimeLogDelivery  DisableLiveRealtimeLogDeliveryRequest
  * @return DisableLiveRealtimeLogDeliveryResponse
 */
async function disableLiveRealtimeLogDelivery(request: DisableLiveRealtimeLogDeliveryRequest): DisableLiveRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableLiveRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model DynamicUpdateWaterMarkStreamRuleRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='pull.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the stream that contains the watermark.

This parameter is required.', example='liveStream****', position='Query'),
  templateId: string(name='TemplateId', description='The watermark template ID. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.

>  The TemplateId parameter is used to replace the watermark template ID during live streaming.

This parameter is required.', example='749b7594-86d6-37b1-513b-e1e19845****', position='Query'),
}

model DynamicUpdateWaterMarkStreamRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BE9407FF-F897-4DBD-338D-98A750AD805F'),
}

model DynamicUpdateWaterMarkStreamRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: DynamicUpdateWaterMarkStreamRuleResponseBody(name='body'),
}

/**
  * @description Dynamically updating a watermark means replacing the watermark template ID during live streaming. Before you call this operation to update a watermark, you must prepare the watermark template ID that is used for replacement. The watermark template ID is specified by the **TemplateId** parameter of this operation. You can call the [DescribeLiveStreamWatermarks](https://help.aliyun.com/document_detail/2848102.html) operation to obtain available watermark template IDs.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of DynamicUpdateWaterMarkStreamRule  DynamicUpdateWaterMarkStreamRuleRequest
  * @return DynamicUpdateWaterMarkStreamRuleResponse
 */
async function dynamicUpdateWaterMarkStreamRule(request: DynamicUpdateWaterMarkStreamRuleRequest): DynamicUpdateWaterMarkStreamRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DynamicUpdateWaterMarkStreamRule', 'POST', '/', 'json', false, 'json', request);
}

model EditPlaylistRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programConfig?: string(name='ProgramConfig', description='The configurations of the episode list. For more information, see the **ProgramConfig** section of this topic.', example='[{"RepeatNumber":"0","ProgramName":"my program"}]', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  programItems: string(name='ProgramItems', description='The episodes that you want to add to the production studio. The value is a JSON string. For more information, see the **InputProgramItem** section of this topic.

This parameter is required.', example='[{"ItemName":"item1","ResourceType":"vod","ResourceValue":"5f8809f2-3352-4d1f-a8f7-86f9429f****"}, {"ItemName": "item2","ResourceType": "vod","ResourceValue": "e7411c0b-dd98-4c61-a545-f8bfba6c****"}]', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model EditPlaylistResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to configure callbacks or add a virtual studio layout.', example='0e94d1f4-1a65-445c-9dcf-de8b3b8d****'),
  items?: {
    failedItems?: [ 
      {
        itemId?: string(name='ItemId', description='The ID of the episode.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****'),
        itemName?: string(name='ItemName', description='The name of the episode.', example='item2'),
      }
    ](name='FailedItems', description='The episodes that failed to be added.'),
    successItems?: [ 
      {
        itemId?: string(name='ItemId', description='The ID of the episode.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****'),
        itemName?: string(name='ItemName', description='The name of the episode.', example='item1'),
      }
    ](name='SuccessItems', description='The episodes that were added.'),
  }(name='Items', description='The information about the episodes.'),
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to delete the episode list, query the information about the episode list, start the episode list, or stop the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model EditPlaylistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EditPlaylistResponseBody(name='body'),
}

/**
  * @description You can call this operation to update all configurations of episodes in an episode list or replace the episodes.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of EditPlaylist  EditPlaylistRequest
  * @return EditPlaylistResponse
 */
async function editPlaylist(request: EditPlaylistRequest): EditPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EditPlaylist', 'POST', '/', 'json', false, 'json', request);
}

model EditShowAndReplaceRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='53200b81-b761-4c10-842a-a0726d97****', position='Query'),
  endTime?: float(name='EndTime', description='The end time of the editing task. Unit: seconds.

> 

*   The valid values range from 0 to the value indicated by the total length of the episode.

*   By default, this parameter is set to the value that indicates the total length of the episode. The editing period cannot exceed the total length of the episode.

*   If you want to edit a VOD file from the 2nd second to the 5th second, set the StartTime parameter to 2.0 and the EndTime parameter to 5.0.', example='5.0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showId: string(name='ShowId', description='The ID of the episode to be edited.

>  You can obtain the ID from the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) operation.

This parameter is required.', example='42200b81-b761-4c10-842a-a0726d97****', position='Query'),
  startTime?: float(name='StartTime', description='The start time of the editing task. Unit: seconds.

> 

*   The valid values range from 0 to the value indicated by the total length of the episode. By default, the editing task starts from the beginning of the episode. Default value: 0.0.

*   If you want to edit a VOD file from the 2nd second to the 5th second, set the StartTime parameter to 2.0 and the EndTime parameter to 5.0.', example='2.0', position='Query'),
  storageInfo?: string(name='StorageInfo', description='The storage information of the episode. The following fields are included:

*   **StorageLocation**: the storage location of ApsaraVideo VOD.
*   **FileName**: the custom file name.

>  Editing outputs must be stored in the VOD bucket within the same account that is used to access both ApsaraVideo VOD and ApsaraVideo Live. For more information about how to obtain the storage location, see [Manage VOD resources](https://help.aliyun.com/document_detail/86097.html).', example='{ "StorageLocation":"***bucket***", "FileName":"EditFile****.mp4" }', position='Query'),
  userData?: string(name='UserData', description='The user information.', example='900a2b2r8-13c2-****-88f2-75e4a07c1ed9', position='Query'),
}

model EditShowAndReplaceResponseBody = {
  jobInfo?: string(name='JobInfo', description='The information about the editing task. The following fields are included:

*   **vodId**: the ID of the VOD file.
*   **mediaid**: the ID of the media file.
*   **jobId**: the ID of the editing task.', example='{         "vodId": "3e34733b40b9a96ccf5c1ff6f69****",         "mediaid": "eb1861d2c9a842340e989dd56****",         "jobId": "7d2fbc380b0e08e55fe98733764****"     }'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model EditShowAndReplaceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EditShowAndReplaceResponseBody(name='body'),
}

/**
  * @description You can call this operation to create an editing task by specifying the production studio ID and the episode ID. You will not receive a notification after the editing task is created. You can call the [GetEditingJobInfo](https://help.aliyun.com/document_detail/2848059.html) operation to query the status of the editing task.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of EditShowAndReplace  EditShowAndReplaceRequest
  * @return EditShowAndReplaceResponse
 */
async function editShowAndReplace(request: EditShowAndReplaceRequest): EditShowAndReplaceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EditShowAndReplace', 'POST', '/', 'json', false, 'json', request);
}

model EffectCasterUrgentRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene. This parameter takes effect only if the scene is a PGM scene.

You can call the [DescribeCasterScenes](https://help.aliyun.com/document_detail/2848039.html) operation to query the scene ID.

This parameter is required.', example='242b4e2c-c30f-4442-85ba-2e3e4e3d****', position='Query'),
}

model EffectCasterUrgentResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model EffectCasterUrgentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EffectCasterUrgentResponseBody(name='body'),
}

/**
  * @description You can call this operation to switch a specified scene to the standby resource. Only a PGM scene is supported.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of EffectCasterUrgent  EffectCasterUrgentRequest
  * @return EffectCasterUrgentResponse
 */
async function effectCasterUrgent(request: EffectCasterUrgentRequest): EffectCasterUrgentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EffectCasterUrgent', 'POST', '/', 'json', false, 'json', request);
}

model EffectCasterVideoResourceRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId: string(name='ResourceId', description='The resource ID. If you call the [DescribeCasterChannels](https://help.aliyun.com/document_detail/2848046.html) operation to query the channels of the production studio, you can obtain the ID of the resource in a specific channel from the ResourceId parameter in the response.

This parameter is required.', example='f096e8d6-0319-4c96-82bc-ecbc79cf****', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene. You can call the [DescribeCasterScenes](~~60262#doc-api-live-DescribeCasterScenes~~ "Queries information about the scenes of a production studio.") operation to get the ID.

This parameter is required.', example='05ab713c-676e-49c0-96ce-cc408da1****', position='Query'),
}

model EffectCasterVideoResourceResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model EffectCasterVideoResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EffectCasterVideoResourceResponseBody(name='body'),
}

/**
  * @description Make sure that the resource is referenced by the scene.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of EffectCasterVideoResource  EffectCasterVideoResourceRequest
  * @return EffectCasterVideoResourceResponse
 */
async function effectCasterVideoResource(request: EffectCasterVideoResourceRequest): EffectCasterVideoResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EffectCasterVideoResource', 'POST', '/', 'json', false, 'json', request);
}

model EnableLiveRealtimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The streaming domain for which you want to enable real-time log delivery.

Separate multiple streaming domains with commas (,).

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model EnableLiveRealtimeLogDeliveryResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model EnableLiveRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: EnableLiveRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description ##
  * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
  * ## QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of EnableLiveRealtimeLogDelivery  EnableLiveRealtimeLogDeliveryRequest
  * @return EnableLiveRealtimeLogDeliveryResponse
 */
async function enableLiveRealtimeLogDelivery(request: EnableLiveRealtimeLogDeliveryRequest): EnableLiveRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableLiveRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model ForbidLiveStreamRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  liveStreamType: string(name='LiveStreamType', description='Specifies whether the live stream is ingested by a streamer or played by a viewer. Set the value to **publisher**.

This parameter is required.', example='publisher', position='Query'),
  oneshot?: string(name='Oneshot', description='Specifies whether to only interrupt the live stream without adding the ingest URL of the live stream to the blacklist. Valid values:

*   **yes**: interrupts the live stream but does not add the ingest URL of the live stream to the blacklist. This value is available only when the live stream is ingested or played in the upstream.
*   **no**: disables the live stream and adds the ingest URL of the live stream to the blacklist.

>  If you do not specify this parameter, the default value no is used.', example='yes', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resumeTime?: string(name='ResumeTime', description='The time when the live stream is resumed. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

> 

*   If you set the **Oneshot** parameter to **no** and do not specify this parameter, the live stream is disabled for six months by default.

*   If you specify this parameter, the live stream is resumed at the specified point in time.', example='2015-12-01T10:37:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the ingested stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model ForbidLiveStreamResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16BFE188-B193-4C3C-ADC5-79A7E31486EA'),
}

model ForbidLiveStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ForbidLiveStreamResponseBody(name='body'),
}

/**
  * @description You can call this operation to disable a live stream and specify the time when the live stream is resumed. If the time is not specified, you can call the [ResumeLiveStream](https://help.aliyun.com/document_detail/2847831.html) operation to resume the live stream. This operation supports only the live streams ingested by streamers.
  * > 
  * *   This operation disables a live stream by adding the stream to the blacklist. You can disable up to 10,000 live streams. If the limit is reached, you cannot disable any more live streams. Pay attention to the number of live streams that are disabled. You can call the [DescribeLiveStreamsBlockList](https://help.aliyun.com/document_detail/2847825.html) operation to query the number of live streams that are disabled.
  * *   An interrupted live stream is not added to the blacklist and does not occupy the quota.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ForbidLiveStream  ForbidLiveStreamRequest
  * @return ForbidLiveStreamResponse
 */
async function forbidLiveStream(request: ForbidLiveStreamRequest): ForbidLiveStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ForbidLiveStream', 'POST', '/', 'json', false, 'json', request);
}

model GetAllCustomTemplatesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  userId?: string(name='UserId', description='The ID of the user.', example='25346073170691****', position='Query'),
}

model GetAllCustomTemplatesResponseBody = {
  customTemplates?: string(name='CustomTemplates', description='The template names and template configurations returned.', example='[{"templateConfig": "{\\"cdesc\\":\\"H264\\",\\"scale\\":\\"[3:4]\\",\\"gop\\":\\"1\\",\\"bframes\\":\\"1\\",\\"height\\":\\"1080\\"}","templateName": "custom1"},{"templateConfig": "{\\"ar\\":\\"44100\\",\\"cdesc\\":\\"H264\\",\\"scale\\":\\"[3:4]\\",\\"gop\\":\\"1\\",\\"bframes\\":\\"1\\",\\"height\\":\\"1080\\"}","templateName": "cus"}]'),
  requestId?: string(name='RequestId', description='The request ID.', example='4791648Q-813C-6254-865C-0ED913661230'),
}

model GetAllCustomTemplatesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetAllCustomTemplatesResponseBody(name='body'),
}

/**
  * @description You can call this operation to query all custom stream mixing templates. A list of template names and template configurations is returned.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of GetAllCustomTemplates  GetAllCustomTemplatesRequest
  * @return GetAllCustomTemplatesResponse
 */
async function getAllCustomTemplates(request: GetAllCustomTemplatesRequest): GetAllCustomTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetAllCustomTemplates', 'POST', '/', 'json', false, 'json', request);
}

model GetCustomTemplateRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The name of the custom template that you want to query. The value is a string.

This parameter is required.', example='TestTemplate', position='Query'),
}

model GetCustomTemplateResponseBody = {
  customTemplate?: string(name='CustomTemplate', description='The configurations of the template.', example='{height:1080,scale:[16:9],gop:60,bframes:30,cdesc:h264}'),
  requestId?: string(name='RequestId', description='The request ID.', example='BC1E78D3-FA8B-4457-DEE2-6093E1232254'),
  template?: string(name='Template', description='The name of the template.', example='TestTemplate'),
}

model GetCustomTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetCustomTemplateResponseBody(name='body'),
}

/**
  * @description Obtain the name of the custom stream mixing template, and then call this operation to query the information about the template.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of GetCustomTemplate  GetCustomTemplateRequest
  * @return GetCustomTemplateResponse
 */
async function getCustomTemplate(request: GetCustomTemplateRequest): GetCustomTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetCustomTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  jobId: string(name='JobId', description='The ID of the edge transcoding task.

This parameter is required.', example='****20b48fb04483915d4f2cd8ac****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetEdgeTranscodeJobResponseBody = {
  job?: {
    createTime?: string(name='CreateTime', description='The time when the task was created.', example='2023-07-24T16:44:55Z'),
    jobId?: string(name='JobId', description='The ID of the task.', example='****20b48fb04483915d4f2cd8ac****'),
    lastStartAt?: string(name='LastStartAt', description='The time when the task was last started.', example='2023-07-25T02:48:58Z'),
    lastStopAt?: string(name='LastStopAt', description='The time when the task was last stopped.', example='2023-07-25T05:48:58Z'),
    name?: string(name='Name', description='The name of the task.', example='my_job'),
    status?: string(name='Status', description='The status of the task. Valid values:

*   0: not started
*   1: in progress', example='0'),
    streamInput?: string(name='StreamInput', description='The URL of the input stream.', example='rtmp://mydomain/app/stream1'),
    streamOutput?: string(name='StreamOutput', description='The URL of the output stream.', example='rtmp://testdomain/app/stream2'),
    templateId?: string(name='TemplateId', description='The ID of the edge transcoding template used by the task.', example='9b1571b513cb44f7a1ba6ae561ff****'),
    templateName?: string(name='TemplateName', description='The name of the edge transcoding template used by the task.', example='my_template'),
    type?: string(name='Type', description='The type of edge transcoding. Valid values:

*   common: standard transcoding and Narrowband HD™ 1.0 transcoding
*   nbhd-2: Narrowband HD™ 2.0 transcoding
*   ultra-hd: ultra-high definition transcoding', example='common'),
  }(name='Job', description='The details of the edge transcoding task.'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model GetEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of GetEdgeTranscodeJob  GetEdgeTranscodeJobRequest
  * @return GetEdgeTranscodeJobResponse
 */
async function getEdgeTranscodeJob(request: GetEdgeTranscodeJobRequest): GetEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model GetEdgeTranscodeTemplateRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateId: string(name='TemplateId', description='The template ID.

This parameter is required.', example='****a046-263c-3560-978a-fb287666****', position='Query'),
}

model GetEdgeTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
  template?: {
    bitrate?: string(name='Bitrate', description='The bitrate. If a numeric value is returned, a fixed bitrate is configured for the output stream. If ws is returned, the output stream maintains the same bitrate as the input stream.', example='3000'),
    codec?: string(name='Codec', description='The video encoding format. Valid values:

*   H.264
*   H.265', example='H.264'),
    createTime?: string(name='CreateTime', description='The time when the template was created.', example='2023-07-25T02:48:58Z'),
    fps?: string(name='Fps', description='The frame rate. If a numeric value is returned, a fixed frame rate is configured for the output stream. If ws is returned, the output stream maintains the same frame rate as the input stream.', example='30'),
    gop?: string(name='Gop', description='The group of pictures (GOP) size. The GOP size can be defined by the number of frames or the time interval between I-frames. If ws is returned, the output stream maintains the same GOP size as the input stream.', example='2s'),
    name?: string(name='Name', description='The template name.', example='my_template'),
    resolution?: string(name='Resolution', description='The resolution. If width and height values are returned, a fixed resolution is configured for the output stream. If ws is returned, the output stream maintains the same resolution as the input stream.

>  If the width value is -1, the width of the output stream is adapted to the height. If the height value is -2, the height of the output stream is adapted to the width.', example='1920*1080'),
    templateId?: string(name='TemplateId', description='The template ID.', example='9b1571b513cb44f7a1ba6ae561ff****'),
    type?: string(name='Type', description='The type of edge transcoding.', example='common'),
  }(name='Template', description='The details of the edge transcoding template.'),
}

model GetEdgeTranscodeTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEdgeTranscodeTemplateResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the details of an edge transcoding template.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of GetEdgeTranscodeTemplate  GetEdgeTranscodeTemplateRequest
  * @return GetEdgeTranscodeTemplateResponse
 */
async function getEdgeTranscodeTemplate(request: GetEdgeTranscodeTemplateRequest): GetEdgeTranscodeTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEdgeTranscodeTemplate', 'POST', '/', 'json', false, 'json', request);
}

model GetEditingJobInfoRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='53200b81-b761-4c10-842a-a0726d97****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showId?: string(name='ShowId', description='The ID of the episode for which you want to query editing tasks.

>  You can obtain the ID from the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html) operation.', example='72200b81-b761-4c10-842a-a0726d97****', position='Query'),
}

model GetEditingJobInfoResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio.', example='53200b81-b761-4c10-842a-a0726d97****'),
  editingTasksInfo?: string(name='EditingTasksInfo', description='The information about editing tasks. The following fields are returned for each editing task:

*   **OutputVodId**: the ID of the output video-on-demand (VOD) file.
*   **TaskStatus**: the status of the editing task. Valid values: -1, 0, 1, 2, and 3. A value of -1 indicates that the editing task fails. A value of 0 indicates that the editing task is being initialized. A value of 1 indicates that editing is in progress. A value of 2 indicates that the output VOD file is being uploaded. A value of 3 indicates that the editing task is successful.
*   **StorageLocation**: the storage location in ApsaraVideo VOD.
*   **FileName**: the name of the file that is edited.
*   **ShowId**: the ID of the episode.', example='"EditingTasksInfo": {     "OutputVodId": "3e34733b40b9a96ccf5c1ff6f69****",     "TaskStatus": 1,     "StorageInfo": {       "StorageLocation": "***bucket***",       "FileName": "EditFile****"     },     "ShowId": "42200b81-b761-4c10-842a-a0726d97****"   },'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model GetEditingJobInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetEditingJobInfoResponseBody(name='body'),
}

/**
  * @description *   When you call this operation, you can specify the CasterId and ShowId parameters to query the information about specific editing tasks. Make sure that the parameter settings meet the requirements.
  * *   If you specify the ShowId parameter in the request, the information about the editing tasks for the specified episode is returned.
  * *   If you do not specify the ShowId parameter in the request, the information about the editing tasks for the entire episode list is returned.
  * ### [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of GetEditingJobInfo  GetEditingJobInfoRequest
  * @return GetEditingJobInfoResponse
 */
async function getEditingJobInfo(request: GetEditingJobInfoRequest): GetEditingJobInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetEditingJobInfo', 'POST', '/', 'json', false, 'json', request);
}

model GetMessageAppRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
}

model GetMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    appConfig?: map[string]string(name='AppConfig', description='The configurations of the application.'),
    appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***'),
    appName?: string(name='AppName', description='The name of the interactive messaging application.', example='testApp'),
    createTime?: long(name='CreateTime', description='The time when the interactive messaging application was created. The time is displayed in UTC.', example='502280113'),
    extension?: map[string]string(name='Extension', description='The extended field.'),
    status?: int32(name='Status', description='The status of the interactive message application. A value of 1 indicates that the application is normal.', example='1'),
  }(name='Result', description='The returned result.'),
}

model GetMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of GetMessageApp  GetMessageAppRequest
  * @return GetMessageAppResponse
 */
async function getMessageApp(request: GetMessageAppRequest): GetMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model GetMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
}

model GetMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    createTime?: long(name='CreateTime', description='The time when the message group was created. The time is displayed in UTC.', example='1502280113'),
    creatorId?: string(name='CreatorId', description='The ID of the creator.', example='as****hs'),
    extension?: map[string]any(name='Extension', description='The extended field.', example='1'),
    groupId?: string(name='GroupId', description='The ID of the message group.', example='AE35-****-T95F'),
    isMuteAll?: boolean(name='IsMuteAll', description='Indicates whether the message group is muted.

*   true: The message group is muted.
*   false: The message group is not muted.', example='true'),
    status?: int32(name='Status', description='The status of the message group. The default value is **1**, which indicates that the message group is normal.', example='1'),
  }(name='Result', description='The returned result.'),
}

model GetMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMessageGroupResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of GetMessageGroup  GetMessageGroupRequest
  * @return GetMessageGroupResponse
 */
async function getMessageGroup(request: GetMessageGroupRequest): GetMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model GetMessageTokenRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='a494caec-***-695ef345db77', position='Body'),
  deviceId: string(name='DeviceId', description='The ID of the device. Each device has a unique ID. You can specify a custom ID. The ID can be up to 64 characters in length and can contain lowercase letters, digits, underscores (_), and hyphen (-). You can specify multiple device IDs. We recommend that you obtain the IDs from the devices and pass the IDs to the server.

This parameter is required.', example='a494caec-***-695ef345db77', position='Body'),
  deviceType: string(name='DeviceType', description='The type of the device. Valid values:

*   ios
*   android
*   web
*   pc

This parameter is required.', example='android', position='Body'),
  userId: string(name='UserId', description='The ID of the user. Each user has a unique ID in the application. The ID can be up to 32 characters in length and can contain lowercase letters, digits, underscores (_), and periods (.). You can specify multiple user IDs.

This parameter is required.', example='de1**a0', position='Body'),
}

model GetMessageTokenResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    accessToken?: string(name='AccessToken', description='The token used to establish a persistent connection.', example='oauth_cloud_key:***-b0YY5Gy6Q'),
    accessTokenExpiredTime?: long(name='AccessTokenExpiredTime', description='Indicates how long until the token expires. Unit: milliseconds.', example='86400000'),
    refreshToken?: string(name='RefreshToken', description='The updated token. If a token expires, you can call RefreshToken to obtain a new token.', example='oauth_cloud_key:****-Q62xggOTdgk3gw='),
  }(name='Result', description='The returned result.'),
}

model GetMessageTokenResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetMessageTokenResponseBody(name='body'),
}

/**
  * @description ##
  * Obtain the user ID, device ID, and device type of the client, and then pass the information to the server. When you call this operation, the server obtains a token and returns the token to the client. Different users have different user IDs, and different devices have different device IDs.
  * ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of GetMessageToken  GetMessageTokenRequest
  * @return GetMessageTokenResponse
 */
async function getMessageToken(request: GetMessageTokenRequest): GetMessageTokenResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetMessageToken', 'POST', '/', 'json', true, 'form', request);
}

model GetTranscodeTaskStatusRequest {
  app?: string(name='App', position='Query'),
  pushDomain?: string(name='PushDomain', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName?: string(name='StreamName', position='Query'),
  transcodingTemplate?: string(name='TranscodingTemplate', position='Query'),
}

model GetTranscodeTaskStatusResponseBody = {
  requestId?: string(name='RequestId'),
}

model GetTranscodeTaskStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: GetTranscodeTaskStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of GetTranscodeTaskStatus  GetTranscodeTaskStatusRequest
  * @return GetTranscodeTaskStatusResponse
 */
async function getTranscodeTaskStatus(request: GetTranscodeTaskStatusRequest): GetTranscodeTaskStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetTranscodeTaskStatus', 'POST', '/', 'json', false, 'json', request);
}

model HotLiveRtcStreamRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='app', position='Query'),
  audioMsid: string(name='AudioMsid', description='The audio MSID.

This parameter is required.', example='rts audio', position='Query'),
  connectionTimeout?: string(name='ConnectionTimeout', description='The duration for which the prefetch connection is maintained. Unit: milliseconds. Default value: 0, which specifies that the prefetch connection is always maintained.', example='0', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  mediaTimeout?: string(name='MediaTimeout', description='The custom period after which a timeout event is triggered. Unit: milliseconds.', example='100000', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionCode: string(name='RegionCode', description='The code of the region in which the live stream is prefetched. For more information, see the following tables that list available region codes.

>  Region codes include provincial codes for China and country codes for all countries.

This parameter is required.', example='ZHJ', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream that you want to prefetch.

This parameter is required.', example='stream', position='Query'),
  videoMsid: string(name='VideoMsid', description='The video MSID.

This parameter is required.', example='rts video', position='Query'),
}

model HotLiveRtcStreamResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16BFE188-B193-4C3C-ADC5-79A7E31486EA'),
}

model HotLiveRtcStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: HotLiveRtcStreamResponseBody(name='body'),
}

/**
  * @description ### [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of HotLiveRtcStream  HotLiveRtcStreamRequest
  * @return HotLiveRtcStreamResponse
 */
async function hotLiveRtcStream(request: HotLiveRtcStreamRequest): HotLiveRtcStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'HotLiveRtcStream', 'POST', '/', 'json', false, 'json', request);
}

model InitializeAutoShowListTaskRequest {
  callBackUrl?: string(name='CallBackUrl', description='The callback URL.', example='http://***.com/callback', position='Query'),
  casterConfig: string(name='CasterConfig', description='The configurations of the production studio. The following configurations are involved:

*   CasterTemplate: required. The output resolution.
*   LiveTemplate: optional. The templates to be used for transcoding.

>  Set the value to a JSON string. Use upper camel case for fields of the string.

This parameter is required.', example='{"CasterTemplate": "lp_ld","LiveTemplates":["lhd", "lsd","lud"]}', position='Query'),
  domainName: string(name='DomainName', description='The output streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  endTime: long(name='EndTime', description='The end timestamp. Unit: milliseconds.

This parameter is required.', example='1645688994000', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceIds?: string(name='ResourceIds', description='The IDs of on-demand media asset files in the playlist. Only on-demand video files are supported. You can specify up to three video files in the playlist. The video files in the playlist are automatically played in sequence. The playback stops at the point in time specified by the EndTime parameter.

> 

*   You can obtain the ID of a video file in the ApsaraVideo Live console or by calling an API operation. For more information, see [Media asset management](https://help.aliyun.com/document_detail/86057.html) or [CreateUploadVideo](https://help.aliyun.com/document_detail/55407.html). - If the video files are all played before the time specified by EndTime, the final frame of the final video file is played until the time specified by EndTime arrives.', example='["89e02xxxxfb349axxxxa0c350d****  ","6ae0xxxxxb349axxxxa0c350a****"]', position='Query'),
  startTime: long(name='StartTime', description='The start timestamp. Unit: milliseconds.

This parameter is required.', example='1645688994000', position='Query'),
}

model InitializeAutoShowListTaskResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio.

>  The value of this parameter can be used as the value of a request parameter to query the streaming URL of the production studio, start the production studio, add video resources to the production studio, add a production studio layout, query production studio layouts, add a production studio component, and add a production studio playlist.', example='b4810848-bcf9-4aef-bd4a-e6bba2d9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  streamList?: string(name='StreamList', description='The list of output video streams.

*   videoFormat: the format of the streaming URL.
*   outputStreamUrl: the source URL.
*   transcodeConfig: the output resolution specified for video transcoding of the source URL.', example='[{"videoFormat":"flv","outputStreamUrl":"http://example.aliyundoc.com","transcodeConfig":"original"}]'),
}

model InitializeAutoShowListTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: InitializeAutoShowListTaskResponseBody(name='body'),
}

/**
  * @description You can call this operation to create a scheduled task to start and stop the playback of an episode list at specified points in time. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of InitializeAutoShowListTask  InitializeAutoShowListTaskRequest
  * @return InitializeAutoShowListTaskResponse
 */
async function initializeAutoShowListTask(request: InitializeAutoShowListTaskRequest): InitializeAutoShowListTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InitializeAutoShowListTask', 'POST', '/', 'json', false, 'json', request);
}

model JoinMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='a494caec-***-695ef345db77', position='Body'),
  broadCastStatistics?: boolean(name='BroadCastStatistics', description='Specifies whether to broadcast statistical messages. If you set the value to true, statistical messages of the message group are broadcasted after the users join the message group. The client can receive and process these messages. Valid values:

*   true: broadcasts statistical messages.
*   false: does not broadcast statistical messages.', example='true', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted. This is the default value.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group to join.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  userId: string(name='UserId', description='The ID of the user. Each user has a unique ID in the application. The ID can be up to 32 characters in length and can contain lowercase letters, digits, underscores (_), and periods (.). You can specify multiple user IDs.

This parameter is required.', example='de1**a0', position='Body'),
}

model JoinMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the users successfully joined the message group. Valid values:

*   true: The users successfully joined the message group.
*   false: The users failed to join the message group.', example='true'),
  }(name='Result', description='The returned result.'),
}

model JoinMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: JoinMessageGroupResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 200 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of JoinMessageGroup  JoinMessageGroupRequest
  * @return JoinMessageGroupResponse
 */
async function joinMessageGroup(request: JoinMessageGroupRequest): JoinMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'JoinMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model KickLiveMessageGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application to which the interactive messaging group belongs.

This parameter is required.', example='coims-****', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the interactive messaging group from which you want to remove the user.

This parameter is required.', example='grouptest', position='Query'),
  kickoffUser: string(name='KickoffUser', description='The user that you want to remove.

This parameter is required.', example='uid1', position='Query'),
}

model KickLiveMessageGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='97168878-5288-10CE-AE56-E2D1627FB5F4'),
}

model KickLiveMessageGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: KickLiveMessageGroupUserResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of KickLiveMessageGroupUser  KickLiveMessageGroupUserRequest
  * @return KickLiveMessageGroupUserResponse
 */
async function kickLiveMessageGroupUser(request: KickLiveMessageGroupUserRequest): KickLiveMessageGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'KickLiveMessageGroupUser', 'POST', '/', 'json', false, 'json', request);
}

model LeaveMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastStatistics?: boolean(name='BroadCastStatistics', description='Specifies whether to broadcast statistical messages. If you set the value to true, statistical messages of the message group are broadcasted after the users join the message group. The client can receive and process these messages. Valid values:

*   true: broadcasts statistical messages.
*   false: does not broadcast statistical messages.', example='true', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted. This is the default value.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  userId: string(name='UserId', description='The ID of the user. Each user has a unique ID in the application.

This parameter is required.', example='de1**a0', position='Body'),
}

model LeaveMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the user left the message group. Valid values:

*   true: The user left the message group.
*   false: The user failed to leave the message group.', example='true'),
  }(name='Result', description='The returned result.'),
}

model LeaveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LeaveMessageGroupResponseBody(name='body'),
}

/**
  * @description ##
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of LeaveMessageGroup  LeaveMessageGroupRequest
  * @return LeaveMessageGroupResponse
 */
async function leaveMessageGroup(request: LeaveMessageGroupRequest): LeaveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LeaveMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model ListEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='cluster-1', position='Query'),
  keyword?: string(name='Keyword', description='The keyword of the query.

*   You can specify a task ID for an exact match.
*   You can specify a task name for a fuzzy match.', example='test', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10. Maximum value: 100.', example='20', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortBy?: string(name='SortBy', description='The sort order of the tasks by creation time. Default value: desc. Valid values:

*   desc: descending order
*   asc: ascending order', example='desc', position='Query'),
  status?: int32(name='Status', description='The task status. Valid values:

*   0: not started
*   1: running', example='0', position='Query'),
  type?: string(name='Type', description='The type of edge transcoding. Valid values:

*   common: standard transcoding and Narrowband HD™ 1.0 transcoding.
*   nbhd-2: Narrowband HD™ 2.0 transcoding
*   ultra-hd: ultra-high definition transcoding

>  If you do not specify this parameter, the query results are filtered based on the types of edge transcoding on which you are granted permissions.', example='common', position='Query'),
}

model ListEdgeTranscodeJobResponseBody = {
  jobList?: {
    job?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the task was created.', example='2023-07-24T16:44:55Z'),
      jobId?: string(name='JobId', description='The ID of the task.', example='****20b48fb04483915d4f2cd8ac****'),
      lastStartAt?: string(name='LastStartAt', description='The time when the task was last started.', example='2023-07-25T02:48:58Z'),
      lastStopAt?: string(name='LastStopAt', description='The time when the task was last stopped.', example='2023-07-25T05:48:58Z'),
      name?: string(name='Name', description='The name of the task.', example='my_job'),
      status?: string(name='Status', description='The status of the task. Valid values:

*   0: not started
*   1: in progress', example='0'),
      streamInput?: string(name='StreamInput', description='The URL of the input stream.', example='rtmp://mydomain/app/stream1'),
      streamOutput?: string(name='StreamOutput', description='The URL of the output stream.', example='rtmp://testdomain/app/stream2'),
      templateId?: string(name='TemplateId', description='The ID of the edge transcoding template used by the task.', example='9b1571b513cb44f7a1ba6ae561ff****'),
      templateName?: string(name='TemplateName', description='The name of the edge transcoding template used by the task.', example='my_template'),
      type?: string(name='Type', description='The type of edge transcoding. Valid values:

*   common: standard transcoding and Narrowband HD™ 1.0 transcoding.
*   nbhd-2: Narrowband HD™ 2.0 transcoding
*   ultra-hd: ultra-high definition transcoding', example='common'),
    }
  ](name='Job')
  }(name='JobList', description='The edge transcoding tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='100'),
}

model ListEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query edge transcoding tasks.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * *   You can query only tasks created or modified in the last 180 days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListEdgeTranscodeJob  ListEdgeTranscodeJobRequest
  * @return ListEdgeTranscodeJobResponse
 */
async function listEdgeTranscodeJob(request: ListEdgeTranscodeJobRequest): ListEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model ListEdgeTranscodeTemplateRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  keyword?: string(name='Keyword', description='The keyword of the query.

*   You can specify a template ID for an exact match.
*   You can also specify a template name for a fuzzy match.', example='baseline', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNo?: int32(name='PageNo', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100. Default value: 10.', example='20', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sortBy?: string(name='SortBy', description='The sorting order of the templates by creation time. Default value: desc. Valid values:

*   desc: descending order.
*   asc: ascending order.', example='desc', position='Query'),
  type?: string(name='Type', description='The type of edge transcoding. Valid values:

*   **common**: standard transcoding and Narrowband HD™ 1.0 transcoding.
*   **nbhd-2**: Narrowband HD™ 2.0 transcoding.
*   **ultra-hd**: ultra-high definition transcoding.

>  If you do not specify this parameter, the query result is filtered based on the type of edge transcoding on which you are granted permissions.', example='nbhd-2', position='Query'),
  videoCodec?: string(name='VideoCodec', description='The video encoding format. Valid values:

*   H.264
*   H.265

>  If you do not specify this parameter, the query result is filtered based on the video encoding format on which you are granted permissions.', example='H.264', position='Query'),
}

model ListEdgeTranscodeTemplateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
  templateList?: {
    template?: [ 
    {
      bitrate?: string(name='Bitrate', description='The bitrate. If a numeric value is returned, a fixed bitrate is configured for the output stream. If ws is returned, the output stream maintains the same bitrate as the input stream.', example='3000'),
      codec?: string(name='Codec', description='The video encoding format. Valid values:

*   H.264
*   H.265', example='H.264'),
      createTime?: string(name='CreateTime', description='The time when the image template was created.', example='2023-07-25T02:48:58Z'),
      fps?: string(name='Fps', description='The frame rate. If a numeric value is returned, a fixed frame rate is configured for the output stream. If ws is returned, the output stream maintains the same frame rate as the input stream.', example='30'),
      gop?: string(name='Gop', description='The group of pictures (GOP) size. The GOP size can be defined by the number of frames or the time interval between I-frames. If ws is returned, the output stream maintains the same GOP size as the input stream.', example='2s'),
      name?: string(name='Name', description='The template name.', example='my_template'),
      resolution?: string(name='Resolution', description='The resolution. If width and height values are returned, a fixed resolution is configured for the output stream. If ws is returned, the output stream maintains the same resolution as the input stream.

>  If the width value is -1, the width of the output video is adapted to a fixed height. If the height value is -2, the height of the output video is adapted to a fixed width.', example='1920*1080'),
      templateId?: string(name='TemplateId', description='The ID of the edge transcoding template.', example='9b1571b513cb44f7a1ba6ae561ff46f7'),
      type?: string(name='Type', description='The type of edge transcoding.', example='common'),
    }
  ](name='Template')
  }(name='TemplateList', description='The details of the edge transcoding templates.'),
  totalCount?: int32(name='TotalCount', description='The total number of templates returned.', example='100'),
}

model ListEdgeTranscodeTemplateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEdgeTranscodeTemplateResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query the list of edge transcoding templates.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListEdgeTranscodeTemplate  ListEdgeTranscodeTemplateRequest
  * @return ListEdgeTranscodeTemplateResponse
 */
async function listEdgeTranscodeTemplate(request: ListEdgeTranscodeTemplateRequest): ListEdgeTranscodeTemplateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEdgeTranscodeTemplate', 'POST', '/', 'json', false, 'json', request);
}

model ListEventSubRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='9qb1****', position='Query'),
}

model ListEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='AE050E24-BE9B-1E79-BB30-7EA0BBAE7F08'),
  subscribers?: [ 
    {
      callbackUrl?: string(name='CallbackUrl', description='The callback URL.', example='http://****.com/callback'),
      channelId?: string(name='ChannelId', description='The ID of the channel to which you subscribe.', example='testmodify'),
      createTime?: string(name='CreateTime', description='The time when the subscription was created. The time is displayed in UTC+8. Format: yyyy-MM-dd hh:mm:ss.', example='2023-08-18 10:14:49'),
      events?: [ string ](name='Events', description='The type of the event. Valid values:

*   ChannelEvent: channel event. For example, the channel is opened or closed.
*   UserEvent: user event. For example, a user joins or leaves the channel.'),
      modifyTime?: string(name='ModifyTime', description='The time when the subscription was modified. The time is displayed in UTC+8. Format: yyyy-MM-dd hh:mm:ss.', example='2023-08-18 10:14:49'),
      roles?: int32(name='Roles', description='The role of the user whose events are returned. Valid values:

*   1: streamer
*   2: viewer

An empty value or a value other than 1 and 2 indicates that events of all users in the channel are returned.

>  This parameter is deprecated. When you create a subscription, this parameter is no longer supported.', example='1', deprecated='true'),
      subId?: string(name='SubId', description='The ID of the event.', example='09be0d2254cb5a89f4cbd86403ec****'),
      users?: [ string ](name='Users', description='The user whose events are returned. We recommend that you use either this parameter or Roles.'),
    }
  ](name='Subscribers', description='The events.'),
}

model ListEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventSubResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListEventSub  ListEventSubRequest
  * @return ListEventSubResponse
 */
async function listEventSub(request: ListEventSubRequest): ListEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEventSub', 'GET', '/', 'json', false, 'json', request);
}

model ListEventSubEventRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='9qb1****', position='Query'),
  endTime: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1698201013', minimum=0, maximum=2234313863, position='Query'),
  pageNo: long(name='PageNo', description='The page number.

This parameter is required.', example='20', minimum=1, maximum=9999999999, position='Query'),
  pageSize: long(name='PageSize', description='The number of callback records to return on each page. Valid values: 1 to 100.

This parameter is required.', example='10', minimum=10, maximum=100, position='Query'),
  startTime: long(name='StartTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds.

This parameter is required.', example='1698195600', minimum=0, maximum=2234313863, position='Query'),
  subscribeId?: string(name='SubscribeId', description='The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.', example='ad53276431c****', position='Query'),
}

model ListEventSubEventResponseBody = {
  count?: long(name='Count', description='The total number of callback records returned on the current page.', example='1'),
  hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by a page.', example='false'),
  logs?: [ 
    {
      appId?: string(name='AppId', description='The application ID.', example='9qb1****'),
      code?: int32(name='Code', description='The HTTP status code. A value of 200 indicates that the callback was successful.', example='200'),
      cost?: int32(name='Cost', description='The callback duration. Unit: milliseconds.', example='22'),
      data?: string(name='Data', description='The details about the callback.', example='{\\"MsgId\\":\\"875d5266cbabb1834cc84a105cf68454\\",\\"MsgTimestamp\\":1697545591,\\"SubscribeId\\":\\"09be0d2254cb5a89f4cbd86403ec5343\\",\\"AppId\\":\\"xxx\\",\\"ChannelId\\":\\"9099\\",\\"Contents\\":[{\\"Event\\":\\"UserEvent\\",\\"UserEvent\\":{\\"UserId\\":\\"linux_test\\",\\"EventTag\\":\\"Leave\\",\\"SessionId\\":\\"je7y2sBZJZQ0VBJZrh4LnBkxvGH2WyVs\\",\\"Timestamp\\":1697545591,\\"ChannelProfile\\":\\"interactive_live\\",\\"US\\":5068748604047364,\\"Reason\\":1,\\"Role\\":1,\\"TerminalType\\":6,\\"UserType\\":2}}]}'),
      messageId?: string(name='MessageId', description='The ID of the callback record.', example='875d5266cbabb1834cc84a105cf6****'),
      subId?: string(name='SubId', description='The subscription ID.', example='ad53276431c****'),
      time?: string(name='Time', description='The time when the callback was generated.', example='2023-10-17 20:26:31.988'),
      url?: string(name='Url', description='The callback URL.', example='http://****.com/callback'),
    }
  ](name='Logs', description='The callback records.'),
  requestId?: string(name='RequestId', description='The request ID.', example='CC8CB656-A7BA-1811-9D6B-4CC187E988BD'),
}

model ListEventSubEventResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListEventSubEventResponseBody(name='body'),
}

/**
  * @description *   The maximum time range to query is seven days.
  * *   The minimum time granularity to query is 1 minute.
  * *   You can query data in the last seven days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListEventSubEvent  ListEventSubEventRequest
  * @return ListEventSubEventResponse
 */
async function listEventSubEvent(request: ListEventSubEventRequest): ListEventSubEventResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListEventSubEvent', 'GET', '/', 'json', false, 'json', request);
}

model ListLiveDelayConfigRequest {
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNum?: int32(name='PageNum', description='The page number. Default value: 1.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values: 5 to 30. Default value: 10.', example='10', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListLiveDelayConfigResponseBody = {
  delayConfigList?: {
    delayConfig?: [ 
    {
      app?: string(name='App', description='The name of the application to which the live stream belongs.', example='liveApp****'),
      delayTime?: string(name='DelayTime', description='The duration for which the playback of the live stream is delayed. Unit: seconds.', example='60'),
      domain?: string(name='Domain', description='The main streaming domain.', example='example.com'),
      stream?: string(name='Stream', description='The name of the live stream.', example='liveStream****'),
      taskTriggerMode?: string(name='TaskTriggerMode', description='The trigger mode. Valid values:

*   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
*   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
*   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.', example='PUBLISH_ONLY'),
    }
  ](name='DelayConfig')
  }(name='DelayConfigList', description='The stream delay configurations.'),
  requestId?: string(name='RequestId', description='The request ID.', example='A3136B58-5876-4168-83CA-B562781981A0'),
  total?: int32(name='Total', description='The number of stream delay configurations.', example='1'),
}

model ListLiveDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveDelayConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveDelayConfig  ListLiveDelayConfigRequest
  * @return ListLiveDelayConfigResponse
 */
async function listLiveDelayConfig(request: ListLiveDelayConfigRequest): ListLiveDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveMessageAppsRequest {
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the query. If you leave this parameter empty or set this parameter to -1, the query starts from the first page.', example='-1', position='Query'),
  sortType: int32(name='SortType', description='The sort order based on the creation time. Valid values:

*   1: ascending order
*   2: descending order

This parameter is required.', example='1', minimum=1, maximum=2, position='Query'),
}

model ListLiveMessageAppsResponseBody = {
  appList?: [ 
    {
      appId?: string(name='AppId', description='The ID of the interactive messaging application queried.', example='demo'),
      appKey?: string(name='AppKey', description='The AppKey of the interactive messaging application. It is used to authorize operations related to the application ID.', example='**********************************'),
      appName?: string(name='AppName', description='The name of the application.', example='testApp'),
      appSign?: string(name='AppSign', description='The signature of the interactive messaging application. It is required by the interactive messaging SDK.', example='**************************************************************************'),
      createTime?: long(name='CreateTime', description='The time when the application was created. The value is a UNIX timestamp. Unit: seconds.', example='1698305471'),
      dataCenter?: string(name='DataCenter', description='The live center.', example='cn-shanghai'),
      disable?: string(name='Disable', description='Indicates whether the interactive messaging application is disabled.', example='false'),
      modifyTime?: long(name='ModifyTime', description='The time when the application was last modified. The value is a UNIX timestamp. Unit: seconds.', example='1698305471'),
      msgLifeCycle?: int32(name='MsgLifeCycle', description='The retention period of group messages in the application. Valid values:

*   0 (default): 30 days
*   1: 90 days
*   2: 180 days', example='1'),
    }
  ](name='AppList', description='The interactive messaging applications.'),
  hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by a page.', example='true'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the next query. This parameter is returned only if the value of HasMore is true.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B8EB4994-1368-1458-B9F3-5B88D76D734C'),
}

model ListLiveMessageAppsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveMessageAppsResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveMessageApps  ListLiveMessageAppsRequest
  * @return ListLiveMessageAppsResponse
 */
async function listLiveMessageApps(request: ListLiveMessageAppsRequest): ListLiveMessageAppsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveMessageApps', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveMessageGroupByPageRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupStatus?: int32(name='GroupStatus', description='The status of the groups to query. Default value: 0. Valid values:

*   0: all groups
*   1: existing groups
*   2: deleted groups', example='1', position='Query'),
  pageNumber?: int32(name='PageNumber', description='The page number. Valid values: [1,10000].

Default value: 1.', example='1', minimum=1, maximum=10000, position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Valid values:[1,50].

Default value: 20.', example='20', maximum=50, position='Query'),
  sortType: int32(name='SortType', description='The sort order based on the time when the groups were created. Valid values:

*   1: ascending order
*   2: descending order

This parameter is required.', example='1', minimum=1, maximum=2, position='Query'),
}

model ListLiveMessageGroupByPageResponseBody = {
  groupList?: [ 
    {
      adminList?: [ string ](name='AdminList', description='The list of administrators.'),
      createtime?: long(name='Createtime', description='The time when the group was created. The value is a UNIX timestamp. Unit: seconds.', example='1698299727'),
      creatorId?: string(name='CreatorId', description='The ID of the user who created the group.', example='user_77'),
      delete?: boolean(name='Delete', description='Indicates whether the group is deleted.', example='true'),
      groupId?: string(name='GroupId', description='The ID of the interactive messaging group.', example='cU9MeBqf****'),
      groupInfo?: string(name='GroupInfo', description='The additional information about the group.', example='testgroupinfo'),
      groupName?: string(name='GroupName', description='The name of the group.', example='mytestgroup'),
    }
  ](name='GroupList', description='The list of groups.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page.', example='20'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B5D95365-5A46-1A6A-BBF5-C7B6BDED****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='50'),
}

model ListLiveMessageGroupByPageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveMessageGroupByPageResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveMessageGroupByPage  ListLiveMessageGroupByPageRequest
  * @return ListLiveMessageGroupByPageResponse
 */
async function listLiveMessageGroupByPage(request: ListLiveMessageGroupByPageRequest): ListLiveMessageGroupByPageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveMessageGroupByPage', 'GET', '/', 'json', false, 'json', request);
}

model ListLiveMessageGroupMessagesRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application to query.

This parameter is required.', example='demo', position='Query'),
  beginTime?: long(name='BeginTime', description='The beginning of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter empty, the earliest available time is used.', example='1697783235', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  endTime?: long(name='EndTime', description='The end of the time range to query. The value is a UNIX timestamp. Unit: seconds. If you leave this parameter empty, the latest available time is used.', example='1698301635', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group to query.

This parameter is required.', example='grouptest', position='Query'),
  msgType?: long(name='MsgType', description='The type of messages that you want to query. If you leave this parameter empty, all types of messages are queried.', example='1', position='Query'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the query. If you leave this parameter empty, the query starts from the first page.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries per page. Valid values: **10 to 50**.

This parameter is required.', example='10', minimum=10, maximum=50, position='Query'),
  sortType: int32(name='SortType', description='The sort order based on the time when the messages were sent. Valid values:

*   1: ascending order
*   2: descending order

This parameter is required.', example='1', minimum=1, maximum=2, position='Query'),
}

model ListLiveMessageGroupMessagesResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the group queried.', example='grouptest'),
  hasmore?: boolean(name='Hasmore', description='Indicates whether the current page is followed by another page.', example='false'),
  messageList?: [ 
    {
      body?: string(name='Body', description='The message body.', example='step2 helo, cc group'),
      msgTid?: string(name='MsgTid', description='The ID of the message.', example='c-1-1-0'),
      msgType?: long(name='MsgType', description='The type of the message.', example='2'),
      sender?: {
        userId?: string(name='UserId', description='The ID of the user who sent the message.', example='uid2'),
        userInfo?: string(name='UserInfo', description='The additional information about the user who sent the message.', example='testusermeta2'),
      }(name='Sender', description='The details about the user who sent the message.'),
      seqNumber?: long(name='SeqNumber', description='The sequence number of the message.', example='1'),
      timestamp?: long(name='Timestamp', description='The time when the message was sent. The value is a UNIX timestamp. Unit: seconds.', example='1697081134'),
      totalMessages?: long(name='TotalMessages', description='The total number of messages.', example='1'),
    }
  ](name='MessageList', description='Details about the messages.'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the next query. A value of 0 indicates that no further pages can be queried.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='1668FDC3-63D7-102F-B5D4-3D2F91D1****'),
}

model ListLiveMessageGroupMessagesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveMessageGroupMessagesResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveMessageGroupMessages  ListLiveMessageGroupMessagesRequest
  * @return ListLiveMessageGroupMessagesResponse
 */
async function listLiveMessageGroupMessages(request: ListLiveMessageGroupMessagesRequest): ListLiveMessageGroupMessagesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveMessageGroupMessages', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveMessageGroupUsersRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application to query.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group to query.

This parameter is required.', example='grouptest', position='Query'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the query. If you leave this parameter empty, the query starts from the first page.', example='1', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries per page. Valid values: **10 to 50**.

This parameter is required.', example='10', minimum=10, maximum=30, position='Query'),
  sortType: int32(name='SortType', description='The sort order based on the time when the users joined the group. Valid values:

*   1: ascending order
*   2: descending order

This parameter is required.', example='1', minimum=1, maximum=2, position='Query'),
}

model ListLiveMessageGroupUsersResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the group queried.', example='grouptest'),
  hasmore?: boolean(name='Hasmore', description='Indicates whether the current page is followed by another page.', example='false'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the next query. A value of 0 indicates that no further pages can be queried.', example='0'),
  requestId?: string(name='RequestId', description='The request ID.', example='A1D75BEA-1329-116F-B29C-76F3F200****'),
  userList?: [ 
    {
      userId?: string(name='UserId', description='The ID of the user.', example='uid1'),
      userInfo?: string(name='UserInfo', description='The additional information about the user.', example='info1'),
    }
  ](name='UserList', description='Details about the users.'),
}

model ListLiveMessageGroupUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveMessageGroupUsersResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * *   For a super group, which has more than 2,000 users, the user list cannot be queried. In addition, the notifications about users entering or leaving the group are sent at an interval of at least of 5 seconds. These notifications display the accurate number of users in the group for the time being, but do not display the list of all users entering or leaving the group. Once a group is upgraded to a super group, the user list of the group is immediately cleared. The super group cannot be restored to a normal group until all users in the group leave the group (that is, the group is closed). After you reopen the group, it is restored to a normal group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveMessageGroupUsers  ListLiveMessageGroupUsersRequest
  * @return ListLiveMessageGroupUsersResponse
 */
async function listLiveMessageGroupUsers(request: ListLiveMessageGroupUsersRequest): ListLiveMessageGroupUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveMessageGroupUsers', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveMessageGroupsRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupStatus?: int32(name='GroupStatus', description='The status of the groups to query. Default value: 0. Valid values:

*   0: all groups
*   1: existing groups
*   2: deleted groups', example='1', position='Query'),
  nextPageToken?: long(name='NextPageToken', description='The starting page number for the query. If you leave this parameter empty, the query starts from the first page.', example='1001', position='Query'),
  sortType: int32(name='SortType', description='The sort order based on the time when the groups were created. Valid values:

*   1: ascending order
*   2: descending order

This parameter is required.', example='1', minimum=1, maximum=2, position='Query'),
}

model ListLiveMessageGroupsResponseBody = {
  groupList?: [ 
    {
      adminList?: [ string ](name='AdminList', description='The list of the IDs of the group administrators.'),
      createtime?: long(name='Createtime', description='The time when the group was created. The value is a UNIX timestamp. Unit: seconds.', example='1698299727'),
      creatorId?: string(name='CreatorId', description='The ID of the group creator.', example='user_77'),
      delete?: boolean(name='Delete', description='Indicates whether the group is deleted.', example='true'),
      groupId?: string(name='GroupId', description='The ID of the group.', example='cU9MeBqf****'),
      groupInfo?: string(name='GroupInfo', description='The additional information about the group.', example='testgroupinfo'),
      groupName?: string(name='GroupName', description='The name of the group.', example='mytestgroup'),
    }
  ](name='GroupList', description='Details about the groups.'),
  hasmore?: boolean(name='Hasmore', description='Indicates whether the current page is followed by another page.', example='false'),
  nextpageToken?: string(name='NextpageToken', description='The starting page number for the next query. This parameter is returned only if the value of Hasmore is true.', example='1001'),
  requestId?: string(name='RequestId', description='The request ID.', example='B5D95365-5A46-1A6A-BBF5-C7B6BDED****'),
}

model ListLiveMessageGroupsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveMessageGroupsResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveMessageGroups  ListLiveMessageGroupsRequest
  * @return ListLiveMessageGroupsResponse
 */
async function listLiveMessageGroups(request: ListLiveMessageGroupsRequest): ListLiveMessageGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveMessageGroups', 'POST', '/', 'json', false, 'json', request);
}

model ListLiveRealtimeLogDeliveryRequest {
  liveOpenapiReserve?: string(name='LiveOpenapiReserve', description='This parameter has no practical significance.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListLiveRealtimeLogDeliveryResponseBody = {
  content?: {
    realtimeLogDeliveryInfo?: [ 
    {
      dmId?: int32(name='DmId', description='The ID of the domain name.', example='1001010'),
      domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
      logstore?: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.', example='logstore_example'),
      project?: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.', example='project_example'),
      region?: string(name='Region', description='The ID of the region where the Log Service project is deployed.', example='cn-hangzhou'),
      status?: string(name='Status', description='The status of real-time log delivery. Valid values:

*   **online**: enabled
*   **offline**: disabled', example='online'),
    }
  ](name='RealtimeLogDeliveryInfo')
  }(name='Content', description='The configurations of real-time log delivery.'),
  requestId?: string(name='RequestId', description='The request ID.', example='30559C03-86C9-4EEC-B840-0DC5F5A2189B'),
}

model ListLiveRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description You can call this operation to query all configurations of real-time log delivery under an account. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveRealtimeLogDelivery  ListLiveRealtimeLogDeliveryRequest
  * @return ListLiveRealtimeLogDeliveryResponse
 */
async function listLiveRealtimeLogDelivery(request: ListLiveRealtimeLogDeliveryRequest): ListLiveRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model ListLiveRealtimeLogDeliveryDomainsRequest {
  logstore: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.

This parameter is required.', example='logstore_example', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.

This parameter is required.', example='project_example', position='Query'),
  region: string(name='Region', description='The ID of the region where the Log Service project is deployed.

This parameter is required.', example='cn-hangzhou', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListLiveRealtimeLogDeliveryDomainsResponseBody = {
  content?: {
    domains?: [ 
    {
      domainName?: string(name='DomainName', description='The streaming domain.', example='example.com'),
      status?: string(name='Status', description='The status of real-time log delivery. Valid values:

*   **online**: enabled
*   **offline**: disabled', example='online'),
    }
  ](name='Domains')
  }(name='Content', description='The domain names.'),
  requestId?: string(name='RequestId', description='The request ID.', example='95D5B69F-8AEC-419B-8F3A-612B35032B0D'),
}

model ListLiveRealtimeLogDeliveryDomainsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveRealtimeLogDeliveryDomainsResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to query all domain names that are associated with a specific configuration of real-time log delivery. The returned results indicate whether real-time log delivery is enabled or disabled for the domain names.
  * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) to query the Project, Logstore, and Region parameters.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveRealtimeLogDeliveryDomains  ListLiveRealtimeLogDeliveryDomainsRequest
  * @return ListLiveRealtimeLogDeliveryDomainsResponse
 */
async function listLiveRealtimeLogDeliveryDomains(request: ListLiveRealtimeLogDeliveryDomainsRequest): ListLiveRealtimeLogDeliveryDomainsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveRealtimeLogDeliveryDomains', 'GET', '/', 'json', false, 'json', request);
}

model ListLiveRealtimeLogDeliveryInfosRequest {
  liveOpenapiReserve?: string(name='LiveOpenapiReserve', description='This parameter has no practical significance.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListLiveRealtimeLogDeliveryInfosResponseBody = {
  content?: {
    realtimeLogDeliveryInfos?: [ 
    {
      logstore?: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.', example='logstore_example'),
      project?: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.', example='project_example'),
      region?: string(name='Region', description='The ID of the region where the Log Service project is deployed.', example='cn-hangzhou'),
    }
  ](name='RealtimeLogDeliveryInfos')
  }(name='Content', description='Details about the configuration of real-time log delivery.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='95D5B69F-8AEC-419B-8F3A-612B35032B0D'),
}

model ListLiveRealtimeLogDeliveryInfosResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListLiveRealtimeLogDeliveryInfosResponseBody(name='body'),
}

/**
  * @description You can call this operation to query all configurations of real-time log delivery. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListLiveRealtimeLogDeliveryInfos  ListLiveRealtimeLogDeliveryInfosRequest
  * @return ListLiveRealtimeLogDeliveryInfosResponse
 */
async function listLiveRealtimeLogDeliveryInfos(request: ListLiveRealtimeLogDeliveryInfosRequest): ListLiveRealtimeLogDeliveryInfosResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListLiveRealtimeLogDeliveryInfos', 'GET', '/', 'json', false, 'json', request);
}

model ListMessageRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  pageNum: int32(name='PageNum', description='The number of the page to return. Default value: 1. Valid values: 1 to 100000.

This parameter is required.', example='10', position='Body'),
  pageSize: int32(name='PageSize', description='The number of entries to return on each page. Default value: 20. Valid values: 1 to 50.

This parameter is required.', example='20', position='Body'),
  sortType?: int32(name='SortType', description='The sort order. Valid values:

*   0: ascending order by time
*   1: descending order by time', example='1', position='Body'),
  type?: int32(name='Type', description='The type of the custom message. Valid values: integers greater than 10000.', example='10002', position='Body'),
}

model ListMessageResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true: The current page is followed by another page.
*   false: The current page is not followed by another page.', example='false'),
    messageList?: [ 
      {
        data?: string(name='Data', description='The message body. The value is a JSON string.', example='test'),
        groupId?: string(name='GroupId', description='The ID of the message group.', example='AE35-****-T95F'),
        messageId?: string(name='MessageId', description='The ID of the message.', example='qt***'),
        senderId?: string(name='SenderId', description='The ID of the user who sent the message.', example='yi***'),
        type?: int32(name='Type', description='The type of the message.', example='10002'),
      }
    ](name='MessageList', description='Details about the messages.'),
  }(name='Result', description='The returned result.'),
}

model ListMessageResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMessageResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMessage  ListMessageRequest
  * @return ListMessageResponse
 */
async function listMessage(request: ListMessageRequest): ListMessageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMessage', 'POST', '/', 'json', true, 'form', request);
}

model ListMessageAppRequest {
  pageNum: int32(name='PageNum', description='The number of the page to return. Default value: 1. Valid values: 1 to 100000.

This parameter is required.', example='10', position='Body'),
  pageSize: int32(name='PageSize', description='The number of applications to return on each page. Default value: 20. Valid values: 1 to 50.

This parameter is required.', example='20', position='Body'),
  sortType?: int32(name='SortType', description='The sort order. Valid values:

*   0: ascending order by time
*   1: descending order by time', example='1', position='Body'),
}

model ListMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    appList?: [ 
      {
        appConfig?: map[string]string(name='AppConfig', description='The configurations of the application.'),
        appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***'),
        appName?: string(name='AppName', description='The name of the interactive messaging application.', example='test'),
        createTime?: long(name='CreateTime', description='The time when the interactive messaging application was created. The time is displayed in UTC.', example='502280113'),
        extension?: map[string]string(name='Extension', description='The extended field.'),
        status?: int32(name='Status', description='The status of the interactive message application. A value of **1** indicates that the application is normal.', example='1'),
      }
    ](name='AppList', description='Details about the applications.'),
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true: The current page is followed by another page.
*   false: The current page is not followed by another page.', example='false'),
    total?: int32(name='Total', description='The total number of interactive message applications.', example='15'),
  }(name='Result', description='The returned result.'),
}

model ListMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMessageApp  ListMessageAppRequest
  * @return ListMessageAppResponse
 */
async function listMessageApp(request: ListMessageAppRequest): ListMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model ListMessageGroupRequest {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***', position='Body'),
  pageNum: int32(name='PageNum', description='The number of the page to return. Default value: 1. Valid values: 1 to 100000.

This parameter is required.', example='10', position='Body'),
  pageSize: int32(name='PageSize', description='The number of message groups to return on each page. Default value: 20.

Valid values: 1 to 50.

This parameter is required.', example='20', position='Body'),
  sortType?: int32(name='SortType', description='The sort order. Valid values:

*   0: ascending order by time
*   1: descending order by time', example='1', position='Body'),
  userId?: string(name='UserId', description='The ID of the user. Each user has a unique ID in the application. You can specify multiple user IDs.', example='de1**a0', position='Body'),
}

model ListMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    groupList?: [ 
      {
        appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***'),
        createTime?: long(name='CreateTime', description='The time when the message group was created. The time is displayed in UTC.', example='1502280113'),
        creatorId?: string(name='CreatorId', description='The ID of the creator.', example='as****hs'),
        extension?: map[string]string(name='Extension', description='The extended field.'),
        groupId?: string(name='GroupId', description='The ID of the message group.', example='AE35-****-T95F'),
        status?: int32(name='Status', description='The status of the message group. The default value is **1**, which indicates that the status of the message group is normal.', example='1'),
      }
    ](name='GroupList', description='The list of message groups.'),
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true: The current page is followed by another page.
*   false: The current page is not followed by another page.', example='false'),
    total?: int32(name='Total', description='The total number of message groups.', example='5'),
  }(name='Result', description='The returned result.'),
}

model ListMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMessageGroupResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMessageGroup  ListMessageGroupRequest
  * @return ListMessageGroupResponse
 */
async function listMessageGroup(request: ListMessageGroupRequest): ListMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model ListMessageGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: 1.

Valid values: 1 to 100000.', example='10', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of members to return on each page. Default value: 20.

Valid values: 1 to 50.', example='20', position='Body'),
  sortType?: int32(name='SortType', description='The sort order. Valid values:

*   0: ascending order by time
*   1: descending order by time', example='1', position='Body'),
}

model ListMessageGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true: The current page is followed by another page.
*   false: The current page is not followed by another page.', example='false'),
    total?: int32(name='Total', description='The total number of users in the message group.', example='2'),
    userList?: [ 
      {
        joinTime?: long(name='JoinTime', description='The time when the user joined the message group. The value is a UTC timestamp.', example='12**45'),
        userId?: string(name='UserId', description='The ID of the user.', example='de1**a0,hu**9'),
      }
    ](name='UserList', description='Details about the users.'),
  }(name='Result', description='The returned result.'),
}

model ListMessageGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMessageGroupUserResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMessageGroupUser  ListMessageGroupUserRequest
  * @return ListMessageGroupUserResponse
 */
async function listMessageGroupUser(request: ListMessageGroupUserRequest): ListMessageGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMessageGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model ListMessageGroupUserByIdRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  userIdList: [ string ](name='UserIdList', description='The list of users.

This parameter is required.', shrink='simple', position='Body'),
}

model ListMessageGroupUserByIdResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true
*   false', example='false'),
    total?: int32(name='Total', description='The total number of users returned.', example='3'),
    userList?: [ 
      {
        isMute?: boolean(name='IsMute', description='Indicates whether the user is muted. Valid values:

*   true: The user is muted.
*   false: The user is not muted.', example='true'),
        muteBy?: [ string ](name='MuteBy', description='The type of the mute. Valid values:

*   group: All members in the message group are muted.
*   user: Specific members in the message group are muted.'),
        userAvatar?: string(name='UserAvatar', description='The URL of the profile picture of the user.', example='"http://www.aliyundoc.com/xxyy.png"'),
        userExtension?: string(name='UserExtension', description='The custom information about the user.', example='12e'),
        userId?: string(name='UserId', description='The ID of the user.', example='ad***'),
        userNick?: string(name='UserNick', description='The nickname of the user.', example='xxyy'),
      }
    ](name='UserList', description='The list of users.'),
  }(name='Result', description='The returned results.'),
}

model ListMessageGroupUserByIdResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMessageGroupUserByIdResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMessageGroupUserById  ListMessageGroupUserByIdRequest
  * @return ListMessageGroupUserByIdResponse
 */
async function listMessageGroupUserById(request: ListMessageGroupUserByIdRequest): ListMessageGroupUserByIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMessageGroupUserById', 'POST', '/', 'json', true, 'form', request);
}

model ListMuteGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  groupId: string(name='GroupId', description='The ID of the messaging group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId?: string(name='OperatorUserId', description='The ID of the user who performs the operation.', example='de1**a0', position='Body'),
  pageNum: int32(name='PageNum', description='The page number. Default value: 1. Valid values: 1 to 100000.

This parameter is required.', example='10', position='Body'),
  pageSize: int32(name='PageSize', description='The number of entries per page. Default value: 20. Valid values: 1 to 50.

This parameter is required.', example='20', position='Body'),
}

model ListMuteGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true
*   false', example='false'),
    total?: int32(name='Total', description='The total number of muted members.', example='2'),
    userList?: [ 
      {
        userId?: string(name='UserId', description='The ID of the muted user.', example='1sd***,yu***'),
      }
    ](name='UserList', description='The list of muted users.'),
  }(name='Result', description='The returned result.'),
}

model ListMuteGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListMuteGroupUserResponseBody(name='body'),
}

/**
  * @description ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ListMuteGroupUser  ListMuteGroupUserRequest
  * @return ListMuteGroupUserResponse
 */
async function listMuteGroupUser(request: ListMuteGroupUserRequest): ListMuteGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListMuteGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model ListPlaylistRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  page?: int32(name='Page', description='The page number.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='20', position='Query'),
  programId?: string(name='ProgramId', description='The ID of the episode list. If you set this parameter, only the information about the specified episode lists is returned. If you do not set this parameter, the information about all episode lists that belong to the account is returned. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListPlaylistResponseBody = {
  programList?: [ 
    {
      casterId?: string(name='CasterId', description='The ID of the production studio to which the episode list belongs. You can use the ID as a request parameter in the API operation that is used to add a layout to the virtual studio, delete a layout in the virtual studio, modify a layout of the virtual studio, or query layouts of the virtual studio.', example='casdfasdfasfdasdflkasjdflaj****'),
      domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
      programId?: string(name='ProgramId', description='The ID of the episode list.', example='c09f3d63-eacf-4fbf-bd48-a07a6ba7****'),
      programName?: string(name='ProgramName', description='The name of the episode list.', example='playlist1'),
      repeatNumber?: int32(name='RepeatNumber', description='The number of playbacks after the first playback is complete. Valid values:

*   **0** (default): specifies that the episode list is played only once.
*   **-1**: specifies that the episode list is played in loop mode.
*   Positive integer: specifies the number of times the episode list repeats after the first playback is complete.', example='1'),
      status?: int32(name='Status', description='The status of the episode list. Valid values:

*   **0**: stopped
*   **1**: running', example='1'),
    }
  ](name='ProgramList', description='The episode lists.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
  total?: int32(name='Total', description='The total number of episode lists returned.', example='1'),
}

model ListPlaylistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPlaylistResponseBody(name='body'),
}

/**
  * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episode lists and then call this operation to query the episode lists.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListPlaylist  ListPlaylistRequest
  * @return ListPlaylistResponse
 */
async function listPlaylist(request: ListPlaylistRequest): ListPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPlaylist', 'POST', '/', 'json', false, 'json', request);
}

model ListPlaylistItemsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  programItemIds?: string(name='ProgramItemIds', description='The IDs of the episodes that you want to query. Separate episode IDs with commas (,). If you set this parameter, only the information about the specified episodes is returned. If you do not set this parameter, the information about all episodes in the episode list is returned.', example='c10f3d63-eacf-4fbf-bd48-a07a6ba7****,c09f3d63-eacf-4fbf-bd48-a07a6ba7****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ListPlaylistItemsResponseBody = {
  programItems?: [ 
    {
      index?: int32(name='Index', description='The sequence number of the episode in the query result.', example='1'),
      programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to edit the episode list, delete the episode list, query the information about the episode list, start the episode list, or stop the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
      programItemId?: string(name='ProgramItemId', description='The ID of the episode.', example='c10f3d63-eacf-4fbf-bd48-a07a6ba7****'),
      programItemName?: string(name='ProgramItemName', description='The name of the episode.', example='playlistItem1'),
      resourceType?: string(name='ResourceType', description='The resource type.', example='vod'),
      resourceValue?: string(name='ResourceValue', description='The resource ID.', example='asdfasdf8as9df8sa9df89****'),
    }
  ](name='ProgramItems', description='The episodes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9****'),
  total?: int32(name='Total', description='The total number of episodes.', example='1'),
}

model ListPlaylistItemsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListPlaylistItemsResponseBody(name='body'),
}

/**
  * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to query the episodes in the episode list
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListPlaylistItems  ListPlaylistItemsRequest
  * @return ListPlaylistItemsResponse
 */
async function listPlaylistItems(request: ListPlaylistItemsRequest): ListPlaylistItemsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListPlaylistItems', 'POST', '/', 'json', false, 'json', request);
}

model ListRTCLiveRoomsRequest {
  appId: string(name='AppId', description='This parameter is required.', example='a494caec-***-695ef345db77', position='Query'),
  pageNo?: int32(name='PageNo', example='1', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', example='50', minimum=10, maximum=100, position='Query'),
}

model ListRTCLiveRoomsResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request', example='5c6a2a0df228-4a64-af62-20e91b96****'),
  rooms?: [ string ](name='Rooms'),
  total?: int32(name='Total', example='2'),
}

model ListRTCLiveRoomsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRTCLiveRoomsResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ListRTCLiveRooms  ListRTCLiveRoomsRequest
  * @return ListRTCLiveRoomsResponse
 */
async function listRTCLiveRooms(request: ListRTCLiveRoomsRequest): ListRTCLiveRoomsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRTCLiveRooms', 'POST', '/', 'json', false, 'json', request);
}

model ListRtcMPUEventSubRecordRequest {
  appId: string(name='AppId', description='The ID of the application.

>  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  endTime: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is required.', example='1970-01-01T00:00:00Z', position='Query'),
  pageNo: int32(name='PageNo', description='The page number.

This parameter is required.', example='20', position='Query'),
  pageSize: int32(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.

This parameter is required.', example='10', position='Query'),
  startTime: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format.

This parameter is required.', example='1970-01-01T00:00:00Z', position='Query'),
  subId?: string(name='SubId', description='The ID of the subscription.', example='yourSubId', position='Query'),
}

model ListRtcMPUEventSubRecordResponseBody = {
  count?: long(name='Count', description='The number of entries per page.', example='1'),
  hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by a page.', example='false'),
  logs?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='yourAppId'),
      callbackUrl?: string(name='CallbackUrl', description='The callback URL.', example='http://testcallback***.com/callback'),
      cost?: long(name='Cost', description='The callback duration. Unit: milliseconds.', example='22'),
      data?: string(name='Data', description='For more information about the callback, see [CreateRtcMPUEventSub](https://help.aliyun.com/document_detail/2804583.html).', example='{\\"EventType\\":1,\\"MsgId\\":\\"42bba8b5-94ab-468c-9dae-9b501dd6c***\\",\\"AppId\\":\\"rtcdev\\",\\"SubId\\":\\"Sub-9799B2C45009799B2C4***\\",\\"TaskId\\":\\"mpucallbacktest\\",\\"CallbackTs\\":1712656430***,\\"Payload\\":{\\"DstUrl\\":\\"rtmp://domain/app/stream?auth\\",\\"EventTs\\":1712656430***,\\"EventCode\\":1,\\"ErrorCode\\":0,\\"ErrorMessage\\":\\"\\"}}'),
      HTTPCode?: string(name='HTTPCode', description='The HTTP status code. 200 indicates that the callback is successful.', example='200'),
      msgId?: string(name='MsgId', description='The ID of the callback record.', example='42bba8b5-********-9b501dd6cb6e'),
      subId?: string(name='SubId', description='The ID of the subscription.', example='Sub-******9799B2C4500******'),
      time?: string(name='Time', description='The time when the callback was invoked. The time follows the ISO 8601 standard in the YYYY-MM-DDThh:mm:ss format. The time is displayed in UTC.', example='1970-01-01T00:00:00Z'),
    }
  ](name='Logs', description='The callback records.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='******3B-0E1A-586A-AC29-742247******'),
}

model ListRtcMPUEventSubRecordResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRtcMPUEventSubRecordResponseBody(name='body'),
}

/**
  * @description You can call this operation to query the callback records of a subscription to mixed-stream relay events in the last seven days.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListRtcMPUEventSubRecord  ListRtcMPUEventSubRecordRequest
  * @return ListRtcMPUEventSubRecordResponse
 */
async function listRtcMPUEventSubRecord(request: ListRtcMPUEventSubRecordRequest): ListRtcMPUEventSubRecordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRtcMPUEventSubRecord', 'POST', '/', 'json', false, 'json', request);
}

model ListRtcMPUTaskDetailRequest {
  appId: string(name='AppId', description='The ID of the application.

>  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  pageNo?: long(name='PageNo', description='The page number.', example='20', position='Query'),
  pageSize?: long(name='PageSize', description='The number of entries per page. Valid values: 1 to 100.

>  If you do not specify TaskId, you must specify PageSize and PageNo. Then, the parameters of all stream relay tasks for the specified application are returned in pages.', example='10', position='Query'),
  taskId?: string(name='TaskId', description='The task ID.

> 

*   The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

*   If you specify TaskId, the parameters of the specified tasks are returned.', example='yourTaskId', position='Query'),
}

model ListRtcMPUTaskDetailResponseBody = {
  MPUTasks?: [ 
    {
      appId?: string(name='AppId', description='The ID of the application.', example='yourAppId'),
      channelId?: string(name='ChannelId', description='The ID of the channel.', example='yourChannelId'),
      maxIdleTime?: string(name='MaxIdleTime', description='The timeout period of an idle connection. Unit: seconds.

>  If the task is idle for a period of time longer than the duration specified by the MaxIdleTime parameter, the task is automatically stopped. If the parameter is not specified, the task is stopped after the channel is closed.', example='10'),
      mixMode?: string(name='MixMode', description='The stream mixing mode. Valid values:

*   0: relays the original single stream without mixing streams. If the value of this parameter is 0, the TranscodeParams parameter is empty.
*   1 (default): mixes multiple streams into a single stream and relays the mixed stream.', example='0'),
      multiStreamURL?: [ 
        {
          isAliCdn?: boolean(name='IsAliCdn', description='Indicates whether stream relay is performed by using Alibaba Cloud CDN. Valid values:

*   false: Stream relay is performed by using a CDN service that is not Alibaba Cloud CDN.
*   true: Stream relay is performed by using Alibaba Cloud CDN.', example='false'),
          URL?: string(name='URL', description='The ingest URL.', example='rtmp://example.com/live/stream****'),
        }
      ](name='MultiStreamURL', description='The multiple ingest URLs relayed.'),
      region?: string(name='Region', description='The region in which the streams are mixed. Valid values:

*   **CN-shanghai**
*   **AP-Singapore (default)**
*   **EMAA-Saudi**', example='CN-Shanghai'),
      seiParams?: {
        layoutVolume?: {
          followIdr?: string(name='FollowIdr', description='Indicates whether to add SEI messages to Instantaneous Decoder Refresh (IDR) frames. Valid values:

*   0: does not add SEI messages.
*   1: adds SEI messages.', example='0'),
          interval?: string(name='Interval', description='The interval at which the SEI messages are added. Unit: milliseconds.', example='1000'),
        }(name='LayoutVolume', description='The layout and volume SEI. If the return value is an empty string, the default layout and volume SEI is used.'),
        passThrough?: {
          followIdr?: string(name='FollowIdr', description='Indicates whether to add SEI messages to Instantaneous Decoder Refresh (IDR) frames. Valid values:

*   0: does not add SEI messages.
*   1: adds SEI messages.', example='0'),
          interval?: string(name='Interval', description='The interval at which the SEI messages are added. Unit: milliseconds.', example='1000'),
          payloadContent?: string(name='PayloadContent', description='The payload content of the custom SEI.', example='yourPayloadContent'),
          payloadContentKey?: string(name='PayloadContentKey', description='The key of the payload content. Default value: udd.', example='yourPayloadContentKey'),
        }(name='PassThrough', description='The custom SEI.'),
        payloadType?: string(name='PayloadType', description='The custom payload type. Valid values: 100 to 254. Default value: 5.', example='100'),
      }(name='SeiParams', description='The supplemental enhancement information (SEI) parameters.'),
      singleSubParams?: {
        sourceType?: string(name='SourceType', description='The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:

*   camera (default): captures the video by using a camera.
*   shareScreen: captures the content displayed on a screen.', example='camera'),
        streamType?: string(name='StreamType', description='The type of the stream that is relayed. Valid values:

*   0 (default): the original stream.
*   1: the audio-only stream.
*   2: the video-only stream.', example='0'),
        userId?: string(name='UserId', description='The ID of the user whose stream is relayed. In single-stream relay mode, you can relay only one stream in a request.', example='yourSubUserId'),
      }(name='SingleSubParams', description='The parameters of the single-stream relay task.'),
      streamURL?: string(name='StreamURL', description='The ingest URL.', example='rtmp://example.com/live/stream****'),
      taskId?: string(name='TaskId', description='The ID of the stream relay task.', example='yourTaskId'),
      transcodeParams?: {
        background?: {
          renderMode?: string(name='RenderMode', description='The display mode. Valid values:

*   0: proportionally scales the video or background image to fit the pane. Black bars are added to fill the extra space.
*   1 (default): crops the video or background image to fit the pane.', example='1'),
          URL?: string(name='URL', description='The URL of the global background image.', example='yourImageUrl'),
        }(name='Background', description='The global background image.'),
        encodeParams?: {
          audioBitrate?: string(name='AudioBitrate', description='The bitrate of the audio. Unit: Kbit/s.', example='128'),
          audioChannels?: string(name='AudioChannels', description='The number of audio channels. Valid values: 1 and 2.', example='2'),
          audioOnly?: string(name='AudioOnly', description='Indicates whether the output stream is an audio-only stream. Valid values:

*   true
*   false (default)', example='false'),
          audioSampleRate?: string(name='AudioSampleRate', description='The audio sampling rate. Unit: Hz.', example='44100'),
          enhancedParam?: string(name='EnhancedParam', description='The parameter for advanced video encoding. The value is a JSON string. Optional fields:

*   profile: the encoding level. If the video encoding format is set to H.264, the valid values of this field are baseline, main, and high.
*   preset: adjusts the trade-off between encoding speed and video quality. Valid values: ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.', example='{"profile": "high", "preset": "veryfast"}'),
          videoBitrate?: string(name='VideoBitrate', description='The bitrate of the video. Unit: Kbit/s.', example='3500'),
          videoCodec?: string(name='VideoCodec', description='The video encoding format. Default value: H.264.', example='H.264'),
          videoFramerate?: string(name='VideoFramerate', description='The frame rate of the video. Unit: frames per second (FPS).', example='25'),
          videoGop?: string(name='VideoGop', description='The group of pictures (GOP) size of the video.', example='20'),
          videoHeight?: string(name='VideoHeight', description='The height of the video. Unit: pixels.', example='1000'),
          videoWidth?: string(name='VideoWidth', description='The width of the video. Unit: pixels.', example='1920'),
        }(name='EncodeParams', description='The encoding parameters of the output stream.'),
        layout?: {
          userPanes?: [ 
            {
              backgroundImageUrl?: string(name='BackgroundImageUrl', description='The URL of the background image of the pane. This image is displayed if the user turns off the camera or is not present in the channel.', example='yourImageUrl'),
              height?: string(name='Height', description='The height of the pane. The value is normalized.', example='0.2632'),
              renderMode?: string(name='RenderMode', description='The display mode. Valid values:

*   0: proportionally scales the video or background image to fit the pane. Black bars are added to fill the extra space.
*   1 (default): crops the video or background image to fit the pane.', example='1'),
              userInfo?: {
                channelId?: string(name='ChannelId', description='The ID of the channel where the user is.', example='yourChannelId'),
                sourceType?: string(name='SourceType', description='The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:

*   camera (default): captures the video by using a camera.
*   shareScreen: captures the content displayed on a screen.', example='camera'),
                userId?: string(name='UserId', description='The ID of the user.', example='yourSubUserId'),
              }(name='UserInfo', description='The information about the user whose stream is played in the pane.'),
              width?: string(name='Width', description='The width of the pane. The value is normalized.', example='0.3564'),
              x?: string(name='X', description='The x-coordinate of the pane. The value is normalized.', example='0.2456'),
              y?: string(name='Y', description='The y-coordinate of the pane. The value is normalized.', example='0.3789'),
              zOrder?: string(name='ZOrder', description='The layer of the pane. A value of 0 indicates that the pane is placed at the bottom layer. A larger value indicates a higher layer.', example='0'),
            }
          ](name='UserPanes', description='The information about the panes.'),
        }(name='Layout', description='The video layout information.

>  The video layout information includes the x-coordinate, y-coordinate, width, height, and layer of the pane. For audio-only transcoding, no video layout information is returned.'),
        userInfos?: [ 
          {
            channelId?: string(name='ChannelId', description='The ID of the channel where the user is.', example='yourChannelId'),
            sourceType?: string(name='SourceType', description='The source of the video. This parameter is valid only if you set StreamType to 2. Valid values:

*   camera (default): captures the video by using a camera.
*   shareScreen: captures the content displayed on a screen.', example='camera'),
            streamType?: string(name='StreamType', description='The type of the stream that is relayed. Valid values:

*   0 (default): the original stream.
*   1: the audio-only stream.
*   2: the video-only stream.', example='0'),
            userId?: string(name='UserId', description='The ID of the user.', example='yourSubUserId'),
          }
        ](name='UserInfos', description='The information about the user whose stream is mixed. If an empty value is returned, streams from all users are mixed.'),
      }(name='TranscodeParams', description='The mixed-stream relay parameters.'),
    }
  ](name='MPUTasks', description='The parameters that you configured when you called the StartLiveMPUTask operation to create the tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model ListRtcMPUTaskDetailResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ListRtcMPUTaskDetailResponseBody(name='body'),
}

/**
  * @description *   You can call the ListRtcMPUTaskDetail operation to query the parameters of mixed-stream relay tasks that were created by calling the StartLiveMPUTask operation.
  * *   By default, the query results are sorted in reverse chronological order based on the task update time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ListRtcMPUTaskDetail  ListRtcMPUTaskDetailRequest
  * @return ListRtcMPUTaskDetailResponse
 */
async function listRtcMPUTaskDetail(request: ListRtcMPUTaskDetailRequest): ListRtcMPUTaskDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListRtcMPUTaskDetail', 'POST', '/', 'json', false, 'json', request);
}

model LiveUpstreamQosDataRequest {
  cdnDomains?: [ string ](name='CdnDomains', shrink='json', position='Query'),
  cdnIsps?: [ string ](name='CdnIsps', shrink='json', position='Query'),
  cdnProvinces?: [ string ](name='CdnProvinces', shrink='json', position='Query'),
  endTime: string(name='EndTime', description='This parameter is required.', position='Query'),
  kwaiSidcs?: [ string ](name='KwaiSidcs', shrink='json', position='Query'),
  kwaiTsc?: [ int32 ](name='KwaiTsc', shrink='json', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime: string(name='StartTime', description='This parameter is required.', position='Query'),
  upstreamDomains?: [ string ](name='UpstreamDomains', shrink='json', position='Query'),
}

model LiveUpstreamQosDataResponseBody = {
  data?: [ 
    {
      cdnDomain?: string(name='CdnDomain'),
      cdnIsp?: string(name='CdnIsp'),
      cdnOcid?: string(name='CdnOcid'),
      cdnProvince?: string(name='CdnProvince'),
      detailData?: [ 
        {
          connectDur?: long(name='ConnectDur'),
          connectFailedCount?: long(name='ConnectFailedCount'),
          count?: long(name='Count'),
          firstDataDur?: long(name='FirstDataDur'),
          firstDataFailedCount?: long(name='FirstDataFailedCount'),
          firstFrameDur?: long(name='FirstFrameDur'),
          firstFrameSuccessCount?: long(name='FirstFrameSuccessCount'),
          statusCode2Xx?: long(name='StatusCode2Xx'),
          statusCode3Xx?: long(name='StatusCode3Xx'),
          statusCode4Xx?: long(name='StatusCode4Xx'),
          statusCode5Xx?: long(name='StatusCode5Xx'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='DetailData'),
      kwaiSidc?: string(name='KwaiSidc'),
      kwaiTsc?: long(name='KwaiTsc'),
      upstreamDomain?: string(name='UpstreamDomain'),
    }
  ](name='Data'),
  endTime?: string(name='EndTime'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model LiveUpstreamQosDataResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: LiveUpstreamQosDataResponseBody(name='body'),
}

/**
  * @param request  the request parameters of LiveUpstreamQosData  LiveUpstreamQosDataRequest
  * @return LiveUpstreamQosDataResponse
 */
async function liveUpstreamQosData(request: LiveUpstreamQosDataRequest): LiveUpstreamQosDataResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LiveUpstreamQosData', 'POST', '/', 'json', false, 'json', request);
}

model MiguLivePullToPushStartRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  miguData: string(name='MiguData', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model MiguLivePullToPushStartResponseBody = {
  code?: string(name='code'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  timestamp?: string(name='timestamp'),
}

model MiguLivePullToPushStartResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MiguLivePullToPushStartResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MiguLivePullToPushStart  MiguLivePullToPushStartRequest
  * @return MiguLivePullToPushStartResponse
 */
async function miguLivePullToPushStart(request: MiguLivePullToPushStartRequest): MiguLivePullToPushStartResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MiguLivePullToPushStart', 'POST', '/', 'json', false, 'json', request);
}

model MiguLivePullToPushStatusRequest {
  domainName: string(name='DomainName', description='This parameter is required.', position='Query'),
  miguData: string(name='MiguData', description='This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model MiguLivePullToPushStatusResponseBody = {
  code?: string(name='code'),
  data?: {
    message?: string(name='message'),
    status?: string(name='status'),
  }(name='data'),
  message?: string(name='message'),
  requestId?: string(name='requestId'),
  timestamp?: string(name='timestamp'),
}

model MiguLivePullToPushStatusResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MiguLivePullToPushStatusResponseBody(name='body'),
}

/**
  * @param request  the request parameters of MiguLivePullToPushStatus  MiguLivePullToPushStatusRequest
  * @return MiguLivePullToPushStatusResponse
 */
async function miguLivePullToPushStatus(request: MiguLivePullToPushStatusRequest): MiguLivePullToPushStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MiguLivePullToPushStatus', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCasterComponentRequest {
  captionLayerContent?: string(name='CaptionLayerContent', description='The information about the subtitle component. The value must be a JSON string. This parameter contains the following fields:

>  This parameter is required if you set ComponentType to caption.

*   **SizeNormalized**: the normalized value of the font size. The value of this field equals the font size divided by the output height. Valid values: `0 to 1`. The maximum font size is 1,024, even if the font size calculated based on this field is greater than 1,024.
*   **BorderWidthNormalized**: the normalized value of the border width. The value of this field equals the border width divided by the font size. Valid values: `0 to 1`. Default value: 0. The maximum border width is 16, even if the border width calculated based on this field is greater than 16.
*   **FontName**: the font name. Default value: KaiTi. For more information about the valid values, see **Fonts used in a production studio**.
*   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is left empty. In this case, the color of the text border is transparent.
*   **LocationId**: the channel ID of the source subtitles.
*   **SourceLan**: the source language of the subtitles in the video. Valid values: en (English), cn (Chinese), es (Spanish), and ru (Russian). Default value: cn.
*   **TargetLan**: the target language of the subtitles in the video. If you do not specify this field, speech recognition is used. If you specify this field, translation is used. Valid values: en (English), cn (Chinese), es (Spanish), and ru (Russian).
*   **ShowSourceLan**: specifies whether to display the source language. A value of true specifies that the source language is displayed. A value of false specifies that the source language is not displayed. Default value: false.
*   **Truncation**: specifies whether to allow subtitle truncation. A value of true specifies that the subtitles can be truncated. A value of false specifies that the subtitles cannot be truncated. Default value: false.
*   **SourceLanPerLineWordCount**: the number of words displayed in each line of the source language. This field takes effect only if you set Truncation to true. Default value: 20.
*   **TargetLanPerLineWordCount**: the number of words displayed in each line of the target language. This field takes effect only if you set Truncation to true. Default value: 20.', example='{"BorderWidthNormalized":0.01,"SizeNormalized":0.05,"Color":"0x000000","LocationId":"RV01","SourceLan":"cn","FontName":"KaiTi","BorderColor":"0xffffff"}', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  componentId: string(name='ComponentId', description='The ID of the component. If the component was added by calling the [AddCasterComponent](https://help.aliyun.com/document_detail/2848030.html) operation, check the value of the response parameter ComponentId to obtain the ID.

This parameter is required.', example='05ab713c-676e-49c0-96ce-cc408da1****', position='Query'),
  componentLayer?: string(name='ComponentLayer', description='The information about the component layer, such as the size and layout, The value must be a JSON string. This parameter contains the following fields:

*   **HeightNormalized**: the normalized value of the height of the component layer.
*   **WidthNormalized**: the normalized value of the width of the component layer.
*   **PositionNormalized**: the normalized value of the position of the component layer.
*   **PositionRefer**: the reference coordinates of the component layer.', example='{"HeightNormalized":"1","PositionRefer":"topRight","WidthNormalized":"0","PositionNormalized":["0.1","0.2"]}', position='Query'),
  componentName?: string(name='ComponentName', description='The name of the component. By default, the name is the ID of the component.', example='text01', position='Query'),
  componentType?: string(name='ComponentType', description='The type of the component. Valid values:

*   **text**: text component. The TextLayerContent parameter is required if you set ComponentType to text.
*   **image**: image component. The ImageLayerContent parameter is required if you set ComponentType to image.
*   **caption**: subtitle component. The CaptionLayerContent parameter is required if you set ComponentType to caption.', example='text', position='Query'),
  effect?: string(name='Effect', description='The display effect for the component. Valid values:

*   **none** (default)
*   **animateH**: horizontal scrolling
*   **animateV**: vertical scrolling', example='animateV', position='Query'),
  imageLayerContent?: string(name='ImageLayerContent', description='The information about the image component. The value must be a JSON string.

>  This parameter is required if you set ComponentType to image.

The MaterialId field specifies the ID of the material from the media asset library.', example='{"MaterialId":"6cf724c6ebfd4a59b5b3cec6f10d5ecf"}', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  textLayerContent?: string(name='TextLayerContent', description='The information about the text component. The value must be a JSON string. This parameter contains the following fields:

>  This parameter is required if you set ComponentType to text.

*   **SizeNormalized**: the normalized value of the font size. The value of this field equals the font size divided by the output height. Valid values: `0 to 1`. The maximum font size is 1,024, even if the font size calculated based on this field is greater than 1,024.
*   **BorderWidthNormalized**: the normalized value of the border width. The value of this field equals the border width divided by the font size. Valid values: `0 to 1`. Default value: 0. The maximum border width is 16, even if the border width calculated based on this field is greater than 16.
*   **FontName**: the font name. Default value: KaiTi. For more information about the valid values, see **Fonts used in a production studio**.
*   **BorderColor**: the color of the text border. Valid values: 0x000000 to 0xffffff. By default, this parameter is left empty. In this case, the color of the text border is transparent.
*   **Text**: the content of the text. By default, this parameter is left empty. In this case, the text contains no content.
*   **Color**: the color of the text. The default value is 0xff0000, which indicates that the text is in red.', example='{"BorderWidthNormalized":"1","SizeNormalized":"0.2","Color":"0x000000","FontName":"KaiTi","BorderColor":"0x000000","Text":"hello world!"}', position='Query'),
}

model ModifyCasterComponentResponseBody = {
  componentId?: string(name='ComponentId', description='The ID of the component. You can use the ID as a request parameter in the API operation that is called to query components in a production studio.', example='05ab713c-676e-49c0-96ce-cc408da1****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model ModifyCasterComponentResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCasterComponentResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify a text, image, or subtitle component.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyCasterComponent  ModifyCasterComponentRequest
  * @return ModifyCasterComponentResponse
 */
async function modifyCasterComponent(request: ModifyCasterComponentRequest): ModifyCasterComponentResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCasterComponent', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCasterEpisodeRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  componentId?: [ string ](name='ComponentId', description='The components. Components in the production studio are listed from the bottom to the top in an array. When the production studio switches to another video resource, the components are also switched.

*   This parameter takes effect and is required only when the EpisodeType parameter is set to **Component**.
*   This parameter is optional when the EpisodeType parameter is set to **Resource**. In this case, if this parameter is specified, the components are bound to and switched together with video resources.

>  The variable N specifies the sequence number of the component. For example, ComponentId.1 specifies the ID of the first component and ComponentId.2 specifies the ID of the second component.', example='["16A96B9A-F203-4EC5-8E43-CB92E68F****"]', position='Query'),
  endTime?: string(name='EndTime', description='The time when the episode ends. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T10:20:00Z', position='Query'),
  episodeId: string(name='EpisodeId', description='The ID of the episode. It is included in the response when you call the [AddCasterEpisode](~~94745#doc-api-live-AddCasterEpisode~~ "Adds an episode to a production studio.") operation.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf938623****', position='Query'),
  episodeName?: string(name='EpisodeName', description='The name of the episode.', example='episode_name_1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the video resource. It is included in the response when you call the [AddCasterVideoResource](~~60250#doc-api-live-AddCasterVideoResource~~ "Adds a video resource to a production studio.") operation.

*   This parameter takes effect and is required only when the EpisodeType is set to **Resource**.
*   If the EpisodeType parameter is set to **Component**, this parameter is invalid.', example='16A96B9A-F203-4EC5-8E43-CB92E683****', position='Query'),
  startTime?: string(name='StartTime', description='The time when the episode starts. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T09:00:00Z', position='Query'),
  switchType?: string(name='SwitchType', description='The policy for switching episodes. This parameter takes effect only when the EpisodeType parameter is set to **Resource**. Valid values:

*   **TimeFirst**: The episode starts when the preceding episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This parameter must be set to TimeFirst when the video resource is a live stream.
*   **ContentFirst**: The episode starts and ends as scheduled.', example='TimeFirst', position='Query'),
}

model ModifyCasterEpisodeResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can use the ID as a request parameter in the API operation that is used to copy the configurations of a scene, update the configurations of a scene, query the scenes of a production studio, query the audio configurations of a scene, start a scene in the production studio, or stop a scene in the production studio.', example='LIVEPRODUCER_POST-cn-0pp1czt****'),
  episodeId?: string(name='EpisodeId', description='The ID of the episode. You can use the ID as a request parameter in the API operation that is used to delete an episode list from a production studio, add episodes to an episode list, remove episodes from an episode list, query the information about episodes in an episode list, update episodes in an episode list, delete an episode list, query the information about an episode list, start an episode list, or stop an episode list.', example='a2b8e671-2fe5-4642-a2ec-bf938623****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model ModifyCasterEpisodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCasterEpisodeResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify the configurations of an episode in a production studio. You cannot change the episode type.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyCasterEpisode  ModifyCasterEpisodeRequest
  * @return ModifyCasterEpisodeResponse
 */
async function modifyCasterEpisode(request: ModifyCasterEpisodeRequest): ModifyCasterEpisodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCasterEpisode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCasterLayoutRequest {
  audioLayer: [ 
    {
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles. Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.', example='5000'),
      validChannel?: string(name='ValidChannel', description='The sound channels that are used for volume input in the audio layer. Valid values:

*   **leftChannel**: the left channel
*   **rightChannel**: the right channel
*   **all** (default): both the left and right channels', example='all'),
      volumeRate?: float(name='VolumeRate', description='The normalized value of the height of the audio layer. The width of the audio layer is proportionally scaled based on this parameter.

The default value is **0**, which indicates that the audio layer is not scaled.', example='1'),
    }
  ](name='AudioLayer', description='The audio layers.

This parameter is required.', position='Query'),
  blendList: [ string ](name='BlendList', description='The location IDs of the video layers, which are in the same order as the video layers.

For more information, see [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html).

This parameter is required.', example='RV02', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. If the layout was added by calling the [AddCasterLayout](https://help.aliyun.com/document_detail/2848025.html) operation, check the value of the response parameter LayoutId to obtain the ID.

This parameter is required.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****', position='Query'),
  mixList: [ string ](name='MixList', description='The location IDs of the audio layers, which are in the same order as the audio layers.

For more information, see [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html).

This parameter is required.', example='RV02', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  videoLayer: [ 
    {
      fillMode?: string(name='FillMode', description='The scaling mode of the video layer. Valid values:

*   **none** (default): indicates that the video layer is not scaled. The video layer is displayed based on its original size.
*   **fit**: indicates that the video layer is adapted to the fill area. In this case, the video layer is scaled proportionally, with its original aspect ratio retained. The video layer is placed in the center, with its longer sides aligned with the fill area. If the aspect ratio of the video layer is different from that of the fill area, the content of the lower layer is displayed alongside the shorter sides. If there is no lower layer, black bars are displayed instead.', example='fit'),
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the video layer. This parameter is used to synchronize the video with subtitles. Unit: milliseconds. Default value: **0**. Valid values: **0 to 5000**.', example='5000'),
      heightNormalized?: float(name='HeightNormalized', description='The normalized value of the height of the video layer.

*   If the FillMode parameter of the video layer is set to none, the width of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
*   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.', example='1'),
      positionNormalized?: [ float ](name='PositionNormalized', description='The normalized value of the position of the video layer, in the format of `[x,y]`. Default value: `[0,0]`.

>  The values of x and y are normalized.', example='0.3'),
      positionRefer?: string(name='PositionRefer', description='The reference coordinates of the video layer. Valid values:

*   **topLeft** (default): the upper-left corner
*   **topRight**: the upper-right corner
*   **bottomLeft**: the lower-left corner
*   **bottomRight**: the lower-right corner
*   **center**: the center
*   **topCenter**: the upper center
*   **bottomCenter**: the lower center
*   **leftCenter**: the left center
*   **rightCenter**: the right center', example='topLeft'),
      widthNormalized?: float(name='WidthNormalized', description='The normalized value of the width of the video layer.

*   If the FillMode parameter of the video layer is set to none, the height of the video layer is proportionally scaled based on this parameter. The default value is **0**, which indicates that the video layer is not scaled.
*   If the FillMode parameter of the video layer is set to fit, the value of this parameter is greater than **0**.', example='1'),
    }
  ](name='VideoLayer', description='The video layers.

This parameter is required.', position='Query'),
}

model ModifyCasterLayoutResponseBody = {
  layoutId?: string(name='LayoutId', description='The ID of the layout. You can use this ID to query information about the layout.', example='21926b36-7dd2-4fde-ae25-51b5bc8e****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model ModifyCasterLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCasterLayoutResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify a layout of the production studio. This operation supports the default and adaptive scaling modes.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyCasterLayout  ModifyCasterLayoutRequest
  * @return ModifyCasterLayoutResponse
 */
async function modifyCasterLayout(request: ModifyCasterLayoutRequest): ModifyCasterLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCasterLayout', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCasterProgramRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  episode: [ 
    {
      componentId?: [ string ](name='ComponentId', description='The components. Components in the production studio are listed from the bottom to the top in an array. When the production studio switches to another video resource, the components are also switched.

*   This parameter is required and available only when EpisodeType is set to **Component**.
*   This parameter is optional when EpisodeType is set to **Resource**. This indicates that the components are bound to and switched together with video resources.', example='["a2b8e671-2fe5-4642-a2ec-bf93888****" ]'),
      endTime?: string(name='EndTime', description='The end time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T10:04:00Z'),
      episodeId?: string(name='EpisodeId', description='The ID of the episode. If the episode was added by calling the [AddCasterEpisode](https://help.aliyun.com/document_detail/2848068.html) operation, check the value of the response parameter EpisodeId to obtain the ID.', example='a2b8e671-2fe5-4642-a2ec-bf938887****'),
      episodeName?: string(name='EpisodeName', description='The name of the episode.', example='program_name_2'),
      episodeType?: string(name='EpisodeType', description='The type of the episode. Valid values:

*   **Resource**: a video resource
*   **Component**: a component', example='Resource'),
      resourceId?: string(name='ResourceId', description='The ID of the video resource. If the video resource was added by calling the [AddCasterVideoResource](https://help.aliyun.com/document_detail/2848020.html) operation, check the value of the response parameter ResourceId to obtain the ID.', example='a2b8e671-2fe5-4642-a2ec-bf938887****'),
      startTime?: string(name='StartTime', description='The start time of the episode. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.', example='2016-06-29T09:02:00Z'),
      switchType?: string(name='SwitchType', description='The policy for switching episodes. This parameter takes effect only when EpisodeType is set to **Resource**. Valid values:

*   **TimeFirst**: The episode starts when the previous episode ends and ends when the next episode starts. If no next episode exists, the episode keeps repeating until a new episode is added or the production studio stops. This value is required for live video resources.
*   **ContentFirst**: The episode starts and ends as scheduled.', example='TimeFirst'),
    }
  ](name='Episode', description='The episodes.

This parameter is required.', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ModifyCasterProgramResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model ModifyCasterProgramResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCasterProgramResponseBody(name='body'),
}

/**
  * @description You can call the [AddCasterProgram](https://help.aliyun.com/document_detail/2848074.html) operation to add the episode list for carousel playback in a production studio and then call this operation to modify the episode list. The supported types of episodes include video resource and component.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 4 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyCasterProgram  ModifyCasterProgramRequest
  * @return ModifyCasterProgramResponse
 */
async function modifyCasterProgram(request: ModifyCasterProgramRequest): ModifyCasterProgramResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCasterProgram', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCasterVideoResourceRequest {
  beginOffset?: int32(name='BeginOffset', description='The offset of the position where the system starts to read the video resource.

This parameter takes effect only when the video resource is a video file. Unit: milliseconds.

>  A value greater than 0 indicates an offset from the first frame.', example='0', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.

If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:

Production Studios > Production Studio Management

>  The CasterId is reflected in the Name column on the Production Studio Management page.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  endOffset?: int32(name='EndOffset', description='This parameter takes effect only when the video resource is a video file. Unit: milliseconds.

*   A value greater than **0** indicates an offset from the first frame.
*   A value smaller than **0** indicates an offset from the last frame.', example='10000', position='Query'),
  imageId?: string(name='ImageId', description='ID of the media library image material.
> This parameter is only available and must be provided when the video source type is an image.', example='a089175eb5f4427684fc0715159a****', position='Query'),
  imageUrl?: string(name='ImageUrl', description='Image material URL. 
>This parameter is only available when the video source type is an image and the image file has not been imported into the material library. Supports uploading images in jpg, png formats, with a maximum file size of 10MB.', example='http://learn.aliyundoc.com/AppName/image.jpg', position='Query'),
  liveStreamUrl?: string(name='LiveStreamUrl', description='The URL of the live stream.

This parameter takes effect and is required only when the video resource is a live stream.', example='rtmp://guide.aliyundoc.com/caster/4a82a3d1b7f0462ea37348366201****?auth_key=1608953344-0-0-ac8c628078541d7055a170ec59a5****', position='Query'),
  materialId?: string(name='MaterialId', description='The ID of the material.', example='f080575eb5f4427684fc0715159a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  ptsCallbackInterval?: int32(name='PtsCallbackInterval', description='The interval between presentation timestamp (PTS) callbacks. Unit: milliseconds. This parameter takes effect only when the video resource is a VOD file.', example='2000', minimum=0, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatNum?: int32(name='RepeatNum', description='The number of playback times after the first playback is complete. This parameter takes effect only when the video resource is a file. Valid values:

*   **0**: indicates that the video is played only once. This is the default value.
*   **-1**: indicates that the video is played in loop mode.', example='0', minimum=-1, maximum=60, position='Query'),
  resourceId: string(name='ResourceId', description='The ID of the video resource. It is reflected in the ResourceId parameter when you call the [AddCasterVideoResource](~~60250#doc-api-live-AddCasterVideoResource~~ "Adds a video resource to a production studio.") operation.

This parameter is required.', example='05ab713c-676e-49c0-96ce-cc408da1****', position='Query'),
  resourceName?: string(name='ResourceName', description='The name of the video resource.', example='test001', position='Query'),
  vodUrl?: string(name='VodUrl', description='The URL of the video-on-demand (VOD) file. This parameter takes effect only when the video resource is a video file that is not from the media library.

>  The VOD file must be in the MP4, FLV, or TS format.', example='http://developer.aliyundoc.com/AppName/StreamName.flv', position='Query'),
}

model ModifyCasterVideoResourceResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. This parameter is used in the requests of the following operations: DescribeCasterVideoResources, AddCasterLayout, and DescribeCasterLayouts.', example='LIVEPRODUCER_POST-cn-0pp1czt****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
  resourceId?: string(name='ResourceId', description='The ID of the resource.', example='98461064-1c94-4dc1-85ce-94098764****'),
}

model ModifyCasterVideoResourceResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyCasterVideoResourceResponseBody(name='body'),
}

/**
  * @description ## Usage notes
  * You must call the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation to create a production studio before you call this operation to modify input sources of the production studio.
  * ## QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of ModifyCasterVideoResource  ModifyCasterVideoResourceRequest
  * @return ModifyCasterVideoResourceResponse
 */
async function modifyCasterVideoResource(request: ModifyCasterVideoResourceRequest): ModifyCasterVideoResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCasterVideoResource', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveAIStudioRequest {
  backgroundResourceId?: string(name='BackgroundResourceId', description='The ID of the background material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.', example='d0eb493192c771efba644531858c0102', position='Query'),
  backgroundResourceUrl?: string(name='BackgroundResourceUrl', description='The URL of the background material.', example='https://xxx.com/2.mp4', position='Query'),
  backgroundType?: string(name='BackgroundType', description='The type of the background material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD', position='Query'),
  description?: string(name='Description', description='The custom description.', example='custom', position='Query'),
  height?: int32(name='Height', description='The preview height. Unit: pixels.

The following preview specifications (width × height) are supported:

*   Landscape low definition 360p (640×360)
*   Portrait low definition 360p (360×640)
*   Landscape standard definition 480p (854×480)
*   Portrait standard definition 480p (480×854)
*   Landscape high definition 720p (1280×720)
*   Portrait high definition 720p (720×1280)
*   Landscape ultra-high definition 1080p (1920×1080)
*   Portrait ultra-high definition 1080p (1080×1920)', example='1080', position='Query'),
  mattingLayout: {
    heightNormalized?: float(name='HeightNormalized', description='The normalized value of the height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.', example='0.5'),
    positionX?: float(name='PositionX', description='The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
    positionY?: float(name='PositionY', description='The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
  }(name='MattingLayout', description='The layout information of the chroma-keyed material.

This parameter is required.', shrink='json', position='Query'),
  mattingType: string(name='MattingType', description='The type of chroma key. Valid values:

*   green: green-screen chroma key
*   blue: blue-screen chroma key
*   complex: background replacement

This parameter is required.', example='complex', position='Query'),
  mediaLayout?: {
    heightNormalized?: float(name='HeightNormalized', description='The normalized value of the material height. The value indicates the ratio of the material height to the height of the background. Valid values: **0 to 1**.', example='0.5'),
    positionX?: float(name='PositionX', description='The x-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
    positionY?: float(name='PositionY', description='The y-coordinate of the material. Valid values: **0 to 1**. The upper-left corner is used as the coordinate origin for the material.', example='0'),
  }(name='MediaLayout', description='The layout information of the multimedia material.', shrink='json', position='Query'),
  mediaResourceId?: string(name='MediaResourceId', description='The ID of the multimedia material in ApsaraVideo VOD. You can obtain the ID from the ApsaraVideo VOD console.', example='d0eb493192c771efba644531858c01102', position='Query'),
  mediaResourceUrl?: string(name='MediaResourceUrl', description='The URL of the multimedia material. Specify either this parameter or the MediaResourceId parameter.', example='https://xxx.com/1.mp4', position='Query'),
  mediaType?: string(name='MediaType', description='The type of the multimedia material. Valid values:

*   VOD: a video in ApsaraVideo VOD
*   PIC: an image
*   LIVE: a live stream', example='VOD', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  studioName: string(name='StudioName', description='The name of the virtual studio template. The name is the same as the value of the StudioName parameter that was specified when you called the CreateLiveAIStudio operation to create the virtual studio template.

This parameter is required.', example='stu02', position='Query'),
  width?: int32(name='Width', description='The preview width. Unit: pixels.', example='1920', position='Query'),
}

model ModifyLiveAIStudioResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0BA6B3C4-525A-5381-A2B0-5351323F31C5'),
}

model ModifyLiveAIStudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveAIStudioResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyLiveAIStudio  ModifyLiveAIStudioRequest
  * @return ModifyLiveAIStudioResponse
 */
async function modifyLiveAIStudio(request: ModifyLiveAIStudioRequest): ModifyLiveAIStudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveAIStudio', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveDomainSchdmByPropertyRequest {
  domainName: string(name='DomainName', description='The domain name for which you want to modify the acceleration region.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  property: string(name='Property', description='The acceleration region that you want to set. {"coverage":"overseas"} specifies regions outside the Chinese mainland. Valid values of coverage:

*   domestic: regions in the Chinese mainland.
*   overseas: regions outside the Chinese mainland.
*   global: regions in and outside the Chinese mainland.

This parameter is required.', example='{"coverage":"global"}', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ModifyLiveDomainSchdmByPropertyResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='15C66C7B-671A-4297-9187-2C4477247A74'),
}

model ModifyLiveDomainSchdmByPropertyResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveDomainSchdmByPropertyResponseBody(name='body'),
}

/**
  * @description ### [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveDomainSchdmByProperty  ModifyLiveDomainSchdmByPropertyRequest
  * @return ModifyLiveDomainSchdmByPropertyResponse
 */
async function modifyLiveDomainSchdmByProperty(request: ModifyLiveDomainSchdmByPropertyRequest): ModifyLiveDomainSchdmByPropertyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveDomainSchdmByProperty', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageAppAuditRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application whose content moderation settings you want to modify.

This parameter is required.', example='demo', position='Query'),
  auditType?: int32(name='AuditType', description='The content moderation method. Valid values:

*   0: disables content moderation.
*   1: uses built-in content moderation.
*   2: uses custom content moderation.', example='2', position='Query'),
  auditUrl?: string(name='AuditUrl', description='The URL for content moderation. This parameter is required if you set AuditType to 2. The URL must start with http:// or https:// and cannot contain a private IP address or a port number.', example='http://example.aliyundoc.com/exampleaudit', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
}

model ModifyLiveMessageAppAuditResponseBody = {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='demo'),
  appSign?: string(name='AppSign', description='The signature of the interactive messaging application. It is required by the interactive messaging SDK.', example='**************************************************************************'),
  auditNeedAuthentication?: boolean(name='AuditNeedAuthentication', description='Indicates whether authentication is enabled. If custom content moderation is used, the value of this parameter is true by default.', example='true'),
  auditType?: int32(name='AuditType', description='The content moderation method.', example='2'),
  auditUrl?: string(name='AuditUrl', description='The URL for content moderation. This parameter is returned when the value of AuditType is 2.', example='http: //example.aliyundoc.com/exampleaudit'),
  requestId?: string(name='RequestId', description='The request ID.', example='4C4E8440-3838-1831-9BDE-AFC15803****'),
}

model ModifyLiveMessageAppAuditResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageAppAuditResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveMessageAppAudit  ModifyLiveMessageAppAuditRequest
  * @return ModifyLiveMessageAppAuditResponse
 */
async function modifyLiveMessageAppAudit(request: ModifyLiveMessageAppAuditRequest): ModifyLiveMessageAppAuditResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageAppAudit', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageAppCallbackRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application whose callback settings you want to modify.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  eventCallbackUrl?: string(name='EventCallbackUrl', description='The callback URL for events such as user logon, logoff, joining a group, and leaving a group. If you leave this parameter empty, callbacks are disabled. The callback URL must start with http:// or https:// and cannot contain a private IP address or a port number.', example='http://example.aliyundoc.com/examplecallback', position='Query'),
}

model ModifyLiveMessageAppCallbackResponseBody = {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='demo'),
  appSign?: string(name='AppSign', description='The signature of the interactive messaging application. It is required by the interactive messaging SDK.', example='**************************************************************************'),
  eventCallbackNeedAuthentication?: boolean(name='EventCallbackNeedAuthentication', description='Indicates whether authentication is required for event callbacks. Default value: true.', example='true'),
  eventCallbackUrl?: string(name='EventCallbackUrl', description='The callback URL for events such as user logon, logoff, joining a group, and leaving a group. This parameter is not returned if it has an empty value.', example='http://example.aliyundoc.com/examplecallback'),
  requestId?: string(name='RequestId', description='The request ID.', example='1F0FFEAD-B7D5-1D4A-A6B9-8C63ADF6****'),
}

model ModifyLiveMessageAppCallbackResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageAppCallbackResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveMessageAppCallback  ModifyLiveMessageAppCallbackRequest
  * @return ModifyLiveMessageAppCallbackResponse
 */
async function modifyLiveMessageAppCallback(request: ModifyLiveMessageAppCallbackRequest): ModifyLiveMessageAppCallbackResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageAppCallback', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageAppDisableRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='ab6b5740****', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  disable?: boolean(name='Disable', description='Specifies whether to disable the interactive messaging application.', example='true', position='Query'),
}

model ModifyLiveMessageAppDisableResponseBody = {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='ab6b5740****'),
  appSign?: string(name='AppSign', description='The signature of the interactive messaging application. It is required by the interactive messaging SDK.', example='H4sIAAAAAAAE/wBwAI//zguHB+lYCilkv7diSkk4GhHQAvMXs5tWyI+I09+uEBiB5sqa28ycJSJFmsd50Mhz8nDrvvqmti+fVaNLC5CMgLvNIy48v1aV9x74LRNFN0+Dxd2Al51xuDNkEIDaEwjqfyxscTXjSr0iQjHu2WgkpQAAAP//AQAA//+yR5XCc****'),
  disable?: boolean(name='Disable', description='Indicates whether the interactive messaging application is disabled.', example='true'),
  requestId?: string(name='RequestId', description='The request ID.', example='6AA1AE11-EA78-1FD4-A966-6BA843073F6D'),
}

model ModifyLiveMessageAppDisableResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageAppDisableResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveMessageAppDisable  ModifyLiveMessageAppDisableRequest
  * @return ModifyLiveMessageAppDisableResponse
 */
async function modifyLiveMessageAppDisable(request: ModifyLiveMessageAppDisableRequest): ModifyLiveMessageAppDisableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageAppDisable', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageGroupRequest {
  adminList?: [ string ](name='AdminList', description='The list of administrators after your change.', shrink='simple', position='Query'),
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
  groupInfo?: string(name='GroupInfo', description='The additional information about the group after the modification. The value can be up to 32 KB in length.', example='newmeta', position='Query'),
  modifyAdmin?: boolean(name='ModifyAdmin', description='Specifies whether to change the group administrators.', example='true', position='Query'),
  modifyInfo?: boolean(name='ModifyInfo', description='Specifies whether to modify the additional information about the group.', example='true', position='Query'),
}

model ModifyLiveMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model ModifyLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveMessageGroup  ModifyLiveMessageGroupRequest
  * @return ModifyLiveMessageGroupResponse
 */
async function modifyLiveMessageGroup(request: ModifyLiveMessageGroupRequest): ModifyLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageGroupBandRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  bannedAll?: boolean(name='BannedAll', description='Specifies whether to mute all users.', example='false', position='Query'),
  bannnedUsers?: [ string ](name='BannnedUsers', description='The ID of the user whom you want to mute. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.', shrink='simple', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  exceptUsers?: [ string ](name='ExceptUsers', description='The ID of the user whom you do not want to mute when you set the BannedAll parameter to true. Separate multiple user IDs with commas (,). You can specify up to 30 users IDs.', shrink='simple', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
}

model ModifyLiveMessageGroupBandResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model ModifyLiveMessageGroupBandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageGroupBandResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveMessageGroupBand  ModifyLiveMessageGroupBandRequest
  * @return ModifyLiveMessageGroupBandResponse
 */
async function modifyLiveMessageGroupBand(request: ModifyLiveMessageGroupBandRequest): ModifyLiveMessageGroupBandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageGroupBand', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveMessageUserInfoRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application whose user information you want to modify.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2593195.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  userId: string(name='UserId', description='The ID of the user whose information you want to modify.

This parameter is required.', example='uid2', position='Query'),
  userMetaInfo?: string(name='UserMetaInfo', description='The additional information about the user after the modification. The value can be up to 512 bytes in length.', example='uid2meta2', position='Query'),
}

model ModifyLiveMessageUserInfoResponseBody = {
  failList?: [ 
    {
      code?: int32(name='Code', description='The error code.', example='440'),
      groupId?: string(name='GroupId', description='The ID of the group to which the user belongs. For failed modification, the information of the user is not updated when you query the users in the group. You can try again after you check the failure reason and fix the issue.', example='grouptest2'),
      reason?: string(name='Reason', description='The reason why the information of the user failed to be modified.', example='group not exists or already deleted'),
      success?: boolean(name='Success', description='Indicates whether the group to which the user belongs is modified. In this case, the group is not modified.', example='false'),
    }
  ](name='FailList', description='The users whose information failed to be modified.'),
  requestId?: string(name='RequestId', description='The request ID.', example='3271ACD2-F143-1204-AFDB-9A87C131****'),
  successList?: [ 
    {
      groupId?: string(name='GroupId', description='The ID of the group to which the user belongs. For successful modification, the information of the user is updated when you query the users in the group.', example='grouptest1'),
      success?: boolean(name='Success', description='Indicates whether the group to which the user belongs is modified. In this case, the group is modified.', example='true'),
    }
  ](name='SuccessList', description='The users whose information was modified.'),
}

model ModifyLiveMessageUserInfoResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveMessageUserInfoResponseBody(name='body'),
}

/**
  * @param request  the request parameters of ModifyLiveMessageUserInfo  ModifyLiveMessageUserInfoRequest
  * @return ModifyLiveMessageUserInfoResponse
 */
async function modifyLiveMessageUserInfo(request: ModifyLiveMessageUserInfoRequest): ModifyLiveMessageUserInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveMessageUserInfo', 'POST', '/', 'json', false, 'json', request);
}

model ModifyLiveRealtimeLogDeliveryRequest {
  domainName: string(name='DomainName', description='The main streaming domain for which you want to modify the configuration of real-time log delivery.

This parameter is required.', example='example.com', position='Query'),
  logstore: string(name='Logstore', description='The name of the Logstore to which log entries are delivered.

This parameter is required.', example='logstore_example', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  project: string(name='Project', description='The name of the Log Service project that is used for real-time log delivery.

This parameter is required.', example='project_example', position='Query'),
  region: string(name='Region', description='The ID of the region where the Log Service project is deployed.

This parameter is required.', example='cn-hangzhou', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ModifyLiveRealtimeLogDeliveryResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='9732E117-8A37-49FD-A36F-ABBB87556CA7'),
}

model ModifyLiveRealtimeLogDeliveryResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyLiveRealtimeLogDeliveryResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to modify the configuration of real-time log delivery for a domain name. Logs for a domain name can be delivered to only one Logstore.
  * This operation is applicable to only streaming domains. If you want to configure real-time log delivery for an ingest domain, [submit a ticket](https://workorder-intl.console.aliyun.com/?spm=5176.12818093.nav-right.dticket.6cb216d07otFWR#/ticket/createIndex).
  * *   You can call the [DescribeLiveDomainRealtimeLogDelivery](https://help.aliyun.com/document_detail/2848121.html) operation to query the Project, Logstore, and Region parameters.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyLiveRealtimeLogDelivery  ModifyLiveRealtimeLogDeliveryRequest
  * @return ModifyLiveRealtimeLogDeliveryResponse
 */
async function modifyLiveRealtimeLogDelivery(request: ModifyLiveRealtimeLogDeliveryRequest): ModifyLiveRealtimeLogDeliveryResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyLiveRealtimeLogDelivery', 'GET', '/', 'json', false, 'json', request);
}

model ModifyShowListRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  highPriorityShowId?: string(name='HighPriorityShowId', description='The episode of the highest priority.

>  You can configure this parameter only before the playback of the episode list starts.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  highPriorityShowStartTime?: string(name='HighPriorityShowStartTime', description='The time at which the episode of the highest priority is played. Format: yyyy-MM-dd\\"T\\"HH:mm:ss.

>  You can configure this parameter only before the episode list starts playing.\\
After you configure this parameter, when the specified point in time is reached, any episode that is playing stops and the episode of the highest priority in the episode list starts to play.', example='2021-11-23T12:30:00', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatTimes?: int32(name='RepeatTimes', description='The number of additional times the episode list is played.

> 

*   The RepeatTimes parameter specifies the number of repetitions. For example, if you set the value to **0**, the episode list is played **once**. If you set the value to **1**, the episode list is played **twice**.********

*   If you set the value to -1, the episode list is repeated indefinitely.', example='5', position='Query'),
  showId?: string(name='ShowId', description='The ID of the episode for which you want to change the position in the playlist.

>  You can call the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) or [DescribeShowList](https://help.aliyun.com/document_detail/2848054.html) operation and check the value of the response parameter ShowId to obtain the ID.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  spot?: int32(name='Spot', description='The position of the episode in the episode list. If you want to change the position of an episode in a playlist, place the ID of the episode in **Spot**.

>  The value must be greater than or equal to 0 and less than or equal to the total number of episodes in the playlist.', example='1', position='Query'),
}

model ModifyShowListResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model ModifyShowListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyShowListResponseBody(name='body'),
}

/**
  * @description This operation allows you to change the position of an episode in an episode list, how many times an episode list is played, and the specific point in time at which the episode of the highest priority in an episode list is played.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyShowList  ModifyShowListRequest
  * @return ModifyShowListResponse
 */
async function modifyShowList(request: ModifyShowListRequest): ModifyShowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyShowList', 'POST', '/', 'json', false, 'json', request);
}

model ModifyStudioLayoutRequest {
  bgImageConfig?: string(name='BgImageConfig', description='The background material configurations. The value is a JSON string. For more information, see **BgImageConfig**.

>  This parameter is required only if you set LayoutType to studio.', example='{ "Id":"k12kj31****", "MaterialId":"f080575eb5f4427684fc0715159a****" }', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

>  The production studio must be a virtual studio that you create in advance.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  commonConfig?: string(name='CommonConfig', description='The common layout configurations. The value is a JSON string. For more information, see **CommonConfig**.

>  This parameter is required only if you set LayoutType to common.', example='{  "ChannelId":"RV01" }', position='Query'),
  layerOrderConfigList?: string(name='LayerOrderConfigList', description='The layer sorting configurations. The value is a JSON string. For more information, see **layerOrderConfig**. You can sort layers of background and multimedia materials. The chroma key layer cannot be sorted. A layer that is in the front of the code is placed behind other layers in the layout.', example='[ { "Type":"media", "Id":"k12kj31****" }, { "Type":"media", "Id":"k12kj31****" } ]', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. If the layout was added by calling the [AddStudioLayout](https://help.aliyun.com/document_detail/2848062.html) operation, check the value of the response parameter LayoutId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  layoutName?: string(name='LayoutName', description='The name of the layout.', example='The name of the layout.', position='Query'),
  mediaInputConfigList?: string(name='MediaInputConfigList', description='The multimedia input configurations. The value is a JSON string. For more information, see **MediaInputConfig**.

>  This parameter is optional and takes effect only if you set LayoutType to studio.', example='[ { "Id":"k12kj31****", "Index":"1", "ChannelId":"RV01", "FillMode":"none", "PositionRefer":"topLeft", "WidthNormalized":"0.4", "HeightNormalized":"0.4", "PositionNormalized":"[0.1, 0.2]" }, { "Id":"k12kj31****", "Index":"2", "ImageMaterialId":"lkajsdfsa8fd89asd8****", "FillMode":"none", "PositionRefer":"topLeft", "WidthNormalized":"0.6", "HeightNormalized":"0.4", "PositionNormalized":"[0.1, 0.2]" } ]', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  screenInputConfigList?: string(name='ScreenInputConfigList', description='The input configurations for chroma key. The value is a JSON string. For more information, see **ScreenInputConfig**.

>  This parameter is required only if you set LayoutType to studio.', example='[ { "Index":"1", "ChannelId":"RV01", "Color":"green", "PositionX":"0.1", "PositionY":"0.2", "HeightNormalized":"0.4" } ]', position='Query'),
}

model ModifyStudioLayoutResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model ModifyStudioLayoutResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ModifyStudioLayoutResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify a layout of a virtual studio. When you call this operation, specify only the parameters that you want to modify.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ModifyStudioLayout  ModifyStudioLayoutRequest
  * @return ModifyStudioLayoutResponse
 */
async function modifyStudioLayout(request: ModifyStudioLayoutRequest): ModifyStudioLayoutResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyStudioLayout', 'POST', '/', 'json', false, 'json', request);
}

model MuteAllGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId: string(name='OperatorUserId', description='The ID of the user who performs the operation.

This parameter is required.', example='de1**a0', position='Body'),
}

model MuteAllGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the mute was successful. Valid values:

*   true: The mute was successful.
*   false: The mute failed.', example='true'),
  }(name='Result', description='The returned result.'),
}

model MuteAllGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MuteAllGroupUserResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of MuteAllGroupUser  MuteAllGroupUserRequest
  * @return MuteAllGroupUserResponse
 */
async function muteAllGroupUser(request: MuteAllGroupUserRequest): MuteAllGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MuteAllGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model MuteGroupUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted. This is the default value.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  muteTime?: int32(name='MuteTime', description='The duration of the mute. Unit: seconds.

> If you do not specify this parameter or set the value to 0, the default duration of 86,400 seconds is used.', example='3600', position='Body'),
  muteUserList: [ string ](name='MuteUserList', description='Details about the mute.

This parameter is required.', shrink='simple', position='Body'),
  operatorUserId?: string(name='OperatorUserId', description='The ID of the user who performs the operation.', example='de1**a0', position='Body'),
}

model MuteGroupUserResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the mute is successful. Valid values:

*   true: The mute is successful.
*   false: The mute failed.', example='true'),
  }(name='Result', description='The returned result.'),
}

model MuteGroupUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: MuteGroupUserResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of MuteGroupUser  MuteGroupUserRequest
  * @return MuteGroupUserResponse
 */
async function muteGroupUser(request: MuteGroupUserRequest): MuteGroupUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MuteGroupUser', 'POST', '/', 'json', true, 'form', request);
}

model OpenLiveShiftRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications under the domain name. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  duration?: int32(name='Duration', description='The length of a TS segment for HTTP Live Streaming (HLS). Unit: seconds.', example='3', position='Query'),
  ignoreTranscode?: boolean(name='IgnoreTranscode', description='Specifies whether to disable time shifting for the transcoded stream. Valid values:

*   **true**: disables time shifting for the transcoded stream.
*   **false**: enables time shifting for the transcoded stream.

Default value: true.', example='true', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can specify an asterisk (\\*) as the value to match all streams in the application. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='liveStream****', position='Query'),
  vision?: int32(name='Vision', description='The duration for which data is retained. Default value: 7. Unit: day.', example='10', position='Query'),
}

model OpenLiveShiftResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model OpenLiveShiftResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: OpenLiveShiftResponseBody(name='body'),
}

/**
  * @description You cannot configure time shifting and delayed transcoding at the same time.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of OpenLiveShift  OpenLiveShiftRequest
  * @return OpenLiveShiftResponse
 */
async function openLiveShift(request: OpenLiveShiftRequest): OpenLiveShiftResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'OpenLiveShift', 'POST', '/', 'json', false, 'json', request);
}

model PlayChoosenShowRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showId: string(name='ShowId', description='The ID of the episode that you want to switch to.

>  You can call the [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html) or [DescribeShowList](https://help.aliyun.com/document_detail/2848054.html) operation and check the value of the response parameter ShowId to obtain the ID.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
}

model PlayChoosenShowResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  showId?: string(name='ShowId', description='The ID of the episode.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
}

model PlayChoosenShowResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PlayChoosenShowResponseBody(name='body'),
}

/**
  * @description After you add episodes to an episode list and start live streaming, you can call this operation to switch among episodes. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/2848051.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of PlayChoosenShow  PlayChoosenShowRequest
  * @return PlayChoosenShowResponse
 */
async function playChoosenShow(request: PlayChoosenShowRequest): PlayChoosenShowResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PlayChoosenShow', 'POST', '/', 'json', false, 'json', request);
}

model PublishLiveStagingConfigToProductionRequest {
  domainName: string(name='DomainName', description='The accelerated domain name.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  functionName: string(name='FunctionName', description='The name of the feature. For more information about how to obtain the feature name, see [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html).

This parameter is required.', example='aliauth', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model PublishLiveStagingConfigToProductionResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model PublishLiveStagingConfigToProductionResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PublishLiveStagingConfigToProductionResponseBody(name='body'),
}

/**
  * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
  * ## QPS limit
  * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
  * @param request  the request parameters of PublishLiveStagingConfigToProduction  PublishLiveStagingConfigToProductionRequest
  * @return PublishLiveStagingConfigToProductionResponse
 */
async function publishLiveStagingConfigToProduction(request: PublishLiveStagingConfigToProductionRequest): PublishLiveStagingConfigToProductionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PublishLiveStagingConfigToProduction', 'POST', '/', 'json', false, 'json', request);
}

model PutRecordStorageLifeCycleRequest {
  streamIds: [ string ](name='StreamIds', description='This parameter is required.', example='stream-xxx', shrink='json', position='Body'),
  tag: string(name='Tag', description='This parameter is required.', example='1095days', position='Body'),
  unixTimestamp: long(name='UnixTimestamp', description='This parameter is required.', example='1758621407', position='Body'),
}

model PutRecordStorageLifeCycleResponseBody = {
  code?: int32(name='Code', example='0'),
  msg?: string(name='Msg', example='success'),
  requestId?: string(name='RequestId', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model PutRecordStorageLifeCycleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: PutRecordStorageLifeCycleResponseBody(name='body'),
}

/**
  * @description ## 请求说明
  * - 该接口允许用户为一个或多个指定的直播流设置新的录制文件存储期限。
  * - `Tag` 字段必须符合格式 `[0-9]+days`，表示直播结束后录制内容将被保存的天数。
  * - 如果对某个流的存储时间修改失败，错误信息会被记录在返回结果中。对于失败的情况，调用方应重试最多3次；如果超过重试次数仍失败，则视为最终失败。
  * - 为了支持未来可能的需求变化（如更长的存储周期），请确保您的系统能够处理不同的时间段值。
  * - 成功执行后，供应商会通过异步回调的方式通知调用方所有操作的结果。若回调失败，将按照1小时、2小时、4小时的时间间隔尝试重新发送，直至成功或达到最大重试次数。
  * @param request  the request parameters of PutRecordStorageLifeCycle  PutRecordStorageLifeCycleRequest
  * @return PutRecordStorageLifeCycleResponse
 */
async function putRecordStorageLifeCycle(request: PutRecordStorageLifeCycleRequest): PutRecordStorageLifeCycleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PutRecordStorageLifeCycle', 'POST', '/', 'json', true, 'form', request);
}

model QueryLiveDomainMultiStreamListRequest {
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

The end time must be later than the start time. The time range specified by the StartTime and EndTime parameters cannot exceed seven days. If the two parameters are not specified, data of the last 24 hours is queried by default.', example='2024-12-02T01:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', description='The page number. Default value: **1**.', example='1', position='Query'),
  pageSize?: int32(name='PageSize', description='The number of entries per page. Default value: 10.

Valid values: 1 to 100.', example='10', minimum=1, maximum=100, position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC. The time range specified by the StartTime and EndTime parameters cannot exceed seven days.', example='2024-12-01T01:00:00Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. This parameter is used for exact match.', example='teststream', position='Query'),
}

model QueryLiveDomainMultiStreamListResponseBody = {
  onlineStreams?: [ 
    {
      appName?: string(name='AppName', description='The name of the application.', example='apptest'),
      changeLogs?: [ 
        {
          changeReason?: string(name='ChangeReason', description='The reason for the switchover.

*   merge cut manually: You proactively switched the stream.
*   master stream no data: No data is available in the active stream.
*   master stream low quality: The quality of the active stream deteriorated.', example='merge cut manually'),
          changeTime?: string(name='ChangeTime', description='The switchover time.', example='2024-11-13T09:20:47Z'),
          masterUpstream?: string(name='MasterUpstream', description='The stream used after the switchover.', example='rtmp://118.178.168.35:1936/wwMultitest/pull.livetest2.aliyunlive.com_wwMultitest428_AliRewrite_2?vhost=pull.livetest2.aliyunlive.com&live_rtmp_test=on'),
          upstreamIp?: string(name='UpstreamIp', description='The IP address used after the switchover.', example='1.1.1.1'),
          upstreamSequence?: string(name='UpstreamSequence', description='The identifier of the stream after the switchover.', example='***test_AliRewrite_2'),
        }
      ](name='ChangeLogs', description='The switchover records.'),
      domain?: string(name='Domain', description='The main streaming domain.', example='play.***.com'),
      optimalMode?: string(name='OptimalMode', description='Indicates whether the dual-stream disaster recovery feature is enabled. Valid values:

*   **on**: enabled
*   **off**: disabled', example='on'),
      streamName?: string(name='StreamName', description='The name of the live stream.', example='teststream'),
      upstreamList?: [ 
        {
          masterFlag?: boolean(name='MasterFlag', description='The active/standby tag.

>  This parameter indicates whether the active or standby stream is being distributed.

Valid values:

*   true
*   false', example='false'),
          upstreamIp?: string(name='UpstreamIp', description='The IP address of the stream ingest client.', example='1.1.1.1'),
          upstreamSequence?: string(name='UpstreamSequence', description='The unique identifier of the stream ingest.', example='***test_Alirewrite1'),
          upstreamTime?: string(name='UpstreamTime', description='The stream ingest time.', example='2024-11-13T09:20:47Z'),
        }
      ](name='UpstreamList', description='The standby streams.'),
    }
  ](name='OnlineStreams', description='The online streams returned.'),
  pageNumber?: int32(name='PageNumber', description='The page number.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries per page.', example='10'),
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A5****'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='19'),
}

model QueryLiveDomainMultiStreamListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryLiveDomainMultiStreamListResponseBody(name='body'),
}

/**
  * @param request  the request parameters of QueryLiveDomainMultiStreamList  QueryLiveDomainMultiStreamListRequest
  * @return QueryLiveDomainMultiStreamListResponse
 */
async function queryLiveDomainMultiStreamList(request: QueryLiveDomainMultiStreamListRequest): QueryLiveDomainMultiStreamListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryLiveDomainMultiStreamList', 'GET', '/', 'json', false, 'json', request);
}

model QueryMessageAppRequest {
  appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***', position='Body'),
  appName?: string(name='AppName', description='The name of the interactive messaging application.', example='testApp', position='Body'),
  pageNum?: int32(name='PageNum', description='The number of the page to return. Default value: 1. Valid values: 1 to 100000.', example='10', position='Body'),
  pageSize?: int32(name='PageSize', description='The number of applications to return on each page. Default value: 20. Valid values: 1 to 50.', example='20', position='Body'),
  sortType?: int32(name='SortType', description='The sort order. Valid values:

*   0: ascending order by time
*   1: descending order by time', example='1', position='Body'),
}

model QueryMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: [ 
    {
      appList?: [ 
        {
          appConfig?: map[string]string(name='AppConfig', description='The configurations of the application.'),
          appId?: string(name='AppId', description='The ID of the interactive messaging application.', example='VKL3***'),
          appName?: string(name='AppName', description='The name of the interactive messaging application.', example='test'),
          createTime?: long(name='CreateTime', description='The time when the interactive messaging application was created. The time is displayed in UTC.', example='502280113'),
          extension?: map[string]string(name='Extension', description='The extended field.'),
          status?: int32(name='Status', description='The status of the interactive message application. A value of **1** indicates that the application is normal.', example='1'),
        }
      ](name='AppList', description='Details about the interactive messaging applications.'),
      hasMore?: boolean(name='HasMore', description='Indicates whether the current page is followed by another page. Valid values:

*   true: The current page is followed by another page.
*   false: The current page is not followed by another page.', example='false'),
      totalCount?: int32(name='TotalCount', description='The total number of applications returned.', example='4'),
    }
  ](name='Result', description='The returned result.'),
}

model QueryMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of QueryMessageApp  QueryMessageAppRequest
  * @return QueryMessageAppResponse
 */
async function queryMessageApp(request: QueryMessageAppRequest): QueryMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model QueryRtcAsrTasksRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId?: string(name='TaskId', description='The ID of the task that you want to query. If you do not specify this parameter, all running tasks under your UID are queried.', example='asr-a6ac15e0-9118-4b4c-9e64-306163a0****', position='Query'),
}

model QueryRtcAsrTasksResponseBody = {
  description?: string(name='Description', description='The result of the request. If success is returned, the request was successful. If an error message is returned, the request failed.', example='success'),
  requestId?: string(name='RequestId', description='The request ID.', example='D8ADAB55-1BB8-5C01-8434-C45D353BB1FD'),
  retCode?: long(name='RetCode', description='The HTTP status code. HTTP status code 2000 indicates that the request was successful. Other HTTP status codes indicate that the request failed.', example='2000'),
  tasks?: map[string]any(name='Tasks', description='The results returned for the tasks.'),
}

model QueryRtcAsrTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QueryRtcAsrTasksResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of QueryRtcAsrTasks  QueryRtcAsrTasksRequest
  * @return QueryRtcAsrTasksResponse
 */
async function queryRtcAsrTasks(request: QueryRtcAsrTasksRequest): QueryRtcAsrTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QueryRtcAsrTasks', 'POST', '/', 'json', false, 'json', request);
}

model QuerySnapshotCallbackAuthRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model QuerySnapshotCallbackAuthResponseBody = {
  callbackAuthKey?: string(name='CallbackAuthKey', description='The callback authentication key.', example='yourkey'),
  callbackReqAuth?: string(name='CallbackReqAuth', description='Indicates whether callback authentication is enabled. Valid values:

*   **yes**: Callback authentication is enabled.
*   **no**: Callback authentication is disabled.', example='yes'),
  domainName?: string(name='DomainName', description='The main streaming domain.', example='example.aliyundoc.com'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD5'),
}

model QuerySnapshotCallbackAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: QuerySnapshotCallbackAuthResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have configured authentication for snapshot callbacks. For more information, see [SetSnapshotCallbackAuth](https://help.aliyun.com/document_detail/2847907.html). You can call this operation to query the configuration of authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of QuerySnapshotCallbackAuth  QuerySnapshotCallbackAuthRequest
  * @return QuerySnapshotCallbackAuthResponse
 */
async function querySnapshotCallbackAuth(request: QuerySnapshotCallbackAuthRequest): QuerySnapshotCallbackAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'QuerySnapshotCallbackAuth', 'POST', '/', 'json', false, 'json', request);
}

model RealTimeRecordCommandRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  command: string(name='Command', description='The action to be performed. Valid values:

*   **start**: forcibly starts recording.
*   **stop**: forcibly stops recording. If the live stream is interrupted for longer than a specific latency, a recording is generated.
*   **cancel_delay**: resets the latency for stream interruption and completely stops recording. If the recording task is stopped when you perform this action, a recording is generated.
*   **restart**: forcibly restarts recording. If the live stream is being recorded when you perform this action, a recording is generated.

>  **stop** forcibly stops recording. By default, a recording is generated after 180 seconds. **cancel_delay** resets the latency for stream interruption from 180 seconds to 0 seconds. This means that a recording is generated immediately.

This parameter is required.', example='start', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. Make sure that you specify the correct stream name. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model RealTimeRecordCommandResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model RealTimeRecordCommandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RealTimeRecordCommandResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you fully understand the billing method and pricing of live stream recording in ApsaraVideo Live. For more information, see [Billing of live stream recording](https://help.aliyun.com/document_detail/195287.html).
  * *   If a live stream is being automatically or manually recorded, you can call this operation to stop recording the live stream.
  * *   If you call this operation to start recording a live stream while it is being recorded, a TaskAlreadyStarted error is returned, indicating that the task has been started.
  * *   If a live stream that you manually record is interrupted, the recording stops.
  * *   If automatic recording is not configured for the live stream, ApsaraVideo Live does not automatically record the live stream after it is resumed.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RealTimeRecordCommand  RealTimeRecordCommandRequest
  * @return RealTimeRecordCommandResponse
 */
async function realTimeRecordCommand(request: RealTimeRecordCommandRequest): RealTimeRecordCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RealTimeRecordCommand', 'POST', '/', 'json', false, 'json', request);
}

model RecoverLiveMessageDeletedGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group that you want to restore.

This parameter is required.', example='grouptest', position='Query'),
}

model RecoverLiveMessageDeletedGroupResponseBody = {
  groupId?: string(name='GroupId', description='The ID of the group that was restored.', example='grouptest'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B95BE680-5A6A-1CAD-8AB1-09DFF5D6****'),
}

model RecoverLiveMessageDeletedGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RecoverLiveMessageDeletedGroupResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to restore a deleted interactive messaging group within 30 days after you call the [DeleteLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) to delete the group.
  * *   After you restore a group, the messages that were stored in the group before it was deleted can still be queried.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RecoverLiveMessageDeletedGroup  RecoverLiveMessageDeletedGroupRequest
  * @return RecoverLiveMessageDeletedGroupResponse
 */
async function recoverLiveMessageDeletedGroup(request: RecoverLiveMessageDeletedGroupRequest): RecoverLiveMessageDeletedGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoverLiveMessageDeletedGroup', 'POST', '/', 'json', false, 'json', request);
}

model RemoveLiveMessageGroupBandRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.

>  Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
  unbannedUsers: [ string ](name='UnbannedUsers', description='The users whom you want to unmute.

This parameter is required.', shrink='simple', position='Query'),
}

model RemoveLiveMessageGroupBandResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model RemoveLiveMessageGroupBandResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveLiveMessageGroupBandResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RemoveLiveMessageGroupBand  RemoveLiveMessageGroupBandRequest
  * @return RemoveLiveMessageGroupBandResponse
 */
async function removeLiveMessageGroupBand(request: RemoveLiveMessageGroupBandRequest): RemoveLiveMessageGroupBandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveLiveMessageGroupBand', 'POST', '/', 'json', false, 'json', request);
}

model RemoveShowFromShowListRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showId?: string(name='ShowId', description='The ID of the episode.

>  You can obtain the ID by checking the value of the response parameter ShowId of the [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html) operation.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  isBatchMode?: boolean(name='isBatchMode', description='Specifies whether to remove multiple episodes at a time. Valid values:

*   true: removes multiple episodes at a time.
*   false: removes a single episode.

>  If you do not configure this parameter or this parameter is left empty, a single episode is to be removed.', example='false', position='Query'),
  showIdList?: [ string ](name='showIdList', description='The IDs of episodes that you want to remove.', position='Query'),
}

model RemoveShowFromShowListResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
  showId?: string(name='ShowId', description='The ID of the episode.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****'),
  failedList?: string(name='failedList', description='The IDs of episodes that failed to be removed and the relevant failure information.', example='failedList[Show1, Show2...]'),
  successfulShowIds?: string(name='successfulShowIds', description='The IDs of episodes that were removed.', example='f1933f16-5467-4308-b3a9-e8d451a90999'),
}

model RemoveShowFromShowListResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveShowFromShowListResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You cannot use this operation on empty episode lists. For information about how to add episodes to an episode list, see [AddShowIntoShowList](https://help.aliyun.com/document_detail/370861.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of RemoveShowFromShowList  RemoveShowFromShowListRequest
  * @return RemoveShowFromShowListResponse
 */
async function removeShowFromShowList(request: RemoveShowFromShowListRequest): RemoveShowFromShowListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveShowFromShowList', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTerminalsRequest {
  appId: string(name='AppId', description='The ID of the application. You can specify only one application ID in each request.

This parameter is required.', example='aec****', position='Query'),
  channelId: string(name='ChannelId', description='The ID of the channel. You can specify only one channel ID in each request.

This parameter is required.', example='testId', position='Query'),
  terminalIds: [ string ](name='TerminalIds', description='The IDs of the users that you want to remove.

This parameter is required.', position='Query'),
}

model RemoveTerminalsResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4AF8'),
  terminals?: [ 
    {
      code?: int32(name='Code', description='The returned status code. A value of 0 indicates that the request is successful. If the request fails, an error message is returned.', example='0'),
      id?: string(name='Id', description='The ID of the user.', example='1811****'),
      message?: string(name='Message', description='The result of removing the specified users from the channel. Valid values:

*   Success
*   Failed', example='Success'),
    }
  ](name='Terminals', description='The information about the users.'),
}

model RemoveTerminalsResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RemoveTerminalsResponseBody(name='body'),
}

/**
  * @description You can call this operation to remove one or more users from a channel.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RemoveTerminals  RemoveTerminalsRequest
  * @return RemoveTerminalsResponse
 */
async function removeTerminals(request: RemoveTerminalsRequest): RemoveTerminalsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTerminals', 'POST', '/', 'json', false, 'json', request);
}

model RestartCasterRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model RestartCasterResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='6EBD1AC4-C34D-4AE1-963E-B688A228BE31'),
}

model RestartCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartCasterResponseBody(name='body'),
}

/**
  * @description *   Only product studios in playlist mode and general mode are supported. Virtual studios are not supported.
  * *   After you restart a production studio, the current settings such as the resolution and screen orientation are reloaded to restore the previous playback status.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RestartCaster  RestartCasterRequest
  * @return RestartCasterResponse
 */
async function restartCaster(request: RestartCasterRequest): RestartCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartCaster', 'POST', '/', 'json', false, 'json', request);
}

model RestartLivePullToPushRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region of the live center. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='preregion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

This parameter is required.', example='6f869419-0692-4fd5-8cf0-66cab659****', position='Query'),
}

model RestartLivePullToPushResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='a05e6b15-15af-405b-a4a2-01522450****'),
  taskId?: string(name='TaskId', description='The new task ID.', example='fb0d4ac7-c7e3-4978-9743-0bf2f6e8****'),
}

model RestartLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartLivePullToPushResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to restart a pulled-stream relay task.
  * *   You can restart a task that is running (even if the task is in an abnormal retry state) or a task that is stopped. For a task that is running, this operation stops and then restarts it. For a task that is stopped, this operation directly starts it.
  * *   You cannot restart a task if the start time specified for the task has not been reached.
  * *   If a task is restarted, the task runs based on the latest configuration of the task. This interrupts stream ingest.
  * *   If a task for a list of ApsaraVideo VOD resources is restarted, the list plays from the beginning based on the latest configuration. You can call an operation to update the video index and playback progress to achieve successive playback.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of RestartLivePullToPush  RestartLivePullToPushRequest
  * @return RestartLivePullToPushResponse
 */
async function restartLivePullToPush(request: RestartLivePullToPushRequest): RestartLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartLivePullToPush', 'GET', '/', 'json', false, 'json', request);
}

model RestartTranscodeTaskRequest {
  app?: string(name='App', position='Query'),
  pushDomain?: string(name='PushDomain', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName?: string(name='StreamName', position='Query'),
  transcodingTemplate?: string(name='TranscodingTemplate', position='Query'),
}

model RestartTranscodeTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartTranscodeTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RestartTranscodeTaskResponseBody(name='body'),
}

/**
  * @param request  the request parameters of RestartTranscodeTask  RestartTranscodeTaskRequest
  * @return RestartTranscodeTaskResponse
 */
async function restartTranscodeTask(request: RestartTranscodeTaskRequest): RestartTranscodeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartTranscodeTask', 'POST', '/', 'json', false, 'json', request);
}

model ResumeLiveStreamRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  liveStreamType: string(name='LiveStreamType', description='Specifies whether the live stream is ingested by a streamer or played by a client. Set the value to **publisher**, which specifies that the live stream is ingested by a streamer.

This parameter is required.', example='publisher', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  streamName: string(name='StreamName', description='The name of the ingested stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model ResumeLiveStreamResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16BFE188-B193-4C3C-ADC5-79A7E31486EA'),
}

model ResumeLiveStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: ResumeLiveStreamResponseBody(name='body'),
}

/**
  * @description You can call this operation to resume the ingest of a stream. This operation supports only the live streams ingested by streamers.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of ResumeLiveStream  ResumeLiveStreamRequest
  * @return ResumeLiveStreamResponse
 */
async function resumeLiveStream(request: ResumeLiveStreamRequest): ResumeLiveStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResumeLiveStream', 'POST', '/', 'json', false, 'json', request);
}

model RollbackLiveStagingConfigRequest {
  domainName: string(name='DomainName', description='The accelerated domain name.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  functionName: string(name='FunctionName', description='The name of the feature. For more information about how to obtain the feature name, see [DescribeLiveDomainStagingConfig](https://help.aliyun.com/document_detail/297374.html).

This parameter is required.', example='aliauth', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model RollbackLiveStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model RollbackLiveStagingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: RollbackLiveStagingConfigResponseBody(name='body'),
}

/**
  * @description Function name is required for calling this operation. You can get the function name by calling the [DescribeLiveDomainStagingConfig](~~297374#doc-api-live-DescribeLiveDomainStagingConfig~~ "Queries the configurations in the canary release environment.") operation.
  * ## QPS limit
  * A single user can perform a maximum of 30 queries per minute. Throttling is triggered when the number of calls per second exceeds the QPS limit. The throttling may affect your business. Thus, we recommend that you observe the QPS limit on this operation. For more information about what a single user means and the QPS details, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live#topic-2136805).
  * @param request  the request parameters of RollbackLiveStagingConfig  RollbackLiveStagingConfigRequest
  * @return RollbackLiveStagingConfigResponse
 */
async function rollbackLiveStagingConfig(request: RollbackLiveStagingConfigRequest): RollbackLiveStagingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RollbackLiveStagingConfig', 'POST', '/', 'json', false, 'json', request);
}

model SendLikeRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  broadCastType?: int32(name='BroadCastType', description='The mode in which system messages are broadcasted. Valid values:

*   0: specifies that system messages are not broadcasted. This is the default value.
*   1: specifies that system messages are broadcasted to specified users.
*   2: specifies that system messages are broadcasted to the message group.', example='2', position='Body'),
  count: string(name='Count', description='The number of likes.

This parameter is required.', example='10', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId?: string(name='OperatorUserId', description='The ID of the user who performs the operation.', example='de1**a0', position='Body'),
}

model SendLikeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    likeCount?: int32(name='LikeCount', description='The number of likes.', example='10'),
  }(name='Result', description='The returned result.'),
}

model SendLikeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendLikeResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of SendLike  SendLikeRequest
  * @return SendLikeResponse
 */
async function sendLike(request: SendLikeRequest): SendLikeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendLike', 'POST', '/', 'json', true, 'form', request);
}

model SendLiveMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application in which the message is received.

This parameter is required.', example='demo', position='Query'),
  body?: string(name='Body', description='The message body. The body can be up to 15 KB in length.', example='hello,group', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The ID of the group that receives the message.

>  Make sure that the specified group ID exists. Otherwise, a ResourceNotExist error is returned.

This parameter is required.', example='grouptest', minLength=1, position='Query'),
  msgTid?: string(name='MsgTid', description='The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.', example='169830****', position='Query'),
  msgType?: long(name='MsgType', description='The message type.', example='1', position='Query'),
  noCache?: boolean(name='NoCache', description='Specifies whether to disable message caching. Valid values: true and false. Default value: false, which specifies that the message is cached to the recent message list of the group.', example='false', position='Query'),
  noStorage?: boolean(name='NoStorage', description='Specifies whether to disable message storage. Valid values: true and false. Default value: false, which specifies that the message is stored for a validity period of 30 days. You can find the message in the response of the ListLiveMessageGroupMessages operation. If you do not want to store the message, set this parameter to true.', example='false', position='Query'),
  senderId: string(name='SenderId', description='The ID of the user who sends the message. The ID can be up to 64 bytes in length and can contain letters and digits.

This parameter is required.', example='uid1', position='Query'),
  senderMetaInfo?: string(name='SenderMetaInfo', description='The additional information about the user who sends the message. The value can be up to 512 bytes in length.', example='uid1meta1', position='Query'),
  staticsIncrease?: long(name='StaticsIncrease', description='The contribution of the message to the increase in the number of messages of this type. Default value: 1.', example='1', position='Query'),
  weight?: long(name='Weight', description='The weight of the message. Default value: 1. A greater value indicates a higher priority. For a message of the highest priority, you can set the weight to 1000000.', example='1', position='Query'),
}

model SendLiveMessageGroupResponseBody = {
  msgTid?: string(name='MsgTid', description='The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.', example='169830****'),
  requestId?: string(name='RequestId', description='The request ID.', example='E4C1245F-597B-1BD1-B9BB-9D220E99****'),
}

model SendLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group. You can send messages to a group only if the group is active, which requires that one or more users have joined the group. Offline messages are not supported. If you fail to send a message, check whether users exist in the group. If you want to send a message when all users are offline, we recommend that you store the message locally and send it after users get online.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SendLiveMessageGroup  SendLiveMessageGroupRequest
  * @return SendLiveMessageGroupResponse
 */
async function sendLiveMessageGroup(request: SendLiveMessageGroupRequest): SendLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model SendLiveMessageUserRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application in which the message is sent.

This parameter is required.', example='demo', position='Query'),
  body?: string(name='Body', description='The message body. It can be up to 15 KB in length.', example='hello, user', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application. Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  highReliability?: boolean(name='HighReliability', description='Specifies whether to set the message as a highly reliable message. A highly reliable message ensures that success is returned only after the receiver has received the message and responded. If the receiver does not respond within 3 seconds, failure is returned.

*   true: sets the message as a highly reliable message.
*   false (default): does not set the message as a highly reliable message.

>  This parameter is supported only by the client SDK V1.5.1 and later. When you send a message to a client with an earlier SDK version, the message can be successfully sent without waiting for an acknowledgement (ACK) response.', example='false', position='Query'),
  msgTid?: string(name='MsgTid', description='The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.', example='169830****', position='Query'),
  msgType?: long(name='MsgType', description='The message type.', example='2', position='Query'),
  receiverId: string(name='ReceiverId', description='The ID of the user who receives the message. The ID can be up to 64 bytes in length and can contain letters and digits.

>  Make sure that the user who receives the message is online. You can call the CheckLiveMessageUsersOnline operation to query whether the user is online.

This parameter is required.', example='uid2', position='Query'),
  senderId: string(name='SenderId', description='The ID of the user who sends the message. The ID can be up to 64 bytes in length and can contain letters and digits.

This parameter is required.', example='uid1', position='Query'),
  senderInfo?: string(name='SenderInfo', description='The additional information about the user who sends the message. It can be up to 512 bytes in length.', example='uid1meta1', position='Query'),
  storage?: boolean(name='Storage', description='Specifies whether to store the message.

*   true: stores the message.
*   false (default): does not store the message.', example='false', position='Query'),
}

model SendLiveMessageUserResponseBody = {
  msgTid?: string(name='MsgTid', description='The ID of the message, which is a unique identifier that can be used to delete the message. The ID can be up to 64 bytes in length and can contain letters and digits.', example='169830****'),
  requestId?: string(name='RequestId', description='The request ID.', example='6CFDE7AB-571A-14EA-B072-989FF753****'),
}

model SendLiveMessageUserResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendLiveMessageUserResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SendLiveMessageUser  SendLiveMessageUserRequest
  * @return SendLiveMessageUserResponse
 */
async function sendLiveMessageUser(request: SendLiveMessageUserRequest): SendLiveMessageUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendLiveMessageUser', 'POST', '/', 'json', false, 'json', request);
}

model SendMessageToGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  data: string(name='Data', description='The message body. The value is a JSON string.

This parameter is required.', example='test', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId: string(name='OperatorUserId', description='The ID of the user who performed the operation.

This parameter is required.', example='de1**a0', position='Body'),
  skipAudit?: boolean(name='SkipAudit', description='Specifies whether the message requires Alibaba Cloud content moderation. Valid values:

- **true**: does not require content moderation.
- **false**: requires content moderation. This is the default value.', example='true', position='Query'),
  type?: int32(name='Type', description='The type of the message. A value that is less than or equal to 10000 specifies a system message. A value that is greater than 10000 specifies a custom message.', example='12000', position='Body'),
}

model SendMessageToGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    messageId?: string(name='MessageId', description='The ID of the message.', example='qt***'),
  }(name='Result', description='The data returned.'),
}

model SendMessageToGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageToGroupResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of SendMessageToGroup  SendMessageToGroupRequest
  * @return SendMessageToGroupResponse
 */
async function sendMessageToGroup(request: SendMessageToGroupRequest): SendMessageToGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendMessageToGroup', 'POST', '/', 'json', true, 'form', request);
}

model SendMessageToGroupUsersRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  data: string(name='Data', description='The message body. The value is a JSON string.

This parameter is required.', example='test', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
  operatorUserId: string(name='OperatorUserId', description='The ID of the user who performs the operation.

This parameter is required.', example='de1**a0', position='Body'),
  receiverIdList?: [ string ](name='ReceiverIdList', description='The list of users to receive the message.', shrink='simple', position='Body'),
  skipAudit?: boolean(name='SkipAudit', description='Specifies whether the message requires Alibaba Cloud content moderation. Valid values:

- **true**: does not require content moderation.
- **false**: requires content moderation. This is the default value.', example='true', position='Query'),
  type: int32(name='Type', description='The type of the message. A value that is less than or equal to 10000 specifies a system message. A value that is greater than 10000 specifies a custom message.

This parameter is required.', example='12000', position='Body'),
}

model SendMessageToGroupUsersResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    messageId?: string(name='MessageId', description='The ID of the message.', example='hp***'),
  }(name='Result', description='The returned result.'),
}

model SendMessageToGroupUsersResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SendMessageToGroupUsersResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of SendMessageToGroupUsers  SendMessageToGroupUsersRequest
  * @return SendMessageToGroupUsersResponse
 */
async function sendMessageToGroupUsers(request: SendMessageToGroupUsersRequest): SendMessageToGroupUsersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SendMessageToGroupUsers', 'POST', '/', 'json', true, 'form', request);
}

model SetCasterChannelRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  channelId: string(name='ChannelId', description='The ID of the channel.

When channels are enabled, the layout references the channel IDs. You can specify up to one resource for a channel. The number of resources is limited by the number of the channels of the production studio. The value must be in the RV[Number] format, such as RV01 and RV12.

This parameter is required.', example='RV01', position='Query'),
  faceBeauty?: string(name='FaceBeauty', description='The face retouching effect. Valid values: 0 (all effects), 1 (skin smoothing), 2 (skin whitening), 3 (dark circles removal), and 4 (nasolabial folds removal).', example='0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  playStatus?: int32(name='PlayStatus', description='The playback status. This parameter take effects for video files, but not for live streams. Valid values:

*   **1**: specifies that the video source is playing. This is the default value.
*   **0**: specifies that the playback of the video source is paused.', example='1', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId?: string(name='ResourceId', description='The ID of the video source.', example='16A96B9A-F203-4EC5-8E43-CB92E68F****', position='Query'),
  seekOffset?: int32(name='SeekOffset', description='The offset of the position where the production studio starts reading the video source. The value must be greater than or equal to 0, indicating an offset from the first frame. This parameter take effects for video files, but not for live streams. Unit: milliseconds.', example='1000', position='Query'),
}

model SetCasterChannelResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model SetCasterChannelResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetCasterChannelResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure a channel for the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetCasterChannel  SetCasterChannelRequest
  * @return SetCasterChannelResponse
 */
async function setCasterChannel(request: SetCasterChannelRequest): SetCasterChannelResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCasterChannel', 'POST', '/', 'json', false, 'json', request);
}

model SetCasterConfigRequest {
  autoSwitchUrgentConfig?: string(name='AutoSwitchUrgentConfig', description='The configuration for automatic switchover to the standby resource.

The `eofThres` field specifies the duration after which the production studio automatically switches to the standby resource if a stream interruption occurs. Unit: seconds.', example='{"eofThres":3}', position='Query'),
  autoSwitchUrgentOn?: boolean(name='AutoSwitchUrgentOn', description='Specifies whether the production studio automatically switches to the standby resource in case of a stream interruption.

*   **true**
*   **false**', example='true', position='Query'),
  callbackUrl?: string(name='CallbackUrl', description='The callback URL. Enter a valid HTTP address for receiving callback notifications. If you do not specify this parameter, the production studio does not send callback notifications.

>  For more information about production studio callbacks, see [Production studio callbacks](https://help.aliyun.com/document_detail/213633.html).', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  casterName?: string(name='CasterName', description='The name of the production studio.', example='liveCaster****', position='Query'),
  channelEnable?: int32(name='ChannelEnable', description='Specifies whether to enable channels. Valid values:

*   **0** (default): disables channels.
*   **1**: enables channels.

> You cannot disable channels after you enable them. If you set this parameter to 0, the production studio references video resources in a layout without using channels. If you enable channels for the first time, make sure that the production studio is in the idle state. After you enable channels, a new layout that references video resources by using channels is generated to replace the original one. Therefore, you must specify video resources for channels. You can use the channels to change the playback progress or status. If the video resource, preview, and program modules of the production studio use the same video source, the three modules display the same content.', example='1', position='Query'),
  delay?: float(name='Delay', description='Specifies whether to enable stream delay. Unit: seconds. Valid values:

*   **0** (default): disables stream delay.

*   **A value greater than 0**: enables stream delay.

*   **Empty**: clears the stream delay configuration.

    **

    **Note **The maximum value can be 300 seconds.', example='0', position='Query'),
  domainName?: string(name='DomainName', description='The main streaming domain.

Complete the configuration of the domain name before the production studio is started. If you do not specify this parameter, the domain configuration for the production studio is cleared.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  programEffect?: int32(name='ProgramEffect', description='Specifies whether to enable the carousel playback feature. Valid values:

*   **0**: disables carousel playback.
*   **1**: enables carousel playback.', example='1', position='Query'),
  programName?: string(name='ProgramName', description='The name of the playlist for carousel playback. You can specify this parameter if you enable the carousel playback feature.', example='program_name', position='Query'),
  recordConfig?: string(name='RecordConfig', description='The recording configuration. The value is a JSON string. You can configure the following fields:

*   **endpoint**: the API server address of an Alibaba Cloud service.
*   **ossBucket**: the name of the Object Storage Service (OSS) bucket.
*   **videoFormat**: the format in which the video file can be exported. Example: `[{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"m3u8\\",\\"CycleDuration\\":21600,\\"SliceOssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{UnixTimestamp}\\"},{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"flv\\",\\"CycleDuration\\":21600}]`.
*   **interval**: the interval between recordings. Unit: milliseconds.

> If you do not specify this parameter, the recording feature is disabled and the recording configuration for the production studio is cleared.', example='{ "endpoint": "http://oss-cn-********.aliyuncs.com/api",  "ossBucket****": "liveBucket****", "VideoFormat":[{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"m3u8\\",\\"CycleDuration\\":21600,\\"SliceOssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{UnixTimestamp}\\"},{\\"OssObjectPrefix\\":\\"record/{AppName}/{StreamName}/{StartTime}_{EndTime}\\",\\"Format\\":\\"flv\\",\\"CycleDuration\\":21600}] "interval": 5 }', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sideOutputUrl?: string(name='SideOutputUrl', description='The custom stream redirect URL.

If you do not specify this parameter, the production studio uses the redirect URL generated by the system.

> Redirect URLs support only the Real-Time Messaging Protocol (RTMP) protocol.', position='Query'),
  sideOutputUrlList?: string(name='SideOutputUrlList', description='The stream relay URLs. A relay URL can be an Alibaba Cloud URL or a URL from a third-party CDN provider. You can specify up to 20 relay URLs over the RTMP protocol.

> Use the following format to specify multiple relay URLs: "rtmp://domain/app1/stream1","rtmp://domain/app2/stream2".', example='rtmp://domain/app/stream?***', position='Query'),
  syncGroupsConfig?: string(name='SyncGroupsConfig', description='The multi-view synchronization configuration. You can specify this parameter to synchronize multiple video sources.

There are two modes of multi-view synchronization.

*   A value of 0 for the mode field specifies the streamer mode. In this mode, multiple video sources are synchronized based on the settings by the streamer.
*   A value of 1 for the mode field specifies the conference mode. In this mode, all video sources are synchronized.

In the streamer mode, the hostResourceId field specifies the video source on the streamer side.

In the conference mode, the hostResourceId field is not available. You need to provide only resource IDs that are required.', example='"[{\\"mode\\":0,\\"resourceIds\\":[\\"5a6c1c33-8424-46f6-813c-c152220a****\\",\\"4e6521dc-a40a-4077-b6bf-1fb12a76****\\"],\\"hostResourceId\\":\\"3aa2b39a-fd0e-4b8c-be73-b7af31c4****\\"}]"', position='Query'),
  transcodeConfig?: string(name='TranscodeConfig', description='The transcoding configuration.

The value is a JSON string. Use upper camel case for fields of the string. If you do not specify this parameter, the transcoding configuration is cleared. If no transcoding template is available, an error occurs when the production studio is started.', example='{"casterTemplate": "lp_ld"}', position='Query'),
  urgentImageId?: string(name='UrgentImageId', description='The ID of the standby image from the media library.', example='a089175eb5f4427684fc0715159a****', position='Query'),
  urgentImageUrl?: string(name='UrgentImageUrl', description='The URL of the standby image.', example='http://learn.aliyundoc.com/AppName/image.jpg', position='Query'),
  urgentLiveStreamUrl?: string(name='UrgentLiveStreamUrl', description='The URL of the standby live stream.', example='rtmp://demo.aliyundoc.com', position='Query'),
  urgentMaterialId?: string(name='UrgentMaterialId', description='The ID of the standby video from the media library. If you do not specify this parameter, the standby video configuration for the production studio is cleared.', example='a2b8e671', position='Query'),
}

model SetCasterConfigResponseBody = {
  casterId?: string(name='CasterId', description='The ID of the production studio. You can specify the ID in a request to query the streaming URLs of the production studio, start the production studio, add a video resource, a layout, a component, or a playlist to the production studio, or query layouts of the production studio.', example='b4810848-bcf9-4aef-bd4a-e6bba2d9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model SetCasterConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetCasterConfigResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to configure the production studio. This operation completely replaces existing configurations. If you leave a parameter empty, the corresponding configuration is cleared for the production studio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetCasterConfig  SetCasterConfigRequest
  * @return SetCasterConfigResponse
 */
async function setCasterConfig(request: SetCasterConfigRequest): SetCasterConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCasterConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetCasterSceneConfigRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/69338.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  componentId?: [ string ](name='ComponentId', description='The IDs of the components. Components in the scene are listed from the bottom to the top in an array.

>  N indicates a sequence number. Examples:\\
ComponentId.1 indicates the ID of the first component.\\
ComponentId.2 indicates the ID of the second component.', example='[ "a2b8e671-2fe5-4642-a2ec-bf931826****", "a2b8e671-2fe5-4642-a2ec-28374657****"]', position='Query'),
  layoutId?: string(name='LayoutId', description='The ID of the layout. If you call the [DescribeCasterLayouts](https://help.aliyun.com/document_detail/60260.html) operation to query the layouts of the production studio, check the value of the response parameter LayoutId to obtain the ID.', example='0c6da077-f037-49e8-8440-3be13393****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This parameter is required.', example='242b4e2c-c30f-4442-85ba-2e3e4e3d****', position='Query'),
}

model SetCasterSceneConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model SetCasterSceneConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetCasterSceneConfigResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * This operation configures a scene by clearing all previous settings of the scene and applying new settings, including the layout setting, to the scene.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of SetCasterSceneConfig  SetCasterSceneConfigRequest
  * @return SetCasterSceneConfigResponse
 */
async function setCasterSceneConfig(request: SetCasterSceneConfigRequest): SetCasterSceneConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetCasterSceneConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveDomainCertificateRequest {
  certName?: string(name='CertName', description='The certificate name.', example='Cert-****', position='Query'),
  certType?: string(name='CertType', description='The certificate type. Valid values:

*   **upload**: a custom certificate
*   **cas**: a certificate that is purchased from Certificate Management Service
*   **free**: a free certificate (for testing)', example='free', position='Query'),
  domainName: string(name='DomainName', description='The domain name that is secured by the certificate. The domain name uses `HTTPS`-based acceleration.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  forceSet?: string(name='ForceSet', description='Specifies whether to check the certificate name for duplicates. A value of 1 indicates that the system does not perform the check and overwrites the information about the certificate that has the same name. Set the value to **1**.', example='1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  SSLPri?: string(name='SSLPri', description='The private key.

>  This parameter is required only if you set the SSLProtocol parameter to on.', example='****', position='Query'),
  SSLProtocol: string(name='SSLProtocol', description='Specifies whether to enable the HTTPS certificate. Valid values:

*   **on**. If you set this parameter to **on**, you must also specify the SSLPub and SSLPri parameters.
*   **off**. This is the default value.

This parameter is required.', example='off', position='Query'),
  SSLPub?: string(name='SSLPub', description='The public key.

>  This parameter is required only if you set the SSLProtocol parameter to on.', example='****', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model SetLiveDomainCertificateResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model SetLiveDomainCertificateResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveDomainCertificateResponseBody(name='body'),
}

/**
  * @description Obtain the domain name, and then call this operation to enable or disable the certificate of a domain name and modify the certificate information.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveDomainCertificate  SetLiveDomainCertificateRequest
  * @return SetLiveDomainCertificateResponse
 */
async function setLiveDomainCertificate(request: SetLiveDomainCertificateRequest): SetLiveDomainCertificateResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveDomainCertificate', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveDomainMultiStreamConfigRequest {
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  switch: string(name='Switch', description='Specifies whether to enable the dual-stream disaster recovery feature. Valid values:

*   **on**: enables the feature.
*   **off**: disables the feature.

This parameter is required.', example='on', position='Query'),
}

model SetLiveDomainMultiStreamConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
}

model SetLiveDomainMultiStreamConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveDomainMultiStreamConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to configure dual-stream disaster recovery for a streaming domain, which allows you to ingest two streams that have the same name.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveDomainMultiStreamConfig  SetLiveDomainMultiStreamConfigRequest
  * @return SetLiveDomainMultiStreamConfigResponse
 */
async function setLiveDomainMultiStreamConfig(request: SetLiveDomainMultiStreamConfigRequest): SetLiveDomainMultiStreamConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveDomainMultiStreamConfig', 'GET', '/', 'json', false, 'json', request);
}

model SetLiveDomainMultiStreamMasterRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='testapp', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='teststream', position='Query'),
  upstreamSequence: string(name='UpstreamSequence', description='The unique identifier of the stream ingest.

This parameter is required.', example='teststream_***', position='Query'),
}

model SetLiveDomainMultiStreamMasterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4E*****43-CB92E68F4CD8'),
}

model SetLiveDomainMultiStreamMasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveDomainMultiStreamMasterResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetLiveDomainMultiStreamMaster  SetLiveDomainMultiStreamMasterRequest
  * @return SetLiveDomainMultiStreamMasterResponse
 */
async function setLiveDomainMultiStreamMaster(request: SetLiveDomainMultiStreamMasterRequest): SetLiveDomainMultiStreamMasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveDomainMultiStreamMaster', 'GET', '/', 'json', false, 'json', request);
}

model SetLiveDomainMultiStreamOptimalModeRequest {
  appName: string(name='AppName', description='The application name.

This parameter is required.', example='testapp', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  optimalMode: string(name='OptimalMode', description='Specifies whether to enable the auto mode of dual-stream disaster recovery. Valid values:

*   **on**: enables the auto mode.
*   **off**: disables the auto mode.

This parameter is required.', example='on', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='teststream', position='Query'),
}

model SetLiveDomainMultiStreamOptimalModeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-****-CB92E68F4CD8'),
}

model SetLiveDomainMultiStreamOptimalModeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveDomainMultiStreamOptimalModeResponseBody(name='body'),
}

/**
  * @param request  the request parameters of SetLiveDomainMultiStreamOptimalMode  SetLiveDomainMultiStreamOptimalModeRequest
  * @return SetLiveDomainMultiStreamOptimalModeResponse
 */
async function setLiveDomainMultiStreamOptimalMode(request: SetLiveDomainMultiStreamOptimalModeRequest): SetLiveDomainMultiStreamOptimalModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveDomainMultiStreamOptimalMode', 'GET', '/', 'json', false, 'json', request);
}

model SetLiveDomainStagingConfigRequest {
  domainName: string(name='DomainName', description='The accelerated domain name.

This parameter is required.', example='developer.aliyundoc.com', position='Query'),
  functions: string(name='Functions', description='The list of features. You must specify the ConfigId field when you want to modify the configurations. For more information, see **Features specified by the Functions parameter**.

This parameter is required.', example='[{"functionArgs":[{"argName":"enable","argValue":"on"},{"argName":"pri","argValue":"1"},{"argName":"rule","argValue":"xxx"}],"functionName":"edge_function"}]', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model SetLiveDomainStagingConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='04F0F334-1335-436C-A1D7-6C044FE73368'),
}

model SetLiveDomainStagingConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveDomainStagingConfigResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * Obtain the accelerated domain name, and then call this operation to set or modify the domain name configurations in the canary release environment. For more information, see **Format of the Functions parameter**.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of SetLiveDomainStagingConfig  SetLiveDomainStagingConfigRequest
  * @return SetLiveDomainStagingConfigResponse
 */
async function setLiveDomainStagingConfig(request: SetLiveDomainStagingConfigRequest): SetLiveDomainStagingConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveDomainStagingConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveEdgeTransferRequest {
  appName?: string(name='AppName', description='The name of the application to which the live stream belongs. Regular expressions are supported, with a few limits. For more information, see the **Description about the AppName and StreamName parameters** section. For example, a value of **liveApp\\*\\*\\*\\*[1,2,3]** specifies that stream relay is configured for three applications: liveApp\\*\\*\\*\\*1, liveApp\\*\\*\\*\\*2, and liveApp\\*\\*\\*\\*3.****

> 

*   This parameter takes effect for only destination domain names that are specified by the TargetDomainList parameter.

*   You cannot use a caret (^) or a dollar sign ($) in a regular expression to configure the `AppName` parameter. Otherwise, stream relay fails.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The ingest domain. Stream relay is configured based on the ingest domain. Only one stream relay configuration can be set for an ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  httpDns?: string(name='HttpDns', description='The HTTPDNS API that is used to obtain the destination URLs. The request must contain the `TargetDomainList` parameter or the `HttpDns` parameter. The two parameters are mutually exclusive.

>  If the `HttpDns` parameter is configured, you cannot configure the `TargetDomainList` parameter, and the `AppName` and `StreamName` parameters do not take effect.

For information about the requirements on the structure of messages that are returned by the HTTPDNS API, see the **Description about the HTTPDNS API** section.', example='http://developer.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the ingested stream. Regular expressions are supported, with a few limits. For more information, see the **Description about the AppName and StreamName parameters** section. For example, a value of **liveStream\\*\\*\\*\\*[1,2,3]** specifies that stream relay is configured for three streams: liveStream\\*\\*\\*\\*1, liveStream\\*\\*\\*\\*2, and liveStream\\*\\*\\*\\*3.****

> 

*   This parameter takes effect for only destination domain names that are specified by the TargetDomainList parameter.

*   You cannot use a caret (^) or a dollar sign ($) in a regular expression to configure the `StreamName` parameter. Otherwise, stream relay fails.', example='liveStream****', position='Query'),
  targetDomainList?: string(name='TargetDomainList', description='The destination domain names to which you want to relay the ingested stream. Separate multiple domain names with commas (,). The request must contain the `TargetDomainList` parameter or the `HttpDns` parameter. The two parameters are mutually exclusive.

> 

*   The `AppName` and `StreamName` parameters take effect only when the `TargetDomainList` parameter is configured.

*   If the `TargetDomainList` parameter is configured, you cannot configure the `HttpDns` parameter.', example='learn.aliyundoc.com,guide.aliyundoc.com', position='Query'),
  transferArgs?: string(name='TransferArgs', description='Specifies whether to pass through stream ingest parameters. Valid values:

*   **yes**: passes through stream ingest parameters.
*   **no**: does not pass through stream ingest parameters.', example='yes', position='Query'),
}

model SetLiveEdgeTransferResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CF8'),
}

model SetLiveEdgeTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveEdgeTransferResponseBody(name='body'),
}

/**
  * @description You can call the SetLiveEdgeTransfer operation to configure edge stream relay. The configuration takes effect for ingested streams that start after edge stream relay is configured. The following table describes the scenarios in which edge stream relay takes effect or not.
  * |Scenario|Analysis|Result|
  * |---|---|---|
  * |1\\. You ingest a stream before you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is not available.|The ingested stream is not affected by your call of the SetLiveEdgeTransfer operation. Edge stream relay does not take effect.|
  * |2\\. You disconnect an ingested stream that started before you called the SetLiveEdgeTransfer operation, and then resume the ingested stream.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the resumed ingested stream based on the configuration.|
  * |3\\. You ingest a stream after you call the SetLiveEdgeTransfer operation.|The configuration of edge stream relay is available.|Edge stream relay takes effect for the ingested stream based on the configuration.|
  * ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveEdgeTransfer  SetLiveEdgeTransferRequest
  * @return SetLiveEdgeTransferResponse
 */
async function setLiveEdgeTransfer(request: SetLiveEdgeTransferRequest): SetLiveEdgeTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveEdgeTransfer', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveLazyPullStreamInfoConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

>  If you want to configure triggered stream pulling for all applications, set the value to **ali_all_app**.

This parameter is required.', example='ali_all_app', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pullAppName?: string(name='PullAppName', description='The name of the application for back-to-origin stream pulling.

>  If you want to use the application specified in the streaming URL, leave this parameter empty.', example='livePullApp****', position='Query'),
  pullDomainName: string(name='PullDomainName', description='The origin server address of the live stream. Separate multiple addresses with semicolons (;).

This parameter is required.', example='guide.aliyundoc.com', position='Query'),
  pullProtocol: string(name='PullProtocol', description='The protocol for back-to-origin stream pulling. Valid values:

*   **rtmp**
*   **httpflv**
*   **hls**

This parameter is required.', example='rtmp', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  transcodeLazy?: string(name='TranscodeLazy', description='Specifies whether to trigger stream pulling when the transcoded stream is played. The default value is **no**. Valid values:

*   **yes**
*   **no**', example='no', position='Query'),
}

model SetLiveLazyPullStreamInfoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CF8'),
}

model SetLiveLazyPullStreamInfoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveLazyPullStreamInfoConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to configure triggered stream pulling. The configuration lets ApsaraVideo Live automatically pull live streams from the origin server when the origin server starts to play live streams.
  * >  The IPv6 protocol is not supported.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveLazyPullStreamInfoConfig  SetLiveLazyPullStreamInfoConfigRequest
  * @return SetLiveLazyPullStreamInfoConfigResponse
 */
async function setLiveLazyPullStreamInfoConfig(request: SetLiveLazyPullStreamInfoConfigRequest): SetLiveLazyPullStreamInfoConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveLazyPullStreamInfoConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveMpuTaskSeiRequest {
  appId: string(name='AppId', description='The application ID.

>  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='VKL3***', position='Query'),
  customSei: string(name='CustomSei', description='The custom SEI.

>  The value is a JSON string that can be up to 4,096 characters in length.

This parameter is required.', example='{"name":"myroom"}', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

>  The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='AL-4bce036dd90277c50705b0599wgfffc7', position='Query'),
}

model SetLiveMpuTaskSeiResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model SetLiveMpuTaskSeiResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveMpuTaskSeiResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * You can call this operation to configure custom SEI for a mixed-stream relay task.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveMpuTaskSei  SetLiveMpuTaskSeiRequest
  * @return SetLiveMpuTaskSeiResponse
 */
async function setLiveMpuTaskSei(request: SetLiveMpuTaskSeiRequest): SetLiveMpuTaskSeiResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveMpuTaskSei', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveStreamBlockRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveApp****', position='Query'),
  blockType: string(name='BlockType', description='The blocking type. Valid values: blacklist and whitelist.

This parameter is required.', example='blacklist', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  locationList: string(name='LocationList', description='The blocked region. If you specify multiple regions, such as CN and AS, separate them with commas (,).

This parameter is required.', example='CN', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  releaseTime?: string(name='ReleaseTime', description='The time when the blocking ends. The time must be in UTC. If you do not specify this parameter, the blocking is valid for 7 days by default.', example='2016-06-29T19:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='liveStream****', position='Query'),
}

model SetLiveStreamBlockResponseBody = {
  description?: string(name='Description', description='The result description.

*   If the request was successful, ok is returned.
*   If the request failed, the failure detail is returned.', example='ok'),
  requestId?: string(name='RequestId', description='The request ID.', example='3be7ade8-d907-483c-b24a-0dad4595beaf'),
  status?: string(name='Status', description='The status. Valid values:

*   ok: The request was successful.
*   fail: The request failed.

>  If any parameter failed to be configured, the request failed.', example='ok'),
}

model SetLiveStreamBlockResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveStreamBlockResponseBody(name='body'),
}

/**
  * @description You can configure up to 200 stream-level region blocking rules for a domain name. If there are rules in which the same application name and the same stream name are specified, the rule that is updated the most recently takes effect.
  * ### [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveStreamBlock  SetLiveStreamBlockRequest
  * @return SetLiveStreamBlockResponse
 */
async function setLiveStreamBlock(request: SetLiveStreamBlockRequest): SetLiveStreamBlockResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveStreamBlock', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveStreamDelayConfigRequest {
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  flvDelay?: int32(name='FlvDelay', description='The latency of FLV-based playback. Unit: seconds.

>  If this parameter is left empty, the latency is set to a value corresponding to the FlvLevel parameter.', example='8', position='Query'),
  flvLevel?: string(name='FlvLevel', description='The latency level of FLV-based playback. Ignore this parameter if the FlvDelay parameter is configured.

Valid values:

*   **short** (default): The latency is 4 seconds.
*   **medium**: The latency is 8 seconds.
*   **long**: The latency is 16 seconds.

>  If both the FlvDelay and FlvLevel parameters are left empty, FlvLevel is set to **short** by default.', example='medium', position='Query'),
  hlsDelay?: int32(name='HlsDelay', description='The latency of HLS-based playback. Unit: seconds.

>  If this parameter is left empty, the latency is set to a value corresponding to the HlsLevel parameter.', example='4', position='Query'),
  hlsLevel?: string(name='HlsLevel', description='The latency level of HLS-based playback. Ignore this parameter if the HlsDelay parameter is configured.

Valid values:

*   **short**: The latency is 3 seconds. This is the default value.
*   **medium**: The latency is 6 seconds.
*   **long**: The latency is 15 seconds.

>  If both the HlsDelay and HlsLevel parameters are left empty, HlsLevel is set to **short** by default.', example='short', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  rtmpDelay?: int32(name='RtmpDelay', description='The latency of RTMP-based playback. Unit: seconds.

>  If this parameter is left empty, the latency is set to a value corresponding to the RtmpLevel parameter.', example='4', position='Query'),
  rtmpLevel?: string(name='RtmpLevel', description='The latency level of RTMP-based playback. Ignore this parameter if the RtmpDelay parameter is configured.

Valid values:

*   **short** (default): The latency is 4 seconds.
*   **medium**: The latency is 8 seconds.
*   **long**: The latency is 16 seconds.

>  If both the RtmpDelay and RtmpLevel parameters are left empty, RtmpLevel is set to **short** by default.', example='short', position='Query'),
}

model SetLiveStreamDelayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='4C747C97-7ECD-4C61-8A92-67AD806331FF'),
}

model SetLiveStreamDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveStreamDelayConfigResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to configure the latency of a streaming domain.
  * *   Because an integer number of groups of pictures (GOPs) are cached, the latency is not less than the GOP size. The actual latency is calculated based on the GOP size. For example, if RtmpDelay is set to 4 seconds and the GOP size is 2 seconds, the minimum latency is 2 seconds (4 seconds minus 2 seconds) and the maximum latency is 6 seconds (4 seconds plus 2 seconds). If the GOP size is greater than the value of RtmpDelay, for example, the GOP size is 5 seconds and RtmpDelay is set to 4 seconds, the latency ranges from 0 to 9 seconds.
  * *   Configuration for the latency of an audio-only stream is invalid. By default, the latency is close to 0.
  * *   For HTTP Live Streaming (HLS)-based playback, the segment size equals the latency divided by 3. Round the value down to the nearest integer. The value cannot be less than 1 second. Then, calculate the maximum number of segments. If the segment size is greater than or equal to 3 seconds, the maximum number of segments is 4. Otherwise, the maximum number of segments is 6.
  * *   The actual HLS segment size is not smaller than the GOP size.
  * *   The latency of HLS-based playback equals the configured segment size times 3.
  * *   If you do not call this operation, the default latency is 2 seconds for Real-Time Messaging Protocol (RTMP)-based playback and 4 seconds for Flash Video (FLV)-based playback. By default, the size of an HLS segment is 5 seconds. In this case, the latency is 15 seconds and the maximum number of segments is 6.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveStreamDelayConfig  SetLiveStreamDelayConfigRequest
  * @return SetLiveStreamDelayConfigResponse
 */
async function setLiveStreamDelayConfig(request: SetLiveStreamDelayConfigRequest): SetLiveStreamDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveStreamDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveStreamPreloadTasksRequest {
  area?: string(name='Area', description='The acceleration region where you want to prefetch the live content. Valid values:

*   domestic: regions in the Chinese mainland.
*   overseas: regions outside the Chinese mainland.
*   global: regions in and outside the Chinese mainland.

If you do not specify this parameter, the acceleration region configured for the domain name is used.', example='domestic', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain name.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  playUrl: string(name='PlayUrl', description='The streaming URL. You can specify up to 100 streaming URLs in a request. Separate multiple streaming URLs with commas (,).

This parameter is required.', position='Query'),
  preloadedEndTime?: string(name='PreloadedEndTime', description='The end time of the prefetch task. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-30T19:00:00Z. The interval between the start time and end time cannot exceed 6 hours.', example='2016-06-30T19:00:00Z', position='Query'),
  preloadedStartTime?: string(name='PreloadedStartTime', description='The start time of the prefetch task. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC. Example: 2016-06-29T19:00:00Z. If you do not specify this parameter, the prefetch task runs for 1 hour by default.', example='2016-06-29T19:00:00Z', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model SetLiveStreamPreloadTasksResponseBody = {
  failedURL?: int32(name='FailedURL', description='The number of URLs for which the prefetch task configuration failed.', example='0'),
  preloadTasksMessages?: {
    preloadTasksMessage?: [ 
    {
      description?: string(name='Description', description='Indicates whether the prefetch task is successful. Valid values:

*   Successfully
*   InternalError', example='Successfully'),
      playUrl?: string(name='PlayUrl', description='The streaming URL.'),
      taskId?: string(name='TaskId', description='The ID of the prefetch task.', example='yourTaskId'),
    }
  ](name='PreloadTasksMessage')
  }(name='PreloadTasksMessages', description='The details of the prefetch task.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='36E0E523-E0C6-5D95-A465-A8EA2DCBA2A5'),
  status?: string(name='Status', description='The status of the prefetch task. Valid values:

*   Success
*   Failed

>  Success is returned only if the prefetch task is configured for all specified streaming URLs.', example='Success'),
  successURL?: int32(name='SuccessURL', description='The number of URLs for which the prefetch task is successfully configured.', example='1'),
  totalURL?: int32(name='TotalURL', description='The total number of URLs.', example='1'),
}

model SetLiveStreamPreloadTasksResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveStreamPreloadTasksResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to specify multiple URLs to prefetch at a time. You can specify up to 100 URLs in a request.
  * *   URLs in the HTTP Live Steaming (HLS) format are not supported.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveStreamPreloadTasks  SetLiveStreamPreloadTasksRequest
  * @return SetLiveStreamPreloadTasksResponse
 */
async function setLiveStreamPreloadTasks(request: SetLiveStreamPreloadTasksRequest): SetLiveStreamPreloadTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveStreamPreloadTasks', 'POST', '/', 'json', false, 'json', request);
}

model SetLiveStreamsNotifyUrlConfigRequest {
  regionId?: string(name='RegionId', position='Host'),
  domainName: string(name='DomainName', description='The ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  exceptionNotifyUrl?: string(name='ExceptionNotifyUrl', description='Exception event callback URL.', example='https://4a7e5f08.r37.cpolar.top/live/Rsssd/call-back/streamStart', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', description='The authentication key.

>  This parameter is required if you set the NotifyReqAuth parameter to **yes**.

Value requirements:

*   The key must be 16 to 64 characters in length.
*   The key can contain letters and digits.', example='123456', position='Query'),
  notifyReqAuth?: string(name='NotifyReqAuth', description='Specifies whether to enable callback authentication. Valid values:

*   **yes**: enables callback authentication. If you set this parameter to **yes**, you must also specify the NotifyAuthKey parameter.
*   **no**: disables callback authentication.

>  If you do not specify this parameter, the default value **no** is used.

For information about the authentication logic, see **Authentication for stream ingest callbacks**.', example='yes', position='Query'),
  notifyUrl?: string(name='NotifyUrl', description='The URL to which the stream ingest callbacks are sent.', example='http://guide.aliyundoc.com/notify', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  switchNotifyUrl?: string(name='SwitchNotifyUrl', position='Query'),
}

model SetLiveStreamsNotifyUrlConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='40A4F36D-A7CC-473A-88E7-154F92242566'),
}

model SetLiveStreamsNotifyUrlConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetLiveStreamsNotifyUrlConfigResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to configure the callback URL and authentication information of an ingest domain.
  * *   If you configure callbacks for stream ingest status, you can receive callback notifications about successful or interrupted stream ingest in a timely manner. For more information, see [Format of stream ingest callbacks](https://help.aliyun.com/document_detail/54787.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 15 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetLiveStreamsNotifyUrlConfig  SetLiveStreamsNotifyUrlConfigRequest
  * @return SetLiveStreamsNotifyUrlConfigResponse
 */
async function setLiveStreamsNotifyUrlConfig(request: SetLiveStreamsNotifyUrlConfigRequest): SetLiveStreamsNotifyUrlConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetLiveStreamsNotifyUrlConfig', 'POST', '/', 'json', false, 'json', request);
}

model SetShowListBackgroundRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  materialId?: string(name='MaterialId', description='The ID of the material in ApsaraVideo VOD.

>  Specify either this parameter or the ResourceUrl parameter.', example='a2b8e671-2fe5-4642-a2ec-bf93880e****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceType?: string(name='ResourceType', description='The resource type. Valid values:

*   LIVE: live stream. You can add a live stream from ApsaraVideo Live or by using a third-party URL.
*   VOD: on-demand video. You can add an on-demand video from ApsaraVideo VOD or by using a third-party URL.
*   PIC: image. You can add an image from ApsaraVideo VOD or by using a third-party URL.

>  Set this parameter to one of the preceding values, or leave this parameter empty.', example='VOD', position='Query'),
  resourceUrl?: string(name='ResourceUrl', description='The URL of the third-party material.', position='Query'),
}

model SetShowListBackgroundResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='987DA143-A39C-5B5D-AF5B-3B07944A0036'),
}

model SetShowListBackgroundResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetShowListBackgroundResponseBody(name='body'),
}

/**
  * @description *   Create a production studio in playlist mode, and then call this operation to add the background material. For information about how to create a production studio, see [CreateCaster](https://help.aliyun.com/document_detail/2848009.html).
  * *   You can call this operation to create, update, or delete the background of the episode list. To delete the background, leave the ResourceType, ResourceUrl, and MaterialId parameters empty.
  * > 
  * *   When you select media resources from ApsaraVideo VOD, we recommend that you select resources that are stored in hosted OSS buckets. Resources stored in non-hosted OSS buckets have a validity period. Pay attention to the validity if you select resources that are stored in non-hosted OSS buckets.
  * *   When you add media resources to a production studio, we recommend that you select resources from ApsaraVideo Live and ApsaraVideo VOD. If you add a third-party stream by specifying a streaming URL, there is a possibility that the stream fails to be played. You must pay attention to the quality and validity of the third-party stream.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetShowListBackground  SetShowListBackgroundRequest
  * @return SetShowListBackgroundResponse
 */
async function setShowListBackground(request: SetShowListBackgroundRequest): SetShowListBackgroundResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetShowListBackground', 'POST', '/', 'json', false, 'json', request);
}

model SetSnapshotCallbackAuthRequest {
  callbackAuthKey: string(name='CallbackAuthKey', description='The custom key that is used for callback authentication.

This parameter is required.', example='yourkey', position='Query'),
  callbackReqAuth: string(name='CallbackReqAuth', description='Specifies whether to enable callback authentication. Valid values:

*   **yes**: enables callback authentication.
*   **no**: disables callback authentication.

This parameter is required.', example='yes', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model SetSnapshotCallbackAuthResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD5'),
}

model SetSnapshotCallbackAuthResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: SetSnapshotCallbackAuthResponseBody(name='body'),
}

/**
  * @description *   Before you configure authentication for snapshot callbacks, you need to specify the callback URL. For more information, see [AddLiveAppSnapshotConfig](https://help.aliyun.com/document_detail/2847897.html).
  * *   You can call this operation to configure authentication for snapshot callbacks for a main streaming domain. Make sure that the parameter settings meet the requirements.
  * *   ApsaraVideo Live allows you to add a specific signature header to each HTTP or HTTPS callback request. This way, the server that receives callback messages can authenticate the signature to prevent illegal or invalid requests. For more information, see [Usage notes for callback authentication](https://help.aliyun.com/document_detail/417349.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of SetSnapshotCallbackAuth  SetSnapshotCallbackAuthRequest
  * @return SetSnapshotCallbackAuthResponse
 */
async function setSnapshotCallbackAuth(request: SetSnapshotCallbackAuthRequest): SetSnapshotCallbackAuthResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SetSnapshotCallbackAuth', 'POST', '/', 'json', false, 'json', request);
}

model StartCasterRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StartCasterResponseBody = {
  pgmSceneInfos?: {
    sceneInfo?: [ 
    {
      sceneId?: string(name='SceneId', description='The ID of the scene.', example='b5f8c837-ceeb-424f-b30b-68e94e86****'),
      streamInfos?: {
        streamInfo?: [ 
        {
          outputStreamUrl?: string(name='OutputStreamUrl', description='The URL.', example='rtmp://abclive/caster/example.net'),
          transcodeConfig?: string(name='TranscodeConfig', description='The transcoding configuration. Valid values:

*   **lsd**: standard definition
*   **lld**: low definition
*   **lud**: ultra-high definition
*   **lhd**: high definition', example='lld'),
          videoFormat?: string(name='VideoFormat', description='The format. Valid values:

*   **flv**
*   **rtmp**
*   **m3u8**', example='flv'),
        }
      ](name='StreamInfo')
      }(name='StreamInfos', description='The stream relay URLs.'),
      streamUrl?: string(name='StreamUrl', description='The streaming URL of the PGM scene in the production studio. The value is not a stream relay URL.', example='rtmp://abclive/caster/example.edu'),
    }
  ](name='SceneInfo')
  }(name='PgmSceneInfos', description='The PGM scenes.'),
  pvwSceneInfos?: {
    sceneInfo?: [ 
    {
      sceneId?: string(name='SceneId', description='The ID of the scene.', example='b5f8c837-ceeb-424f-b30b-68e94e86****'),
      streamUrl?: string(name='StreamUrl', description='The streaming URL of the PVW scene in the production studio. The value is not a stream relay URL.', example='rtmp://abclive/caster/example.net'),
    }
  ](name='SceneInfo')
  }(name='PvwSceneInfos', description='The PVW scenes.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6EBD1AC4-C34D-4AE1-963E-B688A228BE31'),
}

model StartCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartCasterResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to start the production studio. If the production studio does not have a PVW scene or a PGM scene, this operation creates and starts such scenes and starts audio and video processing tasks.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartCaster  StartCasterRequest
  * @return StartCasterResponse
 */
async function startCaster(request: StartCasterRequest): StartCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartCaster', 'POST', '/', 'json', false, 'json', request);
}

model StartCasterSceneRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This parameter takes effect only if the scene is a PVW scene.

This parameter is required.', example='242b4e2c-c30f-4442-85ba-2e3e4e3d****', position='Query'),
}

model StartCasterSceneResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
  streamUrl?: string(name='StreamUrl', description='The streaming URL of the scene. It is used for playback, but not for stream relay.', example='http://live/caster/example.org'),
}

model StartCasterSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartCasterSceneResponseBody(name='body'),
}

/**
  * @description You can call this operation to start a specified PVW scene.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartCasterScene  StartCasterSceneRequest
  * @return StartCasterSceneResponse
 */
async function startCasterScene(request: StartCasterSceneRequest): StartCasterSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartCasterScene', 'POST', '/', 'json', false, 'json', request);
}

model StartEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  jobId: string(name='JobId', description='The ID of the edge transcoding task.

This parameter is required.', example='****20b48fb04483915d4f2cd8ac****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StartEdgeTranscodeJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the edge transcoding task.', example='****20b48fb04483915d4f2cd8ac****'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model StartEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to start an edge transcoding task.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartEdgeTranscodeJob  StartEdgeTranscodeJobRequest
  * @return StartEdgeTranscodeJobResponse
 */
async function startEdgeTranscodeJob(request: StartEdgeTranscodeJobRequest): StartEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model StartLiveDomainRequest {
  domainName: string(name='DomainName', description='The ingest domain or streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model StartLiveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0AEDAF20-4DDF-4165-8750-47FF9C1929C9'),
}

model StartLiveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartLiveDomainResponseBody(name='body'),
}

/**
  * @description This operation does not work if the Alibaba Cloud account to which the domain name belongs has overdue payments or the domain name is invalid.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartLiveDomain  StartLiveDomainRequest
  * @return StartLiveDomainResponse
 */
async function startLiveDomain(request: StartLiveDomainRequest): StartLiveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartLiveDomain', 'POST', '/', 'json', false, 'json', request);
}

model StartLiveMPUTaskRequest {
  appId: string(name='AppId', description='The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  channelId: string(name='ChannelId', description='The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourChannelId', position='Query'),
  maxIdleTime?: string(name='MaxIdleTime', description='The timeout period of an idle connection. Unit: seconds. Valid values: [10,86400].

>  If the task is idle for a period of time longer than the duration specified by the MaxIdleTime parameter, the task is automatically stopped. If the parameter is not specified, the task is stopped after the channel is closed.', example='10', position='Query'),
  mixMode: string(name='MixMode', description='The stream mixing mode. Valid values:

*   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
*   **1** (default): the mixed-stream relay mode.

This parameter is required.', example='0', position='Query'),
  multiStreamURL?: [ 
    {
      isAliCdn?: boolean(name='IsAliCdn', description='Specifies whether to perform stream relay by using Alibaba Cloud CDN. Valid values:

*   false: performs stream relay by using a CDN service that is not Alibaba Cloud CDN.
*   true: performs stream relay by using Alibaba Cloud CDN.

>  The default value of this parameter is false.', example='false'),
      URL?: string(name='URL', description='The ingest URL. Only the RTMP format is supported. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).', example='rtmp://example.com/live/stream****'),
    }
  ](name='MultiStreamURL', description='The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.

>  The StreamURL and MultiStreamURL parameters are mutually exclusive. You must specify one of the two parameters.', shrink='json', position='Query'),
  region?: string(name='Region', description='The region in which the streams are mixed. Valid values:

*   **CN-Shanghai**
*   **AP-Singapore** (default)
*   **EMAA-Saudi**', example='CN-Shanghai', position='Query'),
  seiParams?: {
    layoutVolume?: {
      followIdr?: string(name='FollowIdr', description='Specifies whether to include the SEI in an Instantaneous Decoder Refresh (IDR) frame. Valid values:

*   **0**: does not include the SEI.
*   **1**: includes the SEI.', example='0'),
      interval?: string(name='Interval', description='The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.', example='1000'),
    }(name='LayoutVolume', description='The layout and volume SEI. If you leave this parameter empty, the default layout and volume SEI is used.'),
    passThrough?: {
      followIdr?: string(name='FollowIdr', description='Specifies whether to include the SEI in an IDR frame. Valid values:

*   **0**: does not include the SEI.
*   **1**: includes the SEI.', example='0'),
      interval?: string(name='Interval', description='The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.', example='1000'),
      payloadContent?: string(name='PayloadContent', description='The payload content of the SEI.', example='yourPayloadContent'),
      payloadContentKey?: string(name='PayloadContentKey', description='The key of the payload content of the SEI. If you do not specify this parameter, the default value udd is used.', example='yourPayloadContentKey'),
    }(name='PassThrough', description='Specifies whether to pass through the SEI.'),
    payloadType?: string(name='PayloadType', description='The custom payload_type of the SEI. Valid values: 100 to 254. If you do not specify this parameter, the default value 5 is used.', example='100'),
  }(name='SeiParams', description='The supplemental enhancement information (SEI) parameters.', shrink='json', position='Query'),
  singleSubParams?: {
    sourceType?: string(name='SourceType', description='The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
    streamType?: string(name='StreamType', description='The type of the stream that you want to relay. Valid values:

*   **0** (default): original stream
*   **1**: only the audio track
*   **2**: only the video track', example='0'),
    userId: string(name='UserId', description='The user ID. In the single-stream relay mode, you can relay only one stream in a request.

This parameter is required.', example='yourSubUserId'),
  }(name='SingleSubParams', description='The single-stream relay parameters. These parameters are required if you set MixMode to 0. Leave these parameters empty in the mixed-stream relay mode.', shrink='json', position='Query'),
  streamURL?: string(name='StreamURL', description='The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).

> 

*   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
*   You cannot use the same ingest URL in different tasks.
*   You cannot use the same ingest URL within 10 seconds after a task is stopped.', example='rtmp://example.com/live/stream', position='Query'),
  taskId: string(name='TaskId', description='The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.

This parameter is required.', example='yourTaskId', position='Query'),
  transcodeParams?: {
    background?: {
      renderMode?: string(name='RenderMode', description='The display mode of the global background image. Valid values:

*   **0**: scales the background image proportionally to fit the view, with black bars displayed.
*   **1** (default): crops the background image to fit the view.', example='1'),
      URL?: string(name='URL', description='The URL of the global background image. The URL can be up to 2,048 characters in length.', example='yourImageUrl'),
    }(name='Background', description='The global background image.'),
    encodeParams?: {
      audioBitrate?: string(name='AudioBitrate', description='The bitrate of the audio. Valid values: [8,500]. Unit: Kbit/s.', example='128'),
      audioChannels?: string(name='AudioChannels', description='The number of sound channels. Valid values: 1 and 2.', example='2'),
      audioOnly?: string(name='AudioOnly', description='Specifies whether the output stream is an audio-only stream. Valid values:

*   **true**: The output stream is an audio-only stream. If you set this parameter to true, you need to configure only audio-related parameters under EncodeParams.
*   **false** (default): The output stream is not an audio-only stream. If you set this parameter to false, you need to configure all parameters under EncodeParams, except the VideoCodec and EnhancedParam parameters.', example='false'),
      audioSampleRate?: string(name='AudioSampleRate', description='The audio sampling rate. Valid values: 8000, 16000, 32000, 44100, and 48000. Unit: Hz.', example='44100'),
      enhancedParam?: string(name='EnhancedParam', description='The parameter used for encoding enhancement, which is a JSON string. The parameter includes the optional profile and preset fields.

*   profile: the encoding level. If the video codec is H.264, the valid values of this field are baseline, main, and high. If the video codec is H.265, the valid value of this field is main.
*   preset: adjusts the trade-off between encoding speed and video quality. The valid values of this field are ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.

>  A value of superfast for the preset field is suitable for real-time communication scenarios. We recommend that you not set the field if you are not a professional encoding engineer.', example='{"profile": "high", "preset": "veryfast"}'),
      videoBitrate?: string(name='VideoBitrate', description='The bitrate of the video. Valid values: [1,10000]. Unit: Kbit/s.', example='3500'),
      videoCodec?: string(name='VideoCodec', description='The video codec. Valid values:

*   H.264 (default)
*   H.265', example='H.264'),
      videoFramerate?: string(name='VideoFramerate', description='The frame rate of the video. Valid values: [1,60]. Unit: frames per second (FPS).', example='25'),
      videoGop?: string(name='VideoGop', description='The group of pictures (GOP) size of the video. Valid values: [1,60].', example='20'),
      videoHeight?: string(name='VideoHeight', description='The height of the video. Valid values: [0,1920]. Unit: pixels.', example='1000'),
      videoWidth?: string(name='VideoWidth', description='The width of the video. Valid values: [0,1920]. Unit: pixels.', example='1920'),
    }(name='EncodeParams', description='The encoding parameters for the output stream.'),
    layout?: {
      userPanes?: [ 
        {
          backgroundImageUrl?: string(name='BackgroundImageUrl', description='The URL of the background image of the pane. The URL can be up to 2,048 characters in length. This image is displayed if the user turns off the camera or is not present in the channel.', example='yourImageUrl'),
          height?: string(name='Height', description='The height of the pane. The value is normalized.', example='0.2632'),
          renderMode?: string(name='RenderMode', description='The display mode of the pane. Valid values:

*   **0**: scales the video proportionally to fit the view, with black bars displayed.
*   **1 (default)**: crops the video to fit the view.', example='1'),
          userInfo?: {
            channelId?: string(name='ChannelId', description='The ID of the channel where the user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.', example='yourChannelId'),
            sourceType?: string(name='SourceType', description='The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
            userId?: string(name='UserId', description='The user ID.', example='yourSubUserId'),
          }(name='UserInfo', description='The information about the user whose stream is played in the pane. If you leave this parameter empty, the system automatically sets this parameter based on the order in which streamers join the channel.

> 

*   If you specify the information about a user by using this parameter, the information about the user must also be specified by using the TranscodeParams.UserInfos parameter.

*   This parameter is valid only when you set StreamType to 0 or 2.'),
          width?: string(name='Width', description='The width of the pane. The value is normalized.', example='0.3564'),
          x?: string(name='X', description='The x-coordinate of the pane. The value is normalized.', example='0.2456'),
          y?: string(name='Y', description='The y-coordinate of the pane. The value is normalized.', example='0.3789'),
          zOrder?: string(name='ZOrder', description='The layer in which the pane resides. A value of 0 indicates the bottom layer. Each increment of the value by 1 indicates the next upper layer.', example='0'),
        }
      ](name='UserPanes', description='The information about the panes.'),
    }(name='Layout', description='The video layout information.

>  If video transcoding is required, you must specify the video layout information, including the x-coordinate and y-coordinate, the width and height, and the layer. For audio-only transcoding, leave the video layout information empty.'),
    userInfos?: [ 
      {
        channelId?: string(name='ChannelId', description='The ID of the channel where the subscribed user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.', example='yourChannelId'),
        sourceType?: string(name='SourceType', description='The type of the video source that is subscribed to. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
        streamType?: string(name='StreamType', description='The type of the relayed stream that is subscribed to. Valid values:

*   **0** (default): original stream
*   **1**: only the audio track
*   **2**: only the video track', example='0'),
        userId: string(name='UserId', description='The ID of the subscribed user.

This parameter is required.', example='yourSubUserId'),
      }
    ](name='UserInfos', description='The information about the users whose streams are subscribed to. If you leave this parameter empty, streams from all users are mixed.'),
  }(name='TranscodeParams', description='The mixed-stream relay parameters. These parameters are required if you set MixMode to 1. Leave these parameters empty if you use the single-stream relay mode.', shrink='json', position='Query'),
}

model StartLiveMPUTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0F72851F-5DC1-1979-9B2C-450040316C3E'),
}

model StartLiveMPUTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartLiveMPUTaskResponseBody(name='body'),
}

/**
  * @description By default, you can create up to 200 single-stream relay tasks and up to 40 mixed-stream relay tasks for an application. To increase the quota, [submit a ticket](https://smartservice.console.aliyun.com/service/create-ticket).
  * ### [](#)Lifecycle of a stream relay task
  * **Start**
  * *   Call the StartLiveMPUTask operation to create a task.
  *     *   If no user joins the channel, an error indicating that the channel does not exist is returned.
  *     *   Stream relay is not performed if no stream is ingested. In this case, no relayed stream is available for playback.
  *     *   If the task is in the mixed-stream relay mode, make sure that at least one user is ingesting a stream, which can be relayed for playback. A black screen is displayed in the pane of a user who is not ingesting a stream.
  * *   We recommend that you record the task status, task mode, and task parameters on your business server.
  *     *   Task status: started or stopped.
  *     *   Task mode: single-stream relay or mixed-stream relay.
  *     *   Task parameters: the latest input parameters. For example, after your call of the UpdateLiveMPUTask operation is successful, record the task parameters, which are the latest.
  * *   In co-streaming or battle scenarios, the task is in the mixed-stream relay mode. If the streamer leaves the channel due to exceptions and re-joins the channel, you can directly call the StartLiveMPUTask operation on your business server to start stream relay based on the recorded task parameters.
  *     *   If the task has not been automatically cleared by the system, the task is directly started.
  *     *   If the task has not been automatically cleared by the system, a message indicating that **the task already exists** is returned.
  * **End**
  * *   After the streamer leaves the channel, you need to call the [StopLiveMPUTask](https://help.aliyun.com/document_detail/2362742.html) operation to stop the task.
  * *   If all users specified in the task have left the channel, but you do not call the StopLiveMPUTask operation, the system stops the task in 2 minutes.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartLiveMPUTask  StartLiveMPUTaskRequest
  * @return StartLiveMPUTaskResponse
 */
async function startLiveMPUTask(request: StartLiveMPUTaskRequest): StartLiveMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartLiveMPUTask', 'POST', '/', 'json', false, 'json', request);
}

model StartLiveStreamMonitorRequest {
  monitorId: string(name='MonitorId', description='The ID of the monitoring session.

>  You can obtain the monitoring session ID from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StartLiveStreamMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model StartLiveStreamMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartLiveStreamMonitorResponseBody(name='body'),
}

/**
  * @description You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartLiveStreamMonitor  StartLiveStreamMonitorRequest
  * @return StartLiveStreamMonitorResponse
 */
async function startLiveStreamMonitor(request: StartLiveStreamMonitorRequest): StartLiveStreamMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartLiveStreamMonitor', 'POST', '/', 'json', false, 'json', request);
}

model StartPlaylistRequest {
  offset?: int32(name='Offset', description='The offset of the position where the system starts the playback. This parameter takes effect only if the input source is a video file. Unit: milliseconds.

A value greater than 0 indicates an offset from the first frame.', example='10000', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resumeMode?: string(name='ResumeMode', description='The method to resume the playback of the episode list. Valid values:

*   **Restart**: resumes the playback from the beginning.
*   **Continue**: resumes the playback from the position where the previous playback stops. The **StartItemId** parameter is required only if you set **ResumeMode** to **Custom**.
*   **Custom**: resumes the playback from a custom position.', example='Custom', position='Query'),
  startItemId?: string(name='StartItemId', description='The ID of the first episode to play. This episode is the first to play in carousel playback.

>  This parameter is required only if you set ResumeMode to Custom.', example='asdfasdfasdf****', position='Query'),
}

model StartPlaylistResponseBody = {
  programId?: string(name='ProgramId', description='The ID of the episode list. You can use the ID as a request parameter in the API operation that is used to stop playing the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
  streamInfo?: {
    appName?: string(name='AppName', description='The name of the application.', example='liveApp****'),
    domainName?: string(name='DomainName', description='The main streaming domain.', example='example.com'),
    streamName?: string(name='StreamName', description='The name of the live stream.', example='liveStream****'),
    streams?: {
      stream?: [ 
      {
        pullFlvUrl?: string(name='PullFlvUrl', description='The streaming URL in the Flash Video (FLV) format.', example='http://aliyundoc.com/caster/liveStream****.flv?auth_key=1612772224-0-0-3632be7cd9907169e8b09e91099c****'),
        pullM3U8Url?: string(name='PullM3U8Url', description='The streaming URL in the Real-Time Messaging Protocol (RTMP) format.', example='rtmp:///aliyundoc.com/caster/liveStream****?auth_key=1612772224-0-0-4404ca59c0246226d49d01f734b1****'),
        pullRtmpUrl?: string(name='PullRtmpUrl', description='The streaming URL in the M3U8 format.', example='http://aliyundoc.com/caster/liveStream****.m3u8?auth_key=1612772224-0-0-919a023a127156fe82e3562c3b3b****'),
        quality?: string(name='Quality', description='The video quality of the live stream. Valid values: **original**: original quality', example='original'),
      }
    ](name='Stream')
    }(name='Streams', description='The streaming URLs.'),
  }(name='StreamInfo', description='The information about the live stream.'),
}

model StartPlaylistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartPlaylistResponseBody(name='body'),
}

/**
  * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to start playing the episode list.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StartPlaylist  StartPlaylistRequest
  * @return StartPlaylistResponse
 */
async function startPlaylist(request: StartPlaylistRequest): StartPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartPlaylist', 'POST', '/', 'json', false, 'json', request);
}

model StartRtcCloudRecordingRequest {
  appId: string(name='AppId', description='This parameter is required.', example='********-7074-****-9ef5-85c19a4*****', position='Query'),
  channelId: string(name='ChannelId', description='This parameter is required.', example='room1024', position='Query'),
  maxIdleTime?: long(name='MaxIdleTime', minimum=10, maximum=86400, position='Query'),
  mixLayoutParams?: {
    mixBackground?: {
      renderMode?: int32(name='RenderMode', example='0'),
      url?: string(name='Url', example='https://xxxx.com/photos/my-test-picture.png', maxLength=2048),
    }(name='MixBackground'),
    userPanes?: [ 
      {
        height?: string(name='Height', example='0.5'),
        sourceType?: int32(name='SourceType', example='0'),
        subBackground?: {
          renderMode?: int32(name='RenderMode', example='0'),
          url?: string(name='Url', example='https://xxxx.com/photos/my-test-pane-picture.png', maxLength=2048),
        }(name='SubBackground'),
        userId?: string(name='UserId', example='userA'),
        width?: string(name='Width', example='0.5'),
        x?: string(name='X', example='0'),
        y?: string(name='Y', example='0'),
        zOrder?: int32(name='ZOrder', example='0'),
      }
    ](name='UserPanes'),
  }(name='MixLayoutParams', shrink='json', position='Query'),
  mixTranscodeParams?: {
    audioBitrate: long(name='AudioBitrate', description='This parameter is required.', example='300', minimum=8, maximum=500),
    audioChannels: int32(name='AudioChannels', description='This parameter is required.', example='2'),
    audioSampleRate: long(name='AudioSampleRate', description='This parameter is required.', example='32000'),
    frameFillType?: int32(name='FrameFillType', example='0'),
    videoBitrate?: int32(name='VideoBitrate', example='5000', minimum=1, maximum=10000),
    videoCodec?: string(name='VideoCodec', example='H.264'),
    videoFramerate?: int32(name='VideoFramerate', example='30', minimum=1, maximum=60),
    videoGop?: int32(name='VideoGop', example='30', minimum=1, maximum=60),
    videoHeight?: int32(name='VideoHeight', example='480', minimum=0, maximum=1920),
    videoWidth?: int32(name='VideoWidth', example='640', minimum=0, maximum=1920),
  }(name='MixTranscodeParams', shrink='json', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', position='Query'),
  notifyUrl?: string(name='NotifyUrl', example='http://xxxx/test/mycallback', position='Query'),
  recordParams: {
    maxFileDuration?: long(name='MaxFileDuration', example='7200', minimum=180, maximum=7200),
    recordMode: int32(name='RecordMode', description='This parameter is required.', example='0'),
    streamType?: int32(name='StreamType', example='0'),
  }(name='RecordParams', description='This parameter is required.', shrink='json', position='Query'),
  storageParams: {
    fileInfo?: [ 
      {
        fileNamePattern?: string(name='FileNamePattern', example='{AppId}_{ChannelId}_{StartTime}_{UserId}'),
        filePathPrefix?: [ string ](name='FilePathPrefix'),
        format: string(name='Format', description='This parameter is required.', example='HLS'),
        sliceNamePattern?: string(name='SliceNamePattern', example='{AppId}_{ChannelId}_{StartTime}_{Sequence}'),
      }
    ](name='FileInfo'),
    OSSParams?: {
      OSSBucket: string(name='OSSBucket', description='This parameter is required.', example='mytest-bucket'),
      OSSEndpoint: string(name='OSSEndpoint', description='This parameter is required.', example='oss-cn-shanghai.aliyuncs.com'),
    }(name='OSSParams'),
    storageType: int32(name='StorageType', description='This parameter is required.', example='1'),
    vodParams?: {
      autoCompose?: int32(name='AutoCompose'),
      composeVodTranscodeGroupId?: string(name='ComposeVodTranscodeGroupId'),
      storageLocation?: string(name='StorageLocation'),
      vodTranscodeGroupId?: string(name='VodTranscodeGroupId'),
    }(name='VodParams'),
  }(name='StorageParams', description='This parameter is required.', shrink='json', position='Query'),
  subscribeParams: {
    subscribeUserIdList: [ 
      {
        sourceType?: int32(name='SourceType', example='0'),
        streamType?: int32(name='StreamType', example='0'),
        userId: string(name='UserId', description='This parameter is required.', example='userA'),
      }
    ](name='SubscribeUserIdList', description='This parameter is required.'),
  }(name='SubscribeParams', description='This parameter is required.', shrink='json', position='Query'),
}

model StartRtcCloudRecordingResponseBody = {
  requestId?: string(name='RequestId', example='******58-5876-****-83CA-B56278******'),
  taskId?: string(name='TaskId', example='******73-8501-****-8ac1-72295a******'),
}

model StartRtcCloudRecordingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StartRtcCloudRecordingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StartRtcCloudRecording  StartRtcCloudRecordingRequest
  * @return StartRtcCloudRecordingResponse
 */
async function startRtcCloudRecording(request: StartRtcCloudRecordingRequest): StartRtcCloudRecordingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartRtcCloudRecording', 'POST', '/', 'json', false, 'json', request);
}

model StopCasterRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StopCasterResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model StopCasterResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopCasterResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and call this operation to stop the production studio. When a production studio is stopped, its PVW and PGM scenes are stopped.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopCaster  StopCasterRequest
  * @return StopCasterResponse
 */
async function stopCaster(request: StopCasterRequest): StopCasterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopCaster', 'POST', '/', 'json', false, 'json', request);
}

model StopCasterSceneRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

If you create a production studio through the [CreateCaster](~~69338#doc-api-live-CreateCaster~~ "Creates a production studio.") interface, check the value of the CasterId parameter in the response.

If you create a production studio through the ApsaraVideo Live Console, log in to the console, then check the ID of the production studio through the following path:

Production Studios > Production Studio Management

>  The CasterId is reflected in the Name column on the Production Studio Management page.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This operation is available only when the scene is a preview scene. For more information about the scene types, see [Query the scenes of production studios](https://help.aliyun.com/document_detail/60262.html).

This parameter is required.', example='242b4e2c-c30f-4442-85ba-2e3e4e3d****', position='Query'),
}

model StopCasterSceneResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model StopCasterSceneResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopCasterSceneResponseBody(name='body'),
}

/**
  * @description ## Usage note
  * This operation is only applicable to the PVW scenes.
  * @param request  the request parameters of StopCasterScene  StopCasterSceneRequest
  * @return StopCasterSceneResponse
 */
async function stopCasterScene(request: StopCasterSceneRequest): StopCasterSceneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopCasterScene', 'POST', '/', 'json', false, 'json', request);
}

model StopEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  jobId: string(name='JobId', description='The ID of the edge transcoding task.

This parameter is required.', example='****20b48fb04483915d4f2cd8ac****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StopEdgeTranscodeJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the edge transcoding task.', example='****20b48fb04483915d4f2cd8ac****'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model StopEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to stop an edge transcoding task.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is running.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopEdgeTranscodeJob  StopEdgeTranscodeJobRequest
  * @return StopEdgeTranscodeJobResponse
 */
async function stopEdgeTranscodeJob(request: StopEdgeTranscodeJobRequest): StopEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model StopLiveDomainRequest {
  domainName: string(name='DomainName', description='The streaming domain or ingest domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model StopLiveDomainResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='324AEFFF-308C-4DA7-8CD3-01B277B98F28'),
}

model StopLiveDomainResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopLiveDomainResponseBody(name='body'),
}

/**
  * @description After you disable a domain name, the information about the domain name is retained. ApsaraVideo Live automatically reroutes all requests that are destined for the domain name to the origin.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopLiveDomain  StopLiveDomainRequest
  * @return StopLiveDomainResponse
 */
async function stopLiveDomain(request: StopLiveDomainRequest): StopLiveDomainResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLiveDomain', 'POST', '/', 'json', false, 'json', request);
}

model StopLiveMPUTaskRequest {
  appId: string(name='AppId', description='The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  taskId: string(name='TaskId', description='The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.

This parameter is required.', example='yourTaskId', position='Query'),
}

model StopLiveMPUTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='0F72851F-5DC1-1979-9B2C-450040316C3E'),
}

model StopLiveMPUTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopLiveMPUTaskResponseBody(name='body'),
}

/**
  * @description *   Make sure that a mixed-stream relay task is started before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to start a mixed-stream relay task.
  * *   If a mixed-stream relay task becomes abnormal, the task is automatically stopped 2 minutes after the last person leaves the channel. In this case, you do not need to call the StopLiveMPUTask operation. If you need to resume a mixed-stream relay task that is stopped, call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation again.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopLiveMPUTask  StopLiveMPUTaskRequest
  * @return StopLiveMPUTaskResponse
 */
async function stopLiveMPUTask(request: StopLiveMPUTaskRequest): StopLiveMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLiveMPUTask', 'POST', '/', 'json', false, 'json', request);
}

model StopLivePullToPushRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region of the live center. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='preregion', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

This parameter is required.', example='3bb44350-0c34-49c7-8c5e-cba5e6c0****', position='Query'),
}

model StopLivePullToPushResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='a05e6b15-15af-405b-a4a2-0152245d****'),
  taskId?: string(name='TaskId', description='The new task ID.', example='fb0d4ac7-c7e3-4978-9743-0bf2f6e8****'),
}

model StopLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopLivePullToPushResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to stop a pulled-stream relay task.
  * *   You can stop a task that is running (even if the task is in an abnormal retry state). You cannot stop a task that is not running.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopLivePullToPush  StopLivePullToPushRequest
  * @return StopLivePullToPushResponse
 */
async function stopLivePullToPush(request: StopLivePullToPushRequest): StopLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLivePullToPush', 'GET', '/', 'json', false, 'json', request);
}

model StopLiveStreamMonitorRequest {
  monitorId: string(name='MonitorId', description='The ID of the monitoring session.

>  You can obtain the monitoring session ID**** from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StopLiveStreamMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model StopLiveStreamMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopLiveStreamMonitorResponseBody(name='body'),
}

/**
  * @description Before you call this operation to stop live monitoring, make sure that live monitoring is started. You can call the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation to create a monitoring session, obtain the value of the response parameter **MonitorId**, and then start live monitoring.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopLiveStreamMonitor  StopLiveStreamMonitorRequest
  * @return StopLiveStreamMonitorResponse
 */
async function stopLiveStreamMonitor(request: StopLiveStreamMonitorRequest): StopLiveStreamMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopLiveStreamMonitor', 'POST', '/', 'json', false, 'json', request);
}

model StopPlaylistRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  programId: string(name='ProgramId', description='The ID of the episode list. If the episode list was created by calling the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation, check the value of the response parameter ProgramId to obtain the ID.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model StopPlaylistResponseBody = {
  programId?: string(name='ProgramId', description='The ID of the episode list.', example='445409ec-7eaa-461d-8f29-4bec2eb9****'),
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b96****'),
}

model StopPlaylistResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopPlaylistResponseBody(name='body'),
}

/**
  * @description You can call the [AddPlaylistItems](https://help.aliyun.com/document_detail/2848078.html) operation to add episodes to an episode list and then call this operation to stop playing the episode list.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopPlaylist  StopPlaylistRequest
  * @return StopPlaylistResponse
 */
async function stopPlaylist(request: StopPlaylistRequest): StopPlaylistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopPlaylist', 'POST', '/', 'json', false, 'json', request);
}

model StopRtcAsrTaskRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  taskId: string(name='TaskId', description='The ID of the task.

This parameter is required.', example='asr-d794cc89-a63e-4d08-8b44-242a6597****', position='Query'),
}

model StopRtcAsrTaskResponseBody = {
  description?: string(name='Description', description='The result of the request. If success is returned, the request is successful. If an error message is returned, the request failed.', example='success'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3D208CC1-27C9-51E9-82B8-A6682D466421'),
  retCode?: long(name='RetCode', description='The returned HTTP status code. HTTP status code 2000 indicates that the request is successful. If another HTTP status code is returned, the request failed.', example='2000'),
}

model StopRtcAsrTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopRtcAsrTaskResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 20 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of StopRtcAsrTask  StopRtcAsrTaskRequest
  * @return StopRtcAsrTaskResponse
 */
async function stopRtcAsrTask(request: StopRtcAsrTaskRequest): StopRtcAsrTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopRtcAsrTask', 'POST', '/', 'json', false, 'json', request);
}

model StopRtcCloudRecordingRequest {
  taskId: string(name='TaskId', description='This parameter is required.', example='******73-8501-****-8ac1-72295a******', position='Query'),
}

model StopRtcCloudRecordingResponseBody = {
  requestId?: string(name='RequestId', example='******58-5876-****-83CA-B56278******'),
  taskId?: string(name='TaskId', example='******73-8501-****-8ac1-72295a******'),
}

model StopRtcCloudRecordingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: StopRtcCloudRecordingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of StopRtcCloudRecording  StopRtcCloudRecordingRequest
  * @return StopRtcCloudRecordingResponse
 */
async function stopRtcCloudRecording(request: StopRtcCloudRecordingRequest): StopRtcCloudRecordingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopRtcCloudRecording', 'POST', '/', 'json', false, 'json', request);
}

model TagLiveResourcesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', description='The type of the resources. Set the value to **DOMAIN**.

This parameter is required.', example='example.com', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', example='DOMAIN', position='Query'),
  tag: [ 
    {
      key: string(name='Key', description='This parameter is required.', example='env'),
      value?: string(name='Value', example='product'),
    }
  ](name='Tag', description='This parameter is required.', position='Query'),
}

model TagLiveResourcesResponseBody = {
  requestId?: string(name='RequestId', example='34AB41F1-04A5-496F-8C8D-634BDBE6A9FB'),
}

model TagLiveResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: TagLiveResourcesResponseBody(name='body'),
}

/**
  * @description The key of the tag. Valid values of N: **1 to 20**.
  * @param request  the request parameters of TagLiveResources  TagLiveResourcesRequest
  * @return TagLiveResourcesResponse
 */
async function tagLiveResources(request: TagLiveResourcesRequest): TagLiveResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagLiveResources', 'POST', '/', 'json', false, 'json', request);
}

model UnTagLiveResourcesRequest {
  all?: boolean(name='All', example='false', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', description='This parameter is required.', example='example.com', position='Query'),
  resourceType: string(name='ResourceType', description='This parameter is required.', example='DOMAIN', position='Query'),
  tagKey?: [ string ](name='TagKey', example='env', position='Query'),
}

model UnTagLiveResourcesResponseBody = {
  requestId?: string(name='RequestId', example='97C68796-EB7F-4D41-9D5B-12B909D76508'),
}

model UnTagLiveResourcesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnTagLiveResourcesResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UnTagLiveResources  UnTagLiveResourcesRequest
  * @return UnTagLiveResourcesResponse
 */
async function unTagLiveResources(request: UnTagLiveResourcesRequest): UnTagLiveResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnTagLiveResources', 'POST', '/', 'json', false, 'json', request);
}

model UnbanLiveMessageGroupRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='demo', position='Query'),
  dataCenter?: string(name='DataCenter', description='The data center. It must be the same as the data center that was specified when you called the [CreateLiveMessageApp](https://help.aliyun.com/document_detail/2848162.html) operation to create the interactive messaging application.

>  Valid values: cn-shanghai and ap-southeast-1 (Singapore).', example='cn-shanghai', position='Query'),
  groupId: string(name='GroupId', description='The group ID.

This parameter is required.', example='grouptest', position='Query'),
}

model UnbanLiveMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='84AF36BF-0B39-1F8A-A416-FAC7C484****'),
}

model UnbanLiveMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UnbanLiveMessageGroupResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you have called the [CreateLiveMessageGroup](https://help.aliyun.com/document_detail/2848163.html) operation to create an interactive messaging group.
  * *   If a user was muted by calling the AddLiveMessageGroupBand operation, the user remains muted even after you call the UnbanLiveMessageGroup operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UnbanLiveMessageGroup  UnbanLiveMessageGroupRequest
  * @return UnbanLiveMessageGroupResponse
 */
async function unbanLiveMessageGroup(request: UnbanLiveMessageGroupRequest): UnbanLiveMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnbanLiveMessageGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCasterResourceGroupRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

This parameter is required.', example='a41300c9-23d3-470e-b9bd-****663e0700', position='Query'),
  newResourceGroupId: string(name='NewResourceGroupId', description='The ID of the destination resource group.

This parameter is required.', example='rg-aekz7***34cn5ty', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateCasterResourceGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0D776BD1-****-59D0-9A1B-272832D999F6'),
}

model UpdateCasterResourceGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCasterResourceGroupResponseBody(name='body'),
}

/**
  * @description ## [](#)Usage notes
  * To call this operation to change the resource group to which a production studio belongs, you must have access permissions on the original resource group and the destination resource group.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of UpdateCasterResourceGroup  UpdateCasterResourceGroupRequest
  * @return UpdateCasterResourceGroupResponse
 */
async function updateCasterResourceGroup(request: UpdateCasterResourceGroupRequest): UpdateCasterResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCasterResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCasterSceneAudioRequest {
  audioLayer?: [ 
    {
      filter?: string(name='Filter', description='Specifies whether to enable the features provided by the audio 3A algorithms. This parameter consists of the following fields:

*   **enableAgc**: specifies whether to enable automatic gain control (AGC). This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that AGC is disabled. **1** specifies that AGC is enabled.
*   **enableAns**: specifies whether to enable active noise suppression (ANS). This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that ANS is disabled. **1** specifies that ANS is enabled.
*   **ansMode**: specifies the mode for ANS. This field is optional and takes effect only if you set **enableAns** to **1**. Valid values: 0 and 1. **0** is the default value, which specifies the speech noise reduction mode. **1** specifies the music noise reduction mode.

>  To ensure a better noise reduction effect, we recommend that you set ansMode to 1.

*   **enableBeautify**: specifies whether to enable voice change. This field is optional. Valid values: 0 and 1. **0** is the default value, which specifies that voice change is disabled. **1** specifies that voice change is enabled.
*   **voiceBeautifyMode**: specifies the mode for voice change. This field is optional and takes effect only if you set **enableBeautify** to **1**. Valid values: 0 and 1. **0** is the default value, which specifies the magnetic male voice mode. **1** specifies the fresh female voice mode.', example='{   "enableAgc":0,   "enableAns":1 }'),
      fixedDelayDuration?: int32(name='FixedDelayDuration', description='The fixed delay of the audio layer. This parameter is used to synchronize the audio with subtitles.

Unit: milliseconds. Valid values: **0 to 5000**. Default value: **0**.', example='0'),
      validChannel?: string(name='ValidChannel', description='The sound channels that are used for volume input in the audio layer. Valid values:

*   **leftChannel**: the left channel
*   **rightChannel**: the right channel
*   **all** (default): both the left and right channels', example='all'),
      volumeRate?: float(name='VolumeRate', description='The multiple of the original volume at which the audio layer plays audio. Valid values: **0 to 10.0**. Default value: **1.0**.

*   **1.0**: specifies that the audio layer plays audio at the original volume.
*   A value smaller than **1**: specifies that the audio layer plays audio at a volume that is less than the original volume.
*   A value greater than **1**: specifies that the audio layer plays audio at a volume that is more than the original volume.', example='1'),
    }
  ](name='AudioLayer', description='The audio configurations.', position='Query'),
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='LIVEPRODUCER_POST-cn-0pp1czt****', position='Query'),
  followEnable?: int32(name='FollowEnable', description='The audio mode. By default, the AFV mode is used. If you do not specify this parameter, the scene retains the last configuration. Valid values:

*   **0**: the audio mixing mode.
*   **1**: the AFV mode.', example='1', position='Query'),
  mixList?: [ string ](name='MixList', description='The location IDs of the audio layers, which are in the same order as the audio layers.', example='RV01', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene. If you call the [DescribeCasterScenes](https://help.aliyun.com/document_detail/2848039.html) operation to query scenes of the production studio, check the value of the response parameter ComponentId to obtain the ID.

This parameter is required.', example='a2b8e671-2fe5-4642-a2ec-bf93880e1****', position='Query'),
}

model UpdateCasterSceneAudioResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateCasterSceneAudioResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCasterSceneAudioResponseBody(name='body'),
}

/**
  * @description You can call the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation to create a production studio and then call this operation to modify the audio configurations of a scene in the production studio. This operation supports the audio mixing mode and the audio follows video (AFV) mode.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateCasterSceneAudio  UpdateCasterSceneAudioRequest
  * @return UpdateCasterSceneAudioResponse
 */
async function updateCasterSceneAudio(request: UpdateCasterSceneAudioRequest): UpdateCasterSceneAudioResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCasterSceneAudio', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCasterSceneConfigRequest {
  casterId: string(name='CasterId', description='The ID of the production studio.

*   If the production studio was created by calling the [CreateCaster](https://help.aliyun.com/document_detail/2848009.html) operation, check the value of the response parameter CasterId to obtain the ID.
*   If the production studio was created by using the ApsaraVideo Live console, obtain the ID on the **Production Studio Management** page. To go to the page, log on to the **ApsaraVideo Live console** and click **Production Studios** in the left-side navigation pane.

>  You can find the ID of the production studio in the Instance ID/Name column.

This parameter is required.', example='80787064-1c94-4dc1-85ce-9409960a****', position='Query'),
  componentId?: [ string ](name='ComponentId', description='The IDs of the components. Components in the scene are listed from the bottom to the top in an array.

>  N indicates a sequence number. Examples:\\
ComponentId.1 indicates the ID of the first component.\\
ComponentId.2 indicates the ID of the second component.', example='["98778372-c30f-4442-85ba-2e3e4e3d****"]', position='Query'),
  layoutId: string(name='LayoutId', description='The ID of the layout. If you call the [DescribeCasterLayouts](https://help.aliyun.com/document_detail/2848028.html) operation to query the layouts of the production studio, check the value of the response parameter LayoutId to obtain the ID.

This parameter is required.', example='eeab74fb-379d-4599-a93d-86d16a05****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sceneId: string(name='SceneId', description='The ID of the scene.

This parameter is required.', example='242b4e2c-c30f-4442-85ba-2e3e4e3d****', position='Query'),
}

model UpdateCasterSceneConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='CF60DB6A-7FD6-426E-9288-122CC1A52FA7'),
}

model UpdateCasterSceneConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCasterSceneConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify a scene, including the layout, without invalidating the previous configurations. This operation is more efficient than the SetCasterSceneConfig operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateCasterSceneConfig  UpdateCasterSceneConfigRequest
  * @return UpdateCasterSceneConfigResponse
 */
async function updateCasterSceneConfig(request: UpdateCasterSceneConfigRequest): UpdateCasterSceneConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCasterSceneConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateCustomLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the stream belongs, and it cannot be modified.

This parameter is required.', example='liveApp****', position='Query'),
  audioBitrate?: int32(name='AudioBitrate', description='Audio transcoding bitrate. Unit: kbps, value range: 1 to 1000.', example='512', position='Query'),
  audioChannelNum?: int32(name='AudioChannelNum', description='Number of audio channels. Values: 
- 1: Mono. 
- 2: Stereo.', example='2', position='Query'),
  audioCodec?: string(name='AudioCodec', description='Audio encoding format. Values: 
- aac 
- mp3', example='aac', position='Query'),
  audioProfile?: string(name='AudioProfile', description='Audio encoding. Values: 
- aac_low
 - aac_he
 - aac_he_v2 
- aac_ld', example='aac_low', position='Query'),
  audioRate?: int32(name='AudioRate', description='Audio sampling rate. Values: 22050, 32000, 44100, 48000, 96000. Unit: Hz.
> If **AudioProfile** is set to **aac_ld**, the sampling rate must not exceed 44100.', example='96000', position='Query'),
  bitrateWithSource?: string(name='BitrateWithSource', description='The source-based bitrate settings. This parameter takes precedence over other bitrate settings. The following fields must be included:

*   **UpLimit**: the maximum bitrate. Set this field to an integer from 128 to 10000. The value must be greater than the minimum bitrate.
*   **LowerLimit**: the minimum bitrate. Set this field to an integer from 128 to 10000. The value must be smaller than the maximum bitrate.
*   **Factor**: the ratio of the output bitrate to the source bitrate. Valid values: 0.1 to 1. The value is accurate to one decimal place. A value of 1 indicates that the output video has the same bitrate as the source video.', example='{\\"UpLimit\\":2500,\\"LowerLimit\\":800,\\"Factor\\":1}', position='Query'),
  deInterlaced?: boolean(name='DeInterlaced', position='Query'),
  domain: string(name='Domain', description='Streamer domain name, unmodifiable.

This parameter is required.', example='example.com', position='Query'),
  encryptParameters?: string(name='EncryptParameters', description='Encryption configuration. JSON format, with the following fields: 
-  EncryptType: Type of encryption. Fixed value is aliyun.
 -  KmsKeyID: User\\"s KMS master key ID. 
-  KmsKeyExpireInterval: Key rotation period. Value range: 60~3600, unit: seconds.
> When using DRM encryption, KmsKeyID cannot be modified.', example='{"EncryptType": "aliyun", "KmsKeyID":"afce5722-81d2-43c3-9930-7601da11****","KmsKeyExpireInterval":"3600"}', position='Query'),
  extWithSource?: string(name='ExtWithSource', description='Other source-based settings. The following fields are included:

*   **KeyFrameOpen**: Valid values: yes and no.
*   **Copyts**: Valid values: yes and no.
*   **SeiMode**: Valid values: 0, 1, and 2. 0 specifies that no supplemental enhancement information (SEI) messages are passed through, 1 specifies that part of SEI messages are passed through, and 2 specifies that all SEI messages are passed through.', example='{\\"KeyFrameOpen\\":\\"yes\\",\\"Copyts\\":\\"yes\\",\\"SeiMode\\":1}', position='Query'),
  FPS?: int32(name='FPS', description='Transcode video frame rate. Unit: FPS, value range: 1 to 60.', example='30', position='Query'),
  fpsWithSource?: string(name='FpsWithSource', description='The source-based frame rate settings. This parameter takes precedence over other frame rate settings. The following fields must be included:

*   **UpLimit**: the maximum frame rate. Set this field to an integer from 1 to 60. The value must be greater than the minimum frame rate.
*   **LowerLimit**: the minimum frame rate. Set this field to an integer from 1 to 60. The value must be smaller than the maximum frame rate.', example='{\\"UpLimit\\":60,\\"LowerLimit\\":1}', position='Query'),
  gop?: string(name='Gop', description='Video GOP (Group of Pictures), supports units in frames or seconds. When the unit is frames, the value should be {number}; when the unit is seconds, the value should be {number}s. 
- For frames, the range is 1 to 3000. 
- For seconds, the range is 1 to 20s.', example='1', position='Query'),
  height?: int32(name='Height', description='Video transcoding height. Unit: pixels. The value must meet the following three conditions:
 - Height ≥ 100: The height of the video must be no less than 100 pixels.
 - max(Height, Width) ≤ 2560: The larger of the video\\"s width and height cannot exceed 2560.
 - min(Height, Width) ≤ 1440: The smaller of the video\\"s width and height cannot exceed 1440.
 > For 265 narrowband HD templates, the maximum resolution is 1280×720.', example='720', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to enable triggered transcoding. Valid values:

*   **yes**: enables triggered transcoding.
*   **no**: disables triggered transcoding.', example='yes', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  profile?: int32(name='Profile', description='Encoding level. A set of specific encoding features supported by the video, generally, the higher the value, the better the picture quality, but also the higher the resources consumed for encoding and decoding. Values: 
- 1: baseline (suitable for mobile devices).
 - 2: main (suitable for standard resolution devices). 
- 3: high (suitable for high-resolution devices).', example='2', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resWithSource?: string(name='ResWithSource', description='The source-based resolution settings. This parameter takes precedence over other resolution settings. The following fields must be included:

*   **Type**: You can set this field to short, long, or screen. short specifies that the resolution of the output video is adapted to the shorter side, long specifies that the resolution of the output video is adapted to the longer side, and screen specifies that the output video has an adaptive resolution.

*   **Value**:

    *   Set this field to 360, 480, 540, 720, or 1080 if the Type field is set to short.
    *   Set this field to 640, 848, 960, 1280, or 1920 if the Type field is set to long.
    *   Set this field to 640\\*360, 848\\*480, 960\\*540, 1280\\*720, or 1920\\*1080 if the Type field is set to screen.', example='{\\"Type\\":\\"short\\",\\"Value\\":\\"1080\\"}', position='Query'),
  template: string(name='Template', description='Custom name of the transcoding template, not modifiable.

This parameter is required.', example='LiveCusTranscode****', position='Query'),
  templateType: string(name='TemplateType', description='Custom transcoding template type, unmodifiable.

This parameter is required.', example='h264', position='Query'),
  videoBitrate?: int32(name='VideoBitrate', description='Video transcoding bitrate. Unit: kbps, value range: 1 to 6000.
> The actual bitrate of the transcoded video will try to be as close as possible to the one you set, but it cannot be guaranteed to be exactly the same, especially when the set bitrate is too high or too low.', example='720', position='Query'),
  width?: int32(name='Width', description='Video transcoding width. Unit: pixels. The value must meet the following three conditions: 
- Width ≥ 100: The video width must be no less than 100 pixels. 
- max(Height, Width) ≤ 2560: The larger of the video\\"s height and width cannot exceed 2560. 
- min(Height, Width) ≤ 1440: The smaller of the video\\"s height and width cannot exceed 1440.
> For 265 narrowband HD templates, the maximum resolution is 1280×720.', example='576', position='Query'),
}

model UpdateCustomLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateCustomLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateCustomLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description This operation supports the following types of custom transcoding templates:
  * *   h264: custom H.264 standard transcoding.
  * *   h264-nbhd: custom H.264 Narrowband HD™ transcoding.
  * *   h265: custom H.265 standard transcoding.
  * *   h265-nbhd: custom H.265 Narrowband HD™ transcoding.
  * *   audio: audio-only transcoding.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account.
  * @param request  the request parameters of UpdateCustomLiveStreamTranscode  UpdateCustomLiveStreamTranscodeRequest
  * @return UpdateCustomLiveStreamTranscodeResponse
 */
async function updateCustomLiveStreamTranscode(request: UpdateCustomLiveStreamTranscodeRequest): UpdateCustomLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateCustomLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEdgeTranscodeJobRequest {
  clusterId: string(name='ClusterId', description='The ID of the data center.

This parameter is required.', example='******3b-4d18-395c-8106-ff21a6******', position='Query'),
  jobId: string(name='JobId', description='The ID of the edge transcoding task.

This parameter is required.', example='****20b48fb04483915d4f2cd8ac****', position='Query'),
  name?: string(name='Name', description='The task name.', example='task1', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamInput?: string(name='StreamInput', description='The URL of the input stream.', example='rtmp://mydomain/app/stream1', position='Query'),
  streamOutput?: string(name='StreamOutput', description='The URL of the output stream.', example='rtmp://testdomain/app/stream2', position='Query'),
  templateId?: string(name='TemplateId', description='The template ID.', example='****96e8864746a0b6f3****', position='Query'),
}

model UpdateEdgeTranscodeJobResponseBody = {
  jobId?: string(name='JobId', description='The ID of the edge transcoding task.', example='****20b48fb04483915d4f2cd8ac****'),
  requestId?: string(name='RequestId', description='The request ID.', example='******3B-0E1A-586A-AC29-742247******'),
}

model UpdateEdgeTranscodeJobResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEdgeTranscodeJobResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to update an edge transcoding task.
  * *   To call this operation, make sure that you have the permissions to access the edge transcoding feature and the edge transcoding task that you specify is not started.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 6,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateEdgeTranscodeJob  UpdateEdgeTranscodeJobRequest
  * @return UpdateEdgeTranscodeJobResponse
 */
async function updateEdgeTranscodeJob(request: UpdateEdgeTranscodeJobRequest): UpdateEdgeTranscodeJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEdgeTranscodeJob', 'POST', '/', 'json', false, 'json', request);
}

model UpdateEventSubRequest {
  appId: string(name='AppId', description='The application ID.

This parameter is required.', example='9qb1****', position='Query'),
  callbackUrl: string(name='CallbackUrl', description='The callback URL. For more information about the callback content, see CreateEventSub.

This parameter is required.', example='http://****.com/callback', position='Query'),
  channelId?: string(name='ChannelId', description='The channel ID. You can call the [ListEventSub](https://help.aliyun.com/document_detail/2848210.html) operation to query the channel ID.

> 

*   This parameter is required if you specify the Users.N parameter.

*   If you set this parameter to \\* or do not specify this parameter, all channels are subscribed to.

*   You can create up to 20 subscriptions for each application ID.', example='123333', position='Query'),
  events: [ string ](name='Events', description='The type of the events to which you want to subscribe.

This parameter is required.', position='Query'),
  subscribeId: string(name='SubscribeId', description='The subscription ID. You can obtain the ID from the response to the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation.

This parameter is required.', example='ad53276431c****', position='Query'),
  users?: [ string ](name='Users', description='The user whose events you want to subscribe to.', position='Query'),
}

model UpdateEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='AE050E24-BE9B-1E79-BB30-7EA0BBAE7F08'),
}

model UpdateEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateEventSubResponseBody(name='body'),
}

/**
  * @description *   Before you call this operation, make sure that you have called the [CreateEventSub](https://help.aliyun.com/document_detail/2848209.html) operation to create a callback that is used to subscribe to channel or user events.
  * *   An existing channel that you specify in this operation still uses its original callback configuration. The updated configuration can apply to the channel only if you restart the channel after it is closed for longer than 20 minutes.
  * *   If you only want to update specific parameters, you must also specify the other required parameters with their original values.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateEventSub  UpdateEventSubRequest
  * @return UpdateEventSubResponse
 */
async function updateEventSub(request: UpdateEventSubRequest): UpdateEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateEventSub', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAIProduceRulesRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs.

This parameter is required.', example='AppName', position='Query'),
  description?: string(name='Description', description='The description of the subtitle rule. The description can be up to 128 characters in length and can contain letters, digits, and special characters.', example='live AI subtitle template', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='demo.aliyundoc.com', position='Query'),
  isLazy?: boolean(name='IsLazy', description='Specifies whether to generate live subtitles when stream pulling starts. Valid values:

*   true: generates live subtitles when stream pulling starts and stops generating live subtitles when no streams are pulled for 5 minutes. When stream pulling restarts, live subtitles are generated again.
*   false: generates live subtitles when stream ingest starts.', example='true', position='Query'),
  liveTemplate?: string(name='LiveTemplate', description='The specification of the output subtitles. Valid values:

*   `lp_ld`: 360p (640 × 360)
*   `lp_ld_v`: 360p (360 × 640)
*   `lp_sd`: 480p (854 × 480)
*   `lp_sd_v`: 480p (480 × 854)
*   `lp_hd`: 720p (1280 × 720)
*   `lp_hd_v`: 720p (720 × 1280)
*   `lp_ud`: 1080p (1920 × 1080)
*   `lp_ud_v`: 1080p (1080 × 1920)', example='lp_ld', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  rulesId?: string(name='RulesId', description='The ID of the subtitle rule.', example='445409ec-7eaa-461d -8f29-4bec2eb9****', position='Query'),
  studioName?: string(name='StudioName', description='The name of the virtual background template.', example='sub02', position='Query'),
  subtitleId?: string(name='SubtitleId', description='The ID of the subtitle template.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  subtitleName?: string(name='SubtitleName', description='The name of the subtitle template.', example='sub01', position='Query'),
  suffix?: string(name='Suffix', description='The suffix to match.', example='test01', position='Query'),
}

model UpdateLiveAIProduceRulesResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b96****'),
}

model UpdateLiveAIProduceRulesResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAIProduceRulesResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify the parameters of a specified subtitle rule.
  * >  The live subtitles feature is in invitational preview. You can add up to 300 subtitle templates.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveAIProduceRules  UpdateLiveAIProduceRulesRequest
  * @return UpdateLiveAIProduceRulesResponse
 */
async function updateLiveAIProduceRules(request: UpdateLiveAIProduceRulesRequest): UpdateLiveAIProduceRulesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAIProduceRules', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAISubtitleRequest {
  bgColor?: string(name='BgColor', description='The background color of the subtitles. Color format: RGBA.', example='0xFF0000', position='Query'),
  bgWidthNormalized?: float(name='BgWidthNormalized', description='The size of the background box. Valid values: [0,1].', example='0.09', position='Query'),
  borderWidthNormalized?: float(name='BorderWidthNormalized', description='The font weight. Valid values: [0,1].', example='0.05', position='Query'),
  description?: string(name='Description', description='The description of the subtitle template. The description can be up to 128 characters in length and can contain letters, digits, and special characters.', example='live AI subtitle template', position='Query'),
  dstLanguage?: string(name='DstLanguage', description='The target language. Valid values:

*   en-US: English
*   zh-CN: Chinese
*   es-ES: Spanish
*   ru-RU: Russian', example='zh-CN', position='Query'),
  fontColor?: string(name='FontColor', description='The font color. Color format: RGBA.', example='0xFFFFFF', position='Query'),
  fontName?: string(name='FontName', description='The font. Valid values:

*   KaiTi (default)
*   AlibabaPuHuiTi-Regular
*   AlibabaPuHuiTi-Bold
*   AlibabaPuHuiTi-Light
*   NotoSansHans-Regular
*   NotoSansHans-Bold
*   NotoSansHans-Light', example='KaiTi', position='Query'),
  fontSizeNormalized?: float(name='FontSizeNormalized', description='The font size. Valid values: [0,1].', example='0.037', position='Query'),
  height?: string(name='Height', description='The height of the preview. Unit: pixels.

The following preview specifications (width x height) are supported:

*   360p (640 x 360)
*   360p (360 x 640)
*   480p (854 x 480)
*   480p (480 x 854)
*   720p (1280 x 720)
*   720p (720 x 1280)
*   1080p (1920 x 1080)
*   1080p (1080 x 1920)', example='720', position='Query'),
  maxLines?: int32(name='MaxLines', description='The number of displayed lines.', example='2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  positionNormalized?: [ float ](name='PositionNormalized', description='The position of the subtitles relative to the lower-left corner of the screen. The value is a pair of coordinates.', shrink='json', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  showSourceLan?: boolean(name='ShowSourceLan', description='Specifies whether to display the source language. Valid values: true and false. Default value: false.', example='true', position='Query'),
  srcLanguage?: string(name='SrcLanguage', description='The source language. Valid values:

*   en-US: English
*   zh-CN: Chinese
*   ru-RU: Russian', example='zh-CN', position='Query'),
  subtitleId: string(name='SubtitleId', description='The ID of the subtitle template.

This parameter is required.', example='597991f3-6ef9-4100-9238-82951de1****', position='Query'),
  subtitleName?: string(name='SubtitleName', description='The name of the subtitle template. The name can contain digits, letters, and hyphens (-) but cannot start with a hyphen (-).', example='live AI subtitle template', position='Query'),
  width?: string(name='Width', description='The width of the preview. Unit: pixels.', example='1280', position='Query'),
  wordPerLine?: int32(name='WordPerLine', description='The number of characters per line. Valid values: 1 to 500.', example='20', position='Query'),
}

model UpdateLiveAISubtitleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='String	5c6a2a0df228-4a64- af62-20e91b96****'),
}

model UpdateLiveAISubtitleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAISubtitleResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateLiveAISubtitle  UpdateLiveAISubtitleRequest
  * @return UpdateLiveAISubtitleResponse
 */
async function updateLiveAISubtitle(request: UpdateLiveAISubtitleRequest): UpdateLiveAISubtitleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAISubtitle', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAppRecordConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  delayTime?: int32(name='DelayTime', description='The interruption duration for merge. If the stream interruption duration exceeds the specified duration, a new recording is generated. The value of this parameter ranges from 15 to 21600 seconds.', example='180', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime?: string(name='EndTime', description='The recording end time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  The time range that is specified by the EndTime and StartTime parameters must be less than or equal to seven days. If the value exceeds seven days, ApsaraVideo Live considers seven days as the time range. This parameter takes effect only for the live stream specified by the StreamName parameter. If the StreamName parameter is not specified, this parameter does not take effect.', example='2018-04-16T09:57:21Z', position='Query'),
  onDemand?: int32(name='OnDemand', description='Specifies whether to enable on-demand recording. Valid values:

*   **0**: disables on-demand recording.
*   **1**: enables on-demand recording by using the HTTP callback method.
*   **2**: enables on-demand recording by parsing the stream ingest parameters.
*   **7**: By default, ApsaraVideo Live does not automatically record live streams. You can call the [RealTimeRecordCommand](https://help.aliyun.com/document_detail/2847882.html) operation to manually start or stop recording.

>  If you set the OnDemand parameter to **1**, you need to call the [AddLiveRecordNotifyConfig](https://help.aliyun.com/document_detail/2847891.html) operation to configure the OnDemandUrl parameter. Otherwise, ApsaraVideo Live does not perform on-demand recording.', example='1', position='Query'),
  ossEndpoint: string(name='OssEndpoint', description='The endpoint of the Object Storage Service (OSS) bucket.

To store live stream recordings in OSS, you need to create an OSS bucket in advance. For more information, see [Configure OSS](https://help.aliyun.com/document_detail/84932.html).

This parameter is required.', example='learn.developer.aliyundoc.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  recordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration', description='The recording cycle. Unit: seconds If you do not specify this parameter, the default value 6 hours is used.

> 

*   If a live stream is interrupted during a recording cycle but is resumed within the interruption duration threshold, the stream is recorded in the same recording before and after the interruption.

*   If a live stream is interrupted for longer than the interruption duration threshold, a new recording is generated.', example='1'),
      format?: string(name='Format', description='The recording format. Supported formats include M3U8, Flash Video (FLV), MP4, and Common Media Application Format (CMAF). Valid values:

>  You need to specify at lease one of the RecordFormat and TranscodeRecordFormat parameters. If you set this parameter to m3u8 or cmaf, you must also specify the RecordFormat.N.SliceOssObjectPrefix and RecordFormat.N.SliceDuration parameters.

*   m3u8
*   flv
*   mp4
*   cmaf', example='m3u8'),
      sliceDuration?: int32(name='SliceDuration', description='The duration of a single segment. Unit: seconds

>  This parameter takes effect only if you set the RecordFormat.N.Format parameter to m3u8 or cmaf.

If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.', example='30'),
    }
  ](name='RecordFormat', description='The recording details.', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  startTime?: string(name='StartTime', description='The recording start time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

>  The start time must be within seven days after the stream ingest starts. This parameter takes effect only for the live stream specified by the StreamName parameter. If the StreamName parameter is not specified, this parameter does not take effect.', example='2018-04-10T09:57:21Z', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream.', example='teststream', position='Query'),
  transcodeRecordFormat?: [ 
    {
      cycleDuration?: int32(name='CycleDuration', description='The transcoded stream recording cycle. Unit: seconds If you do not specify this parameter, the default value 6 hours is used.', example='21600'),
      format?: string(name='Format', description='The format of the transcoded stream recording. Supported formats include M3U8, FLV, MP4, and CMAF. Valid values:

>  If you set this parameter to m3u8 or cmaf, you must also specify the TranscodeRecordFormat.N.SliceOssObjectPrefix and TranscodeRecordFormat.N.SliceDuration parameters.

*   m3u8
*   flv
*   mp4
*   cmaf', example='m3u8'),
      sliceDuration?: int32(name='SliceDuration', description='The duration of a single segment in the transcoded stream recording. Unit: seconds.

>  This parameter takes effect only if you set the TranscodeRecordFormat.N.Format parameter to m3u8 or cmaf.

If you do not specify this parameter, the default value 30 seconds is used. Valid values: 5 to 30.', example='30'),
    }
  ](name='TranscodeRecordFormat', description='The transcoded stream recording details.', position='Query'),
  transcodeTemplates?: [ string ](name='TranscodeTemplates', description='The transcoding template group details.', position='Query'),
}

model UpdateLiveAppRecordConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveAppRecordConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAppRecordConfigResponseBody(name='body'),
}

/**
  * @description Obtain the main streaming domain, and then call this operation to update a recording configuration.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveAppRecordConfig  UpdateLiveAppRecordConfigRequest
  * @return UpdateLiveAppRecordConfigResponse
 */
async function updateLiveAppRecordConfig(request: UpdateLiveAppRecordConfigRequest): UpdateLiveAppRecordConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAppRecordConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAppSnapshotConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  callback?: string(name='Callback', description='The callback URL that is used to receive notifications about snapshot capture.', example='https://learn.aliyundoc.com', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ossBucket?: string(name='OssBucket', description='The name of the OSS bucket.', example='liveBucket****', position='Query'),
  ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com', position='Query'),
  overwriteOssObject?: string(name='OverwriteOssObject', description='The naming format of snapshots that are stored in the overwrite mode, which means that a new snapshot overwrites the previous snapshot.

*   The name must be less than 256 bytes in length.
*   Only JPG images are supported.
*   The name can contain variables such as {AppName} and {StreamName}.
*   A value of hyphen (-) indicates that this parameter is deleted.', example='{liveApp****}/{liveStream****}.jpg', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  sequenceOssObject?: string(name='SequenceOssObject', description='The naming format of snapshots that are stored in sequence, which means that a new snapshot does not overwrite the previous snapshot. You can call the [DescribeLiveStreamSnapshotInfo](https://help.aliyun.com/document_detail/2847902.html) operation to query the snapshots that were captured within a specific time period.

*   The name must be less than 256 bytes in length.
*   Only JPG images are supported.
*   The name can contain variables such as {AppName}, {StreamName}, {UnixTimestamp}, and {Sequence}. The name must contain at least one of the {UnixTimestamp} and {Sequence} variables.
*   A value of hyphen (-) indicates that this parameter is deleted.', example='snapshot/{liveApp****}/{liveStream****}/{UnixTimestamp****}.jpg', position='Query'),
  timeInterval?: int32(name='TimeInterval', description='The interval at which snapshots are captured. Valid values: **5 to 3600**. Unit: seconds.', example='5', minimum=5, maximum=3600, position='Query'),
}

model UpdateLiveAppSnapshotConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveAppSnapshotConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAppSnapshotConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify a snapshot configuration of a streaming domain. The captured snapshots are stored in OSS. The modification takes effect after you restart stream ingest.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveAppSnapshotConfig  UpdateLiveAppSnapshotConfigRequest
  * @return UpdateLiveAppSnapshotConfigResponse
 */
async function updateLiveAppSnapshotConfig(request: UpdateLiveAppSnapshotConfigRequest): UpdateLiveAppSnapshotConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAppSnapshotConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAudioAuditConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The application name is case-sensitive.

This parameter is required.', example='liveApp****', position='Query'),
  bizType?: string(name='BizType', description='The business type. You can specify a model. The default value is the domain name.', example='example.edu', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ossBucket?: string(name='OssBucket', description='The name of the Object Storage Service (OSS) bucket.', example='liveBucket****', position='Query'),
  ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the OSS bucket.', example='cn-oss-****.aliyuncs.com', position='Query'),
  ossObject?: string(name='OssObject', description='The name of the recording that is stored in OSS.', example='liveObject****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. The value of this parameter must be the same as the stream name in the ingest URL. Otherwise, the configuration does not take effect. The stream name is case-sensitive.

This parameter is required.', example='liveStream****', position='Query'),
}

model UpdateLiveAudioAuditConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model UpdateLiveAudioAuditConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAudioAuditConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to modify an audio moderation configuration.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveAudioAuditConfig  UpdateLiveAudioAuditConfigRequest
  * @return UpdateLiveAudioAuditConfigResponse
 */
async function updateLiveAudioAuditConfig(request: UpdateLiveAudioAuditConfigRequest): UpdateLiveAudioAuditConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAudioAuditConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveAudioAuditNotifyConfigRequest {
  callback?: string(name='Callback', description='The callback URL. This URL is used to receive callback notifications about violations in audio.', example='http://guide.aliyundoc.com/callback', position='Query'),
  callbackTemplate?: string(name='CallbackTemplate', description='The callback template. Configure the following fields:

*   **{DomainName}**: the streaming domain.
*   **{AppName}**: the name of the application to which the live stream belongs.
*   **{StreamName}**: the name of the live stream.
*   **{Timestamp}**: the time when the callback is returned. The value of this field is a UNIX timestamp. Unit: seconds.
*   **{Result}**: the moderation results.', example='{"domain":{DomainName},"app":{AppName},"stream":{StreamName},"timestamp":{Timestamp},"result":{Result}}', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateLiveAudioAuditNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='7BF95F2A-3B24-4CDE-9346-7F6FA86697A1'),
}

model UpdateLiveAudioAuditNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveAudioAuditNotifyConfigResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateLiveAudioAuditNotifyConfig  UpdateLiveAudioAuditNotifyConfigRequest
  * @return UpdateLiveAudioAuditNotifyConfigResponse
 */
async function updateLiveAudioAuditNotifyConfig(request: UpdateLiveAudioAuditNotifyConfigRequest): UpdateLiveAudioAuditNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveAudioAuditNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveCenterTransferRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name for the live stream that you want to relay. Otherwise, the configuration does not take effect. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='testapp', position='Query'),
  domainName: string(name='DomainName', description='The streaming domain.

This parameter is required.', example='example.com', position='Query'),
  dstUrl: string(name='DstUrl', description='The third-party URL to which the live stream is relayed. You can add only one URL.

>  The protocol that the URL uses must be the same as the protocol of the live stream. Only URLs over RTMP and SRT are supported.

This parameter is required.', example='rtmp://push.example2.aliyunlive.com/testapp1/teststream2', position='Query'),
  endTime?: string(name='EndTime', description='The end time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.

>  The end time must be later than the start time.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  startTime?: string(name='StartTime', description='The start time of stream relay. Specify the time in the ISO 8601 standard in the yyyy-MM-ddTHH:mm:ssZ format. The time must be in UTC.', example='2017-12-21T10:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='teststream', position='Query'),
  transferArgs: string(name='TransferArgs', description='The validity period of stream relay. Valid values:

*   **always**: The stream can always be relayed.
*   **time**: The stream can be relayed in a specified time period.

>  If the value is **time**, **StartTime** and **EndTime** are required.

This parameter is required.', example='always', position='Query'),
}

model UpdateLiveCenterTransferResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='7908F2FF-44F8-120F-9FD6-85AE4B6C19EC'),
}

model UpdateLiveCenterTransferResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveCenterTransferResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify only the **time-related** parameters, including TransferArgs, StartTime, and EndTime.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveCenterTransfer  UpdateLiveCenterTransferRequest
  * @return UpdateLiveCenterTransferResponse
 */
async function updateLiveCenterTransfer(request: UpdateLiveCenterTransferRequest): UpdateLiveCenterTransferResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveCenterTransfer', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveDelayConfigRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs. You can specify an asterisk (\\*) as the value to match all applications that belong to the domain name.

This parameter is required.', example='liveApp****', position='Query'),
  delayTime: int32(name='DelayTime', description='The duration for which the playback of the live stream is delayed. The value must be an integer. Valid values: 16 to 3600. Unit: seconds.

This parameter is required.', example='60', position='Query'),
  domain: string(name='Domain', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream: string(name='Stream', description='The name of the live stream. You can use the wildcard (\\*) to specify all streams of the application.

This parameter is required.', example='liveStream****', position='Query'),
  taskTriggerMode?: string(name='TaskTriggerMode', description='The trigger mode. Valid values:

*   **PUBLISH_ONLY**: Stream delay can be triggered only by specifying the stream delay parameter in the ingest URL.
*   **CONFIG_ONLY**: Stream delay can be triggered only by the stream delay configuration.
*   **PUBLISH_CONFIG**: Stream delay can be triggered by the stream delay parameter in the ingest URL or the stream delay configuration. The stream delay parameter takes precedence over the stream delay configuration.', example='PUBLISH_ONLY', position='Query'),
}

model UpdateLiveDelayConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveDelayConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveDelayConfigResponseBody(name='body'),
}

/**
  * @description ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of UpdateLiveDelayConfig  UpdateLiveDelayConfigRequest
  * @return UpdateLiveDelayConfigResponse
 */
async function updateLiveDelayConfig(request: UpdateLiveDelayConfigRequest): UpdateLiveDelayConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveDelayConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveDetectNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  notifyUrl: string(name='NotifyUrl', description='The callback URL that is used to receive callback notifications about violations, such as pornographic content, detected in live streams.

This parameter is required.', example='http://guide.aliyundoc.com/examplecallback.action', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model UpdateLiveDetectNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveDetectNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveDetectNotifyConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to modify the configuration of callbacks for video moderation results.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveDetectNotifyConfig  UpdateLiveDetectNotifyConfigRequest
  * @return UpdateLiveDetectNotifyConfigResponse
 */
async function updateLiveDetectNotifyConfig(request: UpdateLiveDetectNotifyConfigRequest): UpdateLiveDetectNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveDetectNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveMPUTaskRequest {
  appId: string(name='AppId', description='The application ID. You can specify only one application ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  channelId: string(name='ChannelId', description='The channel ID. You can specify only one channel ID. The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourChannelId', position='Query'),
  mixMode?: string(name='MixMode', description='The stream mixing mode. Valid values:

*   **0**: the single-stream relay mode. In this mode, the service only relays the original single stream, but does not transcode mixed streams. You do not need to set parameters for mixed-stream transcoding.
*   **1** (default): the mixed-stream relay mode.', example='0', position='Query'),
  multiStreamURL?: [ 
    {
      isAliCdn?: boolean(name='IsAliCdn', description='Specifies whether to perform stream relay by using Alibaba Cloud CDN. Valid values:

*   false: performs stream relay by using a CDN service that is not Alibaba Cloud CDN.
*   true: performs stream relay by using Alibaba Cloud CDN.

>  The default value of this parameter is false.', example='false'),
      URL?: string(name='URL', description='The ingest URL. Only the RTMP format is supported. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).', example='rtmp://example.com/live/stream****'),
    }
  ](name='MultiStreamURL', description='The multiple ingest URLs to relay. This parameter allows you to specify multiple ingest URLs.', shrink='json', position='Query'),
  seiParams?: {
    layoutVolume?: {
      followIdr?: string(name='FollowIdr', description='Specifies whether to include the SEI in an Instantaneous Decoder Refresh (IDR) frame. Valid values:

*   **0**: does not include the SEI.
*   **1**: includes the SEI.', example='0'),
      interval?: string(name='Interval', description='The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.', example='1000'),
    }(name='LayoutVolume', description='The layout and volume SEI. If you leave this parameter empty, the default layout and volume SEI is used.'),
    passThrough?: {
      followIdr?: string(name='FollowIdr', description='Specifies whether to include the SEI in an IDR frame. Valid values:

*   **0**: does not include the SEI.
*   **1**: includes the SEI.', example='0'),
      interval?: string(name='Interval', description='The interval at which the SEI is sent. Valid values: [1000,5000]. Unit: milliseconds.', example='1000'),
      payloadContent?: string(name='PayloadContent', description='The payload content of the SEI.', example='yourPayloadContent'),
      payloadContentKey?: string(name='PayloadContentKey', description='The key of the payload content of the SEI. If you do not specify this parameter, the default value udd is used.', example='yourPayloadContentKey'),
    }(name='PassThrough', description='Specifies whether to pass through the SEI.'),
  }(name='SeiParams', description='The supplemental enhancement information (SEI) parameters.', shrink='json', position='Query'),
  singleSubParams?: {
    sourceType?: string(name='SourceType', description='The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
    streamType?: string(name='StreamType', description='The type of the stream that you want to relay. Valid values:

*   **0** (default): original stream
*   **1**: only the audio track
*   **2**: only the video track', example='0'),
    userId: string(name='UserId', description='The user ID. In the single-stream relay mode, you can relay only one stream in a request.

This parameter is required.', example='yourSubUserId'),
  }(name='SingleSubParams', description='The single-stream relay parameters. These parameters are required if you set MixMode to 0.', shrink='json', position='Query'),
  streamURL?: string(name='StreamURL', description='The ingest URL. You can specify only one ingest URL in the Real-Time Messaging Protocol (RTMP) format. The URL can be up to 2,048 characters in length. For information about the generation rules of ingest URLs, see [Ingest and streaming URLs](https://help.aliyun.com/document_detail/199339.html).

> 

*   If the ingest URL is under a domain name for which hotlink protection is enabled, you must include an access token in the URL.
*   You cannot use the same ingest URL in different tasks.
*   You cannot use the same ingest URL within 10 seconds after a task is stopped.', example='rtmp://example.com/live/stream', position='Query'),
  taskId: string(name='TaskId', description='The task ID. You can specify only one task ID. The ID can be up to 55 characters in length and can contain letters, digits, underscores (_), and hyphens (-). The ID must be unique.

This parameter is required.', example='yourTaskId', position='Query'),
  transcodeParams?: {
    background?: {
      renderMode?: string(name='RenderMode', description='The display mode of the global background image.

*   **0**: scales the background image proportionally to fit the view, with black bars displayed.
*   **1** (default): crops the background image to fit the view.', example='1'),
      URL?: string(name='URL', description='The URL of the global background image.', example='yourImageUrl'),
    }(name='Background', description='The global background image.'),
    encodeParams?: {
      audioBitrate?: string(name='AudioBitrate', description='The bitrate of the audio. Valid values: [8,500]. Unit: Kbit/s.', example='128'),
      audioChannels?: string(name='AudioChannels', description='The number of sound channels. Valid values: 1 and 2.', example='2'),
      audioOnly?: string(name='AudioOnly', description='Specifies whether the output stream is an audio-only stream. Valid values:

*   **true**: The output stream is an audio-only stream. If you set this parameter to true, you need to configure only audio-related parameters under EncodeParams.
*   **false** (default): The output stream is not an audio-only stream. If you set this parameter to false, you need to configure all parameters under EncodeParams, except the VideoCodec and EnhancedParam parameters.', example='false'),
      audioSampleRate?: string(name='AudioSampleRate', description='The audio sampling rate. Valid values: 8000, 16000, 32000, 44100, and 48000. Unit: Hz.', example='44100'),
      enhancedParam?: string(name='EnhancedParam', description='The parameter used for encoding enhancement, which is a JSON string. The parameter includes the optional profile and preset fields.

*   profile: the encoding level. If the video codec is H.264, the valid values of this field are baseline, main, and high. If the video codec is H.265, the valid value of this field is main.
*   preset: adjusts the trade-off between encoding speed and video quality. The valid values of this field are ultrafast, superfast, veryfast, faster, fast, medium, slow, slower, veryslow, and placebo. Each value specifies a level of trade-off between encoding speed and video quality. For example, the ultrafast preset has the fastest encoding speed but the lowest video quality, while the placebo preset sacrifices the encoding speed for the best video quality.

>  A value of superfast for the preset field is suitable for real-time communication scenarios. We recommend that you not set the field if you are not a professional encoding engineer.', example='{"profile": "high", "preset": "veryfast"}'),
      videoBitrate?: string(name='VideoBitrate', description='The bitrate of the video. Valid values: [1,10000]. Unit: Kbit/s.', example='3500'),
      videoCodec?: string(name='VideoCodec', description='The video codec. Valid values:

*   H.264 (default)
*   H.265', example='H.264'),
      videoFramerate?: string(name='VideoFramerate', description='The frame rate of the video. Valid values: [1,60]. Unit: frames per second (FPS).', example='25'),
      videoGop?: string(name='VideoGop', description='The group of pictures (GOP) size of the video. Valid values: [1,60].', example='20'),
      videoHeight?: string(name='VideoHeight', description='The height of the video. Valid values: [0,1920]. Unit: pixels.', example='1000'),
      videoWidth?: string(name='VideoWidth', description='The width of the video. Valid values: [0,1920]. Unit: pixels.', example='1920'),
    }(name='EncodeParams', description='The encoding parameters for the output stream.'),
    layout?: {
      userPanes?: [ 
        {
          backgroundImageUrl?: string(name='BackgroundImageUrl', description='The URL of the background image of the pane. This image is displayed if the user turns off the camera or is not present in the channel.', example='yourImageUrl'),
          height?: string(name='Height', description='The height of the pane. The value is normalized.', example='0.2632'),
          renderMode?: string(name='RenderMode', description='The display mode of the pane. Valid values:

*   **0**: scales the video proportionally to fit the view, with black bars displayed.
*   **1 (default)**: crops the video to fit the view.', example='1'),
          userInfo?: {
            channelId?: string(name='ChannelId', description='The ID of the channel where the user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.', example='yourChannelId'),
            sourceType?: string(name='SourceType', description='The type of the video source. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
            userId?: string(name='UserId', description='The user ID.', example='yourSubUserId'),
          }(name='UserInfo', description='The information about the user whose stream is played in the pane. If you leave this parameter empty, the system automatically sets this parameter based on the order in which streamers join the channel.

> 

*   If you specify the information about a user by using this parameter, the information about the user must also be specified by using the TranscodeParams.UserInfos parameter.

*   This parameter is valid only when you set StreamType to 0 or 2.'),
          width?: string(name='Width', description='The width of the pane. The value is normalized.', example='0.3564'),
          x?: string(name='X', description='The x-coordinate of the pane. The value is normalized.', example='0.2456'),
          y?: string(name='Y', description='The y-coordinate of the pane. The value is normalized.', example='0.3789'),
          zOrder?: string(name='ZOrder', description='The layer in which the pane resides. A value of 0 indicates the bottom layer. Each increment of the value by 1 indicates the next upper layer.', example='0'),
        }
      ](name='UserPanes', description='The information about the panes.'),
    }(name='Layout', description='The video layout information.

>  If video transcoding is required, you must specify the video layout information, including the x-coordinate and y-coordinate, the width and height, and the layer. For audio-only transcoding, leave the video layout information empty.'),
    userInfos?: [ 
      {
        channelId?: string(name='ChannelId', description='The ID of the channel where the subscribed user is. If the user is in the same channel, you can leave this parameter empty. We recommend that you specify this parameter when you perform stream mixing across channels.', example='yourChannelId'),
        sourceType?: string(name='SourceType', description='The type of the video source that is subscribed to. This parameter is valid only when you set StreamType to 2. Valid values:

*   **camera** (default)
*   **shareScreen**', example='camera'),
        streamType?: string(name='StreamType', description='The type of the relayed stream that is subscribed to. Valid values:

*   **0** (default): original stream
*   **1**: only the audio track
*   **2**: only the video track', example='0'),
        userId: string(name='UserId', description='The ID of the subscribed user.

This parameter is required.', example='yourSubUserId'),
      }
    ](name='UserInfos', description='The information about the users whose streams are subscribed to. If you leave this parameter empty, streams from all users are mixed.'),
  }(name='TranscodeParams', description='The mixed-stream relay parameters. These parameters are required if you set MixMode to 1.', shrink='json', position='Query'),
}

model UpdateLiveMPUTaskResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0F72851F-5DC1-1979-9B2C-450040316C3E'),
}

model UpdateLiveMPUTaskResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveMPUTaskResponseBody(name='body'),
}

/**
  * @description Make sure that a mixed-stream relay task is created before you call this operation. You can call the [StartLiveMPUTask](https://help.aliyun.com/document_detail/2848199.html) operation to create a mixed-stream relay task.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 500 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveMPUTask  UpdateLiveMPUTaskRequest
  * @return UpdateLiveMPUTaskResponse
 */
async function updateLiveMPUTask(request: UpdateLiveMPUTaskRequest): UpdateLiveMPUTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveMPUTask', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLivePackageConfigRequest {
  appName: string(name='AppName', description='The application name. The value of this parameter must be the same as the application name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.

This parameter is required.', example='AppName', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  ignoreTranscode?: boolean(name='IgnoreTranscode', description='Specifies whether to ignore the transcoded stream. Valid values:

*   **true** (default)
*   **false**', example='true', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  partDuration?: int32(name='PartDuration', description='The part length. Unit: milliseconds.

>  This parameter is required if Protocol is set to LLHLS_TS or LLHLS_CMAF.

*   If the value of SegmentDuration is 1, the valid values of this parameter are 100 to 500.
*   If the value of SegmentDuration is 2, the valid values of this parameter are 100 to 1000.', example='350', position='Query'),
  protocol: string(name='Protocol', description='The streaming protocol and encapsulation format. Valid values:

*   **HLS_CMAF**
*   **LLHLS_TS** (low latency)
*   **LLHLS_CMAF** (low latency)
*   **DASH_CMAF**
*   **HLSDASH_CMAF**

This parameter is required.', example='HLS_CMAF', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  segmentDuration: int32(name='SegmentDuration', description='The segment length. Unit: seconds.

*   If Protocol is set to HLS_CMAF, the valid values of this parameter are 1 to 10.
*   If Protocol is set to LLHLS_TS or LLHLS_CMAF, the valid values of this parameter are 1 to 2.

This parameter is required.', example='5', position='Query'),
  segmentNum: int32(name='SegmentNum', description='The number of segments. Valid values: 3 to 10.

This parameter is required.', example='3', position='Query'),
  streamName: string(name='StreamName', description='The stream name. The value of this parameter must be the same as the stream name that is specified in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all streams.

This parameter is required.', example='StreamName', position='Query'),
}

model UpdateLivePackageConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLivePackageConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLivePackageConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to update a live stream encapsulation configuration. The update takes effect only after you re-ingest the stream.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 300 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLivePackageConfig  UpdateLivePackageConfigRequest
  * @return UpdateLivePackageConfigResponse
 */
async function updateLivePackageConfig(request: UpdateLivePackageConfigRequest): UpdateLivePackageConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLivePackageConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLivePullStreamInfoConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The domain name used for stream pulling. It is the main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  endTime: string(name='EndTime', description='The time when stream pulling ends.

The time range specified by the StartTime and EndTime parameters cannot exceed seven days. The time specified by the EndTime parameter must be later than the current time. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-22T08:00:00Z', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  sourceUrl: string(name='SourceUrl', description='The complete URL of the origin server of the live stream. You can specify multiple URLs by separating them with semicolons (;).

This parameter is required.', position='Query'),
  startTime: string(name='StartTime', description='The time when stream pulling starts.

The time range specified by the StartTime and EndTime parameters cannot exceed seven days. Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

This parameter is required.', example='2017-12-21T08:00:00Z', position='Query'),
  streamName: string(name='StreamName', description='The name of the live stream.

This parameter is required.', example='liveStream****', position='Query'),
}

model UpdateLivePullStreamInfoConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CF8'),
}

model UpdateLivePullStreamInfoConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLivePullStreamInfoConfigResponseBody(name='body'),
}

/**
  * @description This operation is applicable to regular stream pulling. You can call this operation to modify the stream pulling settings of a live stream, including the origin URL, start time, and end time.
  * >  After this operation is complete, ApsaraVideo Live uses the updated settings for regular stream pulling. Make sure that the modification does not affect your business.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLivePullStreamInfoConfig  UpdateLivePullStreamInfoConfigRequest
  * @return UpdateLivePullStreamInfoConfigResponse
 */
async function updateLivePullStreamInfoConfig(request: UpdateLivePullStreamInfoConfigRequest): UpdateLivePullStreamInfoConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLivePullStreamInfoConfig', 'GET', '/', 'json', false, 'json', request);
}

model UpdateLivePullToPushRequest {
  callbackUrl?: string(name='CallbackUrl', description='The callback URL. By default, this parameter is left empty.

> 

*   The URL is used to receive callbacks related to the task.

*   The URL can be up to 2,000 characters in length.

*   If you do not specify this parameter, no callbacks are returned for events related to the task.

*   The update takes effect for subsequent events that occur.', example='https://callback*****.com', position='Query'),
  endTime?: string(name='EndTime', description='The end time of the task.

> 

*   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.

*   The end time must be later than the start time.

*   The end time must be later than the current time.

*   If the task has ended, the update does not take effect.', example='2024-08-27T14:30:00Z', position='Query'),
  fileIndex?: int32(name='FileIndex', description='The file index. Default value: 0.

>  You can modify this parameter only if the task is stopped. The update takes effect after you restart the task.', example='0', position='Query'),
  offset?: int32(name='Offset', description='The offset of the position where the system starts to read the video resource. Unit: seconds. Valid values: positive numbers.

> 

*   This parameter indicates an offset from the first frame.

*   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.

*   The update takes effect only for the first video in a video list.

*   You can modify this parameter only if the task is stopped. The update takes effect immediately.', example='2', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region: string(name='Region', description='The region where the task is started. Valid values:

*   ap-southeast-1: Singapore
*   ap-southeast-5: Indonesia (Jakarta)
*   cn-beijing: China (Beijing)
*   cn-shanghai: China (Shanghai)

This parameter is required.', example='cn-shanghai', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  repeatNumber?: int32(name='RepeatNumber', description='The number of playbacks after the first playback is complete. Valid values:

*   0 (default): specifies that the video list is played only once.
*   \\-1: specifies that the video list is played in loop mode.
*   Positive integer: specifies the number of times the video list repeats after the first playback is complete.

> 

*   This parameter is applicable to only video resources from ApsaraVideo VOD or a third party.

*   The update can take effect immediately.', example='0', position='Query'),
  sourceUrls?: [ string ](name='SourceUrls', description='The source URLs.

> 

*   If SourceType is set to live, you can specify only one streaming URL.

*   If SourceType is set to vod or url, you can specify up to 30 IDs or URLs.

*   If SourceType is set to live, the supported protocols for URLs are Real-Time Messaging Protocol (RTMP), Real-Time Streaming Protocol (RTSP), Secure Reliable Transport Protocol (SRT), and HTTP-FLV.

*   If SourceType is set to vod, specify the IDs of media assets from ApsaraVideo VOD.

*   If SourceType is set to url, the supported protocols for URLs are MP4 and HTTP-FLV.

*   If the source is a live stream, the update takes effect immediately. If the source is a list of video resources from ApsaraVideo VOD or a third party, the update does not take effect until the playback of the current video ends. After the update takes effect, the video list starts to play from the beginning.

*   You can modify this parameter only if the task is stopped. The update takes effect immediately.', example='changedtesturl', shrink='json', position='Query'),
  startTime?: string(name='StartTime', description='The start time of the task.

> 

*   Specify the time in the ISO 8601 standard in the *yyyy-MM-dd*T*HH:mm:ss*Z format. The time must be in UTC.

*   The time range specified by the StartTime and EndTime parameters cannot exceed seven days.

*   If the task has already started, the update does not take effect.', example='2024-08-23T15:30:00Z', position='Query'),
  taskId: string(name='TaskId', description='The task ID.

This parameter is required.', example='fd245384-4067-4f91-9d75-9666a6bc****', position='Query'),
}

model UpdateLivePullToPushResponseBody = {
  description?: string(name='Description', description='The error description.', example='OK'),
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68*****'),
  retCode?: int32(name='RetCode', description='The code that is returned for the request.

> 

*   0 is returned if the request is normal.

*   For information about codes that are returned when exceptions occur, see the following Error codes table.', example='0'),
}

model UpdateLivePullToPushResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLivePullToPushResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to update a pulled-stream relay task.
  * *   As long as the specified start time of a task has not been reached, you can modify the SourceType, Region, and DstUrl parameters of the task.
  * *   If a task is running (even if the task is in an abnormal retry state), you can modify only the CallbackUrl and RepeatTime parameters of the task. The update takes effect immediately.
  * *   If a task is stopped, you can modify all parameters of the task except SourceType, Region, and DstUrl.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLivePullToPush  UpdateLivePullToPushRequest
  * @return UpdateLivePullToPushResponse
 */
async function updateLivePullToPush(request: UpdateLivePullToPushRequest): UpdateLivePullToPushResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLivePullToPush', 'GET', '/', 'json', false, 'json', request);
}

model UpdateLiveRecordNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  needStatusNotify?: boolean(name='NeedStatusNotify', description='Specifies whether to enable callbacks for recording status. Valid values:

*   **true**
*   **false** (default)', example='false', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', minLength=16, maxLength=64, position='Query'),
  notifyReqAuth?: boolean(name='NotifyReqAuth', position='Query'),
  notifyUrl: string(name='NotifyUrl', description='The callback URL that is used to receive notifications about recording events and status.

> 

*   The URL must start with `http://` or `https://`.

*   You must use URLEncoder for encoding. This way, the system can identify Chinese characters, spaces, and special characters.

This parameter is required.', example='http://learn.aliyundoc.com/examplecallback.action', position='Query'),
  onDemandUrl?: string(name='OnDemandUrl', description='The callback URL for on-demand recordings.

> 

*   The URL must start with `http://` or `https://`.

*   You must use URLEncoder for encoding. This way, the system can identify Chinese characters, spaces, and special characters.', example='http://guide.aliyundoc.com/ondemandcallback.action', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model UpdateLiveRecordNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD'),
}

model UpdateLiveRecordNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveRecordNotifyConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation to modify the following settings:
  * *   The callback URL that is used to receive notifications about recording events and status. For more information, see [Recording event callbacks](https://help.aliyun.com/document_detail/55016.html).
  * *   The callback URL for on-demand recordings. For more information, see [On-demand recording callbacks](https://help.aliyun.com/document_detail/85910.html).
  * *   The setting that specifies whether to enable callbacks for recording status.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveRecordNotifyConfig  UpdateLiveRecordNotifyConfigRequest
  * @return UpdateLiveRecordNotifyConfigResponse
 */
async function updateLiveRecordNotifyConfig(request: UpdateLiveRecordNotifyConfigRequest): UpdateLiveRecordNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveRecordNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveRecordVodConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. You can view the application name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.

This parameter is required.', example='testName', position='Query'),
  autoCompose?: string(name='AutoCompose', description='Specifies whether to enable automatic merging. Valid values:

*   **ON**: enables automatic merging. If you set this parameter to ON, you must also specify the ComposeVodTranscodeGroupId parameter.
*   **OFF**: disables automatic merging.', example='OFF', position='Query'),
  composeVodTranscodeGroupId?: string(name='ComposeVodTranscodeGroupId', description='The ID of the transcoding template group in ApsaraVideo VOD that is used to transcode the video file. The video file is generated by merging the VOD files created from live streams.

>  To query transcoding template groups, call the [ListTranscodeTemplateGroup](https://help.aliyun.com/document_detail/454928.html) operation.', example='*****', position='Query'),
  cycleDuration?: int32(name='CycleDuration', description='The recording cycle. Unit: seconds. Valid values: **300 to 21600**. Default value: **3600**.', example='300', minimum=300, maximum=21600, position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  onDemand?: int32(name='OnDemand', description='Specifies whether to enable on-demand recording. Valid values:

*   **0** (default): disables on-demand recording.
*   **1**: enables on-demand recording by using the HTTP callback method.', example='0', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  streamName?: string(name='StreamName', description='The name of the live stream. You can view the stream name on the [Stream Management](https://help.aliyun.com/document_detail/197397.html) page of the ApsaraVideo Live console.', example='stream', position='Query'),
  vodTranscodeGroupId: string(name='VodTranscodeGroupId', description='The ID of the transcoding template group in ApsaraVideo VOD.

This parameter is required.', example='e2d796d3bb5fd8049d32bff62f94****', position='Query'),
}

model UpdateLiveRecordVodConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='61C96B9A-F203-4EC5-8E43-CB92E68F67DF'),
}

model UpdateLiveRecordVodConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveRecordVodConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 1,000 times per minute per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveRecordVodConfig  UpdateLiveRecordVodConfigRequest
  * @return UpdateLiveRecordVodConfigResponse
 */
async function updateLiveRecordVodConfig(request: UpdateLiveRecordVodConfigRequest): UpdateLiveRecordVodConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveRecordVodConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveSnapshotDetectPornConfigRequest {
  appName: string(name='AppName', description='The name of the application to which the live stream belongs. The value of this parameter must be the same as the application name in the ingest URL. Otherwise, the configuration does not take effect. The name can be up to 255 characters in length and can contain digits, letters, hyphens (-), and underscores (_). The name cannot start with a hyphen (-) or underscore (_). You can also specify an asterisk (\\*) as the value to match all applications.

This parameter is required.', example='liveApp****', position='Query'),
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='example.com', position='Query'),
  interval?: int32(name='Interval', description='The interval at which snapshots are captured from the live stream. Valid values: **5 to 3600**. Unit: seconds.', example='5', minimum=5, maximum=3600, position='Query'),
  ossBucket?: string(name='OssBucket', description='The name of the OSS bucket.', example='liveBucket****', position='Query'),
  ossEndpoint?: string(name='OssEndpoint', description='The endpoint of the Object Storage Service (OSS) bucket.', example='cn-oss-****.aliyuncs.com', position='Query'),
  ossObject?: string(name='OssObject', description='The name of the snapshot that stores violations such as pornographic content and politically sensitive content.', example='{liveApp****}/{liveStream****}/{Date}/{Hour}/{Minute}_{Second}.jpg', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  scene?: [ string ](name='Scene', description='The moderation scenario array.', example='porn', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model UpdateLiveSnapshotDetectPornConfigResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveSnapshotDetectPornConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveSnapshotDetectPornConfigResponseBody(name='body'),
}

/**
  * @description *   Obtain the main streaming domain, and then call this operation to modify a video moderation configuration.
  * *   Only some live centers support the content moderation feature. For more information, see [Supported regions](https://help.aliyun.com/document_detail/193730.html).
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveSnapshotDetectPornConfig  UpdateLiveSnapshotDetectPornConfigRequest
  * @return UpdateLiveSnapshotDetectPornConfigResponse
 */
async function updateLiveSnapshotDetectPornConfig(request: UpdateLiveSnapshotDetectPornConfigRequest): UpdateLiveSnapshotDetectPornConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveSnapshotDetectPornConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveSnapshotNotifyConfigRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

This parameter is required.', example='ww.yourdomain***.com', position='Query'),
  notifyAuthKey?: string(name='NotifyAuthKey', description='The callback authentication key. The key can be 16 to 32 characters in length and can contain only letters and digits.

>  This parameter is required if you set the NotifyReqAuth parameter to **yes**.', example='yourkey', position='Query'),
  notifyReqAuth?: string(name='NotifyReqAuth', description='Specifies whether to enable callback authentication. Valid values:

*   **yes**: enables callback authentication
*   **no**: disables callback authentication

>  Default value: **no**. If you set this parameter to **yes**, the NotifyAuthKey parameter is required.', example='yes', position='Query'),
  notifyUrl?: string(name='NotifyUrl', description='The callback URL. Specify a valid URL that is up to 500 characters in length.', example='http://callback.yourdomain***.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateLiveSnapshotNotifyConfigResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='A3136B58-5876-5A93-83CA-B562781981A0'),
}

model UpdateLiveSnapshotNotifyConfigResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveSnapshotNotifyConfigResponseBody(name='body'),
}

/**
  * @description You can call this operation up to 30 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveSnapshotNotifyConfig  UpdateLiveSnapshotNotifyConfigRequest
  * @return UpdateLiveSnapshotNotifyConfigResponse
 */
async function updateLiveSnapshotNotifyConfig(request: UpdateLiveSnapshotNotifyConfigRequest): UpdateLiveSnapshotNotifyConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveSnapshotNotifyConfig', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveStreamMonitorRequest {
  app?: string(name='App', description='The name of the application to which the output stream of the monitoring session belongs. You can specify a name. If you do not specify a name, the system uses **monitor** as the name of the application.', example='monitor****', position='Query'),
  callbackUrl?: string(name='CallbackUrl', description='The callback URL. Supported formats include HTTP and HTTPS.', example='http://guide.aliyundoc.com/notify', position='Query'),
  dingTalkWebHookUrl?: string(name='DingTalkWebHookUrl', description='The URL of the DingTalk chatbot. Specify a DingTalk chatbot that you have configured, and you can receive live monitoring alerts from the chatbot. For more information, see [Configure a custom chatbot](https://open.dingtalk.com/document/robots/custom-robot-access).

>  Specify "Alert" as the custom keyword of the DingTalk chatbot. Otherwise, you cannot receive messages.', example='https://oapi.dingtalk.com/robot/send?access_token=7a7d404056eee1f2fd944ace9bcfc361dc6448583e1d3d3baa****', position='Query'),
  domain?: string(name='Domain', description='The domain name.', example='demo.aliyundoc.com', position='Query'),
  inputList: string(name='InputList', description='The list of input streams to monitor. For more information, see the following **InputConfig** table.

This parameter is required.', example='InputConfig', position='Query'),
  monitorConfig?: string(name='MonitorConfig', description='The monitoring alert thresholds. The value is a JSON string. For more information, see the following MonitorConfig table.', example='"{\\"fpsLowThres\\": 0.6,\\"brLowThres\\": 1.1,\\"eofDurationThresSec\\": 10}"', position='Query'),
  monitorId: string(name='MonitorId', description='The ID of the monitoring session.

>  You can obtain the monitoring session ID from the response of the [CreateLiveStreamMonitor](https://help.aliyun.com/document_detail/2848129.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  monitorName?: string(name='MonitorName', description='The name of the monitoring session.', example='liveMonitor****', position='Query'),
  outputTemplate?: string(name='OutputTemplate', description='The output template of the monitoring session. Valid values:

*   **lp_ld**: low definition
*   **lp_sd**: standard definition
*   **lp_hd**: high definition
*   **lp_ud**: ultra-high definition', example='lp_ud', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  stream?: string(name='Stream', description='The name of the output stream of the monitoring session.', example='monitorStream****', position='Query'),
}

model UpdateLiveStreamMonitorResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0d-f228-4a64-af62-20e91b9676b3'),
}

model UpdateLiveStreamMonitorResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveStreamMonitorResponseBody(name='body'),
}

/**
  * @description You can call this operation to update the configurations of a monitoring session. The updates that you make to the input source configurations when the monitoring session is in the Running state immediately take effect.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveStreamMonitor  UpdateLiveStreamMonitorRequest
  * @return UpdateLiveStreamMonitorResponse
 */
async function updateLiveStreamMonitor(request: UpdateLiveStreamMonitorRequest): UpdateLiveStreamMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveStreamMonitor', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the stream belongs, and it cannot be modified.

This parameter is required.', example='liveApp****', position='Query'),
  domain: string(name='Domain', description='Streamer domain name, not modifiable.

This parameter is required.', example='example.com', position='Query'),
  encryptParameters?: string(name='EncryptParameters', description='The encryption configuration. The value is a JSON string. The following fields are included in the syntax:

*   EncryptType: the type of the encryption. Set the value to **aliyun**.
*   KmsKeyID: the ID of the CMK in KMS.
*   KmsKeyExpireInterval: the validity period of the CMK. Valid values: **60 to 3600**. Unit: seconds.', example='{"EncryptType": "aliyun", "KmsKeyID":"afce5722-81d2-43c3-9930-7601da11****","KmsKeyExpireInterval":"3600"}', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to enable triggered transcoding. Valid values:

*   **yes**: enables triggered transcoding.
*   **no**: disables triggered transcoding.', example='yes', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='Transcoding template, not modifiable.

This parameter is required.', example='lsd', position='Query'),
}

model UpdateLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='Request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description You must obtain the customer master key (CMK) in Key Management Service (KMS) before you call this operation to update a transcoding configuration. Only standard transcoding templates and Narrowband HD™ transcoding templates are supported for this operation.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 30 times per second per account.
  * @param request  the request parameters of UpdateLiveStreamTranscode  UpdateLiveStreamTranscodeRequest
  * @return UpdateLiveStreamTranscodeResponse
 */
async function updateLiveStreamTranscode(request: UpdateLiveStreamTranscodeRequest): UpdateLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveStreamWatermarkRequest {
  description?: string(name='Description', description='The description of the watermark.', example='my watermark', position='Query'),
  height?: int32(name='Height', description='The height of the watermark. Unit: pixel. The height of the watermark is scaled in proportion to the height of the background video.', example='200', position='Query'),
  name?: string(name='Name', description='The name of the watermark.', example='livewatermark****', position='Query'),
  offsetCorner?: string(name='OffsetCorner', description='The position of the watermark. Valid values:

*   TopLeft: the upper-left corner.
*   TopRight: the upper-right corner.
*   BottomLeft: the lower-left corner.
*   BottomRight: the lower-right corner.', example='TopRight', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pictureUrl?: string(name='PictureUrl', description='The URL of the watermark image.', example='http://example.com', position='Query'),
  refHeight?: int32(name='RefHeight', description='The height of the background video. Unit: pixel.', example='1080', position='Query'),
  refWidth?: int32(name='RefWidth', description='The width of the background video. Unit: pixel.', example='1920', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  templateId: string(name='TemplateId', description='The ID of the watermark template.

>  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/410759.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  transparency?: int32(name='Transparency', description='The transparency of the watermark. A smaller value indicates a more transparent watermark. Valid values: 0 to 255.', example='255', position='Query'),
  xOffset?: float(name='XOffset', description='The offset of the watermark along the x-axis. Unit: pixel.

>  In this case, the value of the RefWidth parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the XOffset parameter indicates the x-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the x-axis is positive toward the right.', example='50.0', position='Query'),
  yOffset?: float(name='YOffset', description='The offset of the watermark along the y-axis. Unit: pixel.

>  In this case, the value of the RefHeight parameter is used as the reference. If the OffsetCorner parameter is set to TopLeft, the value of the YOffset parameter indicates the y-axis offset of the upper-left corner of the watermark relative to that of the background video. The directions from the coordinate axes to the center of the background video are positive. In other words, the y-axis is positive downward.', example='100.0', position='Query'),
}

model UpdateLiveStreamWatermarkResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='5c6a2a0df228-4a64-af62-20e91b9676b3'),
}

model UpdateLiveStreamWatermarkResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveStreamWatermarkResponseBody(name='body'),
}

/**
  * @description This operation allows you to modify the parameters of a watermark template with a specified ID.
  * ## QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://www.alibabacloud.com/help/en/apsaravideo-live/latest/qps-limit-on-an-api-operation-in-apsaravideo-live).
  * @param request  the request parameters of UpdateLiveStreamWatermark  UpdateLiveStreamWatermarkRequest
  * @return UpdateLiveStreamWatermarkResponse
 */
async function updateLiveStreamWatermark(request: UpdateLiveStreamWatermarkRequest): UpdateLiveStreamWatermarkResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveStreamWatermark', 'POST', '/', 'json', false, 'json', request);
}

model UpdateLiveStreamWatermarkRuleRequest {
  description?: string(name='Description', description='The description of the custom rule.', example='my rule', position='Query'),
  name?: string(name='Name', description='The name of the custom rule.', example='WatermarkRule****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  ruleId: string(name='RuleId', description='The ID of the watermark rule.

>  You can obtain the rule ID by checking the value of the RuleId parameter that is returned by the [AddLiveStreamWatermarkRule](https://help.aliyun.com/document_detail/2848100.html) operation.

This parameter is required.', example='445409ec-7eaa-461d-8f29-4bec2eb9****', position='Query'),
  templateId?: string(name='TemplateId', description='The ID of the watermark template.

>  You can obtain the template ID by checking the value of the TemplateId parameter that is returned by the [AddLiveStreamWatermark](https://help.aliyun.com/document_detail/2848096.html) operation.', example='445409ec-7eaa-461d-8f29-4bec2eb9 ****', position='Query'),
}

model UpdateLiveStreamWatermarkRuleResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='5c6a2a0df228-4a64-af62-20e91b9676b3'),
}

model UpdateLiveStreamWatermarkRuleResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateLiveStreamWatermarkRuleResponseBody(name='body'),
}

/**
  * @description This operation allows you to modify the parameters of a watermark rule with a specified ID.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 60 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateLiveStreamWatermarkRule  UpdateLiveStreamWatermarkRuleRequest
  * @return UpdateLiveStreamWatermarkRuleResponse
 */
async function updateLiveStreamWatermarkRule(request: UpdateLiveStreamWatermarkRuleRequest): UpdateLiveStreamWatermarkRuleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateLiveStreamWatermarkRule', 'POST', '/', 'json', false, 'json', request);
}

model UpdateMessageAppRequest {
  appConfig?: map[string]string(name='AppConfig', description='The configurations of the application.', shrink='json', position='Body'),
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  appName?: string(name='AppName', description='The name of the interactive messaging application.', example='testApp', position='Body'),
  extension?: map[string]string(name='Extension', description='The extended field.', shrink='json', position='Body'),
}

model UpdateMessageAppResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the update is successful. Valid values:

*   true: The update is successful.
*   false: The update failed.', example='true'),
  }(name='Result', description='The returned result.'),
}

model UpdateMessageAppResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMessageAppResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of UpdateMessageApp  UpdateMessageAppRequest
  * @return UpdateMessageAppResponse
 */
async function updateMessageApp(request: UpdateMessageAppRequest): UpdateMessageAppResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMessageApp', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMessageGroupRequest {
  appId: string(name='AppId', description='The ID of the interactive messaging application.

This parameter is required.', example='VKL3***', position='Body'),
  extension?: map[string]string(name='Extension', description='The extended field.', shrink='json', position='Body'),
  groupId: string(name='GroupId', description='The ID of the message group.

This parameter is required.', example='AE35-****-T95F', position='Body'),
}

model UpdateMessageGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='16A96B9A-****-CB92E68F4CD8'),
  result?: {
    success?: boolean(name='Success', description='Indicates whether the update was successful. Valid values:

*   true: The update was successful.
*   false: The update failed.', example='true'),
  }(name='Result', description='The returned result.'),
}

model UpdateMessageGroupResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMessageGroupResponseBody(name='body'),
}

/**
  * @description ## QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limit on an API operation in ApsaraVideo Live](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of UpdateMessageGroup  UpdateMessageGroupRequest
  * @return UpdateMessageGroupResponse
 */
async function updateMessageGroup(request: UpdateMessageGroupRequest): UpdateMessageGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMessageGroup', 'POST', '/', 'json', true, 'form', request);
}

model UpdateMixStreamRequest {
  domainName: string(name='DomainName', description='The main streaming domain.

>  Only domain names that reside in the China (Shanghai) and China (Beijing) regions are supported.

This parameter is required.', example='example.com', position='Query'),
  inputStreamList: string(name='InputStreamList', description='The input streams, in a JSON array.

For more information, see **InputStreamConfig**.

This parameter is required.', example='{"InputStreamList":[{"LayoutConfig":{"fillSizeNormalized":[0.5,0.5],"fillPositionNormalized":[0,0],"positionRefer":"topLeft","fillMode":"fit"},"LayoutChildId":1,"ResourceValue":"rtmp://aliyundoc.com/caster/8564a8d1659b4dc69df5f66cf4c9****","ResourceType":"live"},{"LayoutConfig":{"fillSizeNormalized":[0.5,0.5],"fillPositionNormalized":[0.5,0],"positionRefer":"topLeft","fillMode":"fit"},"LayoutChildId":2,"ResourceValue":"http://developer.aliyundoc.com/3c3c25426cf744fdb90423e76b78a28a/69b1a16e2b1d423d9841bf27a96f134e-0b1cba51f58bb5ad3a854x96a2c735f****.mp4","ResourceType":"url"},{"LayoutConfig":{"fillSizeNormalized":[1,0.5],"fillPositionNormalized":[0,0.5],"positionRefer":"topLeft","fillMode":"fit"},"LayoutChildId":3,"ResourceValue":"http://aliyundoc.com/c0c6c5446b56432389e91535864938da/ed4adc5263b4474c954b95607a5350ae-fda757b3328438a8cf-4k57f373a0f0****.mp4","ResourceType":"url"}]}', position='Query'),
  layoutId?: string(name='LayoutId', description='The ID of the layout. Valid values:

*   **MixStreamLayout-1-1**
*   **MixStreamLayout-2-1**
*   **MixStreamLayout-2-2**
*   **MixStreamLayout-2-3**
*   **MixStreamLayout-3-1**
*   **MixStreamLayout-3-2**
*   **MixStreamLayout-4-1**
*   **USERDEFINED**: If you do not use a preset layout, set this parameter to **USERDEFINED**.

>  For more information, see [Preset layouts for stream mixing](https://help.aliyun.com/document_detail/199361.html).', example='MixStreamLayout-3-2', position='Query'),
  mixStreamId: string(name='MixStreamId', description='The ID of the stream mixing task. If the task was created by calling the [CreateMixStream](https://help.aliyun.com/document_detail/2848087.html) operation, check the value of the response parameter MixStreamId to obtain the ID.

This parameter is required.', example='5b2a046e-74d7-385e-d2d7-8a5b87e4****', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model UpdateMixStreamResponseBody = {
  mixStreamId?: string(name='MixStreamId', description='The ID of the stream mixing task. You can specify this parameter in a request to delete the stream mixing task or query stream mixing tasks.', example='5b2a046e-74d7-385e-d2d7-8a5b87e4****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1A8CDDFF-0121-4ABB-DA60-AEF095A8W34F'),
}

model UpdateMixStreamResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateMixStreamResponseBody(name='body'),
}

/**
  * @description You can call this operation to update a stream mixing task. This operation allows you to modify the input sources and layout, but not other parameters such as the output resolution.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateMixStream  UpdateMixStreamRequest
  * @return UpdateMixStreamResponse
 */
async function updateMixStream(request: UpdateMixStreamRequest): UpdateMixStreamResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateMixStream', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRtcCloudRecordingRequest {
  mixLayoutParams?: {
    mixBackground?: {
      renderMode?: int32(name='RenderMode', example='0'),
      url?: string(name='Url', example='https://xxxx.com/photos/my-test-picture.png', maxLength=2048),
    }(name='MixBackground'),
    userPanes?: [ 
      {
        height?: string(name='Height', example='0.5'),
        sourceType?: int32(name='SourceType', example='0'),
        subBackground?: {
          renderMode?: int32(name='RenderMode', example='0'),
          url?: string(name='Url', example='https://xxxx.com/photos/my-test-pane-picture.png', maxLength=2048),
        }(name='SubBackground'),
        userId?: string(name='UserId', example='userA'),
        width?: string(name='Width', example='0.5'),
        x?: string(name='X', example='0'),
        y?: string(name='Y', example='0'),
        zOrder?: int32(name='ZOrder', example='0'),
      }
    ](name='UserPanes'),
  }(name='MixLayoutParams', shrink='json', position='Query'),
  subscribeParams: {
    subscribeUserIdList: [ 
      {
        sourceType?: int32(name='SourceType', example='0'),
        streamType?: int32(name='StreamType', example='0'),
        userId: string(name='UserId', description='This parameter is required.', example='userA'),
      }
    ](name='SubscribeUserIdList', description='This parameter is required.'),
  }(name='SubscribeParams', description='This parameter is required.', shrink='json', position='Query'),
  taskId: string(name='TaskId', description='This parameter is required.', example='******73-8501-****-8ac1-72295a******', position='Query'),
}

model UpdateRtcCloudRecordingResponseBody = {
  requestId?: string(name='RequestId', example='******58-5876-****-83CA-B56278******'),
  taskId?: string(name='TaskId', example='******73-8501-****-8ac1-72295a******'),
}

model UpdateRtcCloudRecordingResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRtcCloudRecordingResponseBody(name='body'),
}

/**
  * @param request  the request parameters of UpdateRtcCloudRecording  UpdateRtcCloudRecordingRequest
  * @return UpdateRtcCloudRecordingResponse
 */
async function updateRtcCloudRecording(request: UpdateRtcCloudRecordingRequest): UpdateRtcCloudRecordingResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRtcCloudRecording', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRtcMPUEventSubRequest {
  appId: string(name='AppId', description='The ID of the application.

>  The ID can be up to 64 characters in length and can contain letters, digits, underscores (_), and hyphens (-).

This parameter is required.', example='yourAppId', position='Query'),
  callbackUrl?: string(name='CallbackUrl', description='The callback URL.

>  You can use headers such as HTTP and HTTPS in callback URLs. The URL can be up to 2,083 characters and contain letters, digits, and the following special characters: - _ ? % = # . / +', example='http://****.com/callback', position='Query'),
  channelIds?: string(name='ChannelIds', description='The ID of the channel to which you want to send mixed-stream relay event callbacks. Separate multiple channel IDs with commas (,).

> 

*   If you leave this parameter empty, you are subscribed to all mixed-stream relay events submitted in the application.

*   You cannot specify duplicate channel IDs. You can specify up to 20 channel IDs in each call.
*   The ID can be up to 64 characters in length and contain letters, digits, underscores (_), and hyphens (-).', example='yourChannelIds', position='Query'),
}

model UpdateRtcMPUEventSubResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='******3B-0E1A-586A-AC29-742247******'),
}

model UpdateRtcMPUEventSubResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRtcMPUEventSubResponseBody(name='body'),
}

/**
  * @description *   You can call this operation to update a subscription to mixed-stream relay events. You can modify parameters such as the callback URL and channel IDs.
  * *   Before you call this operation, make sure that you have called the CreateRtcMPUEventSub operation to create the subscription.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 50 times per second per account. Requests that exceed this limit are dropped and you will experience service interruptions. We recommend that you take note of this limit when you call this operation.
  * @param request  the request parameters of UpdateRtcMPUEventSub  UpdateRtcMPUEventSubRequest
  * @return UpdateRtcMPUEventSubResponse
 */
async function updateRtcMPUEventSub(request: UpdateRtcMPUEventSubRequest): UpdateRtcMPUEventSubResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRtcMPUEventSub', 'POST', '/', 'json', false, 'json', request);
}

model UpdateRtsLiveStreamTranscodeRequest {
  app: string(name='App', description='The name of the application to which the live stream belongs, which cannot be modified.

This parameter is required.', example='aliyun-test', position='Query'),
  audioBitrate?: int32(name='AudioBitrate', description='The bitrate of the output audio. Unit: Kbit/s. Valid values: 1 to 1000.

>  This parameter is required if you set the TemplateType parameter to audio.', example='128', position='Query'),
  audioChannelNum?: int32(name='AudioChannelNum', description='The number of sound channels. Valid values:

*   **1**: mono
*   **2**: stereo', example='2', position='Query'),
  audioCodec?: string(name='AudioCodec', description='The audio encoder. Valid values:

*   aac
*   mp3

>  To use the Opus encoder, you need only to set the Opus parameter to true.', example='aac', position='Query'),
  audioProfile?: string(name='AudioProfile', description='The audio codec profile. Valid values:

*   aac_low
*   aac_he
*   aac_he_v2
*   aac_ld', example='aac_low', position='Query'),
  audioRate?: int32(name='AudioRate', description='The audio sampling rate. Valid values: 22050, 32000, 44100, 48000, and 96000. 44100 is commonly used. Unit: Hz.

>  If the value of the AudioProfile parameter is aac_ld, the audio sampling rate cannot exceed 44,100.', example='44100', position='Query'),
  deleteBframes?: boolean(name='DeleteBframes', description='Specifies whether to remove B frames during transcoding. Valid values:

*   true: Remove B frames.
*   false (default): Retain B frames.

> 

*   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.

*   If this parameter is not specified, the default value false is used.', example='false', position='Query'),
  domain: string(name='Domain', description='The main streaming domain, which cannot be modified.

This parameter is required.', example='example.com', position='Query'),
  FPS?: int32(name='FPS', description='The frame rate of the output video. Unit: frames per second (FPS). Valid values: 1 to 60.

>  This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.', example='30', position='Query'),
  gop?: string(name='Gop', description='The group of pictures (GOP) of the output video. This parameter is used to specify the keyframe interval. Unit: seconds. Valid values: 1 to 3.', example='2', position='Query'),
  height?: int32(name='Height', description='The height of the output video. Unit: pixel.

The value must comply with the following rules:

*   Height ≥ 100: The height of the video is at least 100 pixels.
*   max(Height,Width) ≤ 2560: The larger of the width and height of the video cannot exceed 2,560 pixels.
*   min(Height,Width) ≤ 1440: The smaller of the width and height of the video cannot exceed 1,440 pixels. For example, a resolution of 1560 × 1560 pixels is invalid.

> 

*   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.

*   If the TemplateType parameter is set to h264-origin, the highest resolution supported is 4K.', example='1280', position='Query'),
  lazy?: string(name='Lazy', description='Specifies whether to enable triggered transcoding. Valid values:

*   **yes**: enables triggered transcoding.
*   **no**: disables triggered transcoding.', example='no', position='Query'),
  opus?: boolean(name='Opus', description='Specifies whether to transcode streams to the Opus format to be compatible with native WebRTC. Valid values:

*   true: Transcode streams to the Opus format.
*   false: Do not transcode streams to the Opus format.

>  If this parameter is not specified, the default value false is used.', example='true', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  profile?: int32(name='Profile', description='The video encoding profile. The profile defines a set of parameters that are used to encode a video. In most cases, a greater value indicates better image quality and higher resource consumption. Valid values:

*   **1**: baseline. This value is suitable for mobile devices.
*   **2**: main. This value is suitable for standard-definition devices.
*   **3**: high. This value is suitable for high-definition devices.', example='2', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  template: string(name='Template', description='The ID of the custom transcoding template, which cannot be modified.

This parameter is required.', example='ld', position='Query'),
  templateType: string(name='TemplateType', description='The type of the custom transcoding template, which cannot be modified.

This parameter is required.', example='h264', position='Query'),
  videoBitrate?: int32(name='VideoBitrate', description='The bitrate of the output video. Unit: Kbit/s. Valid values: 1 to 6000.

> 

*   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.

*   The bitrate of the output video is as close to the value that you specify as possible, but not the same as the value, especially when the value is excessively large or small.', example='2000', position='Query'),
  width?: int32(name='Width', description='The width of the output video. Unit: pixel.

The value must comply with the following rules:

*   Width ≥ 100: The width of the video is at least 100 pixels.
*   max(Height,Width) ≤ 2560: The larger of the width and height of the video cannot exceed 2,560 pixels.
*   min(Height,Width) ≤ 1440: The smaller of the width and height of the video cannot exceed 1,440 pixels. For example, a resolution of 1560 × 1560 pixels is invalid.

> 

*   This parameter is required when the TemplateType parameter is set to h264, h264-nbhd, or h264-origin.

*   If the TemplateType parameter is set to h264-origin, the highest resolution supported is 4K.', example='720', position='Query'),
}

model UpdateRtsLiveStreamTranscodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='16A96B9A-F203-4EC5-8E43-CB92E68F4CD8'),
}

model UpdateRtsLiveStreamTranscodeResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: UpdateRtsLiveStreamTranscodeResponseBody(name='body'),
}

/**
  * @description This operation supports the following types of custom transcoding templates: h264, h264-nbhd, h264-origin, and audio.
  * ## [](#qps-)QPS limit
  * You can call this operation up to 10 times per second per account.
  * @param request  the request parameters of UpdateRtsLiveStreamTranscode  UpdateRtsLiveStreamTranscodeRequest
  * @return UpdateRtsLiveStreamTranscodeResponse
 */
async function updateRtsLiveStreamTranscode(request: UpdateRtsLiveStreamTranscodeRequest): UpdateRtsLiveStreamTranscodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateRtsLiveStreamTranscode', 'POST', '/', 'json', false, 'json', request);
}

model VerifyLiveDomainOwnerRequest {
  domainName: string(name='DomainName', description='The domain name for which you want to verify the ownership. You can specify only one domain name in each request.

This parameter is required.', example='example.com', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  verifyType: string(name='VerifyType', description='The verification method. Valid values:

*   dnsCheck: DNS record verification
*   fileCheck: file verification

This parameter is required.', example='dnsCheck', position='Query'),
}

model VerifyLiveDomainOwnerResponseBody = {
  content?: string(name='Content', description='The verification information.', example='verify_dffeb6610035dcb77b413******'),
  requestId?: string(name='RequestId', description='The request ID.', example='1BA6D7CE-55F1-5926-8764-F8663473AD0D'),
}

model VerifyLiveDomainOwnerResponse = {
  headers?: map[string]string(name='headers'),
  statusCode?: int32(name='statusCode'),
  body?: VerifyLiveDomainOwnerResponseBody(name='body'),
}

/**
  * @description ### [](#qps-)QPS limit
  * You can call this operation up to 100 times per second per account. Requests that exceed this limit are dropped and you may experience service interruptions. We recommend that you take note of this limit when you call this operation. For more information, see [QPS limits](https://help.aliyun.com/document_detail/343507.html).
  * @param request  the request parameters of VerifyLiveDomainOwner  VerifyLiveDomainOwnerRequest
  * @return VerifyLiveDomainOwnerResponse
 */
async function verifyLiveDomainOwner(request: VerifyLiveDomainOwnerRequest): VerifyLiveDomainOwnerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'VerifyLiveDomainOwner', 'POST', '/', 'json', false, 'json', request);
}

