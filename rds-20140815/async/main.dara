/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Rds';
  @version = '2014-08-15';
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'rds.aliyuncs.com',
    cn-beijing = 'rds.aliyuncs.com',
    cn-hangzhou = 'rds.aliyuncs.com',
    cn-shanghai = 'rds.aliyuncs.com',
    cn-shenzhen = 'rds.aliyuncs.com',
    cn-heyuan = 'rds.aliyuncs.com',
    cn-hongkong = 'rds.aliyuncs.com',
    ap-southeast-1 = 'rds.aliyuncs.com',
    us-west-1 = 'rds.aliyuncs.com',
    us-east-1 = 'rds.aliyuncs.com',
    cn-shanghai-finance-1 = 'rds.aliyuncs.com',
    cn-shenzhen-finance-1 = 'rds.aliyuncs.com',
    cn-north-2-gov-1 = 'rds.aliyuncs.com',
    ap-northeast-2-pop = 'rds.aliyuncs.com',
    cn-beijing-finance-1 = 'rds.aliyuncs.com',
    cn-beijing-finance-pop = 'rds.aliyuncs.com',
    cn-beijing-gov-1 = 'rds.aliyuncs.com',
    cn-beijing-nu16-b01 = 'rds.aliyuncs.com',
    cn-edge-1 = 'rds.aliyuncs.com',
    cn-fujian = 'rds.aliyuncs.com',
    cn-haidian-cm12-c01 = 'rds.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'rds.aliyuncs.com',
    cn-hangzhou-finance = 'rds-vpc.cn-hangzhou-finance.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'rds.aliyuncs.com',
    cn-hangzhou-test-306 = 'rds.aliyuncs.com',
    cn-hongkong-finance-pop = 'rds.aliyuncs.com',
    cn-qingdao-nebula = 'rds.aliyuncs.com',
    cn-shanghai-et15-b01 = 'rds.aliyuncs.com',
    cn-shanghai-et2-b01 = 'rds.aliyuncs.com',
    cn-shanghai-inner = 'rds.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'rds.aliyuncs.com',
    cn-shenzhen-inner = 'rds.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'rds.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'rds.aliyuncs.com',
    cn-wuhan = 'rds.aliyuncs.com',
    cn-yushanfang = 'rds.aliyuncs.com',
    cn-zhangbei = 'rds.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'rds.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'rds.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'rds.aliyuncs.com',
    eu-west-1-oxs = 'rds.aliyuncs.com',
    rus-west-1-pop = 'rds.aliyuncs.com',
  };
}

function close(): void {
  @handler.close();
}

model ActivateMigrationTargetInstanceRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  forceSwitch?: string(name='ForceSwitch', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  switchTimeMode?: string(name='SwitchTimeMode', position='Query'),
}

model ActivateMigrationTargetInstanceResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePort?: long(name='SourcePort'),
  taskId?: long(name='TaskId'),
}

model ActivateMigrationTargetInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ActivateMigrationTargetInstanceResponseBody(name='body'),
}

async function activateMigrationTargetInstance(request: ActivateMigrationTargetInstanceRequest): ActivateMigrationTargetInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ActivateMigrationTargetInstance', 'POST', '/', 'json', false, 'json', request);
}

model AddTagsToResourceRequest {
  tag?: [
    {
      key?: string(name='key', position=''),
      value?: string(name='value', position=''),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model AddTagsToResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsToResourceResponse = {
  headers: map[string]string(name='headers'),
  body: AddTagsToResourceResponseBody(name='body'),
}

async function addTagsToResource(request: AddTagsToResourceRequest): AddTagsToResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AddTagsToResource', 'POST', '/', 'json', false, 'json', request);
}

model AllocateInstancePublicConnectionRequest {
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  generalGroupName?: string(name='GeneralGroupName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model AllocateInstancePublicConnectionResponseBody = {
  connectionString?: string(name='ConnectionString'),
  dbInstanceName?: string(name='DbInstanceName'),
  requestId?: string(name='RequestId'),
}

model AllocateInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateInstancePublicConnectionResponseBody(name='body'),
}

async function allocateInstancePublicConnection(request: AllocateInstancePublicConnectionRequest): AllocateInstancePublicConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateInstancePublicConnection', 'POST', '/', 'json', false, 'json', request);
}

model AllocateReadWriteSplittingConnectionRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  distributionType?: string(name='DistributionType', position='Query'),
  maxDelayTime?: string(name='MaxDelayTime', position='Query'),
  netType?: string(name='NetType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  weight?: string(name='Weight', position='Query'),
}

model AllocateReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocateReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: AllocateReadWriteSplittingConnectionResponseBody(name='body'),
}

async function allocateReadWriteSplittingConnection(request: AllocateReadWriteSplittingConnectionRequest): AllocateReadWriteSplittingConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'AllocateReadWriteSplittingConnection', 'POST', '/', 'json', false, 'json', request);
}

model CalculateDBInstanceWeightRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CalculateDBInstanceWeightResponseBody = {
  items?: {
    DBInstanceWeight?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceType?: string(name='DBInstanceType'),
      readonlyInstanceSQLDelayedTime?: string(name='ReadonlyInstanceSQLDelayedTime'),
      role?: string(name='Role'),
      weight?: string(name='Weight'),
    }
  ](name='DBInstanceWeight')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model CalculateDBInstanceWeightResponse = {
  headers: map[string]string(name='headers'),
  body: CalculateDBInstanceWeightResponseBody(name='body'),
}

async function calculateDBInstanceWeight(request: CalculateDBInstanceWeightRequest): CalculateDBInstanceWeightResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CalculateDBInstanceWeight', 'POST', '/', 'json', false, 'json', request);
}

model CancelImportRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  importId: int32(name='ImportId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CancelImportResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelImportResponse = {
  headers: map[string]string(name='headers'),
  body: CancelImportResponseBody(name='body'),
}

async function cancelImport(request: CancelImportRequest): CancelImportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelImport', 'POST', '/', 'json', false, 'json', request);
}

model CheckAccountNameAvailableRequest {
  accountName: string(name='AccountName', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckAccountNameAvailableResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckAccountNameAvailableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckAccountNameAvailableResponseBody(name='body'),
}

async function checkAccountNameAvailable(request: CheckAccountNameAvailableRequest): CheckAccountNameAvailableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckAccountNameAvailable', 'POST', '/', 'json', false, 'json', request);
}

model CheckCloudResourceAuthorizedRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  targetRegionId?: string(name='TargetRegionId', position='Query'),
}

model CheckCloudResourceAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
}

model CheckCloudResourceAuthorizedResponse = {
  headers: map[string]string(name='headers'),
  body: CheckCloudResourceAuthorizedResponseBody(name='body'),
}

async function checkCloudResourceAuthorized(request: CheckCloudResourceAuthorizedRequest): CheckCloudResourceAuthorizedResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckCloudResourceAuthorized', 'POST', '/', 'json', false, 'json', request);
}

model CheckCreateDdrDBInstanceRequest {
  backupSetId?: string(name='BackupSetId', position='Query'),
  binlogName?: string(name='BinlogName', position='Query'),
  binlogPosition?: string(name='BinlogPosition', position='Query'),
  binlogRole?: string(name='BinlogRole', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  restoreType: string(name='RestoreType', position='Query'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName', position='Query'),
  sourceRegion?: string(name='SourceRegion', position='Query'),
}

model CheckCreateDdrDBInstanceResponseBody = {
  isValid?: string(name='IsValid'),
  requestId?: string(name='RequestId'),
}

model CheckCreateDdrDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CheckCreateDdrDBInstanceResponseBody(name='body'),
}

async function checkCreateDdrDBInstance(request: CheckCreateDdrDBInstanceRequest): CheckCreateDdrDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckCreateDdrDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CheckDBNameAvailableRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckDBNameAvailableResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckDBNameAvailableResponse = {
  headers: map[string]string(name='headers'),
  body: CheckDBNameAvailableResponseBody(name='body'),
}

async function checkDBNameAvailable(request: CheckDBNameAvailableRequest): CheckDBNameAvailableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckDBNameAvailable', 'POST', '/', 'json', false, 'json', request);
}

model CheckInstanceExistRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CheckInstanceExistResponseBody = {
  isExistInstance?: boolean(name='IsExistInstance'),
  requestId?: string(name='RequestId'),
}

model CheckInstanceExistResponse = {
  headers: map[string]string(name='headers'),
  body: CheckInstanceExistResponseBody(name='body'),
}

async function checkInstanceExist(request: CheckInstanceExistRequest): CheckInstanceExistResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CheckInstanceExist', 'POST', '/', 'json', false, 'json', request);
}

model ClearDedicatedHostRequest {
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  failoverMode: string(name='FailoverMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ClearDedicatedHostResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ClearDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: ClearDedicatedHostResponseBody(name='body'),
}

async function clearDedicatedHost(request: ClearDedicatedHostRequest): ClearDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ClearDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model CloneDBInstanceRequest {
  backupId?: string(name='BackupId', position='Query'),
  backupType?: string(name='BackupType', position='Query'),
  category?: string(name='Category', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId: string(name='DBInstanceId', minLength=1, maxLength=65535, position='Query'),
  DBInstanceStorage?: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  dbNames?: string(name='DbNames', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTable?: string(name='RestoreTable', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  tableMeta?: string(name='TableMeta', position='Query'),
  usedTime?: int32(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CloneDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CloneDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CloneDBInstanceResponseBody(name='body'),
}

async function cloneDBInstance(request: CloneDBInstanceRequest): CloneDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CloneParameterGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', position='Query'),
  parameterGroupName: string(name='ParameterGroupName', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetRegionId: string(name='TargetRegionId', position='Query'),
}

model CloneParameterGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloneParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CloneParameterGroupResponseBody(name='body'),
}

async function cloneParameterGroup(request: CloneParameterGroupRequest): CloneParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CloneParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model CopyDatabaseRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CopyDatabaseResponseBody = {
  DBName?: string(name='DBName'),
  DBStatus?: string(name='DBStatus'),
  taskId?: string(name='TaskId'),
}

model CopyDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CopyDatabaseResponseBody(name='body'),
}

async function copyDatabase(request: CopyDatabaseRequest): CopyDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyDatabase', 'POST', '/', 'json', false, 'json', request);
}

model CopyDatabaseBetweenInstancesRequest {
  backupId?: string(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  dbNames: string(name='DbNames', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  syncUserPrivilege?: string(name='SyncUserPrivilege', position='Query'),
  targetDBInstanceId: string(name='TargetDBInstanceId', position='Query'),
}

model CopyDatabaseBetweenInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyDatabaseBetweenInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: CopyDatabaseBetweenInstancesResponseBody(name='body'),
}

async function copyDatabaseBetweenInstances(request: CopyDatabaseBetweenInstancesRequest): CopyDatabaseBetweenInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyDatabaseBetweenInstances', 'POST', '/', 'json', false, 'json', request);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription', position='Query'),
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  accountType?: string(name='AccountType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CreateAccountResponseBody(name='body'),
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateAccount', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupRequest {
  backupMethod?: string(name='BackupMethod', position='Query'),
  backupStrategy?: string(name='BackupStrategy', position='Query'),
  backupType?: string(name='BackupType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateBackupResponseBody = {
  backupJobId?: string(name='BackupJobId'),
  requestId?: string(name='RequestId'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupResponseBody(name='body'),
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackup', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudMigrationPrecheckTaskRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceAccount: string(name='SourceAccount', position='Query'),
  sourceCategory: string(name='SourceCategory', position='Query'),
  sourceIpAddress: string(name='SourceIpAddress', position='Query'),
  sourcePassword: string(name='SourcePassword', position='Query'),
  sourcePort: long(name='SourcePort', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model CreateCloudMigrationPrecheckTaskResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationPrecheckTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCloudMigrationPrecheckTaskResponseBody(name='body'),
}

async function createCloudMigrationPrecheckTask(request: CreateCloudMigrationPrecheckTaskRequest): CreateCloudMigrationPrecheckTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudMigrationPrecheckTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateCloudMigrationTaskRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceAccount: string(name='SourceAccount', position='Query'),
  sourceCategory: string(name='SourceCategory', position='Query'),
  sourceIpAddress: string(name='SourceIpAddress', position='Query'),
  sourcePassword: string(name='SourcePassword', position='Query'),
  sourcePort: long(name='SourcePort', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model CreateCloudMigrationTaskResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateCloudMigrationTaskResponseBody(name='body'),
}

async function createCloudMigrationTask(request: CreateCloudMigrationTaskRequest): CreateCloudMigrationTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateCloudMigrationTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBInstanceRequest {
  amount?: int32(name='Amount', position='Query'),
  autoRenew?: string(name='AutoRenew', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  category?: string(name='Category', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionMode?: string(name='ConnectionMode', position='Query'),
  createStrategy?: string(name='CreateStrategy', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceNetType: string(name='DBInstanceNetType', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  DBIsIgnoreCase?: string(name='DBIsIgnoreCase', position='Query'),
  DBParamGroupId?: string(name='DBParamGroupId', position='Query'),
  DBTimeZone?: string(name='DBTimeZone', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  dryRun?: boolean(name='DryRun', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleARN?: string(name='RoleARN', position='Query'),
  securityIPList: string(name='SecurityIPList', position='Query'),
  storageAutoScale?: string(name='StorageAutoScale', position='Query'),
  storageThreshold?: int32(name='StorageThreshold', position='Query'),
  storageUpperBound?: int32(name='StorageUpperBound', minimum=0, position='Query'),
  systemDBCharset?: string(name='SystemDBCharset', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog', position='Query'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster', position='Query'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave', position='Query'),
  targetMinorVersion?: string(name='TargetMinorVersion', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  userBackupId?: string(name='UserBackupId', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  zoneIdSlave1?: string(name='ZoneIdSlave1', position='Query'),
  zoneIdSlave2?: string(name='ZoneIdSlave2', position='Query'),
}

model CreateDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  dryRun?: boolean(name='DryRun'),
  dryRunResult?: boolean(name='DryRunResult'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
  tagResult?: boolean(name='TagResult'),
  taskId?: string(name='TaskId'),
}

model CreateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBInstanceResponseBody(name='body'),
}

async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateDBProxyEndpointAddressRequest {
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType', position='Query'),
  DBProxyEndpointId: string(name='DBProxyEndpointId', position='Query'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model CreateDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDBProxyEndpointAddressResponseBody(name='body'),
}

async function createDBProxyEndpointAddress(request: CreateDBProxyEndpointAddressRequest): CreateDBProxyEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDBProxyEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model CreateDatabaseRequest {
  characterSetName: string(name='CharacterSetName', position='Query'),
  DBDescription?: string(name='DBDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDatabase', 'POST', '/', 'json', false, 'json', request);
}

model CreateDdrInstanceRequest {
  backupSetId?: string(name='BackupSetId', position='Query'),
  binlogName?: string(name='BinlogName', position='Query'),
  binlogPosition?: string(name='BinlogPosition', position='Query'),
  binlogRole?: string(name='BinlogRole', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  connectionMode?: string(name='ConnectionMode', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceNetType: string(name='DBInstanceNetType', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  restoreType: string(name='RestoreType', position='Query'),
  securityIPList: string(name='SecurityIPList', position='Query'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName', position='Query'),
  sourceRegion?: string(name='SourceRegion', position='Query'),
  systemDBCharset?: string(name='SystemDBCharset', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model CreateDdrInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateDdrInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDdrInstanceResponseBody(name='body'),
}

async function createDdrInstance(request: CreateDdrInstanceRequest): CreateDdrInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDdrInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedHostRequest {
  autoRenew: string(name='AutoRenew', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  hostClass: string(name='HostClass', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  vSwitchId: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateDedicatedHostResponseBody = {
  dedicateHostList?: {
    dedicateHostList?: [ 
    {
      dedicatedHostId?: string(name='DedicatedHostId'),
    }
  ](name='DedicateHostList')
  }(name='DedicateHostList'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostResponseBody(name='body'),
}

async function createDedicatedHost(request: CreateDedicatedHostRequest): CreateDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedHostAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostAccountResponseBody(name='body'),
}

async function createDedicatedHostAccount(request: CreateDedicatedHostAccountRequest): CreateDedicatedHostAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHostAccount', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedHostGroupRequest {
  allocationPolicy?: string(name='AllocationPolicy', position='Query'),
  clientToken: string(name='ClientToken', position='Query'),
  cpuAllocationRatio?: int32(name='CpuAllocationRatio', position='Query'),
  diskAllocationRatio?: int32(name='DiskAllocationRatio', position='Query'),
  engine: string(name='Engine', position='Query'),
  hostReplacePolicy?: string(name='HostReplacePolicy', position='Query'),
  memAllocationRatio?: int32(name='MemAllocationRatio', position='Query'),
  openPermission?: int32(name='OpenPermission', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VPCId: string(name='VPCId', position='Query'),
}

model CreateDedicatedHostGroupResponseBody = {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostGroupResponseBody(name='body'),
}

async function createDedicatedHostGroup(request: CreateDedicatedHostGroupRequest): CreateDedicatedHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDedicatedHostUserRequest {
  dedicatedHostName: string(name='DedicatedHostName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userName: string(name='UserName', position='Query'),
  userPassword: string(name='UserPassword', position='Query'),
}

model CreateDedicatedHostUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDedicatedHostUserResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDedicatedHostUserResponseBody(name='body'),
}

async function createDedicatedHostUser(request: CreateDedicatedHostUserRequest): CreateDedicatedHostUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDedicatedHostUser', 'POST', '/', 'json', false, 'json', request);
}

model CreateDiagnosticReportRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model CreateDiagnosticReportResponseBody = {
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDiagnosticReport', 'POST', '/', 'json', false, 'json', request);
}

model CreateGADInstanceRequest {
  centralDBInstanceId: string(name='CentralDBInstanceId', position='Query'),
  centralRdsDtsAdminAccount: string(name='CentralRdsDtsAdminAccount', position='Query'),
  centralRdsDtsAdminPassword: string(name='CentralRdsDtsAdminPassword', position='Query'),
  centralRegionId: string(name='CentralRegionId', position='Query'),
  DBList: string(name='DBList', position='Query'),
  description?: string(name='Description', position='Query'),
  unitNode: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceStorage?: long(name='DBInstanceStorage'),
      dbInstanceClass?: string(name='DbInstanceClass'),
      dtsConflict: string(name='DtsConflict'),
      dtsInstanceClass: string(name='DtsInstanceClass'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      payType?: string(name='PayType'),
      regionID: string(name='RegionID'),
      securityIPList?: string(name='SecurityIPList'),
      vSwitchID?: string(name='VSwitchID'),
      vpcID?: string(name='VpcID'),
      zoneID?: string(name='ZoneID'),
      zoneIDSlave1?: string(name='ZoneIDSlave1'),
      zoneIDSlave2?: string(name='ZoneIDSlave2'),
    }
  ](name='UnitNode', position='Query'),
}

model CreateGADInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createMemberCount?: string(name='CreateMemberCount'),
    gadInstanceName?: string(name='GadInstanceName'),
    taskID?: string(name='TaskID'),
  }(name='Result'),
}

model CreateGADInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGADInstanceResponseBody(name='body'),
}

async function createGADInstance(request: CreateGADInstanceRequest): CreateGADInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGADInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateGadInstanceMemberRequest {
  centralDBInstanceId: string(name='CentralDBInstanceId', position='Query'),
  centralRdsDtsAdminAccount: string(name='CentralRdsDtsAdminAccount', position='Query'),
  centralRdsDtsAdminPassword: string(name='CentralRdsDtsAdminPassword', position='Query'),
  centralRegionId: string(name='CentralRegionId', position='Query'),
  DBList: string(name='DBList', position='Query'),
  gadInstanceId: string(name='GadInstanceId', position='Query'),
  unitNode: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceStorage?: long(name='DBInstanceStorage'),
      dbInstanceClass?: string(name='DbInstanceClass'),
      dtsConflict: string(name='DtsConflict'),
      dtsInstanceClass: string(name='DtsInstanceClass'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      regionID: string(name='RegionID'),
      securityIPList?: string(name='SecurityIPList'),
      vSwitchID: string(name='VSwitchID'),
      vpcID: string(name='VpcID'),
      zoneID?: string(name='ZoneID'),
      zoneIDSlave1?: string(name='ZoneIDSlave1'),
      zoneIDSlave2?: string(name='ZoneIDSlave2'),
    }
  ](name='UnitNode', position='Query'),
}

model CreateGadInstanceMemberResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  result?: {
    createCount?: string(name='CreateCount'),
    gadInstanceName?: string(name='GadInstanceName'),
  }(name='Result'),
}

model CreateGadInstanceMemberResponse = {
  headers: map[string]string(name='headers'),
  body: CreateGadInstanceMemberResponseBody(name='body'),
}

async function createGadInstanceMember(request: CreateGadInstanceMemberRequest): CreateGadInstanceMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateGadInstanceMember', 'POST', '/', 'json', false, 'json', request);
}

model CreateMigrateTaskRequest {
  backupMode: string(name='BackupMode', position='Query'),
  checkDBMode?: string(name='CheckDBMode', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  isOnlineDB: string(name='IsOnlineDB', position='Query'),
  migrateTaskId?: string(name='MigrateTaskId', position='Query'),
  OSSUrls?: string(name='OSSUrls', position='Query'),
  ossObjectPositions?: string(name='OssObjectPositions', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateMigrateTaskResponseBody = {
  backupMode?: string(name='BackupMode'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateMigrateTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMigrateTaskResponseBody(name='body'),
}

async function createMigrateTask(request: CreateMigrateTaskRequest): CreateMigrateTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMigrateTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateMigrateTaskForSQLServerRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  isOnlineDB: string(name='IsOnlineDB', position='Query'),
  OSSUrls: string(name='OSSUrls', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskType: string(name='TaskType', position='Query'),
}

model CreateMigrateTaskForSQLServerResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceName?: string(name='DBInstanceName'),
  DBName?: string(name='DBName'),
  migrateIaskId?: string(name='MigrateIaskId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  taskType?: string(name='TaskType'),
}

model CreateMigrateTaskForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  body: CreateMigrateTaskForSQLServerResponseBody(name='body'),
}

async function createMigrateTaskForSQLServer(request: CreateMigrateTaskForSQLServerRequest): CreateMigrateTaskForSQLServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateMigrateTaskForSQLServer', 'POST', '/', 'json', false, 'json', request);
}

model CreateOnlineDatabaseTaskRequest {
  checkDBMode: string(name='CheckDBMode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  migrateTaskId: string(name='MigrateTaskId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateOnlineDatabaseTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateOnlineDatabaseTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateOnlineDatabaseTaskResponseBody(name='body'),
}

async function createOnlineDatabaseTask(request: CreateOnlineDatabaseTaskRequest): CreateOnlineDatabaseTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateOnlineDatabaseTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateParameterGroupRequest {
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', position='Query'),
  parameterGroupName: string(name='ParameterGroupName', position='Query'),
  parameters: string(name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateParameterGroupResponseBody(name='body'),
}

async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateReadOnlyDBInstanceRequest {
  autoRenew?: string(name='AutoRenew', position='Query'),
  category?: string(name='Category', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceDescription?: string(name='DBInstanceDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  gdnInstanceName?: string(name='GdnInstanceName', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  instructionSetArch?: string(name='InstructionSetArch', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster', position='Query'),
  tddlBizType?: string(name='TddlBizType', position='Query'),
  tddlRegionConfig?: string(name='TddlRegionConfig', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model CreateReadOnlyDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateReadOnlyDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateReadOnlyDBInstanceResponseBody(name='body'),
}

async function createReadOnlyDBInstance(request: CreateReadOnlyDBInstanceRequest): CreateReadOnlyDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateReadOnlyDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model CreateServiceLinkedRoleRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  serviceLinkedRole: string(name='ServiceLinkedRole', position='Query'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateServiceLinkedRole', 'POST', '/', 'json', false, 'json', request);
}

model CreateTempDBInstanceRequest {
  backupId?: int32(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
}

model CreateTempDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  tempDBInstanceId?: string(name='TempDBInstanceId'),
}

model CreateTempDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateTempDBInstanceResponseBody(name='body'),
}

async function createTempDBInstance(request: CreateTempDBInstanceRequest): CreateTempDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateTempDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccountResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteAccountResponseBody(name='body'),
}

async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteAccount', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupRequest {
  backupId: string(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBackupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBackupResponseBody(name='body'),
}

async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupFileRequest {
  backupId?: string(name='BackupId', position='Query'),
  backupTime?: string(name='BackupTime', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteBackupFileResponseBody = {
  deletedBaksetIds?: {
    deletedBaksetIds?: [ int32 ](name='DeletedBaksetIds')
  }(name='DeletedBaksetIds'),
  requestId?: string(name='RequestId'),
}

model DeleteBackupFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBackupFileResponseBody(name='body'),
}

async function deleteBackupFile(request: DeleteBackupFileRequest): DeleteBackupFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackupFile', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDBInstanceResponseBody = {
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DeleteDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDBInstanceResponseBody(name='body'),
}

async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDBProxyEndpointAddressRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyConnectStringNetType: string(name='DBProxyConnectStringNetType', position='Query'),
  DBProxyEndpointId: string(name='DBProxyEndpointId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDBProxyEndpointAddressResponseBody(name='body'),
}

async function deleteDBProxyEndpointAddress(request: DeleteDBProxyEndpointAddressRequest): DeleteDBProxyEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDBProxyEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDatabaseRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDedicatedHostAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDedicatedHostAccountResponseBody(name='body'),
}

async function deleteDedicatedHostAccount(request: DeleteDedicatedHostAccountRequest): DeleteDedicatedHostAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDedicatedHostAccount', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDedicatedHostGroupRequest {
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDedicatedHostGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedHostGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteDedicatedHostGroupResponseBody(name='body'),
}

async function deleteDedicatedHostGroup(request: DeleteDedicatedHostGroupRequest): DeleteDedicatedHostGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDedicatedHostGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteGadInstanceRequest {
  gadInstanceName: string(name='GadInstanceName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DeleteGadInstanceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DeleteGadInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteGadInstanceResponseBody(name='body'),
}

async function deleteGadInstance(request: DeleteGadInstanceRequest): DeleteGadInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteGadInstance', 'POST', '/', 'json', false, 'json', request);
}

model DeleteParameterGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model DeleteParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteParameterGroupResponseBody(name='body'),
}

async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteUserBackupFileRequest {
  backupId: string(name='BackupId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
}

model DeleteUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteUserBackupFileResponseBody(name='body'),
}

async function deleteUserBackupFile(request: DeleteUserBackupFileRequest): DeleteUserBackupFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteUserBackupFile', 'POST', '/', 'json', false, 'json', request);
}

model DescibeImportsFromDatabaseRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  engine: string(name='Engine', position='Query'),
  importId?: int32(name='ImportId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescibeImportsFromDatabaseResponseBody = {
  items?: {
    importResultFromDB?: [ 
    {
      importDataStatus?: string(name='ImportDataStatus'),
      importDataStatusDescription?: string(name='ImportDataStatusDescription'),
      importDataType?: string(name='ImportDataType'),
      importId?: int32(name='ImportId'),
      incrementalImportingTime?: string(name='IncrementalImportingTime'),
    }
  ](name='ImportResultFromDB')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescibeImportsFromDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DescibeImportsFromDatabaseResponseBody(name='body'),
}

async function descibeImportsFromDatabase(request: DescibeImportsFromDatabaseRequest): DescibeImportsFromDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescibeImportsFromDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=2147483647, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    DBInstanceAccount?: [ 
    {
      accountDescription?: string(name='AccountDescription'),
      accountName?: string(name='AccountName'),
      accountStatus?: string(name='AccountStatus'),
      accountType?: string(name='AccountType'),
      DBInstanceId?: string(name='DBInstanceId'),
      databasePrivileges?: {
        databasePrivilege?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege'),
          accountPrivilegeDetail?: string(name='AccountPrivilegeDetail'),
          DBName?: string(name='DBName'),
        }
      ](name='DatabasePrivilege')
      }(name='DatabasePrivileges'),
      privExceeded?: string(name='PrivExceeded'),
    }
  ](name='DBInstanceAccount')
  }(name='Accounts'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  systemAdminAccountFirstActivationTime?: string(name='SystemAdminAccountFirstActivationTime'),
  systemAdminAccountStatus?: string(name='SystemAdminAccountStatus'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAccountsResponseBody(name='body'),
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAccounts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeActionEventPolicyRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeActionEventPolicyResponseBody = {
  enableEventLog?: string(name='EnableEventLog'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeActionEventPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeActionEventPolicyResponseBody(name='body'),
}

async function describeActionEventPolicy(request: DescribeActionEventPolicyRequest): DescribeActionEventPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeActionEventPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableClassesRequest {
  category: string(name='Category', position='Query'),
  commodityCode?: string(name='CommodityCode', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStorageType: string(name='DBInstanceStorageType', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceChargeType?: string(name='InstanceChargeType', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model DescribeAvailableClassesResponseBody = {
  DBInstanceClasses?: [ 
    {
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceStorageRange?: {
        maxValue?: int32(name='MaxValue'),
        minValue?: int32(name='MinValue'),
        step?: int32(name='Step'),
      }(name='DBInstanceStorageRange'),
    }
  ](name='DBInstanceClasses'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableClassesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableClassesResponseBody(name='body'),
}

async function describeAvailableClasses(request: DescribeAvailableClassesRequest): DescribeAvailableClassesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableClasses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableCrossRegionRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAvailableCrossRegionResponseBody = {
  regions?: {
    region?: [ string ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableCrossRegionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableCrossRegionResponseBody(name='body'),
}

async function describeAvailableCrossRegion(request: DescribeAvailableCrossRegionRequest): DescribeAvailableCrossRegionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableCrossRegion', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableDedicatedHostClassesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageType?: string(name='StorageType', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
}

model DescribeAvailableDedicatedHostClassesResponseBody = {
  hostClasses?: {
    hostClasses?: [ 
    {
      description?: string(name='Description'),
      hostClassName?: string(name='HostClassName'),
    }
  ](name='HostClasses')
  }(name='HostClasses'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableDedicatedHostClassesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableDedicatedHostClassesResponseBody(name='body'),
}

async function describeAvailableDedicatedHostClasses(request: DescribeAvailableDedicatedHostClassesRequest): DescribeAvailableDedicatedHostClassesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableDedicatedHostClasses', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableDedicatedHostZonesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAvailableDedicatedHostZonesResponseBody = {
  requestId?: string(name='RequestId'),
  zones?: {
    dedicatedHostZones?: [ 
    {
      description?: string(name='Description'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHostZones')
  }(name='Zones'),
}

model DescribeAvailableDedicatedHostZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableDedicatedHostZonesResponseBody(name='body'),
}

async function describeAvailableDedicatedHostZones(request: DescribeAvailableDedicatedHostZonesRequest): DescribeAvailableDedicatedHostZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableDedicatedHostZones', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableMetricsRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAvailableMetricsResponseBody = {
  items?: [ 
    {
      description?: string(name='Description'),
      dimension?: string(name='Dimension'),
      groupKey?: string(name='GroupKey'),
      groupKeyType?: string(name='GroupKeyType'),
      method?: string(name='Method'),
      metricsKey?: string(name='MetricsKey'),
      metricsKeyAlias?: string(name='MetricsKeyAlias'),
      sortRule?: int32(name='SortRule'),
      unit?: string(name='Unit'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeAvailableMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableMetricsResponseBody(name='body'),
}

async function describeAvailableMetrics(request: DescribeAvailableMetricsRequest): DescribeAvailableMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableMetrics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableRecoveryTimeRequest {
  crossBackupId: int32(name='CrossBackupId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeAvailableRecoveryTimeResponseBody = {
  crossBackupId?: int32(name='CrossBackupId'),
  recoveryBeginTime?: string(name='RecoveryBeginTime'),
  recoveryEndTime?: string(name='RecoveryEndTime'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableRecoveryTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableRecoveryTimeResponseBody(name='body'),
}

async function describeAvailableRecoveryTime(request: DescribeAvailableRecoveryTimeRequest): DescribeAvailableRecoveryTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableRecoveryTime', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  category?: string(name='Category', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  dispenseMode?: int32(name='DispenseMode', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  instanceChargeType: string(name='InstanceChargeType', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
      supportedEngines?: {
        supportedEngine?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: {
            supportedEngineVersion?: [ 
            {
              supportedCategorys?: {
                supportedCategory?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: {
                    supportedStorageType?: [ 
                    {
                      availableResources?: {
                        availableResource?: [ 
                        {
                          DBInstanceClass?: string(name='DBInstanceClass'),
                          DBInstanceStorageRange?: {
                            max?: int32(name='Max'),
                            min?: int32(name='Min'),
                            step?: int32(name='Step'),
                          }(name='DBInstanceStorageRange'),
                          storageRange?: string(name='StorageRange'),
                        }
                      ](name='AvailableResource')
                      }(name='AvailableResources'),
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageType')
                  }(name='SupportedStorageTypes'),
                }
              ](name='SupportedCategory')
              }(name='SupportedCategorys'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersion')
          }(name='SupportedEngineVersions'),
        }
      ](name='SupportedEngine')
      }(name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableZonesRequest {
  cachedAsync?: boolean(name='CachedAsync', position='Query'),
  category?: string(name='Category', position='Query'),
  commodityCode?: string(name='CommodityCode', position='Query'),
  DBInstanceName?: string(name='DBInstanceName', position='Query'),
  dispenseMode?: string(name='DispenseMode', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeAvailableZonesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId'),
      supportedEngines?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: [ 
            {
              supportedCategorys?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: [ 
                    {
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageTypes'),
                }
              ](name='SupportedCategorys'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersions'),
        }
      ](name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeAvailableZonesResponseBody(name='body'),
}

async function describeAvailableZones(request: DescribeAvailableZonesRequest): DescribeAvailableZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableZones', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupDatabaseRequest {
  backupId?: string(name='BackupId', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBackupDatabaseResponseBody = {
  databaseNames?: string(name='DatabaseNames'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupDatabaseResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupDatabaseResponseBody(name='body'),
}

async function describeBackupDatabase(request: DescribeBackupDatabaseRequest): DescribeBackupDatabaseResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupDatabase', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPolicyRequest {
  backupPolicyMode?: string(name='BackupPolicyMode', position='Query'),
  compressType?: string(name='CompressType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBackupPolicyResponseBody = {
  archiveBackupKeepCount?: string(name='ArchiveBackupKeepCount'),
  archiveBackupKeepPolicy?: string(name='ArchiveBackupKeepPolicy'),
  archiveBackupRetentionPeriod?: string(name='ArchiveBackupRetentionPeriod'),
  backupInterval?: string(name='BackupInterval'),
  backupLog?: string(name='BackupLog'),
  backupMethod?: string(name='BackupMethod'),
  backupRetentionPeriod?: int32(name='BackupRetentionPeriod'),
  category?: string(name='Category'),
  compressType?: string(name='CompressType'),
  enableBackupLog?: string(name='EnableBackupLog'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  localLogRetentionHours?: int32(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  logBackupFrequency?: string(name='LogBackupFrequency'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  preferredNextBackupTime?: string(name='PreferredNextBackupTime'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  requestId?: string(name='RequestId'),
  supportReleasedKeep?: int32(name='SupportReleasedKeep'),
  supportVolumeShadowCopy?: int32(name='SupportVolumeShadowCopy'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupTasksRequest {
  backupJobId?: int32(name='BackupJobId', position='Query'),
  backupJobStatus?: string(name='BackupJobStatus', position='Query'),
  backupMode?: string(name='BackupMode', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  flag?: string(name='Flag', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeBackupTasksResponseBody = {
  items?: {
    backupJob?: [ 
    {
      backupId?: string(name='BackupId'),
      backupJobId?: string(name='BackupJobId'),
      backupProgressStatus?: string(name='BackupProgressStatus'),
      backupStatus?: string(name='BackupStatus'),
      jobMode?: string(name='JobMode'),
      process?: string(name='Process'),
      taskAction?: string(name='TaskAction'),
    }
  ](name='BackupJob')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupTasksResponseBody(name='body'),
}

async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId', position='Query'),
  backupMode?: string(name='BackupMode', position='Query'),
  backupStatus?: string(name='BackupStatus', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=1000, position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupDownloadLinkByDB?: {
        backupDownloadLinkByDB?: [ 
        {
          dataBase?: string(name='DataBase'),
          downloadLink?: string(name='DownloadLink'),
          intranetDownloadLink?: string(name='IntranetDownloadLink'),
        }
      ](name='BackupDownloadLinkByDB')
      }(name='BackupDownloadLinkByDB'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupId?: string(name='BackupId'),
      backupInitiator?: string(name='BackupInitiator'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
      checksum?: string(name='Checksum'),
      consistentTime?: long(name='ConsistentTime'),
      copyOnlyBackup?: string(name='CopyOnlyBackup'),
      DBInstanceId?: string(name='DBInstanceId'),
      encryption?: string(name='Encryption'),
      hostInstanceID?: string(name='HostInstanceID'),
      isAvail?: int32(name='IsAvail'),
      metaStatus?: string(name='MetaStatus'),
      storageClass?: string(name='StorageClass'),
      storeStatus?: string(name='StoreStatus'),
    }
  ](name='Backup')
  }(name='Items'),
  pageNumber?: string(name='PageNumber'),
  pageRecordCount?: string(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalEcsSnapshotSize?: long(name='TotalEcsSnapshotSize'),
  totalRecordCount?: string(name='TotalRecordCount'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBinlogFilesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=1000, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeBinlogFilesResponseBody = {
  items?: {
    binLogFile?: [ 
    {
      checksum?: string(name='Checksum'),
      downloadLink?: string(name='DownloadLink'),
      fileSize?: long(name='FileSize'),
      hostInstanceID?: string(name='HostInstanceID'),
      intranetDownloadLink?: string(name='IntranetDownloadLink'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
      logFileName?: string(name='LogFileName'),
      remoteStatus?: string(name='RemoteStatus'),
    }
  ](name='BinLogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalFileSize?: long(name='TotalFileSize'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeBinlogFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBinlogFilesResponseBody(name='body'),
}

async function describeBinlogFiles(request: DescribeBinlogFilesRequest): DescribeBinlogFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBinlogFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCharacterSetNameRequest {
  engine: string(name='Engine', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCharacterSetNameResponseBody = {
  characterSetNameItems?: {
    characterSetName?: [ string ](name='CharacterSetName')
  }(name='CharacterSetNameItems'),
  engine?: string(name='Engine'),
  requestId?: string(name='RequestId'),
}

model DescribeCharacterSetNameResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCharacterSetNameResponseBody(name='body'),
}

async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCharacterSetName', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudMigrationPrecheckResultRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  pageNumber: long(name='PageNumber', position='Query'),
  pageSize: long(name='PageSize', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceIpAddress?: string(name='SourceIpAddress', position='Query'),
  sourcePort?: long(name='SourcePort', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model DescribeCloudMigrationPrecheckResultResponseBody = {
  items?: [ 
    {
      detail?: string(name='Detail'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      sourceAccount?: string(name='SourceAccount'),
      sourceCategory?: string(name='SourceCategory'),
      sourceIpAddress?: string(name='SourceIpAddress'),
      sourcePassword?: string(name='SourcePassword'),
      sourcePort?: long(name='SourcePort'),
      targetEip?: string(name='TargetEip'),
      targetInstanceName?: string(name='TargetInstanceName'),
      taskId?: long(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Items'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
}

model DescribeCloudMigrationPrecheckResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudMigrationPrecheckResultResponseBody(name='body'),
}

async function describeCloudMigrationPrecheckResult(request: DescribeCloudMigrationPrecheckResultRequest): DescribeCloudMigrationPrecheckResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudMigrationPrecheckResult', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCloudMigrationResultRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  pageNumber: long(name='PageNumber', position='Query'),
  pageSize: long(name='PageSize', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceIpAddress?: string(name='SourceIpAddress', position='Query'),
  sourcePort?: long(name='SourcePort', position='Query'),
  taskId?: long(name='TaskId', position='Query'),
  taskName?: string(name='TaskName', position='Query'),
}

model DescribeCloudMigrationResultResponseBody = {
  items?: [ 
    {
      detail?: string(name='Detail'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      migrateStage?: string(name='MigrateStage'),
      replicationInfo?: string(name='ReplicationInfo'),
      replicationState?: string(name='ReplicationState'),
      sourceAccount?: string(name='SourceAccount'),
      sourceCategory?: string(name='SourceCategory'),
      sourceIpAddress?: string(name='SourceIpAddress'),
      sourcePassword?: string(name='SourcePassword'),
      sourcePort?: long(name='SourcePort'),
      switchTime?: string(name='SwitchTime'),
      targetEip?: string(name='TargetEip'),
      targetInstanceName?: string(name='TargetInstanceName'),
      taskId?: long(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Items'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
}

model DescribeCloudMigrationResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCloudMigrationResultResponseBody(name='body'),
}

async function describeCloudMigrationResult(request: DescribeCloudMigrationResultRequest): DescribeCloudMigrationResultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCloudMigrationResult', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCollationTimeZonesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCollationTimeZonesResponseBody = {
  collationTimeZones?: {
    collationTimeZone?: [ 
    {
      description?: string(name='Description'),
      standardTimeOffset?: string(name='StandardTimeOffset'),
      timeZone?: string(name='TimeZone'),
    }
  ](name='CollationTimeZone')
  }(name='CollationTimeZones'),
  requestId?: string(name='RequestId'),
}

model DescribeCollationTimeZonesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCollationTimeZonesResponseBody(name='body'),
}

async function describeCollationTimeZones(request: DescribeCollationTimeZonesRequest): DescribeCollationTimeZonesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCollationTimeZones', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCrossBackupMetaListRequest {
  backupSetId: string(name='BackupSetId', position='Query'),
  getDbName?: string(name='GetDbName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageIndex?: string(name='PageIndex', position='Query'),
  pageSize?: string(name='PageSize', position='Query'),
  pattern?: string(name='Pattern', position='Query'),
  region?: string(name='Region', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCrossBackupMetaListResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    meta?: [ 
    {
      database?: string(name='Database'),
      size?: string(name='Size'),
      tables?: string(name='Tables'),
    }
  ](name='Meta')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalPageCount?: int32(name='TotalPageCount'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossBackupMetaListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCrossBackupMetaListResponseBody(name='body'),
}

async function describeCrossBackupMetaList(request: DescribeCrossBackupMetaListRequest): DescribeCrossBackupMetaListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCrossBackupMetaList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCrossRegionBackupDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeCrossRegionBackupDBInstanceResponseBody = {
  items?: {
    item?: [ 
    {
      backupEnabled?: string(name='BackupEnabled'),
      backupEnabledTime?: string(name='BackupEnabledTime'),
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossBackupType?: string(name='CrossBackupType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      lockMode?: string(name='LockMode'),
      logBackupEnabled?: string(name='LogBackupEnabled'),
      logBackupEnabledTime?: string(name='LogBackupEnabledTime'),
      retentType?: int32(name='RetentType'),
      retention?: int32(name='Retention'),
    }
  ](name='Item')
  }(name='Items'),
  itemsNumbers?: int32(name='ItemsNumbers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalRecords?: int32(name='TotalRecords'),
}

model DescribeCrossRegionBackupDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCrossRegionBackupDBInstanceResponseBody(name='body'),
}

async function describeCrossRegionBackupDBInstance(request: DescribeCrossRegionBackupDBInstanceRequest): DescribeCrossRegionBackupDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCrossRegionBackupDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCrossRegionBackupsRequest {
  backupId?: int32(name='BackupId', position='Query'),
  crossBackupId?: int32(name='CrossBackupId', position='Query'),
  crossBackupRegion?: string(name='CrossBackupRegion', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeCrossRegionBackupsResponseBody = {
  endTime?: string(name='EndTime'),
  items?: {
    item?: [ 
    {
      backupEndTime?: string(name='BackupEndTime'),
      backupMethod?: string(name='BackupMethod'),
      backupSetScale?: int32(name='BackupSetScale'),
      backupSetStatus?: int32(name='BackupSetStatus'),
      backupStartTime?: string(name='BackupStartTime'),
      backupType?: string(name='BackupType'),
      category?: string(name='Category'),
      consistentTime?: string(name='ConsistentTime'),
      crossBackupDownloadLink?: string(name='CrossBackupDownloadLink'),
      crossBackupId?: int32(name='CrossBackupId'),
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossBackupSetFile?: string(name='CrossBackupSetFile'),
      crossBackupSetLocation?: string(name='CrossBackupSetLocation'),
      crossBackupSetSize?: long(name='CrossBackupSetSize'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      instanceId?: int32(name='InstanceId'),
      restoreRegions?: {
        restoreRegion?: [ string ](name='RestoreRegion')
      }(name='RestoreRegions'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossRegionBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCrossRegionBackupsResponseBody(name='body'),
}

async function describeCrossRegionBackups(request: DescribeCrossRegionBackupsRequest): DescribeCrossRegionBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCrossRegionBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCrossRegionLogBackupFilesRequest {
  crossBackupRegion?: string(name='CrossBackupRegion', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeCrossRegionLogBackupFilesResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  items?: {
    item?: [ 
    {
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossDownloadLink?: string(name='CrossDownloadLink'),
      crossIntranetDownloadLink?: string(name='CrossIntranetDownloadLink'),
      crossLogBackupId?: int32(name='CrossLogBackupId'),
      crossLogBackupSize?: long(name='CrossLogBackupSize'),
      instanceId?: int32(name='InstanceId'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
      logFileName?: string(name='LogFileName'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossRegionLogBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeCrossRegionLogBackupFilesResponseBody(name='body'),
}

async function describeCrossRegionLogBackupFiles(request: DescribeCrossRegionLogBackupFilesRequest): DescribeCrossRegionLogBackupFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCrossRegionLogBackupFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceAttributeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  expired?: string(name='Expired', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceAttributeResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      accountMaxQuantity?: int32(name='AccountMaxQuantity'),
      advancedFeatures?: string(name='AdvancedFeatures'),
      autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion'),
      availabilityValue?: string(name='AvailabilityValue'),
      category?: string(name='Category'),
      collation?: string(name='Collation'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      consoleVersion?: string(name='ConsoleVersion'),
      creationTime?: string(name='CreationTime'),
      currentKernelVersion?: string(name='CurrentKernelVersion'),
      DBInstanceCPU?: string(name='DBInstanceCPU'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceClassType?: string(name='DBInstanceClassType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMemory?: long(name='DBInstanceMemory'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      DBMaxQuantity?: int32(name='DBMaxQuantity'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      extra?: {
        DBInstanceIds?: {
          DBInstanceId?: [ string ](name='DBInstanceId')
        }(name='DBInstanceIds'),
      }(name='Extra'),
      generalGroupName?: string(name='GeneralGroupName'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      incrementSourceDBInstanceId?: string(name='IncrementSourceDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      latestKernelVersion?: string(name='LatestKernelVersion'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      maintainTime?: string(name='MaintainTime'),
      masterInstanceId?: string(name='MasterInstanceId'),
      masterZone?: string(name='MasterZone'),
      maxConnections?: int32(name='MaxConnections'),
      maxIOPS?: int32(name='MaxIOPS'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      proxyType?: int32(name='ProxyType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      readonlyInstanceSQLDelayedTime?: string(name='ReadonlyInstanceSQLDelayedTime'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityIPMode?: string(name='SecurityIPMode'),
      slaveZones?: {
        slaveZone?: [ 
        {
          zoneId?: string(name='ZoneId'),
        }
      ](name='SlaveZone')
      }(name='SlaveZones'),
      superPermissionMode?: string(name='SuperPermissionMode'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      timeZone?: string(name='TimeZone'),
      tips?: string(name='Tips'),
      tipsLevel?: int32(name='TipsLevel'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceAttributeResponseBody(name='body'),
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceDetailRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceDetailResponseBody = {
  activationState?: string(name='ActivationState'),
  DBInstanceId?: string(name='DBInstanceId'),
  licenseType?: string(name='LicenseType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceDetailResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceDetailResponseBody(name='body'),
}

async function describeDBInstanceDetail(request: DescribeDBInstanceDetailRequest): DescribeDBInstanceDetailResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceDetail', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceEncryptionKeyRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  targetRegionId?: string(name='TargetRegionId', position='Query'),
}

model DescribeDBInstanceEncryptionKeyResponseBody = {
  creator?: string(name='Creator'),
  deleteDate?: string(name='DeleteDate'),
  description?: string(name='Description'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus'),
  keyUsage?: string(name='KeyUsage'),
  materialExpireTime?: string(name='MaterialExpireTime'),
  origin?: string(name='Origin'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceEncryptionKeyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceEncryptionKeyResponseBody(name='body'),
}

async function describeDBInstanceEncryptionKey(request: DescribeDBInstanceEncryptionKeyRequest): DescribeDBInstanceEncryptionKeyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceEncryptionKey', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceHAConfigRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceHAConfigResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  HAMode?: string(name='HAMode'),
  hostInstanceInfos?: {
    nodeInfo?: [ 
    {
      dataSyncTime?: string(name='DataSyncTime'),
      logSyncTime?: string(name='LogSyncTime'),
      nodeId?: string(name='NodeId'),
      nodeType?: string(name='NodeType'),
      regionId?: string(name='RegionId'),
      syncStatus?: string(name='SyncStatus'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='NodeInfo')
  }(name='HostInstanceInfos'),
  requestId?: string(name='RequestId'),
  syncMode?: string(name='SyncMode'),
}

model DescribeDBInstanceHAConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceHAConfigResponseBody(name='body'),
}

async function describeDBInstanceHAConfig(request: DescribeDBInstanceHAConfigRequest): DescribeDBInstanceHAConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceHAConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceIPArrayListRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  whitelistNetworkType?: string(name='WhitelistNetworkType', position='Query'),
}

model DescribeDBInstanceIPArrayListResponseBody = {
  items?: {
    DBInstanceIPArray?: [ 
    {
      DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute'),
      DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName'),
      securityIPList?: string(name='SecurityIPList'),
      securityIPType?: string(name='SecurityIPType'),
    }
  ](name='DBInstanceIPArray')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceIPArrayListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceIPArrayListResponseBody(name='body'),
}

async function describeDBInstanceIPArrayList(request: DescribeDBInstanceIPArrayListRequest): DescribeDBInstanceIPArrayListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceIPArrayList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceIpHostnameRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDBInstanceIpHostnameResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  ipHostnameInfos?: string(name='IpHostnameInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceIpHostnameResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceIpHostnameResponseBody(name='body'),
}

async function describeDBInstanceIpHostname(request: DescribeDBInstanceIpHostnameRequest): DescribeDBInstanceIpHostnameResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceIpHostname', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceMetricsRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceMetricsResponseBody = {
  items?: [ 
    {
      description?: string(name='Description'),
      dimension?: string(name='Dimension'),
      groupKey?: string(name='GroupKey'),
      groupKeyType?: string(name='GroupKeyType'),
      method?: string(name='Method'),
      metricsKey?: string(name='MetricsKey'),
      metricsKeyAlias?: string(name='MetricsKeyAlias'),
      sortRule?: int32(name='SortRule'),
      unit?: string(name='Unit'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstanceMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceMetricsResponseBody(name='body'),
}

async function describeDBInstanceMetrics(request: DescribeDBInstanceMetricsRequest): DescribeDBInstanceMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceMetrics', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceMonitorResponseBody = {
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceMonitorResponseBody(name='body'),
}

async function describeDBInstanceMonitor(request: DescribeDBInstanceMonitorRequest): DescribeDBInstanceMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceMonitor', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceNetInfoRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceNetRWSplitType?: string(name='DBInstanceNetRWSplitType', position='Query'),
  flag?: int32(name='Flag', position='Query'),
  generalGroupName?: string(name='GeneralGroupName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceNetInfoResponseBody = {
  DBInstanceNetInfos?: {
    DBInstanceNetInfo?: [ 
    {
      connectionString?: string(name='ConnectionString'),
      connectionStringType?: string(name='ConnectionStringType'),
      DBInstanceWeights?: {
        DBInstanceWeight?: [ 
        {
          availability?: string(name='Availability'),
          DBInstanceId?: string(name='DBInstanceId'),
          DBInstanceType?: string(name='DBInstanceType'),
          role?: string(name='Role'),
          weight?: string(name='Weight'),
        }
      ](name='DBInstanceWeight')
      }(name='DBInstanceWeights'),
      distributionType?: string(name='DistributionType'),
      expiredTime?: string(name='ExpiredTime'),
      IPAddress?: string(name='IPAddress'),
      IPType?: string(name='IPType'),
      maxDelayTime?: string(name='MaxDelayTime'),
      port?: string(name='Port'),
      securityIPGroups?: {
        securityIPGroup?: [ 
        {
          securityIPGroupName?: string(name='SecurityIPGroupName'),
          securityIPs?: string(name='SecurityIPs'),
        }
      ](name='securityIPGroup')
      }(name='SecurityIPGroups'),
      upgradeable?: string(name='Upgradeable'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='DBInstanceNetInfo')
  }(name='DBInstanceNetInfos'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  requestId?: string(name='RequestId'),
  securityIPMode?: string(name='SecurityIPMode'),
}

model DescribeDBInstanceNetInfoResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceNetInfoResponseBody(name='body'),
}

async function describeDBInstanceNetInfo(request: DescribeDBInstanceNetInfoRequest): DescribeDBInstanceNetInfoResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceNetInfo', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancePerformanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  key: string(name='Key', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDBInstancePerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key'),
      unit?: string(name='Unit'),
      valueFormat?: string(name='ValueFormat'),
      values?: {
        performanceValue?: [ 
        {
          date?: string(name='Date'),
          value?: string(name='Value'),
        }
      ](name='PerformanceValue')
      }(name='Values'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstancePerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancePerformanceResponseBody(name='body'),
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancePerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceProxyConfigurationRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceProxyConfigurationResponseBody = {
  attacksProtectionConfiguration?: string(name='AttacksProtectionConfiguration'),
  persistentConnectionsConfiguration?: string(name='PersistentConnectionsConfiguration'),
  requestId?: string(name='RequestId'),
  transparentSwitchConfiguration?: string(name='TransparentSwitchConfiguration'),
}

model DescribeDBInstanceProxyConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceProxyConfigurationResponseBody(name='body'),
}

async function describeDBInstanceProxyConfiguration(request: DescribeDBInstanceProxyConfigurationRequest): DescribeDBInstanceProxyConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceProxyConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceSSLRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceSSLResponseBody = {
  ACL?: string(name='ACL'),
  CAType?: string(name='CAType'),
  clientCACert?: string(name='ClientCACert'),
  clientCACertExpireTime?: string(name='ClientCACertExpireTime'),
  clientCertRevocationList?: string(name='ClientCertRevocationList'),
  connectionString?: string(name='ConnectionString'),
  lastModifyStatus?: string(name='LastModifyStatus'),
  modifyStatusReason?: string(name='ModifyStatusReason'),
  replicationACL?: string(name='ReplicationACL'),
  requestId?: string(name='RequestId'),
  requireUpdate?: string(name='RequireUpdate'),
  requireUpdateItem?: string(name='RequireUpdateItem'),
  requireUpdateReason?: string(name='RequireUpdateReason'),
  SSLCreateTime?: string(name='SSLCreateTime'),
  SSLEnabled?: string(name='SSLEnabled'),
  SSLExpireTime?: string(name='SSLExpireTime'),
  serverCAUrl?: string(name='ServerCAUrl'),
  serverCert?: string(name='ServerCert'),
  serverKey?: string(name='ServerKey'),
}

model DescribeDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceSSLResponseBody(name='body'),
}

async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceStatusRequest {
  addressIP?: string(name='AddressIP', position='Query'),
  addressPort?: string(name='AddressPort', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceStatusResponseBody = {
  DBInstanceCpuCores?: string(name='DBInstanceCpuCores'),
  DBInstanceId?: int32(name='DBInstanceId'),
  DBInstanceName?: string(name='DBInstanceName'),
  DBInstanceStatus?: int32(name='DBInstanceStatus'),
  DBInstanceUseType?: string(name='DBInstanceUseType'),
  requestId?: string(name='RequestId'),
  taskStatus?: int32(name='TaskStatus'),
}

model DescribeDBInstanceStatusResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceStatusResponseBody(name='body'),
}

async function describeDBInstanceStatus(request: DescribeDBInstanceStatusRequest): DescribeDBInstanceStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceStatus', 'GET', '/', 'json', false, 'json', request);
}

model DescribeDBInstanceTDERequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstanceTDEResponseBody = {
  databases?: {
    database?: [ 
    {
      DBName?: string(name='DBName'),
      TDEStatus?: string(name='TDEStatus'),
    }
  ](name='Database')
  }(name='Databases'),
  requestId?: string(name='RequestId'),
  TDEStatus?: string(name='TDEStatus'),
}

model DescribeDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstanceTDEResponseBody(name='body'),
}

async function describeDBInstanceTDE(request: DescribeDBInstanceTDERequest): DescribeDBInstanceTDEResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstanceTDE', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionMode?: string(name='ConnectionMode', position='Query'),
  connectionString?: string(name='ConnectionString', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStatus?: string(name='DBInstanceStatus', position='Query'),
  DBInstanceType?: string(name='DBInstanceType', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  expired?: string(name='Expired', position='Query'),
  instanceLevel?: int32(name='InstanceLevel', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  maxResults?: int32(name='MaxResults', minimum=1, maximum=100, position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=21474836, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  tags?: string(name='Tags', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeDBInstancesResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      createTime?: string(name='CreateTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      dedicatedHostGroupName?: string(name='DedicatedHostGroupName'),
      dedicatedHostIdForLog?: string(name='DedicatedHostIdForLog'),
      dedicatedHostIdForMaster?: string(name='DedicatedHostIdForMaster'),
      dedicatedHostIdForSlave?: string(name='DedicatedHostIdForSlave'),
      dedicatedHostNameForLog?: string(name='DedicatedHostNameForLog'),
      dedicatedHostNameForMaster?: string(name='DedicatedHostNameForMaster'),
      dedicatedHostNameForSlave?: string(name='DedicatedHostNameForSlave'),
      dedicatedHostZoneIdForLog?: string(name='DedicatedHostZoneIdForLog'),
      dedicatedHostZoneIdForMaster?: string(name='DedicatedHostZoneIdForMaster'),
      dedicatedHostZoneIdForSlave?: string(name='DedicatedHostZoneIdForSlave'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      generalGroupName?: string(name='GeneralGroupName'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      masterInstanceId?: string(name='MasterInstanceId'),
      mutriORsignle?: boolean(name='MutriORsignle'),
      payType?: string(name='PayType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      switchWeight?: int32(name='SwitchWeight'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      tips?: string(name='Tips'),
      tipsLevel?: int32(name='TipsLevel'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesResponseBody(name='body'),
}

async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesAsCsvRequest {
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBInstancesAsCsvResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      accountMaxQuantity?: int32(name='AccountMaxQuantity'),
      accountType?: string(name='AccountType'),
      availabilityValue?: string(name='AvailabilityValue'),
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      creationTime?: string(name='CreationTime'),
      DBInstanceCPU?: string(name='DBInstanceCPU'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceClassType?: string(name='DBInstanceClassType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMemory?: long(name='DBInstanceMemory'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceType?: string(name='DBInstanceType'),
      DBMaxQuantity?: int32(name='DBMaxQuantity'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      incrementSourceDBInstanceId?: string(name='IncrementSourceDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      maintainTime?: string(name='MaintainTime'),
      masterInstanceId?: string(name='MasterInstanceId'),
      maxConnections?: int32(name='MaxConnections'),
      maxIOPS?: int32(name='MaxIOPS'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      readDelayTime?: string(name='ReadDelayTime'),
      regionId?: string(name='RegionId'),
      securityIPList?: string(name='SecurityIPList'),
      supportUpgradeAccountType?: string(name='SupportUpgradeAccountType'),
      tags?: string(name='Tags'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstancesAsCsvResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesAsCsvResponseBody(name='body'),
}

async function describeDBInstancesAsCsv(request: DescribeDBInstancesAsCsvRequest): DescribeDBInstancesAsCsvResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancesAsCsv', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesByExpireTimeRequest {
  expirePeriod?: int32(name='ExpirePeriod', minimum=-15, maximum=180, position='Query'),
  expired?: boolean(name='Expired', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeDBInstancesByExpireTimeResponseBody = {
  items?: {
    DBInstanceExpireTime?: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      expireTime?: string(name='ExpireTime'),
      lockMode?: string(name='LockMode'),
      payType?: string(name='PayType'),
    }
  ](name='DBInstanceExpireTime')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesByExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesByExpireTimeResponseBody(name='body'),
}

async function describeDBInstancesByExpireTime(request: DescribeDBInstancesByExpireTimeRequest): DescribeDBInstancesByExpireTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancesByExpireTime', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesByPerformanceRequest {
  tag?: [
    {
      key?: string(name='key', position=''),
      value?: string(name='value', position=''),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sortKey?: string(name='SortKey', position='Query'),
  sortMethod?: string(name='SortMethod', position='Query'),
  tags?: string(name='Tags', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeDBInstancesByPerformanceResponseBody = {
  items?: {
    DBInstancePerformance?: [ 
    {
      CPUUsage?: string(name='CPUUsage'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      diskUsage?: string(name='DiskUsage'),
      IOPSUsage?: string(name='IOPSUsage'),
      sessionUsage?: string(name='SessionUsage'),
    }
  ](name='DBInstancePerformance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesByPerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesByPerformanceResponseBody(name='body'),
}

async function describeDBInstancesByPerformance(request: DescribeDBInstancesByPerformanceRequest): DescribeDBInstancesByPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancesByPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBInstancesForCloneRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionMode?: string(name='ConnectionMode', position='Query'),
  currentInstanceId?: string(name='CurrentInstanceId', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStatus?: string(name='DBInstanceStatus', position='Query'),
  DBInstanceType?: string(name='DBInstanceType', position='Query'),
  engine?: string(name='Engine', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  expired?: string(name='Expired', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  nodeType?: string(name='NodeType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  payType?: string(name='PayType', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  searchKey?: string(name='SearchKey', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeDBInstancesForCloneResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      createTime?: string(name='CreateTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      insId?: int32(name='InsId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      masterInstanceId?: string(name='MasterInstanceId'),
      mutriORsignle?: boolean(name='MutriORsignle'),
      payType?: string(name='PayType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      regionId?: string(name='RegionId'),
      replicateId?: string(name='ReplicateId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesForCloneResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBInstancesForCloneResponseBody(name='body'),
}

async function describeDBInstancesForClone(request: DescribeDBInstancesForCloneRequest): DescribeDBInstancesForCloneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBInstancesForClone', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBProxyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBProxyResponseBody = {
  DBProxyConnectStringItems?: {
    DBProxyConnectStringItems?: [ 
    {
      DBProxyConnectString?: string(name='DBProxyConnectString'),
      DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
      DBProxyConnectStringNetWorkType?: string(name='DBProxyConnectStringNetWorkType'),
      DBProxyConnectStringPort?: string(name='DBProxyConnectStringPort'),
      DBProxyEndpointId?: string(name='DBProxyEndpointId'),
      DBProxyEndpointName?: string(name='DBProxyEndpointName'),
      DBProxyVpcInstanceId?: string(name='DBProxyVpcInstanceId'),
    }
  ](name='DBProxyConnectStringItems')
  }(name='DBProxyConnectStringItems'),
  DBProxyInstanceCurrentMinorVersion?: string(name='DBProxyInstanceCurrentMinorVersion'),
  DBProxyInstanceLatestMinorVersion?: string(name='DBProxyInstanceLatestMinorVersion'),
  DBProxyInstanceName?: string(name='DBProxyInstanceName'),
  DBProxyInstanceNum?: int32(name='DBProxyInstanceNum'),
  DBProxyInstanceStatus?: string(name='DBProxyInstanceStatus'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType'),
  DBProxyServiceStatus?: string(name='DBProxyServiceStatus'),
  dbProxyEndpointItems?: {
    dbProxyEndpointItems?: [ 
    {
      dbProxyEndpointAliases?: string(name='DbProxyEndpointAliases'),
      dbProxyEndpointName?: string(name='DbProxyEndpointName'),
      dbProxyEndpointType?: string(name='DbProxyEndpointType'),
      dbProxyReadWriteMode?: string(name='DbProxyReadWriteMode'),
    }
  ](name='DbProxyEndpointItems')
  }(name='DbProxyEndpointItems'),
  requestId?: string(name='RequestId'),
}

model DescribeDBProxyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBProxyResponseBody(name='body'),
}

async function describeDBProxy(request: DescribeDBProxyRequest): DescribeDBProxyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBProxy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBProxyEndpointRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyConnectString?: string(name='DBProxyConnectString', position='Query'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDBProxyEndpointResponseBody = {
  DBProxyConnectString?: string(name='DBProxyConnectString'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
  DBProxyConnectStringPort?: string(name='DBProxyConnectStringPort'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyFeatures?: string(name='DBProxyFeatures'),
  dbProxyEndpointAliases?: string(name='DbProxyEndpointAliases'),
  dbProxyEndpointReadWriteMode?: string(name='DbProxyEndpointReadWriteMode'),
  endpointConnectItems?: {
    endpointConnectItems?: [ 
    {
      dbProxyEndpointConnectString?: string(name='DbProxyEndpointConnectString'),
      dbProxyEndpointNetType?: string(name='DbProxyEndpointNetType'),
      dbProxyEndpointPort?: string(name='DbProxyEndpointPort'),
    }
  ](name='EndpointConnectItems')
  }(name='EndpointConnectItems'),
  readOnlyInstanceDistributionType?: string(name='ReadOnlyInstanceDistributionType'),
  readOnlyInstanceMaxDelayTime?: string(name='ReadOnlyInstanceMaxDelayTime'),
  readOnlyInstanceWeight?: string(name='ReadOnlyInstanceWeight'),
  requestId?: string(name='RequestId'),
}

model DescribeDBProxyEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBProxyEndpointResponseBody(name='body'),
}

async function describeDBProxyEndpoint(request: DescribeDBProxyEndpointRequest): DescribeDBProxyEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBProxyEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDBProxyPerformanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  metricsName: string(name='MetricsName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeDBProxyPerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key'),
      valueFormat?: string(name='ValueFormat'),
      values?: {
        performanceValue?: [ 
        {
          date?: string(name='Date'),
          value?: string(name='Value'),
        }
      ](name='PerformanceValue')
      }(name='Values'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBProxyPerformanceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDBProxyPerformanceResponseBody(name='body'),
}

async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDBProxyPerformance', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDTCSecurityIpHostsForSQLServerRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeDTCSecurityIpHostsForSQLServerResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  ipHostPairNum?: string(name='IpHostPairNum'),
  items?: {
    whiteListGroups?: [ 
    {
      securityIpHosts?: string(name='SecurityIpHosts'),
      whitelistGroupName?: string(name='WhitelistGroupName'),
    }
  ](name='WhiteListGroups')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDTCSecurityIpHostsForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDTCSecurityIpHostsForSQLServerResponseBody(name='body'),
}

async function describeDTCSecurityIpHostsForSQLServer(request: DescribeDTCSecurityIpHostsForSQLServerRequest): DescribeDTCSecurityIpHostsForSQLServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDTCSecurityIpHostsForSQLServer', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDatabasesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  DBStatus?: string(name='DBStatus', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=0, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=2147483647, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDatabasesResponseBody = {
  databases?: {
    database?: [ 
    {
      accounts?: {
        accountPrivilegeInfo?: [ 
        {
          account?: string(name='Account'),
          accountPrivilege?: string(name='AccountPrivilege'),
          accountPrivilegeDetail?: string(name='AccountPrivilegeDetail'),
        }
      ](name='AccountPrivilegeInfo')
      }(name='Accounts'),
      characterSetName?: string(name='CharacterSetName'),
      DBDescription?: string(name='DBDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBName?: string(name='DBName'),
      DBStatus?: string(name='DBStatus'),
      engine?: string(name='Engine'),
    }
  ](name='Database')
  }(name='Databases'),
  requestId?: string(name='RequestId'),
}

model DescribeDatabasesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDatabasesResponseBody(name='body'),
}

async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDatabases', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostAttributeRequest {
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDedicatedHostAttributeResponseBody = {
  accountName?: string(name='AccountName'),
  allocationStatus?: string(name='AllocationStatus'),
  autoRenew?: string(name='AutoRenew'),
  CPUAllocationRatio?: string(name='CPUAllocationRatio'),
  cpuUsed?: string(name='CpuUsed'),
  createdTime?: string(name='CreatedTime'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  diskAllocationRatio?: string(name='DiskAllocationRatio'),
  expiredTime?: string(name='ExpiredTime'),
  hostCPU?: int32(name='HostCPU'),
  hostClass?: string(name='HostClass'),
  hostMem?: int32(name='HostMem'),
  hostName?: string(name='HostName'),
  hostStatus?: string(name='HostStatus'),
  hostStorage?: int32(name='HostStorage'),
  hostType?: string(name='HostType'),
  IPAddress?: string(name='IPAddress'),
  imageCategory?: string(name='ImageCategory'),
  instanceNumber?: int32(name='InstanceNumber'),
  instanceNumberMaster?: int32(name='InstanceNumberMaster'),
  instanceNumberROMaster?: int32(name='InstanceNumberROMaster'),
  instanceNumberROSlave?: int32(name='InstanceNumberROSlave'),
  instanceNumberSlave?: int32(name='InstanceNumberSlave'),
  memAllocationRatio?: string(name='MemAllocationRatio'),
  memoryUsed?: string(name='MemoryUsed'),
  openPermission?: string(name='OpenPermission'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  storageUsed?: string(name='StorageUsed'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostAttributeResponseBody(name='body'),
}

async function describeDedicatedHostAttribute(request: DescribeDedicatedHostAttributeRequest): DescribeDedicatedHostAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostGroupsRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  imageCategory?: string(name='ImageCategory', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDedicatedHostGroupsResponseBody = {
  dedicatedHostGroups?: {
    dedicatedHostGroups?: [ 
    {
      allocationPolicy?: string(name='AllocationPolicy'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      cpuAllocateRation?: float(name='CpuAllocateRation'),
      cpuAllocatedAmount?: float(name='CpuAllocatedAmount'),
      cpuAllocationRatio?: int32(name='CpuAllocationRatio'),
      createTime?: string(name='CreateTime'),
      dedicatedHostCountGroupByHostType?: map[string]any(name='DedicatedHostCountGroupByHostType'),
      dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      diskAllocateRation?: float(name='DiskAllocateRation'),
      diskAllocatedAmount?: float(name='DiskAllocatedAmount'),
      diskAllocationRatio?: int32(name='DiskAllocationRatio'),
      diskUsedAmount?: float(name='DiskUsedAmount'),
      diskUtility?: float(name='DiskUtility'),
      engine?: string(name='Engine'),
      hostNumber?: int32(name='HostNumber'),
      hostReplacePolicy?: string(name='HostReplacePolicy'),
      instanceNumber?: int32(name='InstanceNumber'),
      memAllocateRation?: float(name='MemAllocateRation'),
      memAllocatedAmount?: float(name='MemAllocatedAmount'),
      memAllocationRatio?: int32(name='MemAllocationRatio'),
      memUsedAmount?: float(name='MemUsedAmount'),
      memUtility?: float(name='MemUtility'),
      openPermission?: string(name='OpenPermission'),
      text?: string(name='Text'),
      VPCId?: string(name='VPCId'),
      zoneIDList?: {
        zoneIDList?: [ string ](name='ZoneIDList')
      }(name='ZoneIDList'),
    }
  ](name='DedicatedHostGroups')
  }(name='DedicatedHostGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostGroupsResponseBody(name='body'),
}

async function describeDedicatedHostGroups(request: DescribeDedicatedHostGroupsRequest): DescribeDedicatedHostGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostImageCategoriesRequest {
  hostGroup: string(name='HostGroup', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeDedicatedHostImageCategoriesResponseBody = {
  images?: {
    images?: [ 
    {
      imageCode?: string(name='ImageCode'),
      imageName?: string(name='ImageName'),
    }
  ](name='Images')
  }(name='Images'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostImageCategoriesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostImageCategoriesResponseBody(name='body'),
}

async function describeDedicatedHostImageCategories(request: DescribeDedicatedHostImageCategoriesRequest): DescribeDedicatedHostImageCategoriesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHostImageCategories', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDedicatedHostsRequest {
  allocationStatus?: string(name='AllocationStatus', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  hostStatus?: string(name='HostStatus', position='Query'),
  hostType?: string(name='HostType', position='Query'),
  orderId?: long(name='OrderId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeDedicatedHostsResponseBody = {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHosts?: {
    dedicatedHosts?: [ 
    {
      accountName?: string(name='AccountName'),
      allocationStatus?: string(name='AllocationStatus'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      CPUAllocationRatio?: string(name='CPUAllocationRatio'),
      cpuUsed?: string(name='CpuUsed'),
      createdTime?: string(name='CreatedTime'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      dedicatedHostId?: string(name='DedicatedHostId'),
      diskAllocationRatio?: string(name='DiskAllocationRatio'),
      endTime?: string(name='EndTime'),
      engine?: string(name='Engine'),
      hostCPU?: string(name='HostCPU'),
      hostClass?: string(name='HostClass'),
      hostMem?: string(name='HostMem'),
      hostName?: string(name='HostName'),
      hostStatus?: string(name='HostStatus'),
      hostStorage?: string(name='HostStorage'),
      hostType?: string(name='HostType'),
      IPAddress?: string(name='IPAddress'),
      imageCategory?: string(name='ImageCategory'),
      instanceNumber?: string(name='InstanceNumber'),
      memAllocationRatio?: string(name='MemAllocationRatio'),
      memoryUsed?: string(name='MemoryUsed'),
      openPermission?: string(name='OpenPermission'),
      storageUsed?: string(name='StorageUsed'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHosts')
  }(name='DedicatedHosts'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDedicatedHostsResponseBody(name='body'),
}

async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDedicatedHosts', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDetachedBackupsRequest {
  backupId?: string(name='BackupId', position='Query'),
  backupMode?: string(name='BackupMode', position='Query'),
  backupStatus?: string(name='BackupStatus', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  region: string(name='Region', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeDetachedBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupId?: string(name='BackupId'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
      consistentTime?: long(name='ConsistentTime'),
      DBInstanceComment?: string(name='DBInstanceComment'),
      DBInstanceId?: string(name='DBInstanceId'),
      hostInstanceID?: string(name='HostInstanceID'),
      isAvail?: int32(name='IsAvail'),
      metaStatus?: string(name='MetaStatus'),
      storeStatus?: string(name='StoreStatus'),
    }
  ](name='Backup')
  }(name='Items'),
  pageNumber?: string(name='PageNumber'),
  pageRecordCount?: string(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: string(name='TotalRecordCount'),
}

model DescribeDetachedBackupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDetachedBackupsResponseBody(name='body'),
}

async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDetachedBackups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDiagnosticReportListRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
}

model DescribeDiagnosticReportListResponseBody = {
  reportList?: [ 
    {
      diagnosticTime?: string(name='DiagnosticTime'),
      downloadURL?: string(name='DownloadURL'),
      endTime?: string(name='EndTime'),
      score?: int32(name='Score'),
      startTime?: string(name='StartTime'),
    }
  ](name='ReportList'),
  requestId?: string(name='RequestId'),
}

model DescribeDiagnosticReportListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeDiagnosticReportListResponseBody(name='body'),
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDiagnosticReportList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeErrorLogsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeErrorLogsResponseBody = {
  items?: {
    errorLog?: [ 
    {
      createTime?: string(name='CreateTime'),
      errorInfo?: string(name='ErrorInfo'),
    }
  ](name='ErrorLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeErrorLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeErrorLogsResponseBody(name='body'),
}

async function describeErrorLogs(request: DescribeErrorLogsRequest): DescribeErrorLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeErrorLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeEventsRequest {
  endTime?: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeEventsResponseBody = {
  eventItems?: {
    eventItems?: [ 
    {
      callerUid?: long(name='CallerUid'),
      eventId?: int32(name='EventId'),
      eventName?: string(name='EventName'),
      eventPayload?: string(name='EventPayload'),
      eventReason?: string(name='EventReason'),
      eventRecordTime?: string(name='EventRecordTime'),
      eventTime?: string(name='EventTime'),
      eventType?: string(name='EventType'),
      eventUserType?: string(name='EventUserType'),
      regionId?: string(name='RegionId'),
      resourceName?: string(name='ResourceName'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='EventItems')
  }(name='EventItems'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeEventsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeEventsResponseBody(name='body'),
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeGadInstancesRequest {
  gadInstanceName?: string(name='GadInstanceName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DescribeGadInstancesResponseBody = {
  gadInstances?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      gadInstanceMembers?: [ 
        {
          DBInstanceID?: string(name='DBInstanceID'),
          dtsInstance?: string(name='DtsInstance'),
          engine?: string(name='Engine'),
          engineVersion?: string(name='EngineVersion'),
          regionId?: string(name='RegionId'),
          role?: string(name='Role'),
          status?: string(name='Status'),
        }
      ](name='GadInstanceMembers'),
      gadInstanceName?: string(name='GadInstanceName'),
      modificationTime?: string(name='ModificationTime'),
      service?: string(name='Service'),
      status?: string(name='Status'),
    }
  ](name='GadInstances'),
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DescribeGadInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeGadInstancesResponseBody(name='body'),
}

async function describeGadInstances(request: DescribeGadInstancesRequest): DescribeGadInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeGadInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHADiagnoseConfigRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHADiagnoseConfigResponseBody = {
  requestId?: string(name='RequestId'),
  tcpConnectionType?: string(name='TcpConnectionType'),
}

model DescribeHADiagnoseConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHADiagnoseConfigResponseBody(name='body'),
}

async function describeHADiagnoseConfig(request: DescribeHADiagnoseConfigRequest): DescribeHADiagnoseConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHADiagnoseConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeHASwitchConfigRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeHASwitchConfigResponseBody = {
  HAConfig?: string(name='HAConfig'),
  manualHATime?: string(name='ManualHATime'),
  requestId?: string(name='RequestId'),
}

model DescribeHASwitchConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeHASwitchConfigResponseBody(name='body'),
}

async function describeHASwitchConfig(request: DescribeHASwitchConfigRequest): DescribeHASwitchConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeHASwitchConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceAutoRenewalAttributeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=50, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeInstanceAutoRenewalAttributeResponseBody = {
  items?: {
    item?: [ 
    {
      autoRenew?: string(name='AutoRenew'),
      DBInstanceId?: string(name='DBInstanceId'),
      duration?: int32(name='Duration'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewalAttribute(request: DescribeInstanceAutoRenewalAttributeRequest): DescribeInstanceAutoRenewalAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceAutoRenewalAttribute', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceCrossBackupPolicyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceCrossBackupPolicyResponseBody = {
  backupEnabled?: string(name='BackupEnabled'),
  backupEnabledTime?: string(name='BackupEnabledTime'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  crossBackupType?: string(name='CrossBackupType'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  lockMode?: string(name='LockMode'),
  logBackupEnabled?: string(name='LogBackupEnabled'),
  logBackupEnabledTime?: string(name='LogBackupEnabledTime'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  retentType?: int32(name='RetentType'),
  retention?: int32(name='Retention'),
}

model DescribeInstanceCrossBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceCrossBackupPolicyResponseBody(name='body'),
}

async function describeInstanceCrossBackupPolicy(request: DescribeInstanceCrossBackupPolicyRequest): DescribeInstanceCrossBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceCrossBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceKeywordsRequest {
  key?: string(name='Key', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceKeywordsResponseBody = {
  key?: string(name='Key'),
  requestId?: string(name='RequestId'),
  words?: {
    word?: [ string ](name='word')
  }(name='Words'),
}

model DescribeInstanceKeywordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeInstanceKeywordsResponseBody(name='body'),
}

async function describeInstanceKeywords(request: DescribeInstanceKeywordsRequest): DescribeInstanceKeywordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceKeywords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLocalAvailableRecoveryTimeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  region?: string(name='Region', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeLocalAvailableRecoveryTimeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  recoveryBeginTime?: string(name='RecoveryBeginTime'),
  recoveryEndTime?: string(name='RecoveryEndTime'),
  requestId?: string(name='RequestId'),
}

model DescribeLocalAvailableRecoveryTimeResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLocalAvailableRecoveryTimeResponseBody(name='body'),
}

async function describeLocalAvailableRecoveryTime(request: DescribeLocalAvailableRecoveryTimeRequest): DescribeLocalAvailableRecoveryTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLocalAvailableRecoveryTime', 'POST', '/', 'json', false, 'json', request);
}

model DescribeLogBackupFilesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=1000, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeLogBackupFilesResponseBody = {
  items?: {
    binLogFile?: [ 
    {
      downloadLink?: string(name='DownloadLink'),
      fileSize?: long(name='FileSize'),
      intranetDownloadLink?: string(name='IntranetDownloadLink'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
    }
  ](name='BinLogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalFileSize?: long(name='TotalFileSize'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeLogBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeLogBackupFilesResponseBody(name='body'),
}

async function describeLogBackupFiles(request: DescribeLogBackupFilesRequest): DescribeLogBackupFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeLogBackupFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMetaListRequest {
  backupSetID?: int32(name='BackupSetID', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  getDbName?: string(name='GetDbName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageIndex?: int32(name='PageIndex', position='Query'),
  pageSize?: int32(name='PageSize', position='Query'),
  pattern?: string(name='Pattern', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  restoreType?: string(name='RestoreType', position='Query'),
}

model DescribeMetaListResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    meta?: [ 
    {
      database?: string(name='Database'),
      size?: string(name='Size'),
      tables?: string(name='Tables'),
    }
  ](name='Meta')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalPageCount?: int32(name='TotalPageCount'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeMetaListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMetaListResponseBody(name='body'),
}

async function describeMetaList(request: DescribeMetaListRequest): DescribeMetaListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMetaList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMigrateTaskByIdRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  migrateTaskId: string(name='MigrateTaskId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeMigrateTaskByIdResponseBody = {
  backupMode?: string(name='BackupMode'),
  createTime?: string(name='CreateTime'),
  DBInstanceName?: string(name='DBInstanceName'),
  DBName?: string(name='DBName'),
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  isDBReplaced?: string(name='IsDBReplaced'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeMigrateTaskByIdResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMigrateTaskByIdResponseBody(name='body'),
}

async function describeMigrateTaskById(request: DescribeMigrateTaskByIdRequest): DescribeMigrateTaskByIdResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMigrateTaskById', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMigrateTasksRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeMigrateTasksResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  items?: {
    migrateTask?: [ 
    {
      backupMode?: string(name='BackupMode'),
      createTime?: string(name='CreateTime'),
      DBName?: string(name='DBName'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      isDBReplaced?: string(name='IsDBReplaced'),
      migrateTaskId?: string(name='MigrateTaskId'),
      status?: string(name='Status'),
    }
  ](name='MigrateTask')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeMigrateTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMigrateTasksResponseBody(name='body'),
}

async function describeMigrateTasks(request: DescribeMigrateTasksRequest): DescribeMigrateTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMigrateTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMigrateTasksForSQLServerRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeMigrateTasksForSQLServerResponseBody = {
  DBInstanceID?: string(name='DBInstanceID'),
  DBInstanceName?: string(name='DBInstanceName'),
  endTime?: string(name='EndTime'),
  items?: {
    migrateTask?: [ 
    {
      createTime?: string(name='CreateTime'),
      DBName?: string(name='DBName'),
      desc?: string(name='Desc'),
      endTime?: string(name='EndTime'),
      isDBReplaced?: string(name='IsDBReplaced'),
      migrateIaskId?: string(name='MigrateIaskId'),
      status?: string(name='Status'),
      taskType?: string(name='TaskType'),
    }
  ](name='MigrateTask')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeMigrateTasksForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMigrateTasksForSQLServerResponseBody(name='body'),
}

async function describeMigrateTasksForSQLServer(request: DescribeMigrateTasksForSQLServerRequest): DescribeMigrateTasksForSQLServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMigrateTasksForSQLServer', 'POST', '/', 'json', false, 'json', request);
}

model DescribeModifyPGHbaConfigLogRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
}

model DescribeModifyPGHbaConfigLogResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  hbaLogItems?: {
    hbaLogItem?: [ 
    {
      afterHbaItems?: {
        hbaItem?: [ 
        {
          address?: string(name='Address'),
          database?: string(name='Database'),
          mask?: string(name='Mask'),
          method?: string(name='Method'),
          option?: string(name='Option'),
          priorityId?: int32(name='PriorityId'),
          type?: string(name='Type'),
          user?: string(name='User'),
        }
      ](name='HbaItem')
      }(name='AfterHbaItems'),
      beforeHbaItems?: {
        hbaItem?: [ 
        {
          address?: string(name='Address'),
          database?: string(name='Database'),
          mask?: string(name='Mask'),
          method?: string(name='Method'),
          option?: string(name='Option'),
          priorityId?: int32(name='PriorityId'),
          type?: string(name='Type'),
          user?: string(name='User'),
        }
      ](name='HbaItem')
      }(name='BeforeHbaItems'),
      modifyStatus?: string(name='ModifyStatus'),
      modifyTime?: string(name='ModifyTime'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='HbaLogItem')
  }(name='HbaLogItems'),
  logItemCount?: int32(name='LogItemCount'),
  requestId?: string(name='RequestId'),
}

model DescribeModifyPGHbaConfigLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeModifyPGHbaConfigLogResponseBody(name='body'),
}

async function describeModifyPGHbaConfigLog(request: DescribeModifyPGHbaConfigLogRequest): DescribeModifyPGHbaConfigLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeModifyPGHbaConfigLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeModifyParameterLogRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeModifyParameterLogResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  items?: {
    parameterChangeLog?: [ 
    {
      modifyTime?: string(name='ModifyTime'),
      newParameterValue?: string(name='NewParameterValue'),
      oldParameterValue?: string(name='OldParameterValue'),
      parameterName?: string(name='ParameterName'),
      status?: string(name='Status'),
    }
  ](name='ParameterChangeLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeModifyParameterLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeModifyParameterLogResponseBody(name='body'),
}

async function describeModifyParameterLog(request: DescribeModifyParameterLogRequest): DescribeModifyParameterLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeModifyParameterLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOssDownloadsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  migrateTaskId: string(name='MigrateTaskId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeOssDownloadsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  items?: {
    ossDownload?: [ 
    {
      backupMode?: string(name='BackupMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      fileName?: string(name='FileName'),
      fileSize?: string(name='FileSize'),
      isAvailable?: string(name='IsAvailable'),
      status?: string(name='Status'),
    }
  ](name='OssDownload')
  }(name='Items'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
}

model DescribeOssDownloadsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOssDownloadsResponseBody(name='body'),
}

async function describeOssDownloads(request: DescribeOssDownloadsRequest): DescribeOssDownloadsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOssDownloads', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOssDownloadsForSQLServerRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  migrateTaskId: string(name='MigrateTaskId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeOssDownloadsForSQLServerResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    ossDownload?: [ 
    {
      bakType?: string(name='BakType'),
      createTime?: string(name='CreateTime'),
      desc?: string(name='Desc'),
      fileName?: string(name='FileName'),
      fileSize?: string(name='FileSize'),
      isAvail?: string(name='IsAvail'),
      status?: string(name='Status'),
    }
  ](name='OssDownload')
  }(name='Items'),
  migrateIaskId?: string(name='MigrateIaskId'),
  requestId?: string(name='RequestId'),
}

model DescribeOssDownloadsForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOssDownloadsForSQLServerResponseBody(name='body'),
}

async function describeOssDownloadsForSQLServer(request: DescribeOssDownloadsForSQLServerRequest): DescribeOssDownloadsForSQLServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOssDownloadsForSQLServer', 'POST', '/', 'json', false, 'json', request);
}

model DescribePGHbaConfigRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribePGHbaConfigResponseBody = {
  defaultHbaItems?: {
    hbaItem?: [ 
    {
      address?: string(name='Address'),
      database?: string(name='Database'),
      mask?: string(name='Mask'),
      method?: string(name='Method'),
      option?: string(name='Option'),
      priorityId?: int32(name='PriorityId'),
      type?: string(name='Type'),
      user?: string(name='User'),
    }
  ](name='HbaItem')
  }(name='DefaultHbaItems'),
  hbaModifyTime?: string(name='HbaModifyTime'),
  lastModifyStatus?: string(name='LastModifyStatus'),
  modifyStatusReason?: string(name='ModifyStatusReason'),
  requestId?: string(name='RequestId'),
  runningHbaItems?: {
    hbaItem?: [ 
    {
      address?: string(name='Address'),
      database?: string(name='Database'),
      mask?: string(name='Mask'),
      method?: string(name='Method'),
      option?: string(name='Option'),
      priorityId?: int32(name='PriorityId'),
      type?: string(name='Type'),
      user?: string(name='User'),
    }
  ](name='HbaItem')
  }(name='RunningHbaItems'),
}

model DescribePGHbaConfigResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePGHbaConfigResponseBody(name='body'),
}

async function describePGHbaConfig(request: DescribePGHbaConfigRequest): DescribePGHbaConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePGHbaConfig', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterGroupResponseBody = {
  paramGroup?: {
    parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      forceRestart?: int32(name='ForceRestart'),
      paramCounts?: int32(name='ParamCounts'),
      paramDetail?: {
        parameterDetail?: [ 
        {
          paramName?: string(name='ParamName'),
          paramValue?: string(name='ParamValue'),
        }
      ](name='ParameterDetail')
      }(name='ParamDetail'),
      parameterGroupDesc?: string(name='ParameterGroupDesc'),
      parameterGroupId?: string(name='ParameterGroupId'),
      parameterGroupName?: string(name='ParameterGroupName'),
      parameterGroupType?: int32(name='ParameterGroupType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ParameterGroup')
  }(name='ParamGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParameterGroupResponseBody(name='body'),
}

async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterGroupsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterGroupsResponseBody = {
  parameterGroups?: {
    parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      forceRestart?: int32(name='ForceRestart'),
      paramCounts?: int32(name='ParamCounts'),
      parameterGroupDesc?: string(name='ParameterGroupDesc'),
      parameterGroupId?: string(name='ParameterGroupId'),
      parameterGroupName?: string(name='ParameterGroupName'),
      parameterGroupType?: int32(name='ParameterGroupType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ParameterGroup')
  }(name='ParameterGroups'),
  requestId?: string(name='RequestId'),
  signalForOptimizeParams?: boolean(name='SignalForOptimizeParams'),
}

model DescribeParameterGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParameterGroupsResponseBody(name='body'),
}

async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParameterTemplatesRequest {
  category?: string(name='Category', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParameterTemplatesResponseBody = {
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  parameterCount?: string(name='ParameterCount'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode'),
      forceModify?: string(name='ForceModify'),
      forceRestart?: string(name='ForceRestart'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='TemplateRecord')
  }(name='Parameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParameterTemplatesResponseBody(name='body'),
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameterTemplates', 'POST', '/', 'json', false, 'json', request);
}

model DescribeParametersRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeParametersResponseBody = {
  configParameters?: {
    DBInstanceParameter?: [ 
    {
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='DBInstanceParameter')
  }(name='ConfigParameters'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  requestId?: string(name='RequestId'),
  runningParameters?: {
    DBInstanceParameter?: [ 
    {
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='DBInstanceParameter')
  }(name='RunningParameters'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeParameters', 'POST', '/', 'json', false, 'json', request);
}

model DescribePriceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  commodityCode?: string(name='CommodityCode', position='Query'),
  DBInstanceClass: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceUsedType?: int32(name='InstanceUsedType', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  quantity: int32(name='Quantity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeType?: string(name='TimeType', position='Query'),
  usedTime?: int32(name='UsedTime', minimum=1, maximum=999, position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    activityInfo?: {
      checkErrMsg?: string(name='CheckErrMsg'),
      errorCode?: string(name='ErrorCode'),
      success?: string(name='Success'),
    }(name='ActivityInfo'),
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradePrice?: float(name='TradePrice'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribePrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRdsResourceSettingsRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  resourceNiche: string(name='ResourceNiche', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRdsResourceSettingsResponseBody = {
  rdsInstanceResourceSettings?: {
    rdsInstanceResourceSetting?: [ 
    {
      endDate?: string(name='EndDate'),
      isTop?: string(name='IsTop'),
      noticeBarContent?: string(name='NoticeBarContent'),
      poppedUpButtonText?: string(name='PoppedUpButtonText'),
      poppedUpButtonType?: string(name='PoppedUpButtonType'),
      poppedUpButtonUrl?: string(name='PoppedUpButtonUrl'),
      poppedUpContent?: string(name='PoppedUpContent'),
      resourceNiche?: string(name='ResourceNiche'),
      startDate?: string(name='StartDate'),
    }
  ](name='RdsInstanceResourceSetting')
  }(name='RdsInstanceResourceSettings'),
  requestId?: string(name='RequestId'),
}

model DescribeRdsResourceSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRdsResourceSettingsResponseBody(name='body'),
}

async function describeRdsResourceSettings(request: DescribeRdsResourceSettingsRequest): DescribeRdsResourceSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRdsResourceSettings', 'POST', '/', 'json', false, 'json', request);
}

model DescribeReadDBInstanceDelayRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readInstanceId: string(name='ReadInstanceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeReadDBInstanceDelayResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  delayTime?: int32(name='DelayTime'),
  items?: {
    items?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      readDBInstanceNames?: {
        readDBInstanceName?: [ string ](name='ReadDBInstanceName')
      }(name='ReadDBInstanceNames'),
      readDelayTimes?: {
        readDelayTime?: [ string ](name='ReadDelayTime')
      }(name='ReadDelayTimes'),
      readonlyInstanceDelay?: {
        readonlyInstanceDelay?: [ 
        {
          flushLag?: string(name='FlushLag'),
          flushLatency?: string(name='FlushLatency'),
          readDBInstanceName?: string(name='ReadDBInstanceName'),
          replayLag?: string(name='ReplayLag'),
          replayLatency?: string(name='ReplayLatency'),
          sendLatency?: string(name='SendLatency'),
          writeLag?: string(name='WriteLag'),
          writeLatency?: string(name='WriteLatency'),
        }
      ](name='ReadonlyInstanceDelay')
      }(name='ReadonlyInstanceDelay'),
    }
  ](name='Items')
  }(name='Items'),
  readDBInstanceId?: string(name='ReadDBInstanceId'),
  requestId?: string(name='RequestId'),
}

model DescribeReadDBInstanceDelayResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeReadDBInstanceDelayResponseBody(name='body'),
}

async function describeReadDBInstanceDelay(request: DescribeReadDBInstanceDelayRequest): DescribeReadDBInstanceDelayResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeReadDBInstanceDelay', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    RDSRegion?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
      zoneName?: string(name='ZoneName'),
    }
  ](name='RDSRegion')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRenewalPriceRequest {
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  orderType?: string(name='OrderType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType?: string(name='PayType', position='Query'),
  quantity?: int32(name='Quantity', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timeType: string(name='TimeType', position='Query'),
  usedTime: int32(name='UsedTime', position='Query'),
}

model DescribeRenewalPriceResponseBody = {
  priceInfo?: {
    activityInfo?: {
      checkErrMsg?: string(name='CheckErrMsg'),
      errorCode?: string(name='ErrorCode'),
      success?: string(name='Success'),
    }(name='ActivityInfo'),
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradePrice?: float(name='TradePrice'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRenewalPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeResourceUsageRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeResourceUsageResponseBody = {
  archiveBackupSize?: long(name='ArchiveBackupSize'),
  backupDataSize?: long(name='BackupDataSize'),
  backupLogSize?: long(name='BackupLogSize'),
  backupOssDataSize?: long(name='BackupOssDataSize'),
  backupOssLogSize?: long(name='BackupOssLogSize'),
  backupSize?: long(name='BackupSize'),
  coldBackupSize?: long(name='ColdBackupSize'),
  DBInstanceId?: string(name='DBInstanceId'),
  dataSize?: long(name='DataSize'),
  diskUsed?: long(name='DiskUsed'),
  engine?: string(name='Engine'),
  logSize?: long(name='LogSize'),
  paidBackupSize?: long(name='PaidBackupSize'),
  requestId?: string(name='RequestId'),
  SQLSize?: long(name='SQLSize'),
}

model DescribeResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeResourceUsageResponseBody(name='body'),
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeResourceUsage', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLCollectorPolicyRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus'),
  storagePeriod?: int32(name='StoragePeriod'),
}

model DescribeSQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLCollectorPolicyResponseBody(name='body'),
}

async function describeSQLCollectorPolicy(request: DescribeSQLCollectorPolicyRequest): DescribeSQLCollectorPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLCollectorPolicy', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLCollectorRetentionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model DescribeSQLCollectorRetentionResponseBody = {
  configValue?: string(name='ConfigValue'),
  requestId?: string(name='RequestId'),
}

model DescribeSQLCollectorRetentionResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLCollectorRetentionResponseBody(name='body'),
}

async function describeSQLCollectorRetention(request: DescribeSQLCollectorRetentionRequest): DescribeSQLCollectorRetentionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLCollectorRetention', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogFilesRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  fileName?: string(name='FileName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=200, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSQLLogFilesResponseBody = {
  items?: {
    logFile?: [ 
    {
      fileID?: string(name='FileID'),
      logDownloadURL?: string(name='LogDownloadURL'),
      logEndTime?: string(name='LogEndTime'),
      logSize?: string(name='LogSize'),
      logStartTime?: string(name='LogStartTime'),
      logStatus?: string(name='LogStatus'),
    }
  ](name='LogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogFilesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogFilesResponseBody(name='body'),
}

async function describeSQLLogFiles(request: DescribeSQLLogFilesRequest): DescribeSQLLogFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogFiles', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogRecordsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  database?: string(name='Database', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  form?: string(name='Form', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=200, position='Query'),
  queryKeywords?: string(name='QueryKeywords', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SQLId?: long(name='SQLId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
  user?: string(name='User', position='Query'),
}

model DescribeSQLLogRecordsResponseBody = {
  items?: {
    SQLRecord?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      executeTime?: string(name='ExecuteTime'),
      hostAddress?: string(name='HostAddress'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLText?: string(name='SQLText'),
      threadID?: string(name='ThreadID'),
      totalExecutionTimes?: long(name='TotalExecutionTimes'),
    }
  ](name='SQLRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model DescribeSQLLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogRecordsResponseBody(name='body'),
}

async function describeSQLLogRecords(request: DescribeSQLLogRecordsRequest): DescribeSQLLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSQLLogReportListRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=50, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSQLLogReportListResponseBody = {
  items?: {
    item?: [ 
    {
      latencyTopNItems?: {
        latencyTopNItem?: [ 
        {
          avgLatency?: long(name='AvgLatency'),
          SQLExecuteTimes?: long(name='SQLExecuteTimes'),
          SQLText?: string(name='SQLText'),
        }
      ](name='LatencyTopNItem')
      }(name='LatencyTopNItems'),
      QPSTopNItems?: {
        QPSTopNItem?: [ 
        {
          SQLExecuteTimes?: long(name='SQLExecuteTimes'),
          SQLText?: string(name='SQLText'),
        }
      ](name='QPSTopNItem')
      }(name='QPSTopNItems'),
      reportTime?: string(name='ReportTime'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogReportListResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSQLLogReportListResponseBody(name='body'),
}

async function describeSQLLogReportList(request: DescribeSQLLogReportListRequest): DescribeSQLLogReportListResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSQLLogReportList', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSecurityGroupConfigurationRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeSecurityGroupConfigurationResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    ecsSecurityGroupRelation?: [ 
    {
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='EcsSecurityGroupRelation')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeSecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSecurityGroupConfigurationResponseBody(name='body'),
}

async function describeSecurityGroupConfiguration(request: DescribeSecurityGroupConfigurationRequest): DescribeSecurityGroupConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSecurityGroupConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogRecordsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SQLHASH?: string(name='SQLHASH', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSlowLogRecordsResponseBody = {
  CPUTime?: long(name='CPUTime'),
  DBInstanceId?: string(name='DBInstanceId'),
  engine?: string(name='Engine'),
  items?: {
    SQLSlowRecord?: [ 
    {
      applicationName?: string(name='ApplicationName'),
      clientHostName?: string(name='ClientHostName'),
      cpuTime?: long(name='CpuTime'),
      DBName?: string(name='DBName'),
      executionStartTime?: string(name='ExecutionStartTime'),
      hostAddress?: string(name='HostAddress'),
      lastRowsAffectedCount?: long(name='LastRowsAffectedCount'),
      lockTimes?: long(name='LockTimes'),
      logicalIORead?: long(name='LogicalIORead'),
      parseRowCounts?: long(name='ParseRowCounts'),
      physicalIORead?: long(name='PhysicalIORead'),
      queryTimeMS?: long(name='QueryTimeMS'),
      queryTimes?: long(name='QueryTimes'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      rowsAffectedCount?: long(name='RowsAffectedCount'),
      SQLText?: string(name='SQLText'),
      userName?: string(name='UserName'),
      writeIOCount?: long(name='WriteIOCount'),
    }
  ](name='SQLSlowRecord')
  }(name='Items'),
  lastRowsAffectedCount?: long(name='LastRowsAffectedCount'),
  logicalIORead?: long(name='LogicalIORead'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  physicalIORead?: long(name='PhysicalIORead'),
  requestId?: string(name='RequestId'),
  rowsAffectedCount?: long(name='RowsAffectedCount'),
  SQLHash?: string(name='SQLHash'),
  totalRecordCount?: int32(name='TotalRecordCount'),
  userName?: string(name='UserName'),
  writesIOCount?: long(name='WritesIOCount'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeSlowLogsRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  endTime: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=65535, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sortKey?: string(name='SortKey', position='Query'),
  startTime: string(name='StartTime', position='Query'),
}

model DescribeSlowLogsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  items?: {
    SQLSlowLog?: [ 
    {
      avgExecutionTime?: long(name='AvgExecutionTime'),
      avgIOWriteCounts?: long(name='AvgIOWriteCounts'),
      avgLastRowsAffectedCounts?: long(name='AvgLastRowsAffectedCounts'),
      avgLogicalReadCounts?: long(name='AvgLogicalReadCounts'),
      avgPhysicalReadCounts?: long(name='AvgPhysicalReadCounts'),
      avgRowsAffectedCounts?: long(name='AvgRowsAffectedCounts'),
      createTime?: string(name='CreateTime'),
      DBName?: string(name='DBName'),
      maxExecutionTime?: long(name='MaxExecutionTime'),
      maxIOWriteCounts?: long(name='MaxIOWriteCounts'),
      maxLastRowsAffectedCounts?: long(name='MaxLastRowsAffectedCounts'),
      maxLockTime?: long(name='MaxLockTime'),
      maxLogicalReadCounts?: long(name='MaxLogicalReadCounts'),
      maxPhysicalReadCounts?: long(name='MaxPhysicalReadCounts'),
      maxRowsAffectedCounts?: long(name='MaxRowsAffectedCounts'),
      minIOWriteCounts?: long(name='MinIOWriteCounts'),
      minLastRowsAffectedCounts?: long(name='MinLastRowsAffectedCounts'),
      minLogicalReadCounts?: long(name='MinLogicalReadCounts'),
      minPhysicalReadCounts?: long(name='MinPhysicalReadCounts'),
      minRowsAffectedCounts?: long(name='MinRowsAffectedCounts'),
      mySQLTotalExecutionCounts?: long(name='MySQLTotalExecutionCounts'),
      mySQLTotalExecutionTimes?: long(name='MySQLTotalExecutionTimes'),
      parseMaxRowCount?: long(name='ParseMaxRowCount'),
      parseTotalRowCounts?: long(name='ParseTotalRowCounts'),
      reportTime?: string(name='ReportTime'),
      returnMaxRowCount?: long(name='ReturnMaxRowCount'),
      returnTotalRowCounts?: long(name='ReturnTotalRowCounts'),
      SQLHASH?: string(name='SQLHASH'),
      SQLIdStr?: string(name='SQLIdStr'),
      SQLServerAvgCpuTime?: long(name='SQLServerAvgCpuTime'),
      SQLServerAvgExecutionTime?: long(name='SQLServerAvgExecutionTime'),
      SQLServerMaxCpuTime?: long(name='SQLServerMaxCpuTime'),
      SQLServerMinCpuTime?: long(name='SQLServerMinCpuTime'),
      SQLServerMinExecutionTime?: long(name='SQLServerMinExecutionTime'),
      SQLServerTotalCpuTime?: long(name='SQLServerTotalCpuTime'),
      SQLServerTotalExecutionCounts?: long(name='SQLServerTotalExecutionCounts'),
      SQLServerTotalExecutionTimes?: long(name='SQLServerTotalExecutionTimes'),
      SQLText?: string(name='SQLText'),
      slowLogId?: long(name='SlowLogId'),
      totalIOWriteCounts?: long(name='TotalIOWriteCounts'),
      totalLastRowsAffectedCounts?: long(name='TotalLastRowsAffectedCounts'),
      totalLockTimes?: long(name='TotalLockTimes'),
      totalLogicalReadCounts?: long(name='TotalLogicalReadCounts'),
      totalPhysicalReadCounts?: long(name='TotalPhysicalReadCounts'),
      totalRowsAffectedCounts?: long(name='TotalRowsAffectedCounts'),
    }
  ](name='SQLSlowLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSlowLogsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeSlowLogsResponseBody(name='body'),
}

async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeSlowLogs', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTagsRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType?: string(name='ResourceType', position='Query'),
  tags?: string(name='Tags', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model DescribeTagsResponseBody = {
  items?: {
    tagInfos?: [ 
    {
      DBInstanceIds?: {
        DBInstanceIds?: [ string ](name='DBInstanceIds')
      }(name='DBInstanceIds'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagInfos')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTags', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTasksRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  endTime?: string(name='EndTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', position='Query'),
  status?: string(name='Status', position='Query'),
  taskAction?: string(name='TaskAction', position='Query'),
}

model DescribeTasksResponseBody = {
  items?: {
    taskProgressInfo?: [ 
    {
      beginTime?: string(name='BeginTime'),
      currentStepName?: string(name='CurrentStepName'),
      DBName?: string(name='DBName'),
      expectedFinishTime?: string(name='ExpectedFinishTime'),
      finishTime?: string(name='FinishTime'),
      progress?: string(name='Progress'),
      progressInfo?: string(name='ProgressInfo'),
      remain?: int32(name='Remain'),
      status?: string(name='Status'),
      stepProgressInfo?: string(name='StepProgressInfo'),
      stepsInfo?: string(name='StepsInfo'),
      taskAction?: string(name='TaskAction'),
      taskErrorCode?: string(name='TaskErrorCode'),
      taskErrorMessage?: string(name='TaskErrorMessage'),
      taskId?: string(name='TaskId'),
    }
  ](name='TaskProgressInfo')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTasksResponseBody(name='body'),
}

async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUpgradeMajorVersionPrecheckTaskRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetMajorVersion?: string(name='TargetMajorVersion', position='Query'),
  taskId?: int32(name='TaskId', position='Query'),
}

model DescribeUpgradeMajorVersionPrecheckTaskResponseBody = {
  items?: [ 
    {
      checkTime?: string(name='CheckTime'),
      detail?: string(name='Detail'),
      effectiveTime?: string(name='EffectiveTime'),
      result?: string(name='Result'),
      sourceMajorVersion?: string(name='SourceMajorVersion'),
      targetMajorVersion?: string(name='TargetMajorVersion'),
      taskId?: int32(name='TaskId'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeUpgradeMajorVersionPrecheckTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUpgradeMajorVersionPrecheckTaskResponseBody(name='body'),
}

async function describeUpgradeMajorVersionPrecheckTask(request: DescribeUpgradeMajorVersionPrecheckTaskRequest): DescribeUpgradeMajorVersionPrecheckTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpgradeMajorVersionPrecheckTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeUpgradeMajorVersionTasksRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, maximum=2147483647, position='Query'),
  pageSize?: int32(name='PageSize', minimum=30, maximum=100, position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetMajorVersion?: string(name='TargetMajorVersion', position='Query'),
  taskId?: int32(name='TaskId', position='Query'),
}

model DescribeUpgradeMajorVersionTasksResponseBody = {
  items?: [ 
    {
      collectStatMode?: string(name='CollectStatMode'),
      detail?: string(name='Detail'),
      endTime?: string(name='EndTime'),
      result?: string(name='Result'),
      sourceInsName?: string(name='SourceInsName'),
      sourceMajorVersion?: string(name='SourceMajorVersion'),
      startTime?: string(name='StartTime'),
      switchTime?: string(name='SwitchTime'),
      targetInsName?: string(name='TargetInsName'),
      targetMajorVersion?: string(name='TargetMajorVersion'),
      taskId?: int32(name='TaskId'),
      upgradeMode?: string(name='UpgradeMode'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeUpgradeMajorVersionTasksResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeUpgradeMajorVersionTasksResponseBody(name='body'),
}

async function describeUpgradeMajorVersionTasks(request: DescribeUpgradeMajorVersionTasksRequest): DescribeUpgradeMajorVersionTasksResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeUpgradeMajorVersionTasks', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVSwitchesRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  pageNumber?: long(name='PageNumber', position='Query'),
  pageSize?: long(name='PageSize', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  vpcId?: string(name='VpcId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: long(name='TotalCount'),
  vSwitchs?: [ 
    {
      aliUid?: string(name='AliUid'),
      bid?: string(name='Bid'),
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      isDefault?: boolean(name='IsDefault'),
      izNo?: string(name='IzNo'),
      regionNo?: string(name='RegionNo'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitchs'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVSwitches', 'POST', '/', 'json', false, 'json', request);
}

model DestroyDBInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DestroyDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DestroyDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: DestroyDBInstanceResponseBody(name='body'),
}

async function destroyDBInstance(request: DestroyDBInstanceRequest): DestroyDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DestroyDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model DetachGadInstanceMemberRequest {
  gadInstanceName: string(name='GadInstanceName', position='Query'),
  memberInstanceName: string(name='MemberInstanceName', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model DetachGadInstanceMemberResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
}

model DetachGadInstanceMemberResponse = {
  headers: map[string]string(name='headers'),
  body: DetachGadInstanceMemberResponseBody(name='body'),
}

async function detachGadInstanceMember(request: DetachGadInstanceMemberRequest): DetachGadInstanceMemberResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachGadInstanceMember', 'POST', '/', 'json', false, 'json', request);
}

model DropDedicatedHostUserRequest {
  dedicatedHostName: string(name='DedicatedHostName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userName: string(name='UserName', position='Query'),
}

model DropDedicatedHostUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model DropDedicatedHostUserResponse = {
  headers: map[string]string(name='headers'),
  body: DropDedicatedHostUserResponseBody(name='body'),
}

async function dropDedicatedHostUser(request: DropDedicatedHostUserRequest): DropDedicatedHostUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DropDedicatedHostUser', 'POST', '/', 'json', false, 'json', request);
}

model EvaluateDedicatedHostInstanceResourceRequest {
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  diskSize?: string(name='DiskSize', position='Query'),
  diskType?: string(name='DiskType', position='Query'),
  engine: string(name='Engine', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  instanceClassNames: string(name='InstanceClassNames', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model EvaluateDedicatedHostInstanceResourceResponseBody = {
  available?: int32(name='Available'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  requestId?: string(name='RequestId'),
}

model EvaluateDedicatedHostInstanceResourceResponse = {
  headers: map[string]string(name='headers'),
  body: EvaluateDedicatedHostInstanceResourceResponseBody(name='body'),
}

async function evaluateDedicatedHostInstanceResource(request: EvaluateDedicatedHostInstanceResourceRequest): EvaluateDedicatedHostInstanceResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EvaluateDedicatedHostInstanceResource', 'POST', '/', 'json', false, 'json', request);
}

model GetDbProxyInstanceSslRequest {
  dbInstanceId: string(name='DbInstanceId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model GetDbProxyInstanceSslResponseBody = {
  dbProxyCertListItems?: {
    dbProxyCertListItems?: [ 
    {
      certCommonName?: string(name='CertCommonName'),
      dbInstanceName?: string(name='DbInstanceName'),
      endpointName?: string(name='EndpointName'),
      endpointType?: string(name='EndpointType'),
      sslExpiredTime?: string(name='SslExpiredTime'),
    }
  ](name='DbProxyCertListItems')
  }(name='DbProxyCertListItems'),
  requestId?: string(name='RequestId'),
}

model GetDbProxyInstanceSslResponse = {
  headers: map[string]string(name='headers'),
  body: GetDbProxyInstanceSslResponseBody(name='body'),
}

async function getDbProxyInstanceSsl(request: GetDbProxyInstanceSslRequest): GetDbProxyInstanceSslResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GetDbProxyInstanceSsl', 'POST', '/', 'json', false, 'json', request);
}

model GrantAccountPrivilegeRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPrivilege: string(name='AccountPrivilege', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GrantAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  body: GrantAccountPrivilegeResponseBody(name='body'),
}

async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantAccountPrivilege', 'POST', '/', 'json', false, 'json', request);
}

model GrantOperatorPermissionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  expiredTime: string(name='ExpiredTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privileges: string(name='Privileges', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model GrantOperatorPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantOperatorPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: GrantOperatorPermissionResponseBody(name='body'),
}

async function grantOperatorPermission(request: GrantOperatorPermissionRequest): GrantOperatorPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GrantOperatorPermission', 'POST', '/', 'json', false, 'json', request);
}

model ImportDatabaseBetweenInstancesRequest {
  DBInfo: string(name='DBInfo', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceDBInstanceId: string(name='SourceDBInstanceId', position='Query'),
}

model ImportDatabaseBetweenInstancesResponseBody = {
  importId?: string(name='ImportId'),
  requestId?: string(name='RequestId'),
}

model ImportDatabaseBetweenInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: ImportDatabaseBetweenInstancesResponseBody(name='body'),
}

async function importDatabaseBetweenInstances(request: ImportDatabaseBetweenInstancesRequest): ImportDatabaseBetweenInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportDatabaseBetweenInstances', 'POST', '/', 'json', false, 'json', request);
}

model ImportUserBackupFileRequest {
  backupFile: string(name='BackupFile', position='Query'),
  bucketRegion: string(name='BucketRegion', position='Query'),
  comment?: string(name='Comment', minLength=2, maxLength=256, position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreSize?: int32(name='RestoreSize', position='Query'),
  retention?: int32(name='Retention', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ImportUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
}

model ImportUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  body: ImportUserBackupFileResponseBody(name='body'),
}

async function importUserBackupFile(request: ImportUserBackupFileRequest): ImportUserBackupFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ImportUserBackupFile', 'POST', '/', 'json', false, 'json', request);
}

model ListClassesRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  commodityCode: string(name='CommodityCode', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  orderType: string(name='OrderType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListClassesResponseBody = {
  items?: [ 
    {
      classCode?: string(name='ClassCode'),
      classGroup?: string(name='ClassGroup'),
      cpu?: string(name='Cpu'),
      maxConnections?: string(name='MaxConnections'),
      maxIOMBPS?: string(name='MaxIOMBPS'),
      maxIOPS?: string(name='MaxIOPS'),
      memoryClass?: string(name='MemoryClass'),
      referencePrice?: string(name='ReferencePrice'),
    }
  ](name='Items'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model ListClassesResponse = {
  headers: map[string]string(name='headers'),
  body: ListClassesResponseBody(name='body'),
}

async function listClasses(request: ListClassesRequest): ListClassesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListClasses', 'POST', '/', 'json', false, 'json', request);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId?: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListTagResources', 'POST', '/', 'json', false, 'json', request);
}

model ListUserBackupFilesRequest {
  backupId?: string(name='BackupId', position='Query'),
  comment?: string(name='Comment', position='Query'),
  ossUrl?: string(name='OssUrl', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', position='Query'),
  tags?: string(name='Tags', position='Query'),
}

model ListUserBackupFilesResponseBody = {
  records?: [ 
    {
      backupId?: string(name='BackupId'),
      binlogInfo?: string(name='BinlogInfo'),
      comment?: string(name='Comment'),
      creationTime?: string(name='CreationTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      finishTime?: string(name='FinishTime'),
      modificationTime?: string(name='ModificationTime'),
      ossBucket?: string(name='OssBucket'),
      ossFileMetaData?: string(name='OssFileMetaData'),
      ossFileName?: string(name='OssFileName'),
      ossFilePath?: string(name='OssFilePath'),
      ossFileSize?: long(name='OssFileSize'),
      ossUrl?: string(name='OssUrl'),
      reason?: string(name='Reason'),
      restoreSize?: string(name='RestoreSize'),
      retention?: int32(name='Retention'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Records'),
  requestId?: string(name='RequestId'),
}

model ListUserBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  body: ListUserBackupFilesResponseBody(name='body'),
}

async function listUserBackupFiles(request: ListUserBackupFilesRequest): ListUserBackupFilesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUserBackupFiles', 'POST', '/', 'json', false, 'json', request);
}

model LockAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model LockAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockAccountResponse = {
  headers: map[string]string(name='headers'),
  body: LockAccountResponseBody(name='body'),
}

async function lockAccount(request: LockAccountRequest): LockAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'LockAccount', 'POST', '/', 'json', false, 'json', request);
}

model MigrateDBInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  specifiedTime?: string(name='SpecifiedTime', position='Query'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster', position='Query'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave', position='Query'),
  zoneIdForFollower?: string(name='ZoneIdForFollower', position='Query'),
  zoneIdForLog?: string(name='ZoneIdForLog', position='Query'),
}

model MigrateDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model MigrateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateDBInstanceResponseBody(name='body'),
}

async function migrateDBInstance(request: MigrateDBInstanceRequest): MigrateDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MigrateDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model MigrateSecurityIPModeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model MigrateSecurityIPModeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  securityIPMode?: string(name='SecurityIPMode'),
}

model MigrateSecurityIPModeResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateSecurityIPModeResponseBody(name='body'),
}

async function migrateSecurityIPMode(request: MigrateSecurityIPModeRequest): MigrateSecurityIPModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MigrateSecurityIPMode', 'POST', '/', 'json', false, 'json', request);
}

model MigrateToOtherZoneRequest {
  category?: string(name='Category', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage?: long(name='DBInstanceStorage', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  isModifySpec?: string(name='IsModifySpec', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId: string(name='ZoneId', position='Query'),
  zoneIdSlave1?: string(name='ZoneIdSlave1', position='Query'),
  zoneIdSlave2?: string(name='ZoneIdSlave2', position='Query'),
}

model MigrateToOtherZoneResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'MigrateToOtherZone', 'POST', '/', 'json', false, 'json', request);
}

model ModifyAccountDescriptionRequest {
  accountDescription: string(name='AccountDescription', position='Query'),
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyAccountDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyActionEventPolicyRequest {
  enableEventLog: string(name='EnableEventLog', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyActionEventPolicyResponseBody = {
  enableEventLog?: string(name='EnableEventLog'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model ModifyActionEventPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyActionEventPolicyResponseBody(name='body'),
}

async function modifyActionEventPolicy(request: ModifyActionEventPolicyRequest): ModifyActionEventPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyActionEventPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyBackupPolicyRequest {
  archiveBackupKeepCount?: int32(name='ArchiveBackupKeepCount', position='Query'),
  archiveBackupKeepPolicy?: string(name='ArchiveBackupKeepPolicy', position='Query'),
  archiveBackupRetentionPeriod?: string(name='ArchiveBackupRetentionPeriod', position='Query'),
  backupInterval?: string(name='BackupInterval', position='Query'),
  backupLog?: string(name='BackupLog', position='Query'),
  backupMethod?: string(name='BackupMethod', position='Query'),
  backupPolicyMode?: string(name='BackupPolicyMode', position='Query'),
  backupRetentionPeriod?: string(name='BackupRetentionPeriod', position='Query'),
  category?: string(name='Category', position='Query'),
  compressType?: string(name='CompressType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  enableBackupLog?: string(name='EnableBackupLog', position='Query'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection', position='Query'),
  localLogRetentionHours?: string(name='LocalLogRetentionHours', position='Query'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace', position='Query'),
  logBackupFrequency?: string(name='LogBackupFrequency', position='Query'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber', position='Query'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod', position='Query'),
  preferredBackupTime?: string(name='PreferredBackupTime', position='Query'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyBackupPolicyResponseBody = {
  compressType?: string(name='CompressType'),
  DBInstanceID?: string(name='DBInstanceID'),
  enableBackupLog?: string(name='EnableBackupLog'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  localLogRetentionHours?: int32(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber'),
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyCollationTimeZoneRequest {
  collation?: string(name='Collation', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  timezone?: string(name='Timezone', position='Query'),
}

model ModifyCollationTimeZoneResponseBody = {
  collation?: string(name='Collation'),
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  timezone?: string(name='Timezone'),
}

model ModifyCollationTimeZoneResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyCollationTimeZoneResponseBody(name='body'),
}

async function modifyCollationTimeZone(request: ModifyCollationTimeZoneRequest): ModifyCollationTimeZoneResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyCollationTimeZone', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBDescriptionRequest {
  DBDescription: string(name='DBDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBDescriptionResponseBody(name='body'),
}

async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceAutoUpgradeMinorVersionRequest {
  autoUpgradeMinorVersion: string(name='AutoUpgradeMinorVersion', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceAutoUpgradeMinorVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceAutoUpgradeMinorVersionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceAutoUpgradeMinorVersionResponseBody(name='body'),
}

async function modifyDBInstanceAutoUpgradeMinorVersion(request: ModifyDBInstanceAutoUpgradeMinorVersionRequest): ModifyDBInstanceAutoUpgradeMinorVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceAutoUpgradeMinorVersion', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceConnectionModeRequest {
  connectionMode: string(name='ConnectionMode', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceConnectionModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionModeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceConnectionModeResponseBody(name='body'),
}

async function modifyDBInstanceConnectionMode(request: ModifyDBInstanceConnectionModeRequest): ModifyDBInstanceConnectionModeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceConnectionMode', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceConnectionStringRequest {
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  generalGroupName?: string(name='GeneralGroupName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceConnectionStringResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionStringResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceConnectionStringResponseBody(name='body'),
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceConnectionString', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceDescriptionRequest {
  DBInstanceDescription: string(name='DBInstanceDescription', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceDescriptionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceDescriptionResponseBody(name='body'),
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceDescription', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceHAConfigRequest {
  dbInstanceId: string(name='DbInstanceId', position='Query'),
  HAMode: string(name='HAMode', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  syncMode: string(name='SyncMode', position='Query'),
}

model ModifyDBInstanceHAConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceHAConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceHAConfigResponseBody(name='body'),
}

async function modifyDBInstanceHAConfig(request: ModifyDBInstanceHAConfigRequest): ModifyDBInstanceHAConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceHAConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  maintainTime: string(name='MaintainTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMaintainTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMetricsRequest {
  DBInstanceName: string(name='DBInstanceName', position='Query'),
  metricsConfig: string(name='MetricsConfig', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  scope: string(name='Scope', position='Query'),
}

model ModifyDBInstanceMetricsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  scope?: string(name='Scope'),
}

model ModifyDBInstanceMetricsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMetricsResponseBody(name='body'),
}

async function modifyDBInstanceMetrics(request: ModifyDBInstanceMetricsRequest): ModifyDBInstanceMetricsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMetrics', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceMonitorRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: string(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceMonitorResponseBody(name='body'),
}

async function modifyDBInstanceMonitor(request: ModifyDBInstanceMonitorRequest): ModifyDBInstanceMonitorResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceMonitor', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceNetworkExpireTimeRequest {
  classicExpiredDays: int32(name='ClassicExpiredDays', position='Query'),
  connectionString: string(name='ConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceNetworkExpireTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceNetworkExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceNetworkExpireTimeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkExpireTime(request: ModifyDBInstanceNetworkExpireTimeRequest): ModifyDBInstanceNetworkExpireTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceNetworkExpireTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceNetworkTypeRequest {
  classicExpiredDays?: string(name='ClassicExpiredDays', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  instanceNetworkType: string(name='InstanceNetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  readWriteSplittingClassicExpiredDays?: int32(name='ReadWriteSplittingClassicExpiredDays', position='Query'),
  readWriteSplittingPrivateIpAddress?: string(name='ReadWriteSplittingPrivateIpAddress', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retainClassic?: string(name='RetainClassic', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model ModifyDBInstanceNetworkTypeResponseBody = {
  connectionString?: string(name='ConnectionString'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceNetworkTypeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceNetworkType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstancePayTypeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  payType: string(name='PayType', position='Query'),
  period: string(name='Period', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  usedTime?: int32(name='UsedTime', position='Query'),
}

model ModifyDBInstancePayTypeResponseBody = {
  orderId?: long(name='OrderId'),
}

model ModifyDBInstancePayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstancePayTypeResponseBody(name='body'),
}

async function modifyDBInstancePayType(request: ModifyDBInstancePayTypeRequest): ModifyDBInstancePayTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstancePayType', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceProxyConfigurationRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  proxyConfigurationKey: string(name='ProxyConfigurationKey', position='Query'),
  proxyConfigurationValue: string(name='ProxyConfigurationValue', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBInstanceProxyConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceProxyConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceProxyConfigurationResponseBody(name='body'),
}

async function modifyDBInstanceProxyConfiguration(request: ModifyDBInstanceProxyConfigurationRequest): ModifyDBInstanceProxyConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceProxyConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceSSLRequest {
  ACL?: string(name='ACL', position='Query'),
  CAType?: string(name='CAType', position='Query'),
  clientCACert?: string(name='ClientCACert', position='Query'),
  clientCAEnabled?: int32(name='ClientCAEnabled', position='Query'),
  clientCertRevocationList?: string(name='ClientCertRevocationList', position='Query'),
  clientCrlEnabled?: int32(name='ClientCrlEnabled', position='Query'),
  connectionString: string(name='ConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  replicationACL?: string(name='ReplicationACL', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SSLEnabled?: int32(name='SSLEnabled', position='Query'),
  serverCert?: string(name='ServerCert', position='Query'),
  serverKey?: string(name='ServerKey', position='Query'),
}

model ModifyDBInstanceSSLResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceSSLResponseBody(name='body'),
}

async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceSSL', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceSpecRequest {
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage?: int32(name='DBInstanceStorage', minimum=5, maximum=32000, position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId', position='Query'),
  direction?: string(name='Direction', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='资源组名称', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sourceBiz?: string(name='SourceBiz', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  usedTime?: long(name='UsedTime', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model ModifyDBInstanceSpecResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceSpecResponseBody(name='body'),
}

async function modifyDBInstanceSpec(request: ModifyDBInstanceSpecRequest): ModifyDBInstanceSpecResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceSpec', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBInstanceTDERequest {
  certificate?: string(name='Certificate', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName?: string(name='DBName', position='Query'),
  encryptionKey?: string(name='EncryptionKey', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  passWord?: string(name='PassWord', position='Query'),
  privateKey?: string(name='PrivateKey', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  roleArn?: string(name='RoleArn', position='Query'),
  TDEStatus: string(name='TDEStatus', position='Query'),
}

model ModifyDBInstanceTDEResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBInstanceTDEResponseBody(name='body'),
}

async function modifyDBInstanceTDE(request: ModifyDBInstanceTDERequest): ModifyDBInstanceTDEResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBInstanceTDE', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBProxyRequest {
  configDBProxyService: string(name='ConfigDBProxyService', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyInstanceNum?: string(name='DBProxyInstanceNum', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model ModifyDBProxyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBProxyResponseBody(name='body'),
}

async function modifyDBProxy(request: ModifyDBProxyRequest): ModifyDBProxyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBProxy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBProxyEndpointRequest {
  configDBProxyFeatures?: string(name='ConfigDBProxyFeatures', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId', position='Query'),
  dbEndpointAliases?: string(name='DbEndpointAliases', position='Query'),
  dbEndpointOperator?: string(name='DbEndpointOperator', position='Query'),
  dbEndpointReadWriteMode?: string(name='DbEndpointReadWriteMode', position='Query'),
  dbEndpointType?: string(name='DbEndpointType', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readOnlyInstanceDistributionType?: string(name='ReadOnlyInstanceDistributionType', position='Query'),
  readOnlyInstanceMaxDelayTime?: string(name='ReadOnlyInstanceMaxDelayTime', position='Query'),
  readOnlyInstanceWeight?: string(name='ReadOnlyInstanceWeight', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBProxyEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyEndpointResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBProxyEndpointResponseBody(name='body'),
}

async function modifyDBProxyEndpoint(request: ModifyDBProxyEndpointRequest): ModifyDBProxyEndpointResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBProxyEndpoint', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBProxyEndpointAddressRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType', position='Query'),
  DBProxyEndpointId: string(name='DBProxyEndpointId', position='Query'),
  DBProxyNewConnectString?: string(name='DBProxyNewConnectString', position='Query'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBProxyEndpointAddressResponseBody(name='body'),
}

async function modifyDBProxyEndpointAddress(request: ModifyDBProxyEndpointAddressRequest): ModifyDBProxyEndpointAddressResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBProxyEndpointAddress', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDBProxyInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBProxyInstanceNum: string(name='DBProxyInstanceNum', position='Query'),
  DBProxyInstanceType: string(name='DBProxyInstanceType', position='Query'),
  effectiveSpecificTime?: string(name='EffectiveSpecificTime', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDBProxyInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDBProxyInstanceResponseBody(name='body'),
}

async function modifyDBProxyInstance(request: ModifyDBProxyInstanceRequest): ModifyDBProxyInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDBProxyInstance', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDTCSecurityIpHostsForSQLServerRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityIpHosts: string(name='SecurityIpHosts', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
  whiteListGroupName: string(name='WhiteListGroupName', position='Query'),
}

model ModifyDTCSecurityIpHostsForSQLServerResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  DTCSetResult?: string(name='DTCSetResult'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDTCSecurityIpHostsForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDTCSecurityIpHostsForSQLServerResponseBody(name='body'),
}

async function modifyDTCSecurityIpHostsForSQLServer(request: ModifyDTCSecurityIpHostsForSQLServerRequest): ModifyDTCSecurityIpHostsForSQLServerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDTCSecurityIpHostsForSQLServer', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDasInstanceConfigRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  storageAutoScale: string(name='StorageAutoScale', position='Query'),
  storageThreshold?: int32(name='StorageThreshold', minimum=10, maximum=50, position='Query'),
  storageUpperBound?: int32(name='StorageUpperBound', minimum=0, position='Query'),
}

model ModifyDasInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDasInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDasInstanceConfigResponseBody(name='body'),
}

async function modifyDasInstanceConfig(request: ModifyDasInstanceConfigRequest): ModifyDasInstanceConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDasInstanceConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDbProxyInstanceSslRequest {
  dbInstanceId: string(name='DbInstanceId', position='Query'),
  dbProxyConnectString: string(name='DbProxyConnectString', position='Query'),
  dbProxyEndpointId: string(name='DbProxyEndpointId', position='Query'),
  dbProxySslEnabled: string(name='DbProxySslEnabled', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
}

model ModifyDbProxyInstanceSslResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDbProxyInstanceSslResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDbProxyInstanceSslResponseBody(name='body'),
}

async function modifyDbProxyInstanceSsl(request: ModifyDbProxyInstanceSslRequest): ModifyDbProxyInstanceSslResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDbProxyInstanceSsl', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAccountResponseBody(name='body'),
}

async function modifyDedicatedHostAccount(request: ModifyDedicatedHostAccountRequest): ModifyDedicatedHostAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAccount', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostAttributeRequest {
  allocationStatus?: string(name='AllocationStatus', position='Query'),
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  hostName?: string(name='HostName', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostAttribute(request: ModifyDedicatedHostAttributeRequest): ModifyDedicatedHostAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostGroupAttributeRequest {
  allocationPolicy?: string(name='AllocationPolicy', position='Query'),
  cpuAllocationRatio?: int32(name='CpuAllocationRatio', position='Query'),
  dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc', position='Query'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  diskAllocationRatio?: int32(name='DiskAllocationRatio', position='Query'),
  hostReplacePolicy?: string(name='HostReplacePolicy', position='Query'),
  memAllocationRatio?: int32(name='MemAllocationRatio', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyDedicatedHostGroupAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostGroupAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostGroupAttributeResponseBody(name='body'),
}

async function modifyDedicatedHostGroupAttribute(request: ModifyDedicatedHostGroupAttributeRequest): ModifyDedicatedHostGroupAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostGroupAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyDedicatedHostUserRequest {
  dedicatedHostName: string(name='DedicatedHostName', position='Query'),
  newPassword: string(name='NewPassword', position='Query'),
  oldPassword: string(name='OldPassword', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  userName: string(name='UserName', position='Query'),
}

model ModifyDedicatedHostUserResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDedicatedHostUserResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyDedicatedHostUserResponseBody(name='body'),
}

async function modifyDedicatedHostUser(request: ModifyDedicatedHostUserRequest): ModifyDedicatedHostUserResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyDedicatedHostUser', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHADiagnoseConfigRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tcpConnectionType?: string(name='TcpConnectionType', position='Query'),
}

model ModifyHADiagnoseConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHADiagnoseConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHADiagnoseConfigResponseBody(name='body'),
}

async function modifyHADiagnoseConfig(request: ModifyHADiagnoseConfigRequest): ModifyHADiagnoseConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHADiagnoseConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyHASwitchConfigRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  HAConfig?: string(name='HAConfig', position='Query'),
  manualHATime?: string(name='ManualHATime', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyHASwitchConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHASwitchConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyHASwitchConfigResponseBody(name='body'),
}

async function modifyHASwitchConfig(request: ModifyHASwitchConfigRequest): ModifyHASwitchConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyHASwitchConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  autoRenew?: string(name='AutoRenew', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  duration?: string(name='Duration', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceAutoRenewalAttribute', 'POST', '/', 'json', false, 'json', request);
}

model ModifyInstanceCrossBackupPolicyRequest {
  backupEnabled?: string(name='BackupEnabled', position='Query'),
  crossBackupRegion?: string(name='CrossBackupRegion', position='Query'),
  crossBackupType?: string(name='CrossBackupType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  logBackupEnabled?: string(name='LogBackupEnabled', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentType?: int32(name='RetentType', position='Query'),
  retention?: int32(name='Retention', position='Query'),
}

model ModifyInstanceCrossBackupPolicyResponseBody = {
  backupEnabled?: string(name='BackupEnabled'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  crossBackupType?: string(name='CrossBackupType'),
  DBInstanceId?: string(name='DBInstanceId'),
  logBackupEnabled?: string(name='LogBackupEnabled'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  retentType?: int32(name='RetentType'),
  retention?: int32(name='Retention'),
}

model ModifyInstanceCrossBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyInstanceCrossBackupPolicyResponseBody(name='body'),
}

async function modifyInstanceCrossBackupPolicy(request: ModifyInstanceCrossBackupPolicyRequest): ModifyInstanceCrossBackupPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyInstanceCrossBackupPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifyPGHbaConfigRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  hbaItem: [ 
    {
      address: string(name='Address'),
      database: string(name='Database'),
      mask?: string(name='Mask'),
      method: string(name='Method'),
      option?: string(name='Option'),
      priorityId: int32(name='PriorityId'),
      type: string(name='Type'),
      user: string(name='User'),
    }
  ](name='HbaItem', position='Query'),
  opsType: string(name='OpsType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyPGHbaConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPGHbaConfigResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyPGHbaConfigResponseBody(name='body'),
}

async function modifyPGHbaConfig(request: ModifyPGHbaConfigRequest): ModifyPGHbaConfigResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyPGHbaConfig', 'POST', '/', 'json', false, 'json', request);
}

model ModifyParameterRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  forcerestart?: boolean(name='Forcerestart', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupId?: string(name='ParameterGroupId', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyParameterResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyParameterResponseBody(name='body'),
}

async function modifyParameter(request: ModifyParameterRequest): ModifyParameterResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyParameter', 'POST', '/', 'json', false, 'json', request);
}

model ModifyParameterGroupRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  parameterGroupDesc?: string(name='ParameterGroupDesc', position='Query'),
  parameterGroupId: string(name='ParameterGroupId', position='Query'),
  parameterGroupName?: string(name='ParameterGroupName', position='Query'),
  parameters?: string(name='Parameters', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model ModifyParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyParameterGroupResponseBody(name='body'),
}

async function modifyParameterGroup(request: ModifyParameterGroupRequest): ModifyParameterGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyParameterGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifyReadWriteSplittingConnectionRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  distributionType?: string(name='DistributionType', position='Query'),
  maxDelayTime?: string(name='MaxDelayTime', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  weight?: string(name='Weight', position='Query'),
}

model ModifyReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReadWriteSplittingConnectionResponseBody(name='body'),
}

async function modifyReadWriteSplittingConnection(request: ModifyReadWriteSplittingConnectionRequest): ModifyReadWriteSplittingConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReadWriteSplittingConnection', 'POST', '/', 'json', false, 'json', request);
}

model ModifyReadonlyInstanceDelayReplicationTimeRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  readSQLReplicationTime: string(name='ReadSQLReplicationTime', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyReadonlyInstanceDelayReplicationTimeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  readSQLReplicationTime?: string(name='ReadSQLReplicationTime'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyReadonlyInstanceDelayReplicationTimeResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyReadonlyInstanceDelayReplicationTimeResponseBody(name='body'),
}

async function modifyReadonlyInstanceDelayReplicationTime(request: ModifyReadonlyInstanceDelayReplicationTimeRequest): ModifyReadonlyInstanceDelayReplicationTimeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyReadonlyInstanceDelayReplicationTime', 'POST', '/', 'json', false, 'json', request);
}

model ModifyResourceGroupRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ModifyResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: ModifyResourceGroupResponseBody(name='body'),
}

async function modifyResourceGroup(request: ModifyResourceGroupRequest): ModifyResourceGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifyResourceGroup', 'POST', '/', 'json', false, 'json', request);
}

model ModifySQLCollectorPolicyRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  SQLCollectorStatus: string(name='SQLCollectorStatus', position='Query'),
}

model ModifySQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySQLCollectorPolicyResponseBody(name='body'),
}

async function modifySQLCollectorPolicy(request: ModifySQLCollectorPolicyRequest): ModifySQLCollectorPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySQLCollectorPolicy', 'POST', '/', 'json', false, 'json', request);
}

model ModifySQLCollectorRetentionRequest {
  configValue: string(name='ConfigValue', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Host'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityToken?: string(name='SecurityToken', position='Query'),
}

model ModifySQLCollectorRetentionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySQLCollectorRetentionResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySQLCollectorRetentionResponseBody(name='body'),
}

async function modifySQLCollectorRetention(request: ModifySQLCollectorRetentionRequest): ModifySQLCollectorRetentionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySQLCollectorRetention', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityGroupConfigurationRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', position='Query'),
}

model ModifySecurityGroupConfigurationResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    ecsSecurityGroupRelation?: [ 
    {
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='EcsSecurityGroupRelation')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityGroupConfigurationResponseBody(name='body'),
}

async function modifySecurityGroupConfiguration(request: ModifySecurityGroupConfigurationRequest): ModifySecurityGroupConfigurationResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityGroupConfiguration', 'POST', '/', 'json', false, 'json', request);
}

model ModifySecurityIpsRequest {
  DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute', position='Query'),
  DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  freshWhiteListReadins?: string(name='FreshWhiteListReadins', position='Query'),
  modifyMode?: string(name='ModifyMode', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityIPType?: string(name='SecurityIPType', position='Query'),
  securityIps: string(name='SecurityIps', position='Query'),
  whitelistNetworkType?: string(name='WhitelistNetworkType', position='Query'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ModifySecurityIps', 'POST', '/', 'json', false, 'json', request);
}

model PurgeDBInstanceLogRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model PurgeDBInstanceLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model PurgeDBInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  body: PurgeDBInstanceLogResponseBody(name='body'),
}

async function purgeDBInstanceLog(request: PurgeDBInstanceLogRequest): PurgeDBInstanceLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'PurgeDBInstanceLog', 'POST', '/', 'json', false, 'json', request);
}

model RebuildDBInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  dedicatedHostId?: string(name='DedicatedHostId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  rebuildNodeType?: string(name='RebuildNodeType', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RebuildDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model RebuildDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RebuildDBInstanceResponseBody(name='body'),
}

async function rebuildDBInstance(request: RebuildDBInstanceRequest): RebuildDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RebuildDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model RecoveryDBInstanceRequest {
  backupId?: string(name='BackupId', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage?: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  dbNames: string(name='DbNames', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  payType?: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  targetDBInstanceId?: string(name='TargetDBInstanceId', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model RecoveryDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RecoveryDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RecoveryDBInstanceResponseBody(name='body'),
}

async function recoveryDBInstance(request: RecoveryDBInstanceRequest): RecoveryDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RecoveryDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstanceConnectionRequest {
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  instanceNetworkType: string(name='InstanceNetworkType', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseInstanceConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstanceConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstanceConnectionResponseBody(name='body'),
}

async function releaseInstanceConnection(request: ReleaseInstanceConnectionRequest): ReleaseInstanceConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstanceConnection', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseInstancePublicConnectionRequest {
  currentConnectionString: string(name='CurrentConnectionString', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseInstancePublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseInstancePublicConnectionResponseBody(name='body'),
}

async function releaseInstancePublicConnection(request: ReleaseInstancePublicConnectionRequest): ReleaseInstancePublicConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseInstancePublicConnection', 'POST', '/', 'json', false, 'json', request);
}

model ReleaseReadWriteSplittingConnectionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReleaseReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  body: ReleaseReadWriteSplittingConnectionResponseBody(name='body'),
}

async function releaseReadWriteSplittingConnection(request: ReleaseReadWriteSplittingConnectionRequest): ReleaseReadWriteSplittingConnectionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReleaseReadWriteSplittingConnection', 'POST', '/', 'json', false, 'json', request);
}

model RemoveTagsFromResourceRequest {
  tag?: [
    {
      key?: string(name='key', position=''),
      value?: string(name='value', position=''),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tags?: string(name='Tags', position='Query'),
  proxyId?: string(name='proxyId', position='Query'),
}

model RemoveTagsFromResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsFromResourceResponse = {
  headers: map[string]string(name='headers'),
  body: RemoveTagsFromResourceResponseBody(name='body'),
}

async function removeTagsFromResource(request: RemoveTagsFromResourceRequest): RemoveTagsFromResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RemoveTagsFromResource', 'POST', '/', 'json', false, 'json', request);
}

model RenewInstanceRequest {
  autoPay?: string(name='AutoPay', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period: int32(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RenewInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RenewInstance', 'POST', '/', 'json', false, 'json', request);
}

model ReplaceDedicatedHostRequest {
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  failoverMode: string(name='FailoverMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ReplaceDedicatedHostResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model ReplaceDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: ReplaceDedicatedHostResponseBody(name='body'),
}

async function replaceDedicatedHost(request: ReplaceDedicatedHostRequest): ReplaceDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ReplaceDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model ResetAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ResetAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ResetAccountResponseBody(name='body'),
}

async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAccount', 'POST', '/', 'json', false, 'json', request);
}

model ResetAccountPasswordRequest {
  accountName: string(name='AccountName', position='Query'),
  accountPassword: string(name='AccountPassword', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  body: ResetAccountPasswordResponseBody(name='body'),
}

async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResetAccountPassword', 'POST', '/', 'json', false, 'json', request);
}

model RestartDBInstanceRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RestartDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDBInstanceResponseBody(name='body'),
}

async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model RestartDedicatedHostRequest {
  dedicatedHostId: string(name='DedicatedHostId', position='Query'),
  failoverMode: string(name='FailoverMode', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RestartDedicatedHostResponseBody = {
  dedicatedHostId?: string(name='DedicatedHostId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model RestartDedicatedHostResponse = {
  headers: map[string]string(name='headers'),
  body: RestartDedicatedHostResponseBody(name='body'),
}

async function restartDedicatedHost(request: RestartDedicatedHostRequest): RestartDedicatedHostResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartDedicatedHost', 'POST', '/', 'json', false, 'json', request);
}

model RestoreDdrTableRequest {
  backupId?: string(name='BackupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  restoreType: string(name='RestoreType', position='Query'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName', position='Query'),
  sourceRegion?: string(name='SourceRegion', position='Query'),
  tableMeta: string(name='TableMeta', position='Query'),
}

model RestoreDdrTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestoreDdrTableResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreDdrTableResponseBody(name='body'),
}

async function restoreDdrTable(request: RestoreDdrTableRequest): RestoreDdrTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreDdrTable', 'POST', '/', 'json', false, 'json', request);
}

model RestoreTableRequest {
  backupId?: string(name='BackupId', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  instantRecovery?: boolean(name='InstantRecovery', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restoreTime?: string(name='RestoreTime', position='Query'),
  tableMeta: string(name='TableMeta', position='Query'),
}

model RestoreTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestoreTableResponse = {
  headers: map[string]string(name='headers'),
  body: RestoreTableResponseBody(name='body'),
}

async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestoreTable', 'POST', '/', 'json', false, 'json', request);
}

model RevokeAccountPrivilegeRequest {
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBName: string(name='DBName', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RevokeAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeAccountPrivilegeResponseBody(name='body'),
}

async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeAccountPrivilege', 'POST', '/', 'json', false, 'json', request);
}

model RevokeOperatorPermissionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RevokeOperatorPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeOperatorPermissionResponse = {
  headers: map[string]string(name='headers'),
  body: RevokeOperatorPermissionResponseBody(name='body'),
}

async function revokeOperatorPermission(request: RevokeOperatorPermissionRequest): RevokeOperatorPermissionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RevokeOperatorPermission', 'POST', '/', 'json', false, 'json', request);
}

model StartDBInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  DBInstanceTransType?: int32(name='DBInstanceTransType', position='Query'),
  dedicatedHostGroupId: string(name='DedicatedHostGroupId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  engineVersion?: string(name='EngineVersion', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  specifiedTime?: string(name='SpecifiedTime', position='Query'),
  storage?: int32(name='Storage', position='Query'),
  targetDBInstanceClass?: string(name='TargetDBInstanceClass', position='Query'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog', position='Query'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster', position='Query'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
}

model StartDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model StartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StartDBInstanceResponseBody(name='body'),
}

async function startDBInstance(request: StartDBInstanceRequest): StartDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StartDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model StopDBInstanceRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model StopDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: StopDBInstanceResponseBody(name='body'),
}

async function stopDBInstance(request: StopDBInstanceRequest): StopDBInstanceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'StopDBInstance', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDBInstanceHARequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  force?: string(name='Force', position='Query'),
  nodeId: string(name='NodeId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SwitchDBInstanceHAResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceHAResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDBInstanceHAResponseBody(name='body'),
}

async function switchDBInstanceHA(request: SwitchDBInstanceHARequest): SwitchDBInstanceHAResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDBInstanceHA', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDBInstanceNetTypeRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  connectionStringPrefix: string(name='ConnectionStringPrefix', position='Query'),
  connectionStringType?: string(name='ConnectionStringType', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  port?: string(name='Port', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model SwitchDBInstanceNetTypeResponseBody = {
  newConnectionString?: string(name='NewConnectionString'),
  oldConnectionString?: string(name='OldConnectionString'),
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceNetTypeResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDBInstanceNetTypeResponseBody(name='body'),
}

async function switchDBInstanceNetType(request: SwitchDBInstanceNetTypeRequest): SwitchDBInstanceNetTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDBInstanceNetType', 'POST', '/', 'json', false, 'json', request);
}

model SwitchDBInstanceVpcRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
}

model SwitchDBInstanceVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceVpcResponse = {
  headers: map[string]string(name='headers'),
  body: SwitchDBInstanceVpcResponseBody(name='body'),
}

async function switchDBInstanceVpc(request: SwitchDBInstanceVpcRequest): SwitchDBInstanceVpcResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SwitchDBInstanceVpc', 'POST', '/', 'json', false, 'json', request);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tag?: [ 
    {
      key: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Query'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TagResources', 'POST', '/', 'json', false, 'json', request);
}

model TerminateMigrateTaskRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  migrateTaskId: string(name='MigrateTaskId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model TerminateMigrateTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateMigrateTaskResponse = {
  headers: map[string]string(name='headers'),
  body: TerminateMigrateTaskResponseBody(name='body'),
}

async function terminateMigrateTask(request: TerminateMigrateTaskRequest): TerminateMigrateTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TerminateMigrateTask', 'POST', '/', 'json', false, 'json', request);
}

model TransformDBInstancePayTypeRequest {
  autoRenew?: string(name='AutoRenew', position='Query'),
  businessInfo?: string(name='BusinessInfo', position='Query'),
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  usedTime?: int32(name='UsedTime', position='Query'),
}

model TransformDBInstancePayTypeResponseBody = {
  chargeType?: string(name='ChargeType'),
  DBInstanceId?: string(name='DBInstanceId'),
  expiredTime?: string(name='ExpiredTime'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model TransformDBInstancePayTypeResponse = {
  headers: map[string]string(name='headers'),
  body: TransformDBInstancePayTypeResponseBody(name='body'),
}

async function transformDBInstancePayType(request: TransformDBInstancePayTypeRequest): TransformDBInstancePayTypeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'TransformDBInstancePayType', 'POST', '/', 'json', false, 'json', request);
}

model UnlockAccountRequest {
  accountName: string(name='AccountName', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UnlockAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnlockAccountResponse = {
  headers: map[string]string(name='headers'),
  body: UnlockAccountResponseBody(name='body'),
}

async function unlockAccount(request: UnlockAccountRequest): UnlockAccountResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UnlockAccount', 'POST', '/', 'json', false, 'json', request);
}

model UntagResourcesRequest {
  all?: boolean(name='All', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceId: [ string ](name='ResourceId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  resourceType: string(name='ResourceType', position='Query'),
  tagKey?: [ string ](name='TagKey', position='Query'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UntagResources', 'POST', '/', 'json', false, 'json', request);
}

model UpdateUserBackupFileRequest {
  backupId: string(name='BackupId', position='Query'),
  comment?: string(name='Comment', minLength=2, maxLength=256, position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retention?: int32(name='Retention', position='Query'),
}

model UpdateUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
}

model UpdateUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateUserBackupFileResponseBody(name='body'),
}

async function updateUserBackupFile(request: UpdateUserBackupFileRequest): UpdateUserBackupFileResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateUserBackupFile', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceEngineVersionRequest {
  clientToken?: string(name='ClientToken', position='Query'),
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  effectiveTime?: string(name='EffectiveTime', position='Query'),
  engineVersion: string(name='EngineVersion', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model UpgradeDBInstanceEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceEngineVersionResponseBody(name='body'),
}

async function upgradeDBInstanceEngineVersion(request: UpgradeDBInstanceEngineVersionRequest): UpgradeDBInstanceEngineVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceEngineVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceKernelVersionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  targetMinorVersion?: string(name='TargetMinorVersion', position='Query'),
  upgradeTime?: string(name='UpgradeTime', position='Query'),
}

model UpgradeDBInstanceKernelVersionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceKernelVersionResponseBody(name='body'),
}

async function upgradeDBInstanceKernelVersion(request: UpgradeDBInstanceKernelVersionRequest): UpgradeDBInstanceKernelVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceKernelVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceMajorVersionRequest {
  collectStatMode?: string(name='CollectStatMode', position='Query'),
  DBInstanceClass?: string(name='DBInstanceClass', position='Query'),
  DBInstanceId?: string(name='DBInstanceId', position='Query'),
  DBInstanceStorage?: int32(name='DBInstanceStorage', position='Query'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType', position='Query'),
  instanceNetworkType?: string(name='InstanceNetworkType', position='Query'),
  payType: string(name='PayType', position='Query'),
  period?: string(name='Period', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchOver?: string(name='SwitchOver', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  switchTimeMode?: string(name='SwitchTimeMode', position='Query'),
  targetMajorVersion?: string(name='TargetMajorVersion', position='Query'),
  usedTime?: string(name='UsedTime', position='Query'),
  VPCId?: string(name='VPCId', position='Query'),
  vSwitchId?: string(name='VSwitchId', position='Query'),
  zoneId?: string(name='ZoneId', position='Query'),
  zoneIdSlave1?: string(name='ZoneIdSlave1', position='Query'),
  zoneIdSlave2?: string(name='ZoneIdSlave2', position='Query'),
}

model UpgradeDBInstanceMajorVersionResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model UpgradeDBInstanceMajorVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceMajorVersionResponseBody(name='body'),
}

async function upgradeDBInstanceMajorVersion(request: UpgradeDBInstanceMajorVersionRequest): UpgradeDBInstanceMajorVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceMajorVersion', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBInstanceMajorVersionPrecheckRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  targetMajorVersion: string(name='TargetMajorVersion', position='Query'),
}

model UpgradeDBInstanceMajorVersionPrecheckResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceMajorVersionPrecheckResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBInstanceMajorVersionPrecheckResponseBody(name='body'),
}

async function upgradeDBInstanceMajorVersionPrecheck(request: UpgradeDBInstanceMajorVersionPrecheckRequest): UpgradeDBInstanceMajorVersionPrecheckResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBInstanceMajorVersionPrecheck', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeDBProxyInstanceKernelVersionRequest {
  DBInstanceId: string(name='DBInstanceId', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  switchTime?: string(name='SwitchTime', position='Query'),
  upgradeTime?: string(name='UpgradeTime', position='Query'),
}

model UpgradeDBProxyInstanceKernelVersionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBProxyInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeDBProxyInstanceKernelVersionResponseBody(name='body'),
}

async function upgradeDBProxyInstanceKernelVersion(request: UpgradeDBProxyInstanceKernelVersionRequest): UpgradeDBProxyInstanceKernelVersionResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeDBProxyInstanceKernelVersion', 'POST', '/', 'json', false, 'json', request);
}

