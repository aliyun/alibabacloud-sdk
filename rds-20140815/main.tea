/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    cn-qingdao = 'rds.aliyuncs.com',
    cn-beijing = 'rds.aliyuncs.com',
    cn-hangzhou = 'rds.aliyuncs.com',
    cn-shanghai = 'rds.aliyuncs.com',
    cn-shenzhen = 'rds.aliyuncs.com',
    cn-heyuan = 'rds.aliyuncs.com',
    cn-hongkong = 'rds.aliyuncs.com',
    ap-southeast-1 = 'rds.aliyuncs.com',
    us-west-1 = 'rds.aliyuncs.com',
    us-east-1 = 'rds.aliyuncs.com',
    cn-shanghai-finance-1 = 'rds.aliyuncs.com',
    cn-shenzhen-finance-1 = 'rds.aliyuncs.com',
    cn-north-2-gov-1 = 'rds.aliyuncs.com',
    ap-northeast-2-pop = 'rds.aliyuncs.com',
    cn-beijing-finance-1 = 'rds.aliyuncs.com',
    cn-beijing-finance-pop = 'rds.aliyuncs.com',
    cn-beijing-gov-1 = 'rds.aliyuncs.com',
    cn-beijing-nu16-b01 = 'rds.aliyuncs.com',
    cn-edge-1 = 'rds.aliyuncs.com',
    cn-fujian = 'rds.aliyuncs.com',
    cn-haidian-cm12-c01 = 'rds.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'rds.aliyuncs.com',
    cn-hangzhou-finance = 'rds-vpc.cn-hangzhou-finance.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'rds.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'rds.aliyuncs.com',
    cn-hangzhou-test-306 = 'rds.aliyuncs.com',
    cn-hongkong-finance-pop = 'rds.aliyuncs.com',
    cn-qingdao-nebula = 'rds.aliyuncs.com',
    cn-shanghai-et15-b01 = 'rds.aliyuncs.com',
    cn-shanghai-et2-b01 = 'rds.aliyuncs.com',
    cn-shanghai-inner = 'rds.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'rds.aliyuncs.com',
    cn-shenzhen-inner = 'rds.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'rds.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'rds.aliyuncs.com',
    cn-wuhan = 'rds.aliyuncs.com',
    cn-yushanfang = 'rds.aliyuncs.com',
    cn-zhangbei = 'rds.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'rds.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'rds.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'rds.aliyuncs.com',
    eu-west-1-oxs = 'rds.aliyuncs.com',
    rus-west-1-pop = 'rds.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('rds', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model ActivateMigrationTargetInstanceRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  forceSwitch?: string(name='ForceSwitch'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  switchTimeMode?: string(name='SwitchTimeMode'),
}

model ActivateMigrationTargetInstanceResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePort?: long(name='SourcePort'),
  taskId?: long(name='TaskId'),
}

model ActivateMigrationTargetInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ActivateMigrationTargetInstanceResponseBody(name='body'),
}

async function activateMigrationTargetInstanceWithOptions(request: ActivateMigrationTargetInstanceRequest, runtime: Util.RuntimeOptions): ActivateMigrationTargetInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.forceSwitch)) {
    query['ForceSwitch'] = request.forceSwitch;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.switchTimeMode)) {
    query['SwitchTimeMode'] = request.switchTimeMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ActivateMigrationTargetInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function activateMigrationTargetInstance(request: ActivateMigrationTargetInstanceRequest): ActivateMigrationTargetInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return activateMigrationTargetInstanceWithOptions(request, runtime);
}

model AddTagsToResourceRequest {
  tag?: [
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  proxyId?: string(name='proxyId'),
}

model AddTagsToResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model AddTagsToResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddTagsToResourceResponseBody(name='body'),
}

async function addTagsToResourceWithOptions(request: AddTagsToResourceRequest, runtime: Util.RuntimeOptions): AddTagsToResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddTagsToResource',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addTagsToResource(request: AddTagsToResourceRequest): AddTagsToResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return addTagsToResourceWithOptions(request, runtime);
}

model AllocateInstancePublicConnectionRequest {
  babelfishPort?: string(name='BabelfishPort'),
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  DBInstanceId?: string(name='DBInstanceId'),
  generalGroupName?: string(name='GeneralGroupName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model AllocateInstancePublicConnectionResponseBody = {
  connectionString?: string(name='ConnectionString'),
  dbInstanceName?: string(name='DbInstanceName'),
  requestId?: string(name='RequestId'),
}

model AllocateInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateInstancePublicConnectionResponseBody(name='body'),
}

async function allocateInstancePublicConnectionWithOptions(request: AllocateInstancePublicConnectionRequest, runtime: Util.RuntimeOptions): AllocateInstancePublicConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.babelfishPort)) {
    query['BabelfishPort'] = request.babelfishPort;
  }
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.generalGroupName)) {
    query['GeneralGroupName'] = request.generalGroupName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateInstancePublicConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateInstancePublicConnection(request: AllocateInstancePublicConnectionRequest): AllocateInstancePublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateInstancePublicConnectionWithOptions(request, runtime);
}

model AllocateReadWriteSplittingConnectionRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  DBInstanceId?: string(name='DBInstanceId'),
  distributionType?: string(name='DistributionType'),
  maxDelayTime?: string(name='MaxDelayTime'),
  netType?: string(name='NetType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  weight?: string(name='Weight'),
}

model AllocateReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model AllocateReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AllocateReadWriteSplittingConnectionResponseBody(name='body'),
}

async function allocateReadWriteSplittingConnectionWithOptions(request: AllocateReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): AllocateReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.distributionType)) {
    query['DistributionType'] = request.distributionType;
  }
  if (!Util.isUnset(request.maxDelayTime)) {
    query['MaxDelayTime'] = request.maxDelayTime;
  }
  if (!Util.isUnset(request.netType)) {
    query['NetType'] = request.netType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AllocateReadWriteSplittingConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function allocateReadWriteSplittingConnection(request: AllocateReadWriteSplittingConnectionRequest): AllocateReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return allocateReadWriteSplittingConnectionWithOptions(request, runtime);
}

model CalculateDBInstanceWeightRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CalculateDBInstanceWeightResponseBody = {
  items?: {
    DBInstanceWeight?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceType?: string(name='DBInstanceType'),
      readonlyInstanceSQLDelayedTime?: string(name='ReadonlyInstanceSQLDelayedTime'),
      weight?: string(name='Weight'),
    }
  ](name='DBInstanceWeight')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model CalculateDBInstanceWeightResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CalculateDBInstanceWeightResponseBody(name='body'),
}

async function calculateDBInstanceWeightWithOptions(request: CalculateDBInstanceWeightRequest, runtime: Util.RuntimeOptions): CalculateDBInstanceWeightResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CalculateDBInstanceWeight',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function calculateDBInstanceWeight(request: CalculateDBInstanceWeightRequest): CalculateDBInstanceWeightResponse {
  var runtime = new Util.RuntimeOptions{};
  return calculateDBInstanceWeightWithOptions(request, runtime);
}

model CancelImportRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  importId?: int32(name='ImportId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CancelImportResponseBody = {
  requestId?: string(name='RequestId'),
}

model CancelImportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelImportResponseBody(name='body'),
}

async function cancelImportWithOptions(request: CancelImportRequest, runtime: Util.RuntimeOptions): CancelImportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.importId)) {
    query['ImportId'] = request.importId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelImport',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelImport(request: CancelImportRequest): CancelImportResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelImportWithOptions(request, runtime);
}

model CheckAccountNameAvailableRequest {
  accountName?: string(name='AccountName'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
}

model CheckAccountNameAvailableResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckAccountNameAvailableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckAccountNameAvailableResponseBody(name='body'),
}

async function checkAccountNameAvailableWithOptions(request: CheckAccountNameAvailableRequest, runtime: Util.RuntimeOptions): CheckAccountNameAvailableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckAccountNameAvailable',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkAccountNameAvailable(request: CheckAccountNameAvailableRequest): CheckAccountNameAvailableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAccountNameAvailableWithOptions(request, runtime);
}

model CheckCloudResourceAuthorizedRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  targetRegionId?: string(name='TargetRegionId'),
}

model CheckCloudResourceAuthorizedResponseBody = {
  authorizationState?: int32(name='AuthorizationState'),
  requestId?: string(name='RequestId'),
  roleArn?: string(name='RoleArn'),
}

model CheckCloudResourceAuthorizedResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckCloudResourceAuthorizedResponseBody(name='body'),
}

async function checkCloudResourceAuthorizedWithOptions(request: CheckCloudResourceAuthorizedRequest, runtime: Util.RuntimeOptions): CheckCloudResourceAuthorizedResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckCloudResourceAuthorized',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkCloudResourceAuthorized(request: CheckCloudResourceAuthorizedRequest): CheckCloudResourceAuthorizedResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCloudResourceAuthorizedWithOptions(request, runtime);
}

model CheckCreateDdrDBInstanceRequest {
  backupSetId?: string(name='BackupSetId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  restoreType?: string(name='RestoreType'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName'),
  sourceRegion?: string(name='SourceRegion'),
}

model CheckCreateDdrDBInstanceResponseBody = {
  isValid?: string(name='IsValid'),
  requestId?: string(name='RequestId'),
}

model CheckCreateDdrDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckCreateDdrDBInstanceResponseBody(name='body'),
}

async function checkCreateDdrDBInstanceWithOptions(request: CheckCreateDdrDBInstanceRequest, runtime: Util.RuntimeOptions): CheckCreateDdrDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupSetId)) {
    query['BackupSetId'] = request.backupSetId;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  if (!Util.isUnset(request.sourceDBInstanceName)) {
    query['SourceDBInstanceName'] = request.sourceDBInstanceName;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckCreateDdrDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkCreateDdrDBInstance(request: CheckCreateDdrDBInstanceRequest): CheckCreateDdrDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkCreateDdrDBInstanceWithOptions(request, runtime);
}

model CheckDBNameAvailableRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckDBNameAvailableResponseBody = {
  requestId?: string(name='RequestId'),
}

model CheckDBNameAvailableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckDBNameAvailableResponseBody(name='body'),
}

async function checkDBNameAvailableWithOptions(request: CheckDBNameAvailableRequest, runtime: Util.RuntimeOptions): CheckDBNameAvailableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckDBNameAvailable',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkDBNameAvailable(request: CheckDBNameAvailableRequest): CheckDBNameAvailableResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkDBNameAvailableWithOptions(request, runtime);
}

model CheckInstanceExistRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CheckInstanceExistResponseBody = {
  isExistInstance?: boolean(name='IsExistInstance'),
  requestId?: string(name='RequestId'),
}

model CheckInstanceExistResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckInstanceExistResponseBody(name='body'),
}

async function checkInstanceExistWithOptions(request: CheckInstanceExistRequest, runtime: Util.RuntimeOptions): CheckInstanceExistResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckInstanceExist',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkInstanceExist(request: CheckInstanceExistRequest): CheckInstanceExistResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkInstanceExistWithOptions(request, runtime);
}

model CheckServiceLinkedRoleRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceLinkedRole?: string(name='ServiceLinkedRole'),
}

model CheckServiceLinkedRoleResponseBody = {
  hasServiceLinkedRole?: string(name='HasServiceLinkedRole'),
  requestId?: string(name='RequestId'),
}

model CheckServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CheckServiceLinkedRoleResponseBody(name='body'),
}

async function checkServiceLinkedRoleWithOptions(request: CheckServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CheckServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CheckServiceLinkedRole',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function checkServiceLinkedRole(request: CheckServiceLinkedRoleRequest): CheckServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkServiceLinkedRoleWithOptions(request, runtime);
}

model CloneDBInstanceRequest {
  backupId?: string(name='BackupId'),
  backupType?: string(name='BackupType'),
  category?: string(name='Category'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dbNames?: string(name='DbNames'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTable?: string(name='RestoreTable'),
  restoreTime?: string(name='RestoreTime'),
  serverlessConfig?: {
    autoPause?: boolean(name='AutoPause'),
    maxCapacity?: double(name='MaxCapacity'),
    minCapacity?: double(name='MinCapacity'),
    switchForce?: boolean(name='SwitchForce'),
  }(name='ServerlessConfig'),
  tableMeta?: string(name='TableMeta'),
  usedTime?: int32(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CloneDBInstanceShrinkRequest {
  backupId?: string(name='BackupId'),
  backupType?: string(name='BackupType'),
  category?: string(name='Category'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dbNames?: string(name='DbNames'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTable?: string(name='RestoreTable'),
  restoreTime?: string(name='RestoreTime'),
  serverlessConfigShrink?: string(name='ServerlessConfig'),
  tableMeta?: string(name='TableMeta'),
  usedTime?: int32(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CloneDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model CloneDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneDBInstanceResponseBody(name='body'),
}

async function cloneDBInstanceWithOptions(tmpReq: CloneDBInstanceRequest, runtime: Util.RuntimeOptions): CloneDBInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CloneDBInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serverlessConfig)) {
    request.serverlessConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfig, 'ServerlessConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.dbNames)) {
    query['DbNames'] = request.dbNames;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTable)) {
    query['RestoreTable'] = request.restoreTable;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.serverlessConfigShrink)) {
    query['ServerlessConfig'] = request.serverlessConfigShrink;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneDBInstance(request: CloneDBInstanceRequest): CloneDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneDBInstanceWithOptions(request, runtime);
}

model CloneParameterGroupRequest {
  ownerId?: long(name='OwnerId'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
  parameterGroupId?: string(name='ParameterGroupId'),
  parameterGroupName?: string(name='ParameterGroupName'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetRegionId?: string(name='TargetRegionId'),
}

model CloneParameterGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloneParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloneParameterGroupResponseBody(name='body'),
}

async function cloneParameterGroupWithOptions(request: CloneParameterGroupRequest, runtime: Util.RuntimeOptions): CloneParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupDesc)) {
    query['ParameterGroupDesc'] = request.parameterGroupDesc;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameterGroupName)) {
    query['ParameterGroupName'] = request.parameterGroupName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CloneParameterGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cloneParameterGroup(request: CloneParameterGroupRequest): CloneParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return cloneParameterGroupWithOptions(request, runtime);
}

model ConfirmNotifyRequest {
  confirmor?: long(name='Confirmor'),
  notifyIdList?: [ long ](name='NotifyIdList'),
}

model ConfirmNotifyShrinkRequest {
  confirmor?: long(name='Confirmor'),
  notifyIdListShrink?: string(name='NotifyIdList'),
}

model ConfirmNotifyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ConfirmNotifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ConfirmNotifyResponseBody(name='body'),
}

async function confirmNotifyWithOptions(tmpReq: ConfirmNotifyRequest, runtime: Util.RuntimeOptions): ConfirmNotifyResponse {
  Util.validateModel(tmpReq);
  var request = new ConfirmNotifyShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.notifyIdList)) {
    request.notifyIdListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.notifyIdList, 'NotifyIdList', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.confirmor)) {
    body['Confirmor'] = request.confirmor;
  }
  if (!Util.isUnset(request.notifyIdListShrink)) {
    body['NotifyIdList'] = request.notifyIdListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ConfirmNotify',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function confirmNotify(request: ConfirmNotifyRequest): ConfirmNotifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return confirmNotifyWithOptions(request, runtime);
}

model CopyDatabaseRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CopyDatabaseResponseBody = {
  DBName?: string(name='DBName'),
  DBStatus?: string(name='DBStatus'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CopyDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyDatabaseResponseBody(name='body'),
}

async function copyDatabaseWithOptions(request: CopyDatabaseRequest, runtime: Util.RuntimeOptions): CopyDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyDatabase',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyDatabase(request: CopyDatabaseRequest): CopyDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyDatabaseWithOptions(request, runtime);
}

model CopyDatabaseBetweenInstancesRequest {
  backupId?: string(name='BackupId'),
  DBInstanceId?: string(name='DBInstanceId'),
  dbNames?: string(name='DbNames'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  syncUserPrivilege?: string(name='SyncUserPrivilege'),
  targetDBInstanceId?: string(name='TargetDBInstanceId'),
}

model CopyDatabaseBetweenInstancesResponseBody = {
  requestId?: string(name='RequestId'),
}

model CopyDatabaseBetweenInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyDatabaseBetweenInstancesResponseBody(name='body'),
}

async function copyDatabaseBetweenInstancesWithOptions(request: CopyDatabaseBetweenInstancesRequest, runtime: Util.RuntimeOptions): CopyDatabaseBetweenInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.dbNames)) {
    query['DbNames'] = request.dbNames;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.syncUserPrivilege)) {
    query['SyncUserPrivilege'] = request.syncUserPrivilege;
  }
  if (!Util.isUnset(request.targetDBInstanceId)) {
    query['TargetDBInstanceId'] = request.targetDBInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CopyDatabaseBetweenInstances',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function copyDatabaseBetweenInstances(request: CopyDatabaseBetweenInstancesRequest): CopyDatabaseBetweenInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return copyDatabaseBetweenInstancesWithOptions(request, runtime);
}

model CreateAccountRequest {
  accountDescription?: string(name='AccountDescription'),
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  accountType?: string(name='AccountType'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateAccountResponseBody(name='body'),
}

async function createAccountWithOptions(request: CreateAccountRequest, runtime: Util.RuntimeOptions): CreateAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.accountType)) {
    query['AccountType'] = request.accountType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateAccount',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createAccount(request: CreateAccountRequest): CreateAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return createAccountWithOptions(request, runtime);
}

model CreateBackupRequest {
  backupMethod?: string(name='BackupMethod'),
  backupStrategy?: string(name='BackupStrategy'),
  backupType?: string(name='BackupType'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateBackupResponseBody = {
  backupJobId?: string(name='BackupJobId'),
  requestId?: string(name='RequestId'),
}

model CreateBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupResponseBody(name='body'),
}

async function createBackupWithOptions(request: CreateBackupRequest, runtime: Util.RuntimeOptions): CreateBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupMethod)) {
    query['BackupMethod'] = request.backupMethod;
  }
  if (!Util.isUnset(request.backupStrategy)) {
    query['BackupStrategy'] = request.backupStrategy;
  }
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackup(request: CreateBackupRequest): CreateBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupWithOptions(request, runtime);
}

model CreateCloudMigrationPrecheckTaskRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceAccount?: string(name='SourceAccount'),
  sourceCategory?: string(name='SourceCategory'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePassword?: string(name='SourcePassword'),
  sourcePort?: long(name='SourcePort'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationPrecheckTaskResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationPrecheckTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCloudMigrationPrecheckTaskResponseBody(name='body'),
}

async function createCloudMigrationPrecheckTaskWithOptions(request: CreateCloudMigrationPrecheckTaskRequest, runtime: Util.RuntimeOptions): CreateCloudMigrationPrecheckTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceAccount)) {
    query['SourceAccount'] = request.sourceAccount;
  }
  if (!Util.isUnset(request.sourceCategory)) {
    query['SourceCategory'] = request.sourceCategory;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  if (!Util.isUnset(request.sourcePassword)) {
    query['SourcePassword'] = request.sourcePassword;
  }
  if (!Util.isUnset(request.sourcePort)) {
    query['SourcePort'] = request.sourcePort;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudMigrationPrecheckTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCloudMigrationPrecheckTask(request: CreateCloudMigrationPrecheckTaskRequest): CreateCloudMigrationPrecheckTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudMigrationPrecheckTaskWithOptions(request, runtime);
}

model CreateCloudMigrationTaskRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceAccount?: string(name='SourceAccount'),
  sourceCategory?: string(name='SourceCategory'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePassword?: string(name='SourcePassword'),
  sourcePort?: long(name='SourcePort'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationTaskResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model CreateCloudMigrationTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateCloudMigrationTaskResponseBody(name='body'),
}

async function createCloudMigrationTaskWithOptions(request: CreateCloudMigrationTaskRequest, runtime: Util.RuntimeOptions): CreateCloudMigrationTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceAccount)) {
    query['SourceAccount'] = request.sourceAccount;
  }
  if (!Util.isUnset(request.sourceCategory)) {
    query['SourceCategory'] = request.sourceCategory;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  if (!Util.isUnset(request.sourcePassword)) {
    query['SourcePassword'] = request.sourcePassword;
  }
  if (!Util.isUnset(request.sourcePort)) {
    query['SourcePort'] = request.sourcePort;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateCloudMigrationTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createCloudMigrationTask(request: CreateCloudMigrationTaskRequest): CreateCloudMigrationTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createCloudMigrationTaskWithOptions(request, runtime);
}

model CreateDBInstanceRequest {
  amount?: int32(name='Amount'),
  autoRenew?: string(name='AutoRenew'),
  babelfishConfig?: string(name='BabelfishConfig'),
  businessInfo?: string(name='BusinessInfo'),
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  connectionMode?: string(name='ConnectionMode'),
  connectionString?: string(name='ConnectionString'),
  createStrategy?: string(name='CreateStrategy'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceNetType?: string(name='DBInstanceNetType'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  DBIsIgnoreCase?: string(name='DBIsIgnoreCase'),
  DBParamGroupId?: string(name='DBParamGroupId'),
  DBTimeZone?: string(name='DBTimeZone'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  dryRun?: boolean(name='DryRun'),
  encryptionKey?: string(name='EncryptionKey'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleARN?: string(name='RoleARN'),
  securityIPList?: string(name='SecurityIPList'),
  serverlessConfig?: {
    autoPause?: boolean(name='AutoPause'),
    maxCapacity?: double(name='MaxCapacity'),
    minCapacity?: double(name='MinCapacity'),
    switchForce?: boolean(name='SwitchForce'),
  }(name='ServerlessConfig'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storageThreshold?: int32(name='StorageThreshold'),
  storageUpperBound?: int32(name='StorageUpperBound'),
  systemDBCharset?: string(name='SystemDBCharset'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  usedTime?: string(name='UsedTime'),
  userBackupId?: string(name='UserBackupId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
}

model CreateDBInstanceShrinkRequest {
  amount?: int32(name='Amount'),
  autoRenew?: string(name='AutoRenew'),
  babelfishConfig?: string(name='BabelfishConfig'),
  businessInfo?: string(name='BusinessInfo'),
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  connectionMode?: string(name='ConnectionMode'),
  connectionString?: string(name='ConnectionString'),
  createStrategy?: string(name='CreateStrategy'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceNetType?: string(name='DBInstanceNetType'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  DBIsIgnoreCase?: string(name='DBIsIgnoreCase'),
  DBParamGroupId?: string(name='DBParamGroupId'),
  DBTimeZone?: string(name='DBTimeZone'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  dryRun?: boolean(name='DryRun'),
  encryptionKey?: string(name='EncryptionKey'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleARN?: string(name='RoleARN'),
  securityIPList?: string(name='SecurityIPList'),
  serverlessConfigShrink?: string(name='ServerlessConfig'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storageThreshold?: int32(name='StorageThreshold'),
  storageUpperBound?: int32(name='StorageUpperBound'),
  systemDBCharset?: string(name='SystemDBCharset'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  usedTime?: string(name='UsedTime'),
  userBackupId?: string(name='UserBackupId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
}

model CreateDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  dryRun?: boolean(name='DryRun'),
  dryRunResult?: boolean(name='DryRunResult'),
  message?: string(name='Message'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
  tagResult?: boolean(name='TagResult'),
  taskId?: string(name='TaskId'),
}

model CreateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBInstanceResponseBody(name='body'),
}

async function createDBInstanceWithOptions(tmpReq: CreateDBInstanceRequest, runtime: Util.RuntimeOptions): CreateDBInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDBInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serverlessConfig)) {
    request.serverlessConfigShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfig, 'ServerlessConfig', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.amount)) {
    query['Amount'] = request.amount;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.babelfishConfig)) {
    query['BabelfishConfig'] = request.babelfishConfig;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionMode)) {
    query['ConnectionMode'] = request.connectionMode;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.createStrategy)) {
    query['CreateStrategy'] = request.createStrategy;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceNetType)) {
    query['DBInstanceNetType'] = request.DBInstanceNetType;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.DBIsIgnoreCase)) {
    query['DBIsIgnoreCase'] = request.DBIsIgnoreCase;
  }
  if (!Util.isUnset(request.DBParamGroupId)) {
    query['DBParamGroupId'] = request.DBParamGroupId;
  }
  if (!Util.isUnset(request.DBTimeZone)) {
    query['DBTimeZone'] = request.DBTimeZone;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.dryRun)) {
    query['DryRun'] = request.dryRun;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleARN)) {
    query['RoleARN'] = request.roleARN;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.serverlessConfigShrink)) {
    query['ServerlessConfig'] = request.serverlessConfigShrink;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storageThreshold)) {
    query['StorageThreshold'] = request.storageThreshold;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  if (!Util.isUnset(request.systemDBCharset)) {
    query['SystemDBCharset'] = request.systemDBCharset;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForLog)) {
    query['TargetDedicatedHostIdForLog'] = request.targetDedicatedHostIdForLog;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForMaster)) {
    query['TargetDedicatedHostIdForMaster'] = request.targetDedicatedHostIdForMaster;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForSlave)) {
    query['TargetDedicatedHostIdForSlave'] = request.targetDedicatedHostIdForSlave;
  }
  if (!Util.isUnset(request.targetMinorVersion)) {
    query['TargetMinorVersion'] = request.targetMinorVersion;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.userBackupId)) {
    query['UserBackupId'] = request.userBackupId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.zoneIdSlave1)) {
    query['ZoneIdSlave1'] = request.zoneIdSlave1;
  }
  if (!Util.isUnset(request.zoneIdSlave2)) {
    query['ZoneIdSlave2'] = request.zoneIdSlave2;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBInstance(request: CreateDBInstanceRequest): CreateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBInstanceWithOptions(request, runtime);
}

model CreateDBProxyEndpointAddressRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model CreateDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDBProxyEndpointAddressResponseBody(name='body'),
}

async function createDBProxyEndpointAddressWithOptions(request: CreateDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): CreateDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyConnectStringNetType)) {
    query['DBProxyConnectStringNetType'] = request.DBProxyConnectStringNetType;
  }
  if (!Util.isUnset(request.DBProxyEndpointId)) {
    query['DBProxyEndpointId'] = request.DBProxyEndpointId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.DBProxyNewConnectStringPort)) {
    query['DBProxyNewConnectStringPort'] = request.DBProxyNewConnectStringPort;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDBProxyEndpointAddress',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDBProxyEndpointAddress(request: CreateDBProxyEndpointAddressRequest): CreateDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDBProxyEndpointAddressWithOptions(request, runtime);
}

model CreateDatabaseRequest {
  characterSetName?: string(name='CharacterSetName'),
  DBDescription?: string(name='DBDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDatabaseResponseBody(name='body'),
}

async function createDatabaseWithOptions(request: CreateDatabaseRequest, runtime: Util.RuntimeOptions): CreateDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.characterSetName)) {
    query['CharacterSetName'] = request.characterSetName;
  }
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDatabase',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDatabase(request: CreateDatabaseRequest): CreateDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatabaseWithOptions(request, runtime);
}

model CreateDdrInstanceRequest {
  backupSetId?: string(name='BackupSetId'),
  clientToken?: string(name='ClientToken'),
  connectionMode?: string(name='ConnectionMode'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceNetType?: string(name='DBInstanceNetType'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  restoreType?: string(name='RestoreType'),
  securityIPList?: string(name='SecurityIPList'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName'),
  sourceRegion?: string(name='SourceRegion'),
  systemDBCharset?: string(name='SystemDBCharset'),
  usedTime?: string(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CreateDdrInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateDdrInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDdrInstanceResponseBody(name='body'),
}

async function createDdrInstanceWithOptions(request: CreateDdrInstanceRequest, runtime: Util.RuntimeOptions): CreateDdrInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupSetId)) {
    query['BackupSetId'] = request.backupSetId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionMode)) {
    query['ConnectionMode'] = request.connectionMode;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceNetType)) {
    query['DBInstanceNetType'] = request.DBInstanceNetType;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  if (!Util.isUnset(request.securityIPList)) {
    query['SecurityIPList'] = request.securityIPList;
  }
  if (!Util.isUnset(request.sourceDBInstanceName)) {
    query['SourceDBInstanceName'] = request.sourceDBInstanceName;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  if (!Util.isUnset(request.systemDBCharset)) {
    query['SystemDBCharset'] = request.systemDBCharset;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDdrInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDdrInstance(request: CreateDdrInstanceRequest): CreateDdrInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDdrInstanceWithOptions(request, runtime);
}

model CreateDiagnosticReportRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  startTime?: string(name='StartTime'),
}

model CreateDiagnosticReportResponseBody = {
  reportId?: string(name='ReportId'),
  requestId?: string(name='RequestId'),
}

model CreateDiagnosticReportResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDiagnosticReportResponseBody(name='body'),
}

async function createDiagnosticReportWithOptions(request: CreateDiagnosticReportRequest, runtime: Util.RuntimeOptions): CreateDiagnosticReportResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateDiagnosticReport',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDiagnosticReport(request: CreateDiagnosticReportRequest): CreateDiagnosticReportResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDiagnosticReportWithOptions(request, runtime);
}

model CreateGADInstanceRequest {
  centralDBInstanceId?: string(name='CentralDBInstanceId'),
  centralRdsDtsAdminAccount?: string(name='CentralRdsDtsAdminAccount'),
  centralRdsDtsAdminPassword?: string(name='CentralRdsDtsAdminPassword'),
  centralRegionId?: string(name='CentralRegionId'),
  DBList?: string(name='DBList'),
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  unitNode?: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceStorage?: long(name='DBInstanceStorage'),
      dbInstanceClass?: string(name='DbInstanceClass'),
      dtsConflict?: string(name='DtsConflict'),
      dtsInstanceClass?: string(name='DtsInstanceClass'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      payType?: string(name='PayType'),
      regionID?: string(name='RegionID'),
      securityIPList?: string(name='SecurityIPList'),
      vSwitchID?: string(name='VSwitchID'),
      vpcID?: string(name='VpcID'),
      zoneID?: string(name='ZoneID'),
      zoneIDSlave1?: string(name='ZoneIDSlave1'),
      zoneIDSlave2?: string(name='ZoneIDSlave2'),
    }
  ](name='UnitNode'),
}

model CreateGADInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createMemberCount?: string(name='CreateMemberCount'),
    gadInstanceName?: string(name='GadInstanceName'),
    taskID?: string(name='TaskID'),
  }(name='Result'),
}

model CreateGADInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGADInstanceResponseBody(name='body'),
}

async function createGADInstanceWithOptions(request: CreateGADInstanceRequest, runtime: Util.RuntimeOptions): CreateGADInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.centralDBInstanceId)) {
    query['CentralDBInstanceId'] = request.centralDBInstanceId;
  }
  if (!Util.isUnset(request.centralRdsDtsAdminAccount)) {
    query['CentralRdsDtsAdminAccount'] = request.centralRdsDtsAdminAccount;
  }
  if (!Util.isUnset(request.centralRdsDtsAdminPassword)) {
    query['CentralRdsDtsAdminPassword'] = request.centralRdsDtsAdminPassword;
  }
  if (!Util.isUnset(request.centralRegionId)) {
    query['CentralRegionId'] = request.centralRegionId;
  }
  if (!Util.isUnset(request.DBList)) {
    query['DBList'] = request.DBList;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.unitNode)) {
    query['UnitNode'] = request.unitNode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGADInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGADInstance(request: CreateGADInstanceRequest): CreateGADInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGADInstanceWithOptions(request, runtime);
}

model CreateGadInstanceMemberRequest {
  centralDBInstanceId?: string(name='CentralDBInstanceId'),
  centralRdsDtsAdminAccount?: string(name='CentralRdsDtsAdminAccount'),
  centralRdsDtsAdminPassword?: string(name='CentralRdsDtsAdminPassword'),
  centralRegionId?: string(name='CentralRegionId'),
  DBList?: string(name='DBList'),
  gadInstanceId?: string(name='GadInstanceId'),
  unitNode?: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceStorage?: long(name='DBInstanceStorage'),
      dbInstanceClass?: string(name='DbInstanceClass'),
      dtsConflict?: string(name='DtsConflict'),
      dtsInstanceClass?: string(name='DtsInstanceClass'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      regionID?: string(name='RegionID'),
      securityIPList?: string(name='SecurityIPList'),
      vSwitchID?: string(name='VSwitchID'),
      vpcID?: string(name='VpcID'),
      zoneID?: string(name='ZoneID'),
      zoneIDSlave1?: string(name='ZoneIDSlave1'),
      zoneIDSlave2?: string(name='ZoneIDSlave2'),
    }
  ](name='UnitNode'),
}

model CreateGadInstanceMemberResponseBody = {
  requestId?: string(name='RequestId'),
  result?: {
    createCount?: string(name='CreateCount'),
    gadInstanceName?: string(name='GadInstanceName'),
  }(name='Result'),
}

model CreateGadInstanceMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateGadInstanceMemberResponseBody(name='body'),
}

async function createGadInstanceMemberWithOptions(request: CreateGadInstanceMemberRequest, runtime: Util.RuntimeOptions): CreateGadInstanceMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.centralDBInstanceId)) {
    query['CentralDBInstanceId'] = request.centralDBInstanceId;
  }
  if (!Util.isUnset(request.centralRdsDtsAdminAccount)) {
    query['CentralRdsDtsAdminAccount'] = request.centralRdsDtsAdminAccount;
  }
  if (!Util.isUnset(request.centralRdsDtsAdminPassword)) {
    query['CentralRdsDtsAdminPassword'] = request.centralRdsDtsAdminPassword;
  }
  if (!Util.isUnset(request.centralRegionId)) {
    query['CentralRegionId'] = request.centralRegionId;
  }
  if (!Util.isUnset(request.DBList)) {
    query['DBList'] = request.DBList;
  }
  if (!Util.isUnset(request.gadInstanceId)) {
    query['GadInstanceId'] = request.gadInstanceId;
  }
  if (!Util.isUnset(request.unitNode)) {
    query['UnitNode'] = request.unitNode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateGadInstanceMember',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createGadInstanceMember(request: CreateGadInstanceMemberRequest): CreateGadInstanceMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return createGadInstanceMemberWithOptions(request, runtime);
}

model CreateMigrateTaskRequest {
  backupMode?: string(name='BackupMode'),
  checkDBMode?: string(name='CheckDBMode'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  isOnlineDB?: string(name='IsOnlineDB'),
  migrateTaskId?: string(name='MigrateTaskId'),
  OSSUrls?: string(name='OSSUrls'),
  ossObjectPositions?: string(name='OssObjectPositions'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateMigrateTaskResponseBody = {
  backupMode?: string(name='BackupMode'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateMigrateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMigrateTaskResponseBody(name='body'),
}

async function createMigrateTaskWithOptions(request: CreateMigrateTaskRequest, runtime: Util.RuntimeOptions): CreateMigrateTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.checkDBMode)) {
    query['CheckDBMode'] = request.checkDBMode;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.isOnlineDB)) {
    query['IsOnlineDB'] = request.isOnlineDB;
  }
  if (!Util.isUnset(request.migrateTaskId)) {
    query['MigrateTaskId'] = request.migrateTaskId;
  }
  if (!Util.isUnset(request.OSSUrls)) {
    query['OSSUrls'] = request.OSSUrls;
  }
  if (!Util.isUnset(request.ossObjectPositions)) {
    query['OssObjectPositions'] = request.ossObjectPositions;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateMigrateTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMigrateTask(request: CreateMigrateTaskRequest): CreateMigrateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMigrateTaskWithOptions(request, runtime);
}

model CreateOnlineDatabaseTaskRequest {
  checkDBMode?: string(name='CheckDBMode'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  migrateTaskId?: string(name='MigrateTaskId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateOnlineDatabaseTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateOnlineDatabaseTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOnlineDatabaseTaskResponseBody(name='body'),
}

async function createOnlineDatabaseTaskWithOptions(request: CreateOnlineDatabaseTaskRequest, runtime: Util.RuntimeOptions): CreateOnlineDatabaseTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.checkDBMode)) {
    query['CheckDBMode'] = request.checkDBMode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.migrateTaskId)) {
    query['MigrateTaskId'] = request.migrateTaskId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateOnlineDatabaseTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOnlineDatabaseTask(request: CreateOnlineDatabaseTaskRequest): CreateOnlineDatabaseTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOnlineDatabaseTaskWithOptions(request, runtime);
}

model CreateParameterGroupRequest {
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  ownerId?: long(name='OwnerId'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
  parameterGroupName?: string(name='ParameterGroupName'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateParameterGroupResponseBody(name='body'),
}

async function createParameterGroupWithOptions(request: CreateParameterGroupRequest, runtime: Util.RuntimeOptions): CreateParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupDesc)) {
    query['ParameterGroupDesc'] = request.parameterGroupDesc;
  }
  if (!Util.isUnset(request.parameterGroupName)) {
    query['ParameterGroupName'] = request.parameterGroupName;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateParameterGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createParameterGroup(request: CreateParameterGroupRequest): CreateParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createParameterGroupWithOptions(request, runtime);
}

model CreateReadOnlyDBInstanceRequest {
  autoRenew?: string(name='AutoRenew'),
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  engineVersion?: string(name='EngineVersion'),
  gdnInstanceName?: string(name='GdnInstanceName'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  instructionSetArch?: string(name='InstructionSetArch'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  tddlBizType?: string(name='TddlBizType'),
  tddlRegionConfig?: string(name='TddlRegionConfig'),
  usedTime?: string(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CreateReadOnlyDBInstanceResponseBody = {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  port?: string(name='Port'),
  requestId?: string(name='RequestId'),
}

model CreateReadOnlyDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateReadOnlyDBInstanceResponseBody(name='body'),
}

async function createReadOnlyDBInstanceWithOptions(request: CreateReadOnlyDBInstanceRequest, runtime: Util.RuntimeOptions): CreateReadOnlyDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.gdnInstanceName)) {
    query['GdnInstanceName'] = request.gdnInstanceName;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.instructionSetArch)) {
    query['InstructionSetArch'] = request.instructionSetArch;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForMaster)) {
    query['TargetDedicatedHostIdForMaster'] = request.targetDedicatedHostIdForMaster;
  }
  if (!Util.isUnset(request.tddlBizType)) {
    query['TddlBizType'] = request.tddlBizType;
  }
  if (!Util.isUnset(request.tddlRegionConfig)) {
    query['TddlRegionConfig'] = request.tddlRegionConfig;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateReadOnlyDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createReadOnlyDBInstance(request: CreateReadOnlyDBInstanceRequest): CreateReadOnlyDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReadOnlyDBInstanceWithOptions(request, runtime);
}

model CreateSecretRequest {
  clientToken?: string(name='ClientToken'),
  dbInstanceId?: string(name='DbInstanceId'),
  dbNames?: string(name='DbNames'),
  description?: string(name='Description'),
  engine?: string(name='Engine'),
  ownerId?: long(name='OwnerId'),
  password?: string(name='Password'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secretName?: string(name='SecretName'),
  username?: string(name='Username'),
}

model CreateSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretArn?: string(name='SecretArn'),
  secretName?: string(name='SecretName'),
  success?: boolean(name='Success'),
}

model CreateSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSecretResponseBody(name='body'),
}

async function createSecretWithOptions(request: CreateSecretRequest, runtime: Util.RuntimeOptions): CreateSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.dbNames)) {
    query['DbNames'] = request.dbNames;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateSecret',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSecret(request: CreateSecretRequest): CreateSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSecretWithOptions(request, runtime);
}

model CreateServiceLinkedRoleRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serviceLinkedRole?: string(name='ServiceLinkedRole'),
}

model CreateServiceLinkedRoleResponseBody = {
  requestId?: string(name='RequestId'),
}

model CreateServiceLinkedRoleResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateServiceLinkedRoleResponseBody(name='body'),
}

async function createServiceLinkedRoleWithOptions(request: CreateServiceLinkedRoleRequest, runtime: Util.RuntimeOptions): CreateServiceLinkedRoleResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serviceLinkedRole)) {
    query['ServiceLinkedRole'] = request.serviceLinkedRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateServiceLinkedRole',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createServiceLinkedRole(request: CreateServiceLinkedRoleRequest): CreateServiceLinkedRoleResponse {
  var runtime = new Util.RuntimeOptions{};
  return createServiceLinkedRoleWithOptions(request, runtime);
}

model CreateTempDBInstanceRequest {
  backupId?: int32(name='BackupId'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
}

model CreateTempDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  tempDBInstanceId?: string(name='TempDBInstanceId'),
}

model CreateTempDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTempDBInstanceResponseBody(name='body'),
}

async function createTempDBInstanceWithOptions(request: CreateTempDBInstanceRequest, runtime: Util.RuntimeOptions): CreateTempDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTempDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTempDBInstance(request: CreateTempDBInstanceRequest): CreateTempDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTempDBInstanceWithOptions(request, runtime);
}

model DeleteADSettingRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteADSettingResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteADSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteADSettingResponseBody(name='body'),
}

async function deleteADSettingWithOptions(request: DeleteADSettingRequest, runtime: Util.RuntimeOptions): DeleteADSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteADSetting',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteADSetting(request: DeleteADSettingRequest): DeleteADSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteADSettingWithOptions(request, runtime);
}

model DeleteAccountRequest {
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteAccountResponseBody(name='body'),
}

async function deleteAccountWithOptions(request: DeleteAccountRequest, runtime: Util.RuntimeOptions): DeleteAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteAccount',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteAccount(request: DeleteAccountRequest): DeleteAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteAccountWithOptions(request, runtime);
}

model DeleteBackupRequest {
  backupId?: string(name='BackupId'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBackupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteBackupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupResponseBody(name='body'),
}

async function deleteBackupWithOptions(request: DeleteBackupRequest, runtime: Util.RuntimeOptions): DeleteBackupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackup(request: DeleteBackupRequest): DeleteBackupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupWithOptions(request, runtime);
}

model DeleteBackupFileRequest {
  backupId?: string(name='BackupId'),
  backupTime?: string(name='BackupTime'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteBackupFileResponseBody = {
  deletedBaksetIds?: {
    deletedBaksetIds?: [ int32 ](name='DeletedBaksetIds')
  }(name='DeletedBaksetIds'),
  requestId?: string(name='RequestId'),
}

model DeleteBackupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupFileResponseBody(name='body'),
}

async function deleteBackupFileWithOptions(request: DeleteBackupFileRequest, runtime: Util.RuntimeOptions): DeleteBackupFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupTime)) {
    query['BackupTime'] = request.backupTime;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupFile',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupFile(request: DeleteBackupFileRequest): DeleteBackupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupFileWithOptions(request, runtime);
}

model DeleteDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDBInstanceResponseBody = {
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DeleteDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBInstanceResponseBody(name='body'),
}

async function deleteDBInstanceWithOptions(request: DeleteDBInstanceRequest, runtime: Util.RuntimeOptions): DeleteDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.releasedKeepPolicy)) {
    query['ReleasedKeepPolicy'] = request.releasedKeepPolicy;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBInstance(request: DeleteDBInstanceRequest): DeleteDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBInstanceWithOptions(request, runtime);
}

model DeleteDBProxyEndpointAddressRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  regionId?: string(name='RegionId'),
}

model DeleteDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDBProxyEndpointAddressResponseBody(name='body'),
}

async function deleteDBProxyEndpointAddressWithOptions(request: DeleteDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): DeleteDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyConnectStringNetType)) {
    query['DBProxyConnectStringNetType'] = request.DBProxyConnectStringNetType;
  }
  if (!Util.isUnset(request.DBProxyEndpointId)) {
    query['DBProxyEndpointId'] = request.DBProxyEndpointId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDBProxyEndpointAddress',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDBProxyEndpointAddress(request: DeleteDBProxyEndpointAddressRequest): DeleteDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDBProxyEndpointAddressWithOptions(request, runtime);
}

model DeleteDatabaseRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteDatabaseResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDatabaseResponseBody(name='body'),
}

async function deleteDatabaseWithOptions(request: DeleteDatabaseRequest, runtime: Util.RuntimeOptions): DeleteDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDatabase',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDatabase(request: DeleteDatabaseRequest): DeleteDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDatabaseWithOptions(request, runtime);
}

model DeleteGadInstanceRequest {
  gadInstanceName?: string(name='GadInstanceName'),
  regionId?: string(name='RegionId'),
}

model DeleteGadInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteGadInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteGadInstanceResponseBody(name='body'),
}

async function deleteGadInstanceWithOptions(request: DeleteGadInstanceRequest, runtime: Util.RuntimeOptions): DeleteGadInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gadInstanceName)) {
    query['GadInstanceName'] = request.gadInstanceName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteGadInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteGadInstance(request: DeleteGadInstanceRequest): DeleteGadInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteGadInstanceWithOptions(request, runtime);
}

model DeleteParameterGroupRequest {
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model DeleteParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteParameterGroupResponseBody(name='body'),
}

async function deleteParameterGroupWithOptions(request: DeleteParameterGroupRequest, runtime: Util.RuntimeOptions): DeleteParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteParameterGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteParameterGroup(request: DeleteParameterGroupRequest): DeleteParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteParameterGroupWithOptions(request, runtime);
}

model DeleteSecretRequest {
  clientToken?: string(name='ClientToken'),
  dbInstanceId?: string(name='DbInstanceId'),
  engine?: string(name='Engine'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  secretArn?: string(name='SecretArn'),
  secretName?: string(name='SecretName'),
}

model DeleteSecretResponseBody = {
  requestId?: string(name='RequestId'),
  secretArn?: string(name='SecretArn'),
  secretName?: string(name='SecretName'),
  success?: boolean(name='Success'),
}

model DeleteSecretResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSecretResponseBody(name='body'),
}

async function deleteSecretWithOptions(request: DeleteSecretRequest, runtime: Util.RuntimeOptions): DeleteSecretResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.secretArn)) {
    query['SecretArn'] = request.secretArn;
  }
  if (!Util.isUnset(request.secretName)) {
    query['SecretName'] = request.secretName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSecret',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSecret(request: DeleteSecretRequest): DeleteSecretResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSecretWithOptions(request, runtime);
}

model DeleteUserBackupFileRequest {
  backupId?: string(name='BackupId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
}

model DeleteUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUserBackupFileResponseBody(name='body'),
}

async function deleteUserBackupFileWithOptions(request: DeleteUserBackupFileRequest, runtime: Util.RuntimeOptions): DeleteUserBackupFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUserBackupFile',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUserBackupFile(request: DeleteUserBackupFileRequest): DeleteUserBackupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUserBackupFileWithOptions(request, runtime);
}

model DescibeImportsFromDatabaseRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  importId?: int32(name='ImportId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescibeImportsFromDatabaseResponseBody = {
  items?: {
    importResultFromDB?: [ 
    {
      importDataStatus?: string(name='ImportDataStatus'),
      importDataStatusDescription?: string(name='ImportDataStatusDescription'),
      importDataType?: string(name='ImportDataType'),
      importId?: int32(name='ImportId'),
      incrementalImportingTime?: string(name='IncrementalImportingTime'),
    }
  ](name='ImportResultFromDB')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescibeImportsFromDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescibeImportsFromDatabaseResponseBody(name='body'),
}

async function descibeImportsFromDatabaseWithOptions(request: DescibeImportsFromDatabaseRequest, runtime: Util.RuntimeOptions): DescibeImportsFromDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.importId)) {
    query['ImportId'] = request.importId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescibeImportsFromDatabase',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function descibeImportsFromDatabase(request: DescibeImportsFromDatabaseRequest): DescibeImportsFromDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return descibeImportsFromDatabaseWithOptions(request, runtime);
}

model DescribeADInfoRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeADInfoResponseBody = {
  ADDNS?: string(name='ADDNS'),
  ADServerIpAddress?: string(name='ADServerIpAddress'),
  ADStatus?: string(name='ADStatus'),
  abnormalReason?: string(name='AbnormalReason'),
  requestId?: string(name='RequestId'),
  userName?: string(name='UserName'),
}

model DescribeADInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeADInfoResponseBody(name='body'),
}

async function describeADInfoWithOptions(request: DescribeADInfoRequest, runtime: Util.RuntimeOptions): DescribeADInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeADInfo',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeADInfo(request: DescribeADInfoRequest): DescribeADInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeADInfoWithOptions(request, runtime);
}

model DescribeAccountsRequest {
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAccountsResponseBody = {
  accounts?: {
    DBInstanceAccount?: [ 
    {
      accountDescription?: string(name='AccountDescription'),
      accountName?: string(name='AccountName'),
      accountStatus?: string(name='AccountStatus'),
      accountType?: string(name='AccountType'),
      bypassRLS?: string(name='BypassRLS'),
      createDB?: string(name='CreateDB'),
      createRole?: string(name='CreateRole'),
      DBInstanceId?: string(name='DBInstanceId'),
      databasePrivileges?: {
        databasePrivilege?: [ 
        {
          accountPrivilege?: string(name='AccountPrivilege'),
          accountPrivilegeDetail?: string(name='AccountPrivilegeDetail'),
          DBName?: string(name='DBName'),
        }
      ](name='DatabasePrivilege')
      }(name='DatabasePrivileges'),
      privExceeded?: string(name='PrivExceeded'),
      replication?: string(name='Replication'),
      validUntil?: string(name='ValidUntil'),
    }
  ](name='DBInstanceAccount')
  }(name='Accounts'),
  pageNumber?: int32(name='PageNumber'),
  requestId?: string(name='RequestId'),
  systemAdminAccountFirstActivationTime?: string(name='SystemAdminAccountFirstActivationTime'),
  systemAdminAccountStatus?: string(name='SystemAdminAccountStatus'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAccountsResponseBody(name='body'),
}

async function describeAccountsWithOptions(request: DescribeAccountsRequest, runtime: Util.RuntimeOptions): DescribeAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAccounts',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAccounts(request: DescribeAccountsRequest): DescribeAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAccountsWithOptions(request, runtime);
}

model DescribeActionEventPolicyRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeActionEventPolicyResponseBody = {
  enableEventLog?: string(name='EnableEventLog'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeActionEventPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeActionEventPolicyResponseBody(name='body'),
}

async function describeActionEventPolicyWithOptions(request: DescribeActionEventPolicyRequest, runtime: Util.RuntimeOptions): DescribeActionEventPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeActionEventPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeActionEventPolicy(request: DescribeActionEventPolicyRequest): DescribeActionEventPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeActionEventPolicyWithOptions(request, runtime);
}

model DescribeAnalyticdbByPrimaryDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAnalyticdbByPrimaryDBInstanceResponseBody = {
  analyticDBCount?: int32(name='AnalyticDBCount'),
  requestId?: string(name='RequestId'),
}

model DescribeAnalyticdbByPrimaryDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAnalyticdbByPrimaryDBInstanceResponseBody(name='body'),
}

async function describeAnalyticdbByPrimaryDBInstanceWithOptions(request: DescribeAnalyticdbByPrimaryDBInstanceRequest, runtime: Util.RuntimeOptions): DescribeAnalyticdbByPrimaryDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAnalyticdbByPrimaryDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAnalyticdbByPrimaryDBInstance(request: DescribeAnalyticdbByPrimaryDBInstanceRequest): DescribeAnalyticdbByPrimaryDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAnalyticdbByPrimaryDBInstanceWithOptions(request, runtime);
}

model DescribeAvailableClassesRequest {
  category?: string(name='Category'),
  commodityCode?: string(name='CommodityCode'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  instanceChargeType?: string(name='InstanceChargeType'),
  orderType?: string(name='OrderType'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeAvailableClassesResponseBody = {
  DBInstanceClasses?: [ 
    {
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceStorageRange?: {
        maxValue?: int32(name='MaxValue'),
        minValue?: int32(name='MinValue'),
        step?: int32(name='Step'),
      }(name='DBInstanceStorageRange'),
    }
  ](name='DBInstanceClasses'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableClassesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableClassesResponseBody(name='body'),
}

async function describeAvailableClassesWithOptions(request: DescribeAvailableClassesRequest, runtime: Util.RuntimeOptions): DescribeAvailableClassesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.instanceChargeType)) {
    query['InstanceChargeType'] = request.instanceChargeType;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableClasses',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableClasses(request: DescribeAvailableClassesRequest): DescribeAvailableClassesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableClassesWithOptions(request, runtime);
}

model DescribeAvailableCrossRegionRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAvailableCrossRegionResponseBody = {
  regions?: {
    region?: [ string ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableCrossRegionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableCrossRegionResponseBody(name='body'),
}

async function describeAvailableCrossRegionWithOptions(request: DescribeAvailableCrossRegionRequest, runtime: Util.RuntimeOptions): DescribeAvailableCrossRegionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableCrossRegion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableCrossRegion(request: DescribeAvailableCrossRegionRequest): DescribeAvailableCrossRegionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableCrossRegionWithOptions(request, runtime);
}

model DescribeAvailableMetricsRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAvailableMetricsResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: [ 
    {
      description?: string(name='Description'),
      dimension?: string(name='Dimension'),
      groupKey?: string(name='GroupKey'),
      groupKeyType?: string(name='GroupKeyType'),
      method?: string(name='Method'),
      metricsKey?: string(name='MetricsKey'),
      metricsKeyAlias?: string(name='MetricsKeyAlias'),
      sortRule?: int32(name='SortRule'),
      unit?: string(name='Unit'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeAvailableMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableMetricsResponseBody(name='body'),
}

async function describeAvailableMetricsWithOptions(request: DescribeAvailableMetricsRequest, runtime: Util.RuntimeOptions): DescribeAvailableMetricsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableMetrics',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableMetrics(request: DescribeAvailableMetricsRequest): DescribeAvailableMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableMetricsWithOptions(request, runtime);
}

model DescribeAvailableRecoveryTimeRequest {
  crossBackupId?: int32(name='CrossBackupId'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeAvailableRecoveryTimeResponseBody = {
  crossBackupId?: int32(name='CrossBackupId'),
  recoveryBeginTime?: string(name='RecoveryBeginTime'),
  recoveryEndTime?: string(name='RecoveryEndTime'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableRecoveryTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableRecoveryTimeResponseBody(name='body'),
}

async function describeAvailableRecoveryTimeWithOptions(request: DescribeAvailableRecoveryTimeRequest, runtime: Util.RuntimeOptions): DescribeAvailableRecoveryTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.crossBackupId)) {
    query['CrossBackupId'] = request.crossBackupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableRecoveryTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableRecoveryTime(request: DescribeAvailableRecoveryTimeRequest): DescribeAvailableRecoveryTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableRecoveryTimeWithOptions(request, runtime);
}

model DescribeAvailableZonesRequest {
  category?: string(name='Category'),
  commodityCode?: string(name='CommodityCode'),
  DBInstanceName?: string(name='DBInstanceName'),
  dispenseMode?: string(name='DispenseMode'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeAvailableZonesResponseBody = {
  availableZones?: [ 
    {
      regionId?: string(name='RegionId'),
      supportedEngines?: [ 
        {
          engine?: string(name='Engine'),
          supportedEngineVersions?: [ 
            {
              supportedCategorys?: [ 
                {
                  category?: string(name='Category'),
                  supportedStorageTypes?: [ 
                    {
                      storageType?: string(name='StorageType'),
                    }
                  ](name='SupportedStorageTypes'),
                }
              ](name='SupportedCategorys'),
              version?: string(name='Version'),
            }
          ](name='SupportedEngineVersions'),
        }
      ](name='SupportedEngines'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableZonesResponseBody(name='body'),
}

async function describeAvailableZonesWithOptions(request: DescribeAvailableZonesRequest, runtime: Util.RuntimeOptions): DescribeAvailableZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.dispenseMode)) {
    query['DispenseMode'] = request.dispenseMode;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableZones',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableZones(request: DescribeAvailableZonesRequest): DescribeAvailableZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableZonesWithOptions(request, runtime);
}

model DescribeBackupDatabaseRequest {
  backupId?: string(name='BackupId'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupDatabaseResponseBody = {
  databaseNames?: string(name='DatabaseNames'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupDatabaseResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupDatabaseResponseBody(name='body'),
}

async function describeBackupDatabaseWithOptions(request: DescribeBackupDatabaseRequest, runtime: Util.RuntimeOptions): DescribeBackupDatabaseResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupDatabase',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupDatabase(request: DescribeBackupDatabaseRequest): DescribeBackupDatabaseResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupDatabaseWithOptions(request, runtime);
}

model DescribeBackupPolicyRequest {
  backupPolicyMode?: string(name='BackupPolicyMode'),
  compressType?: string(name='CompressType'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupPolicyResponseBody = {
  archiveBackupKeepCount?: string(name='ArchiveBackupKeepCount'),
  archiveBackupKeepPolicy?: string(name='ArchiveBackupKeepPolicy'),
  archiveBackupRetentionPeriod?: string(name='ArchiveBackupRetentionPeriod'),
  backupInterval?: string(name='BackupInterval'),
  backupLog?: string(name='BackupLog'),
  backupMethod?: string(name='BackupMethod'),
  backupRetentionPeriod?: int32(name='BackupRetentionPeriod'),
  category?: string(name='Category'),
  compressType?: string(name='CompressType'),
  enableBackupLog?: string(name='EnableBackupLog'),
  enableIncrementDataBackup?: boolean(name='EnableIncrementDataBackup'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  localLogRetentionHours?: int32(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  logBackupFrequency?: string(name='LogBackupFrequency'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber'),
  logBackupRetentionPeriod?: int32(name='LogBackupRetentionPeriod'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  preferredNextBackupTime?: string(name='PreferredNextBackupTime'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  requestId?: string(name='RequestId'),
  supportReleasedKeep?: int32(name='SupportReleasedKeep'),
  supportVolumeShadowCopy?: int32(name='SupportVolumeShadowCopy'),
}

model DescribeBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPolicyResponseBody(name='body'),
}

async function describeBackupPolicyWithOptions(request: DescribeBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupPolicyMode)) {
    query['BackupPolicyMode'] = request.backupPolicyMode;
  }
  if (!Util.isUnset(request.compressType)) {
    query['CompressType'] = request.compressType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.releasedKeepPolicy)) {
    query['ReleasedKeepPolicy'] = request.releasedKeepPolicy;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPolicy(request: DescribeBackupPolicyRequest): DescribeBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPolicyWithOptions(request, runtime);
}

model DescribeBackupTasksRequest {
  backupJobId?: int32(name='BackupJobId'),
  backupJobStatus?: string(name='BackupJobStatus'),
  backupMode?: string(name='BackupMode'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  flag?: string(name='Flag'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeBackupTasksResponseBody = {
  items?: {
    backupJob?: [ 
    {
      backupId?: string(name='BackupId'),
      backupJobId?: string(name='BackupJobId'),
      backupProgressStatus?: string(name='BackupProgressStatus'),
      backupStatus?: string(name='BackupStatus'),
      jobMode?: string(name='JobMode'),
      process?: string(name='Process'),
      taskAction?: string(name='TaskAction'),
    }
  ](name='BackupJob')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeBackupTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupTasksResponseBody(name='body'),
}

async function describeBackupTasksWithOptions(request: DescribeBackupTasksRequest, runtime: Util.RuntimeOptions): DescribeBackupTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupJobId)) {
    query['BackupJobId'] = request.backupJobId;
  }
  if (!Util.isUnset(request.backupJobStatus)) {
    query['BackupJobStatus'] = request.backupJobStatus;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.flag)) {
    query['Flag'] = request.flag;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupTasks',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupTasks(request: DescribeBackupTasksRequest): DescribeBackupTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupTasksWithOptions(request, runtime);
}

model DescribeBackupsRequest {
  backupId?: string(name='BackupId'),
  backupMode?: string(name='BackupMode'),
  backupStatus?: string(name='BackupStatus'),
  backupType?: string(name='BackupType'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupDownloadLinkByDB?: {
        backupDownloadLinkByDB?: [ 
        {
          dataBase?: string(name='DataBase'),
          downloadLink?: string(name='DownloadLink'),
          intranetDownloadLink?: string(name='IntranetDownloadLink'),
        }
      ](name='BackupDownloadLinkByDB')
      }(name='BackupDownloadLinkByDB'),
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupId?: string(name='BackupId'),
      backupInitiator?: string(name='BackupInitiator'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
      checksum?: string(name='Checksum'),
      consistentTime?: long(name='ConsistentTime'),
      copyOnlyBackup?: string(name='CopyOnlyBackup'),
      DBInstanceId?: string(name='DBInstanceId'),
      encryption?: string(name='Encryption'),
      hostInstanceID?: string(name='HostInstanceID'),
      isAvail?: int32(name='IsAvail'),
      metaStatus?: string(name='MetaStatus'),
      resourceGroupId?: string(name='ResourceGroupId'),
      storageClass?: string(name='StorageClass'),
      storeStatus?: string(name='StoreStatus'),
    }
  ](name='Backup')
  }(name='Items'),
  pageNumber?: string(name='PageNumber'),
  pageRecordCount?: string(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalEcsSnapshotSize?: long(name='TotalEcsSnapshotSize'),
  totalRecordCount?: string(name='TotalRecordCount'),
}

model DescribeBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupsResponseBody(name='body'),
}

async function describeBackupsWithOptions(request: DescribeBackupsRequest, runtime: Util.RuntimeOptions): DescribeBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackups',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackups(request: DescribeBackupsRequest): DescribeBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupsWithOptions(request, runtime);
}

model DescribeBinlogFilesRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeBinlogFilesResponseBody = {
  items?: {
    binLogFile?: [ 
    {
      checksum?: string(name='Checksum'),
      downloadLink?: string(name='DownloadLink'),
      fileSize?: long(name='FileSize'),
      hostInstanceID?: string(name='HostInstanceID'),
      intranetDownloadLink?: string(name='IntranetDownloadLink'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
      logFileName?: string(name='LogFileName'),
      remoteStatus?: string(name='RemoteStatus'),
    }
  ](name='BinLogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalFileSize?: long(name='TotalFileSize'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeBinlogFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBinlogFilesResponseBody(name='body'),
}

async function describeBinlogFilesWithOptions(request: DescribeBinlogFilesRequest, runtime: Util.RuntimeOptions): DescribeBinlogFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBinlogFiles',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBinlogFiles(request: DescribeBinlogFilesRequest): DescribeBinlogFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBinlogFilesWithOptions(request, runtime);
}

model DescribeCharacterSetNameRequest {
  engine?: string(name='Engine'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCharacterSetNameResponseBody = {
  characterSetNameItems?: {
    characterSetName?: [ string ](name='CharacterSetName')
  }(name='CharacterSetNameItems'),
  engine?: string(name='Engine'),
  requestId?: string(name='RequestId'),
}

model DescribeCharacterSetNameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCharacterSetNameResponseBody(name='body'),
}

async function describeCharacterSetNameWithOptions(request: DescribeCharacterSetNameRequest, runtime: Util.RuntimeOptions): DescribeCharacterSetNameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCharacterSetName',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCharacterSetName(request: DescribeCharacterSetNameRequest): DescribeCharacterSetNameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCharacterSetNameWithOptions(request, runtime);
}

model DescribeCloudMigrationPrecheckResultRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePort?: long(name='SourcePort'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model DescribeCloudMigrationPrecheckResultResponseBody = {
  items?: [ 
    {
      detail?: string(name='Detail'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      sourceAccount?: string(name='SourceAccount'),
      sourceCategory?: string(name='SourceCategory'),
      sourceIpAddress?: string(name='SourceIpAddress'),
      sourcePassword?: string(name='SourcePassword'),
      sourcePort?: long(name='SourcePort'),
      targetEip?: string(name='TargetEip'),
      targetInstanceName?: string(name='TargetInstanceName'),
      taskId?: long(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Items'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
}

model DescribeCloudMigrationPrecheckResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCloudMigrationPrecheckResultResponseBody(name='body'),
}

async function describeCloudMigrationPrecheckResultWithOptions(request: DescribeCloudMigrationPrecheckResultRequest, runtime: Util.RuntimeOptions): DescribeCloudMigrationPrecheckResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  if (!Util.isUnset(request.sourcePort)) {
    query['SourcePort'] = request.sourcePort;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudMigrationPrecheckResult',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudMigrationPrecheckResult(request: DescribeCloudMigrationPrecheckResultRequest): DescribeCloudMigrationPrecheckResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudMigrationPrecheckResultWithOptions(request, runtime);
}

model DescribeCloudMigrationResultRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceIpAddress?: string(name='SourceIpAddress'),
  sourcePort?: long(name='SourcePort'),
  taskId?: long(name='TaskId'),
  taskName?: string(name='TaskName'),
}

model DescribeCloudMigrationResultResponseBody = {
  items?: [ 
    {
      detail?: string(name='Detail'),
      gmtCreated?: string(name='GmtCreated'),
      gmtModified?: string(name='GmtModified'),
      migrateStage?: string(name='MigrateStage'),
      replicationInfo?: string(name='ReplicationInfo'),
      replicationState?: string(name='ReplicationState'),
      sourceAccount?: string(name='SourceAccount'),
      sourceCategory?: string(name='SourceCategory'),
      sourceIpAddress?: string(name='SourceIpAddress'),
      sourcePassword?: string(name='SourcePassword'),
      sourcePort?: long(name='SourcePort'),
      switchTime?: string(name='SwitchTime'),
      targetEip?: string(name='TargetEip'),
      targetInstanceName?: string(name='TargetInstanceName'),
      taskId?: long(name='TaskId'),
      taskName?: string(name='TaskName'),
    }
  ](name='Items'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalSize?: int32(name='TotalSize'),
}

model DescribeCloudMigrationResultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCloudMigrationResultResponseBody(name='body'),
}

async function describeCloudMigrationResultWithOptions(request: DescribeCloudMigrationResultRequest, runtime: Util.RuntimeOptions): DescribeCloudMigrationResultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceIpAddress)) {
    query['SourceIpAddress'] = request.sourceIpAddress;
  }
  if (!Util.isUnset(request.sourcePort)) {
    query['SourcePort'] = request.sourcePort;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.taskName)) {
    query['TaskName'] = request.taskName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCloudMigrationResult',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCloudMigrationResult(request: DescribeCloudMigrationResultRequest): DescribeCloudMigrationResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCloudMigrationResultWithOptions(request, runtime);
}

model DescribeCollationTimeZonesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCollationTimeZonesResponseBody = {
  collationTimeZones?: {
    collationTimeZone?: [ 
    {
      description?: string(name='Description'),
      standardTimeOffset?: string(name='StandardTimeOffset'),
      timeZone?: string(name='TimeZone'),
    }
  ](name='CollationTimeZone')
  }(name='CollationTimeZones'),
  requestId?: string(name='RequestId'),
}

model DescribeCollationTimeZonesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCollationTimeZonesResponseBody(name='body'),
}

async function describeCollationTimeZonesWithOptions(request: DescribeCollationTimeZonesRequest, runtime: Util.RuntimeOptions): DescribeCollationTimeZonesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCollationTimeZones',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCollationTimeZones(request: DescribeCollationTimeZonesRequest): DescribeCollationTimeZonesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCollationTimeZonesWithOptions(request, runtime);
}

model DescribeCrossBackupMetaListRequest {
  backupSetId?: string(name='BackupSetId'),
  getDbName?: string(name='GetDbName'),
  ownerId?: long(name='OwnerId'),
  pageIndex?: string(name='PageIndex'),
  pageSize?: string(name='PageSize'),
  pattern?: string(name='Pattern'),
  region?: string(name='Region'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCrossBackupMetaListResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    meta?: [ 
    {
      database?: string(name='Database'),
      size?: string(name='Size'),
      tables?: string(name='Tables'),
    }
  ](name='Meta')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalPageCount?: int32(name='TotalPageCount'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossBackupMetaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrossBackupMetaListResponseBody(name='body'),
}

async function describeCrossBackupMetaListWithOptions(request: DescribeCrossBackupMetaListRequest, runtime: Util.RuntimeOptions): DescribeCrossBackupMetaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupSetId)) {
    query['BackupSetId'] = request.backupSetId;
  }
  if (!Util.isUnset(request.getDbName)) {
    query['GetDbName'] = request.getDbName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pattern)) {
    query['Pattern'] = request.pattern;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossBackupMetaList',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrossBackupMetaList(request: DescribeCrossBackupMetaListRequest): DescribeCrossBackupMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossBackupMetaListWithOptions(request, runtime);
}

model DescribeCrossRegionBackupDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeCrossRegionBackupDBInstanceResponseBody = {
  items?: {
    item?: [ 
    {
      backupEnabled?: string(name='BackupEnabled'),
      backupEnabledTime?: string(name='BackupEnabledTime'),
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossBackupType?: string(name='CrossBackupType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      lockMode?: string(name='LockMode'),
      logBackupEnabled?: string(name='LogBackupEnabled'),
      logBackupEnabledTime?: string(name='LogBackupEnabledTime'),
      retentType?: int32(name='RetentType'),
      retention?: int32(name='Retention'),
    }
  ](name='Item')
  }(name='Items'),
  itemsNumbers?: int32(name='ItemsNumbers'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  totalRecords?: int32(name='TotalRecords'),
}

model DescribeCrossRegionBackupDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrossRegionBackupDBInstanceResponseBody(name='body'),
}

async function describeCrossRegionBackupDBInstanceWithOptions(request: DescribeCrossRegionBackupDBInstanceRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionBackupDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossRegionBackupDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrossRegionBackupDBInstance(request: DescribeCrossRegionBackupDBInstanceRequest): DescribeCrossRegionBackupDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionBackupDBInstanceWithOptions(request, runtime);
}

model DescribeCrossRegionBackupsRequest {
  backupId?: int32(name='BackupId'),
  crossBackupId?: int32(name='CrossBackupId'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeCrossRegionBackupsResponseBody = {
  endTime?: string(name='EndTime'),
  items?: {
    item?: [ 
    {
      backupEndTime?: string(name='BackupEndTime'),
      backupMethod?: string(name='BackupMethod'),
      backupSetScale?: int32(name='BackupSetScale'),
      backupSetStatus?: int32(name='BackupSetStatus'),
      backupStartTime?: string(name='BackupStartTime'),
      backupType?: string(name='BackupType'),
      category?: string(name='Category'),
      consistentTime?: string(name='ConsistentTime'),
      crossBackupDownloadLink?: string(name='CrossBackupDownloadLink'),
      crossBackupId?: int32(name='CrossBackupId'),
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossBackupSetFile?: string(name='CrossBackupSetFile'),
      crossBackupSetLocation?: string(name='CrossBackupSetLocation'),
      crossBackupSetSize?: long(name='CrossBackupSetSize'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      instanceId?: int32(name='InstanceId'),
      restoreRegions?: {
        restoreRegion?: [ string ](name='RestoreRegion')
      }(name='RestoreRegions'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossRegionBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrossRegionBackupsResponseBody(name='body'),
}

async function describeCrossRegionBackupsWithOptions(request: DescribeCrossRegionBackupsRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.crossBackupId)) {
    query['CrossBackupId'] = request.crossBackupId;
  }
  if (!Util.isUnset(request.crossBackupRegion)) {
    query['CrossBackupRegion'] = request.crossBackupRegion;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossRegionBackups',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrossRegionBackups(request: DescribeCrossRegionBackupsRequest): DescribeCrossRegionBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionBackupsWithOptions(request, runtime);
}

model DescribeCrossRegionLogBackupFilesRequest {
  crossBackupRegion?: string(name='CrossBackupRegion'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeCrossRegionLogBackupFilesResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  items?: {
    item?: [ 
    {
      crossBackupRegion?: string(name='CrossBackupRegion'),
      crossDownloadLink?: string(name='CrossDownloadLink'),
      crossIntranetDownloadLink?: string(name='CrossIntranetDownloadLink'),
      crossLogBackupId?: int32(name='CrossLogBackupId'),
      crossLogBackupSize?: long(name='CrossLogBackupSize'),
      instanceId?: int32(name='InstanceId'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
      logFileName?: string(name='LogFileName'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeCrossRegionLogBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrossRegionLogBackupFilesResponseBody(name='body'),
}

async function describeCrossRegionLogBackupFilesWithOptions(request: DescribeCrossRegionLogBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeCrossRegionLogBackupFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.crossBackupRegion)) {
    query['CrossBackupRegion'] = request.crossBackupRegion;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossRegionLogBackupFiles',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrossRegionLogBackupFiles(request: DescribeCrossRegionLogBackupFilesRequest): DescribeCrossRegionLogBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossRegionLogBackupFilesWithOptions(request, runtime);
}

model DescribeDBInstanceAttributeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  expired?: string(name='Expired'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceAttributeResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      accountMaxQuantity?: int32(name='AccountMaxQuantity'),
      advancedFeatures?: string(name='AdvancedFeatures'),
      autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion'),
      availabilityValue?: string(name='AvailabilityValue'),
      babelfishConfig?: {
        babelfishEnabled?: string(name='BabelfishEnabled'),
        migrationMode?: string(name='MigrationMode'),
      }(name='BabelfishConfig'),
      category?: string(name='Category'),
      collation?: string(name='Collation'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      consoleVersion?: string(name='ConsoleVersion'),
      creationTime?: string(name='CreationTime'),
      currentKernelVersion?: string(name='CurrentKernelVersion'),
      DBInstanceCPU?: string(name='DBInstanceCPU'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceClassType?: string(name='DBInstanceClassType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMemory?: long(name='DBInstanceMemory'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      DBMaxQuantity?: int32(name='DBMaxQuantity'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      deletionProtection?: boolean(name='DeletionProtection'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      extra?: {
        DBInstanceIds?: {
          DBInstanceId?: [ string ](name='DBInstanceId')
        }(name='DBInstanceIds'),
      }(name='Extra'),
      generalGroupName?: string(name='GeneralGroupName'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      IPType?: string(name='IPType'),
      incrementSourceDBInstanceId?: string(name='IncrementSourceDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      instructionSetArch?: string(name='InstructionSetArch'),
      latestKernelVersion?: string(name='LatestKernelVersion'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      maintainTime?: string(name='MaintainTime'),
      masterInstanceId?: string(name='MasterInstanceId'),
      masterZone?: string(name='MasterZone'),
      maxConnections?: int32(name='MaxConnections'),
      maxIOMBPS?: int32(name='MaxIOMBPS'),
      maxIOPS?: int32(name='MaxIOPS'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      proxyType?: int32(name='ProxyType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      readonlyInstanceSQLDelayedTime?: string(name='ReadonlyInstanceSQLDelayedTime'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityIPList?: string(name='SecurityIPList'),
      securityIPMode?: string(name='SecurityIPMode'),
      serverlessConfig?: {
        autoPause?: boolean(name='AutoPause'),
        scaleMax?: double(name='ScaleMax'),
        scaleMin?: double(name='ScaleMin'),
        switchForce?: boolean(name='SwitchForce'),
      }(name='ServerlessConfig'),
      slaveZones?: {
        slaveZone?: [ 
        {
          zoneId?: string(name='ZoneId'),
        }
      ](name='SlaveZone')
      }(name='SlaveZones'),
      superPermissionMode?: string(name='SuperPermissionMode'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      timeZone?: string(name='TimeZone'),
      tips?: string(name='Tips'),
      tipsLevel?: int32(name='TipsLevel'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
      kindCode?: string(name='kindCode'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceAttributeResponseBody(name='body'),
}

async function describeDBInstanceAttributeWithOptions(request: DescribeDBInstanceAttributeRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceAttribute',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceAttribute(request: DescribeDBInstanceAttributeRequest): DescribeDBInstanceAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceAttributeWithOptions(request, runtime);
}

model DescribeDBInstanceByTagsRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  proxyId?: string(name='proxyId'),
}

model DescribeDBInstanceByTagsResponseBody = {
  items?: {
    DBInstanceTag?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      tags?: {
        tag?: [ 
        {
          tagKey?: string(name='TagKey'),
          tagValue?: string(name='TagValue'),
        }
      ](name='Tag')
      }(name='Tags'),
    }
  ](name='DBInstanceTag')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstanceByTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceByTagsResponseBody(name='body'),
}

async function describeDBInstanceByTagsWithOptions(request: DescribeDBInstanceByTagsRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceByTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceByTags',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceByTags(request: DescribeDBInstanceByTagsRequest): DescribeDBInstanceByTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceByTagsWithOptions(request, runtime);
}

model DescribeDBInstanceDetailRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceDetailResponseBody = {
  activationState?: string(name='ActivationState'),
  DBInstanceId?: string(name='DBInstanceId'),
  licenseType?: string(name='LicenseType'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceDetailResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceDetailResponseBody(name='body'),
}

async function describeDBInstanceDetailWithOptions(request: DescribeDBInstanceDetailRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceDetailResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceDetail',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceDetail(request: DescribeDBInstanceDetailRequest): DescribeDBInstanceDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceDetailWithOptions(request, runtime);
}

model DescribeDBInstanceEncryptionKeyRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  encryptionKey?: string(name='EncryptionKey'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  targetRegionId?: string(name='TargetRegionId'),
}

model DescribeDBInstanceEncryptionKeyResponseBody = {
  creator?: string(name='Creator'),
  deleteDate?: string(name='DeleteDate'),
  description?: string(name='Description'),
  encryptionKey?: string(name='EncryptionKey'),
  encryptionKeyStatus?: string(name='EncryptionKeyStatus'),
  keyUsage?: string(name='KeyUsage'),
  materialExpireTime?: string(name='MaterialExpireTime'),
  origin?: string(name='Origin'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceEncryptionKeyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceEncryptionKeyResponseBody(name='body'),
}

async function describeDBInstanceEncryptionKeyWithOptions(request: DescribeDBInstanceEncryptionKeyRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceEncryptionKeyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.targetRegionId)) {
    query['TargetRegionId'] = request.targetRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceEncryptionKey',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceEncryptionKey(request: DescribeDBInstanceEncryptionKeyRequest): DescribeDBInstanceEncryptionKeyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceEncryptionKeyWithOptions(request, runtime);
}

model DescribeDBInstanceHAConfigRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceHAConfigResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  HAMode?: string(name='HAMode'),
  hostInstanceInfos?: {
    nodeInfo?: [ 
    {
      dataSyncTime?: string(name='DataSyncTime'),
      logSyncTime?: string(name='LogSyncTime'),
      nodeId?: string(name='NodeId'),
      nodeType?: string(name='NodeType'),
      regionId?: string(name='RegionId'),
      syncStatus?: string(name='SyncStatus'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='NodeInfo')
  }(name='HostInstanceInfos'),
  requestId?: string(name='RequestId'),
  syncMode?: string(name='SyncMode'),
}

model DescribeDBInstanceHAConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceHAConfigResponseBody(name='body'),
}

async function describeDBInstanceHAConfigWithOptions(request: DescribeDBInstanceHAConfigRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceHAConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceHAConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceHAConfig(request: DescribeDBInstanceHAConfigRequest): DescribeDBInstanceHAConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceHAConfigWithOptions(request, runtime);
}

model DescribeDBInstanceIPArrayListRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  whitelistNetworkType?: string(name='WhitelistNetworkType'),
}

model DescribeDBInstanceIPArrayListResponseBody = {
  items?: {
    DBInstanceIPArray?: [ 
    {
      DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute'),
      DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName'),
      securityIPList?: string(name='SecurityIPList'),
      securityIPType?: string(name='SecurityIPType'),
    }
  ](name='DBInstanceIPArray')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceIPArrayListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceIPArrayListResponseBody(name='body'),
}

async function describeDBInstanceIPArrayListWithOptions(request: DescribeDBInstanceIPArrayListRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceIPArrayListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.whitelistNetworkType)) {
    query['WhitelistNetworkType'] = request.whitelistNetworkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceIPArrayList',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceIPArrayList(request: DescribeDBInstanceIPArrayListRequest): DescribeDBInstanceIPArrayListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceIPArrayListWithOptions(request, runtime);
}

model DescribeDBInstanceIpHostnameRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDBInstanceIpHostnameResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  ipHostnameInfos?: string(name='IpHostnameInfos'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceIpHostnameResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceIpHostnameResponseBody(name='body'),
}

async function describeDBInstanceIpHostnameWithOptions(request: DescribeDBInstanceIpHostnameRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceIpHostnameResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceIpHostname',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceIpHostname(request: DescribeDBInstanceIpHostnameRequest): DescribeDBInstanceIpHostnameResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceIpHostnameWithOptions(request, runtime);
}

model DescribeDBInstanceMetricsRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceMetricsResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: [ 
    {
      description?: string(name='Description'),
      dimension?: string(name='Dimension'),
      groupKey?: string(name='GroupKey'),
      groupKeyType?: string(name='GroupKeyType'),
      method?: string(name='Method'),
      metricsKey?: string(name='MetricsKey'),
      metricsKeyAlias?: string(name='MetricsKeyAlias'),
      sortRule?: int32(name='SortRule'),
      unit?: string(name='Unit'),
    }
  ](name='Items'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstanceMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceMetricsResponseBody(name='body'),
}

async function describeDBInstanceMetricsWithOptions(request: DescribeDBInstanceMetricsRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceMetricsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceMetrics',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceMetrics(request: DescribeDBInstanceMetricsRequest): DescribeDBInstanceMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceMetricsWithOptions(request, runtime);
}

model DescribeDBInstanceMonitorRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceMonitorResponseBody = {
  period?: string(name='Period'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceMonitorResponseBody(name='body'),
}

async function describeDBInstanceMonitorWithOptions(request: DescribeDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceMonitor',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceMonitor(request: DescribeDBInstanceMonitorRequest): DescribeDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceMonitorWithOptions(request, runtime);
}

model DescribeDBInstanceNetInfoRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceNetRWSplitType?: string(name='DBInstanceNetRWSplitType'),
  flag?: int32(name='Flag'),
  generalGroupName?: string(name='GeneralGroupName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceNetInfoResponseBody = {
  DBInstanceNetInfos?: {
    DBInstanceNetInfo?: [ 
    {
      babelfishPort?: string(name='BabelfishPort'),
      connectionString?: string(name='ConnectionString'),
      connectionStringType?: string(name='ConnectionStringType'),
      DBInstanceWeights?: {
        DBInstanceWeight?: [ 
        {
          availability?: string(name='Availability'),
          DBInstanceId?: string(name='DBInstanceId'),
          DBInstanceType?: string(name='DBInstanceType'),
          role?: string(name='Role'),
          weight?: string(name='Weight'),
        }
      ](name='DBInstanceWeight')
      }(name='DBInstanceWeights'),
      distributionType?: string(name='DistributionType'),
      expiredTime?: string(name='ExpiredTime'),
      IPAddress?: string(name='IPAddress'),
      IPType?: string(name='IPType'),
      maxDelayTime?: string(name='MaxDelayTime'),
      port?: string(name='Port'),
      securityIPGroups?: {
        securityIPGroup?: [ 
        {
          securityIPGroupName?: string(name='SecurityIPGroupName'),
          securityIPs?: string(name='SecurityIPs'),
        }
      ](name='securityIPGroup')
      }(name='SecurityIPGroups'),
      upgradeable?: string(name='Upgradeable'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
    }
  ](name='DBInstanceNetInfo')
  }(name='DBInstanceNetInfos'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  requestId?: string(name='RequestId'),
  securityIPMode?: string(name='SecurityIPMode'),
}

model DescribeDBInstanceNetInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceNetInfoResponseBody(name='body'),
}

async function describeDBInstanceNetInfoWithOptions(request: DescribeDBInstanceNetInfoRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceNetInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceNetRWSplitType)) {
    query['DBInstanceNetRWSplitType'] = request.DBInstanceNetRWSplitType;
  }
  if (!Util.isUnset(request.flag)) {
    query['Flag'] = request.flag;
  }
  if (!Util.isUnset(request.generalGroupName)) {
    query['GeneralGroupName'] = request.generalGroupName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceNetInfo',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceNetInfo(request: DescribeDBInstanceNetInfoRequest): DescribeDBInstanceNetInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceNetInfoWithOptions(request, runtime);
}

model DescribeDBInstanceNetInfoForChannelRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceNetRWSplitType?: string(name='DBInstanceNetRWSplitType'),
  flag?: string(name='Flag'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceNetInfoForChannelResponseBody = {
  DBInstanceNetInfos?: {
    DBInstanceNetInfo?: [ 
    {
      availability?: string(name='Availability'),
      connectionString?: string(name='ConnectionString'),
      connectionStringType?: string(name='ConnectionStringType'),
      DBInstanceWeights?: {
        DBInstanceWeight?: [ 
        {
          availability?: string(name='Availability'),
          DBInstanceId?: string(name='DBInstanceId'),
          DBInstanceType?: string(name='DBInstanceType'),
          weight?: string(name='Weight'),
        }
      ](name='DBInstanceWeight')
      }(name='DBInstanceWeights'),
      distributionType?: string(name='DistributionType'),
      IPAddress?: string(name='IPAddress'),
      IPType?: string(name='IPType'),
      maxDelayTime?: string(name='MaxDelayTime'),
      port?: string(name='Port'),
      securityIPGroups?: {
        securityIPGroup?: [ 
        {
          securityIPGroupName?: string(name='SecurityIPGroupName'),
          securityIPs?: string(name='SecurityIPs'),
        }
      ](name='securityIPGroup')
      }(name='SecurityIPGroups'),
      upgradeable?: string(name='Upgradeable'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      expiredTime?: string(name='expiredTime'),
    }
  ](name='DBInstanceNetInfo')
  }(name='DBInstanceNetInfos'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstanceNetInfoForChannelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceNetInfoForChannelResponseBody(name='body'),
}

async function describeDBInstanceNetInfoForChannelWithOptions(request: DescribeDBInstanceNetInfoForChannelRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceNetInfoForChannelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceNetRWSplitType)) {
    query['DBInstanceNetRWSplitType'] = request.DBInstanceNetRWSplitType;
  }
  if (!Util.isUnset(request.flag)) {
    query['Flag'] = request.flag;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceNetInfoForChannel',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceNetInfoForChannel(request: DescribeDBInstanceNetInfoForChannelRequest): DescribeDBInstanceNetInfoForChannelResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceNetInfoForChannelWithOptions(request, runtime);
}

model DescribeDBInstancePerformanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  key?: string(name='Key'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstancePerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key'),
      unit?: string(name='Unit'),
      valueFormat?: string(name='ValueFormat'),
      values?: {
        performanceValue?: [ 
        {
          date?: string(name='Date'),
          value?: string(name='Value'),
        }
      ](name='PerformanceValue')
      }(name='Values'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBInstancePerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancePerformanceResponseBody(name='body'),
}

async function describeDBInstancePerformanceWithOptions(request: DescribeDBInstancePerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancePerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancePerformance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancePerformance(request: DescribeDBInstancePerformanceRequest): DescribeDBInstancePerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancePerformanceWithOptions(request, runtime);
}

model DescribeDBInstancePromoteActivityRequest {
  aliUid?: string(name='AliUid'),
  dbInstanceName?: string(name='DbInstanceName'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstancePromoteActivityResponseBody = {
  aliUid?: string(name='AliUid'),
  bid?: string(name='Bid'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceName?: string(name='DBInstanceName'),
  DBType?: string(name='DBType'),
  isActivity?: string(name='IsActivity'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstancePromoteActivityResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancePromoteActivityResponseBody(name='body'),
}

async function describeDBInstancePromoteActivityWithOptions(request: DescribeDBInstancePromoteActivityRequest, runtime: Util.RuntimeOptions): DescribeDBInstancePromoteActivityResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.aliUid)) {
    query['AliUid'] = request.aliUid;
  }
  if (!Util.isUnset(request.dbInstanceName)) {
    query['DbInstanceName'] = request.dbInstanceName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancePromoteActivity',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancePromoteActivity(request: DescribeDBInstancePromoteActivityRequest): DescribeDBInstancePromoteActivityResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancePromoteActivityWithOptions(request, runtime);
}

model DescribeDBInstanceProxyConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceProxyConfigurationResponseBody = {
  attacksProtectionConfiguration?: string(name='AttacksProtectionConfiguration'),
  persistentConnectionsConfiguration?: string(name='PersistentConnectionsConfiguration'),
  requestId?: string(name='RequestId'),
  transparentSwitchConfiguration?: string(name='TransparentSwitchConfiguration'),
}

model DescribeDBInstanceProxyConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceProxyConfigurationResponseBody(name='body'),
}

async function describeDBInstanceProxyConfigurationWithOptions(request: DescribeDBInstanceProxyConfigurationRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceProxyConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceProxyConfiguration',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceProxyConfiguration(request: DescribeDBInstanceProxyConfigurationRequest): DescribeDBInstanceProxyConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceProxyConfigurationWithOptions(request, runtime);
}

model DescribeDBInstanceSSLRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceSSLResponseBody = {
  ACL?: string(name='ACL'),
  CAType?: string(name='CAType'),
  clientCACert?: string(name='ClientCACert'),
  clientCACertExpireTime?: string(name='ClientCACertExpireTime'),
  clientCertRevocationList?: string(name='ClientCertRevocationList'),
  connectionString?: string(name='ConnectionString'),
  lastModifyStatus?: string(name='LastModifyStatus'),
  modifyStatusReason?: string(name='ModifyStatusReason'),
  replicationACL?: string(name='ReplicationACL'),
  requestId?: string(name='RequestId'),
  requireUpdate?: string(name='RequireUpdate'),
  requireUpdateItem?: string(name='RequireUpdateItem'),
  requireUpdateReason?: string(name='RequireUpdateReason'),
  SSLCreateTime?: string(name='SSLCreateTime'),
  SSLEnabled?: string(name='SSLEnabled'),
  SSLExpireTime?: string(name='SSLExpireTime'),
  serverCAUrl?: string(name='ServerCAUrl'),
  serverCert?: string(name='ServerCert'),
  serverKey?: string(name='ServerKey'),
}

model DescribeDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceSSLResponseBody(name='body'),
}

async function describeDBInstanceSSLWithOptions(request: DescribeDBInstanceSSLRequest, runtime: Util.RuntimeOptions): DescribeDBInstanceSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceSSL',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceSSL(request: DescribeDBInstanceSSLRequest): DescribeDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceSSLWithOptions(request, runtime);
}

model DescribeDBInstanceTDERequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstanceTDEResponseBody = {
  databases?: {
    database?: [ 
    {
      DBName?: string(name='DBName'),
      TDEStatus?: string(name='TDEStatus'),
    }
  ](name='Database')
  }(name='Databases'),
  requestId?: string(name='RequestId'),
  TDEStatus?: string(name='TDEStatus'),
}

model DescribeDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstanceTDEResponseBody(name='body'),
}

async function describeDBInstanceTDEWithOptions(request: DescribeDBInstanceTDERequest, runtime: Util.RuntimeOptions): DescribeDBInstanceTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstanceTDE',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstanceTDE(request: DescribeDBInstanceTDERequest): DescribeDBInstanceTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstanceTDEWithOptions(request, runtime);
}

model DescribeDBInstancesRequest {
  clientToken?: string(name='ClientToken'),
  connectionMode?: string(name='ConnectionMode'),
  connectionString?: string(name='ConnectionString'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  DBInstanceType?: string(name='DBInstanceType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  expired?: string(name='Expired'),
  instanceLevel?: int32(name='InstanceLevel'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  searchKey?: string(name='SearchKey'),
  tags?: string(name='Tags'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
  proxyId?: string(name='proxyId'),
}

model DescribeDBInstancesResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      createTime?: string(name='CreateTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      dedicatedHostGroupName?: string(name='DedicatedHostGroupName'),
      dedicatedHostIdForLog?: string(name='DedicatedHostIdForLog'),
      dedicatedHostIdForMaster?: string(name='DedicatedHostIdForMaster'),
      dedicatedHostIdForSlave?: string(name='DedicatedHostIdForSlave'),
      dedicatedHostNameForLog?: string(name='DedicatedHostNameForLog'),
      dedicatedHostNameForMaster?: string(name='DedicatedHostNameForMaster'),
      dedicatedHostNameForSlave?: string(name='DedicatedHostNameForSlave'),
      dedicatedHostZoneIdForLog?: string(name='DedicatedHostZoneIdForLog'),
      dedicatedHostZoneIdForMaster?: string(name='DedicatedHostZoneIdForMaster'),
      dedicatedHostZoneIdForSlave?: string(name='DedicatedHostZoneIdForSlave'),
      deletionProtection?: boolean(name='DeletionProtection'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      generalGroupName?: string(name='GeneralGroupName'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      masterInstanceId?: string(name='MasterInstanceId'),
      mutriORsignle?: boolean(name='MutriORsignle'),
      payType?: string(name='PayType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      switchWeight?: int32(name='SwitchWeight'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      tips?: string(name='Tips'),
      tipsLevel?: int32(name='TipsLevel'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      vpcName?: string(name='VpcName'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  nextToken?: string(name='NextToken'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesResponseBody(name='body'),
}

async function describeDBInstancesWithOptions(request: DescribeDBInstancesRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionMode)) {
    query['ConnectionMode'] = request.connectionMode;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStatus)) {
    query['DBInstanceStatus'] = request.DBInstanceStatus;
  }
  if (!Util.isUnset(request.DBInstanceType)) {
    query['DBInstanceType'] = request.DBInstanceType;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.instanceLevel)) {
    query['InstanceLevel'] = request.instanceLevel;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstances',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstances(request: DescribeDBInstancesRequest): DescribeDBInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesWithOptions(request, runtime);
}

model DescribeDBInstancesAsCsvRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBInstancesAsCsvResponseBody = {
  items?: {
    DBInstanceAttribute?: [ 
    {
      accountMaxQuantity?: int32(name='AccountMaxQuantity'),
      accountType?: string(name='AccountType'),
      availabilityValue?: string(name='AvailabilityValue'),
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      connectionString?: string(name='ConnectionString'),
      creationTime?: string(name='CreationTime'),
      DBInstanceCPU?: string(name='DBInstanceCPU'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceClassType?: string(name='DBInstanceClassType'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceMemory?: long(name='DBInstanceMemory'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorage?: int32(name='DBInstanceStorage'),
      DBInstanceType?: string(name='DBInstanceType'),
      DBMaxQuantity?: int32(name='DBMaxQuantity'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      incrementSourceDBInstanceId?: string(name='IncrementSourceDBInstanceId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      maintainTime?: string(name='MaintainTime'),
      masterInstanceId?: string(name='MasterInstanceId'),
      maxConnections?: int32(name='MaxConnections'),
      maxIOPS?: int32(name='MaxIOPS'),
      payType?: string(name='PayType'),
      port?: string(name='Port'),
      readDelayTime?: string(name='ReadDelayTime'),
      regionId?: string(name='RegionId'),
      securityIPList?: string(name='SecurityIPList'),
      supportUpgradeAccountType?: string(name='SupportUpgradeAccountType'),
      tags?: string(name='Tags'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstanceAttribute')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDBInstancesAsCsvResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesAsCsvResponseBody(name='body'),
}

async function describeDBInstancesAsCsvWithOptions(request: DescribeDBInstancesAsCsvRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesAsCsvResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancesAsCsv',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancesAsCsv(request: DescribeDBInstancesAsCsvRequest): DescribeDBInstancesAsCsvResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesAsCsvWithOptions(request, runtime);
}

model DescribeDBInstancesByExpireTimeRequest {
  expirePeriod?: int32(name='ExpirePeriod'),
  expired?: boolean(name='Expired'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  proxyId?: string(name='proxyId'),
}

model DescribeDBInstancesByExpireTimeResponseBody = {
  items?: {
    DBInstanceExpireTime?: [ 
    {
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      expireTime?: string(name='ExpireTime'),
      lockMode?: string(name='LockMode'),
      payType?: string(name='PayType'),
    }
  ](name='DBInstanceExpireTime')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesByExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesByExpireTimeResponseBody(name='body'),
}

async function describeDBInstancesByExpireTimeWithOptions(request: DescribeDBInstancesByExpireTimeRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesByExpireTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.expirePeriod)) {
    query['ExpirePeriod'] = request.expirePeriod;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancesByExpireTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancesByExpireTime(request: DescribeDBInstancesByExpireTimeRequest): DescribeDBInstancesByExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesByExpireTimeWithOptions(request, runtime);
}

model DescribeDBInstancesByPerformanceRequest {
  tag?: [
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sortKey?: string(name='SortKey'),
  sortMethod?: string(name='SortMethod'),
  tags?: string(name='Tags'),
  proxyId?: string(name='proxyId'),
}

model DescribeDBInstancesByPerformanceResponseBody = {
  items?: {
    DBInstancePerformance?: [ 
    {
      CPUUsage?: string(name='CPUUsage'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      diskUsage?: string(name='DiskUsage'),
      IOPSUsage?: string(name='IOPSUsage'),
      sessionUsage?: string(name='SessionUsage'),
    }
  ](name='DBInstancePerformance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesByPerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesByPerformanceResponseBody(name='body'),
}

async function describeDBInstancesByPerformanceWithOptions(request: DescribeDBInstancesByPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesByPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['SortKey'] = request.sortKey;
  }
  if (!Util.isUnset(request.sortMethod)) {
    query['SortMethod'] = request.sortMethod;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancesByPerformance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancesByPerformance(request: DescribeDBInstancesByPerformanceRequest): DescribeDBInstancesByPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesByPerformanceWithOptions(request, runtime);
}

model DescribeDBInstancesForCloneRequest {
  clientToken?: string(name='ClientToken'),
  connectionMode?: string(name='ConnectionMode'),
  currentInstanceId?: string(name='CurrentInstanceId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  DBInstanceType?: string(name='DBInstanceType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  expired?: string(name='Expired'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  nodeType?: string(name='NodeType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  payType?: string(name='PayType'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  searchKey?: string(name='SearchKey'),
  vSwitchId?: string(name='VSwitchId'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
  proxyId?: string(name='proxyId'),
}

model DescribeDBInstancesForCloneResponseBody = {
  items?: {
    DBInstance?: [ 
    {
      category?: string(name='Category'),
      connectionMode?: string(name='ConnectionMode'),
      createTime?: string(name='CreateTime'),
      DBInstanceClass?: string(name='DBInstanceClass'),
      DBInstanceDescription?: string(name='DBInstanceDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBInstanceNetType?: string(name='DBInstanceNetType'),
      DBInstanceStatus?: string(name='DBInstanceStatus'),
      DBInstanceStorageType?: string(name='DBInstanceStorageType'),
      DBInstanceType?: string(name='DBInstanceType'),
      destroyTime?: string(name='DestroyTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      expireTime?: string(name='ExpireTime'),
      guardDBInstanceId?: string(name='GuardDBInstanceId'),
      insId?: int32(name='InsId'),
      instanceNetworkType?: string(name='InstanceNetworkType'),
      lockMode?: string(name='LockMode'),
      lockReason?: string(name='LockReason'),
      masterInstanceId?: string(name='MasterInstanceId'),
      mutriORsignle?: boolean(name='MutriORsignle'),
      payType?: string(name='PayType'),
      readOnlyDBInstanceIds?: {
        readOnlyDBInstanceId?: [ 
        {
          DBInstanceId?: string(name='DBInstanceId'),
        }
      ](name='ReadOnlyDBInstanceId')
      }(name='ReadOnlyDBInstanceIds'),
      regionId?: string(name='RegionId'),
      replicateId?: string(name='ReplicateId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tempDBInstanceId?: string(name='TempDBInstanceId'),
      vSwitchId?: string(name='VSwitchId'),
      vpcCloudInstanceId?: string(name='VpcCloudInstanceId'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DBInstance')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeDBInstancesForCloneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBInstancesForCloneResponseBody(name='body'),
}

async function describeDBInstancesForCloneWithOptions(request: DescribeDBInstancesForCloneRequest, runtime: Util.RuntimeOptions): DescribeDBInstancesForCloneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionMode)) {
    query['ConnectionMode'] = request.connectionMode;
  }
  if (!Util.isUnset(request.currentInstanceId)) {
    query['CurrentInstanceId'] = request.currentInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStatus)) {
    query['DBInstanceStatus'] = request.DBInstanceStatus;
  }
  if (!Util.isUnset(request.DBInstanceType)) {
    query['DBInstanceType'] = request.DBInstanceType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.expired)) {
    query['Expired'] = request.expired;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.searchKey)) {
    query['SearchKey'] = request.searchKey;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBInstancesForClone',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBInstancesForClone(request: DescribeDBInstancesForCloneRequest): DescribeDBInstancesForCloneResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBInstancesForCloneWithOptions(request, runtime);
}

model DescribeDBMiniEngineVersionsRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  minorVersionTag?: string(name='MinorVersionTag'),
  nodeType?: string(name='NodeType'),
  regionId?: string(name='RegionId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageType?: string(name='StorageType'),
}

model DescribeDBMiniEngineVersionsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  maxRecordsPerPage?: int32(name='MaxRecordsPerPage'),
  minorVersionItems?: [ 
    {
      communityMinorVersion?: string(name='CommunityMinorVersion'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      isHotfixVersion?: boolean(name='IsHotfixVersion'),
      minorVersion?: string(name='MinorVersion'),
      nodeType?: string(name='NodeType'),
      releaseNote?: string(name='ReleaseNote'),
      releaseType?: string(name='ReleaseType'),
      statusDesc?: string(name='StatusDesc'),
      tag?: string(name='Tag'),
    }
  ](name='MinorVersionItems'),
  pageNumbers?: int32(name='PageNumbers'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeDBMiniEngineVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBMiniEngineVersionsResponseBody(name='body'),
}

async function describeDBMiniEngineVersionsWithOptions(request: DescribeDBMiniEngineVersionsRequest, runtime: Util.RuntimeOptions): DescribeDBMiniEngineVersionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.minorVersionTag)) {
    query['MinorVersionTag'] = request.minorVersionTag;
  }
  if (!Util.isUnset(request.nodeType)) {
    query['NodeType'] = request.nodeType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageType)) {
    query['StorageType'] = request.storageType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBMiniEngineVersions',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBMiniEngineVersions(request: DescribeDBMiniEngineVersionsRequest): DescribeDBMiniEngineVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBMiniEngineVersionsWithOptions(request, runtime);
}

model DescribeDBProxyRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBProxyResponseBody = {
  DBProxyConnectStringItems?: {
    DBProxyConnectStringItems?: [ 
    {
      DBProxyConnectString?: string(name='DBProxyConnectString'),
      DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
      DBProxyConnectStringNetWorkType?: string(name='DBProxyConnectStringNetWorkType'),
      DBProxyConnectStringPort?: string(name='DBProxyConnectStringPort'),
      DBProxyEndpointId?: string(name='DBProxyEndpointId'),
      DBProxyEndpointName?: string(name='DBProxyEndpointName'),
      DBProxyVpcInstanceId?: string(name='DBProxyVpcInstanceId'),
    }
  ](name='DBProxyConnectStringItems')
  }(name='DBProxyConnectStringItems'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyInstanceCurrentMinorVersion?: string(name='DBProxyInstanceCurrentMinorVersion'),
  DBProxyInstanceLatestMinorVersion?: string(name='DBProxyInstanceLatestMinorVersion'),
  DBProxyInstanceName?: string(name='DBProxyInstanceName'),
  DBProxyInstanceNum?: int32(name='DBProxyInstanceNum'),
  DBProxyInstanceSize?: string(name='DBProxyInstanceSize'),
  DBProxyInstanceStatus?: string(name='DBProxyInstanceStatus'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType'),
  DBProxyServiceStatus?: string(name='DBProxyServiceStatus'),
  dbProxyEndpointItems?: {
    dbProxyEndpointItems?: [ 
    {
      dbProxyEndpointAliases?: string(name='DbProxyEndpointAliases'),
      dbProxyEndpointName?: string(name='DbProxyEndpointName'),
      dbProxyEndpointType?: string(name='DbProxyEndpointType'),
      dbProxyReadWriteMode?: string(name='DbProxyReadWriteMode'),
    }
  ](name='DbProxyEndpointItems')
  }(name='DbProxyEndpointItems'),
  requestId?: string(name='RequestId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDBProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBProxyResponseBody(name='body'),
}

async function describeDBProxyWithOptions(request: DescribeDBProxyRequest, runtime: Util.RuntimeOptions): DescribeDBProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBProxy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBProxy(request: DescribeDBProxyRequest): DescribeDBProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyWithOptions(request, runtime);
}

model DescribeDBProxyEndpointRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyConnectString?: string(name='DBProxyConnectString'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDBProxyEndpointResponseBody = {
  DBProxyConnectString?: string(name='DBProxyConnectString'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
  DBProxyConnectStringPort?: string(name='DBProxyConnectStringPort'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyFeatures?: string(name='DBProxyFeatures'),
  dbProxyEndpointAliases?: string(name='DbProxyEndpointAliases'),
  dbProxyEndpointReadWriteMode?: string(name='DbProxyEndpointReadWriteMode'),
  endpointConnectItems?: {
    endpointConnectItems?: [ 
    {
      dbProxyEndpointConnectString?: string(name='DbProxyEndpointConnectString'),
      dbProxyEndpointNetType?: string(name='DbProxyEndpointNetType'),
      dbProxyEndpointPort?: string(name='DbProxyEndpointPort'),
    }
  ](name='EndpointConnectItems')
  }(name='EndpointConnectItems'),
  readOnlyInstanceDistributionType?: string(name='ReadOnlyInstanceDistributionType'),
  readOnlyInstanceMaxDelayTime?: string(name='ReadOnlyInstanceMaxDelayTime'),
  readOnlyInstanceWeight?: string(name='ReadOnlyInstanceWeight'),
  requestId?: string(name='RequestId'),
}

model DescribeDBProxyEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBProxyEndpointResponseBody(name='body'),
}

async function describeDBProxyEndpointWithOptions(request: DescribeDBProxyEndpointRequest, runtime: Util.RuntimeOptions): DescribeDBProxyEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyConnectString)) {
    query['DBProxyConnectString'] = request.DBProxyConnectString;
  }
  if (!Util.isUnset(request.DBProxyEndpointId)) {
    query['DBProxyEndpointId'] = request.DBProxyEndpointId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBProxyEndpoint',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBProxyEndpoint(request: DescribeDBProxyEndpointRequest): DescribeDBProxyEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyEndpointWithOptions(request, runtime);
}

model DescribeDBProxyPerformanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType'),
  endTime?: string(name='EndTime'),
  metricsName?: string(name='MetricsName'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBProxyPerformanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  endTime?: string(name='EndTime'),
  performanceKeys?: {
    performanceKey?: [ 
    {
      key?: string(name='Key'),
      valueFormat?: string(name='ValueFormat'),
      values?: {
        performanceValue?: [ 
        {
          date?: string(name='Date'),
          value?: string(name='Value'),
        }
      ](name='PerformanceValue')
      }(name='Values'),
    }
  ](name='PerformanceKey')
  }(name='PerformanceKeys'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
}

model DescribeDBProxyPerformanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDBProxyPerformanceResponseBody(name='body'),
}

async function describeDBProxyPerformanceWithOptions(request: DescribeDBProxyPerformanceRequest, runtime: Util.RuntimeOptions): DescribeDBProxyPerformanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.DBProxyInstanceType)) {
    query['DBProxyInstanceType'] = request.DBProxyInstanceType;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.metricsName)) {
    query['MetricsName'] = request.metricsName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDBProxyPerformance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDBProxyPerformance(request: DescribeDBProxyPerformanceRequest): DescribeDBProxyPerformanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDBProxyPerformanceWithOptions(request, runtime);
}

model DescribeDTCSecurityIpHostsForSQLServerRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeDTCSecurityIpHostsForSQLServerResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  ipHostPairNum?: string(name='IpHostPairNum'),
  items?: {
    whiteListGroups?: [ 
    {
      securityIpHosts?: string(name='SecurityIpHosts'),
      whitelistGroupName?: string(name='WhitelistGroupName'),
    }
  ](name='WhiteListGroups')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeDTCSecurityIpHostsForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDTCSecurityIpHostsForSQLServerResponseBody(name='body'),
}

async function describeDTCSecurityIpHostsForSQLServerWithOptions(request: DescribeDTCSecurityIpHostsForSQLServerRequest, runtime: Util.RuntimeOptions): DescribeDTCSecurityIpHostsForSQLServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDTCSecurityIpHostsForSQLServer',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDTCSecurityIpHostsForSQLServer(request: DescribeDTCSecurityIpHostsForSQLServerRequest): DescribeDTCSecurityIpHostsForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
}

model DescribeDatabasesRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  DBStatus?: string(name='DBStatus'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDatabasesResponseBody = {
  databases?: {
    database?: [ 
    {
      accounts?: {
        accountPrivilegeInfo?: [ 
        {
          account?: string(name='Account'),
          accountPrivilege?: string(name='AccountPrivilege'),
          accountPrivilegeDetail?: string(name='AccountPrivilegeDetail'),
        }
      ](name='AccountPrivilegeInfo')
      }(name='Accounts'),
      characterSetName?: string(name='CharacterSetName'),
      collate?: string(name='Collate'),
      connLimit?: string(name='ConnLimit'),
      ctype?: string(name='Ctype'),
      DBDescription?: string(name='DBDescription'),
      DBInstanceId?: string(name='DBInstanceId'),
      DBName?: string(name='DBName'),
      DBStatus?: string(name='DBStatus'),
      engine?: string(name='Engine'),
      pageNumber?: int32(name='PageNumber'),
      pageSize?: int32(name='PageSize'),
      resourceGroupId?: string(name='ResourceGroupId'),
      tablespace?: string(name='Tablespace'),
      totalCount?: int32(name='TotalCount'),
    }
  ](name='Database')
  }(name='Databases'),
  requestId?: string(name='RequestId'),
}

model DescribeDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDatabasesResponseBody(name='body'),
}

async function describeDatabasesWithOptions(request: DescribeDatabasesRequest, runtime: Util.RuntimeOptions): DescribeDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.DBStatus)) {
    query['DBStatus'] = request.DBStatus;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDatabases',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDatabases(request: DescribeDatabasesRequest): DescribeDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDatabasesWithOptions(request, runtime);
}

model DescribeDedicatedHostGroupsRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  imageCategory?: string(name='ImageCategory'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeDedicatedHostGroupsResponseBody = {
  dedicatedHostGroups?: {
    dedicatedHostGroups?: [ 
    {
      allocationPolicy?: string(name='AllocationPolicy'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      cpuAllocateRation?: float(name='CpuAllocateRation'),
      cpuAllocatedAmount?: float(name='CpuAllocatedAmount'),
      cpuAllocationRatio?: int32(name='CpuAllocationRatio'),
      createTime?: string(name='CreateTime'),
      dedicatedHostCountGroupByHostType?: map[string]any(name='DedicatedHostCountGroupByHostType'),
      dedicatedHostGroupDesc?: string(name='DedicatedHostGroupDesc'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      diskAllocateRation?: float(name='DiskAllocateRation'),
      diskAllocatedAmount?: float(name='DiskAllocatedAmount'),
      diskAllocationRatio?: int32(name='DiskAllocationRatio'),
      diskUsedAmount?: float(name='DiskUsedAmount'),
      diskUtility?: float(name='DiskUtility'),
      engine?: string(name='Engine'),
      hostNumber?: int32(name='HostNumber'),
      hostReplacePolicy?: string(name='HostReplacePolicy'),
      instanceNumber?: int32(name='InstanceNumber'),
      memAllocateRation?: float(name='MemAllocateRation'),
      memAllocatedAmount?: float(name='MemAllocatedAmount'),
      memAllocationRatio?: int32(name='MemAllocationRatio'),
      memUsedAmount?: float(name='MemUsedAmount'),
      memUtility?: float(name='MemUtility'),
      openPermission?: string(name='OpenPermission'),
      text?: string(name='Text'),
      VPCId?: string(name='VPCId'),
      zoneIDList?: {
        zoneIDList?: [ string ](name='ZoneIDList')
      }(name='ZoneIDList'),
    }
  ](name='DedicatedHostGroups')
  }(name='DedicatedHostGroups'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostGroupsResponseBody(name='body'),
}

async function describeDedicatedHostGroupsWithOptions(request: DescribeDedicatedHostGroupsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.imageCategory)) {
    query['ImageCategory'] = request.imageCategory;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHostGroups',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHostGroups(request: DescribeDedicatedHostGroupsRequest): DescribeDedicatedHostGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostGroupsWithOptions(request, runtime);
}

model DescribeDedicatedHostsRequest {
  allocationStatus?: string(name='AllocationStatus'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  hostStatus?: string(name='HostStatus'),
  hostType?: string(name='HostType'),
  orderId?: long(name='OrderId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeDedicatedHostsResponseBody = {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHosts?: {
    dedicatedHosts?: [ 
    {
      accountName?: string(name='AccountName'),
      allocationStatus?: string(name='AllocationStatus'),
      bastionInstanceId?: string(name='BastionInstanceId'),
      CPUAllocationRatio?: string(name='CPUAllocationRatio'),
      cpuUsed?: string(name='CpuUsed'),
      createdTime?: string(name='CreatedTime'),
      dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
      dedicatedHostId?: string(name='DedicatedHostId'),
      diskAllocationRatio?: string(name='DiskAllocationRatio'),
      endTime?: string(name='EndTime'),
      engine?: string(name='Engine'),
      hostCPU?: string(name='HostCPU'),
      hostClass?: string(name='HostClass'),
      hostMem?: string(name='HostMem'),
      hostName?: string(name='HostName'),
      hostStatus?: string(name='HostStatus'),
      hostStorage?: string(name='HostStorage'),
      hostType?: string(name='HostType'),
      IPAddress?: string(name='IPAddress'),
      imageCategory?: string(name='ImageCategory'),
      instanceNumber?: string(name='InstanceNumber'),
      memAllocationRatio?: string(name='MemAllocationRatio'),
      memoryUsed?: string(name='MemoryUsed'),
      openPermission?: string(name='OpenPermission'),
      storageUsed?: string(name='StorageUsed'),
      VPCId?: string(name='VPCId'),
      vSwitchId?: string(name='VSwitchId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='DedicatedHosts')
  }(name='DedicatedHosts'),
  requestId?: string(name='RequestId'),
}

model DescribeDedicatedHostsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDedicatedHostsResponseBody(name='body'),
}

async function describeDedicatedHostsWithOptions(request: DescribeDedicatedHostsRequest, runtime: Util.RuntimeOptions): DescribeDedicatedHostsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.allocationStatus)) {
    query['AllocationStatus'] = request.allocationStatus;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.hostStatus)) {
    query['HostStatus'] = request.hostStatus;
  }
  if (!Util.isUnset(request.hostType)) {
    query['HostType'] = request.hostType;
  }
  if (!Util.isUnset(request.orderId)) {
    query['OrderId'] = request.orderId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDedicatedHosts',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDedicatedHosts(request: DescribeDedicatedHostsRequest): DescribeDedicatedHostsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDedicatedHostsWithOptions(request, runtime);
}

model DescribeDetachedBackupsRequest {
  backupId?: string(name='BackupId'),
  backupMode?: string(name='BackupMode'),
  backupStatus?: string(name='BackupStatus'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  region?: string(name='Region'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeDetachedBackupsResponseBody = {
  items?: {
    backup?: [ 
    {
      backupDownloadURL?: string(name='BackupDownloadURL'),
      backupEndTime?: string(name='BackupEndTime'),
      backupId?: string(name='BackupId'),
      backupIntranetDownloadURL?: string(name='BackupIntranetDownloadURL'),
      backupMethod?: string(name='BackupMethod'),
      backupMode?: string(name='BackupMode'),
      backupSize?: long(name='BackupSize'),
      backupStartTime?: string(name='BackupStartTime'),
      backupStatus?: string(name='BackupStatus'),
      backupType?: string(name='BackupType'),
      consistentTime?: long(name='ConsistentTime'),
      DBInstanceComment?: string(name='DBInstanceComment'),
      DBInstanceId?: string(name='DBInstanceId'),
      hostInstanceID?: string(name='HostInstanceID'),
      isAvail?: int32(name='IsAvail'),
      metaStatus?: string(name='MetaStatus'),
      storeStatus?: string(name='StoreStatus'),
    }
  ](name='Backup')
  }(name='Items'),
  pageNumber?: string(name='PageNumber'),
  pageRecordCount?: string(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: string(name='TotalRecordCount'),
}

model DescribeDetachedBackupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDetachedBackupsResponseBody(name='body'),
}

async function describeDetachedBackupsWithOptions(request: DescribeDetachedBackupsRequest, runtime: Util.RuntimeOptions): DescribeDetachedBackupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupMode)) {
    query['BackupMode'] = request.backupMode;
  }
  if (!Util.isUnset(request.backupStatus)) {
    query['BackupStatus'] = request.backupStatus;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDetachedBackups',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDetachedBackups(request: DescribeDetachedBackupsRequest): DescribeDetachedBackupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDetachedBackupsWithOptions(request, runtime);
}

model DescribeDiagnosticReportListRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeDiagnosticReportListResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  reportList?: [ 
    {
      diagnosticTime?: string(name='DiagnosticTime'),
      downloadURL?: string(name='DownloadURL'),
      endTime?: string(name='EndTime'),
      score?: int32(name='Score'),
      startTime?: string(name='StartTime'),
    }
  ](name='ReportList'),
  requestId?: string(name='RequestId'),
}

model DescribeDiagnosticReportListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDiagnosticReportListResponseBody(name='body'),
}

async function describeDiagnosticReportListWithOptions(request: DescribeDiagnosticReportListRequest, runtime: Util.RuntimeOptions): DescribeDiagnosticReportListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeDiagnosticReportList',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeDiagnosticReportList(request: DescribeDiagnosticReportListRequest): DescribeDiagnosticReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeDiagnosticReportListWithOptions(request, runtime);
}

model DescribeErrorLogsRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeErrorLogsResponseBody = {
  items?: {
    errorLog?: [ 
    {
      createTime?: string(name='CreateTime'),
      errorInfo?: string(name='ErrorInfo'),
    }
  ](name='ErrorLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeErrorLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeErrorLogsResponseBody(name='body'),
}

async function describeErrorLogsWithOptions(request: DescribeErrorLogsRequest, runtime: Util.RuntimeOptions): DescribeErrorLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeErrorLogs',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeErrorLogs(request: DescribeErrorLogsRequest): DescribeErrorLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeErrorLogsWithOptions(request, runtime);
}

model DescribeEventsRequest {
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeEventsResponseBody = {
  eventItems?: {
    eventItems?: [ 
    {
      callerUid?: long(name='CallerUid'),
      eventId?: int32(name='EventId'),
      eventName?: string(name='EventName'),
      eventPayload?: string(name='EventPayload'),
      eventReason?: string(name='EventReason'),
      eventRecordTime?: string(name='EventRecordTime'),
      eventTime?: string(name='EventTime'),
      eventType?: string(name='EventType'),
      eventUserType?: string(name='EventUserType'),
      regionId?: string(name='RegionId'),
      resourceName?: string(name='ResourceName'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='EventItems')
  }(name='EventItems'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeEventsResponseBody(name='body'),
}

async function describeEventsWithOptions(request: DescribeEventsRequest, runtime: Util.RuntimeOptions): DescribeEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeEvents',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeEvents(request: DescribeEventsRequest): DescribeEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeEventsWithOptions(request, runtime);
}

model DescribeGadInstancesRequest {
  gadInstanceName?: string(name='GadInstanceName'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
}

model DescribeGadInstancesResponseBody = {
  gadInstances?: [ 
    {
      creationTime?: string(name='CreationTime'),
      description?: string(name='Description'),
      gadInstanceMembers?: [ 
        {
          DBInstanceID?: string(name='DBInstanceID'),
          dtsInstance?: string(name='DtsInstance'),
          engine?: string(name='Engine'),
          engineVersion?: string(name='EngineVersion'),
          regionId?: string(name='RegionId'),
          resourceGroupId?: string(name='ResourceGroupId'),
          role?: string(name='Role'),
          status?: string(name='Status'),
        }
      ](name='GadInstanceMembers'),
      gadInstanceName?: string(name='GadInstanceName'),
      modificationTime?: string(name='ModificationTime'),
      service?: string(name='Service'),
      status?: string(name='Status'),
    }
  ](name='GadInstances'),
  requestId?: string(name='RequestId'),
}

model DescribeGadInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeGadInstancesResponseBody(name='body'),
}

async function describeGadInstancesWithOptions(request: DescribeGadInstancesRequest, runtime: Util.RuntimeOptions): DescribeGadInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gadInstanceName)) {
    query['GadInstanceName'] = request.gadInstanceName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeGadInstances',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeGadInstances(request: DescribeGadInstancesRequest): DescribeGadInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeGadInstancesWithOptions(request, runtime);
}

model DescribeHADiagnoseConfigRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHADiagnoseConfigResponseBody = {
  requestId?: string(name='RequestId'),
  tcpConnectionType?: string(name='TcpConnectionType'),
}

model DescribeHADiagnoseConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHADiagnoseConfigResponseBody(name='body'),
}

async function describeHADiagnoseConfigWithOptions(request: DescribeHADiagnoseConfigRequest, runtime: Util.RuntimeOptions): DescribeHADiagnoseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHADiagnoseConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHADiagnoseConfig(request: DescribeHADiagnoseConfigRequest): DescribeHADiagnoseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHADiagnoseConfigWithOptions(request, runtime);
}

model DescribeHASwitchConfigRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeHASwitchConfigResponseBody = {
  HAConfig?: string(name='HAConfig'),
  manualHATime?: string(name='ManualHATime'),
  requestId?: string(name='RequestId'),
}

model DescribeHASwitchConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHASwitchConfigResponseBody(name='body'),
}

async function describeHASwitchConfigWithOptions(request: DescribeHASwitchConfigRequest, runtime: Util.RuntimeOptions): DescribeHASwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHASwitchConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHASwitchConfig(request: DescribeHASwitchConfigRequest): DescribeHASwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHASwitchConfigWithOptions(request, runtime);
}

model DescribeInstanceAutoRenewalAttributeRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  proxyId?: string(name='proxyId'),
}

model DescribeInstanceAutoRenewalAttributeResponseBody = {
  items?: {
    item?: [ 
    {
      autoRenew?: string(name='AutoRenew'),
      DBInstanceId?: string(name='DBInstanceId'),
      duration?: int32(name='Duration'),
      regionId?: string(name='RegionId'),
      status?: string(name='Status'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function describeInstanceAutoRenewalAttributeWithOptions(request: DescribeInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): DescribeInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceAutoRenewalAttribute',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceAutoRenewalAttribute(request: DescribeInstanceAutoRenewalAttributeRequest): DescribeInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model DescribeInstanceCrossBackupPolicyRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeInstanceCrossBackupPolicyResponseBody = {
  backupEnabled?: string(name='BackupEnabled'),
  backupEnabledTime?: string(name='BackupEnabledTime'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  crossBackupType?: string(name='CrossBackupType'),
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStatus?: string(name='DBInstanceStatus'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  lockMode?: string(name='LockMode'),
  logBackupEnabled?: string(name='LogBackupEnabled'),
  logBackupEnabledTime?: string(name='LogBackupEnabledTime'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  retentType?: int32(name='RetentType'),
  retention?: int32(name='Retention'),
}

model DescribeInstanceCrossBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceCrossBackupPolicyResponseBody(name='body'),
}

async function describeInstanceCrossBackupPolicyWithOptions(request: DescribeInstanceCrossBackupPolicyRequest, runtime: Util.RuntimeOptions): DescribeInstanceCrossBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceCrossBackupPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceCrossBackupPolicy(request: DescribeInstanceCrossBackupPolicyRequest): DescribeInstanceCrossBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceCrossBackupPolicyWithOptions(request, runtime);
}

model DescribeInstanceKeywordsRequest {
  key?: string(name='Key'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeInstanceKeywordsResponseBody = {
  key?: string(name='Key'),
  requestId?: string(name='RequestId'),
  words?: {
    word?: [ string ](name='word')
  }(name='Words'),
}

model DescribeInstanceKeywordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceKeywordsResponseBody(name='body'),
}

async function describeInstanceKeywordsWithOptions(request: DescribeInstanceKeywordsRequest, runtime: Util.RuntimeOptions): DescribeInstanceKeywordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceKeywords',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceKeywords(request: DescribeInstanceKeywordsRequest): DescribeInstanceKeywordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceKeywordsWithOptions(request, runtime);
}

model DescribeLocalAvailableRecoveryTimeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  region?: string(name='Region'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeLocalAvailableRecoveryTimeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  recoveryBeginTime?: string(name='RecoveryBeginTime'),
  recoveryEndTime?: string(name='RecoveryEndTime'),
  requestId?: string(name='RequestId'),
}

model DescribeLocalAvailableRecoveryTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLocalAvailableRecoveryTimeResponseBody(name='body'),
}

async function describeLocalAvailableRecoveryTimeWithOptions(request: DescribeLocalAvailableRecoveryTimeRequest, runtime: Util.RuntimeOptions): DescribeLocalAvailableRecoveryTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.region)) {
    query['Region'] = request.region;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLocalAvailableRecoveryTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLocalAvailableRecoveryTime(request: DescribeLocalAvailableRecoveryTimeRequest): DescribeLocalAvailableRecoveryTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLocalAvailableRecoveryTimeWithOptions(request, runtime);
}

model DescribeLogBackupFilesRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeLogBackupFilesResponseBody = {
  items?: {
    binLogFile?: [ 
    {
      downloadLink?: string(name='DownloadLink'),
      fileSize?: long(name='FileSize'),
      intranetDownloadLink?: string(name='IntranetDownloadLink'),
      linkExpiredTime?: string(name='LinkExpiredTime'),
      logBeginTime?: string(name='LogBeginTime'),
      logEndTime?: string(name='LogEndTime'),
    }
  ](name='BinLogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalFileSize?: long(name='TotalFileSize'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeLogBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeLogBackupFilesResponseBody(name='body'),
}

async function describeLogBackupFilesWithOptions(request: DescribeLogBackupFilesRequest, runtime: Util.RuntimeOptions): DescribeLogBackupFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeLogBackupFiles',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeLogBackupFiles(request: DescribeLogBackupFilesRequest): DescribeLogBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeLogBackupFilesWithOptions(request, runtime);
}

model DescribeMetaListRequest {
  backupSetID?: int32(name='BackupSetID'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  getDbName?: string(name='GetDbName'),
  ownerId?: long(name='OwnerId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  pattern?: string(name='Pattern'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  restoreType?: string(name='RestoreType'),
}

model DescribeMetaListResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    meta?: [ 
    {
      database?: string(name='Database'),
      size?: string(name='Size'),
      tables?: string(name='Tables'),
    }
  ](name='Meta')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalPageCount?: int32(name='TotalPageCount'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeMetaListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMetaListResponseBody(name='body'),
}

async function describeMetaListWithOptions(request: DescribeMetaListRequest, runtime: Util.RuntimeOptions): DescribeMetaListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupSetID)) {
    query['BackupSetID'] = request.backupSetID;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.getDbName)) {
    query['GetDbName'] = request.getDbName;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageIndex)) {
    query['PageIndex'] = request.pageIndex;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.pattern)) {
    query['Pattern'] = request.pattern;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMetaList',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMetaList(request: DescribeMetaListRequest): DescribeMetaListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMetaListWithOptions(request, runtime);
}

model DescribeMigrateTaskByIdRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  migrateTaskId?: string(name='MigrateTaskId'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMigrateTaskByIdResponseBody = {
  backupMode?: string(name='BackupMode'),
  createTime?: string(name='CreateTime'),
  DBInstanceName?: string(name='DBInstanceName'),
  DBName?: string(name='DBName'),
  description?: string(name='Description'),
  endTime?: string(name='EndTime'),
  isDBReplaced?: string(name='IsDBReplaced'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
  status?: string(name='Status'),
}

model DescribeMigrateTaskByIdResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMigrateTaskByIdResponseBody(name='body'),
}

async function describeMigrateTaskByIdWithOptions(request: DescribeMigrateTaskByIdRequest, runtime: Util.RuntimeOptions): DescribeMigrateTaskByIdResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.migrateTaskId)) {
    query['MigrateTaskId'] = request.migrateTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMigrateTaskById',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMigrateTaskById(request: DescribeMigrateTaskByIdRequest): DescribeMigrateTaskByIdResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMigrateTaskByIdWithOptions(request, runtime);
}

model DescribeMigrateTasksRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeMigrateTasksResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  items?: {
    migrateTask?: [ 
    {
      backupMode?: string(name='BackupMode'),
      createTime?: string(name='CreateTime'),
      DBName?: string(name='DBName'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      isDBReplaced?: string(name='IsDBReplaced'),
      migrateTaskId?: string(name='MigrateTaskId'),
      status?: string(name='Status'),
    }
  ](name='MigrateTask')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeMigrateTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMigrateTasksResponseBody(name='body'),
}

async function describeMigrateTasksWithOptions(request: DescribeMigrateTasksRequest, runtime: Util.RuntimeOptions): DescribeMigrateTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMigrateTasks',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMigrateTasks(request: DescribeMigrateTasksRequest): DescribeMigrateTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMigrateTasksWithOptions(request, runtime);
}

model DescribeModifyPGHbaConfigLogRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeModifyPGHbaConfigLogResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  hbaLogItems?: {
    hbaLogItem?: [ 
    {
      afterHbaItems?: {
        hbaItem?: [ 
        {
          address?: string(name='Address'),
          database?: string(name='Database'),
          mask?: string(name='Mask'),
          method?: string(name='Method'),
          option?: string(name='Option'),
          priorityId?: int32(name='PriorityId'),
          type?: string(name='Type'),
          user?: string(name='User'),
        }
      ](name='HbaItem')
      }(name='AfterHbaItems'),
      beforeHbaItems?: {
        hbaItem?: [ 
        {
          address?: string(name='Address'),
          database?: string(name='Database'),
          mask?: string(name='Mask'),
          method?: string(name='Method'),
          option?: string(name='Option'),
          priorityId?: int32(name='PriorityId'),
          type?: string(name='Type'),
          user?: string(name='User'),
        }
      ](name='HbaItem')
      }(name='BeforeHbaItems'),
      modifyStatus?: string(name='ModifyStatus'),
      modifyTime?: string(name='ModifyTime'),
      statusReason?: string(name='StatusReason'),
    }
  ](name='HbaLogItem')
  }(name='HbaLogItems'),
  logItemCount?: int32(name='LogItemCount'),
  requestId?: string(name='RequestId'),
}

model DescribeModifyPGHbaConfigLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeModifyPGHbaConfigLogResponseBody(name='body'),
}

async function describeModifyPGHbaConfigLogWithOptions(request: DescribeModifyPGHbaConfigLogRequest, runtime: Util.RuntimeOptions): DescribeModifyPGHbaConfigLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeModifyPGHbaConfigLog',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeModifyPGHbaConfigLog(request: DescribeModifyPGHbaConfigLogRequest): DescribeModifyPGHbaConfigLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModifyPGHbaConfigLogWithOptions(request, runtime);
}

model DescribeModifyParameterLogRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeModifyParameterLogResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  items?: {
    parameterChangeLog?: [ 
    {
      modifyTime?: string(name='ModifyTime'),
      newParameterValue?: string(name='NewParameterValue'),
      oldParameterValue?: string(name='OldParameterValue'),
      parameterName?: string(name='ParameterName'),
      status?: string(name='Status'),
    }
  ](name='ParameterChangeLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeModifyParameterLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeModifyParameterLogResponseBody(name='body'),
}

async function describeModifyParameterLogWithOptions(request: DescribeModifyParameterLogRequest, runtime: Util.RuntimeOptions): DescribeModifyParameterLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeModifyParameterLog',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeModifyParameterLog(request: DescribeModifyParameterLogRequest): DescribeModifyParameterLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeModifyParameterLogWithOptions(request, runtime);
}

model DescribeOssDownloadsRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  migrateTaskId?: string(name='MigrateTaskId'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeOssDownloadsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  items?: {
    ossDownload?: [ 
    {
      backupMode?: string(name='BackupMode'),
      createTime?: string(name='CreateTime'),
      description?: string(name='Description'),
      endTime?: string(name='EndTime'),
      fileName?: string(name='FileName'),
      fileSize?: string(name='FileSize'),
      isAvailable?: string(name='IsAvailable'),
      status?: string(name='Status'),
    }
  ](name='OssDownload')
  }(name='Items'),
  migrateTaskId?: string(name='MigrateTaskId'),
  requestId?: string(name='RequestId'),
}

model DescribeOssDownloadsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOssDownloadsResponseBody(name='body'),
}

async function describeOssDownloadsWithOptions(request: DescribeOssDownloadsRequest, runtime: Util.RuntimeOptions): DescribeOssDownloadsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.migrateTaskId)) {
    query['MigrateTaskId'] = request.migrateTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOssDownloads',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOssDownloads(request: DescribeOssDownloadsRequest): DescribeOssDownloadsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOssDownloadsWithOptions(request, runtime);
}

model DescribePGHbaConfigRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribePGHbaConfigResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  defaultHbaItems?: {
    hbaItem?: [ 
    {
      address?: string(name='Address'),
      database?: string(name='Database'),
      mask?: string(name='Mask'),
      method?: string(name='Method'),
      option?: string(name='Option'),
      priorityId?: int32(name='PriorityId'),
      type?: string(name='Type'),
      user?: string(name='User'),
    }
  ](name='HbaItem')
  }(name='DefaultHbaItems'),
  hbaModifyTime?: string(name='HbaModifyTime'),
  lastModifyStatus?: string(name='LastModifyStatus'),
  modifyStatusReason?: string(name='ModifyStatusReason'),
  requestId?: string(name='RequestId'),
  runningHbaItems?: {
    hbaItem?: [ 
    {
      address?: string(name='Address'),
      database?: string(name='Database'),
      mask?: string(name='Mask'),
      method?: string(name='Method'),
      option?: string(name='Option'),
      priorityId?: int32(name='PriorityId'),
      type?: string(name='Type'),
      user?: string(name='User'),
    }
  ](name='HbaItem')
  }(name='RunningHbaItems'),
}

model DescribePGHbaConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePGHbaConfigResponseBody(name='body'),
}

async function describePGHbaConfigWithOptions(request: DescribePGHbaConfigRequest, runtime: Util.RuntimeOptions): DescribePGHbaConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePGHbaConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePGHbaConfig(request: DescribePGHbaConfigRequest): DescribePGHbaConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePGHbaConfigWithOptions(request, runtime);
}

model DescribeParameterGroupRequest {
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupResponseBody = {
  paramGroup?: {
    parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      forceRestart?: int32(name='ForceRestart'),
      paramCounts?: int32(name='ParamCounts'),
      paramDetail?: {
        parameterDetail?: [ 
        {
          paramName?: string(name='ParamName'),
          paramValue?: string(name='ParamValue'),
        }
      ](name='ParameterDetail')
      }(name='ParamDetail'),
      parameterGroupDesc?: string(name='ParameterGroupDesc'),
      parameterGroupId?: string(name='ParameterGroupId'),
      parameterGroupName?: string(name='ParameterGroupName'),
      parameterGroupType?: int32(name='ParameterGroupType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ParameterGroup')
  }(name='ParamGroup'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterGroupResponseBody(name='body'),
}

async function describeParameterGroupWithOptions(request: DescribeParameterGroupRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterGroup(request: DescribeParameterGroupRequest): DescribeParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupWithOptions(request, runtime);
}

model DescribeParameterGroupsRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterGroupsResponseBody = {
  parameterGroups?: {
    parameterGroup?: [ 
    {
      createTime?: string(name='CreateTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      forceRestart?: int32(name='ForceRestart'),
      paramCounts?: int32(name='ParamCounts'),
      parameterGroupDesc?: string(name='ParameterGroupDesc'),
      parameterGroupId?: string(name='ParameterGroupId'),
      parameterGroupName?: string(name='ParameterGroupName'),
      parameterGroupType?: int32(name='ParameterGroupType'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='ParameterGroup')
  }(name='ParameterGroups'),
  requestId?: string(name='RequestId'),
  signalForOptimizeParams?: boolean(name='SignalForOptimizeParams'),
}

model DescribeParameterGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterGroupsResponseBody(name='body'),
}

async function describeParameterGroupsWithOptions(request: DescribeParameterGroupsRequest, runtime: Util.RuntimeOptions): DescribeParameterGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterGroups',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterGroups(request: DescribeParameterGroupsRequest): DescribeParameterGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterGroupsWithOptions(request, runtime);
}

model DescribeParameterTemplatesRequest {
  category?: string(name='Category'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParameterTemplatesResponseBody = {
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  parameterCount?: string(name='ParameterCount'),
  parameters?: {
    templateRecord?: [ 
    {
      checkingCode?: string(name='CheckingCode'),
      forceModify?: string(name='ForceModify'),
      forceRestart?: string(name='ForceRestart'),
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='TemplateRecord')
  }(name='Parameters'),
  requestId?: string(name='RequestId'),
}

model DescribeParameterTemplatesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParameterTemplatesResponseBody(name='body'),
}

async function describeParameterTemplatesWithOptions(request: DescribeParameterTemplatesRequest, runtime: Util.RuntimeOptions): DescribeParameterTemplatesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameterTemplates',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameterTemplates(request: DescribeParameterTemplatesRequest): DescribeParameterTemplatesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParameterTemplatesWithOptions(request, runtime);
}

model DescribeParametersRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeParametersResponseBody = {
  configParameters?: {
    DBInstanceParameter?: [ 
    {
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='DBInstanceParameter')
  }(name='ConfigParameters'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  requestId?: string(name='RequestId'),
  runningParameters?: {
    DBInstanceParameter?: [ 
    {
      parameterDescription?: string(name='ParameterDescription'),
      parameterName?: string(name='ParameterName'),
      parameterValue?: string(name='ParameterValue'),
    }
  ](name='DBInstanceParameter')
  }(name='RunningParameters'),
}

model DescribeParametersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeParametersResponseBody(name='body'),
}

async function describeParametersWithOptions(request: DescribeParametersRequest, runtime: Util.RuntimeOptions): DescribeParametersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeParameters',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeParameters(request: DescribeParametersRequest): DescribeParametersResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeParametersWithOptions(request, runtime);
}

model DescribePriceRequest {
  clientToken?: string(name='ClientToken'),
  commodityCode?: string(name='CommodityCode'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  engine?: string(name='Engine'),
  engineVersion?: string(name='EngineVersion'),
  instanceUsedType?: int32(name='InstanceUsedType'),
  orderType?: string(name='OrderType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  quantity?: int32(name='Quantity'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  timeType?: string(name='TimeType'),
  usedTime?: int32(name='UsedTime'),
  zoneId?: string(name='ZoneId'),
}

model DescribePriceResponseBody = {
  priceInfo?: {
    activityInfo?: {
      checkErrMsg?: string(name='CheckErrMsg'),
      errorCode?: string(name='ErrorCode'),
      success?: string(name='Success'),
    }(name='ActivityInfo'),
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradePrice?: float(name='TradePrice'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribePriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePriceResponseBody(name='body'),
}

async function describePriceWithOptions(request: DescribePriceRequest, runtime: Util.RuntimeOptions): DescribePriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.instanceUsedType)) {
    query['InstanceUsedType'] = request.instanceUsedType;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.timeType)) {
    query['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribePrice',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePrice(request: DescribePriceRequest): DescribePriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePriceWithOptions(request, runtime);
}

model DescribeRdsResourceSettingsRequest {
  ownerId?: long(name='OwnerId'),
  resourceNiche?: string(name='ResourceNiche'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRdsResourceSettingsResponseBody = {
  rdsInstanceResourceSettings?: {
    rdsInstanceResourceSetting?: [ 
    {
      endDate?: string(name='EndDate'),
      isTop?: string(name='IsTop'),
      noticeBarContent?: string(name='NoticeBarContent'),
      poppedUpButtonText?: string(name='PoppedUpButtonText'),
      poppedUpButtonType?: string(name='PoppedUpButtonType'),
      poppedUpButtonUrl?: string(name='PoppedUpButtonUrl'),
      poppedUpContent?: string(name='PoppedUpContent'),
      resourceNiche?: string(name='ResourceNiche'),
      startDate?: string(name='StartDate'),
    }
  ](name='RdsInstanceResourceSetting')
  }(name='RdsInstanceResourceSettings'),
  requestId?: string(name='RequestId'),
}

model DescribeRdsResourceSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRdsResourceSettingsResponseBody(name='body'),
}

async function describeRdsResourceSettingsWithOptions(request: DescribeRdsResourceSettingsRequest, runtime: Util.RuntimeOptions): DescribeRdsResourceSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceNiche)) {
    query['ResourceNiche'] = request.resourceNiche;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRdsResourceSettings',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRdsResourceSettings(request: DescribeRdsResourceSettingsRequest): DescribeRdsResourceSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRdsResourceSettingsWithOptions(request, runtime);
}

model DescribeReadDBInstanceDelayRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  readInstanceId?: string(name='ReadInstanceId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeReadDBInstanceDelayResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  delayTime?: int32(name='DelayTime'),
  items?: {
    items?: [ 
    {
      DBInstanceId?: string(name='DBInstanceId'),
      readDBInstanceNames?: {
        readDBInstanceName?: [ string ](name='ReadDBInstanceName')
      }(name='ReadDBInstanceNames'),
      readDelayTimes?: {
        readDelayTime?: [ string ](name='ReadDelayTime')
      }(name='ReadDelayTimes'),
      readonlyInstanceDelay?: {
        readonlyInstanceDelay?: [ 
        {
          flushLag?: string(name='FlushLag'),
          flushLatency?: string(name='FlushLatency'),
          readDBInstanceName?: string(name='ReadDBInstanceName'),
          replayLag?: string(name='ReplayLag'),
          replayLatency?: string(name='ReplayLatency'),
          sendLatency?: string(name='SendLatency'),
          writeLag?: string(name='WriteLag'),
          writeLatency?: string(name='WriteLatency'),
        }
      ](name='ReadonlyInstanceDelay')
      }(name='ReadonlyInstanceDelay'),
    }
  ](name='Items')
  }(name='Items'),
  readDBInstanceId?: string(name='ReadDBInstanceId'),
  requestId?: string(name='RequestId'),
}

model DescribeReadDBInstanceDelayResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeReadDBInstanceDelayResponseBody(name='body'),
}

async function describeReadDBInstanceDelayWithOptions(request: DescribeReadDBInstanceDelayRequest, runtime: Util.RuntimeOptions): DescribeReadDBInstanceDelayResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readInstanceId)) {
    query['ReadInstanceId'] = request.readInstanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeReadDBInstanceDelay',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeReadDBInstanceDelay(request: DescribeReadDBInstanceDelayRequest): DescribeReadDBInstanceDelayResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeReadDBInstanceDelayWithOptions(request, runtime);
}

model DescribeRegionInfosRequest {
  clientToken?: string(name='ClientToken'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionInfosResponseBody = {
  regions?: {
    RDSRegion?: [ 
    {
      regionId?: string(name='RegionId'),
    }
  ](name='RDSRegion')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionInfosResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionInfosResponseBody(name='body'),
}

async function describeRegionInfosWithOptions(request: DescribeRegionInfosRequest, runtime: Util.RuntimeOptions): DescribeRegionInfosResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegionInfos',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegionInfos(request: DescribeRegionInfosRequest): DescribeRegionInfosResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionInfosWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: {
    RDSRegion?: [ 
    {
      localName?: string(name='LocalName'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
      zoneName?: string(name='ZoneName'),
    }
  ](name='RDSRegion')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRenewalPriceRequest {
  businessInfo?: string(name='BusinessInfo'),
  clientToken?: string(name='ClientToken'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderType?: string(name='OrderType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  quantity?: int32(name='Quantity'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  timeType?: string(name='TimeType'),
  usedTime?: int32(name='UsedTime'),
}

model DescribeRenewalPriceResponseBody = {
  priceInfo?: {
    activityInfo?: {
      checkErrMsg?: string(name='CheckErrMsg'),
      errorCode?: string(name='ErrorCode'),
      success?: string(name='Success'),
    }(name='ActivityInfo'),
    coupons?: {
      coupon?: [ 
      {
        couponNo?: string(name='CouponNo'),
        description?: string(name='Description'),
        isSelected?: string(name='IsSelected'),
        name?: string(name='Name'),
      }
    ](name='Coupon')
    }(name='Coupons'),
    currency?: string(name='Currency'),
    discountPrice?: float(name='DiscountPrice'),
    originalPrice?: float(name='OriginalPrice'),
    ruleIds?: {
      ruleId?: [ string ](name='RuleId')
    }(name='RuleIds'),
    tradePrice?: float(name='TradePrice'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
  rules?: {
    rule?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      ruleId?: long(name='RuleId'),
    }
  ](name='Rule')
  }(name='Rules'),
}

model DescribeRenewalPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRenewalPriceResponseBody(name='body'),
}

async function describeRenewalPriceWithOptions(request: DescribeRenewalPriceRequest, runtime: Util.RuntimeOptions): DescribeRenewalPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.quantity)) {
    query['Quantity'] = request.quantity;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.timeType)) {
    query['TimeType'] = request.timeType;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRenewalPrice',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRenewalPrice(request: DescribeRenewalPriceRequest): DescribeRenewalPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRenewalPriceWithOptions(request, runtime);
}

model DescribeResourceUsageRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeResourceUsageResponseBody = {
  archiveBackupSize?: long(name='ArchiveBackupSize'),
  backupDataSize?: long(name='BackupDataSize'),
  backupLogSize?: long(name='BackupLogSize'),
  backupOssDataSize?: long(name='BackupOssDataSize'),
  backupOssLogSize?: long(name='BackupOssLogSize'),
  backupSize?: long(name='BackupSize'),
  coldBackupSize?: long(name='ColdBackupSize'),
  DBInstanceId?: string(name='DBInstanceId'),
  dataSize?: long(name='DataSize'),
  diskUsed?: long(name='DiskUsed'),
  engine?: string(name='Engine'),
  logSize?: long(name='LogSize'),
  paidBackupSize?: long(name='PaidBackupSize'),
  requestId?: string(name='RequestId'),
  SQLSize?: long(name='SQLSize'),
}

model DescribeResourceUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeResourceUsageResponseBody(name='body'),
}

async function describeResourceUsageWithOptions(request: DescribeResourceUsageRequest, runtime: Util.RuntimeOptions): DescribeResourceUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeResourceUsage',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeResourceUsage(request: DescribeResourceUsageRequest): DescribeResourceUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeResourceUsageWithOptions(request, runtime);
}

model DescribeSQLCollectorPolicyRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus'),
  storagePeriod?: int32(name='StoragePeriod'),
}

model DescribeSQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLCollectorPolicyResponseBody(name='body'),
}

async function describeSQLCollectorPolicyWithOptions(request: DescribeSQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): DescribeSQLCollectorPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLCollectorPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLCollectorPolicy(request: DescribeSQLCollectorPolicyRequest): DescribeSQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLCollectorPolicyWithOptions(request, runtime);
}

model DescribeSQLCollectorRetentionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model DescribeSQLCollectorRetentionResponseBody = {
  configValue?: string(name='ConfigValue'),
  requestId?: string(name='RequestId'),
}

model DescribeSQLCollectorRetentionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLCollectorRetentionResponseBody(name='body'),
}

async function describeSQLCollectorRetentionWithOptions(request: DescribeSQLCollectorRetentionRequest, runtime: Util.RuntimeOptions): DescribeSQLCollectorRetentionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLCollectorRetention',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLCollectorRetention(request: DescribeSQLCollectorRetentionRequest): DescribeSQLCollectorRetentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLCollectorRetentionWithOptions(request, runtime);
}

model DescribeSQLLogFilesRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  fileName?: string(name='FileName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSQLLogFilesResponseBody = {
  items?: {
    logFile?: [ 
    {
      fileID?: string(name='FileID'),
      logDownloadURL?: string(name='LogDownloadURL'),
      logEndTime?: string(name='LogEndTime'),
      logSize?: string(name='LogSize'),
      logStartTime?: string(name='LogStartTime'),
      logStatus?: string(name='LogStatus'),
    }
  ](name='LogFile')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLLogFilesResponseBody(name='body'),
}

async function describeSQLLogFilesWithOptions(request: DescribeSQLLogFilesRequest, runtime: Util.RuntimeOptions): DescribeSQLLogFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLLogFiles',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLLogFiles(request: DescribeSQLLogFilesRequest): DescribeSQLLogFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogFilesWithOptions(request, runtime);
}

model DescribeSQLLogRecordsRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  database?: string(name='Database'),
  endTime?: string(name='EndTime'),
  form?: string(name='Form'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  queryKeywords?: string(name='QueryKeywords'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SQLId?: long(name='SQLId'),
  startTime?: string(name='StartTime'),
  user?: string(name='User'),
}

model DescribeSQLLogRecordsResponseBody = {
  items?: {
    SQLRecord?: [ 
    {
      accountName?: string(name='AccountName'),
      DBName?: string(name='DBName'),
      executeTime?: string(name='ExecuteTime'),
      hostAddress?: string(name='HostAddress'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      SQLText?: string(name='SQLText'),
      threadID?: string(name='ThreadID'),
      totalExecutionTimes?: long(name='TotalExecutionTimes'),
    }
  ](name='SQLRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: long(name='TotalRecordCount'),
}

model DescribeSQLLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLLogRecordsResponseBody(name='body'),
}

async function describeSQLLogRecordsWithOptions(request: DescribeSQLLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSQLLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.database)) {
    query['Database'] = request.database;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.form)) {
    query['Form'] = request.form;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.queryKeywords)) {
    query['QueryKeywords'] = request.queryKeywords;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SQLId)) {
    query['SQLId'] = request.SQLId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.user)) {
    query['User'] = request.user;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLLogRecords',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLLogRecords(request: DescribeSQLLogRecordsRequest): DescribeSQLLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogRecordsWithOptions(request, runtime);
}

model DescribeSQLLogReportListRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeSQLLogReportListResponseBody = {
  items?: {
    item?: [ 
    {
      latencyTopNItems?: {
        latencyTopNItem?: [ 
        {
          avgLatency?: long(name='AvgLatency'),
          SQLExecuteTimes?: long(name='SQLExecuteTimes'),
          SQLText?: string(name='SQLText'),
        }
      ](name='LatencyTopNItem')
      }(name='LatencyTopNItems'),
      QPSTopNItems?: {
        QPSTopNItem?: [ 
        {
          SQLExecuteTimes?: long(name='SQLExecuteTimes'),
          SQLText?: string(name='SQLText'),
        }
      ](name='QPSTopNItem')
      }(name='QPSTopNItems'),
      reportTime?: string(name='ReportTime'),
    }
  ](name='Item')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSQLLogReportListResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSQLLogReportListResponseBody(name='body'),
}

async function describeSQLLogReportListWithOptions(request: DescribeSQLLogReportListRequest, runtime: Util.RuntimeOptions): DescribeSQLLogReportListResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSQLLogReportList',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSQLLogReportList(request: DescribeSQLLogReportListRequest): DescribeSQLLogReportListResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSQLLogReportListWithOptions(request, runtime);
}

model DescribeSecretsRequest {
  acceptLanguage?: string(name='AcceptLanguage'),
  clientToken?: string(name='ClientToken'),
  dbInstanceId?: string(name='DbInstanceId'),
  engine?: string(name='Engine'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSecretsResponseBody = {
  pageNumber?: long(name='PageNumber'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  secrets?: [ 
    {
      accountId?: string(name='AccountId'),
      description?: string(name='Description'),
      regionId?: string(name='RegionId'),
      secretArn?: string(name='SecretArn'),
      secretName?: string(name='SecretName'),
      username?: string(name='Username'),
    }
  ](name='Secrets'),
}

model DescribeSecretsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecretsResponseBody(name='body'),
}

async function describeSecretsWithOptions(request: DescribeSecretsRequest, runtime: Util.RuntimeOptions): DescribeSecretsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acceptLanguage)) {
    query['AcceptLanguage'] = request.acceptLanguage;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.engine)) {
    query['Engine'] = request.engine;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecrets',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecrets(request: DescribeSecretsRequest): DescribeSecretsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecretsWithOptions(request, runtime);
}

model DescribeSecurityGroupConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeSecurityGroupConfigurationResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    ecsSecurityGroupRelation?: [ 
    {
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='EcsSecurityGroupRelation')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeSecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSecurityGroupConfigurationResponseBody(name='body'),
}

async function describeSecurityGroupConfigurationWithOptions(request: DescribeSecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): DescribeSecurityGroupConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSecurityGroupConfiguration',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSecurityGroupConfiguration(request: DescribeSecurityGroupConfigurationRequest): DescribeSecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSecurityGroupConfigurationWithOptions(request, runtime);
}

model DescribeSlowLogRecordsRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SQLHASH?: string(name='SQLHASH'),
  startTime?: string(name='StartTime'),
}

model DescribeSlowLogRecordsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  engine?: string(name='Engine'),
  items?: {
    SQLSlowRecord?: [ 
    {
      applicationName?: string(name='ApplicationName'),
      clientHostName?: string(name='ClientHostName'),
      cpuTime?: long(name='CpuTime'),
      DBName?: string(name='DBName'),
      executionStartTime?: string(name='ExecutionStartTime'),
      hostAddress?: string(name='HostAddress'),
      lastRowsAffectedCount?: long(name='LastRowsAffectedCount'),
      lockTimes?: long(name='LockTimes'),
      logicalIORead?: long(name='LogicalIORead'),
      parseRowCounts?: long(name='ParseRowCounts'),
      physicalIORead?: long(name='PhysicalIORead'),
      queryTimeMS?: long(name='QueryTimeMS'),
      queryTimes?: long(name='QueryTimes'),
      returnRowCounts?: long(name='ReturnRowCounts'),
      rowsAffectedCount?: long(name='RowsAffectedCount'),
      SQLHash?: string(name='SQLHash'),
      SQLText?: string(name='SQLText'),
      userName?: string(name='UserName'),
      writeIOCount?: long(name='WriteIOCount'),
    }
  ](name='SQLSlowRecord')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSlowLogRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowLogRecordsResponseBody(name='body'),
}

async function describeSlowLogRecordsWithOptions(request: DescribeSlowLogRecordsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SQLHASH)) {
    query['SQLHASH'] = request.SQLHASH;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogRecords',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlowLogRecords(request: DescribeSlowLogRecordsRequest): DescribeSlowLogRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogRecordsWithOptions(request, runtime);
}

model DescribeSlowLogsRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sortKey?: string(name='SortKey'),
  startTime?: string(name='StartTime'),
}

model DescribeSlowLogsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  engine?: string(name='Engine'),
  items?: {
    SQLSlowLog?: [ 
    {
      avgExecutionTime?: long(name='AvgExecutionTime'),
      avgIOWriteCounts?: long(name='AvgIOWriteCounts'),
      avgLastRowsAffectedCounts?: long(name='AvgLastRowsAffectedCounts'),
      avgLogicalReadCounts?: long(name='AvgLogicalReadCounts'),
      avgPhysicalReadCounts?: long(name='AvgPhysicalReadCounts'),
      avgRowsAffectedCounts?: long(name='AvgRowsAffectedCounts'),
      createTime?: string(name='CreateTime'),
      DBName?: string(name='DBName'),
      maxExecutionTime?: long(name='MaxExecutionTime'),
      maxIOWriteCounts?: long(name='MaxIOWriteCounts'),
      maxLastRowsAffectedCounts?: long(name='MaxLastRowsAffectedCounts'),
      maxLockTime?: long(name='MaxLockTime'),
      maxLogicalReadCounts?: long(name='MaxLogicalReadCounts'),
      maxPhysicalReadCounts?: long(name='MaxPhysicalReadCounts'),
      maxRowsAffectedCounts?: long(name='MaxRowsAffectedCounts'),
      minIOWriteCounts?: long(name='MinIOWriteCounts'),
      minLastRowsAffectedCounts?: long(name='MinLastRowsAffectedCounts'),
      minLogicalReadCounts?: long(name='MinLogicalReadCounts'),
      minPhysicalReadCounts?: long(name='MinPhysicalReadCounts'),
      minRowsAffectedCounts?: long(name='MinRowsAffectedCounts'),
      mySQLTotalExecutionCounts?: long(name='MySQLTotalExecutionCounts'),
      mySQLTotalExecutionTimes?: long(name='MySQLTotalExecutionTimes'),
      parseMaxRowCount?: long(name='ParseMaxRowCount'),
      parseTotalRowCounts?: long(name='ParseTotalRowCounts'),
      reportTime?: string(name='ReportTime'),
      returnMaxRowCount?: long(name='ReturnMaxRowCount'),
      returnTotalRowCounts?: long(name='ReturnTotalRowCounts'),
      SQLHASH?: string(name='SQLHASH'),
      SQLIdStr?: string(name='SQLIdStr'),
      SQLServerAvgCpuTime?: long(name='SQLServerAvgCpuTime'),
      SQLServerAvgExecutionTime?: long(name='SQLServerAvgExecutionTime'),
      SQLServerMaxCpuTime?: long(name='SQLServerMaxCpuTime'),
      SQLServerMinCpuTime?: long(name='SQLServerMinCpuTime'),
      SQLServerMinExecutionTime?: long(name='SQLServerMinExecutionTime'),
      SQLServerTotalCpuTime?: long(name='SQLServerTotalCpuTime'),
      SQLServerTotalExecutionCounts?: long(name='SQLServerTotalExecutionCounts'),
      SQLServerTotalExecutionTimes?: long(name='SQLServerTotalExecutionTimes'),
      SQLText?: string(name='SQLText'),
      slowLogId?: long(name='SlowLogId'),
      totalIOWriteCounts?: long(name='TotalIOWriteCounts'),
      totalLastRowsAffectedCounts?: long(name='TotalLastRowsAffectedCounts'),
      totalLockTimes?: long(name='TotalLockTimes'),
      totalLogicalReadCounts?: long(name='TotalLogicalReadCounts'),
      totalPhysicalReadCounts?: long(name='TotalPhysicalReadCounts'),
      totalRowsAffectedCounts?: long(name='TotalRowsAffectedCounts'),
    }
  ](name='SQLSlowLog')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  startTime?: string(name='StartTime'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeSlowLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeSlowLogsResponseBody(name='body'),
}

async function describeSlowLogsWithOptions(request: DescribeSlowLogsRequest, runtime: Util.RuntimeOptions): DescribeSlowLogsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sortKey)) {
    query['SortKey'] = request.sortKey;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeSlowLogs',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeSlowLogs(request: DescribeSlowLogsRequest): DescribeSlowLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeSlowLogsWithOptions(request, runtime);
}

model DescribeTagsRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tags?: string(name='Tags'),
  proxyId?: string(name='proxyId'),
}

model DescribeTagsResponseBody = {
  items?: {
    tagInfos?: [ 
    {
      DBInstanceIds?: {
        DBInstanceIds?: [ string ](name='DBInstanceIds')
      }(name='DBInstanceIds'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagInfos')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model DescribeTagsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTagsResponseBody(name='body'),
}

async function describeTagsWithOptions(request: DescribeTagsRequest, runtime: Util.RuntimeOptions): DescribeTagsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTags',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTags(request: DescribeTagsRequest): DescribeTagsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTagsWithOptions(request, runtime);
}

model DescribeTasksRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
  status?: string(name='Status'),
  taskAction?: string(name='TaskAction'),
}

model DescribeTasksResponseBody = {
  items?: {
    taskProgressInfo?: [ 
    {
      beginTime?: string(name='BeginTime'),
      currentStepName?: string(name='CurrentStepName'),
      DBName?: string(name='DBName'),
      expectedFinishTime?: string(name='ExpectedFinishTime'),
      finishTime?: string(name='FinishTime'),
      progress?: string(name='Progress'),
      progressInfo?: string(name='ProgressInfo'),
      remain?: int32(name='Remain'),
      status?: string(name='Status'),
      stepProgressInfo?: string(name='StepProgressInfo'),
      stepsInfo?: string(name='StepsInfo'),
      taskAction?: string(name='TaskAction'),
      taskErrorCode?: string(name='TaskErrorCode'),
      taskErrorMessage?: string(name='TaskErrorMessage'),
      taskId?: string(name='TaskId'),
    }
  ](name='TaskProgressInfo')
  }(name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTasksResponseBody(name='body'),
}

async function describeTasksWithOptions(request: DescribeTasksRequest, runtime: Util.RuntimeOptions): DescribeTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.taskAction)) {
    query['TaskAction'] = request.taskAction;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTasks',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTasks(request: DescribeTasksRequest): DescribeTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTasksWithOptions(request, runtime);
}

model DescribeUpgradeMajorVersionPrecheckTaskRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
  taskId?: int32(name='TaskId'),
}

model DescribeUpgradeMajorVersionPrecheckTaskResponseBody = {
  items?: [ 
    {
      checkTime?: string(name='CheckTime'),
      detail?: string(name='Detail'),
      effectiveTime?: string(name='EffectiveTime'),
      result?: string(name='Result'),
      sourceMajorVersion?: string(name='SourceMajorVersion'),
      targetMajorVersion?: string(name='TargetMajorVersion'),
      taskId?: int32(name='TaskId'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeUpgradeMajorVersionPrecheckTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeMajorVersionPrecheckTaskResponseBody(name='body'),
}

async function describeUpgradeMajorVersionPrecheckTaskWithOptions(request: DescribeUpgradeMajorVersionPrecheckTaskRequest, runtime: Util.RuntimeOptions): DescribeUpgradeMajorVersionPrecheckTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetMajorVersion)) {
    query['TargetMajorVersion'] = request.targetMajorVersion;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeMajorVersionPrecheckTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUpgradeMajorVersionPrecheckTask(request: DescribeUpgradeMajorVersionPrecheckTaskRequest): DescribeUpgradeMajorVersionPrecheckTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeMajorVersionPrecheckTaskWithOptions(request, runtime);
}

model DescribeUpgradeMajorVersionTasksRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
  taskId?: int32(name='TaskId'),
}

model DescribeUpgradeMajorVersionTasksResponseBody = {
  items?: [ 
    {
      collectStatMode?: string(name='CollectStatMode'),
      detail?: string(name='Detail'),
      endTime?: string(name='EndTime'),
      result?: string(name='Result'),
      sourceInsName?: string(name='SourceInsName'),
      sourceMajorVersion?: string(name='SourceMajorVersion'),
      startTime?: string(name='StartTime'),
      switchTime?: string(name='SwitchTime'),
      targetInsName?: string(name='TargetInsName'),
      targetMajorVersion?: string(name='TargetMajorVersion'),
      taskId?: int32(name='TaskId'),
      upgradeMode?: string(name='UpgradeMode'),
    }
  ](name='Items'),
  pageNumber?: int32(name='PageNumber'),
  pageRecordCount?: int32(name='PageRecordCount'),
  requestId?: string(name='RequestId'),
  totalRecordCount?: int32(name='TotalRecordCount'),
}

model DescribeUpgradeMajorVersionTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUpgradeMajorVersionTasksResponseBody(name='body'),
}

async function describeUpgradeMajorVersionTasksWithOptions(request: DescribeUpgradeMajorVersionTasksRequest, runtime: Util.RuntimeOptions): DescribeUpgradeMajorVersionTasksResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetMajorVersion)) {
    query['TargetMajorVersion'] = request.targetMajorVersion;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUpgradeMajorVersionTasks',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUpgradeMajorVersionTasks(request: DescribeUpgradeMajorVersionTasksRequest): DescribeUpgradeMajorVersionTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUpgradeMajorVersionTasksWithOptions(request, runtime);
}

model DescribeVSwitchesRequest {
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
  vpcId?: string(name='VpcId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVSwitchesResponseBody = {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  vSwitchs?: [ 
    {
      cidrBlock?: string(name='CidrBlock'),
      description?: string(name='Description'),
      isDefault?: boolean(name='IsDefault'),
      izNo?: string(name='IzNo'),
      status?: string(name='Status'),
      vSwitchId?: string(name='VSwitchId'),
      vSwitchName?: string(name='VSwitchName'),
    }
  ](name='VSwitchs'),
}

model DescribeVSwitchesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVSwitchesResponseBody(name='body'),
}

async function describeVSwitchesWithOptions(request: DescribeVSwitchesRequest, runtime: Util.RuntimeOptions): DescribeVSwitchesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.vpcId)) {
    query['VpcId'] = request.vpcId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVSwitches',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVSwitches(request: DescribeVSwitchesRequest): DescribeVSwitchesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVSwitchesWithOptions(request, runtime);
}

model DestroyDBInstanceRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DestroyDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DestroyDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DestroyDBInstanceResponseBody(name='body'),
}

async function destroyDBInstanceWithOptions(request: DestroyDBInstanceRequest, runtime: Util.RuntimeOptions): DestroyDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DestroyDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function destroyDBInstance(request: DestroyDBInstanceRequest): DestroyDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return destroyDBInstanceWithOptions(request, runtime);
}

model DetachGadInstanceMemberRequest {
  gadInstanceName?: string(name='GadInstanceName'),
  memberInstanceName?: string(name='MemberInstanceName'),
  regionId?: string(name='RegionId'),
}

model DetachGadInstanceMemberResponseBody = {
  requestId?: string(name='RequestId'),
}

model DetachGadInstanceMemberResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachGadInstanceMemberResponseBody(name='body'),
}

async function detachGadInstanceMemberWithOptions(request: DetachGadInstanceMemberRequest, runtime: Util.RuntimeOptions): DetachGadInstanceMemberResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.gadInstanceName)) {
    query['GadInstanceName'] = request.gadInstanceName;
  }
  if (!Util.isUnset(request.memberInstanceName)) {
    query['MemberInstanceName'] = request.memberInstanceName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachGadInstanceMember',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachGadInstanceMember(request: DetachGadInstanceMemberRequest): DetachGadInstanceMemberResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachGadInstanceMemberWithOptions(request, runtime);
}

model GetDBInstanceTopologyRequest {
  DBInstanceId?: string(name='DBInstanceId'),
}

model GetDBInstanceTopologyResponseBody = {
  code?: string(name='Code'),
  data?: {
    connections?: [ 
      {
        connectionString?: string(name='ConnectionString'),
        DBInstanceName?: string(name='DBInstanceName'),
        netType?: string(name='NetType'),
        zoneId?: string(name='ZoneId'),
      }
    ](name='Connections'),
    DBInstanceName?: string(name='DBInstanceName'),
    nodes?: [ 
      {
        DBInstanceName?: string(name='DBInstanceName'),
        dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
        dedicatedHostId?: string(name='DedicatedHostId'),
        nodeId?: string(name='NodeId'),
        role?: string(name='Role'),
        zoneId?: string(name='ZoneId'),
      }
    ](name='Nodes'),
  }(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model GetDBInstanceTopologyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDBInstanceTopologyResponseBody(name='body'),
}

async function getDBInstanceTopologyWithOptions(request: GetDBInstanceTopologyRequest, runtime: Util.RuntimeOptions): GetDBInstanceTopologyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDBInstanceTopology',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDBInstanceTopology(request: GetDBInstanceTopologyRequest): GetDBInstanceTopologyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDBInstanceTopologyWithOptions(request, runtime);
}

model GetDbProxyInstanceSslRequest {
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  dbInstanceId?: string(name='DbInstanceId'),
  regionId?: string(name='RegionId'),
}

model GetDbProxyInstanceSslResponseBody = {
  dbProxyCertListItems?: {
    dbProxyCertListItems?: [ 
    {
      certCommonName?: string(name='CertCommonName'),
      dbInstanceName?: string(name='DbInstanceName'),
      endpointName?: string(name='EndpointName'),
      endpointType?: string(name='EndpointType'),
      sslExpiredTime?: string(name='SslExpiredTime'),
    }
  ](name='DbProxyCertListItems')
  }(name='DbProxyCertListItems'),
  requestId?: string(name='RequestId'),
}

model GetDbProxyInstanceSslResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDbProxyInstanceSslResponseBody(name='body'),
}

async function getDbProxyInstanceSslWithOptions(request: GetDbProxyInstanceSslRequest, runtime: Util.RuntimeOptions): GetDbProxyInstanceSslResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDbProxyInstanceSsl',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDbProxyInstanceSsl(request: GetDbProxyInstanceSslRequest): GetDbProxyInstanceSslResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDbProxyInstanceSslWithOptions(request, runtime);
}

model GrantAccountPrivilegeRequest {
  accountName?: string(name='AccountName'),
  accountPrivilege?: string(name='AccountPrivilege'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantAccountPrivilegeResponseBody(name='body'),
}

async function grantAccountPrivilegeWithOptions(request: GrantAccountPrivilegeRequest, runtime: Util.RuntimeOptions): GrantAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPrivilege)) {
    query['AccountPrivilege'] = request.accountPrivilege;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantAccountPrivilege',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantAccountPrivilege(request: GrantAccountPrivilegeRequest): GrantAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantAccountPrivilegeWithOptions(request, runtime);
}

model GrantOperatorPermissionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  expiredTime?: string(name='ExpiredTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privileges?: string(name='Privileges'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model GrantOperatorPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model GrantOperatorPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GrantOperatorPermissionResponseBody(name='body'),
}

async function grantOperatorPermissionWithOptions(request: GrantOperatorPermissionRequest, runtime: Util.RuntimeOptions): GrantOperatorPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.expiredTime)) {
    query['ExpiredTime'] = request.expiredTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privileges)) {
    query['Privileges'] = request.privileges;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GrantOperatorPermission',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function grantOperatorPermission(request: GrantOperatorPermissionRequest): GrantOperatorPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return grantOperatorPermissionWithOptions(request, runtime);
}

model ImportDatabaseBetweenInstancesRequest {
  DBInfo?: string(name='DBInfo'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sourceDBInstanceId?: string(name='SourceDBInstanceId'),
}

model ImportDatabaseBetweenInstancesResponseBody = {
  importId?: string(name='ImportId'),
  requestId?: string(name='RequestId'),
}

model ImportDatabaseBetweenInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportDatabaseBetweenInstancesResponseBody(name='body'),
}

async function importDatabaseBetweenInstancesWithOptions(request: ImportDatabaseBetweenInstancesRequest, runtime: Util.RuntimeOptions): ImportDatabaseBetweenInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInfo)) {
    query['DBInfo'] = request.DBInfo;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sourceDBInstanceId)) {
    query['SourceDBInstanceId'] = request.sourceDBInstanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportDatabaseBetweenInstances',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importDatabaseBetweenInstances(request: ImportDatabaseBetweenInstancesRequest): ImportDatabaseBetweenInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return importDatabaseBetweenInstancesWithOptions(request, runtime);
}

model ImportUserBackupFileRequest {
  backupFile?: string(name='BackupFile'),
  bucketRegion?: string(name='BucketRegion'),
  comment?: string(name='Comment'),
  engineVersion?: string(name='EngineVersion'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreSize?: int32(name='RestoreSize'),
  retention?: int32(name='Retention'),
  zoneId?: string(name='ZoneId'),
}

model ImportUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
  status?: boolean(name='Status'),
}

model ImportUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ImportUserBackupFileResponseBody(name='body'),
}

async function importUserBackupFileWithOptions(request: ImportUserBackupFileRequest, runtime: Util.RuntimeOptions): ImportUserBackupFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupFile)) {
    query['BackupFile'] = request.backupFile;
  }
  if (!Util.isUnset(request.bucketRegion)) {
    query['BucketRegion'] = request.bucketRegion;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreSize)) {
    query['RestoreSize'] = request.restoreSize;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ImportUserBackupFile',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function importUserBackupFile(request: ImportUserBackupFileRequest): ImportUserBackupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return importUserBackupFileWithOptions(request, runtime);
}

model ListClassesRequest {
  clientToken?: string(name='ClientToken'),
  commodityCode?: string(name='CommodityCode'),
  DBInstanceId?: string(name='DBInstanceId'),
  orderType?: string(name='OrderType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListClassesResponseBody = {
  items?: [ 
    {
      classCode?: string(name='ClassCode'),
      classGroup?: string(name='ClassGroup'),
      cpu?: string(name='Cpu'),
      encryptedMemory?: string(name='EncryptedMemory'),
      instructionSetArch?: string(name='InstructionSetArch'),
      maxConnections?: string(name='MaxConnections'),
      maxIOMBPS?: string(name='MaxIOMBPS'),
      maxIOPS?: string(name='MaxIOPS'),
      memoryClass?: string(name='MemoryClass'),
      referencePrice?: string(name='ReferencePrice'),
    }
  ](name='Items'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model ListClassesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListClassesResponseBody(name='body'),
}

async function listClassesWithOptions(request: ListClassesRequest, runtime: Util.RuntimeOptions): ListClassesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.commodityCode)) {
    query['CommodityCode'] = request.commodityCode;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.orderType)) {
    query['OrderType'] = request.orderType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListClasses',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listClasses(request: ListClassesRequest): ListClassesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listClassesWithOptions(request, runtime);
}

model ListTagResourcesRequest {
  nextToken?: string(name='NextToken'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model ListTagResourcesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  tagResources?: {
    tagResource?: [ 
    {
      resourceId?: string(name='ResourceId'),
      resourceType?: string(name='ResourceType'),
      tagKey?: string(name='TagKey'),
      tagValue?: string(name='TagValue'),
    }
  ](name='TagResource')
  }(name='TagResources'),
}

model ListTagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTagResourcesResponseBody(name='body'),
}

async function listTagResourcesWithOptions(request: ListTagResourcesRequest, runtime: Util.RuntimeOptions): ListTagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTagResources',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTagResources(request: ListTagResourcesRequest): ListTagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTagResourcesWithOptions(request, runtime);
}

model ListUserBackupFilesRequest {
  backupId?: string(name='BackupId'),
  comment?: string(name='Comment'),
  ossUrl?: string(name='OssUrl'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
  tags?: string(name='Tags'),
}

model ListUserBackupFilesResponseBody = {
  records?: [ 
    {
      backupId?: string(name='BackupId'),
      binlogInfo?: string(name='BinlogInfo'),
      comment?: string(name='Comment'),
      creationTime?: string(name='CreationTime'),
      engine?: string(name='Engine'),
      engineVersion?: string(name='EngineVersion'),
      finishTime?: string(name='FinishTime'),
      modificationTime?: string(name='ModificationTime'),
      ossBucket?: string(name='OssBucket'),
      ossFileMetaData?: string(name='OssFileMetaData'),
      ossFileName?: string(name='OssFileName'),
      ossFilePath?: string(name='OssFilePath'),
      ossFileSize?: long(name='OssFileSize'),
      ossUrl?: string(name='OssUrl'),
      reason?: string(name='Reason'),
      restoreSize?: string(name='RestoreSize'),
      retention?: int32(name='Retention'),
      status?: string(name='Status'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Records'),
  requestId?: string(name='RequestId'),
}

model ListUserBackupFilesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUserBackupFilesResponseBody(name='body'),
}

async function listUserBackupFilesWithOptions(request: ListUserBackupFilesRequest, runtime: Util.RuntimeOptions): ListUserBackupFilesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.ossUrl)) {
    query['OssUrl'] = request.ossUrl;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUserBackupFiles',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUserBackupFiles(request: ListUserBackupFilesRequest): ListUserBackupFilesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUserBackupFilesWithOptions(request, runtime);
}

model LockAccountRequest {
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model LockAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LockAccountResponseBody(name='body'),
}

async function lockAccountWithOptions(request: LockAccountRequest, runtime: Util.RuntimeOptions): LockAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LockAccount',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function lockAccount(request: LockAccountRequest): LockAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return lockAccountWithOptions(request, runtime);
}

model MigrateConnectionToOtherZoneRequest {
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  zoneId?: string(name='ZoneId'),
}

model MigrateConnectionToOtherZoneResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
}

model MigrateConnectionToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateConnectionToOtherZoneResponseBody(name='body'),
}

async function migrateConnectionToOtherZoneWithOptions(request: MigrateConnectionToOtherZoneRequest, runtime: Util.RuntimeOptions): MigrateConnectionToOtherZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateConnectionToOtherZone',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateConnectionToOtherZone(request: MigrateConnectionToOtherZoneRequest): MigrateConnectionToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateConnectionToOtherZoneWithOptions(request, runtime);
}

model MigrateDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  effectiveTime?: string(name='EffectiveTime'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  specifiedTime?: string(name='SpecifiedTime'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  zoneIdForFollower?: string(name='ZoneIdForFollower'),
  zoneIdForLog?: string(name='ZoneIdForLog'),
}

model MigrateDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model MigrateDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateDBInstanceResponseBody(name='body'),
}

async function migrateDBInstanceWithOptions(request: MigrateDBInstanceRequest, runtime: Util.RuntimeOptions): MigrateDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.specifiedTime)) {
    query['SpecifiedTime'] = request.specifiedTime;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForMaster)) {
    query['TargetDedicatedHostIdForMaster'] = request.targetDedicatedHostIdForMaster;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForSlave)) {
    query['TargetDedicatedHostIdForSlave'] = request.targetDedicatedHostIdForSlave;
  }
  if (!Util.isUnset(request.zoneIdForFollower)) {
    query['ZoneIdForFollower'] = request.zoneIdForFollower;
  }
  if (!Util.isUnset(request.zoneIdForLog)) {
    query['ZoneIdForLog'] = request.zoneIdForLog;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateDBInstance(request: MigrateDBInstanceRequest): MigrateDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateDBInstanceWithOptions(request, runtime);
}

model MigrateSecurityIPModeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model MigrateSecurityIPModeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  securityIPMode?: string(name='SecurityIPMode'),
}

model MigrateSecurityIPModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateSecurityIPModeResponseBody(name='body'),
}

async function migrateSecurityIPModeWithOptions(request: MigrateSecurityIPModeRequest, runtime: Util.RuntimeOptions): MigrateSecurityIPModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateSecurityIPMode',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateSecurityIPMode(request: MigrateSecurityIPModeRequest): MigrateSecurityIPModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateSecurityIPModeWithOptions(request, runtime);
}

model MigrateToOtherZoneRequest {
  category?: string(name='Category'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: long(name='DBInstanceStorage'),
  effectiveTime?: string(name='EffectiveTime'),
  isModifySpec?: string(name='IsModifySpec'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
}

model MigrateToOtherZoneResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model MigrateToOtherZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: MigrateToOtherZoneResponseBody(name='body'),
}

async function migrateToOtherZoneWithOptions(request: MigrateToOtherZoneRequest, runtime: Util.RuntimeOptions): MigrateToOtherZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.isModifySpec)) {
    query['IsModifySpec'] = request.isModifySpec;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.zoneIdSlave1)) {
    query['ZoneIdSlave1'] = request.zoneIdSlave1;
  }
  if (!Util.isUnset(request.zoneIdSlave2)) {
    query['ZoneIdSlave2'] = request.zoneIdSlave2;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'MigrateToOtherZone',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function migrateToOtherZone(request: MigrateToOtherZoneRequest): MigrateToOtherZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return migrateToOtherZoneWithOptions(request, runtime);
}

model ModifyADInfoRequest {
  ADAccountName?: string(name='ADAccountName'),
  ADDNS?: string(name='ADDNS'),
  ADPassword?: string(name='ADPassword'),
  ADServerIpAddress?: string(name='ADServerIpAddress'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyADInfoResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyADInfoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyADInfoResponseBody(name='body'),
}

async function modifyADInfoWithOptions(request: ModifyADInfoRequest, runtime: Util.RuntimeOptions): ModifyADInfoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ADAccountName)) {
    query['ADAccountName'] = request.ADAccountName;
  }
  if (!Util.isUnset(request.ADDNS)) {
    query['ADDNS'] = request.ADDNS;
  }
  if (!Util.isUnset(request.ADPassword)) {
    query['ADPassword'] = request.ADPassword;
  }
  if (!Util.isUnset(request.ADServerIpAddress)) {
    query['ADServerIpAddress'] = request.ADServerIpAddress;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyADInfo',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyADInfo(request: ModifyADInfoRequest): ModifyADInfoResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyADInfoWithOptions(request, runtime);
}

model ModifyAccountDescriptionRequest {
  accountDescription?: string(name='AccountDescription'),
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyAccountDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyAccountDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyAccountDescriptionResponseBody(name='body'),
}

async function modifyAccountDescriptionWithOptions(request: ModifyAccountDescriptionRequest, runtime: Util.RuntimeOptions): ModifyAccountDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountDescription)) {
    query['AccountDescription'] = request.accountDescription;
  }
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyAccountDescription',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyAccountDescription(request: ModifyAccountDescriptionRequest): ModifyAccountDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyAccountDescriptionWithOptions(request, runtime);
}

model ModifyActionEventPolicyRequest {
  enableEventLog?: string(name='EnableEventLog'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyActionEventPolicyResponseBody = {
  enableEventLog?: string(name='EnableEventLog'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
}

model ModifyActionEventPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyActionEventPolicyResponseBody(name='body'),
}

async function modifyActionEventPolicyWithOptions(request: ModifyActionEventPolicyRequest, runtime: Util.RuntimeOptions): ModifyActionEventPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.enableEventLog)) {
    query['EnableEventLog'] = request.enableEventLog;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyActionEventPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyActionEventPolicy(request: ModifyActionEventPolicyRequest): ModifyActionEventPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyActionEventPolicyWithOptions(request, runtime);
}

model ModifyBackupPolicyRequest {
  archiveBackupKeepCount?: int32(name='ArchiveBackupKeepCount'),
  archiveBackupKeepPolicy?: string(name='ArchiveBackupKeepPolicy'),
  archiveBackupRetentionPeriod?: string(name='ArchiveBackupRetentionPeriod'),
  backupInterval?: string(name='BackupInterval'),
  backupLog?: string(name='BackupLog'),
  backupMethod?: string(name='BackupMethod'),
  backupPolicyMode?: string(name='BackupPolicyMode'),
  backupRetentionPeriod?: string(name='BackupRetentionPeriod'),
  category?: string(name='Category'),
  compressType?: string(name='CompressType'),
  DBInstanceId?: string(name='DBInstanceId'),
  enableBackupLog?: string(name='EnableBackupLog'),
  enableIncrementDataBackup?: boolean(name='EnableIncrementDataBackup'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  localLogRetentionHours?: string(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  logBackupFrequency?: string(name='LogBackupFrequency'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber'),
  logBackupRetentionPeriod?: string(name='LogBackupRetentionPeriod'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  preferredBackupPeriod?: string(name='PreferredBackupPeriod'),
  preferredBackupTime?: string(name='PreferredBackupTime'),
  releasedKeepPolicy?: string(name='ReleasedKeepPolicy'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyBackupPolicyResponseBody = {
  compressType?: string(name='CompressType'),
  DBInstanceID?: string(name='DBInstanceID'),
  enableBackupLog?: string(name='EnableBackupLog'),
  highSpaceUsageProtection?: string(name='HighSpaceUsageProtection'),
  localLogRetentionHours?: int32(name='LocalLogRetentionHours'),
  localLogRetentionSpace?: string(name='LocalLogRetentionSpace'),
  logBackupLocalRetentionNumber?: int32(name='LogBackupLocalRetentionNumber'),
  requestId?: string(name='RequestId'),
}

model ModifyBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyBackupPolicyResponseBody(name='body'),
}

async function modifyBackupPolicyWithOptions(request: ModifyBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.archiveBackupKeepCount)) {
    query['ArchiveBackupKeepCount'] = request.archiveBackupKeepCount;
  }
  if (!Util.isUnset(request.archiveBackupKeepPolicy)) {
    query['ArchiveBackupKeepPolicy'] = request.archiveBackupKeepPolicy;
  }
  if (!Util.isUnset(request.archiveBackupRetentionPeriod)) {
    query['ArchiveBackupRetentionPeriod'] = request.archiveBackupRetentionPeriod;
  }
  if (!Util.isUnset(request.backupInterval)) {
    query['BackupInterval'] = request.backupInterval;
  }
  if (!Util.isUnset(request.backupLog)) {
    query['BackupLog'] = request.backupLog;
  }
  if (!Util.isUnset(request.backupMethod)) {
    query['BackupMethod'] = request.backupMethod;
  }
  if (!Util.isUnset(request.backupPolicyMode)) {
    query['BackupPolicyMode'] = request.backupPolicyMode;
  }
  if (!Util.isUnset(request.backupRetentionPeriod)) {
    query['BackupRetentionPeriod'] = request.backupRetentionPeriod;
  }
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.compressType)) {
    query['CompressType'] = request.compressType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.enableBackupLog)) {
    query['EnableBackupLog'] = request.enableBackupLog;
  }
  if (!Util.isUnset(request.enableIncrementDataBackup)) {
    query['EnableIncrementDataBackup'] = request.enableIncrementDataBackup;
  }
  if (!Util.isUnset(request.highSpaceUsageProtection)) {
    query['HighSpaceUsageProtection'] = request.highSpaceUsageProtection;
  }
  if (!Util.isUnset(request.localLogRetentionHours)) {
    query['LocalLogRetentionHours'] = request.localLogRetentionHours;
  }
  if (!Util.isUnset(request.localLogRetentionSpace)) {
    query['LocalLogRetentionSpace'] = request.localLogRetentionSpace;
  }
  if (!Util.isUnset(request.logBackupFrequency)) {
    query['LogBackupFrequency'] = request.logBackupFrequency;
  }
  if (!Util.isUnset(request.logBackupLocalRetentionNumber)) {
    query['LogBackupLocalRetentionNumber'] = request.logBackupLocalRetentionNumber;
  }
  if (!Util.isUnset(request.logBackupRetentionPeriod)) {
    query['LogBackupRetentionPeriod'] = request.logBackupRetentionPeriod;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.preferredBackupPeriod)) {
    query['PreferredBackupPeriod'] = request.preferredBackupPeriod;
  }
  if (!Util.isUnset(request.preferredBackupTime)) {
    query['PreferredBackupTime'] = request.preferredBackupTime;
  }
  if (!Util.isUnset(request.releasedKeepPolicy)) {
    query['ReleasedKeepPolicy'] = request.releasedKeepPolicy;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyBackupPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyBackupPolicy(request: ModifyBackupPolicyRequest): ModifyBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyBackupPolicyWithOptions(request, runtime);
}

model ModifyCollationTimeZoneRequest {
  collation?: string(name='Collation'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  timezone?: string(name='Timezone'),
}

model ModifyCollationTimeZoneResponseBody = {
  collation?: string(name='Collation'),
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
  timezone?: string(name='Timezone'),
}

model ModifyCollationTimeZoneResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyCollationTimeZoneResponseBody(name='body'),
}

async function modifyCollationTimeZoneWithOptions(request: ModifyCollationTimeZoneRequest, runtime: Util.RuntimeOptions): ModifyCollationTimeZoneResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collation)) {
    query['Collation'] = request.collation;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.timezone)) {
    query['Timezone'] = request.timezone;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyCollationTimeZone',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyCollationTimeZone(request: ModifyCollationTimeZoneRequest): ModifyCollationTimeZoneResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyCollationTimeZoneWithOptions(request, runtime);
}

model ModifyDBDescriptionRequest {
  DBDescription?: string(name='DBDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBDescriptionResponseBody(name='body'),
}

async function modifyDBDescriptionWithOptions(request: ModifyDBDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBDescription)) {
    query['DBDescription'] = request.DBDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBDescription',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBDescription(request: ModifyDBDescriptionRequest): ModifyDBDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBDescriptionWithOptions(request, runtime);
}

model ModifyDBInstanceAutoUpgradeMinorVersionRequest {
  autoUpgradeMinorVersion?: string(name='AutoUpgradeMinorVersion'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceAutoUpgradeMinorVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceAutoUpgradeMinorVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceAutoUpgradeMinorVersionResponseBody(name='body'),
}

async function modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request: ModifyDBInstanceAutoUpgradeMinorVersionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceAutoUpgradeMinorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoUpgradeMinorVersion)) {
    query['AutoUpgradeMinorVersion'] = request.autoUpgradeMinorVersion;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceAutoUpgradeMinorVersion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceAutoUpgradeMinorVersion(request: ModifyDBInstanceAutoUpgradeMinorVersionRequest): ModifyDBInstanceAutoUpgradeMinorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceAutoUpgradeMinorVersionWithOptions(request, runtime);
}

model ModifyDBInstanceConnectionModeRequest {
  connectionMode?: string(name='ConnectionMode'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceConnectionModeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionModeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceConnectionModeResponseBody(name='body'),
}

async function modifyDBInstanceConnectionModeWithOptions(request: ModifyDBInstanceConnectionModeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceConnectionModeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionMode)) {
    query['ConnectionMode'] = request.connectionMode;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceConnectionMode',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceConnectionMode(request: ModifyDBInstanceConnectionModeRequest): ModifyDBInstanceConnectionModeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceConnectionModeWithOptions(request, runtime);
}

model ModifyDBInstanceConnectionStringRequest {
  babelfishPort?: string(name='BabelfishPort'),
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  currentConnectionString?: string(name='CurrentConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  generalGroupName?: string(name='GeneralGroupName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceConnectionStringResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceConnectionStringResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceConnectionStringResponseBody(name='body'),
}

async function modifyDBInstanceConnectionStringWithOptions(request: ModifyDBInstanceConnectionStringRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceConnectionStringResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.babelfishPort)) {
    query['BabelfishPort'] = request.babelfishPort;
  }
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.currentConnectionString)) {
    query['CurrentConnectionString'] = request.currentConnectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.generalGroupName)) {
    query['GeneralGroupName'] = request.generalGroupName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceConnectionString',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceConnectionString(request: ModifyDBInstanceConnectionStringRequest): ModifyDBInstanceConnectionStringResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceConnectionStringWithOptions(request, runtime);
}

model ModifyDBInstanceDelayedReplicationTimeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  readSQLReplicationTime?: string(name='ReadSQLReplicationTime'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceDelayedReplicationTimeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  readSQLReplicationTime?: string(name='ReadSQLReplicationTime'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDBInstanceDelayedReplicationTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceDelayedReplicationTimeResponseBody(name='body'),
}

async function modifyDBInstanceDelayedReplicationTimeWithOptions(request: ModifyDBInstanceDelayedReplicationTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceDelayedReplicationTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readSQLReplicationTime)) {
    query['ReadSQLReplicationTime'] = request.readSQLReplicationTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceDelayedReplicationTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceDelayedReplicationTime(request: ModifyDBInstanceDelayedReplicationTimeRequest): ModifyDBInstanceDelayedReplicationTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceDelayedReplicationTimeWithOptions(request, runtime);
}

model ModifyDBInstanceDeletionProtectionRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  deletionProtection?: boolean(name='DeletionProtection'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceDeletionProtectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceDeletionProtectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceDeletionProtectionResponseBody(name='body'),
}

async function modifyDBInstanceDeletionProtectionWithOptions(request: ModifyDBInstanceDeletionProtectionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceDeletionProtectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.deletionProtection)) {
    query['DeletionProtection'] = request.deletionProtection;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceDeletionProtection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceDeletionProtection(request: ModifyDBInstanceDeletionProtectionRequest): ModifyDBInstanceDeletionProtectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceDeletionProtectionWithOptions(request, runtime);
}

model ModifyDBInstanceDescriptionRequest {
  DBInstanceDescription?: string(name='DBInstanceDescription'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceDescriptionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceDescriptionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceDescriptionResponseBody(name='body'),
}

async function modifyDBInstanceDescriptionWithOptions(request: ModifyDBInstanceDescriptionRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceDescriptionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceDescription)) {
    query['DBInstanceDescription'] = request.DBInstanceDescription;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceDescription',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceDescription(request: ModifyDBInstanceDescriptionRequest): ModifyDBInstanceDescriptionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceDescriptionWithOptions(request, runtime);
}

model ModifyDBInstanceHAConfigRequest {
  dbInstanceId?: string(name='DbInstanceId'),
  HAMode?: string(name='HAMode'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  syncMode?: string(name='SyncMode'),
}

model ModifyDBInstanceHAConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceHAConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceHAConfigResponseBody(name='body'),
}

async function modifyDBInstanceHAConfigWithOptions(request: ModifyDBInstanceHAConfigRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceHAConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.HAMode)) {
    query['HAMode'] = request.HAMode;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.syncMode)) {
    query['SyncMode'] = request.syncMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceHAConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceHAConfig(request: ModifyDBInstanceHAConfigRequest): ModifyDBInstanceHAConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceHAConfigWithOptions(request, runtime);
}

model ModifyDBInstanceMaintainTimeRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  maintainTime?: string(name='MaintainTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceMaintainTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMaintainTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceMaintainTimeResponseBody(name='body'),
}

async function modifyDBInstanceMaintainTimeWithOptions(request: ModifyDBInstanceMaintainTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMaintainTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.maintainTime)) {
    query['MaintainTime'] = request.maintainTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceMaintainTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceMaintainTime(request: ModifyDBInstanceMaintainTimeRequest): ModifyDBInstanceMaintainTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMaintainTimeWithOptions(request, runtime);
}

model ModifyDBInstanceMetricsRequest {
  DBInstanceName?: string(name='DBInstanceName'),
  metricsConfig?: string(name='MetricsConfig'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  scope?: string(name='Scope'),
}

model ModifyDBInstanceMetricsResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
  scope?: string(name='Scope'),
}

model ModifyDBInstanceMetricsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceMetricsResponseBody(name='body'),
}

async function modifyDBInstanceMetricsWithOptions(request: ModifyDBInstanceMetricsRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMetricsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceName)) {
    query['DBInstanceName'] = request.DBInstanceName;
  }
  if (!Util.isUnset(request.metricsConfig)) {
    query['MetricsConfig'] = request.metricsConfig;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.scope)) {
    query['Scope'] = request.scope;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceMetrics',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceMetrics(request: ModifyDBInstanceMetricsRequest): ModifyDBInstanceMetricsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMetricsWithOptions(request, runtime);
}

model ModifyDBInstanceMonitorRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceMonitorResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceMonitorResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceMonitorResponseBody(name='body'),
}

async function modifyDBInstanceMonitorWithOptions(request: ModifyDBInstanceMonitorRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceMonitorResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceMonitor',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceMonitor(request: ModifyDBInstanceMonitorRequest): ModifyDBInstanceMonitorResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceMonitorWithOptions(request, runtime);
}

model ModifyDBInstanceNetworkExpireTimeRequest {
  classicExpiredDays?: int32(name='ClassicExpiredDays'),
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceNetworkExpireTimeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceNetworkExpireTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceNetworkExpireTimeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkExpireTimeWithOptions(request: ModifyDBInstanceNetworkExpireTimeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetworkExpireTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classicExpiredDays)) {
    query['ClassicExpiredDays'] = request.classicExpiredDays;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceNetworkExpireTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceNetworkExpireTime(request: ModifyDBInstanceNetworkExpireTimeRequest): ModifyDBInstanceNetworkExpireTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetworkExpireTimeWithOptions(request, runtime);
}

model ModifyDBInstanceNetworkTypeRequest {
  classicExpiredDays?: string(name='ClassicExpiredDays'),
  DBInstanceId?: string(name='DBInstanceId'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  readWriteSplittingClassicExpiredDays?: int32(name='ReadWriteSplittingClassicExpiredDays'),
  readWriteSplittingPrivateIpAddress?: string(name='ReadWriteSplittingPrivateIpAddress'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retainClassic?: string(name='RetainClassic'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model ModifyDBInstanceNetworkTypeResponseBody = {
  connectionString?: string(name='ConnectionString'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDBInstanceNetworkTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceNetworkTypeResponseBody(name='body'),
}

async function modifyDBInstanceNetworkTypeWithOptions(request: ModifyDBInstanceNetworkTypeRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceNetworkTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.classicExpiredDays)) {
    query['ClassicExpiredDays'] = request.classicExpiredDays;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.readWriteSplittingClassicExpiredDays)) {
    query['ReadWriteSplittingClassicExpiredDays'] = request.readWriteSplittingClassicExpiredDays;
  }
  if (!Util.isUnset(request.readWriteSplittingPrivateIpAddress)) {
    query['ReadWriteSplittingPrivateIpAddress'] = request.readWriteSplittingPrivateIpAddress;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retainClassic)) {
    query['RetainClassic'] = request.retainClassic;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceNetworkType',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceNetworkType(request: ModifyDBInstanceNetworkTypeRequest): ModifyDBInstanceNetworkTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceNetworkTypeWithOptions(request, runtime);
}

model ModifyDBInstancePayTypeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  usedTime?: int32(name='UsedTime'),
}

model ModifyDBInstancePayTypeResponseBody = {
  orderId?: long(name='OrderId'),
}

model ModifyDBInstancePayTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstancePayTypeResponseBody(name='body'),
}

async function modifyDBInstancePayTypeWithOptions(request: ModifyDBInstancePayTypeRequest, runtime: Util.RuntimeOptions): ModifyDBInstancePayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstancePayType',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstancePayType(request: ModifyDBInstancePayTypeRequest): ModifyDBInstancePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstancePayTypeWithOptions(request, runtime);
}

model ModifyDBInstanceProxyConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  proxyConfigurationKey?: string(name='ProxyConfigurationKey'),
  proxyConfigurationValue?: string(name='ProxyConfigurationValue'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBInstanceProxyConfigurationResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceProxyConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceProxyConfigurationResponseBody(name='body'),
}

async function modifyDBInstanceProxyConfigurationWithOptions(request: ModifyDBInstanceProxyConfigurationRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceProxyConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.proxyConfigurationKey)) {
    query['ProxyConfigurationKey'] = request.proxyConfigurationKey;
  }
  if (!Util.isUnset(request.proxyConfigurationValue)) {
    query['ProxyConfigurationValue'] = request.proxyConfigurationValue;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceProxyConfiguration',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceProxyConfiguration(request: ModifyDBInstanceProxyConfigurationRequest): ModifyDBInstanceProxyConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceProxyConfigurationWithOptions(request, runtime);
}

model ModifyDBInstanceSSLRequest {
  ACL?: string(name='ACL'),
  CAType?: string(name='CAType'),
  clientCACert?: string(name='ClientCACert'),
  clientCAEnabled?: int32(name='ClientCAEnabled'),
  clientCertRevocationList?: string(name='ClientCertRevocationList'),
  clientCrlEnabled?: int32(name='ClientCrlEnabled'),
  connectionString?: string(name='ConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  replicationACL?: string(name='ReplicationACL'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SSLEnabled?: int32(name='SSLEnabled'),
  serverCert?: string(name='ServerCert'),
  serverKey?: string(name='ServerKey'),
}

model ModifyDBInstanceSSLResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSSLResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceSSLResponseBody(name='body'),
}

async function modifyDBInstanceSSLWithOptions(request: ModifyDBInstanceSSLRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSSLResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ACL)) {
    query['ACL'] = request.ACL;
  }
  if (!Util.isUnset(request.CAType)) {
    query['CAType'] = request.CAType;
  }
  if (!Util.isUnset(request.clientCACert)) {
    query['ClientCACert'] = request.clientCACert;
  }
  if (!Util.isUnset(request.clientCAEnabled)) {
    query['ClientCAEnabled'] = request.clientCAEnabled;
  }
  if (!Util.isUnset(request.clientCertRevocationList)) {
    query['ClientCertRevocationList'] = request.clientCertRevocationList;
  }
  if (!Util.isUnset(request.clientCrlEnabled)) {
    query['ClientCrlEnabled'] = request.clientCrlEnabled;
  }
  if (!Util.isUnset(request.connectionString)) {
    query['ConnectionString'] = request.connectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.replicationACL)) {
    query['ReplicationACL'] = request.replicationACL;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SSLEnabled)) {
    query['SSLEnabled'] = request.SSLEnabled;
  }
  if (!Util.isUnset(request.serverCert)) {
    query['ServerCert'] = request.serverCert;
  }
  if (!Util.isUnset(request.serverKey)) {
    query['ServerKey'] = request.serverKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceSSL',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceSSL(request: ModifyDBInstanceSSLRequest): ModifyDBInstanceSSLResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSSLWithOptions(request, runtime);
}

model ModifyDBInstanceSpecRequest {
  category?: string(name='Category'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  direction?: string(name='Direction'),
  effectiveTime?: string(name='EffectiveTime'),
  engineVersion?: string(name='EngineVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverlessConfiguration?: {
    autoPause?: boolean(name='AutoPause'),
    maxCapacity?: double(name='MaxCapacity'),
    minCapacity?: double(name='MinCapacity'),
    switchForce?: boolean(name='SwitchForce'),
  }(name='ServerlessConfiguration'),
  sourceBiz?: string(name='SourceBiz'),
  switchTime?: string(name='SwitchTime'),
  usedTime?: long(name='UsedTime'),
  zoneId?: string(name='ZoneId'),
}

model ModifyDBInstanceSpecShrinkRequest {
  category?: string(name='Category'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  direction?: string(name='Direction'),
  effectiveTime?: string(name='EffectiveTime'),
  engineVersion?: string(name='EngineVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  serverlessConfigurationShrink?: string(name='ServerlessConfiguration'),
  sourceBiz?: string(name='SourceBiz'),
  switchTime?: string(name='SwitchTime'),
  usedTime?: long(name='UsedTime'),
  zoneId?: string(name='ZoneId'),
}

model ModifyDBInstanceSpecResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceSpecResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceSpecResponseBody(name='body'),
}

async function modifyDBInstanceSpecWithOptions(tmpReq: ModifyDBInstanceSpecRequest, runtime: Util.RuntimeOptions): ModifyDBInstanceSpecResponse {
  Util.validateModel(tmpReq);
  var request = new ModifyDBInstanceSpecShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.serverlessConfiguration)) {
    request.serverlessConfigurationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serverlessConfiguration, 'ServerlessConfiguration', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.category)) {
    query['Category'] = request.category;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.direction)) {
    query['Direction'] = request.direction;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.serverlessConfigurationShrink)) {
    query['ServerlessConfiguration'] = request.serverlessConfigurationShrink;
  }
  if (!Util.isUnset(request.sourceBiz)) {
    query['SourceBiz'] = request.sourceBiz;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceSpec',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceSpec(request: ModifyDBInstanceSpecRequest): ModifyDBInstanceSpecResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceSpecWithOptions(request, runtime);
}

model ModifyDBInstanceTDERequest {
  certificate?: string(name='Certificate'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  encryptionKey?: string(name='EncryptionKey'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  passWord?: string(name='PassWord'),
  privateKey?: string(name='PrivateKey'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  roleArn?: string(name='RoleArn'),
  TDEStatus?: string(name='TDEStatus'),
}

model ModifyDBInstanceTDEResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBInstanceTDEResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBInstanceTDEResponseBody(name='body'),
}

async function modifyDBInstanceTDEWithOptions(request: ModifyDBInstanceTDERequest, runtime: Util.RuntimeOptions): ModifyDBInstanceTDEResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.certificate)) {
    query['Certificate'] = request.certificate;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.encryptionKey)) {
    query['EncryptionKey'] = request.encryptionKey;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.passWord)) {
    query['PassWord'] = request.passWord;
  }
  if (!Util.isUnset(request.privateKey)) {
    query['PrivateKey'] = request.privateKey;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.roleArn)) {
    query['RoleArn'] = request.roleArn;
  }
  if (!Util.isUnset(request.TDEStatus)) {
    query['TDEStatus'] = request.TDEStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBInstanceTDE',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBInstanceTDE(request: ModifyDBInstanceTDERequest): ModifyDBInstanceTDEResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBInstanceTDEWithOptions(request, runtime);
}

model ModifyDBProxyRequest {
  configDBProxyService?: string(name='ConfigDBProxyService'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyInstanceNum?: string(name='DBProxyInstanceNum'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model ModifyDBProxyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBProxyResponseBody(name='body'),
}

async function modifyDBProxyWithOptions(request: ModifyDBProxyRequest, runtime: Util.RuntimeOptions): ModifyDBProxyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configDBProxyService)) {
    query['ConfigDBProxyService'] = request.configDBProxyService;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.DBProxyInstanceNum)) {
    query['DBProxyInstanceNum'] = request.DBProxyInstanceNum;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBProxy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBProxy(request: ModifyDBProxyRequest): ModifyDBProxyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyWithOptions(request, runtime);
}

model ModifyDBProxyEndpointRequest {
  configDBProxyFeatures?: string(name='ConfigDBProxyFeatures'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  dbEndpointAliases?: string(name='DbEndpointAliases'),
  dbEndpointOperator?: string(name='DbEndpointOperator'),
  dbEndpointReadWriteMode?: string(name='DbEndpointReadWriteMode'),
  dbEndpointType?: string(name='DbEndpointType'),
  ownerId?: long(name='OwnerId'),
  readOnlyInstanceDistributionType?: string(name='ReadOnlyInstanceDistributionType'),
  readOnlyInstanceMaxDelayTime?: string(name='ReadOnlyInstanceMaxDelayTime'),
  readOnlyInstanceWeight?: string(name='ReadOnlyInstanceWeight'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBProxyEndpointResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyEndpointResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBProxyEndpointResponseBody(name='body'),
}

async function modifyDBProxyEndpointWithOptions(request: ModifyDBProxyEndpointRequest, runtime: Util.RuntimeOptions): ModifyDBProxyEndpointResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configDBProxyFeatures)) {
    query['ConfigDBProxyFeatures'] = request.configDBProxyFeatures;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEndpointId)) {
    query['DBProxyEndpointId'] = request.DBProxyEndpointId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.dbEndpointAliases)) {
    query['DbEndpointAliases'] = request.dbEndpointAliases;
  }
  if (!Util.isUnset(request.dbEndpointOperator)) {
    query['DbEndpointOperator'] = request.dbEndpointOperator;
  }
  if (!Util.isUnset(request.dbEndpointReadWriteMode)) {
    query['DbEndpointReadWriteMode'] = request.dbEndpointReadWriteMode;
  }
  if (!Util.isUnset(request.dbEndpointType)) {
    query['DbEndpointType'] = request.dbEndpointType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readOnlyInstanceDistributionType)) {
    query['ReadOnlyInstanceDistributionType'] = request.readOnlyInstanceDistributionType;
  }
  if (!Util.isUnset(request.readOnlyInstanceMaxDelayTime)) {
    query['ReadOnlyInstanceMaxDelayTime'] = request.readOnlyInstanceMaxDelayTime;
  }
  if (!Util.isUnset(request.readOnlyInstanceWeight)) {
    query['ReadOnlyInstanceWeight'] = request.readOnlyInstanceWeight;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBProxyEndpoint',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBProxyEndpoint(request: ModifyDBProxyEndpointRequest): ModifyDBProxyEndpointResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyEndpointWithOptions(request, runtime);
}

model ModifyDBProxyEndpointAddressRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyConnectStringNetType?: string(name='DBProxyConnectStringNetType'),
  DBProxyEndpointId?: string(name='DBProxyEndpointId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyNewConnectString?: string(name='DBProxyNewConnectString'),
  DBProxyNewConnectStringPort?: string(name='DBProxyNewConnectStringPort'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBProxyEndpointAddressResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyEndpointAddressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBProxyEndpointAddressResponseBody(name='body'),
}

async function modifyDBProxyEndpointAddressWithOptions(request: ModifyDBProxyEndpointAddressRequest, runtime: Util.RuntimeOptions): ModifyDBProxyEndpointAddressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyConnectStringNetType)) {
    query['DBProxyConnectStringNetType'] = request.DBProxyConnectStringNetType;
  }
  if (!Util.isUnset(request.DBProxyEndpointId)) {
    query['DBProxyEndpointId'] = request.DBProxyEndpointId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.DBProxyNewConnectString)) {
    query['DBProxyNewConnectString'] = request.DBProxyNewConnectString;
  }
  if (!Util.isUnset(request.DBProxyNewConnectStringPort)) {
    query['DBProxyNewConnectStringPort'] = request.DBProxyNewConnectStringPort;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBProxyEndpointAddress',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBProxyEndpointAddress(request: ModifyDBProxyEndpointAddressRequest): ModifyDBProxyEndpointAddressResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyEndpointAddressWithOptions(request, runtime);
}

model ModifyDBProxyInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  DBProxyInstanceNum?: string(name='DBProxyInstanceNum'),
  DBProxyInstanceType?: string(name='DBProxyInstanceType'),
  effectiveSpecificTime?: string(name='EffectiveSpecificTime'),
  effectiveTime?: string(name='EffectiveTime'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyDBProxyInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDBProxyInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDBProxyInstanceResponseBody(name='body'),
}

async function modifyDBProxyInstanceWithOptions(request: ModifyDBProxyInstanceRequest, runtime: Util.RuntimeOptions): ModifyDBProxyInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.DBProxyInstanceNum)) {
    query['DBProxyInstanceNum'] = request.DBProxyInstanceNum;
  }
  if (!Util.isUnset(request.DBProxyInstanceType)) {
    query['DBProxyInstanceType'] = request.DBProxyInstanceType;
  }
  if (!Util.isUnset(request.effectiveSpecificTime)) {
    query['EffectiveSpecificTime'] = request.effectiveSpecificTime;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDBProxyInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDBProxyInstance(request: ModifyDBProxyInstanceRequest): ModifyDBProxyInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDBProxyInstanceWithOptions(request, runtime);
}

model ModifyDTCSecurityIpHostsForSQLServerRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIpHosts?: string(name='SecurityIpHosts'),
  securityToken?: string(name='SecurityToken'),
  whiteListGroupName?: string(name='WhiteListGroupName'),
}

model ModifyDTCSecurityIpHostsForSQLServerResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  DTCSetResult?: string(name='DTCSetResult'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyDTCSecurityIpHostsForSQLServerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDTCSecurityIpHostsForSQLServerResponseBody(name='body'),
}

async function modifyDTCSecurityIpHostsForSQLServerWithOptions(request: ModifyDTCSecurityIpHostsForSQLServerRequest, runtime: Util.RuntimeOptions): ModifyDTCSecurityIpHostsForSQLServerResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIpHosts)) {
    query['SecurityIpHosts'] = request.securityIpHosts;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  if (!Util.isUnset(request.whiteListGroupName)) {
    query['WhiteListGroupName'] = request.whiteListGroupName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDTCSecurityIpHostsForSQLServer',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDTCSecurityIpHostsForSQLServer(request: ModifyDTCSecurityIpHostsForSQLServerRequest): ModifyDTCSecurityIpHostsForSQLServerResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDTCSecurityIpHostsForSQLServerWithOptions(request, runtime);
}

model ModifyDasInstanceConfigRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  storageAutoScale?: string(name='StorageAutoScale'),
  storageThreshold?: int32(name='StorageThreshold'),
  storageUpperBound?: int32(name='StorageUpperBound'),
}

model ModifyDasInstanceConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDasInstanceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDasInstanceConfigResponseBody(name='body'),
}

async function modifyDasInstanceConfigWithOptions(request: ModifyDasInstanceConfigRequest, runtime: Util.RuntimeOptions): ModifyDasInstanceConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.storageAutoScale)) {
    query['StorageAutoScale'] = request.storageAutoScale;
  }
  if (!Util.isUnset(request.storageThreshold)) {
    query['StorageThreshold'] = request.storageThreshold;
  }
  if (!Util.isUnset(request.storageUpperBound)) {
    query['StorageUpperBound'] = request.storageUpperBound;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDasInstanceConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDasInstanceConfig(request: ModifyDasInstanceConfigRequest): ModifyDasInstanceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDasInstanceConfigWithOptions(request, runtime);
}

model ModifyDbProxyInstanceSslRequest {
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  dbInstanceId?: string(name='DbInstanceId'),
  dbProxyConnectString?: string(name='DbProxyConnectString'),
  dbProxyEndpointId?: string(name='DbProxyEndpointId'),
  dbProxySslEnabled?: string(name='DbProxySslEnabled'),
  regionId?: string(name='RegionId'),
}

model ModifyDbProxyInstanceSslResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyDbProxyInstanceSslResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyDbProxyInstanceSslResponseBody(name='body'),
}

async function modifyDbProxyInstanceSslWithOptions(request: ModifyDbProxyInstanceSslRequest, runtime: Util.RuntimeOptions): ModifyDbProxyInstanceSslResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.dbInstanceId)) {
    query['DbInstanceId'] = request.dbInstanceId;
  }
  if (!Util.isUnset(request.dbProxyConnectString)) {
    query['DbProxyConnectString'] = request.dbProxyConnectString;
  }
  if (!Util.isUnset(request.dbProxyEndpointId)) {
    query['DbProxyEndpointId'] = request.dbProxyEndpointId;
  }
  if (!Util.isUnset(request.dbProxySslEnabled)) {
    query['DbProxySslEnabled'] = request.dbProxySslEnabled;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyDbProxyInstanceSsl',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyDbProxyInstanceSsl(request: ModifyDbProxyInstanceSslRequest): ModifyDbProxyInstanceSslResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyDbProxyInstanceSslWithOptions(request, runtime);
}

model ModifyHADiagnoseConfigRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tcpConnectionType?: string(name='TcpConnectionType'),
}

model ModifyHADiagnoseConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHADiagnoseConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHADiagnoseConfigResponseBody(name='body'),
}

async function modifyHADiagnoseConfigWithOptions(request: ModifyHADiagnoseConfigRequest, runtime: Util.RuntimeOptions): ModifyHADiagnoseConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tcpConnectionType)) {
    query['TcpConnectionType'] = request.tcpConnectionType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHADiagnoseConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHADiagnoseConfig(request: ModifyHADiagnoseConfigRequest): ModifyHADiagnoseConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHADiagnoseConfigWithOptions(request, runtime);
}

model ModifyHASwitchConfigRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  HAConfig?: string(name='HAConfig'),
  manualHATime?: string(name='ManualHATime'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyHASwitchConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyHASwitchConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyHASwitchConfigResponseBody(name='body'),
}

async function modifyHASwitchConfigWithOptions(request: ModifyHASwitchConfigRequest, runtime: Util.RuntimeOptions): ModifyHASwitchConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.HAConfig)) {
    query['HAConfig'] = request.HAConfig;
  }
  if (!Util.isUnset(request.manualHATime)) {
    query['ManualHATime'] = request.manualHATime;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyHASwitchConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyHASwitchConfig(request: ModifyHASwitchConfigRequest): ModifyHASwitchConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyHASwitchConfigWithOptions(request, runtime);
}

model ModifyInstanceAutoRenewalAttributeRequest {
  autoRenew?: string(name='AutoRenew'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  duration?: string(name='Duration'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyInstanceAutoRenewalAttributeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyInstanceAutoRenewalAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceAutoRenewalAttributeResponseBody(name='body'),
}

async function modifyInstanceAutoRenewalAttributeWithOptions(request: ModifyInstanceAutoRenewalAttributeRequest, runtime: Util.RuntimeOptions): ModifyInstanceAutoRenewalAttributeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.duration)) {
    query['Duration'] = request.duration;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceAutoRenewalAttribute',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceAutoRenewalAttribute(request: ModifyInstanceAutoRenewalAttributeRequest): ModifyInstanceAutoRenewalAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceAutoRenewalAttributeWithOptions(request, runtime);
}

model ModifyInstanceCrossBackupPolicyRequest {
  backupEnabled?: string(name='BackupEnabled'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  crossBackupType?: string(name='CrossBackupType'),
  DBInstanceId?: string(name='DBInstanceId'),
  logBackupEnabled?: string(name='LogBackupEnabled'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retentType?: int32(name='RetentType'),
  retention?: int32(name='Retention'),
}

model ModifyInstanceCrossBackupPolicyResponseBody = {
  backupEnabled?: string(name='BackupEnabled'),
  crossBackupRegion?: string(name='CrossBackupRegion'),
  crossBackupType?: string(name='CrossBackupType'),
  DBInstanceId?: string(name='DBInstanceId'),
  logBackupEnabled?: string(name='LogBackupEnabled'),
  regionId?: string(name='RegionId'),
  requestId?: string(name='RequestId'),
  retentType?: int32(name='RetentType'),
  retention?: int32(name='Retention'),
}

model ModifyInstanceCrossBackupPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyInstanceCrossBackupPolicyResponseBody(name='body'),
}

async function modifyInstanceCrossBackupPolicyWithOptions(request: ModifyInstanceCrossBackupPolicyRequest, runtime: Util.RuntimeOptions): ModifyInstanceCrossBackupPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupEnabled)) {
    query['BackupEnabled'] = request.backupEnabled;
  }
  if (!Util.isUnset(request.crossBackupRegion)) {
    query['CrossBackupRegion'] = request.crossBackupRegion;
  }
  if (!Util.isUnset(request.crossBackupType)) {
    query['CrossBackupType'] = request.crossBackupType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.logBackupEnabled)) {
    query['LogBackupEnabled'] = request.logBackupEnabled;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retentType)) {
    query['RetentType'] = request.retentType;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyInstanceCrossBackupPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyInstanceCrossBackupPolicy(request: ModifyInstanceCrossBackupPolicyRequest): ModifyInstanceCrossBackupPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyInstanceCrossBackupPolicyWithOptions(request, runtime);
}

model ModifyPGHbaConfigRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  hbaItem?: [ 
    {
      address?: string(name='Address'),
      database?: string(name='Database'),
      mask?: string(name='Mask'),
      method?: string(name='Method'),
      option?: string(name='Option'),
      priorityId?: int32(name='PriorityId'),
      type?: string(name='Type'),
      user?: string(name='User'),
    }
  ](name='HbaItem'),
  opsType?: string(name='OpsType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyPGHbaConfigResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyPGHbaConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyPGHbaConfigResponseBody(name='body'),
}

async function modifyPGHbaConfigWithOptions(request: ModifyPGHbaConfigRequest, runtime: Util.RuntimeOptions): ModifyPGHbaConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.hbaItem)) {
    query['HbaItem'] = request.hbaItem;
  }
  if (!Util.isUnset(request.opsType)) {
    query['OpsType'] = request.opsType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyPGHbaConfig',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyPGHbaConfig(request: ModifyPGHbaConfigRequest): ModifyPGHbaConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyPGHbaConfigWithOptions(request, runtime);
}

model ModifyParameterRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  forcerestart?: boolean(name='Forcerestart'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  parameterGroupId?: string(name='ParameterGroupId'),
  parameters?: string(name='Parameters'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  switchTimeMode?: string(name='SwitchTimeMode'),
}

model ModifyParameterResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyParameterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyParameterResponseBody(name='body'),
}

async function modifyParameterWithOptions(request: ModifyParameterRequest, runtime: Util.RuntimeOptions): ModifyParameterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.forcerestart)) {
    query['Forcerestart'] = request.forcerestart;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.switchTimeMode)) {
    query['SwitchTimeMode'] = request.switchTimeMode;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyParameter',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyParameter(request: ModifyParameterRequest): ModifyParameterResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParameterWithOptions(request, runtime);
}

model ModifyParameterGroupRequest {
  modifyMode?: string(name='ModifyMode'),
  ownerId?: long(name='OwnerId'),
  parameterGroupDesc?: string(name='ParameterGroupDesc'),
  parameterGroupId?: string(name='ParameterGroupId'),
  parameterGroupName?: string(name='ParameterGroupName'),
  parameters?: string(name='Parameters'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyParameterGroupResponseBody = {
  parameterGroupId?: string(name='ParameterGroupId'),
  requestId?: string(name='RequestId'),
}

model ModifyParameterGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyParameterGroupResponseBody(name='body'),
}

async function modifyParameterGroupWithOptions(request: ModifyParameterGroupRequest, runtime: Util.RuntimeOptions): ModifyParameterGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.parameterGroupDesc)) {
    query['ParameterGroupDesc'] = request.parameterGroupDesc;
  }
  if (!Util.isUnset(request.parameterGroupId)) {
    query['ParameterGroupId'] = request.parameterGroupId;
  }
  if (!Util.isUnset(request.parameterGroupName)) {
    query['ParameterGroupName'] = request.parameterGroupName;
  }
  if (!Util.isUnset(request.parameters)) {
    query['Parameters'] = request.parameters;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyParameterGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyParameterGroup(request: ModifyParameterGroupRequest): ModifyParameterGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyParameterGroupWithOptions(request, runtime);
}

model ModifyReadWriteSplittingConnectionRequest {
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  DBInstanceId?: string(name='DBInstanceId'),
  distributionType?: string(name='DistributionType'),
  maxDelayTime?: string(name='MaxDelayTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  weight?: string(name='Weight'),
}

model ModifyReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyReadWriteSplittingConnectionResponseBody(name='body'),
}

async function modifyReadWriteSplittingConnectionWithOptions(request: ModifyReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): ModifyReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.distributionType)) {
    query['DistributionType'] = request.distributionType;
  }
  if (!Util.isUnset(request.maxDelayTime)) {
    query['MaxDelayTime'] = request.maxDelayTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.weight)) {
    query['Weight'] = request.weight;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyReadWriteSplittingConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyReadWriteSplittingConnection(request: ModifyReadWriteSplittingConnectionRequest): ModifyReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReadWriteSplittingConnectionWithOptions(request, runtime);
}

model ModifyReadonlyInstanceDelayReplicationTimeRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  readSQLReplicationTime?: string(name='ReadSQLReplicationTime'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyReadonlyInstanceDelayReplicationTimeResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  readSQLReplicationTime?: string(name='ReadSQLReplicationTime'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifyReadonlyInstanceDelayReplicationTimeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyReadonlyInstanceDelayReplicationTimeResponseBody(name='body'),
}

async function modifyReadonlyInstanceDelayReplicationTimeWithOptions(request: ModifyReadonlyInstanceDelayReplicationTimeRequest, runtime: Util.RuntimeOptions): ModifyReadonlyInstanceDelayReplicationTimeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.readSQLReplicationTime)) {
    query['ReadSQLReplicationTime'] = request.readSQLReplicationTime;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyReadonlyInstanceDelayReplicationTime',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyReadonlyInstanceDelayReplicationTime(request: ModifyReadonlyInstanceDelayReplicationTimeRequest): ModifyReadonlyInstanceDelayReplicationTimeResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyReadonlyInstanceDelayReplicationTimeWithOptions(request, runtime);
}

model ModifyResourceGroupRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ModifyResourceGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifyResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifyResourceGroupResponseBody(name='body'),
}

async function modifyResourceGroupWithOptions(request: ModifyResourceGroupRequest, runtime: Util.RuntimeOptions): ModifyResourceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifyResourceGroup',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifyResourceGroup(request: ModifyResourceGroupRequest): ModifyResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifyResourceGroupWithOptions(request, runtime);
}

model ModifySQLCollectorPolicyRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  SQLCollectorStatus?: string(name='SQLCollectorStatus'),
}

model ModifySQLCollectorPolicyResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySQLCollectorPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySQLCollectorPolicyResponseBody(name='body'),
}

async function modifySQLCollectorPolicyWithOptions(request: ModifySQLCollectorPolicyRequest, runtime: Util.RuntimeOptions): ModifySQLCollectorPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.SQLCollectorStatus)) {
    query['SQLCollectorStatus'] = request.SQLCollectorStatus;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySQLCollectorPolicy',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySQLCollectorPolicy(request: ModifySQLCollectorPolicyRequest): ModifySQLCollectorPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySQLCollectorPolicyWithOptions(request, runtime);
}

model ModifySQLCollectorRetentionRequest {
  configValue?: string(name='ConfigValue'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityToken?: string(name='SecurityToken'),
}

model ModifySQLCollectorRetentionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ModifySQLCollectorRetentionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySQLCollectorRetentionResponseBody(name='body'),
}

async function modifySQLCollectorRetentionWithOptions(request: ModifySQLCollectorRetentionRequest, runtime: Util.RuntimeOptions): ModifySQLCollectorRetentionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.configValue)) {
    query['ConfigValue'] = request.configValue;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityToken)) {
    query['SecurityToken'] = request.securityToken;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySQLCollectorRetention',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySQLCollectorRetention(request: ModifySQLCollectorRetentionRequest): ModifySQLCollectorRetentionResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySQLCollectorRetentionWithOptions(request, runtime);
}

model ModifySecurityGroupConfigurationRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
}

model ModifySecurityGroupConfigurationResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  items?: {
    ecsSecurityGroupRelation?: [ 
    {
      networkType?: string(name='NetworkType'),
      regionId?: string(name='RegionId'),
      securityGroupId?: string(name='SecurityGroupId'),
    }
  ](name='EcsSecurityGroupRelation')
  }(name='Items'),
  requestId?: string(name='RequestId'),
}

model ModifySecurityGroupConfigurationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityGroupConfigurationResponseBody(name='body'),
}

async function modifySecurityGroupConfigurationWithOptions(request: ModifySecurityGroupConfigurationRequest, runtime: Util.RuntimeOptions): ModifySecurityGroupConfigurationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityGroupConfiguration',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityGroupConfiguration(request: ModifySecurityGroupConfigurationRequest): ModifySecurityGroupConfigurationResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityGroupConfigurationWithOptions(request, runtime);
}

model ModifySecurityIpsRequest {
  DBInstanceIPArrayAttribute?: string(name='DBInstanceIPArrayAttribute'),
  DBInstanceIPArrayName?: string(name='DBInstanceIPArrayName'),
  DBInstanceId?: string(name='DBInstanceId'),
  freshWhiteListReadins?: string(name='FreshWhiteListReadins'),
  modifyMode?: string(name='ModifyMode'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityIPType?: string(name='SecurityIPType'),
  securityIps?: string(name='SecurityIps'),
  whitelistNetworkType?: string(name='WhitelistNetworkType'),
}

model ModifySecurityIpsResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model ModifySecurityIpsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ModifySecurityIpsResponseBody(name='body'),
}

async function modifySecurityIpsWithOptions(request: ModifySecurityIpsRequest, runtime: Util.RuntimeOptions): ModifySecurityIpsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceIPArrayAttribute)) {
    query['DBInstanceIPArrayAttribute'] = request.DBInstanceIPArrayAttribute;
  }
  if (!Util.isUnset(request.DBInstanceIPArrayName)) {
    query['DBInstanceIPArrayName'] = request.DBInstanceIPArrayName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.freshWhiteListReadins)) {
    query['FreshWhiteListReadins'] = request.freshWhiteListReadins;
  }
  if (!Util.isUnset(request.modifyMode)) {
    query['ModifyMode'] = request.modifyMode;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityIPType)) {
    query['SecurityIPType'] = request.securityIPType;
  }
  if (!Util.isUnset(request.securityIps)) {
    query['SecurityIps'] = request.securityIps;
  }
  if (!Util.isUnset(request.whitelistNetworkType)) {
    query['WhitelistNetworkType'] = request.whitelistNetworkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ModifySecurityIps',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function modifySecurityIps(request: ModifySecurityIpsRequest): ModifySecurityIpsResponse {
  var runtime = new Util.RuntimeOptions{};
  return modifySecurityIpsWithOptions(request, runtime);
}

model PurgeDBInstanceLogRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model PurgeDBInstanceLogResponseBody = {
  requestId?: string(name='RequestId'),
}

model PurgeDBInstanceLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: PurgeDBInstanceLogResponseBody(name='body'),
}

async function purgeDBInstanceLogWithOptions(request: PurgeDBInstanceLogRequest, runtime: Util.RuntimeOptions): PurgeDBInstanceLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'PurgeDBInstanceLog',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function purgeDBInstanceLog(request: PurgeDBInstanceLogRequest): PurgeDBInstanceLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return purgeDBInstanceLogWithOptions(request, runtime);
}

model QueryNotifyRequest {
  from?: string(name='From'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  to?: string(name='To'),
  withConfirmed?: boolean(name='WithConfirmed'),
}

model QueryNotifyResponseBody = {
  data?: {
    notifyItemList?: [ 
      {
        aliUid?: long(name='AliUid'),
        confirmFlag?: boolean(name='ConfirmFlag'),
        confirmor?: long(name='Confirmor'),
        gmtCreated?: string(name='GmtCreated'),
        gmtModified?: string(name='GmtModified'),
        id?: long(name='Id'),
        idempotentCount?: string(name='IdempotentCount'),
        idempotentId?: string(name='IdempotentId'),
        level?: string(name='Level'),
        notifyElement?: string(name='NotifyElement'),
        templateName?: string(name='TemplateName'),
        type?: string(name='Type'),
      }
    ](name='NotifyItemList'),
    pageNumber?: int32(name='PageNumber'),
    pageSize?: int32(name='PageSize'),
    totalRecordCount?: int32(name='TotalRecordCount'),
  }(name='Data'),
  requestId?: string(name='RequestId'),
}

model QueryNotifyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: QueryNotifyResponseBody(name='body'),
}

async function queryNotifyWithOptions(request: QueryNotifyRequest, runtime: Util.RuntimeOptions): QueryNotifyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.from)) {
    body['From'] = request.from;
  }
  if (!Util.isUnset(request.pageNumber)) {
    body['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    body['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.to)) {
    body['To'] = request.to;
  }
  if (!Util.isUnset(request.withConfirmed)) {
    body['WithConfirmed'] = request.withConfirmed;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'QueryNotify',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function queryNotify(request: QueryNotifyRequest): QueryNotifyResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryNotifyWithOptions(request, runtime);
}

model RebuildDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  dedicatedHostId?: string(name='DedicatedHostId'),
  ownerId?: long(name='OwnerId'),
  rebuildNodeType?: string(name='RebuildNodeType'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RebuildDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model RebuildDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RebuildDBInstanceResponseBody(name='body'),
}

async function rebuildDBInstanceWithOptions(request: RebuildDBInstanceRequest, runtime: Util.RuntimeOptions): RebuildDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.dedicatedHostId)) {
    query['DedicatedHostId'] = request.dedicatedHostId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.rebuildNodeType)) {
    query['RebuildNodeType'] = request.rebuildNodeType;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RebuildDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function rebuildDBInstance(request: RebuildDBInstanceRequest): RebuildDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return rebuildDBInstanceWithOptions(request, runtime);
}

model ReceiveDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  guardDBInstanceId?: string(name='GuardDBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReceiveDBInstanceResponseBody = {
  guardDBInstanceId?: string(name='GuardDBInstanceId'),
  requestId?: string(name='RequestId'),
}

model ReceiveDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReceiveDBInstanceResponseBody(name='body'),
}

async function receiveDBInstanceWithOptions(request: ReceiveDBInstanceRequest, runtime: Util.RuntimeOptions): ReceiveDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.guardDBInstanceId)) {
    query['GuardDBInstanceId'] = request.guardDBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReceiveDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function receiveDBInstance(request: ReceiveDBInstanceRequest): ReceiveDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return receiveDBInstanceWithOptions(request, runtime);
}

model RecoveryDBInstanceRequest {
  backupId?: string(name='BackupId'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  dbNames?: string(name='DbNames'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  targetDBInstanceId?: string(name='TargetDBInstanceId'),
  usedTime?: string(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model RecoveryDBInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RecoveryDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RecoveryDBInstanceResponseBody(name='body'),
}

async function recoveryDBInstanceWithOptions(request: RecoveryDBInstanceRequest, runtime: Util.RuntimeOptions): RecoveryDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.dbNames)) {
    query['DbNames'] = request.dbNames;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.targetDBInstanceId)) {
    query['TargetDBInstanceId'] = request.targetDBInstanceId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RecoveryDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function recoveryDBInstance(request: RecoveryDBInstanceRequest): RecoveryDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return recoveryDBInstanceWithOptions(request, runtime);
}

model ReleaseInstanceConnectionRequest {
  currentConnectionString?: string(name='CurrentConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseInstanceConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstanceConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseInstanceConnectionResponseBody(name='body'),
}

async function releaseInstanceConnectionWithOptions(request: ReleaseInstanceConnectionRequest, runtime: Util.RuntimeOptions): ReleaseInstanceConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentConnectionString)) {
    query['CurrentConnectionString'] = request.currentConnectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstanceConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstanceConnection(request: ReleaseInstanceConnectionRequest): ReleaseInstanceConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstanceConnectionWithOptions(request, runtime);
}

model ReleaseInstancePublicConnectionRequest {
  currentConnectionString?: string(name='CurrentConnectionString'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseInstancePublicConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseInstancePublicConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseInstancePublicConnectionResponseBody(name='body'),
}

async function releaseInstancePublicConnectionWithOptions(request: ReleaseInstancePublicConnectionRequest, runtime: Util.RuntimeOptions): ReleaseInstancePublicConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.currentConnectionString)) {
    query['CurrentConnectionString'] = request.currentConnectionString;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseInstancePublicConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseInstancePublicConnection(request: ReleaseInstancePublicConnectionRequest): ReleaseInstancePublicConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseInstancePublicConnectionWithOptions(request, runtime);
}

model ReleaseReadWriteSplittingConnectionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ReleaseReadWriteSplittingConnectionResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseReadWriteSplittingConnectionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseReadWriteSplittingConnectionResponseBody(name='body'),
}

async function releaseReadWriteSplittingConnectionWithOptions(request: ReleaseReadWriteSplittingConnectionRequest, runtime: Util.RuntimeOptions): ReleaseReadWriteSplittingConnectionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseReadWriteSplittingConnection',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseReadWriteSplittingConnection(request: ReleaseReadWriteSplittingConnectionRequest): ReleaseReadWriteSplittingConnectionResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseReadWriteSplittingConnectionWithOptions(request, runtime);
}

model RemoveTagsFromResourceRequest {
  tag?: [
    {
      key?: string(name='key'),
      value?: string(name='value'),
    }
  ](name='Tag'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  tags?: string(name='Tags'),
  proxyId?: string(name='proxyId'),
}

model RemoveTagsFromResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RemoveTagsFromResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemoveTagsFromResourceResponseBody(name='body'),
}

async function removeTagsFromResourceWithOptions(request: RemoveTagsFromResourceRequest, runtime: Util.RuntimeOptions): RemoveTagsFromResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.tags)) {
    query['Tags'] = request.tags;
  }
  if (!Util.isUnset(request.proxyId)) {
    query['proxyId'] = request.proxyId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RemoveTagsFromResource',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function removeTagsFromResource(request: RemoveTagsFromResourceRequest): RemoveTagsFromResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return removeTagsFromResourceWithOptions(request, runtime);
}

model RenewInstanceRequest {
  autoPay?: string(name='AutoPay'),
  autoRenew?: string(name='AutoRenew'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  period?: int32(name='Period'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RenewInstanceResponseBody = {
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model RenewInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RenewInstanceResponseBody(name='body'),
}

async function renewInstanceWithOptions(request: RenewInstanceRequest, runtime: Util.RuntimeOptions): RenewInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoPay)) {
    query['AutoPay'] = request.autoPay;
  }
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RenewInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function renewInstance(request: RenewInstanceRequest): RenewInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return renewInstanceWithOptions(request, runtime);
}

model RequestServiceOfCloudDBARequest {
  DBInstanceId?: string(name='DBInstanceId'),
  serviceRequestParam?: string(name='ServiceRequestParam'),
  serviceRequestType?: string(name='ServiceRequestType'),
}

model RequestServiceOfCloudDBAResponseBody = {
  attrData?: string(name='AttrData'),
  listData?: string(name='ListData'),
  requestId?: string(name='RequestId'),
}

model RequestServiceOfCloudDBAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RequestServiceOfCloudDBAResponseBody(name='body'),
}

async function requestServiceOfCloudDBAWithOptions(request: RequestServiceOfCloudDBARequest, runtime: Util.RuntimeOptions): RequestServiceOfCloudDBAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.serviceRequestParam)) {
    query['ServiceRequestParam'] = request.serviceRequestParam;
  }
  if (!Util.isUnset(request.serviceRequestType)) {
    query['ServiceRequestType'] = request.serviceRequestType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RequestServiceOfCloudDBA',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function requestServiceOfCloudDBA(request: RequestServiceOfCloudDBARequest): RequestServiceOfCloudDBAResponse {
  var runtime = new Util.RuntimeOptions{};
  return requestServiceOfCloudDBAWithOptions(request, runtime);
}

model ResetAccountRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetAccountResponseBody(name='body'),
}

async function resetAccountWithOptions(request: ResetAccountRequest, runtime: Util.RuntimeOptions): ResetAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccount',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetAccount(request: ResetAccountRequest): ResetAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountWithOptions(request, runtime);
}

model ResetAccountPasswordRequest {
  accountName?: string(name='AccountName'),
  accountPassword?: string(name='AccountPassword'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ResetAccountPasswordResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResetAccountPasswordResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResetAccountPasswordResponseBody(name='body'),
}

async function resetAccountPasswordWithOptions(request: ResetAccountPasswordRequest, runtime: Util.RuntimeOptions): ResetAccountPasswordResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.accountPassword)) {
    query['AccountPassword'] = request.accountPassword;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResetAccountPassword',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resetAccountPassword(request: ResetAccountPasswordRequest): ResetAccountPasswordResponse {
  var runtime = new Util.RuntimeOptions{};
  return resetAccountPasswordWithOptions(request, runtime);
}

model RestartDBInstanceRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartDBInstanceResponseBody(name='body'),
}

async function restartDBInstanceWithOptions(request: RestartDBInstanceRequest, runtime: Util.RuntimeOptions): RestartDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartDBInstance(request: RestartDBInstanceRequest): RestartDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartDBInstanceWithOptions(request, runtime);
}

model RestoreDdrTableRequest {
  backupId?: string(name='BackupId'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  restoreType?: string(name='RestoreType'),
  sourceDBInstanceName?: string(name='SourceDBInstanceName'),
  sourceRegion?: string(name='SourceRegion'),
  tableMeta?: string(name='TableMeta'),
}

model RestoreDdrTableResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
}

model RestoreDdrTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreDdrTableResponseBody(name='body'),
}

async function restoreDdrTableWithOptions(request: RestoreDdrTableRequest, runtime: Util.RuntimeOptions): RestoreDdrTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  if (!Util.isUnset(request.sourceDBInstanceName)) {
    query['SourceDBInstanceName'] = request.sourceDBInstanceName;
  }
  if (!Util.isUnset(request.sourceRegion)) {
    query['SourceRegion'] = request.sourceRegion;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreDdrTable',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restoreDdrTable(request: RestoreDdrTableRequest): RestoreDdrTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreDdrTableWithOptions(request, runtime);
}

model RestoreTableRequest {
  backupId?: string(name='BackupId'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  instantRecovery?: boolean(name='InstantRecovery'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restoreTime?: string(name='RestoreTime'),
  tableMeta?: string(name='TableMeta'),
}

model RestoreTableResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestoreTableResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestoreTableResponseBody(name='body'),
}

async function restoreTableWithOptions(request: RestoreTableRequest, runtime: Util.RuntimeOptions): RestoreTableResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.instantRecovery)) {
    query['InstantRecovery'] = request.instantRecovery;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restoreTime)) {
    query['RestoreTime'] = request.restoreTime;
  }
  if (!Util.isUnset(request.tableMeta)) {
    query['TableMeta'] = request.tableMeta;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestoreTable',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restoreTable(request: RestoreTableRequest): RestoreTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return restoreTableWithOptions(request, runtime);
}

model RevokeAccountPrivilegeRequest {
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBName?: string(name='DBName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeAccountPrivilegeResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeAccountPrivilegeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeAccountPrivilegeResponseBody(name='body'),
}

async function revokeAccountPrivilegeWithOptions(request: RevokeAccountPrivilegeRequest, runtime: Util.RuntimeOptions): RevokeAccountPrivilegeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBName)) {
    query['DBName'] = request.DBName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeAccountPrivilege',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeAccountPrivilege(request: RevokeAccountPrivilegeRequest): RevokeAccountPrivilegeResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeAccountPrivilegeWithOptions(request, runtime);
}

model RevokeOperatorPermissionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RevokeOperatorPermissionResponseBody = {
  requestId?: string(name='RequestId'),
}

model RevokeOperatorPermissionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RevokeOperatorPermissionResponseBody(name='body'),
}

async function revokeOperatorPermissionWithOptions(request: RevokeOperatorPermissionRequest, runtime: Util.RuntimeOptions): RevokeOperatorPermissionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RevokeOperatorPermission',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function revokeOperatorPermission(request: RevokeOperatorPermissionRequest): RevokeOperatorPermissionResponse {
  var runtime = new Util.RuntimeOptions{};
  return revokeOperatorPermissionWithOptions(request, runtime);
}

model StartDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceTransType?: int32(name='DBInstanceTransType'),
  dedicatedHostGroupId?: string(name='DedicatedHostGroupId'),
  effectiveTime?: string(name='EffectiveTime'),
  engineVersion?: string(name='EngineVersion'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  specifiedTime?: string(name='SpecifiedTime'),
  storage?: int32(name='Storage'),
  targetDBInstanceClass?: string(name='TargetDBInstanceClass'),
  targetDedicatedHostIdForLog?: string(name='TargetDedicatedHostIdForLog'),
  targetDedicatedHostIdForMaster?: string(name='TargetDedicatedHostIdForMaster'),
  targetDedicatedHostIdForSlave?: string(name='TargetDedicatedHostIdForSlave'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model StartDBInstanceResponseBody = {
  migrationId?: int32(name='MigrationId'),
  requestId?: string(name='RequestId'),
  taskId?: int32(name='TaskId'),
}

model StartDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartDBInstanceResponseBody(name='body'),
}

async function startDBInstanceWithOptions(request: StartDBInstanceRequest, runtime: Util.RuntimeOptions): StartDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceTransType)) {
    query['DBInstanceTransType'] = request.DBInstanceTransType;
  }
  if (!Util.isUnset(request.dedicatedHostGroupId)) {
    query['DedicatedHostGroupId'] = request.dedicatedHostGroupId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.specifiedTime)) {
    query['SpecifiedTime'] = request.specifiedTime;
  }
  if (!Util.isUnset(request.storage)) {
    query['Storage'] = request.storage;
  }
  if (!Util.isUnset(request.targetDBInstanceClass)) {
    query['TargetDBInstanceClass'] = request.targetDBInstanceClass;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForLog)) {
    query['TargetDedicatedHostIdForLog'] = request.targetDedicatedHostIdForLog;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForMaster)) {
    query['TargetDedicatedHostIdForMaster'] = request.targetDedicatedHostIdForMaster;
  }
  if (!Util.isUnset(request.targetDedicatedHostIdForSlave)) {
    query['TargetDedicatedHostIdForSlave'] = request.targetDedicatedHostIdForSlave;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startDBInstance(request: StartDBInstanceRequest): StartDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return startDBInstanceWithOptions(request, runtime);
}

model StopDBInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model StopDBInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model StopDBInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopDBInstanceResponseBody(name='body'),
}

async function stopDBInstanceWithOptions(request: StopDBInstanceRequest, runtime: Util.RuntimeOptions): StopDBInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopDBInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopDBInstance(request: StopDBInstanceRequest): StopDBInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopDBInstanceWithOptions(request, runtime);
}

model SwitchDBInstanceHARequest {
  DBInstanceId?: string(name='DBInstanceId'),
  effectiveTime?: string(name='EffectiveTime'),
  force?: string(name='Force'),
  nodeId?: string(name='NodeId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SwitchDBInstanceHAResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceHAResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDBInstanceHAResponseBody(name='body'),
}

async function switchDBInstanceHAWithOptions(request: SwitchDBInstanceHARequest, runtime: Util.RuntimeOptions): SwitchDBInstanceHAResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.nodeId)) {
    query['NodeId'] = request.nodeId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDBInstanceHA',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchDBInstanceHA(request: SwitchDBInstanceHARequest): SwitchDBInstanceHAResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceHAWithOptions(request, runtime);
}

model SwitchDBInstanceNetTypeRequest {
  clientToken?: string(name='ClientToken'),
  connectionStringPrefix?: string(name='ConnectionStringPrefix'),
  connectionStringType?: string(name='ConnectionStringType'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  port?: string(name='Port'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SwitchDBInstanceNetTypeResponseBody = {
  newConnectionString?: string(name='NewConnectionString'),
  oldConnectionString?: string(name='OldConnectionString'),
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceNetTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDBInstanceNetTypeResponseBody(name='body'),
}

async function switchDBInstanceNetTypeWithOptions(request: SwitchDBInstanceNetTypeRequest, runtime: Util.RuntimeOptions): SwitchDBInstanceNetTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.connectionStringPrefix)) {
    query['ConnectionStringPrefix'] = request.connectionStringPrefix;
  }
  if (!Util.isUnset(request.connectionStringType)) {
    query['ConnectionStringType'] = request.connectionStringType;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDBInstanceNetType',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchDBInstanceNetType(request: SwitchDBInstanceNetTypeRequest): SwitchDBInstanceNetTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceNetTypeWithOptions(request, runtime);
}

model SwitchDBInstanceVpcRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
}

model SwitchDBInstanceVpcResponseBody = {
  requestId?: string(name='RequestId'),
}

model SwitchDBInstanceVpcResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchDBInstanceVpcResponseBody(name='body'),
}

async function switchDBInstanceVpcWithOptions(request: SwitchDBInstanceVpcRequest, runtime: Util.RuntimeOptions): SwitchDBInstanceVpcResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchDBInstanceVpc',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchDBInstanceVpc(request: SwitchDBInstanceVpcRequest): SwitchDBInstanceVpcResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchDBInstanceVpcWithOptions(request, runtime);
}

model SwitchGuardToMasterInstanceRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model SwitchGuardToMasterInstanceResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  requestId?: string(name='RequestId'),
}

model SwitchGuardToMasterInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SwitchGuardToMasterInstanceResponseBody(name='body'),
}

async function switchGuardToMasterInstanceWithOptions(request: SwitchGuardToMasterInstanceRequest, runtime: Util.RuntimeOptions): SwitchGuardToMasterInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SwitchGuardToMasterInstance',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function switchGuardToMasterInstance(request: SwitchGuardToMasterInstanceRequest): SwitchGuardToMasterInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return switchGuardToMasterInstanceWithOptions(request, runtime);
}

model TagResourcesRequest {
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model TagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model TagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TagResourcesResponseBody(name='body'),
}

async function tagResourcesWithOptions(request: TagResourcesRequest, runtime: Util.RuntimeOptions): TagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TagResources',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function tagResources(request: TagResourcesRequest): TagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return tagResourcesWithOptions(request, runtime);
}

model TerminateMigrateTaskRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  migrateTaskId?: string(name='MigrateTaskId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model TerminateMigrateTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model TerminateMigrateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TerminateMigrateTaskResponseBody(name='body'),
}

async function terminateMigrateTaskWithOptions(request: TerminateMigrateTaskRequest, runtime: Util.RuntimeOptions): TerminateMigrateTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.migrateTaskId)) {
    query['MigrateTaskId'] = request.migrateTaskId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TerminateMigrateTask',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function terminateMigrateTask(request: TerminateMigrateTaskRequest): TerminateMigrateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return terminateMigrateTaskWithOptions(request, runtime);
}

model TransformDBInstancePayTypeRequest {
  autoRenew?: string(name='AutoRenew'),
  businessInfo?: string(name='BusinessInfo'),
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  usedTime?: int32(name='UsedTime'),
}

model TransformDBInstancePayTypeResponseBody = {
  chargeType?: string(name='ChargeType'),
  DBInstanceId?: string(name='DBInstanceId'),
  expiredTime?: string(name='ExpiredTime'),
  orderId?: long(name='OrderId'),
  requestId?: string(name='RequestId'),
}

model TransformDBInstancePayTypeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: TransformDBInstancePayTypeResponseBody(name='body'),
}

async function transformDBInstancePayTypeWithOptions(request: TransformDBInstancePayTypeRequest, runtime: Util.RuntimeOptions): TransformDBInstancePayTypeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.autoRenew)) {
    query['AutoRenew'] = request.autoRenew;
  }
  if (!Util.isUnset(request.businessInfo)) {
    query['BusinessInfo'] = request.businessInfo;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'TransformDBInstancePayType',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function transformDBInstancePayType(request: TransformDBInstancePayTypeRequest): TransformDBInstancePayTypeResponse {
  var runtime = new Util.RuntimeOptions{};
  return transformDBInstancePayTypeWithOptions(request, runtime);
}

model UnlockAccountRequest {
  accountName?: string(name='AccountName'),
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UnlockAccountResponseBody = {
  requestId?: string(name='RequestId'),
}

model UnlockAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UnlockAccountResponseBody(name='body'),
}

async function unlockAccountWithOptions(request: UnlockAccountRequest, runtime: Util.RuntimeOptions): UnlockAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.accountName)) {
    query['AccountName'] = request.accountName;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UnlockAccount',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function unlockAccount(request: UnlockAccountRequest): UnlockAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return unlockAccountWithOptions(request, runtime);
}

model UntagResourcesRequest {
  all?: boolean(name='All'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceId?: [ string ](name='ResourceId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  resourceType?: string(name='ResourceType'),
  tagKey?: [ string ](name='TagKey'),
}

model UntagResourcesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UntagResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UntagResourcesResponseBody(name='body'),
}

async function untagResourcesWithOptions(request: UntagResourcesRequest, runtime: Util.RuntimeOptions): UntagResourcesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.all)) {
    query['All'] = request.all;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceId)) {
    query['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.resourceType)) {
    query['ResourceType'] = request.resourceType;
  }
  if (!Util.isUnset(request.tagKey)) {
    query['TagKey'] = request.tagKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UntagResources',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function untagResources(request: UntagResourcesRequest): UntagResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return untagResourcesWithOptions(request, runtime);
}

model UpdateUserBackupFileRequest {
  backupId?: string(name='BackupId'),
  comment?: string(name='Comment'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retention?: int32(name='Retention'),
}

model UpdateUserBackupFileResponseBody = {
  backupId?: string(name='BackupId'),
  requestId?: string(name='RequestId'),
}

model UpdateUserBackupFileResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUserBackupFileResponseBody(name='body'),
}

async function updateUserBackupFileWithOptions(request: UpdateUserBackupFileRequest, runtime: Util.RuntimeOptions): UpdateUserBackupFileResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.comment)) {
    query['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUserBackupFile',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUserBackupFile(request: UpdateUserBackupFileRequest): UpdateUserBackupFileResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUserBackupFileWithOptions(request, runtime);
}

model UpgradeDBInstanceEngineVersionRequest {
  clientToken?: string(name='ClientToken'),
  DBInstanceId?: string(name='DBInstanceId'),
  effectiveTime?: string(name='EffectiveTime'),
  engineVersion?: string(name='EngineVersion'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model UpgradeDBInstanceEngineVersionResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceEngineVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceEngineVersionResponseBody(name='body'),
}

async function upgradeDBInstanceEngineVersionWithOptions(request: UpgradeDBInstanceEngineVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceEngineVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.effectiveTime)) {
    query['EffectiveTime'] = request.effectiveTime;
  }
  if (!Util.isUnset(request.engineVersion)) {
    query['EngineVersion'] = request.engineVersion;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceEngineVersion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeDBInstanceEngineVersion(request: UpgradeDBInstanceEngineVersionRequest): UpgradeDBInstanceEngineVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceEngineVersionWithOptions(request, runtime);
}

model UpgradeDBInstanceKernelVersionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  upgradeTime?: string(name='UpgradeTime'),
}

model UpgradeDBInstanceKernelVersionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  targetMinorVersion?: string(name='TargetMinorVersion'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceKernelVersionResponseBody(name='body'),
}

async function upgradeDBInstanceKernelVersionWithOptions(request: UpgradeDBInstanceKernelVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceKernelVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.targetMinorVersion)) {
    query['TargetMinorVersion'] = request.targetMinorVersion;
  }
  if (!Util.isUnset(request.upgradeTime)) {
    query['UpgradeTime'] = request.upgradeTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceKernelVersion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeDBInstanceKernelVersion(request: UpgradeDBInstanceKernelVersionRequest): UpgradeDBInstanceKernelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceKernelVersionWithOptions(request, runtime);
}

model UpgradeDBInstanceMajorVersionRequest {
  collectStatMode?: string(name='CollectStatMode'),
  DBInstanceClass?: string(name='DBInstanceClass'),
  DBInstanceId?: string(name='DBInstanceId'),
  DBInstanceStorage?: int32(name='DBInstanceStorage'),
  DBInstanceStorageType?: string(name='DBInstanceStorageType'),
  instanceNetworkType?: string(name='InstanceNetworkType'),
  payType?: string(name='PayType'),
  period?: string(name='Period'),
  privateIpAddress?: string(name='PrivateIpAddress'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchOver?: string(name='SwitchOver'),
  switchTime?: string(name='SwitchTime'),
  switchTimeMode?: string(name='SwitchTimeMode'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
  usedTime?: string(name='UsedTime'),
  VPCId?: string(name='VPCId'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
  zoneIdSlave1?: string(name='ZoneIdSlave1'),
  zoneIdSlave2?: string(name='ZoneIdSlave2'),
}

model UpgradeDBInstanceMajorVersionResponseBody = {
  DBInstanceId?: string(name='DBInstanceId'),
  orderId?: string(name='OrderId'),
  requestId?: string(name='RequestId'),
  taskId?: long(name='TaskId'),
}

model UpgradeDBInstanceMajorVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceMajorVersionResponseBody(name='body'),
}

async function upgradeDBInstanceMajorVersionWithOptions(request: UpgradeDBInstanceMajorVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceMajorVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.collectStatMode)) {
    query['CollectStatMode'] = request.collectStatMode;
  }
  if (!Util.isUnset(request.DBInstanceClass)) {
    query['DBInstanceClass'] = request.DBInstanceClass;
  }
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBInstanceStorage)) {
    query['DBInstanceStorage'] = request.DBInstanceStorage;
  }
  if (!Util.isUnset(request.DBInstanceStorageType)) {
    query['DBInstanceStorageType'] = request.DBInstanceStorageType;
  }
  if (!Util.isUnset(request.instanceNetworkType)) {
    query['InstanceNetworkType'] = request.instanceNetworkType;
  }
  if (!Util.isUnset(request.payType)) {
    query['PayType'] = request.payType;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.privateIpAddress)) {
    query['PrivateIpAddress'] = request.privateIpAddress;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchOver)) {
    query['SwitchOver'] = request.switchOver;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.switchTimeMode)) {
    query['SwitchTimeMode'] = request.switchTimeMode;
  }
  if (!Util.isUnset(request.targetMajorVersion)) {
    query['TargetMajorVersion'] = request.targetMajorVersion;
  }
  if (!Util.isUnset(request.usedTime)) {
    query['UsedTime'] = request.usedTime;
  }
  if (!Util.isUnset(request.VPCId)) {
    query['VPCId'] = request.VPCId;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.zoneIdSlave1)) {
    query['ZoneIdSlave1'] = request.zoneIdSlave1;
  }
  if (!Util.isUnset(request.zoneIdSlave2)) {
    query['ZoneIdSlave2'] = request.zoneIdSlave2;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceMajorVersion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeDBInstanceMajorVersion(request: UpgradeDBInstanceMajorVersionRequest): UpgradeDBInstanceMajorVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceMajorVersionWithOptions(request, runtime);
}

model UpgradeDBInstanceMajorVersionPrecheckRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
}

model UpgradeDBInstanceMajorVersionPrecheckResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  targetMajorVersion?: string(name='TargetMajorVersion'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBInstanceMajorVersionPrecheckResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBInstanceMajorVersionPrecheckResponseBody(name='body'),
}

async function upgradeDBInstanceMajorVersionPrecheckWithOptions(request: UpgradeDBInstanceMajorVersionPrecheckRequest, runtime: Util.RuntimeOptions): UpgradeDBInstanceMajorVersionPrecheckResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.targetMajorVersion)) {
    query['TargetMajorVersion'] = request.targetMajorVersion;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBInstanceMajorVersionPrecheck',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeDBInstanceMajorVersionPrecheck(request: UpgradeDBInstanceMajorVersionPrecheckRequest): UpgradeDBInstanceMajorVersionPrecheckResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBInstanceMajorVersionPrecheckWithOptions(request, runtime);
}

model UpgradeDBProxyInstanceKernelVersionRequest {
  DBInstanceId?: string(name='DBInstanceId'),
  DBProxyEngineType?: string(name='DBProxyEngineType'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  switchTime?: string(name='SwitchTime'),
  upgradeTime?: string(name='UpgradeTime'),
}

model UpgradeDBProxyInstanceKernelVersionResponseBody = {
  DBInstanceName?: string(name='DBInstanceName'),
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model UpgradeDBProxyInstanceKernelVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeDBProxyInstanceKernelVersionResponseBody(name='body'),
}

async function upgradeDBProxyInstanceKernelVersionWithOptions(request: UpgradeDBProxyInstanceKernelVersionRequest, runtime: Util.RuntimeOptions): UpgradeDBProxyInstanceKernelVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.DBInstanceId)) {
    query['DBInstanceId'] = request.DBInstanceId;
  }
  if (!Util.isUnset(request.DBProxyEngineType)) {
    query['DBProxyEngineType'] = request.DBProxyEngineType;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.switchTime)) {
    query['SwitchTime'] = request.switchTime;
  }
  if (!Util.isUnset(request.upgradeTime)) {
    query['UpgradeTime'] = request.upgradeTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeDBProxyInstanceKernelVersion',
    version = '2014-08-15',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeDBProxyInstanceKernelVersion(request: UpgradeDBProxyInstanceKernelVersionRequest): UpgradeDBProxyInstanceKernelVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeDBProxyInstanceKernelVersionWithOptions(request, runtime);
}

