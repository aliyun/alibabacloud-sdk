/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'Eci';
  @version = '2018-08-08';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model CommitContainerRequest {
  acrRegistryInfo?: {
    arnService?: string(name='ArnService', description='The RAM role ARN of the account to which permissions are granted during a cross-account authorization.', example='acs:ram::1609982529******:role/role-test'),
    arnUser?: string(name='ArnUser', description='The RAM role ARN of the account that is used to grant permissions during a cross-account authorization.', example='acs:ram::1298452580******:role/role-test'),
    instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
    regionId?: string(name='RegionId', description='The ID of the region where the Container Registry Enterprise Edition instance resides.', example='cn-hangzhou'),
  }(name='AcrRegistryInfo', description='The access credential configurations of the Container Registry Enterprise Edition instance.\\
If you use a Container Registry Personal Edition instance, you can leave this parameter empty.', position='Query'),
  arn?: {
    roleArn?: string(name='RoleArn', description='The ARN of the RAM role of the Container Registry Enterprise Edition instance.', example='acs:ram:xxx'),
    roleType?: string(name='RoleType', description='The type of the authorization.', example='user'),
  }(name='Arn', description='The ARN that is required for authorization.', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The ID of the container group.', example='eci-bp1do4xz75fa5sd****', position='Query'),
  containerName: string(name='ContainerName', description='The name of the container.', example='container-1', position='Query'),
  image?: {
    author?: string(name='Author', description='The authorization of the image.', example='ECI'),
    message?: string(name='Message', description='The message about the image.', example='test commit'),
    repository: string(name='Repository', description='The image repository.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eastest/registry-test'),
    tag: string(name='Tag', description='The tag of the image. This parameter is empty by default, which indicates that the tag is not modified.', example='0.0.6'),
  }(name='Image', description='The image of the container.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CommitContainerResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB8D2B22-D636-4182-****-1FC9DBDAD66F'),
  taskId?: string(name='TaskId', description='The ID of the task.', example='t-bp18cwvrb3v9tjk0tekz'),
}

model CommitContainerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CommitContainerResponseBody(name='body'),
}

/**
  * You must specify the Alibaba Cloud Resource Name (ARN) of the RAM role of the Container Registry Enterprise Edition instance to grant the elastic container instance to assume the RAM role to push images.
  *
 */
async function commitContainer(request: CommitContainerRequest): CommitContainerResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CommitContainer', 'POST', '/', 'json', false, 'json', request);
}

model CopyDataCacheRequest {
  bucket?: string(name='Bucket', description='The bucket in which the DataCache is stored.', example='default', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  dataCacheId: string(name='DataCacheId', description='The ID of the DataCache in the source region.', example='edc-bp15l4vvys94oo******', position='Query'),
  destinationRegionId: string(name='DestinationRegionId', description='The destination region of the DataCache.', example='cn-hangzhou', position='Query'),
  name?: string(name='Name', description='The DataCache name.', example='test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  path?: string(name='Path', description='The storage path of the data.', example='/bucket-test', position='Query'),
  regionId: string(name='RegionId', description='The source region of the DataCache.', example='cn-beijing', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group to which the DataCache belongs.', example='rg-2df3isufhi38****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The number of days for which the DataCache is retained.', example='7', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='testkey'),
      value?: string(name='Value', description='The value of the tag.', example='testvalue'),
    }
  ](name='Tag', description='The tags of the DataCache.', position='Query'),
}

model CopyDataCacheResponseBody = {
  dataCacheId?: string(name='DataCacheId', description='The ID generated for the DataCache in the destination region.', example='edc-bp1423y6d7v7l6ua****'),
  requestId?: string(name='RequestId', description='The request ID.', example='58EE0CB3-C864-5395-A4F7-24F425074839'),
}

model CopyDataCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CopyDataCacheResponseBody(name='body'),
}

/**
  * You cannot directly use a DataCache across regions. You can call this operation to copy a DataCache from one region to another region. This operation is suitable for the following scenarios:
  * *   If you want to use a DataCache across regions and the DataCache exists in Region A, you can call this operation to quickly copy the DataCache to Region B.
  * *   If you directly pull data from a region outside China to a region inside the Chinese mainland when you create a DataCache, the data may be pulled at a slow speed due to network limits. In this case, you can create a DataCache in a region outside the Chinese mainland but inside China, such as the China (Hong Kong) region, and call this operation to copy the data to the region inside the Chinese mainland.
  * > The process of copying a DataCache is equivalent to copying a snapshot. You are charged for the traffic generated during the copy process and the storage of the generated DataCache.
  *
 */
async function copyDataCache(request: CopyDataCacheRequest): CopyDataCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CopyDataCache', 'POST', '/', 'json', false, 'json', request);
}

model CreateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer', description='The IP addresses of the DNS servers.', example='172.10.*.**'),
    option?: [ 
      {
        name?: string(name='Name', description='The name of the option.', example='name'),
        value?: string(name='Value', description='The value of the option.', example='value'),
      }
    ](name='Option', description='Configuration options of the DNS server.'),
    search?: [ string ](name='Search', description='The search domains of the DNS server.', example='svc.local.kubenetes'),
  }(name='DnsConfig', position='Query'),
  hostSecurityContext?: {
    sysctl?: [ 
      {
        name?: string(name='Name', description='The key of the unsafe sysctl when you modify sysctls by configuring a security context. Valid values:

*   kernel.shm \\* (except kernel.shm_rmid_forced)
*   kernel.msg\\*kernel.sem
*   fs.mqueue.\\*
*   net.\\*(except net.ipv4.tcp_syncookies, net.ipv4.ping_group_range, and net.ipv4.ip_unprivileged_port_start)', example='kernel.msgmax'),
        value?: string(name='Value', description='The value of the unsafe sysctl when you modify sysctls by configuring a security context.', example='65536'),
      }
    ](name='Sysctl', description='Configure a security context to modify unsafe sysctls. For more information, see [Configure a security context](~~462313~~).'),
  }(name='HostSecurityContext', position='Query'),
  securityContext?: {
    sysctl?: [ 
      {
        name?: string(name='Name', description='The name of the safe sysctl when you configure a security context to modify sysctls. Valid values:

*   net.ipv4.ping_group_range
*   net.ipv4.ip_unprivileged_port_start', example='kernel.msgmax'),
        value?: string(name='Value', description='The value of the safe sysctl when you configure a security context to modify sysctls.', example='65536'),
      }
    ](name='Sysctl', description='Configure a security context to modify sysctls. For more information, see [Configure a security context](~~462313~~)'),
  }(name='SecurityContext', position='Query'),
  acrRegistryInfo?: [ 
    {
      arnService?: string(name='ArnService', description='The Alibaba Cloud Resource Name (ARN) of the RAM roles in the Alibaba Cloud account to which the elastic container instance belongs.', example='acs:ram::1609982529******:role/role-assume'),
      arnUser?: string(name='ArnUser', description='The ARN of the RAM roles in the Alibaba Cloud account to which the Container Registry instance belongs.', example='acs:ram::1298452580******:role/role-acr'),
      domain?: [ string ](name='Domain', description='The domain names of the Container Registry Enterprise Edition instance. By default, all domain names of the instance are displayed. You can specify multiple domain names. Separate multiple domain names with commas (,).', example='*****-****-registry.cn-beijing.cr.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of the Container Registry Enterprise Edition instance.', example='acr-test'),
      regionId?: string(name='RegionId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cn-beijing'),
    }
  ](name='AcrRegistryInfo', description='The information about the Container Registry Enterprise Edition instance. For more information, see [Pull images from a Container Registry Enterprise Edition instance without using secrets](~~194250~~).', position='Query'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds', description='The validity period of the elastic container instance. When this period expires, the instance is forced to exit. Unit: seconds.', example='1000', position='Query'),
  autoCreateEip?: boolean(name='AutoCreateEip', description='Specifies whether to automatically create an EIP and associate it with the elastic container instance.', example='true', position='Query'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='Specifies whether to automatically match image caches. Default value: false.', example='false', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency of requests?](~~25693~~)', example='123e4567-xxxx-12d3-xxxx-426655440000', position='Query'),
  container: [ 
    {
      livenessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg', description='The arguments that are passed to the startup command of the container. You can specify a maximum of 10 arguments.', example='100', maximum=65535),
      command?: [ string ](name='Command', description='The commands that you want to run to perform checks in containers.', example='sleep'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container. Unit: cores.', example='0.25'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The name of the environment variable. The name must be 1 to 128 characters in length, and can contain letters, digits, and underscores (\\_). It cannot start with a digit.``', example='PATH'),
          value?: string(name='Value', description='The value of the environment variable. The value can be up to 256 characters in length.', example='/usr/local/bin'),
        }
      ](name='EnvironmentVar', description='The environment variable of the container.'),
      environmentVarHide?: boolean(name='EnvironmentVarHide', description='Specifies whether to hide the information about the environment variable when you query the details of an elastic container instance (ECI). Valid values:

*   false (default): does not hide the information about the environment variable.
*   true: does not return the information about the environment variable. If the environment variable contains sensitive information, you can set this parameter to true to improve the security of the information.', example='false'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image: string(name='Image', description='The image of the container.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:latest', minimum=1, maximum=255),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The policy that you want to use to pull an image. Valid values:

*   Always: Image pulling is always performed.
*   IfNotPresent: On-premises images are used first. If no on-premises images are available, image pulling is performed.
*   Never: Image pulling is not performed. On-premises images are always used.', example='Always'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec', description='The commands to be executed in containers when you use the CLI to specify the postStart callback function.', example='["/bin/sh", "-c", "echo Hello from the postStart handler > /usr/share/message"]'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost', description='The IP address of the host that receives HTTP GET requests when you use HTTP requests to specify the postStart callback function.', example='10.0.XX.XX'),
      lifecyclePostStartHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name', description='The key of the custom field in the HTTP GET request header when you use HTTP requests to specify the postStart callback function.', example='Xiao-Custom-Header'),
          value?: string(name='Value', description='The value of the custom field in the HTTP GET request header when you use HTTP requests to specify the postStart callback function.', example='test-postStart'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeader', description='The HTTP GET request header.'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath', description='The path to which HTTP GET requests are sent when you use HTTP requests to specify the postStart callback function.', example='/healthyz'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort', description='The port to which HTTP GET requests are sent when you use HTTP requests to specify the postStart callback function.', example='5050'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme', description='The protocol type of HTTP GET requests when you use HTTP requests to specify the postStart callback function. Valid values:

*   HTTP
*   HTTPS', example='HTTPS'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost', description='The port that is detected by TCP sockets when you use TCP sockets to specify the postStart callback function.', example='10.0.XX.XX'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort', description='The port that is detected by TCP sockets when you use TCP sockets to specify the postStart callback function.', example='80'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec', description='The commands to be executed in containers when you use the CLI to specify the preStop callback function.', example='["/bin/sh", "-c","echo Hello from the preStop handler > /usr/share/message"]'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost', description='The IP address of the host that receives HTTP GET requests when you use HTTP requests to specify the preStop callback function.', example='10.0.XX.XX'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name', description='The key of the custom field in the HTTP GET request header when you use HTTP requests to specify the preStop callback function.', example='Xiao-Custom-Header'),
          value?: string(name='Value', description='The value of the custom field in the HTTP GET request header when you use HTTP requests to specify the preStop callback function.', example='test-preStop'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader', description='The HTTP GET request header.'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath', description='The path to which HTTP GET requests are sent when you use HTTP requests to specify the preStop callback function.', example='/healthyz'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort', description='The port to which HTTP GET requests are sent when you use HTTP requests to specify the preStop callback function.', example='88'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme', description='The protocol type of HTTP GET requests when you use HTTP requests to specify the preStop callback function. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost', description='The host IP address that is detected by TCP sockets when you use TCP sockets to specify the preStop callback function.', example='10.0.XX.XX'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort', description='The port that is detected by TCP sockets when you use TCP sockets to specify the preStop callback function.', example='90'),
      memory?: float(name='Memory', description='The memory size of the container. Unit: GiB', example='0.5'),
      name: string(name='Name', description='The container name.', example='nginx'),
      port?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='80'),
          protocol?: string(name='Protocol', description='The protocol type. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='Port', description='The port to which HTTP GET requests are sent when you use HTTP requests to perform health checks.'),
      securityContextRunAsGroup?: long(name='SecurityContextRunAsGroup'),
      securityContextRunAsNonRoot?: boolean(name='SecurityContextRunAsNonRoot'),
      stdin?: boolean(name='Stdin', description='Specifies whether the container allocates a buffer for standard input in the container runtime. If you do not specify this parameter, an end-of-file (EOF) error occurs when standard input in the container is read. Default value: false.', example='false'),
      stdinOnce?: boolean(name='StdinOnce', description='Specifies whether to keep the standard input stream open in the container runtime across multiple attach sessions if Stdin is set to true.\\
If StdinOnce is set to true, the standard input stream is opened when the container is started, remains empty until the first client is attached to standard input, and then remains open and receives data until the client is disconnected. When the client is disconnected, the standard input stream is closed and remains closed until the container is restarted.', example='false'),
      terminationMessagePath?: string(name='TerminationMessagePath', description='The path of the file from which the system retrieves termination messages of the container when the container exits.', example='/tmp/termination-log'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy', description='The message notification policy. This parameter is empty by default. You can use only Message Service (MNS) queues to configure notifications.', example='FallbackToLogsOnError'),
      tty?: boolean(name='Tty', description='Specifies whether to enable interaction. Default value: false.

If you set Command to /bin/bash, you must set this parameter to true.', example='false'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath', description='The directory to which the volume is mounted.

>  The data stored in this directory is overwritten by the data on the volume. Specify this parameter with caution.', example='/pod/data'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: This volume mount does not receive subsequent mounts that are performed on this volume or subdirectories of this volume.
*   HostToCotainer: The volume mount receives subsequent mounts that are performed on this volume or the subdirectories of this volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives subsequent mounts that are performed on the volume or the subdirectories of the volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The name of the volume. This parameter is the same as Name in the Volume object.', example='default-volume1'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the volume is read-only. Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume.', example='data2/'),
        }
      ](name='VolumeMount', description='The information about the volume that you want to mount on the container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/local/'),
    }
  ](name='Container', description='The information about the containers.', position='Query'),
  containerGroupName: string(name='ContainerGroupName', description='The name of the elastic container instance. Format requirements:

*   The name must be 2 to 128 characters in length
*   The name can contain lowercase letters, digits, and hyphens (-). It cannot start or end with a hyphen (-).', example='nginx-test', position='Query'),
  containerResourceView?: boolean(name='ContainerResourceView', description='Specifies whether to enable container resource view. Container resource view displays the actual container resource data instead of data of the host. If the specifications of the generated elastic container instance are larger than the specifications that you request for when you create the instance, you can enable the ContainerResourceView feature to ensure that the resources that you view in the container are the same as the resources that you request for.', example='false', position='Query'),
  corePattern?: string(name='CorePattern', description='The path to store core dump files. For more information, see [Save core files to volumes](~~167801~~).

> The path cannot start with a vertical bar (`|`). You cannot use core dump files to configure executable programs.', example='/xx/xx/core', position='Query'),
  cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the elastic container instance.', example='1.0', position='Query'),
  cpuArchitecture?: string(name='CpuArchitecture', position='Query'),
  cpuOptionsCore?: int32(name='CpuOptionsCore', description='The number of physical CPU cores. You can specify this parameter only for specific instance types. For more information, see [Specify custom CPU options](~~197781~~).', example='2', minimum=0, maximum=1000, position='Query'),
  cpuOptionsNuma?: string(name='CpuOptionsNuma', description='This parameter is not available.', example='1', position='Query'),
  cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore', description='The number of threads per core. You can specify this parameter only for specific instance types. If you set this parameter to 1, Hyper-Threading is disabled. For more information, see [Specify custom CPU options](~~197781~~).', example='2', minimum=0, maximum=1000, position='Query'),
  dataCacheBucket?: string(name='DataCacheBucket', description='The bucket to store data caches.', example='default', position='Query'),
  dataCacheBurstingEnabled?: boolean(name='DataCacheBurstingEnabled', description='Specifies whether to enable the performance burst feature when ESSDs AutoPL are used for data caching. For more information, see [ESSDs AutoPL](~~368372~~).', example='false', position='Query'),
  dataCachePL?: string(name='DataCachePL', description='The performance level of the disk used by data caches.\\
Enhanced SSDs (ESSDs) are preferentially used. The default performance level is PL1.', example='PL1', position='Query'),
  dataCacheProvisionedIops?: long(name='DataCacheProvisionedIops', description='The input/output operations per second (IOPS) provisioned for ESSDs AutoPL when ESSDs AutoPL are used for data caching.\\
Valid values: 0 to min{50000, 1000 × Capacity - Baseline IOPS}. Baseline IOPS = min{1,800 + 50 × Capacity, 50,000}.\\
For more information, see [ESSDs AutoPL](~~368372~~).', example='40000', position='Query'),
  dnsPolicy?: string(name='DnsPolicy', description='The Domain Name System (DNS) policy. Valid values:

*   None: uses the DNS that is specified for DnsConfig-related parameters.
*   Default: uses the DNS that is specified for the runtime environment.', example='Default', position='Query'),
  dryRun?: boolean(name='DryRun', description='Specifies whether to perform only a dry run without performing the actual request. Valid values:

*   true: performs only a dry run without creating an elastic container instance. The check items include the request format, service limits, resource inventory, and whether the required parameters are specified. If the request fails the dry run, an error is returned. If the request passes the dry run, the DryRun.Success error code is returned.
*   false (default): performs a dry run, and creates an elastic container instance after the request passes the dry run.', example='false', position='Query'),
  egressBandwidth?: long(name='EgressBandwidth', description='The maximum outbound bandwidth. Unit: bytes.', example='1024000', minimum=0, maximum=9223372036854775807, position='Query'),
  eipBandwidth?: int32(name='EipBandwidth', description='The bandwidth of the EIP. Unit: Mbit/s. Default value: 5.\\
You can specify this parameter when you set AutoCreateEip to true.', example='5', minimum=0, maximum=1000000, position='Query'),
  eipCommonBandwidthPackage?: string(name='EipCommonBandwidthPackage', description='Specifies the EIP bandwidth plan that you want to use.', example='cbwp-2zeukbj916scmj51m****', position='Query'),
  eipISP?: string(name='EipISP', description='The line type of the elastic IP address (EIP). Valid values:

*   BGP: BGP (Multi-ISP) lines
*   BGP_PRO: BGP (Multi-ISP) Pro lines', example='BPG', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The ID of the elastic IP address (EIP).', example='eip-uf66jeqopgqa9hdn****', position='Query'),
  ephemeralStorage?: int32(name='EphemeralStorage', description='The increased storage capacity of the temporary storage space. Unit: GiB.\\
For more information, see [Increase the storage capacity of the temporary storage space](~~204066~~).', example='20', minimum=0, maximum=5000, position='Query'),
  fixedIp?: string(name='FixedIp', description='Specifies whether to configure the instance to use a fixed IP address. For more information, see [Configure an elastic container instance to use a fixed IP address](~~2381086~~).', example='true', position='Query'),
  fixedIpRetainHour?: int32(name='FixedIpRetainHour', description='The retention period of the fixed IP address after the original instance is released and the fixed IP address becomes idle. Unit: hours. Default value: 48.', example='24', position='Query'),
  hostAliase?: [ 
    {
      hostname?: [ string ](name='Hostname', description='The hostname of the elastic container instance.', example='hehe.com'),
      ip?: string(name='Ip', description='The IP address of the host.', example='1.1.1.1'),
    }
  ](name='HostAliase', description='The alias of the elastic container instance.', position='Query'),
  hostName?: string(name='HostName', description='The hostname of the instance.', example='test', position='Query'),
  imageAccelerateMode?: string(name='ImageAccelerateMode', description='The image acceleration mode. Valid values:

*   nydus: Nydus is used to accelerate image pulling. The images must support Nydus.
*   dadi: DADI is used to accelerate image pulling. The images must support DADI.
*   p2p: P2P is used to accelerate image pulling. The images must support P2P.
*   imc: Image caches are used to accelerate image pulling.', example='imc', position='Query'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password', description='The password that you use to access the image repository.', example='yourpassword'),
      server?: string(name='Server', description='The address of the image repository.', example='registry-vpc.cn-shanghai.aliyuncs.com'),
      userName?: string(name='UserName', description='The username that you use to access the image repository.', example='yourusername'),
    }
  ](name='ImageRegistryCredential', description='The information about the image repository.', position='Query'),
  imageSnapshotId?: string(name='ImageSnapshotId', description='The ID of the image cache. For more information, see [Use image caches to accelerate the creation of instances](~~141281~~).', example='imc-2zebxkiifuyzzlhl****', position='Query'),
  ingressBandwidth?: long(name='IngressBandwidth', description='The maximum inbound bandwidth. Unit: bytes.', example='1024000', minimum=0, maximum=9223372036854775807, position='Query'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg', description='The arguments that are passed to the startup command of the init container.', example='10', maximum=65535),
      command?: [ string ](name='Command', description='The startup commands of the init container.', example='sleep'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the init container. Unit: cores.', example='0.5'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The name of the environment variable. The name must be 1 to 128 characters in length, and can contain letters, digits, and underscores (\\_). It cannot start with a digit.``', example='Path'),
          value?: string(name='Value', description='The value of the environment variable. The value can be up to 256 characters in length.', example='/usr/bin/'),
        }
      ](name='EnvironmentVar', description='The environment variable of the init container.'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the init container.', example='1'),
      image?: string(name='Image', description='The image of the init container.', example='nginx'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The policy for image pulling. Valid values:

*   Always: Each time instances are created, image pulling is performed.
*   IfNotPresent: On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: On-premises images are always used. Image pulling is not performed.', example='Always'),
      memory?: float(name='Memory', description='The memory size of the init container. Unit: GiB.', example='1.0'),
      name?: string(name='Name', description='The container name.', example='test-init'),
      port?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='8888'),
          protocol?: string(name='Protocol', description='The protocol type. Valid values:

*   TCP
*   UDP', example='TCP'),
        }
      ](name='Port', description='The port number of the init container.'),
      terminationMessagePath?: string(name='TerminationMessagePath', description='The path of the file from which the system retrieves termination messages of the init container when the init container exits.', example='/tmp/termination-log'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy', description='The message notification policy. This parameter is empty by default.', example='*****'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath', description='The directory to which the volume is mounted. The data stored in this directory is overwritten by the data on the volume. Specify this parameter with caution.', example='/usr/share/'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to the volume or to the subdirectories of the volume.
*   HostToCotainer: The volume mount receives subsequent mounts that are mounted to the volume or to the subdirectories of the volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives subsequent mounts that are mounted to the volume or to the subdirectories of the volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The volume name.', example='test-empty'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the mount path is read-only. Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume. The pod can mount different directories of the same volume to different directories of the init container.', example='/usr/sub/'),
        }
      ](name='VolumeMount', description='The information about the volume that you want to mount on the init container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the init container.', example='/usr/local'),
    }
  ](name='InitContainer', description='The information about the init containers.', position='Query'),
  insecureRegistry?: string(name='InsecureRegistry', description='The address of the self-managed image repository. When you create an elastic container instance by using an image in a self-managed image repository that uses a self-signed certificate, you must specify this parameter to skip the certificate authentication. This prevents image pull failures caused by certificate authentication failures.', example='"harbor***.pre.com,192.168.XX.XX:5000,reg***.test.com:80"', position='Query'),
  instanceType?: string(name='InstanceType', description='The ECS instance type. Different instance types are supported. For more information, see [Specify an ECS instance type to create an elastic container instance](~~114664~~).', example='ecs.c5.xlarge', position='Query'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount', description='The number of IPv6 addresses. Set the value to 1. You can assign only one IPv6 address to an elastic container instance.', example='1', position='Query'),
  ipv6GatewayBandwidth?: string(name='Ipv6GatewayBandwidth', description='The peak Internet bandwidth of the IPv6 address when the Ipv6GatewayBandwidthEnable parameter is set to true. Valid values:

*   If the billing method for the Internet bandwidth of the IPv6 gateway is pay-by-bandwidth, the Internet bandwidth of the IPv6 address ranges from 1 to 2,000 Mbit/s.

*   If the billing method for the Internet bandwidth of the IPv6 gateway is pay-by-traffic, the Internet bandwidth range of the IPv6 address is based on the edition of the IPv6 gateway.

    *   If the IPv6 gateway is of Free Edition, the Internet bandwidth of the IPv6 address ranges from 1 to 200 Mbit/s.
    *   If the IPv6 gateway is of Enterprise Edition, the Internet bandwidth of the IPv6 address ranges from 1 to 500 Mbit/s.
    *   If the IPv6 gateway is of Enhanced Enterprise Edition, the Internet bandwidth of the IPv6 address ranges from 1 to 1,000 Mbit/s.

The default value is the maximum value in the Internet bandwidth range of the IPv6 gateway.', example='100', position='Query'),
  ipv6GatewayBandwidthEnable?: boolean(name='Ipv6GatewayBandwidthEnable', description='Specifies whether to enable IPv6 Internet access for the elastic container instance.', example='true', position='Query'),
  memory?: float(name='Memory', description='The memory size that you want to allocate to the elastic container instance. Unit: GiB.', example='2.0', position='Query'),
  ntpServer?: [ string ](name='NtpServer', description='The domain names of the NTP server.', example='ntp.cloud.aliyuncs.com', position='Query'),
  osType?: string(name='OsType', position='Query'),
  overheadReservationOption?: {
    enableOverheadReservation?: boolean(name='EnableOverheadReservation'),
  }(name='OverheadReservationOption', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plainHttpRegistry?: string(name='PlainHttpRegistry', description='The address of the self-managed image repository. When you create an elastic container instance by using an image in a self-managed image repository that uses the HTTP protocol, you must specify this parameter. This allows Elastic Container Instance to pull the image over the HTTP protocol instead over the default HTTPS protocol. This prevents image pull failures caused by different protocols.', example='"harbor***.pre.com,192.168.XX.XX:5000,reg***.test.com:80"', position='Query'),
  privateIpAddress?: string(name='PrivateIpAddress', description='The private IP address of the elastic container instance. Only IPv4 addresses are supported. Make sure that the IP address is idle.', example='172.16.0.1', position='Query'),
  ramRoleName?: string(name='RamRoleName', description='The name of the RAM role that you want to associate with the elastic container instance. You can use the RAM role to access elastic container instances and ECS instances. For more information, see [Use an instance RAM role by calling API operations](~~61178~~).', example='RamTestRole', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instance belongs.', example='rg-uf66jeqopgqa9hdn****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restartPolicy?: string(name='RestartPolicy', description='The restart policy of the elastic container instance. Valid values:

*   Always: Always restarts the instance.
*   Never: Never restarts the instance.
*   OnFailure: Restarts the instance when the last start failed.

Default value: Always.', example='Always', position='Query'),
  scheduleStrategy?: string(name='ScheduleStrategy', description='The resource scheduling policy when you specify multiple zones to create an elastic container instance. To specify multiple zones, you can use the VSwitchId to specify multiple vSwitches. Valid values:

*   VSwitchOrdered: The system schedules resources in the sequence of the vSwitches.
*   VSwitchRandom: The system schedules resources at random.

For more information, see [Specify multiple zones to create an elastic container instance](~~157290~~).', example='VSwitchOrdered', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the instance is assigned. Instances within the same security group can access each other.

If you do not specify a security group, the system automatically uses the default security group in the region that you selected. Make sure that the inbound rules of the security group contain the container protocols and port numbers that you want to expose. If you do not have a default security group in the region, the system creates a default security group, and then adds the container protocols and port numbers that you specified to the inbound rules of the security group.', example='sg-uf66jeqopgqa9hdn****', position='Query'),
  shareProcessNamespace?: boolean(name='ShareProcessNamespace', description='Specifies whether to use a shared namespace. Default value: false.', example='false', position='Query'),
  spotDuration?: long(name='SpotDuration', description='The protection period of the preemptible instance. Unit: hours. Default value: 1. A value of 0 indicates no protection period.', example='1', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible elastic container instance. The value can contain up to three decimal places.

If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.', example='0.025', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the instance. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance whose bidding price is based on the market price at the time of purchase.

Default value: NoSpot.', example='SpotWithPriceLimit', position='Query'),
  strictSpot?: boolean(name='StrictSpot', description='Specifies whether to enable periodical execution.

*   true: enables periodical execution.
*   false: disables periodical execution.', example='true', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of a tag. The tag key cannot be an empty string and must be unique. The tag key can be up to 64 characters in length and cannot contain `http://` or `https://`. The tag key cannot start with `acs:` or `aliyun`.', example='version'),
      value?: string(name='Value', description='The value of a tag. The tag value can be an empty string. The tag value can be up to 128 characters in length and cannot contain `http://` or `https://`. The tag value cannot start with `acs:`.', example='3'),
    }
  ](name='Tag', description='The tags that you want to bind with the instance. You can bind a maximum of 20 tags. For more information, see [Use tags to manage elastic container instances](~~146608~~).', position='Query'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds', description='The buffer time during which the program handles operations before the program stops. Unit: seconds.', example='60', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the instance is connected. You can specify up to 10 vSwitch IDs. Separate multiple vSwitch IDs with commas (,). Example: `vsw-***,vsw-***`.

If no vSwitch is specified, the system automatically uses the default vSwitch in the default VPC in the region that you selected. If you do not have a default VPC or a default vSwitch in the region, the system automatically creates a default VPC and a default vSwitch.

> The number of IP addresses in the vSwitch CIDR block determines the maximum number of elastic container instances that can be created for the vSwitch. Before you create elastic container instances, plan the CIDR block of the vSwitch.', example='vsw-bp1xpiowfm5vo8o3c****,vsw-bp1rkyjgr1xwoho6k****', position='Query'),
  volume?: [ 
    {
      configFileVolume: {
        configFileToPath?: [ 
          {
            content?: string(name='Content'),
            mode?: int32(name='Mode'),
            path?: string(name='Path'),
          }
        ](name='ConfigFileToPath'),
        defaultMode?: int32(name='DefaultMode'),
      }(name='ConfigFileVolume'),
      diskVolume: {
        diskId?: string(name='DiskId'),
        diskSize?: int32(name='DiskSize'),
        fsType?: string(name='FsType'),
      }(name='DiskVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
        sizeLimit?: string(name='SizeLimit'),
      }(name='EmptyDirVolume'),
      flexVolume: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      name?: string(name='Name', description='The name of the volume.', example='default-volume1'),
      type?: string(name='Type', description='The type of the volume when you set the Type parameter to HostPathVolume. Valid values:

*   Directory
*   File', example='ConfigFileVolume'),
    }
  ](name='Volume', description='Information about volumes.', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone in which the elastic container instance is deployed. If you do not specify this parameter, the system selects a zone.

This parameter is empty by default.', example='cn-hangzhou-b', position='Query'),
}

model CreateContainerGroupResponseBody = {
  containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-uf6fonnghi50u374****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model CreateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateContainerGroupResponseBody(name='body'),
}

/**
  * When you call the CreateContainerGroup operation to create an elastic container instance, the system creates a service-linked role named AliyunServiceRoleForECI. This role is used to access other Alibaba Cloud services such as Elastic Compute Service (ECS) and Virtual Private Cloud (VPC). For more information, see [Elastic Container Instance service-linked role](~~212914~~).
  * When you create an elastic container instance, you can configure features such as instances, images, and storage based on your business requirements. For information about parameters configured for the features and the description of the parameters, see the following documents:
  * **Instances** You can use one of the following methods to create an elastic container instance:
  * *   [Specify the number of vCPUs and memory size to create an elastic container instance](~~114662~~)
  *     *   [Create job-optimized elastic container instances](~~324246~~)
  *     *   [Ignore special containers during resource adjustment](~~446853~~)
  * *   [Specify ECS instance types to create an elastic container instance](~~114664~~)
  * Both the preceding creation methods support the following features:
  * *   [Specify custom CPU options](~~197781~~)
  * *   [Create a preemptible elastic container instance](~~157759~~)
  * *   [Configure multiple zones](~~157290~~)
  * *   [Configure multiple specifications](~~146468~~)
  * *   [Use tags to manage elastic container instances](~~146608~~)
  * **Images**
  * *   [Configure a container image](~~461311~~)
  * *   [Use the image cache feature to accelerate the creation of an elastic container instance](~~141281~~)
  * *   [Specify a Container Registry Enterprise Edition instance](~~194250~~)
  * *   [Use self-managed image repositories](~~378059~~)
  * **Networking**
  * *   [Create and Associate an EIP](~~99146~~)
  * *   [Assign a security group](~~176237~~)
  * *   [Assign an IPv6 address to an elastic container instance](~~451282~~)
  * *   [Configure maximum bandwidth](~~190635~~)
  * **Storage**
  * *   [Mount a disk volume](~~144571~~)
  * *   [Mount a NAS volume](~~464075~~)
  * *   [Mount an OSS bucket to an elastic container instance as a volume](~~464076~~)
  * *   [Mount an emptyDir volume](~~464078~~)
  * *   [Mount a ConfigFile volume](~~464080~~)
  * *   [Increase the size of the temporary storage space](~~204066~~)
  * **Container configuration**
  * *   [Configure startup commands and arguments for a container](~~94593~~)
  * *   [Use probes to perform health checks on a container](~~99053~~)
  * *   [Obtain metadata by using environment variables](~~141788~~)
  * *   [Configure a security context](~~462313~~)
  * *   [Configure the NTP service](~~462768~~)
  * **Logging and O\\&M**
  * *   [Use environment variables to configure log collection](~~121973~~)
  * *   [Save core files to volumes](~~167801~~)
  *
 */
async function createContainerGroup(request: CreateContainerGroupRequest): CreateContainerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateContainerGroup', 'POST', '/', 'json', false, 'json', request);
}

model CreateDataCacheRequest {
  bucket?: string(name='Bucket', description='The bucket in which the data is stored. By default, the default bucket is used. You can use a custom bucket for business grouping and to prevent path conflicts.

>  eci-system is the reserved bucket of the ECI and cannot be used.', example='default', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).', example='123e4567-****-12d3-****-426655440000', position='Query'),
  dataSource?: {
    options?: map[string]string(name='Options', description='The parameters that are configured for the data source.'),
    type?: string(name='Type', description='The type of the data source. Valid values:

*   URL
*   NAS
*   OSS
*   SNAPSHOT', example='NAS'),
  }(name='DataSource', description='The data source.', position='Query'),
  eipCreateParam?: {
    bandwidth?: int32(name='Bandwidth', description='The bandwidth of the EIP. Unit: Mbit/s. Default value: 5.', example='10'),
    commonBandwidthPackage?: string(name='CommonBandwidthPackage', description='The EIP bandwidth plan to be associated.', example='cbwp-2zeukbj916scmj51m****'),
    ISP?: string(name='ISP', description='The line type of the EIP. Valid values:

*   BGP: BGP (Multi-ISP) line
*   BGP_PRO: BGP (Multi-ISP) Pro line', example='BGP'),
    internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-data-transfer', example='PayByTraffic'),
    publicIpAddressPoolId?: string(name='PublicIpAddressPoolId', description='The ID of the IP address pool. The EIP is allocated from the IP address pool. You cannot use the IP address pool feature by default. To use this feature, you must apply for the privilege in the Quota Center console.', example='pippool-2vc4xdtjhwl4t0go5****'),
  }(name='EipCreateParam', description='The elastic IP address (EIP) to be created and associated. If no NAT gateway is configured for the virtual private cloud (VPC), you can associate an EIP to pull data from the Internet.', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The existing elastic IP address (EIP) to be associated. If no NAT gateway is configured for the virtual private cloud (VPC), you can associate an EIP to pull data from the Internet.', example='eip-uf66jeqopgqa9hdn****', position='Query'),
  name?: string(name='Name', description='The DataCache name.', example='test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  path?: string(name='Path', description='The storage path of the data.', example='/model/test', position='Query'),
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-2df3isufhi38****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The number of days for which the DataCache is retained. When the retention days end, the DataCache is deleted. By default, DataCaches do not expire.', example='7', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the generated ECI belongs during the creation of the data cache.', example='sg-2ze81zoc3yl7a3we****', position='Query'),
  size?: int32(name='Size', description='The size of the data cache. Unit: GiB. Default value: 20. Evaluate the required size based on the actual data size.', example='30', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='testkey'),
      value?: string(name='Value', description='The value of the tag.', example='testvalue'),
    }
  ](name='Tag', description='The tags to be bound to the data cache.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the generated ECI belongs during the creation of the data cache.', example='vsw-bp1jrgfqqy54kg5hc****', position='Query'),
}

model CreateDataCacheResponseBody = {
  dataCacheId?: string(name='DataCacheId', description='The DataCache ID.', example='edc-bp15l4vvys94oo******'),
  requestId?: string(name='RequestId', description='The request ID.', example='D81A4A13-6DCC-4579-AC62-90A6C3EC7BBC'),
}

model CreateDataCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDataCacheResponseBody(name='body'),
}

/**
  * *   You are charged for the creation of image caches. We recommend that you learn the relevant billing information in advance. For more information, see [DataCaches](~~2503093~~).
  * *   Before you create an image cache, you must evaluate the size of the data to be cached. If the size of the data exceeds the specified cache size, the image cache fails to be created.
  * *   When a data cache is being created, the system automatically creates a temporary elastic container instance (ECI) and an enhanced SSD (ESSD) for the data cache. During the creation, do not delete the ECI and ESSD. Otherwise, the data cache fails to be created.
  * *   When a data cache is being created, a snapshot is generated for the data cache. Do not delete the snapshot. Otherwise, the data cache becomes invalid.
  *
 */
async function createDataCache(request: CreateDataCacheRequest): CreateDataCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateDataCache', 'POST', '/', 'json', false, 'json', request);
}

model CreateImageCacheRequest {
  acrRegistryInfo?: [ 
    {
      arnService?: string(name='ArnService', description='The Alibaba Cloud Resource Name (ARN) of the RAM roles in the Alibaba Cloud account to which the elastic container instance belongs.', example='acs:ram::1609982529******:role/role-assume'),
      arnUser?: string(name='ArnUser', description='The ARN of the RAM roles in the Alibaba Cloud account to which the Container Registry Enterprise Edition instance belongs.', example='acs:ram::1298452580******:role/role-acr'),
      domain?: [ string ](name='Domain', description='The domain names of the Container Registry Enterprise Edition instance. By default, all domain names of the instance are displayed. You can specify multiple domain names. Separate multiple domain names with commas (,).', example='test****-registry.cn-beijing.cr.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The ID of Container Registry Enterprise Edition instance N.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of Container Registry Enterprise Edition instance N.', example='test****'),
      regionId?: string(name='RegionId', description='The region ID of Container Registry Enterprise Edition instance N.', example='cn-beijing'),
    }
  ](name='AcrRegistryInfo', description='Information about the Container Registry Enterprise Edition instance. For more information, see [Pull images from a Container Registry Enterprise Edition instance without using secrets](~~194250~~).', position='Query'),
  annotations?: string(name='Annotations', description='Comments.', example='hide', position='Query'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='Specifies whether to enable reuse of image cache layers. If you enable this feature, and the image cache that you want to create and an existing image cache contain duplicate image layers, the system reuses the duplicate image layers to create the new image cache. This accelerates the creation of the image cache. Valid values:

*   true: enables reuse of image cache layers.
*   false: disables reuse of image cache layers.

Default value: false.', example='true', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request](~~25693~~).', example='123e4567-xxx-xxx-xxxx-42665544xxxx', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The ID of the elastic IP address (EIP). If you want to pull images over the Internet, make sure that the elastic container instance can access the Internet. You can configure an EIP or a NAT gateway for the elastic container instance to access the Internet.', example='eip-2zedsm5mfl3uhdj2d****', position='Query'),
  eliminationStrategy?: string(name='EliminationStrategy', description='The elimination policy of the image cache. This parameter is empty by default, which indicates that the image cache is always retained.

You can set this parameter to LRU, which indicates that the image cache can be automatically deleted. When the number of image caches reaches the quota, the system automatically deletes the image caches whose EliminationStrategy parameter is set to LRU and that are least commonly used.', example='LRU', position='Query'),
  flash?: boolean(name='Flash', description='Specifies whether to enable the instant image cache feature. The feature can accelerate the creation of image caches. Valid values:

*   true
*   false

Default value: false.', example='true', position='Query'),
  flashCopyCount?: int32(name='FlashCopyCount', description='The number of temporary local snapshots. By default, the system creates one snapshot for each image cache. If an image cache is used to create multiple elastic container instances at a time, we recommend that you set this parameter to create multiple snapshots for the image cache. We recommend that you create one snapshot for creation of every 1,000 elastic container instances.

>  If you set the Flash parameter to true, instant image cache is enabled. During the creation of the image cache, the system first creates a temporary local snapshot for you to instantly use the snapshot. After the temporary local snapshot is created, the system begins to create a regular snapshot. After the regular snapshot is created, the temporary local snapshot is automatically deleted.', example='7', position='Query'),
  image: [ string ](name='Image', description='Container image N that is used to create the image cache.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:1.15.10-perl', position='Query'),
  imageCacheName: string(name='ImageCacheName', description='The name of the image cache.', example='testcache', position='Query'),
  imageCacheSize?: int32(name='ImageCacheSize', description='The size of the image cache. Unit: GiB. Default value: 20.', example='20', position='Query'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password', description='The password that is used to log on to image repository N.', example='password'),
      server?: string(name='Server', description='The address of the image repository without the `http://` or `https://` prefix.', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
      userName?: string(name='UserName', description='The username that is used to log on to image repository N.', example='username'),
    }
  ](name='ImageRegistryCredential', description='The image repository.', position='Query'),
  insecureRegistry?: string(name='InsecureRegistry', description='The address of the self-managed image repository.

When you create an image cache by using an image in a self-managed image repository that uses a self-signed certificate, you must specify this parameter to skip the certificate authentication. This can prevent the image from failing to pull due to certificate authentication failures.', example='"harbor***.pre.com,192.168.XX.XX:5000,reg***.test.com:80"', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  plainHttpRegistry?: string(name='PlainHttpRegistry', description='The address of the self-managed image repository. When you create an image cache by using an image in a self-managed image repository that uses the HTTP protocol, you must specify this parameter. This way, Elastic Container Instance uses the HTTP protocol instead of the default HTTPS protocol to pull the image. This can prevent the image from failing to pull due to different protocols.', example='"harbor***.pre.com,192.168.XX.XX:5000,reg***.test.com:80"', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the image cache.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aekzh43v*****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of the image cache. Unit: days. When the retention period ends, the image cache expires and is deleted. By default, image caches never expire.

>  The image caches that fail to be created are only retained for one day.', example='7', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-uf66jeqopgqa9hdn****', position='Query'),
  standardCopyCount?: int32(name='StandardCopyCount', description='The number of regular snapshots. By default, the system creates one snapshot for each image cache. If an image cache is used to create multiple elastic container instances at a time, we recommend that you set this parameter to create multiple snapshots for the image cache. We recommend that you create one snapshot for creation of every 1,000 elastic container instances.

>  If you set the Flash parameter to false, instant image cache is disabled. In this case, only regular snapshots are generated during the creation of the image cache.', example='7', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N of the image cache. Valid values of N: 1 to 20.', example='imc'),
      value?: string(name='Value', description='The value of tag N of the image cache. Valid values of N: 1 to 20.', example='test'),
    }
  ](name='Tag', description='The tag of the image cache.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch. You can specify up to 10 vSwitch IDs. Separate multiple vSwitch IDs with commas (,). Example: `vsw-***,vsw-***`.', example='vsw-uf6h3rbwbm90urjwa****', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the image cache.', example='cn-hangzhou-g', position='Query'),
}

model CreateImageCacheResponseBody = {
  containerGroupId?: string(name='ContainerGroupId', description='The ID of the intermediate elastic container instance that is used to create the image cache.', example='eci-2zebxkiifuyzzlhl****'),
  imageCacheId?: string(name='ImageCacheId', description='The ID of the image cache.', example='imc-2zebxkiifuyzzlhl****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='0E234675-3465-4CC3-9D0F-9A864BC391DD'),
}

model CreateImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageCacheResponseBody(name='body'),
}

/**
  * *   **Precautions**
  *     *   You are charged for creation of image caches. We recommend that you learn the relevant billing information in advance. For more information about billing of image caches, see [Image caches](~~447682~~).
  *     *   Before you create an image cache, you must estimate the total size of the images that you want to cache. If the total size of the images exceeds the specified cache size, the image cache cannot be created.
  *     *   When an image cache is being created, the system creates an intermediate elastic container instance and an intermediate enhanced SSD (ESSD) at performance level 1 (PL1). Do not delete the intermediate instance and the ESSD while the image cache is being created. If you delete the intermediate instance or the ESSD, the image cache cannot be created.
  *     *   A temporary local snapshot and a specific number of regular snapshots are generated during the creation of the image cache. Do not delete these snapshots. If you delete these snapshots, the image cache becomes invalid.
  *     *   If you use SDKs, SDK for Java 1.0.10 or later and SDK for Python 1.0.7 or later are supported.
  * *   **Usage notes**
  *     *   For images that are created based on Container Registry Enterprise Edition instances and use custom domain names, if you want to configure password-free access to the image caches, you must use AcrRegistryInfo-related parameters to specify Container Registry instances. When you configure AcrRegistryInfo-related parameters, you must set the AcrRegistryInfo.N.InstanceId parameter.
  *     *   If the image cache that you created will be used to create more than 1,000 elastic container instances at a time, we recommend that you use the StandardCopyCount and FlashCopyCount parameters to create multiple temporary local snapshots and regular snapshots of the image. The multiple snapshots are billed based on incremental data. If no incremental data exists on the multiple snapshots, you are not charged for the multiple snapshots.
  * >  When you call the CreateImageCache operation to create an image cache, the system automatically creates a service-linked role named AliyunServiceRoleForECI. The role is used to access other Alibaba Cloud services such as Elastic Compute Service (ECS) and Virtual Private Cloud (VPC). For more information, see [Elastic Container Instance service-linked role](~~212914~~).
  *
 */
async function createImageCache(request: CreateImageCacheRequest): CreateImageCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateImageCache', 'POST', '/', 'json', false, 'json', request);
}

model CreateInstanceOpsTaskRequest {
  containerGroupId: string(name='ContainerGroupId', description='The ID of the container group.', example='eci-bp1dvysdafbh00t7****', position='Query'),
  opsType: string(name='OpsType', description='The type of the O&M task. Valid values:

*   coredump
*   tcpdump', example='coredump', position='Query'),
  opsValue: string(name='OpsValue', description='The value of the O\\&M task. You can set this parameter based on the value of OpsType.

*   If OpsType is set to coredump, the valid values of OpsValue are:

    *   enable: enables coredump.
    *   disable: disables coredump.

*   If OpsType is set to tcpdump, the value of OpsValue is a JSON-formatted parameter string. Example: `{"Enable":true, "IfDeviceName":"eth0"}`. The value may contain the following parameters:

    *   Enable: specifies whether to enable tcpdump. You must specify this parameter. Valid values: true and false.
    *   Protocol: the network protocol. Valid values: tcp, udp, and icmpv4.
    *   SourceIp: the source IP address.
    *   SourceCidr: the source CIDR block. If you specify both an IP address and a CIDR block, the IP address is ignored if the CIDR block is valid.
    *   SourcePort: the source port. Valid values: 1 to 65535.
    *   DestIp: the destination IP address.
    *   DestCidr: the destination CIDR block. If you specify both an IP address and a CIDR block, the IP address is ignored if the CIDR block is valid.
    *   DestPort: the destination port. Valid values: 1 to 65535.
    *   IfDeviceName: the destination network interface controller. Default value: eth0.
    *   Snaplen: the length to be captured. Default value: 65535. Unit: bytes.
    *   Duration: the captured period. Unit: seconds.
    *   PacketNum: the number of packets to be captured.
    *   FileSize: the size of the destination files on packets. Unit: bytes. Maximum value: 1073741824. 1073741824 bytes is equal to 1 GB.', example='enable', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the O&M task.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model CreateInstanceOpsTaskResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='89945DD3-9072-47D0-A318-353284CFC7B'),
  result?: string(name='Result', description='The creation result of the O&M task.', example='Coredump settings has been configured successfully.'),
}

model CreateInstanceOpsTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceOpsTaskResponseBody(name='body'),
}

/**
  * O&M tasks are classified into:
  * *   coredump: After you enable coredump, the system generates a core dump file when a container unexpectedly stops. You can use the core dump file to analyze the exception and find out the cause of the problem. For more information, see [Enable coredump](~~167801~~).
  * *   tcpdump: After you enable tcpdump, the system captures network packets when a container unexpectedly stops. You can analyze the packets and locate network problems. For more information, see Enable [tcpdump](~~429749~~).
  *
 */
async function createInstanceOpsTask(request: CreateInstanceOpsTaskRequest): CreateInstanceOpsTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateInstanceOpsTask', 'POST', '/', 'json', false, 'json', request);
}

model CreateVirtualNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clusterDNS?: string(name='ClusterDNS', description='The IP address of the DNS server. If dnsPolicy=ClusterFirst is configured for the Elastic Container Instance pod, Elastic Container Instance uses the configuration to provide DNS services to containers. You can configure multiple IP addresses. Separate multiple IP addresses with commas (,).', example='100.1.XX.XX', position='Query'),
  clusterDomain?: string(name='ClusterDomain', description='The domain name of the cluster. If this parameter is specified, in addition to the search domain of the host, Kubelet configures all containers to search for the specified domain name.', example='example.com', position='Query'),
  customResources?: string(name='CustomResources', description='The custom resources that are supported by the virtual node. If a custom resource is specified in the request of an Elastic Container Instance pod, the pod is scheduled to run on the virtual node that supports the custom resource. You can use the Resource name = Number of resources format to specify custom resources. Separate multiple resources with commas (,).', example='example1.com=100,example2.com=200', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The ID of the elastic IP address (EIP).', example='eip-uf66jeqopgqa9hdn****', position='Query'),
  enablePublicNetwork?: boolean(name='EnablePublicNetwork', description='Specifies whether to enable Internet access for the VNode. Default value: false.

If the value of this parameter is true, the VNode exposes a public IP address to external services.', example='false', position='Query'),
  kubeConfig?: string(name='KubeConfig', description='KubeConfig of the Kubernetes cluster to which the VNode is to be connected. The value must be Base64-encoded.', example='JTVDbmFwaVZlcnNpb24lM0ElMjB2MSU1Q25jbHVzdGVycyUzQSU1Q24tJTIwY2x1c3RlciUzQSU1Q24uLi******', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the virtual node.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-uf66jeqopgqa9hdn****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId: string(name='SecurityGroupId', description='The ID of the security group. The VNode and the elastic container instances in the VNode are added to the security group.', example='sg-2ze81zoc3yl7a3we****', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='name'),
      value?: string(name='Value', description='The value of tag.', example='test'),
    }
  ](name='Tag', description='Tag.', position='Query'),
  taint?: [ 
    {
      effect?: string(name='Effect', description='The effect of taint N. Valid values of N: 1 to 20. Valid values:

- NoSchedule: No pods are scheduled to the nodes that have the taint.
- NoExecute: Existing pods in the node are evicted while no pods are scheduled to the nodes that have the taint.
- PreferNoSchedule: Pods are preferentially not scheduled to the nodes that have the taint.', example='NoSchedule'),
      key?: string(name='Key', description='The key of taint.', example='testKey'),
      value?: string(name='Value', description='The value of taint.', example='testValue'),
    }
  ](name='Taint', description='Taint.', position='Query'),
  tlsBootstrapEnabled?: boolean(name='TlsBootstrapEnabled', description='Specifies whether to enable TLS bootstrapping. If you set this parameter to true, use the KubeConfig certificate for TLS bootstrapping. Valid values:

- true
- false

Default value: false.', example='false', position='Query'),
  vSwitchId: string(name='VSwitchId', description='The ID of the vSwitch. The vSwitch is connected to the VNode and the elastic container instances in the VNode.

You can specify 1 to 10 vSwitches for a VPC.', example='vsw-2ze23nqzig8inprou****', position='Query'),
  virtualNodeName?: string(name='VirtualNodeName', description='he name of the VNode. The name must be 2 to 128 characters in length, and can contain lowercase letters, digits, periods (.), and hyphens (-).', example='testNode', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the VNode.', example='cn-hangzhou-b', position='Query'),
}

model CreateVirtualNodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='89164E78-FC82-4684-BE97-DCDD85D26546'),
  virtualNodeId?: string(name='VirtualNodeId', description='The ID of the VNode.', example='vnd-2ze960zkdqrldeaw****'),
}

model CreateVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualNodeResponseBody(name='body'),
}

/**
  * *   When you call this operation to create a virtual node, the system automatically creates a service-linked role AliyunServiceRoleForECIVnode. This way, you can use the service-linked role to access relevant cloud services such as Elastic Container Instance, Elastic Compute Service (ECS), and Virtual Private Cloud (VPC). For more information, see [Service-linked role for virtual nodes](~~311014~~).
  * *   You are charged for virtual nodes based on number of virtual nodes that you use. Each virtual node has a resident node, which is equivalent to an ECI instance with 2 vCPU cores and 8 GiB memory. You are charged for virtual nodes based on elastic container instances.
  *
 */
async function createVirtualNode(request: CreateVirtualNodeRequest): CreateVirtualNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVirtualNode', 'POST', '/', 'json', false, 'json', request);
}

model DeleteContainerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The instance ID.', example='eci-2zelg8vwnlzdhf8hv****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteContainerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='45D5B0AD-3B00-4A9B-9911-6D5303B06712'),
}

model DeleteContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContainerGroupResponseBody(name='body'),
}

async function deleteContainerGroup(request: DeleteContainerGroupRequest): DeleteContainerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteContainerGroup', 'POST', '/', 'json', false, 'json', request);
}

model DeleteDataCacheRequest {
  bucket?: string(name='Bucket', description='The bucket that stores the DataCache. By default, the bucket is named default.', example='default', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotency of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence](~~25693~~).', example='5e74729e-ce21-4c3e-9163-cbaf0f02768e', position='Query'),
  dataCacheId?: string(name='DataCacheId', description='The ID of the DataCache.', example='edc-bp1a7n7uawwwol******', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  path?: string(name='Path', description='The directory in which the virtual host of the DataCache is located.', example='/data/models/', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the DataCache.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteDataCacheResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='C0F8A012-1426-5EB2-96F5-B4416DEB5B78'),
}

model DeleteDataCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDataCacheResponseBody(name='body'),
}

async function deleteDataCache(request: DeleteDataCacheRequest): DeleteDataCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteDataCache', 'POST', '/', 'json', false, 'json', request);
}

model DeleteImageCacheRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotency of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  imageCacheId: string(name='ImageCacheId', description='The ID of the image cache.', example='imc-2zebxkiifuyzzlhl****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the image cache.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DeleteImageCacheResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='89945DD3-9072-47D0-A218-354284CFC7A2'),
}

model DeleteImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageCacheResponseBody(name='body'),
}

async function deleteImageCache(request: DeleteImageCacheRequest): DeleteImageCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteImageCache', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVirtualNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must make sure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency of requests](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the virtual node.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  virtualNodeId: string(name='VirtualNodeId', description='The ID of the virtual node.', example='vnd-2ze960zkdqrldeaw****', position='Query'),
}

model DeleteVirtualNodeResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model DeleteVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualNodeResponseBody(name='body'),
}

async function deleteVirtualNode(request: DeleteVirtualNodeRequest): DeleteVirtualNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVirtualNode', 'POST', '/', 'json', false, 'json', request);
}

model DescribeAvailableResourceRequest {
  destinationResource: {
    category: string(name='Category', description='The type of the resource. Valid values:

*   InstanceTypeFamily: queries instance families. If you use this parameter value, you must also specify the Value parameter.
*   InstanceType: queries instance types. If you use this parameter value, you must also specify the Value, Cores, and Memory parameters.', example='InstanceTypeFamily'),
    cores?: float(name='Cores', description='The number of vCPUs. This parameter is available only when the Category parameter is set to InstanceType.', example='2'),
    memory?: float(name='Memory', description='The size of the memory. Unit: GiB. This parameter is available only when the Category parameter is set to InstanceType.', example='4'),
    value?: string(name='Value', description='Instance families or instance types.

*   If you set Category to InstanceTypeFamily, you must set this parameter to instance families such as ecs.c5.
*   If you set Category to InstanceType, you must set this parameter to instance types such as ecs.c5.large.', example='ecs.c6'),
  }(name='DestinationResource', description='The information about the resource that you want to query.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the ECS instance families.

You can call the [DescribeRegions](~~146965~~) operation to query the most recent list of regions.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotResource?: {
    spotDuration?: int32(name='SpotDuration', description='The protection period of the preemptible instance. Unit: hours. Default value: 1. The value of 0 indicates no protection period.', example='1'),
    spotPriceLimit?: double(name='SpotPriceLimit', description='The maximum hourly price of the preemptible elastic container instance. The value can be accurate to three decimal places. If you set SpotStrategy to SpotWithPriceLimit, you must specify the SpotPriceLimit parameter.', example='0.2'),
    spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the elastic container instance. Valid values:

*   NoSpot: The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is created as a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is created as a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.

Default value: NoSpot.

> If you set this parameter to SpotWithPriceLimit or SpotAsPriceGo to query preemptible instances, you must set Category to InstanceType. You must also use the Value parameter to specify instance types, or use the Cores and Memory parameters to specify the number of vCPUs and memory size.', example='SpotAsPriceGo'),
  }(name='SpotResource', description='The information about the preemptible instances that you want to query.', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the ECS instance families.

This parameter is empty by default, which indicates that ECS instance families available in all zones in the specified region are queried.', example='cn-hangzhou-e', position='Query'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      availableResources?: {
        availableResource?: [ 
        {
          supportedResources?: {
            supportedResource?: [ 
            {
              statusCategory?: string(name='StatusCategory', description='The category of resources based on stock status. Valid values:

*   WithStock: Resources are in sufficient stock.
*   ClosedWithStock: Resources are insufficient. We recommend that you use instance types that are in sufficient stock.
*   WithoutStock: Resources are sold out and will be replenished. We recommend that you use instance types that are in sufficient stock.
*   ClosedWithoutStock: Resources are sold out and will not be replenished. We recommend that you use instance types that are in sufficient stock.', example='WithStock'),
              value?: string(name='Value', description='The ECS instance types or instance families that are available in the zones.

*   If the return value of the Type parameter is InstanceTypeFamily, this parameter indicates instance families that are returned.
*   If the return value of the Type parameter is InstanceType, this parameter indicates instance types that are returned.', example='ecs.c6'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources', description='The information about the resources that are available in the zones.'),
          type?: string(name='Type', description='The type of the resource. Valid values:

*   InstanceTypeFamily: instance families.
*   InstanceType: instance types.', example='InstanceTypeFamily'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources', description='The resources that are available in the specified zone.'),
      regionId?: string(name='RegionId', description='The region ID of the resources.', example='cn-hangzhou'),
      zoneId?: string(name='ZoneId', description='The zone ID of the resources.', example='cn-hangzhou-e'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones', description='The zones in which the specified resources are available.'),
  requestId?: string(name='RequestId', description='The request ID.', example='6829735A-FF76-58C6-AECB-27CBF135A7AA'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

/**
  * When you call the CreateContainerGroup operation to create an elastic container instance, you can use the InstanceType parameter to specify ECS instance types that fit your specific needs. To ensure that the elastic container instance can be created, you can call the DescribeAvailableResource operation to query which ECS instance types and instance families are available in the specified region and zone before you create the elastic container instance.
  *
 */
async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeAvailableResource', 'POST', '/', 'json', false, 'json', request);
}

model DescribeCommitContainerTaskRequest {
  containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance on which the CommitContainer task is executed.\\
You must enter the instance ID, the task ID, or both for the request.', example='eci-2zelg8vwnlzdhf8hv****', position='Query'),
  maxResults?: int32(name='MaxResults', description='The number of entries to return on each page.\\
Maximum value: 50.\\
Default value: 10.', example='20', position='Query'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. Set the value to the value of NextToken that is returned from the last request.', example='AAAAAdDWBF2****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  taskId?: [ string ](name='TaskId', description='The ID of the task.', position='Query'),
  taskStatus?: string(name='TaskStatus', description='The status of the task. Valid values:

*   Running
*   Succeeded
*   Failed', example='Running', position='Query'),
}

model DescribeCommitContainerTaskResponseBody = {
  commitTasks?: [ 
    {
      commitPhaseInfos?: [ 
        {
          message?: string(name='Message', description='The message about the phase.', example='Pull base image for container container-1 successfully'),
          phase?: string(name='Phase', description='The phase name. Valid values:

*   PullBaseImage: Pull the original container image.
*   CommitContainer: Commit the container to generate an image.
*   PushCommittedImage: Push the image to Container Registry.', example='PullBaseImage'),
          recordTime?: string(name='RecordTime', description='The record time of the phase.', example='2023-01-05T14:06:40.920005316+08:00'),
          status?: string(name='Status', description='The state of the phase.', example='Success'),
        }
      ](name='CommitPhaseInfos', description='The information about the phase that the task arrives.'),
      containerName?: string(name='ContainerName', description='The container name.', example='worker0'),
      statusMessage?: string(name='StatusMessage', description='The message about the state.', example='Commit container -xxxxxx'),
      taskCreationTime?: string(name='TaskCreationTime', description='The time when the task was started.', example='2023-03-06T08:22:40Z'),
      taskFinishedTime?: string(name='TaskFinishedTime', description='The time when the task was complete.', example='2023-03-06T08:23:40Z'),
      taskId?: string(name='TaskId', description='The task ID.', example='t-2zej6nstkg744qc3****'),
      taskProgress?: string(name='TaskProgress', description='The progress of the task in percentage.', example='50%'),
      taskStatus?: string(name='TaskStatus', description='The state of the task. Valid values:

*   Running
*   Succeeded
*   Failed', example='Running'),
    }
  ](name='CommitTasks', description='Details of the task.'),
  maxResults?: string(name='MaxResults', description='The number of entries returned per page.', example='20'),
  nextToken?: string(name='NextToken', description='The query token that is returned in this request.', example='AAAAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='45D5B0AD-3B00-4A9B-9911-6D5303B06712'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='5'),
}

model DescribeCommitContainerTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCommitContainerTaskResponseBody(name='body'),
}

async function describeCommitContainerTask(request: DescribeCommitContainerTaskRequest): DescribeCommitContainerTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeCommitContainerTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerGroupEventsRequest {
  containerGroupIds?: string(name='ContainerGroupIds', description='The IDs of the elastic container instances. You can specify up to 20 IDs. Each ID must be a JSON string.', example='["eci-bp17gw49eu09yiwm****", "eci-bp19aq49du01abcm****", "eci-2zegym1qhbmdfr1s****"]', position='Query'),
  eventSource?: string(name='EventSource', description='The event source. Valid values:

*   EciService
*   K8sAgent

This parameter is empty by default. This indicates that all events are queried.', example='K8sAgent', position='Query'),
  limit?: int32(name='Limit', description='The maximum number of elastic container instances to be returned for this request. Default value: 200.

>  The number of elastic container instances to be returned is no greater than this parameter value.', example='200', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.

You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='d78f2dd8-5979-42fe-xaee-b16db43be5bc', position='Query'),
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-uf66jeqopgqa9hdn****', position='Query'),
  sinceSecond?: int32(name='SinceSecond', description='A relative time in seconds before the current time from which to show event information. This parameter is used to poll incremental events.', example='60', minimum=60, maximum=3600, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='test'),
      value?: string(name='Value', description='The value of the tag.', example='name'),
    }
  ](name='Tag', description='The tag that is added to the elastic container instances.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-uf6h3rbwbm90urjwa****', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID.', example='cn-hangzhou-k', position='Query'),
}

model DescribeContainerGroupEventsResponseBody = {
  data?: [ 
    {
      annotations?: string(name='Annotations', description='The annotations of the elastic container instance.', example='"{\\"tenancy.x-k8s.io/namespace\\":\\"redis\\"}"'),
      containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-uf6fonnghi50v6nq****'),
      events?: [ 
        {
          count?: int32(name='Count', description='The number of events.', example='10'),
          firstTimestamp?: string(name='FirstTimestamp', description='The first occurrence time of the event.', example='2021-10-04T09:08:04Z'),
          lastTimestamp?: string(name='LastTimestamp', description='The most recent occurrence time of the event.', example='2021-10-04T09:08:04Z'),
          message?: string(name='Message', description='The message about the event.', example='Started container'),
          metadata?: {
            name?: string(name='Name', description='The event name.', example='eci-uto-created-eci-for-ubuntu.167e3fb73cc7f9cb'),
            namespace?: string(name='Namespace', description='The namespace.', example='default'),
          }(name='Metadata', description='The metadata of the event.'),
          reason?: string(name='Reason', description='The cause of the event.', example='Started'),
          reportingComponent?: string(name='ReportingComponent', description='The component from which the event is reported.', example='test'),
          reportingInstance?: string(name='ReportingInstance', description='The instance from which the event is reported.', example='test'),
          source?: {
            component?: string(name='Component', description='The component.', example='kubelet'),
            host?: string(name='Host', description='The host.', example='eci'),
          }(name='Source', description='The source.'),
          type?: string(name='Type', description='The event type. Valid values:

*   Normal
*   Warning', example='Normal'),
          involvedObject?: {
            apiVersion?: string(name='ApiVersion', description='The version of Kubernetes.', example='v1'),
            kind?: string(name='Kind', description='The resource type.', example='Pod'),
            name?: string(name='Name', description='The resource name.', example='test'),
            namespace?: string(name='Namespace', description='The namespace where the resource resides.', example='default'),
            uid?: string(name='Uid', description='The resource ID.', example='eci-8vb5nkcq3a5cu0p3****'),
          }(name='involvedObject', description='The resource object that the event is about.'),
        }
      ](name='Events', description='The events.'),
      name?: string(name='Name', description='The name of the elastic container instance.', example='test'),
      namespace?: string(name='Namespace', description='The namespace where the elastic container instance resides.', example='redis'),
      uuid?: string(name='uuid', description='The UUID of the elastic container instance.', example='3fc6b309-****-****'),
    }
  ](name='Data', description='Details of the events.'),
  requestId?: string(name='RequestId', description='The request ID.', example='1340C38D-6189-54D1-86F6-7D5ECF3E0088'),
  totalCount?: int32(name='TotalCount', description='The total number of entries of returned events.', example='10'),
}

model DescribeContainerGroupEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupEventsResponseBody(name='body'),
}

/**
  * You can call this operation to query the event information about multiple elastic container instances at a time. By default, the most recent 50 entries of events of each elastic container instance are returned.
  *
 */
async function describeContainerGroupEvents(request: DescribeContainerGroupEventsRequest): DescribeContainerGroupEventsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerGroupEvents', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerGroupMetricRequest {
  containerGroupId: string(name='ContainerGroupId', description='The instance ID.', example='eci-bp17da5olmkuagfr****', position='Query'),
  endTime?: string(name='EndTime', description='The end of the time range to query. The default value is the current time.

Specify the time in RFC 3339 format.', example='2019-09-12T01:05:00.000Z', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  period?: string(name='Period', description='The data aggregation period. Unit: seconds. Valid values: 15, 30, 60, and 600. Default value: 60.

>  If the StartTime and EndTime parameters are not specified, the system returns the monitoring data generated in the last 5 minutes with a data aggregation period of 15s. The Period parameter is ignored.', example='15', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. The beginning of the time range must be a time point in the last 30 days. The default value is 5 minutes before the value of EndTime.

Specify the time in RFC 3339 format. For example, to query the data starting from March 12, 2019, 09:00 UTC+8, you can set the parameter to 2019-03-12T09:00:00.000+08:00 or 2019-03-12T01:00:00.000Z.', example='2019-03-12T01:00:00.000Z', position='Query'),
}

model DescribeContainerGroupMetricResponseBody = {
  containerGroupId?: string(name='ContainerGroupId', description='The instance ID.', example='eci-bp1dqpye03ke5s6p****'),
  records?: [ 
    {
      CPU?: {
        limit?: long(name='Limit', description='The upper limit of vCPU usage. The calculation formula for this parameter: The number of vCPUs × 1000.', example='2000'),
        load?: long(name='Load', description='The average load in the last 10 seconds.', example='0'),
        usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds', description='The cumulative usage of vCPUs.', example='70769883'),
        usageNanoCores?: long(name='UsageNanoCores', description='The vCPU usage in the sampling window. Unit for the sampling window: nanoseconds.', example='0'),
      }(name='CPU', description='The monitoring data of vCPUs.'),
      containers?: [ 
        {
          CPU?: {
            limit?: long(name='Limit', description='The upper limit of vCPU usage. The calculation formula for this parameter: The number of vCPUs × 1000.', example='1024'),
            load?: long(name='Load', description='The average load in the last 10 seconds.', example='0'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds', description='The cumulative usage of vCPUs.', example='40876694'),
            usageNanoCores?: long(name='UsageNanoCores', description='The vCPU usage in the sampling window. Unit for the sampling window: nanoseconds.', example='0'),
          }(name='CPU', description='The vCPU monitoring data of the container.'),
          memory?: {
            availableBytes?: long(name='AvailableBytes', description='The size of the available memory. Unit: bytes.', example='4285091840'),
            cache?: long(name='Cache', description='The size of the cache. Unit: bytes.', example='9289728'),
            rss?: long(name='Rss', description='The size of the resident memory set, which indicates the size of the physical memory that is actually used. Unit: bytes.', example='9289728'),
            usageBytes?: long(name='UsageBytes', description='The size of the used memory. Unit: bytes.', example='9289728'),
            workingSet?: long(name='WorkingSet', description='The usage of the working set. Unit: bytes.', example='9289728'),
          }(name='Memory', description='The memory monitoring data of the container.'),
          name?: string(name='Name', description='The name of the container.', example='u1'),
        }
      ](name='Containers', description='The monitoring data of containers.'),
      disk?: [ 
        {
          device?: string(name='Device', description='The name of the disk.', example='/dev/vda'),
          readBytes?: long(name='ReadBytes', description='The amount of data that was read from the disk. Unit: bytes.', example='210714112'),
          readIO?: long(name='ReadIO', description='This parameter is unavailable for public use.', example='123'),
          writeBytes?: long(name='WriteBytes', description='The amount of data that was written to the disk. Unit: bytes.', example='1375109120'),
          writeIO?: long(name='WriteIO', description='This parameter is unavailable for public use.', example='123'),
        }
      ](name='Disk', description='The monitoring data of disks.'),
      filesystem?: [ 
        {
          available?: long(name='Available', description='The size of the available space.', example='35319836672'),
          capacity?: long(name='Capacity', description='The total file system space.', example='41610981376'),
          category?: string(name='Category', description='The type of the partition. Valid values:

*   System
*   Volume
*   Other', example='System'),
          fsName?: string(name='FsName', description='The name of the partition.', example='/dev/root'),
          usage?: long(name='Usage', description='The size of used space.', example='4368744448'),
        }
      ](name='Filesystem', description='The monitoring data of file system partitions.'),
      memory?: {
        availableBytes?: long(name='AvailableBytes', description='The size of the available memory. Unit: bytes.', example='4285091840'),
        cache?: long(name='Cache', description='The size of the cache. Unit: bytes.', example='9289728'),
        rss?: long(name='Rss', description='The size of the resident memory set, which indicates the size of the physical memory that is actually used. Unit: bytes.', example='9289728'),
        usageBytes?: long(name='UsageBytes', description='The size of the used memory. Unit: bytes.', example='9289728'),
        workingSet?: long(name='WorkingSet', description='The usage of the working set. Unit: bytes.', example='9289728'),
      }(name='Memory', description='The monitoring data of the memory.'),
      network?: {
        interfaces?: [ 
          {
            name?: string(name='Name', description='The name of the NIC.', example='eth0'),
            rxBytes?: long(name='RxBytes', description='The number of bytes received by the NIC.', example='505001954'),
            rxDrops?: long(name='RxDrops', description='The number of received packets dropped on the NIC.', example='0'),
            rxErrors?: long(name='RxErrors', description='The number of received packet errors on the NIC.', example='0'),
            rxPackets?: long(name='RxPackets', description='The number of packets received by the NIC.', example='4800583'),
            txBytes?: long(name='TxBytes', description='The number of bytes transmitted by the NIC.', example='1381805699'),
            txDrops?: long(name='TxDrops', description='The number of transmitted packets dropped on the NIC.', example='0'),
            txErrors?: long(name='TxErrors', description='The number of transmitted packet errors on the NIC.', example='0'),
            txPackets?: long(name='TxPackets', description='The number of packets transmitted by the NIC.', example='5158427'),
          }
        ](name='Interfaces', description='The monitoring data of network interface controllers (NICs).'),
      }(name='Network', description='The monitoring data of the network.'),
      timestamp?: string(name='Timestamp', description='The time when the monitoring data entry was collected. The time follows the RFC 3339 format.', example='2021-08-25T16:22:00.000+08:00'),
    }
  ](name='Records', description='The monitoring data of the elastic container instance.'),
  requestId?: string(name='RequestId', description='The request ID.', example='D81A4A13-6DCC-4579-AC62-90A6C3EC7BBC'),
}

model DescribeContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupMetricResponseBody(name='body'),
}

/**
  * *   A maximum of 50 monitoring data entries can be returned. If the number of monitoring data entries exceeds this limit, an error message is returned.
  * *   You can query real-time monitoring data (data generated within the last 5 minutes) and historical data (data generated more than 5 minutes ago). If the time range to query starts or ends later than the current time, historical monitoring data generated more than 5 minutes ago is returned.
  * *   The elastic container instance whose monitoring data you want to query must be created after April 3, 2019, 15:00 UTC+8.
  *
 */
async function describeContainerGroupMetric(request: DescribeContainerGroupMetricRequest): DescribeContainerGroupMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerGroupMetric', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerGroupPriceRequest {
  cpu?: float(name='Cpu', description='The number of vCPUs. For information about the vCPU and memory specifications that are supported by Elastic Container Instance, see [vCPU and memory specifications](~~114662~~).', example='2.0', position='Query'),
  ephemeralStorage?: int32(name='EphemeralStorage', description='The storage size of the temporary storage space. Unit: GiB.', example='20', position='Query'),
  instanceType?: string(name='InstanceType', description='The instance type of the Elastic Compute Service (ECS) instance that is used to create the elastic container instance. For information about the ECS instance types that are supported by Elastic Container Instance, see [ECS instance types that are supported by Elastic Container Instance](~~114664~~).

> If you specify this parameter, the specified specifications of vCPUs and memory are ignored. Only the price of the ECS instance type is returned.', example='ecs.c5.large', position='Query'),
  memory?: float(name='Memory', description='The size of the memory. Unit: GiB. For information about the vCPU and memory specifications that are supported by Elastic Container Instance, see [vCPU and memory specifications](~~114662~~).', example='4.0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance. You can call the [DescribeRegions](~~146965~~) operation to query the most recent region and zone list.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  spotDuration?: int32(name='SpotDuration', description='The protection period of the preemptible instance. Unit: hours. Default value: 1. The value of 0 indicates no protection period.', example='1', position='Query'),
  spotPriceLimit?: float(name='SpotPriceLimit', description='The maximum hourly price of the preemptible elastic container instance. The value can contain up to three decimal places. If you set SpotStrategy to SpotWithPriceLimit, you must specify SpotPriceLimit.', example='0.2', position='Query'),
  spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the elastic container instance. Valid values:

*   NoSpot: The instance is a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance with a user-defined maximum hourly price.
*   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bid price.

Default value: NoSpot.', example='SpotWithPriceLimit', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instance. You can call the [DescribeRegions](~~146965~~) operation to query the most recent region and zone list.', example='cn-hangzhou-g', position='Query'),
}

model DescribeContainerGroupPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency', description='The currency unit. Valid values:

*   CNY: This value only applies to the China site (aliyun.com).
*   USD: This value only applies to the International site (alibabacloud.com).', example='CNY'),
      detailInfos?: {
        detailInfo?: [ 
        {
          discountPrice?: float(name='DiscountPrice', description='The discount.', example='0'),
          originalPrice?: float(name='OriginalPrice', description='The original price.', example='0.000098'),
          resource?: string(name='Resource', description='The name of the resource.', example='cpu'),
          rules?: {
            rule?: [ 
            {
              description?: string(name='Description', description='The description of the rule.', example='Receive a 15% discount on a 1-year subscription'),
              ruleId?: long(name='RuleId', description='The rule ID.', example='123456'),
            }
          ](name='Rule')
          }(name='Rules', description='Details about the pricing rules.'),
          tradePrice?: float(name='TradePrice', description='The transaction price.', example='0.000098'),
        }
      ](name='DetailInfo')
      }(name='DetailInfos', description='The information about the price.'),
      discountPrice?: float(name='DiscountPrice', description='The discount.', example='0'),
      originalPrice?: float(name='OriginalPrice', description='The original price.', example='0.00012252'),
      tradePrice?: float(name='TradePrice', description='The transaction price, which is equal to the original price minus the discount.', example='0.00012252'),
    }(name='Price', description='The price.'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description', description='The description of the promotion rule.', example='Receive a 15% discount on a 1-year subscription'),
        ruleId?: long(name='RuleId', description='The ID of the promotion rule.', example='123456'),
      }
    ](name='Rule')
    }(name='Rules', description='Details about the promotion rules.'),
    spotPrices?: {
      spotPrice?: [ 
      {
        instanceType?: string(name='InstanceType', description='The ECS instance type.', example='ecs.c5.large'),
        originPrice?: float(name='OriginPrice', description='The original price.', example='0.622'),
        spotPrice?: float(name='SpotPrice', description='The prices of preemptible elastic container instances.', example='0.056'),
        zoneId?: string(name='ZoneId', description='The zone ID of the instance.', example='cn-hangzhou-i'),
      }
    ](name='SpotPrice')
    }(name='SpotPrices', description='The information about the prices of preemptible elastic container instances.'),
  }(name='PriceInfo', description='The information about the prices and discount rules.'),
  requestId?: string(name='RequestId', description='The request ID.', example='7A872585-33C7-4D69-AB8E-412E81EBA387'),
}

model DescribeContainerGroupPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupPriceResponseBody(name='body'),
}

/**
  * *   When you call this operation, you cannot use resource groups to control the permissions of a RAM user.
  * *   You can create an elastic container instance by specifying vCPU and memory resource specifications or by specifying ECS instance types. When you call this operation to query the prices of elastic container instances, pass in specifications of the elastic container instances.
  *     *   [vCPU and memory specifications](~~114662~~).
  *     *   [ECS instance types that are supported by Elastic Container Instance](~~114664~~).
  *
 */
async function describeContainerGroupPrice(request: DescribeContainerGroupPriceRequest): DescribeContainerGroupPriceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerGroupPrice', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerGroupStatusRequest {
  containerGroupIds?: string(name='ContainerGroupIds', description='The IDs of the instances. You can specify up to 20 IDs. Each ID must be a string in the JSON format.', example='["eci-bp17gw49eu09yiwm****", "eci-bp19aq49du01abcm****", "eci-2zegym1qhbmdfr1s****"]', position='Query'),
  limit?: int32(name='Limit', description='Specifies the maximum number of elastic container instances to be returned for this request. Default value: 200.

> The number of returned resources can be less than or equal to the value of this parameter.', example='200', minimum=1, maximum=200, position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. If NextToken is empty, no next page exists.\\
You do not need to specify this parameter for the first request. You must specify the token that is obtained from the previous query as the value of NextToken.', example='d78f2dd8-5979-42fe-xaee-b16db43be5bc', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instances.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the instances belong.', example='rg-uf66jeqopgqa9hdn****', position='Query'),
  sinceSecond?: int32(name='SinceSecond', description='A relative time in seconds before the current time from which to show elastic container instances whose status changes. This parameter is used to poll status of elastic container instances.', example='60', minimum=60, maximum=3600, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='testKey'),
      value?: string(name='Value', description='The value of the tag.', example='testValue'),
    }
  ](name='Tag', description='The tag that is bound to the instances.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-uf6h3rbwbm90urjwa****', position='Query'),
  zoneId?: string(name='ZoneId', description='The zone ID of the instances.', example='cn-hangzhou-k', position='Query'),
}

model DescribeContainerGroupStatusResponseBody = {
  data?: [ 
    {
      annotations?: string(name='Annotations', description='The annotations of the elastic container instance.', example='"{\\"tenancy.x-k8s.io/namespace\\":\\"redis\\"}"'),
      containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-bp1jrgfqqy54kg5hc****'),
      name?: string(name='Name', description='The name of the elastic container instance.', example='nginx'),
      namespace?: string(name='Namespace', description='The namespace where the elastic container instance resides.', example='default'),
      podStatus?: {
        conditions?: [ 
          {
            message?: string(name='Message', description='The message about the event.', example='Completed'),
            reason?: string(name='Reason', description='The cause of the event.', example='Completed'),
            lastTransitionTime?: string(name='lastTransitionTime', description='The time when the status last changed.', example='2021-05-12T07:02:47Z'),
            status?: string(name='status', description='The state of the pod condition.', example='True'),
            type?: string(name='type', description='The type of the pod condition. Valid values:

*   PodScheduled
*   Ready
*   Initialized
*   Unschedulable', example='Ready'),
          }
        ](name='Conditions', description='The information about the pod conditions.'),
        containerStatuses?: [ 
          {
            image?: string(name='Image', description='The image of the container.', example='registry-vpc.cn-zhangjiakou.aliyuncs.com/eci_open/ubuntu:18.04'),
            imageID?: string(name='ImageID', description='The image ID.', example='registry-vpc.cn-zhangjiakou.aliyuncs.com/eci_open/ubuntu@sha256:134c7fe821b9d359490cd009ce7ca322453f4f2d018623f849e580a89a685e5d'),
            lastState?: {
              running?: {
                startedAtstartedAt?: string(name='StartedAtstartedAt', description='The start time.', example='2021-05-23T20:49:31Z'),
              }(name='Running', description='The container is created and running.'),
              terminated?: {
                containerID?: string(name='ContainerID', description='The container ID.', example='containerd://3ff993933bea366c4719e43a1b067d89bc7f01f1f573981659a44ff17a******'),
                exitCode?: int32(name='ExitCode', description='The exit code.', example='0'),
                finishedAt?: string(name='FinishedAt', description='The end time.', example='2021-05-23T20:49:31Z'),
                message?: string(name='Message', description='The message about the event.', example='Completed'),
                reason?: string(name='Reason', description='The cause of the event.', example='Completed'),
                signal?: int32(name='Signal', description='The signal code.', example='1'),
                startedAt?: string(name='StartedAt', description='The start time.', example='021-05-12T07:02:52Z'),
              }(name='Terminated', description='The container is terminated and exits after a successful or failed run.'),
              waiting?: {
                message?: string(name='Message', description='The message about the event.', example='Back-off'),
                reason?: string(name='Reason', description='The cause of the event.', example='Started'),
              }(name='Waiting', description='The container is waiting for being created.'),
            }(name='LastState', description='The most recent state of the container.'),
            name?: string(name='Name', description='The container name.', example='ubuntu'),
            ready?: boolean(name='Ready', description='Indicates whether the container is ready for use.', example='true'),
            restartCount?: int32(name='RestartCount', description='The number of restarts.', example='1'),
            started?: boolean(name='Started', description='Indicates whether the container is started.', example='true'),
            state?: {
              running?: {
                startedAtstartedAt?: string(name='StartedAtstartedAt', description='The start time.', example='2021-05-23T20:49:31Z'),
              }(name='Running', description='The container is created and running.'),
              terminated?: {
                containerID?: string(name='ContainerID', description='The container ID.', example='containerd://3ff993933bea366c4719e43a1b067d89bc7f01f1f573981659a44ff17a******'),
                exitCode?: int32(name='ExitCode', description='The exit code.', example='0'),
                finishedAt?: string(name='FinishedAt', description='The end time.', example='2021-05-23T20:55:31Z'),
                message?: string(name='Message', description='The message about the event.', example='Completed'),
                reason?: string(name='Reason', description='The cause of the event.', example='Completed'),
                signal?: int32(name='Signal', description='The signal code.', example='1'),
                startedAt?: string(name='StartedAt', description='The start time.', example='2021-05-23T20:49:31Z'),
              }(name='Terminated', description='The container is terminated and exits after a successful or failed run.'),
              waiting?: {
                message?: string(name='Message', description='The message about the event.', example='Back-off'),
                reason?: string(name='Reason', description='The cause of the event.', example='Started'),
              }(name='Waiting', description='The container is waiting for being created.'),
            }(name='State', description='The state of the container. Valid values:

*   Waiting
*   Running
*   Terminated'),
          }
        ](name='ContainerStatuses', description='The state information about the container.'),
        hostIp?: string(name='HostIp', description='The IP address of the host.', example='192.168.XX.XX'),
        phase?: string(name='Phase', description='The lifecycle phase of the pod.', example='Running'),
        podIp?: string(name='PodIp', description='The IP address of the pod.', example='192.168.XX.XX'),
        podIps?: [ 
          {
            ip?: string(name='Ip', description='The IP address of the pod.', example='192.168.XX.XX'),
          }
        ](name='PodIps', description='The collection of pod IP addresses.'),
        qosClass?: string(name='QosClass', description='The quality of service (QoS) of the pod.', example='Guaranteed'),
        startTime?: string(name='StartTime', description='The time when the container started to run.', example='2021-05-12T07:02:47Z'),
      }(name='PodStatus', description='The state information about the elastic container instance.'),
      status?: string(name='Status', description='The state of the elastic container instance.', example='Running'),
      uuid?: string(name='uuid', description='The UUID of the elastic container instance. The UUID of an elastic container instance is similar to the UID of a Kubernetes pod in concept and usage.', example='78ee0657-987g-b8b2-1f507dic4****'),
    }
  ](name='Data', description='The collection of status of the elastic container instances.'),
  nextToken?: string(name='NextToken', description='A pagination token. It can be used in the next request to retrieve a new page of results.', example='d78f2dd8-5979-42fe-****-b16db43be5bc'),
  requestId?: string(name='RequestId', description='The request ID.', example='1340C38D-6189-54D1-86F6-7D5ECF3E0088'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='1'),
}

model DescribeContainerGroupStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupStatusResponseBody(name='body'),
}

async function describeContainerGroupStatus(request: DescribeContainerGroupStatusRequest): DescribeContainerGroupStatusResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerGroupStatus', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerGroupsRequest {
  containerGroupIds?: string(name='ContainerGroupIds', description='The IDs of the elastic container instances in JSON format. You can specify up to 20 IDs.', example='["eci-bp17gw49eu09yiwm****", "eci-bp19aq49du01abcm****", "eci-2zegym1qhbmdfr1s****"]', position='Query'),
  containerGroupName?: string(name='ContainerGroupName', description='The name of the elastic container instance.', example='test', position='Query'),
  limit?: int32(name='Limit', description='The maximum number of resources to return. Default value: 20. Maximum value: 20.

>  The number of returned resources is less than or equal to the specified number.', example='20', position='Query'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query. If this parameter is left empty, all results have been returned.

> You do not need to specify this parameter in the first request. Starting from the second request, you can obtain the token from the result returned by the previous request.', example='d78f2dd8-5979-42fe-****-b16db43be5bc', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the elastic container instances belong. If you do not specify a resource group when you create an elastic container instance, the system automatically adds the instance to the default resource group in your account.', example='rg-aekzh43v*****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', position='Query'),
  status?: string(name='Status', description='The status of the elastic container instance. Valid values:

*   Pending: The instance is being started.
*   Running: The instance is running.
*   Succeeded: The instance runs successfully.
*   Failed: The instance fails to run.
*   Scheduling: The instance is being created.
*   ScheduleFailed: The instance fails to be created.
*   Restarting: The instance is being restarted.
*   Updating: The instance is being updated.
*   Terminating: The instance is being terminated.
*   Expired: The instance expires.', example='Running', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the instances.', example='name'),
      value?: string(name='Value', description='The tag value of the instances.', example='test'),
    }
  ](name='Tag', description='The tag of the instances.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the elastic container instances are connected.', example='vsw-bp1jrgfqqy54kg5hc****', position='Query'),
  withEvent?: boolean(name='WithEvent', description='Specifies whether to return event information.', example='true', position='Query'),
  zoneId?: string(name='ZoneId', description='The ID of the zone in which the elastic container instances are deployed. If you do not specify this parameter, the system selects a zone.

This parameter is empty by default.', example='cn-hangzhou-h', position='Query'),
}

model DescribeContainerGroupsResponseBody = {
  containerGroups?: [ 
    {
      computeCategory?: string(name='ComputeCategory'),
      containerGroupId?: string(name='ContainerGroupId', description='The instance ID.', example='eci-bp1jrgfqqy54kg5hc****'),
      containerGroupName?: string(name='ContainerGroupName', description='The instance name.', example='test'),
      containers?: [ 
        {
          args?: [ string ](name='Args', description='The arguments that are passed to the startup command of the container.'),
          commands?: [ string ](name='Commands', description='The container startup commands.'),
          cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container.', example='2.0'),
          currentState?: {
            detailStatus?: string(name='DetailStatus', description='The details of the container status.', example='working'),
            exitCode?: int32(name='ExitCode', description='The exit code of the container.', example='0'),
            finishTime?: string(name='FinishTime', description='The time when the container stopped running.', example='2018-08-02T15:00:00Z'),
            message?: string(name='Message', description='The message about the container status.', example='Back-off 5m0s restarting failed container=test pod=test_eci-xxx(xxx)'),
            reason?: string(name='Reason', description='The reason why the container is in this state.', example='Started'),
            signal?: int32(name='Signal', description='The code of the container status.', example='1'),
            startTime?: string(name='StartTime', description='The time when the container started to run.', example='2019-12-19T12:05:02Z'),
            state?: string(name='State', description='The container status. Valid values:

*   Waiting
*   Running
*   Terminated', example='Terminated'),
          }(name='CurrentState', description='The current container status.'),
          environmentVars?: [ 
            {
              key?: string(name='Key', description='The environment variable.', example='PATH'),
              value?: string(name='Value', description='The value of the environment variable.', example='/usr/bin/'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath', description='The path of the field.', example='status.podIP'),
                }(name='FieldRef', description='The specified field.'),
              }(name='ValueFrom', description='The source of the variable value. This parameter has a value only when the Value parameter is not empty.'),
            }
          ](name='EnvironmentVars', description='The environment variables.'),
          gpu?: int32(name='Gpu', description='The number of GPUs.', example='1'),
          image?: string(name='Image', description='The image of the container.', example='mysql'),
          imagePullPolicy?: string(name='ImagePullPolicy', description='The policy for image pulling. Valid values:

*   Always: Image pulling is always performed.
*   IfNotPresent: On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: On-premises images are always used. Image pulling is not performed.', example='Always'),
          livenessProbe?: {
            execs?: [ string ](name='Execs', description='The commands that are used to check the containers.'),
            failureThreshold?: int32(name='FailureThreshold', description='The minimum number of consecutive failures that must occur for the check to be considered failed. Default value: 3.', example='3'),
            httpGet?: {
              path?: string(name='Path', description='The path to which HTTP GET requests were sent.', example='/usr/nginx/'),
              port?: int32(name='Port', description='The port to which HTTP GET requests were sent.', example='80'),
              scheme?: string(name='Scheme', description='The protocol type of the HTTP GET requests.', example='HTTP'),
            }(name='HttpGet', description='The HTTP GET method that is used to check the container.'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds', description='The number of seconds between the time when the startup of the container ends and the time when the check starts.', example='10'),
            periodSeconds?: int32(name='PeriodSeconds', description='The interval at which the container is checked. Unit: seconds. Default value: 10. Minimum value: 1.', example='5'),
            successThreshold?: int32(name='SuccessThreshold', description='The minimum number of consecutive successes that must occur for the check to be considered successful. Default value: 1. Set the value to 1.', example='1'),
            tcpSocket?: {
              host?: string(name='Host', description='The hostname.', example='1.2.3.4'),
              port?: int32(name='Port', description='The port number.', example='80'),
            }(name='TcpSocket', description='The TCP socket method that is used to check the container.'),
            timeoutSeconds?: int32(name='TimeoutSeconds', description='The timeout period of the health check. Unit: seconds. Default value: 1. Minimum value: 1.', example='10'),
          }(name='LivenessProbe', description='The liveness probe of the container.'),
          memory?: float(name='Memory', description='The memory size of the container. Unit: GiB.', example='2.0'),
          name?: string(name='Name', description='The container name.', example='nginx'),
          ports?: [ 
            {
              port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='8080'),
              protocol?: string(name='Protocol', description='The protocol.', example='TCP'),
            }
          ](name='Ports', description='The exposed port and protocol of the container.'),
          previousState?: {
            detailStatus?: string(name='DetailStatus', description='The details of the container status.', example='working'),
            exitCode?: int32(name='ExitCode', description='The exit code of the container.', example='0'),
            finishTime?: string(name='FinishTime', description='The time when the container stopped running.', example='2018-08-02T15:00:00Z'),
            message?: string(name='Message', description='The message about the container status.', example='Back-off 5m0s restarting failed container=test pod=test_eci-xxx(xxx)'),
            reason?: string(name='Reason', description='The reason why the container is in this state.', example='Completed'),
            signal?: int32(name='Signal', description='The code of the container status.', example='1'),
            startTime?: string(name='StartTime', description='The time when the container started to run.', example='2018-08-02T15:00:00Z'),
            state?: string(name='State', description='The container status. Valid values:

*   Waiting: The container is being started.
*   Running: The container is running.
*   Terminated: The container stops running.', example='Terminated'),
          }(name='PreviousState', description='The previous state of the container.'),
          readinessProbe?: {
            execs?: [ string ](name='Execs', description='The commands to be executed in containers when you use a command-line interface (CLI) to perform health checks.'),
            failureThreshold?: int32(name='FailureThreshold', description='The minimum number of consecutive failures that must occur for the check to be considered failed. Default value: 3.', example='3'),
            httpGet?: {
              path?: string(name='Path', description='The path to which the system sends an HTTP GET request for a probe.', example='/usr/local'),
              port?: int32(name='Port', description='The port to which the system sends an HTTP GET request for a health check.', example='8080'),
              scheme?: string(name='Scheme', description='The protocol type of the HTTP GET requests.', example='HTTP'),
            }(name='HttpGet', description='The HTTP GET method that is used to check the container.'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds', description='The number of seconds between the time when the startup of the container ends and the time when the check starts.', example='5'),
            periodSeconds?: int32(name='PeriodSeconds', description='The interval at which the container is checked. Unit: seconds. Default value: 10. Minimum value: 1.', example='1'),
            successThreshold?: int32(name='SuccessThreshold', description='The minimum number of consecutive successes that must occur for the check to be considered successful. Default value: 1. Set the value to 1.', example='1'),
            tcpSocket?: {
              host?: string(name='Host', description='The IP address of the host.', example='1.2.3.4'),
              port?: int32(name='Port', description='The port number.', example='8888'),
            }(name='TcpSocket', description='The TCP socket method that is used to check the container.'),
            timeoutSeconds?: int32(name='TimeoutSeconds', description='The timeout period of the health check. Unit: seconds. Default value: 1. Minimum value: 1.', example='1'),
          }(name='ReadinessProbe', description='The readiness probe that is used to check whether the container is ready to serve a request.'),
          ready?: boolean(name='Ready', description='Indicates whether the container passed the readiness probe.', example='true'),
          restartCount?: int32(name='RestartCount', description='The number of times that the container restarted.', example='0'),
          securityContext?: {
            capability?: {
              adds?: [ string ](name='Adds', description='The permissions specific to the process in the container.'),
            }(name='Capability', description='The permissions specific to the processes in the container.'),
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem', description='Indicates whether the root file system is set to the read-only mode. The only valid value is true.', example='true'),
            runAsUser?: long(name='RunAsUser', description='The ID of the user that runs the container.', example='1000'),
          }(name='SecurityContext', description='The security context of the elastic container instance.'),
          stdin?: boolean(name='Stdin', description='Indicates whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur when standard input streams in the container are read. Default value: false.', example='true'),
          stdinOnce?: boolean(name='StdinOnce', description='Indicates whether the container runtime closes the stdin channel after the stdin channel has been opened by a sing attach. If stdin is true, the stdin stream remains open across multiple attach sessions. If StdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and receive data until the client disconnects. When the client disconnects, stdin is closed and remains closed until the container is restarted.', example='true'),
          tty?: boolean(name='Tty', description='Indicates whether interaction is enabled. Default value: false If the Command parameter is a `/bin/bash` command, the value is true.', example='false'),
          volumeMounts?: [ 
            {
              mountPath?: string(name='MountPath', description='The directory to which the volume is mounted. Data under this directory is overwritten by the data on the volume.', example='/usr/share/'),
              mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of volumes. Mount propagation allows the sharing of volumes that are mounted on a container to other containers in the same pod, or even to other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to the volume or the subdirectories of the volume.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to the volume or to the subdirectories of the volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives all subsequent mounts that are mounted to the volume or to the subdirectories of the volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.', example='None'),
              name?: string(name='Name', description='The volume name.', example='test-empty'),
              readOnly?: boolean(name='ReadOnly', description='Indicates whether the volume is read-only.', example='false'),
              subPath?: string(name='SubPath', description='The subdirectory of the volume. This parameter specifies different subdirectories of the same volume that the instance can mount to different subdirectories of containers.', example='/usr/sub'),
            }
          ](name='VolumeMounts', description='Information about the mounted volumes.'),
          workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/local/nginx'),
        }
      ](name='Containers', description='The containers in the elastic container instance.'),
      cpu?: float(name='Cpu', description='The number of vCPUs that are allocated to the elastic container instance.', example='2.0'),
      creationTime?: string(name='CreationTime', description='The time when the system created the elastic container instance after the system received the request. The time follows the RFC 3339 standard and must be in UTC.', example='2018-08-02T15:00:00Z'),
      discount?: int32(name='Discount', description='The discount.', example='9'),
      dnsConfig?: {
        nameServers?: [ string ](name='NameServers', description='The IP addresses of DNS servers.'),
        options?: [ 
          {
            name?: string(name='Name', description='The variable name of the option.', example='name'),
            value?: string(name='Value', description='The value of the object.', example='value'),
          }
        ](name='Options', description='The objects. Each object is a name-value pair. The value is optional.'),
        searches?: [ string ](name='Searches', description='The lookup domains of DNS server N.'),
      }(name='DnsConfig', description='The Domain Name System (DNS) settings.'),
      eciSecurityContext?: {
        sysctls?: [ 
          {
            name?: string(name='Name', description='The name of the Sysctl parameter.', example='kernel.msgmax'),
            value?: string(name='Value', description='The value of the Sysctl parameter.', example='65536'),
          }
        ](name='Sysctls', description='The Sysctl parameters.'),
      }(name='EciSecurityContext', description='The security context of the elastic container instance.'),
      eniInstanceId?: string(name='EniInstanceId', description='The ID of the elastic network interface (ENI).', example='eni-bp14rzqi6fd8satm****'),
      ephemeralStorage?: int32(name='EphemeralStorage', description='The size of the temporary storage space. Unit: GiB.', example='20'),
      events?: [ 
        {
          count?: int32(name='Count', description='The number of the events.', example='20'),
          firstTimestamp?: string(name='FirstTimestamp', description='The time when the event started.', example='2018-08-02T15:00:00Z'),
          lastTimestamp?: string(name='LastTimestamp', description='The time when the event ended.', example='2018-08-02T15:00:00Z'),
          message?: string(name='Message', description='The message about the event.', example='Started container'),
          name?: string(name='Name', description='The category to which the event belongs.', example='test-xxx'),
          reason?: string(name='Reason', description='The event name.', example='Created'),
          type?: string(name='Type', description='The type of the event. Valid values:

*   Normal
*   Warning', example='Normal'),
        }
      ](name='Events', description='The events about the elastic container instance. A maximum of 50 events can be returned.'),
      expiredTime?: string(name='ExpiredTime', description='The time when the elastic container instance failed to run due to overdue payments. The time follows the RFC 3339 standard and must be in UTC.', example='2018-08-02T15:00:00Z'),
      failedTime?: string(name='FailedTime', description='The time when the instance failed to run. The time follows the RFC 3339 standard and must be in UTC.', example='2018-08-02T15:00:00Z'),
      hostAliases?: [ 
        {
          hostnames?: [ string ](name='Hostnames', description='The information about the host.'),
          ip?: string(name='Ip', description='The IP address.', example='192.0.XX.XX'),
        }
      ](name='HostAliases', description='The hostname mapping of a container in the elastic container instance.'),
      initContainers?: [ 
        {
          args?: [ string ](name='Args', description='The arguments that are passed to the startup command.'),
          command?: [ string ](name='Command', description='The startup commands of the containers.'),
          cpu?: float(name='Cpu', description='The number of vCPUs.', example='1.0'),
          currentState?: {
            detailStatus?: string(name='DetailStatus', description='The details of the container status.', example='working'),
            exitCode?: int32(name='ExitCode', description='The exit code of the container.', example='0'),
            finishTime?: string(name='FinishTime', description='The time when the container stopped running.', example='2018-08-02T15:00:00Z'),
            message?: string(name='Message', description='The message about the event.', example='Created container'),
            reason?: string(name='Reason', description='The reason why the container is in this state.', example='Started'),
            signal?: int32(name='Signal', description='The code of the container status.', example='1'),
            startTime?: string(name='StartTime', description='The time when the container started to run.', example='2018-08-02T15:00:00Z'),
            state?: string(name='State', description='The container status. Valid values:

*   Waiting
*   Running
*   Terminated', example='Running'),
          }(name='CurrentState', description='The current container status.'),
          environmentVars?: [ 
            {
              key?: string(name='Key', description='The environment variable.', example='PATH'),
              value?: string(name='Value', description='The value of the environment variable.', example='/usr/local/bin'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath', description='The path from which the fields come in the specified version. Only `status.podIP` is supported.', example='status.podIP'),
                }(name='FieldRef', description='The specified field.'),
              }(name='ValueFrom', description='The source of the variable value. This parameter has a value only when the Value parameter is not empty.'),
            }
          ](name='EnvironmentVars', description='The environment variables.'),
          gpu?: int32(name='Gpu', description='The number of GPUs.', example='1'),
          image?: string(name='Image', description='The image.', example='nginx'),
          imagePullPolicy?: string(name='ImagePullPolicy', description='The policy for image pulling. Valid values:

*   Always: Image pulling is always performed.
*   IfNotPresent: On-premises images are preferentially used. If no on-premises images are available, image pulling is performed.
*   Never: On-premises images are always used. Image pulling is not performed.', example='Always'),
          memory?: float(name='Memory', description='The size of memory that is allocated to the init container. Unit: GiB.', example='2.0'),
          name?: string(name='Name', description='The name of the init container.', example='Init-xxx'),
          ports?: [ 
            {
              port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='8888'),
              protocol?: string(name='Protocol', description='The protocol.', example='TCP'),
            }
          ](name='Ports', description='The exposed port and protocol of the container.'),
          previousState?: {
            detailStatus?: string(name='DetailStatus', description='The details of the container status.', example='working'),
            exitCode?: int32(name='ExitCode', description='The exit code of the container.', example='0'),
            finishTime?: string(name='FinishTime', description='The time when the container stopped running.', example='2019-12-24T05:35:44Z'),
            message?: string(name='Message', description='The message about the container status.', example='Started container'),
            reason?: string(name='Reason', description='The reason why the container is in this state.', example='completed'),
            signal?: int32(name='Signal', description='The code of the container status.', example='1'),
            startTime?: string(name='StartTime', description='The time when the container started to run.', example='2019-12-24T05:35:44Z'),
            state?: string(name='State', description='The status of the container. Valid values: Waiting, Running, and Terminated.', example='Terminated'),
          }(name='PreviousState', description='The previous state of the container.'),
          ready?: boolean(name='Ready', description='Indicates whether the container passed the readiness probe.', example='true'),
          restartCount?: int32(name='RestartCount', description='The number of times the container restarted.', example='5'),
          securityContext?: {
            capability?: {
              adds?: [ string ](name='Adds', description='The permissions specific to the process in the container.'),
            }(name='Capability', description='The permissions specific to the processes in the container.'),
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem', description='Indicates whether the root file system is set to the read-only mode. The only valid value is true.', example='true'),
            runAsUser?: long(name='RunAsUser', description='The UID that is used to run the entry point of the container process.', example='1557'),
          }(name='SecurityContext', description='The security context of the container.'),
          volumeMounts?: [ 
            {
              mountPath?: string(name='MountPath', description='The directory to which the volume is mounted. Data under this directory is overwritten by the data on the volume.', example='/usr/share/'),
              mountPropagation?: string(name='MountPropagation', description='The mount propagation settings of volumes. Mount propagation allows the sharing of volumes that are mounted on a container to other containers in the same pod, or even to other pods on the same node. Valid values:

*   None: The volume mount does not receive subsequent mounts that are mounted to the volume or the subdirectories of the volume.
*   HostToCotainer: The volume mount receives all subsequent mounts that are mounted to the volume or to the subdirectories of the volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives all subsequent mounts that are mounted to the volume or to the subdirectories of the volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.', example='None'),
              name?: string(name='Name', description='The name of the volume. The name is the same as the volume you selected when you purchased the container.', example='test-empty'),
              readOnly?: boolean(name='ReadOnly', description='Default value: false.', example='false'),
            }
          ](name='VolumeMounts', description='The information about the volumes that are mounted to the init container.'),
          workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/test'),
        }
      ](name='InitContainers', description='The information about the init containers.'),
      instanceType?: string(name='InstanceType', description='The instance type of the Elastic Compute Service (ECS) instance that is used to create the elastic container instance.', example='ecs.g5.large'),
      internetIp?: string(name='InternetIp', description='The public IP address.', example='192.0.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address.', example='172.16.XX.XX'),
      ipv6Address?: string(name='Ipv6Address', description='The IPv6 address.', example='2001:XXXX:4:4:4:4:4:4'),
      memory?: float(name='Memory', description='The memory size of the elastic container instance. Unit: GiB.', example='4.0'),
      ramRoleName?: string(name='RamRoleName', description='The name of the instance RAM role. You can use an instance RAM role to access both elastic container instances and ECS instances. For more information, see [Use the instance RAM role by calling APIs](~~61178~~).', example='ram:PassRole'),
      regionId?: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-8db03793gfrz****'),
      restartPolicy?: string(name='RestartPolicy', description='The restart policy of the elastic container instance. Valid values:

*   Never: never restarts the elastic container instance.
*   Always: always restarts the elastic container instance.
*   OnFailure: restarts the instance if it fails to run.', example='Never'),
      securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the instance belongs.', example='sg-bp12ujq5zpxuyjfo3o8r'),
      spotPriceLimit?: double(name='SpotPriceLimit', description='The maximum hourly price for the preemptible elastic container instance.

This parameter is returned only if you set the SpotStrategy parameter to SpotWithPriceLimit.', example='0.025'),
      spotStrategy?: string(name='SpotStrategy', description='The bidding policy for the instance. Valid values:

*   NoSpot (default): The instance is created as a regular pay-as-you-go instance.
*   SpotWithPriceLimit: The instance is a preemptible instance that has a maximum price.
*   SpotAsPriceGo: The instance is a preemptible instance for which the market price at the time of purchase is automatically used as the bidding price.', example='NoSpot'),
      status?: string(name='Status', description='The status of the instance. Valid values:

*   Pending: The elastic container instance is being started.
*   Running: The elastic container instance is running.
*   Succeeded: The elastic container instance runs successfully.
*   Failed: The elastic container instance fails to run.
*   Scheduling: The elastic container instance is being created.
*   ScheduleFailed: The elastic container instance fails to be created.
*   Restarting: The elastic container instance is being restarted.
*   Updating: The elastic container instance is being updated.
*   Terminating: The elastic container instance is being terminated.
*   Expired: The instance expired.', example='Running'),
      succeededTime?: string(name='SucceededTime', description='The time when all containers in the elastic container instance exit. The time follows the RFC 3339 standard and must be in UTC.', example='2019-12-11T04:33:42Z'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='name'),
          value?: string(name='Value', description='The value of the tag.', example='test-xh'),
        }
      ](name='Tags', description='The tags of the instance.'),
      tenantEniInstanceId?: string(name='TenantEniInstanceId', description='This parameter is unavailable.', example='i-xxx'),
      tenantEniIp?: string(name='TenantEniIp', description='This parameter is unavailable.', example='10.10.XX.XX'),
      tenantSecurityGroupId?: string(name='TenantSecurityGroupId', description='This parameter is unavailable.', example='sg-xxx'),
      tenantVSwitchId?: string(name='TenantVSwitchId', description='This parameter is unavailable.', example='vsw-xxx'),
      vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch.', example='vsw-bp1vzjjflab6wvjox****'),
      volumes?: [ 
        {
          configFileVolumeConfigFileToPaths?: [ 
            {
              content?: string(name='Content', description='The content of the configuration file. Maximum size: 32 KB.', example='hello world'),
              path?: string(name='Path', description='The relative path of the configuration file.', example='/usr/bin/'),
            }
          ](name='ConfigFileVolumeConfigFileToPaths', description='The paths to configuration files.'),
          diskVolumeDiskId?: string(name='DiskVolumeDiskId', description='The ID of the disk when you set the Type parameter to DiskVolume.', example='d-xxxx'),
          diskVolumeFsType?: string(name='DiskVolumeFsType', description='The file system type of the disk volume.', example='xfs'),
          emptyDirVolumeMedium?: string(name='EmptyDirVolumeMedium', description='The storage media of emptyDir volume N. This parameter is empty by default, indicating that the node file system is used as the storage media. Valid values:

*   Memory: uses memory as the storage media.
*   LocalRaid0: forms local disks into RAID 0. This value is applicable only to scenarios in which an elastic container instance that has local disks mounted is created. For more information, see [Create an elastic container instance that has local disks mounted](~~114664~~).', example='Memory'),
          emptyDirVolumeSizeLimit?: string(name='EmptyDirVolumeSizeLimit', description='The storage capacity of emptyDir volume N.', example='256Mi'),
          flexVolumeDriver?: string(name='FlexVolumeDriver', description='The name of the FlexVolume driver.', example='flexvolume'),
          flexVolumeFsType?: string(name='FlexVolumeFsType', description='The file system type when you set the Type parameter to FlexVolume. The default value is determined by the script of the FlexVolume plug-in.', example='ntfs'),
          flexVolumeOptions?: string(name='FlexVolumeOptions', description='The options when you set the Volume.N.Type parameter to FlexVolume.', example='[nolock,tcp,noresvport]'),
          NFSVolumePath?: string(name='NFSVolumePath', description='The path of the NFS volume.', example='/eci'),
          NFSVolumeReadOnly?: boolean(name='NFSVolumeReadOnly', description='Indicates whether the volume is read-only.', example='false'),
          NFSVolumeServer?: string(name='NFSVolumeServer', description='The endpoint of the server when you set the Type parameter to NFSVolume.', example='0eafxxxxx-xxxxx.cn-hangzhou.nas.aliyuncs.com'),
          name?: string(name='Name', description='The volume name.', example='test-empty'),
          type?: string(name='Type', description='The type of the volume. Valid values:

*   EmptyDirVolume
*   NFSVolume
*   ConfigFileVolume
*   FlexVolume', example='EmptyDirVolume'),
        }
      ](name='Volumes', description='The information about the volumes.'),
      vpcId?: string(name='VpcId', description='The ID of the virtual private cloud (VPC) to which the elastic container instances belong.', example='vpc-1vzjjflab6wvjox****'),
      zoneId?: string(name='ZoneId', description='The zone to which the instance belongs.', example='cn-hangzhou-h'),
    }
  ](name='ContainerGroups', description='Details about the elastic container instances.'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the query.', example='d78f2dd8-5979-42fe-****-b16db43be5bc'),
  requestId?: string(name='RequestId', description='The ID of the request. The value is unique.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
  totalCount?: int32(name='TotalCount', description='The number of queried instances.', example='1'),
}

model DescribeContainerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupsResponseBody(name='body'),
}

/**
  * *   After an elastic container instance is terminated, its underlying computing resources are recycled. By default, other resources, such as elastic IP addresses (EIPs), that are created together with the instance are released together with the instance.
  * *   The metadata of an instance in the final status (Failed, Succeeded, or Expired) is retained based on the following rules:
  *     *   All metadata information is retained within 1 hour since the instance enters the final status.
  *     *   One hour after the instance enters the final status, only the latest 100 entries of metadata information in each region are retained.
  *
 */
async function describeContainerGroups(request: DescribeContainerGroupsRequest): DescribeContainerGroupsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerGroups', 'POST', '/', 'json', false, 'json', request);
}

model DescribeContainerLogRequest {
  containerGroupId: string(name='ContainerGroupId', description='The instance ID.', example='eci-uf6fonnghi50v6nq****', position='Query'),
  containerName: string(name='ContainerName', description='The name of the container.', example='nginx', position='Query'),
  lastTime?: boolean(name='LastTime', description='Specifies whether to query the logs of the previous container if the container exits and restarts. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
  limitBytes?: long(name='LimitBytes', description='The limit on the total size of logs. Unit: bytes. Valid values: 1 to 1048576(1 MB).', example='123798', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID of the elastic container instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  sinceSeconds?: int32(name='SinceSeconds', description='A relative time in seconds before the current time from which to show logs. Examples: 10, 20, and 30.', example='10', position='Query'),
  startTime?: string(name='StartTime', description='The beginning of the time range to query. Specify the time in the RFC 3339 standard. The time must be in UTC.', example='2018-08-02T15:00:00Z', position='Query'),
  tail?: int32(name='Tail', description='The number of log entries that you want to query. Default value: 500. Maximum value: 2000. A maximum of 1 MB of logs can be returned.', example='500', position='Query'),
  timestamps?: boolean(name='Timestamps', description='Specifies whether to return the timestamps of logs. Valid values:

*   true
*   false

Default value: false.', example='false', position='Query'),
}

model DescribeContainerLogResponseBody = {
  containerName?: string(name='ContainerName', description='The container name.', example='nginx'),
  content?: string(name='Content', description='The content of the log.', example='{}'),
  requestId?: string(name='RequestId', description='The request ID.', example='CA850ADA-****-4AC8-****-5B5990EAB7D0'),
}

model DescribeContainerLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerLogResponseBody(name='body'),
}

async function describeContainerLog(request: DescribeContainerLogRequest): DescribeContainerLogResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeContainerLog', 'POST', '/', 'json', false, 'json', request);
}

model DescribeDataCachesRequest {
  bucket?: string(name='Bucket', description='The bucket that stores the data cache. Default value: default.', example='default', position='Query'),
  dataCacheId?: [ string ](name='DataCacheId', description='The data cache IDs.', position='Query'),
  limit?: int32(name='Limit', description='The maximum entries of query results that are allowed to be displayed. Valid values: 1 to 20. Default value: 20.', example='20', position='Query'),
  nextToken?: string(name='NextToken', description='The query token. Set the value to the NextToken value that is returned in the previous call.', example='d78f2dd8-5979-42fe-****-b16db43be5bc', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  path?: string(name='Path', description='The virtual host (vHost) directory in which the data cache resides.', example='/data/models/', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the data caches that you want to query.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the data cache belongs.', example='rg-acfmzw2jz2z****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='testkey'),
      value?: string(name='Value', description='The tag value.', example='testvalue'),
    }
  ](name='Tag', description='The tags that are attached to the data cache.', position='Query'),
}

model DescribeDataCachesResponseBody = {
  dataCaches?: [ 
    {
      bucket?: string(name='Bucket', description='The bucket that stores the data cache.', example='default'),
      containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance that was generated when the data cache was created.', example='eci-8vb1y2w1dv7zeirn****'),
      creationTime?: string(name='CreationTime', description='The time when the data cache was created.', example='2023-06-16T02:43Z'),
      dataCacheId?: string(name='DataCacheId', description='The data cache ID.', example='edc-bp15l4vvys94oo******'),
      dataSource?: {
        options?: string(name='Options', description='The parameters that are configured for the data source.', example='{
      "options": {
            "path": "/",
            "server": "0ce1f4****-or***.cn-hangzhou.nas.aliyuncs.com",
            "vers": "3",
            "options": "nolock,proto=tcp,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport"
      },
      "type": "NAS"
}'),
        type?: string(name='Type', description='The type of the data source. Valid values:

*   NAS
*   OSS
*   URL
*   SNAPSHOT', example='URL'),
      }(name='DataSource', description='The information about the data source.'),
      events?: [ 
        {
          count?: int32(name='Count', description='The number of times that the event occurred.', example='1'),
          firstTimestamp?: string(name='FirstTimestamp', description='The time when the event started.', example='2021-06-16T02:14:48Z'),
          lastTimestamp?: string(name='LastTimestamp', description='The time when the event ended.', example='2021-06-16T02:24:48Z'),
          message?: string(name='Message', description='The information about the event.', example='Successfully check data cache resource.'),
          name?: string(name='Name', description='The event name.', example='datacache'),
          reason?: string(name='Reason', description='The event cause.', example='Started'),
          type?: string(name='Type', description='The event type. Valid values:

*   Normal
*   Warning', example='Normal'),
        }
      ](name='Events', description='The events.'),
      expireDateTime?: string(name='ExpireDateTime', description='The time when the data cache expires.', example='2023-06-26T02:43Z'),
      flashSnapshotId?: string(name='FlashSnapshotId', description='The ID of the local snapshot.', example='s-bp12w3v37sit96t6****'),
      lastMatchedTime?: string(name='LastMatchedTime', description='The time when the data cache was last matched.', example='2023-06-18T02:43Z'),
      name?: string(name='Name', description='The data cache name.', example='test'),
      path?: string(name='Path', description='The vHost directory in which the data cache resides.', example='/data/models/'),
      progress?: string(name='Progress', description='The creation progress of the data cache.', example='100%'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-aek2hlt3ux4****'),
      size?: int32(name='Size', description='The size of the data cache. Unit: GiB.', example='20'),
      snapshotId?: string(name='SnapshotId', description='The snapshot ID.', example='s-2zec5oj8e1yhxijt****'),
      status?: string(name='Status', description='The state of the data cache. Valid values:

*   Loading: The data cache is loading data.
*   Creating: The data cache is being created.
*   Available: The data cache is created.
*   Failed: The data cache failed to be created.
*   Updating: The data cache is being updated.
*   UpdateFailed: The data cache failed to be updated.

The data cache is available when it is in the Ready state.', example='Ready'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='testkey'),
          value?: string(name='Value', description='The tag value.', example='testvalue'),
        }
      ](name='Tags', description='The tags that are attached to the data cache.'),
    }
  ](name='DataCaches', description='The information about the data caches.'),
  nextToken?: string(name='NextToken', description='The query token. Set the value to the NextToken value that is returned in the previous call.', example='d78f2dd8-5979-42fe-xaee-b16db43be5bc'),
  requestId?: string(name='RequestId', description='The request ID.', example='B8756BA0-6452-419C-9727-37A6209C85E0'),
  totalCount?: int32(name='TotalCount', description='The number of entries returned.', example='2'),
}

model DescribeDataCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeDataCachesResponseBody(name='body'),
}

async function describeDataCaches(request: DescribeDataCachesRequest): DescribeDataCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeDataCaches', 'POST', '/', 'json', false, 'json', request);
}

model DescribeImageCachesRequest {
  image?: string(name='Image', description='The container images.', example='nginx', position='Query'),
  imageCacheId?: string(name='ImageCacheId', description='The IDs of the image caches.', example='imc-bp195erqe9o2pb09****', position='Query'),
  imageCacheName?: string(name='ImageCacheName', description='The names of the image caches.', example='testcache', position='Query'),
  imageFullMatch?: boolean(name='ImageFullMatch', description='Specifies whether the image layers of the image caches must contain all image layers of the container image.\\
If you configure MatchImage, you can configure this parameter to further filter query results.', example='true', position='Query'),
  imageMatchCountRequest?: int32(name='ImageMatchCountRequest', description='The quantity of image caches whose image layers contain all image layers of the container image.\\
If you configure MatchImage, you can configure this parameter to further filter query results.', example='3', position='Query'),
  limit?: int32(name='Limit', description='The maximum entries of query results that are allowed to be displayed.', example='20', position='Query'),
  matchImage?: [ string ](name='MatchImage', description='The container images used to match the image caches that you want to query. You can specify a maximum of 100 container images.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:1.15.10-perl', position='Query'),
  nextToken?: string(name='NextToken', description='The pagination token that is used in the next request to retrieve a new page of results. You must specify the token that is obtained from the previous query as the value of NextToken.', example='AAAAAdDWBF2****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the image caches.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the image caches belong.', example='rg-2df3isufhi38****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  snapshotId?: string(name='SnapshotId', description='The IDs of the snapshots that correspond to the image caches.', example='s-2zec5oj8e1yhxijt****', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N of the image cache.', example='imc'),
      value?: string(name='Value', description='The value of tag N of the image cache.', example='test'),
    }
  ](name='Tag', description='The tags to add to the image caches.', position='Query'),
}

model DescribeImageCachesResponseBody = {
  imageCaches?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-bp18oq3m15prd9jb****'),
      creationTime?: string(name='CreationTime', description='The time when the image cache was created.', example='2021-02-09T02:24:07Z'),
      eliminationStrategy?: string(name='EliminationStrategy', description='The elimination policy of the image cache. This parameter is empty by default, which indicates that the image cache is always retained.

You can set this parameter to LRU, which indicates that the image cache can be automatically deleted. When the number of image caches reaches the quota, the system automatically deletes the image caches whose EliminationStrategy parameter is set to LRU and that are least regularly used.', example='LRU'),
      events?: [ 
        {
          count?: int32(name='Count', description='The number of events.', example='1'),
          firstTimestamp?: string(name='FirstTimestamp', description='The time when the event started.', example='2021-02-09T02:24:48Z'),
          lastTimestamp?: string(name='LastTimestamp', description='The time when the event ended.', example='2021-02-09T02:24:48Z'),
          message?: string(name='Message', description='The message about the event.', example='Successfully check image cache resource.'),
          name?: string(name='Name', description='The name of the event.', example='imagetest.1661f31f851a****'),
          reason?: string(name='Reason', description='The cause of the event.', example='Started'),
          type?: string(name='Type', description='The type of the event. Valid values:', example='Normal'),
        }
      ](name='Events', description='The events of pulling an image to create the image cache.'),
      expireDateTime?: string(name='ExpireDateTime', description='The time when the image cache expires.', example='2019-11-10T09:00:48Z'),
      flashSnapshotId?: string(name='FlashSnapshotId', description='The ID of the local snapshot. A temporary local snapshot is created if the instant image cache feature is enabled.', example='s-bp12w3v37sit96t6****'),
      imageCacheId?: string(name='ImageCacheId', description='The ID of the image cache.', example='imc-bp195erqe9o2pb09****'),
      imageCacheName?: string(name='ImageCacheName', description='The name of the image cache.', example='imagetest'),
      imageCacheSize?: int32(name='ImageCacheSize', description='The size of the image cache. Unit: GiB.', example='20'),
      images?: [ string ](name='Images', description='The images contained in the image cache.'),
      lastMatchedTime?: string(name='LastMatchedTime', description='The time when the image cache was last matched.', example='2021-08-18T03:48:10Z'),
      progress?: string(name='Progress', description='The progress of creating the snapshot that is used to create the image cache.

>  If the instant image cache feature is enabled, the system creates a temporary local snapshot and then a regular snapshot. In this case, this parameter indicates the progress of creating the regular snapshot.', example='100%'),
      regionId?: string(name='RegionId', description='The region ID of the image cache.', example='cn-beijing'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the image cache belongs.', example='rg-2df3isufhi38****'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot that corresponds to the image cache.', example='s-2zec5oj8e1yhxijt****'),
      status?: string(name='Status', description='The status of the image cache. Valid values:

*   Preparing: The image cache is being prepared.
*   Creating: The image is being created.
*   Ready: The image cache is created.
*   Failed: The image cache failed to be created.
*   Updating: The image cache is being updated.
*   UpdateFailed: The image cache failed to be updated.

The image cache is ready for use when it is in the Ready state.', example='Ready'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='imc'),
          value?: string(name='Value', description='The tag value.', example='test'),
        }
      ](name='Tags', description='The tags of the image cache.'),
    }
  ](name='ImageCaches', description='The information about image caches.'),
  nextToken?: string(name='NextToken', description='The returned value of NextToken is a pagination token, which can be used in the next request to retrieve a new page of results.', example='AAAAAdDWBF2****'),
  requestId?: string(name='RequestId', description='The request ID.', example='39FC2E43-3DD7-4CEF-9EF4-E4AD6E635301'),
  totalCount?: int32(name='TotalCount', description='The total number of entries returned.', example='15'),
}

model DescribeImageCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageCachesResponseBody(name='body'),
}

async function describeImageCaches(request: DescribeImageCachesRequest): DescribeImageCachesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeImageCaches', 'POST', '/', 'json', false, 'json', request);
}

model DescribeInstanceOpsRecordsRequest {
  containerGroupId: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-bp1dvysdafbh00t7****', position='Query'),
  opsType: string(name='OpsType', description='The type of the O\\&M task. Valid values:

*   coredump
*   tcpdump', example='coredump', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeInstanceOpsRecordsResponseBody = {
  records?: [ 
    {
      createTime?: string(name='CreateTime', description='The time when the O\\&M task was created.', example='2021-12-29T15:00:00Z'),
      expireTime?: string(name='ExpireTime', description='The time when the O\\&M task expires.', example='2099-12-29T15:00:00Z'),
      opsStatus?: string(name='OpsStatus', description='The status of the O\\&M task.', example='Ready'),
      opsType?: string(name='OpsType', description='The type of the O\\&M task.', example='coredump'),
      resultContent?: string(name='ResultContent', description='The content of the O\\&M result. The content is the download URL of the files that are generated for the O\\&M task.', example='https://******'),
      resultType?: string(name='ResultType', description='The type of the O\\&M result. Valid value: OSS. This value indicates that the files generated for the O\\&M task are saved to Object Storage Service (OSS) buckets.', example='OSS'),
    }
  ](name='Records', description='The details of the O\\&M tasks.'),
  requestId?: string(name='RequestId', description='The request ID.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model DescribeInstanceOpsRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceOpsRecordsResponseBody(name='body'),
}

async function describeInstanceOpsRecords(request: DescribeInstanceOpsRecordsRequest): DescribeInstanceOpsRecordsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeInstanceOpsRecords', 'POST', '/', 'json', false, 'json', request);
}

model DescribeMultiContainerGroupMetricRequest {
  containerGroupIds: string(name='ContainerGroupIds', description='The instance ID. The value is a JSON array. You can specify up to 20 instance IDs at a time.', example='["eci-2zegym1qhbmdfr1s****","eci-2ze39w5svzj5ic34****"]', position='Query'),
  metricType?: string(name='MetricType', description='The type of the monitoring data. Set the value to summary. This value indicates that records are returned.', example='summary', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the elastic container instances belong.', example='rg-acfmzw2jz2z****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeMultiContainerGroupMetricResponseBody = {
  monitorDatas?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-bp15oolgorelvhfb****'),
      records?: [ 
        {
          CPU?: {
            limit?: long(name='Limit', description='The upper limit of vCPU usage. The calculation formula for this parameter: The number of vCPUs × 1000.', example='2000'),
            load?: long(name='Load', description='The average load in the last 10 seconds.', example='0'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds', description='The cumulative usage of vCPUs.', example='70769883'),
            usageNanoCores?: long(name='UsageNanoCores', description='The vCPU usage in the sampling window. Unit for the sampling window: nanoseconds.', example='0'),
          }(name='CPU', description='The monitoring data of vCPUs.'),
          containers?: [ 
            {
              CPU?: {
                limit?: long(name='Limit', description='The upper limit of vCPU usage. The calculation formula for this parameter: The number of vCPUs × 1000.', example='321234'),
                load?: long(name='Load', description='The average load in the last 10 seconds.', example='12341'),
                usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds', description='The cumulative usage of vCPUs.', example='40876694'),
                usageNanoCores?: long(name='UsageNanoCores', description='The vCPU usage in the sampling window. Unit for the sampling window: nanoseconds.', example='0'),
              }(name='CPU', description='The vCPU monitoring data of the container.'),
              memory?: {
                availableBytes?: long(name='AvailableBytes', description='The size of the available memory. Unit: bytes.', example='4285091840'),
                cache?: long(name='Cache', description='The size of the cache. Unit: bytes.', example='9289728'),
                rss?: long(name='Rss', description='The size of the resident memory set, which indicates the size of the physical memory that is actually used. Unit: bytes.', example='9289728'),
                usageBytes?: long(name='UsageBytes', description='The size of the used memory. Unit: bytes.', example='9289728'),
                workingSet?: long(name='WorkingSet', description='The usage of the working set. Unit: bytes.', example='9289728'),
              }(name='Memory', description='The memory monitoring data of the container.'),
              name?: string(name='Name', description='The name.', example='test1'),
            }
          ](name='Containers', description='The monitoring data of containers.'),
          disk?: [ 
            {
              device?: string(name='Device', description='The name of the disk.', example='/dev/vda'),
              readBytes?: long(name='ReadBytes', description='The amount of data that was read from the disk. Unit: bytes.', example='210714112'),
              readIo?: long(name='ReadIo', description='This parameter is unavailable for public use.', example='123'),
              writeBytes?: long(name='WriteBytes', description='The amount of data that was written to the disk. Unit: bytes.', example='1375109120'),
              writeIo?: long(name='WriteIo', description='This parameter is unavailable for public use.', example='123'),
            }
          ](name='Disk', description='The monitoring data of disks.'),
          filesystem?: [ 
            {
              available?: long(name='Available', description='The size of the available space.', example='35319836672'),
              capacity?: long(name='Capacity', description='The total file system space.', example='41610981376'),
              fsName?: string(name='FsName', description='The name of the partition.', example='/dev/root'),
              usage?: long(name='Usage', description='The size of used space.', example='4368744448'),
            }
          ](name='Filesystem', description='The monitoring data of file system partitions.'),
          memory?: {
            availableBytes?: long(name='AvailableBytes', description='The size of the available memory. Unit: bytes.', example='4289445888'),
            cache?: long(name='Cache', description='The size of the cache. Unit: bytes.', example='7028736'),
            rss?: long(name='Rss', description='The size of the resident memory set, which indicates the size of the physical memory that is actually used. Unit: bytes.', example='1593344'),
            usageBytes?: long(name='UsageBytes', description='The size of the used memory. Unit: bytes.', example='11153408'),
            workingSet?: long(name='WorkingSet', description='The usage of the working set. Unit: bytes.', example='5521408'),
          }(name='Memory', description='The monitoring data of the memory.'),
          network?: {
            interfaces?: [ 
              {
                name?: string(name='Name', description='The name of the NIC.', example='eth0'),
                rxBytes?: long(name='RxBytes', description='The total number of bytes received.', example='505001954'),
                rxDrops?: long(name='RxDrops', description='The number of packets that fail to be received.', example='0'),
                rxErrors?: long(name='RxErrors', description='The number of receipt errors.', example='0'),
                rxPackets?: long(name='RxPackets', description='The total number of packets received.', example='4800583'),
                txBytes?: long(name='TxBytes', description='The total number of bytes sent.', example='1381805699'),
                txDrops?: long(name='TxDrops', description='The number of packets that fail to arrive at their destination.', example='0'),
                txErrors?: long(name='TxErrors', description='The total number of sending errors.', example='0'),
                txPackets?: long(name='TxPackets', description='The total number of packets sent.', example='5158427'),
              }
            ](name='Interfaces', description='The monitoring data of network interface controllers (NICs).'),
          }(name='Network', description='The monitoring data of the network.'),
          timestamp?: string(name='Timestamp', description='The time when the entry of monitoring data was collected. The time follows the RFC 3339 format.', example='2019-12-19T02:31:54Z'),
        }
      ](name='Records', description='The details about monitoring data.'),
    }
  ](name='MonitorDatas', description='The monitoring data of the elastic container instances.'),
  requestId?: string(name='RequestId', description='The request ID.', example='B8756BA0-6452-419C-9727-37A6209C85E0'),
}

model DescribeMultiContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMultiContainerGroupMetricResponseBody(name='body'),
}

/**
  * *   Only the latest entry of monitoring data of each elastic container instance is returned.
  * *   You can query only the monitoring data of elastic container instances that are created after April 3, 2019 15:00:00 UTC+8.
  *
 */
async function describeMultiContainerGroupMetric(request: DescribeMultiContainerGroupMetricRequest): DescribeMultiContainerGroupMetricResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeMultiContainerGroupMetric', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      recommendZones?: [ string ](name='RecommendZones', description='The recommended zones. Recommended zones are zones that have relatively sufficient resources in the current region.'),
      regionEndpoint?: string(name='RegionEndpoint', description='The endpoint for the region.', example='eci.aliyuncs.com'),
      regionId?: string(name='RegionId', description='The region ID.', example='cn-hangzhou'),
      zones?: [ string ](name='Zones', description='The queried zones.'),
    }
  ](name='Regions', description='The queried regions.'),
  requestId?: string(name='RequestId', description='The request ID.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVirtualNodesRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that it is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency of requests?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  limit?: long(name='Limit', description='The maximum number of resources that are allowed to return for this request. Default value: 20. Maximum value: 20.

>  The number of returned resources is less than or equal to the specified number.', example='20', position='Query'),
  nextToken?: string(name='NextToken', description='The token that determines the start point of the next query. If this parameter is empty, all results have been returned.

You do not need to specify this parameter in the first request. From the second request, you can obtain the token from the result returned by the previous request.', example='d78f2dd8-5979-42fe-****-b16db43be5bc', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the virtual nodes.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-uf66jeqopgqa9hdn****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  status?: string(name='Status', description='The status of the virtual node. Valid values:

*   Pending
*   Ready
*   Failed', example='Ready', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N.', example='name'),
      value?: string(name='Value', description='The value of tag N.', example='test'),
    }
  ](name='Tag', description='The tags that are bound to the virtual node.', position='Query'),
  virtualNodeIds?: string(name='VirtualNodeIds', description='The IDs of the virtual nodes. You can specify up to 20 IDs. Each ID must be a string in the JSON format.', example='["vnd-2ze960zkdqrldeaw****","vnd-3ebzcviqbwt25dsz****"]', position='Query'),
  virtualNodeName?: string(name='VirtualNodeName', description='The names of the virtual nodes.', example='testNode', position='Query'),
}

model DescribeVirtualNodesResponseBody = {
  nextToken?: string(name='NextToken', description='The token that determines the start point of the next query.', example='d78f2dd8-5979-42fe-****-b16db43be5bc'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9C9B9917-ED22-50D5-ADE6-9FA9D58AD05F'),
  totalCount?: int32(name='TotalCount', description='The number of virtual nodes that were queried.', example='1'),
  virtualNodes?: [ 
    {
      creationTime?: string(name='CreationTime', description='The time when the virtual node was created. The time follows the RFC 3339 standard and is displayed in UTC.', example='2021-09-08T15:00:00Z'),
      events?: [ 
        {
          count?: int32(name='Count', description='The number of events.', example='1'),
          firstTimestamp?: string(name='FirstTimestamp', description='The time when the event started.', example='2021-09-08T02:24:48Z'),
          lastTimestamp?: string(name='LastTimestamp', description='The time when the event ended.', example='2021-09-08T02:24:52Z'),
          message?: string(name='Message', description='The message of the event.', example='Successfully'),
          name?: string(name='Name', description='The name of the object to which the event belongs.', example='test'),
          reason?: string(name='Reason', description='The name of the event.', example='Created'),
          type?: string(name='Type', description='The type of the event. Valid values:

*   Normal
*   Warning', example='Normal'),
        }
      ](name='Events', description='The events about the virtual node.'),
      internetIp?: string(name='InternetIp', description='The public IP address of the virtual node.', example='192.0.XX.XX'),
      intranetIp?: string(name='IntranetIp', description='The private IP address of the virtual node.', example='10.19.XX.XX'),
      regionId?: string(name='RegionId', description='The ID of the region in which the virtual node resides.', example='cn-hangzhou'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the virtual node belongs.', example='rg-uf66jeqopgqa9hdn****'),
      status?: string(name='Status', description='The status of the virtual node. Valid values:

*   Pending
*   Ready
*   Failed', example='Ready'),
      tags?: [ 
        {
          key?: string(name='Key', description='The key of the tag.', example='name'),
          value?: string(name='Value', description='The value of the tag.', example='test'),
        }
      ](name='Tags', description='The tags that are bound to the virtual node.'),
      virtualNodeId?: string(name='VirtualNodeId', description='The ID of the virtual node.', example='vnd-2ze960zkdqrldeaw****'),
      virtualNodeName?: string(name='VirtualNodeName', description='The name of the virtual node.', example='testNode'),
      virtualNodeSecurityGroupId?: string(name='VirtualNodeSecurityGroupId', description='The ID of the security group to which the virtual node belongs.', example='sg-2zeeyaaxlkq9sppl****'),
      virtualNodeVSwitchId?: string(name='VirtualNodeVSwitchId', description='The ID of the vSwitch with which the virtual node is associated.', example='vsw-2ze23nqzig8inprou****'),
      vpcId?: string(name='VpcId', description='The ID of the VPC to which the virtual node belongs.', example='vpc-1vzjjflab6wvjox****'),
    }
  ](name='VirtualNodes', description='The virtual nodes that were queried.'),
}

model DescribeVirtualNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVirtualNodesResponseBody(name='body'),
}

async function describeVirtualNodes(request: DescribeVirtualNodesRequest): DescribeVirtualNodesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVirtualNodes', 'POST', '/', 'json', false, 'json', request);
}

model ExecContainerCommandRequest {
  command: string(name='Command', description='The commands to run in the container. You can specify up to 20 commands. Each command can be up to 256 characters in length.\\
The strings must be in the JSON format. Example: `["/bin/sh", "-c", "ls -a"]`.', example='["/bin/sh", "-c", "ls -a"]', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-2zebxkiifulhl****', position='Query'),
  containerName: string(name='ContainerName', description='The name of the container.', example='nginx', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  stdin?: boolean(name='Stdin', description='Specifies whether to read the commands from standard input (stdin). Default value: true.', example='true', position='Query'),
  sync?: boolean(name='Sync', description='Specifies whether to run the command immediately and return the result. Default value: false.\\
If you set this parameter to true, set the value of TTY to false.', example='false', position='Query'),
  TTY?: boolean(name='TTY', description='Specifies whether to enable interaction. Default value: false.\\
If the command is a /bin/bash command, set the value to true.', example='false', position='Query'),
}

model ExecContainerCommandResponseBody = {
  httpUrl?: string(name='HttpUrl', description='The HTTP URL. You can use this URL to enter the container within 30 seconds after this operation is called. For more information, see [Use and integrate the Elastic Container Instance terminal](~~202846~~).', example='https://eci.console.aliyun.com/terminal?param=X32a****'),
  requestId?: string(name='RequestId', description='The request ID.', example='28B583A8-313D-4383-7817-B5A9F7E0****'),
  syncResponse?: string(name='SyncResponse', description='The output of the command. This parameter is returned only if Sync is set to true.', example='Hello'),
  webSocketUri?: string(name='WebSocketUri', description='The WebSocket URL. You can use this URL to establish a WebSocket connection with the container.', example='wss://eci-cn-shanghai.aliyun.com/exec/?s=ktHPx****'),
}

model ExecContainerCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecContainerCommandResponseBody(name='body'),
}

async function execContainerCommand(request: ExecContainerCommandRequest): ExecContainerCommandResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecContainerCommand', 'POST', '/', 'json', false, 'json', request);
}

model ListUsageRequest {
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model ListUsageResponseBody = {
  attributes?: map[string]any(name='Attributes', description='The information about the used amounts and upper limits of privileges and quotas that you have in the specified region. The information contains the following items:

*   UsedCpu: the number of existing vCPUs.
*   MaxCpu: the upper limit of vCPUs.
*   MaxImageCacheCount: the upper limit of manually created image caches.
*   UsedImageCacheCount: the number of existing image caches that are manually created.
*   MaxAutoImageCacheCount: the upper limit of automatically created image caches.
*   UsedAutoImageCacheCount: the number of existing image caches that are automatically created.
*   MaxDataCacheCount: the upper limit of DataCaches.
*   UsedDataCacheCount: the number of existing DataCaches.', example='{"UsedCpu": 11,"MaxCpu": 1000,"MaxImageCacheCount": 50,"UsedImageCacheCount": 0}'),
  requestId?: string(name='RequestId', description='The request ID.', example='89164E78-FC82-4684-BE97-DCDD85D26546'),
}

model ListUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsageResponseBody(name='body'),
}

/**
  * This operation does not support resource group authentication.
  *
 */
async function listUsage(request: ListUsageRequest): ListUsageResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ListUsage', 'POST', '/', 'json', false, 'json', request);
}

model ResizeContainerGroupVolumeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotence](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The ID of the elastic container instance.', example='eci-2zelg8vwnlzdhf8hv****', position='Query'),
  newSize: long(name='NewSize', description='The size of the volume after the volume is scaled up. Unit: GiB. Valid values:

*   Ultra disk (cloud_efficiency): 20 to 32768
*   Standard SSD (cloud_ssd): 20 to 32768
*   Enhanced SSD (cloud_essd): 20 to 32768
*   Basic disk (cloud): 5 to 2000

>  The capacity of the volume after the volume is scaled up must be greater than the original capacity of the volume. If the new capacity is equal to the original capacity of the volume, only the file system is scaled up.', example='100', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  volumeName: string(name='VolumeName', description='The name of the volume that you want to scale up. The volume must be an Alibaba Cloud disk.', example='default-volume1', position='Query'),
}

model ResizeContainerGroupVolumeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model ResizeContainerGroupVolumeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeContainerGroupVolumeResponseBody(name='body'),
}

/**
  * You can scale up volumes by calling this operation. You cannot scale down volumes by calling this operation. Only volumes of Alibaba Cloud disks can be scaled up.
  *
 */
async function resizeContainerGroupVolume(request: ResizeContainerGroupVolumeRequest): ResizeContainerGroupVolumeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ResizeContainerGroupVolume', 'POST', '/', 'json', false, 'json', request);
}

model RestartContainerGroupRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The instance ID.', example='eci-2zelg8vwnlzdhf8hv****', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
}

model RestartContainerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='45D5B0AD-3B00-4A9B-9911-6D5303B06712'),
}

model RestartContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartContainerGroupResponseBody(name='body'),
}

/**
  * *   Only elastic container instances that are in the Pending or Running state can be restarted. Instances that are in the Succeeded or Failed state cannot be restarted.
  * *   Elastic container instances that were created before 15:00:00 on March 7, 2019 cannot be restarted.
  * *   When an elastic container instance is being restarted, its status changes into Restarting.
  *
 */
async function restartContainerGroup(request: RestartContainerGroupRequest): RestartContainerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'RestartContainerGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer', description='The IP addresses of the DNS servers.', example='1.2.3.4'),
    option?: [ 
      {
        name?: string(name='Name', description='The option name of DNS configurations.', example='ndots'),
        value?: string(name='Value', description='The option value of DNS configurations.', example='2'),
      }
    ](name='Option', description='The configurations of DNS.'),
    search?: [ string ](name='Search', description='The search domains of the Domain Name System (DNS) server.', example='my.dns.search.suffix'),
  }(name='DnsConfig', position='Query'),
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain', description='The domain names of the Container Registry Enterprise Edition instance. By default, all domain names of the instance are displayed. You can specify one or more domain names. Separate multiple domain names with commas (,).'),
      instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of the Container Registry Enterprise Edition instance.', example='acr-test'),
      regionId?: string(name='RegionId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cn-beijing'),
    }
  ](name='AcrRegistryInfo', description='The information about the Container Registry Enterprise Edition instance.', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the value, but you must ensure that the value is unique among different requests. The token can only contain ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency](~~25693~~).', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  container?: [ 
    {
      livenessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg', description='The arguments that are passed to the container startup command. You can specify up to 10 arguments.', example='hello'),
      command?: [ string ](name='Command', description='The commands that are used to run the probe.', example='echo'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the container.', example='1.0'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The name of the environment variable for the container.', example='PATH'),
          value?: string(name='Value', description='The value of the environment variable for the container.', example='/usr/bin/local/'),
        }
      ](name='EnvironmentVar', description='The environment variables for the container.'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the container.', example='1'),
      image?: string(name='Image', description='The image of the container.', example='jenkins'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy.', example='Never'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec', description='The command that you run in the container when you use a command-line interface (CLI) to specify the postStart callback function.', example='hide'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost', description='The IP address of the host that receives HTTP GET requests when you use HTTP requests to specify the postStart callback function.', example='hide'),
      lifecyclePostStartHandlerHttpGetHttpHeaders?: [ 
        {
          name?: string(name='Name', description='The request parameter of HTTP GET requests when you use HTTP requests to specify the postStart callback function.', example='testValue'),
          value?: string(name='Value', description='The request parameter value of HTTP GET requests when you use HTTP requests to specify the postStart callback function.', example='test'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeaders', description='The information about the valid HTTP request headers among the generated HTTP request headers.'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath', description='The path to which HTTP GET requests are sent when you use HTTP requests to specify the postStart callback function.', example='/healthyz'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort', description='The port to which HTTP GET requests are sent when you use HTTP requests to specify the postStart callback function.', example='1'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme', description='The path to which HTTP GET requests are sent when you use HTTP requests to specify the postStart callback function.', example='/healthyz'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost', description='The host IP address of TCP socket probes when you use TCP sockets to specify the postStart callback function.', example='10.0.XX.XX'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort', description='The port of TCP socket probes when you use TCP sockets to specify the postStart callback function.', example='1'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec', description='The command that you run in the container when you use a CLI to specify the preStop callback function.', example='hide'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost', description='The IP address of the host that receives HTTP GET requests when you use HTTP requests to specify the preStop callback function.', example='10.0.XX.XX'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name', description='The request parameter of HTTP GET requests when you use HTTP requests to specify the preStop callback function.', example='test'),
          value?: string(name='Value', description='The request parameter value of HTTP GET requests when you use HTTP requests to specify the preStop callback function.', example='testValue'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader', description='The information about the generated HTTP request headers.'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath', description='The path to which HTTP GET requests are sent when you use HTTP requests to specify the preStop callback function.', example='/healthyz'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort', description='The port to which HTTP GET requests are sent when you use HTTP requests to specify the preStop callback function.', example='1'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme', description='The protocol type of HTTP GET requests when you use HTTP requests to specify the preStop callback function. Valid values:

*   HTTP
*   HTTPS', example='HTTP'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost', description='The host IP address of TCP socket probes when you use TCP sockets to specify the preStop callback function.', example='10.0.XX.XX'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort', description='The port of TCP socket probes when you use TCP sockets to specify the preStop callback function.', example='80'),
      memory?: float(name='Memory', description='The memory size of the container.', example='2.0'),
      name?: string(name='Name', description='The name of the container.', example='jenkins'),
      port?: [ 
        {
          port?: int32(name='Port', description='The port number. Valid values: 1 to 65535.', example='8080'),
          protocol?: string(name='Protocol', description='The protocol of the container. Valid values: TCP and UDP.', example='TCP'),
        }
      ](name='Port', description='The port to which the system sends an HTTP GET request for a health check.'),
      stdin?: boolean(name='Stdin', description='Specifies whether the container allocates buffer resources to standard input streams when the container is running. If you do not specify this parameter, an end-of-file (EOF) error may occur when standard input streams in the container are read. Default value: false.', example='false'),
      stdinOnce?: boolean(name='StdinOnce', description='Whether the container runtime closes the stdin channel after the stdin channel has been opened by a sing attach. If stdin is true, the stdin stream remains open across multiple attach sessions. If StdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and receive data until the client disconnects. When the client disconnects, stdin is closed and remains closed until the container is restarted.', example='true'),
      tty?: boolean(name='Tty', description='Specifies whether to enable interaction. Default value: false. If the command is a /bin/bash command, set the value to true.', example='false'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath', description='The directory of the volume that is mounted to the container. The data in this directory is overwritten by the data on the volume. Specify this parameter with caution.', example='/usr/share/'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation setting of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: This volume mount does not receive subsequent mounts that are mounted to this volume or subdirectories of this volume by the host.
*   HostToCotainer: This volume mount receives all subsequent mounts that are mounted to this volume or subdirectories of this volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives all subsequent mounts that are mounted to this volume or subdirectories of this volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The name of the volume that is mounted to the container. Valid values: the values of Volume.N.Name, which are the names of volumes that are mounted to the elastic container instance.', example='test-empty'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the volume is read-only. Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume that is mounted to the container. The pod can mount different directories of the same volume to different subdirectories of containers.', example='/usr/share/sub/'),
        }
      ](name='VolumeMount', description='Pod volumes to mount into the filesystem of the container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the container.', example='/usr/share/'),
    }
  ](name='Container', description='The new configurations of the container group.', position='Query'),
  containerGroupId: string(name='ContainerGroupId', description='The ID of the elastic container instance that you want to update.', example='eci-2zelg8vwnlzdhf8hv****', position='Query'),
  cpu?: float(name='Cpu', description='The number of vCPUs allocated to the elastic container instance.', example='2.0', position='Query'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password', description='The password that is used to access the image repository.', example='yourpassword'),
      server?: string(name='Server', description='The address of the image repository. This address does not contain `http://` or `https://`.', example='registry.cn-shanghai.aliyuncs.com/ecitest/nginx:alpine'),
      userName?: string(name='UserName', description='The username that is used to access the image repository.', example='yourname'),
    }
  ](name='ImageRegistryCredential', description='The information about the credentials of the image repository.', position='Query'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg', description='The startup arguments of the init container.', example='10'),
      command?: [ string ](name='Command', description='The commands of the init container.', example='/bin/sh sleep'),
      cpu?: float(name='Cpu', description='The number of vCPUs that you want to allocate to the init container.', example='2.0'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key', description='The name of the environment variable for the init container.', example='PATH'),
          value?: string(name='Value', description='The value of the environment variable for the init container.', example='/usr/local/bin'),
        }
      ](name='EnvironmentVar', description='The environment variables for the init container.'),
      gpu?: int32(name='Gpu', description='The number of GPUs that you want to allocate to the init container.', example='1'),
      image?: string(name='Image', description='The image of the init container.', example='nginx'),
      imagePullPolicy?: string(name='ImagePullPolicy', description='The image pulling policy.', example='Onfailure'),
      memory?: float(name='Memory', description='The size of memory that you want to allocate to the init container.', example='4.0'),
      name?: string(name='Name', description='The name of the init container.', example='init-nginx'),
      port?: [ 
        {
          port?: int32(name='Port', description='The port number of the init container. Valid values: 1 to 65535.', example='9000'),
          protocol?: string(name='Protocol', description='The protocol of the init container. Valid values: TCP and UDP.', example='TCP'),
        }
      ](name='Port', description='The port number. Valid values: 1 to 65535.'),
      stdin?: boolean(name='Stdin', description='Specifies whether the init container allocates buffer resources to standard input streams when the init container is running. If you do not specify this parameter, an EOF error may occur when standard input streams in the init container are read. Default value: false.', example='false'),
      stdinOnce?: boolean(name='StdinOnce', description='Whether the container runtime closes the stdin channel after the stdin channel has been opened by a sing attach. If stdin is true, the stdin stream remains open across multiple attach sessions. If StdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and receive data until the client disconnects. When the client disconnects, stdin is closed and remains closed until the container is restarted.', example='true'),
      tty?: boolean(name='Tty', description='Specifies whether to enable interaction. Default value: false. If the command is a /bin/bash command, set the value to true.', example='true'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath', description='The directory of the volume that is mounted to the init container. The data in this directory is overwritten by the data on the volume. Specify this parameter with caution.', example='/pod/data'),
          mountPropagation?: string(name='MountPropagation', description='The mount propagation setting of the volume. Mount propagation allows volumes that are mounted on one container to be shared with other containers in the same pod, or even with other pods on the same node. Valid values:

*   None: This volume mount does not receive subsequent mounts that are mounted to this volume or subdirectories of this volume by the host.
*   HostToCotainer: This volume mount receives all subsequent mounts that are mounted to this volume or subdirectories of this volume.
*   Bidirectional: The volume mount behaves the same as the HostToCotainer mount. The volume mount receives all subsequent mounts that are mounted to this volume or subdirectories of this volume. In addition, all volume mounts created by the container are propagated back to the host and to all containers of all pods that use the same volume.

Default value: None.', example='None'),
          name?: string(name='Name', description='The name of the volume that is mounted to the init container. Valid values: the values of Volume.N.Name, which are the names of volumes that are mounted to the elastic container instance.', example='default-volume1'),
          readOnly?: boolean(name='ReadOnly', description='Specifies whether the volume is read-only. Default value: false.', example='false'),
          subPath?: string(name='SubPath', description='The subdirectory of the volume that is mounted to the init container. The pod can mount different directories of the same volume to different subdirectories of init containers.', example='data2/'),
        }
      ](name='VolumeMount', description='Pod volumes to mount into the filesystem of the init container.'),
      workingDir?: string(name='WorkingDir', description='The working directory of the init container.', example='/bin/local/'),
    }
  ](name='InitContainer', description='The information about the new init containers.', position='Query'),
  memory?: float(name='Memory', description='The memory size allocated to the elastic container instance. Unit: GiB.', example='4.0', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the instance.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-2df3isufhi38****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  restartPolicy?: string(name='RestartPolicy', description='The restart policy of the elastic container instance. Valid values:

*   Always: Always restarts the instance if a container in the instance exits upon termination.
*   Never: Never restarts the instance if a container in the instance exits upon termination.
*   OnFailure: Restarts the instance only if a container in the instance exists upon failure with a status code of non-zero.', example='Always', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='name'),
      value?: string(name='Value', description='The value of the tag.', example='hxh'),
    }
  ](name='Tag', description='The tags that are bound to the instance.', position='Query'),
  updateType?: string(name='UpdateType', description='The update type. Valid values:

*   RenewUpdate: full update. You must specify all relevant parameters to update the instance. For a parameter of the List type, you must specify all the items contained in the parameter even if you want to update only some of the items. For a parameter of the struct type, you must specify all the members if you want to update only some of the members.
*   IncrementalUpdate: incremental update. You can specify only the parameter that needs to be updated. Other related parameters remain unchanged.

Default value: RenewUpdate.', example='RenewUpdate', position='Query'),
  volume?: [ 
    {
      configFileVolume: {
        configFileToPath?: [ 
          {
            content?: string(name='Content'),
            path?: string(name='Path'),
          }
        ](name='ConfigFileToPath'),
      }(name='ConfigFileVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
        sizeLimit?: string(name='SizeLimit'),
      }(name='EmptyDirVolume'),
      flexVolume: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      name?: string(name='Name', description='The name of the volume.', example='test-empty'),
      type?: string(name='Type', description='The type of the HostPath volume. Valid values:

*   Directory
*   File

> This parameter is unavailable.', example='EmptyDirVolume'),
    }
  ](name='Volume', description='The volumes that are mounted to the instance.', position='Query'),
}

model UpdateContainerGroupResponseBody = {
  requestId?: string(name='RequestId', description='The ID of the request.', example='CB8D2B22-D636-4182-****-1FC9DBDAD66F'),
}

model UpdateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateContainerGroupResponseBody(name='body'),
}

/**
  * *   You can update only elastic container instances that are in the Pending or Running state. After you call this operation to update an elastic container instance, the instance enters the Updating state.
  * *   You cannot update elastic container instances that were created before 15:00:00 March 7, 2019.
  *
 */
async function updateContainerGroup(request: UpdateContainerGroupRequest): UpdateContainerGroupResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateContainerGroup', 'POST', '/', 'json', false, 'json', request);
}

model UpdateDataCacheRequest {
  bucket?: string(name='Bucket', description='The bucket in which the data cache is stored. Default value: default.', example='default', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate a token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence](~~25693~~).', example='2f22dc16-cad0-4d3f-87e5-91e604756547', position='Query'),
  dataCacheId?: string(name='DataCacheId', description='The data cache ID.', example='edc-bp1a7n7uawwwol******', position='Query'),
  dataSource?: {
    options?: map[string]string(name='Options', description='The parameters that are configured for the data source.'),
    type?: string(name='Type', description='The type of the data source. Valid values:

*   URL
*   NAS
*   OSS
*   SNAPSHOT', example='NAS'),
  }(name='DataSource', description='The information about the data source.', position='Query'),
  eipCreateParam?: {
    bandwidth?: int32(name='Bandwidth', description='The bandwidth of the EIP. Unit: Mbit/s. Default value: 5.', example='10'),
    commonBandwidthPackage?: string(name='CommonBandwidthPackage', description='The EIP bandwidth plan to be associated.', example='cbwp-2zeukbj916scmj51m****'),
    ISP?: string(name='ISP', description='The line type of the EIP. Valid values:

*   BGP (default): BGP (Multi-ISP) line
*   BGP_PRO: BGP (Multi-ISP) Pro line', example='BGP'),
    internetChargeType?: string(name='InternetChargeType', description='The metering method of the EIP. Valid values:

*   PayByBandwidth: pay-by-bandwidth
*   PayByTraffic: pay-by-data-transfer', example='PayByTraffic'),
    publicIpAddressPoolId?: string(name='PublicIpAddressPoolId', description='The ID of the IP address pool. The EIP is allocated from the IP address pool. You cannot use the IP address pool feature by default. To use this feature, you must apply for the privilege in the Quota Center console.', example='pippool-bp187arfugi543y1s****'),
  }(name='EipCreateParam', description='The elastic IP address (EIP) to be created and associated. If no NAT gateway is configured for the virtual private cloud (VPC), you can associate an EIP to pull data from the Internet.', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The ID of the elastic IP address (EIP). If no NAT gateway is configured for the virtual private cloud (VPC), you can bind an EIP to the elastic container instance to pull data from the Internet.', example='eip-2zedsm5mfl3uhdj2d****', position='Query'),
  name?: string(name='Name', description='The data cache name.', example='test', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The resource group ID.', example='rg-acfmzw2jz2z****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The retention period for the data cache. The data cache is deleted after the retention period expires. By default, the data cache does not expire.', example='7', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group.', example='sg-2ze81zoc3yl7a3we****', position='Query'),
  size?: int32(name='Size', description='The data cache size.', example='20', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='testkey'),
      value?: string(name='Value', description='The tag value.', example='testvalue'),
    }
  ](name='Tag', description='The tags that are added to the data cache.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The vSwitch ID.', example='vsw-2ze23nqzig8inprou****', position='Query'),
}

model UpdateDataCacheResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='BD8BBB43-8E05-5F46-89A9-2512D8A324A2'),
}

model UpdateDataCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDataCacheResponseBody(name='body'),
}

async function updateDataCache(request: UpdateDataCacheRequest): UpdateDataCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateDataCache', 'POST', '/', 'json', false, 'json', request);
}

model UpdateImageCacheRequest {
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain', description='The domain names of the Container Registry Enterprise Edition instance. By default, all domain names of the instance are displayed. You can specify multiple domain names. Separate multiple domain names with commas (,).', example='test****-registry.cn-hangzhou.cr.aliyuncs.com'),
      instanceId?: string(name='InstanceId', description='The ID of the Container Registry Enterprise Edition instance.', example='cri-nwj395hgf6f3****'),
      instanceName?: string(name='InstanceName', description='The name of the Container Registry Enterprise Edition instance.', example='test****'),
      regionId?: string(name='RegionId', description='The region ID of the Container Registry Enterprise Edition instance.', example='cn-hangzhou'),
    }
  ](name='AcrRegistryInfo', description='The information about the Container Registry Enterprise Edition instance.', position='Query'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache', description='Specifies whether to enable reuse of image cache layers. If you enable this feature and the image cache that you want to create and an existing image cache contain duplicate image layers, the system reuses the duplicate image layers to create the new image cache. This accelerates the creation of the image cache. Valid values:

*   true
*   false

Default value: false.', example='true', position='Query'),
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure the idempotence of a request?](~~25693~~)', example='123e4567-xxx-xxx-xxxx-42665544xxxx', position='Query'),
  eipInstanceId?: string(name='EipInstanceId', description='The ID of the elastic IP address (EIP). If you want to pull public images, you must make sure that the elastic container instance can access the Internet. To enable Internet access, you can configure an EIP or a NAT gateway for the instance.', example='eip-2zedsm5mfl3uhdj2d****', position='Query'),
  eliminationStrategy?: string(name='EliminationStrategy', description='The elimination policy for the image cache. This parameter is empty by default, which indicates that the image cache is always retained.

You can set this parameter to LRU, which indicates that the image cache can be automatically deleted. When the number of image caches reaches the quota, the system automatically deletes the image caches whose EliminationStrategy parameter is set to LRU and that are least recently used.', example='LRU', position='Query'),
  flash?: boolean(name='Flash', description='Specifies whether to enable the instant image cache feature. The feature can accelerate the creation of image caches. Valid values:

*   true
*   false

Default value: false.', example='true', position='Query'),
  flashCopyCount?: int32(name='FlashCopyCount', description='The number of duplicates of temporary local snapshots. By default, the system creates one snapshot for each image cache. If you use the image cache to create multiple elastic container instances at a time, we recommend that you configure this parameter to create multiple snapshot duplicates for the image cache. We recommend that you create one snapshot duplicate for creation of every 1,000 elastic container instances.

> If you enable the instant image cache feature by setting Flash to true, a local snapshot is first created during the creation of the image cache. After the local snapshot is created, regular snapshots start to be created. After the regular snapshots are created, the local snapshot is automatically deleted.', example='7', position='Query'),
  image?: [ string ](name='Image', description='Container images that are used to create the image cache.', example='registry-vpc.cn-hangzhou.aliyuncs.com/eci_open/nginx:1.15.10-perl', position='Query'),
  imageCacheId: string(name='ImageCacheId', description='The ID of the image cache.', example='imc-bp195erqe9o2pb09****', position='Query'),
  imageCacheName?: string(name='ImageCacheName', description='The name of the image cache.', example='testcache', position='Query'),
  imageCacheSize?: int32(name='ImageCacheSize', description='The size of the image cache. Unit: GiB. Default value: 20.', example='20', position='Query'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password', description='The password that is used to access the image repository.', example='password'),
      server?: string(name='Server', description='The image repository address without `http://` or `https://` as a prefix.', example='registry-vpc.cn-hangzhou.aliyuncs.com'),
      userName?: string(name='UserName', description='The username that is used to access the image repository.', example='username'),
    }
  ](name='ImageRegistryCredential', description='The information about the image repository.', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the image cache.', example='cn-hangzhou', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group to which the image cache belongs.', example='rg-aekzh43v*****', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  retentionDays?: int32(name='RetentionDays', description='The retention period of the image cache. Unit: days. When the retention period elapses, the image cache expires and is deleted. By default, image caches never expire.

> The image caches that fail to be created are retained for only 1 day.', example='7', position='Query'),
  securityGroupId?: string(name='SecurityGroupId', description='The ID of the security group to which the image cache belongs.', example='sg-uf66jeqopgqa9hdn****', position='Query'),
  standardCopyCount?: int32(name='StandardCopyCount', description='The number of duplicates of regular snapshots. By default, the system creates one snapshot for each image cache. If you use the image cache to create multiple elastic container instances at a time, we recommend that you configure this parameter to create multiple snapshot duplicates for the image cache. We recommend that you create one snapshot duplicate for creation of every 1,000 elastic container instances.

> If you disable the instant image cache feature by setting Flash to false, only regular snapshots are generated when you create an image cache.', example='7', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N to add to the image cache.', example='imc'),
      value?: string(name='Value', description='The value of tag N to add to the image cache.', example='test'),
    }
  ](name='Tag', description='The tags to add to the image cache. A maximum of 20 tags can be added to the image cache.', position='Query'),
  vSwitchId?: string(name='VSwitchId', description='The ID of the vSwitch to which the image cache is connected.', example='vsw-uf6h3rbwbm90urjwa****', position='Query'),
}

model UpdateImageCacheResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='0E234675-3465-4CC3-9D0F-9A864BC391DD'),
}

model UpdateImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageCacheResponseBody(name='body'),
}

/**
  * Only image caches that are in the Ready or UpdateFailed state can be updated.
  *
 */
async function updateImageCache(request: UpdateImageCacheRequest): UpdateImageCacheResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateImageCache', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVirtualNodeRequest {
  clientToken?: string(name='ClientToken', description='The client token that is used to ensure the idempotence of the request. You can use the client to generate the token, but you must make sure that the token is unique among different requests. The token can contain only ASCII characters and cannot exceed 64 characters in length. For more information, see [How to ensure idempotency of requests?](~~25693~~)', example='123e4567-e89b-12d3-a456-426655440000', position='Query'),
  clusterDNS?: string(name='ClusterDNS', description='The IP address of the DNS server. If `dnsPolicy=ClusterFirst` is configured for the Elastic Container Instance pod, Elastic Container Instance uses the configuration to provide DNS services to containers. You can configure multiple IP addresses. Separate multiple IP addresses with commas (,).', example='100.1.XX.XX', position='Query'),
  clusterDomain?: string(name='ClusterDomain', description='The domain name of the cluster. If this parameter is specified, in addition to the search domain of the host, Kubelet configures all containers to search for the specified domain name.', example='example.com', position='Query'),
  customResources?: string(name='CustomResources', description='The custom resources that are supported by the virtual node. If a custom resource is specified in the request of an Elastic Container Instance pod, the pod is scheduled to run on the virtual node that supports the custom resource. You can use the `Resource name = Number of resources` format to specify custom resources. Separate multiple resources with commas (,).', example='example1.com=100,example2.com=200', position='Query'),
  ownerAccount?: string(name='OwnerAccount', position='Query'),
  ownerId?: long(name='OwnerId', position='Query'),
  regionId: string(name='RegionId', description='The region ID of the virtual node.', example='cn-hangzhou', position='Query'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount', position='Query'),
  resourceOwnerId?: long(name='ResourceOwnerId', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of tag N to add to the virtual node.', example='name'),
      value?: string(name='Value', description='The value of tag N to add to the virtual node.', example='test'),
    }
  ](name='Tag', description='The tags to add to the virtual node.', position='Query'),
  virtualNodeId: string(name='VirtualNodeId', description='The ID of the virtual node.', example='vnd-2ze960zkdqrldeaw****', position='Query'),
  virtualNodeName?: string(name='VirtualNodeName', description='The name of the virtual node.', example='testNode', position='Query'),
}

model UpdateVirtualNodeResponseBody = {
  requestId?: string(name='RequestId', description='The request ID.', example='89945DD3-9072-47D0-A318-353284CFC7B3'),
}

model UpdateVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVirtualNodeResponseBody(name='body'),
}

/**
  * ## Usage notes
  * Only virtual nodes that are in the Ready state can be updated.
  *
 */
async function updateVirtualNode(request: UpdateVirtualNodeRequest): UpdateVirtualNodeResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVirtualNode', 'POST', '/', 'json', false, 'json', request);
}

