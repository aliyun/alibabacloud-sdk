/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  

  checkConfig(config);
  @endpoint = getEndpoint('eci', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    search?: [ string ](name='Search'),
    option?: [ 
      {
        value?: string(name='Value'),
        name?: string(name='Name'),
      }
    ](name='Option'),
  }(name='DnsConfig'),
  securityContext?: {
    sysctl?: [ 
      {
        value?: string(name='Value'),
        name?: string(name='Name'),
      }
    ](name='Sysctl'),
  }(name='SecurityContext'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  containerGroupName?: string(name='ContainerGroupName'),
  restartPolicy?: string(name='RestartPolicy'),
  eipInstanceId?: string(name='EipInstanceId'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
  resourceGroupId?: string(name='ResourceGroupId'),
  dnsPolicy?: string(name='DnsPolicy'),
  clientToken?: string(name='ClientToken'),
  instanceType?: string(name='InstanceType'),
  slsEnable?: boolean(name='SlsEnable'),
  imageSnapshotId?: string(name='ImageSnapshotId'),
  ramRoleName?: string(name='RamRoleName'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds'),
  spotStrategy?: string(name='SpotStrategy'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  scheduleStrategy?: string(name='ScheduleStrategy'),
  tenantVSwitchId?: string(name='TenantVSwitchId'),
  tenantSecurityGroupId?: string(name='TenantSecurityGroupId'),
  corePattern?: string(name='CorePattern'),
  shareProcessNamespace?: boolean(name='ShareProcessNamespace'),
  productOnEciMode?: string(name='ProductOnEciMode'),
  secondaryENIPolicy?: string(name='SecondaryENIPolicy'),
  autoCreateEip?: boolean(name='AutoCreateEip'),
  eipBandwidth?: int32(name='EipBandwidth'),
  eipISP?: string(name='EipISP'),
  eipCommonBandwidthPackage?: string(name='EipCommonBandwidthPackage'),
  hostName?: string(name='HostName'),
  ingressBandwidth?: long(name='IngressBandwidth'),
  egressBandwidth?: long(name='EgressBandwidth'),
  cpuOptionsCore?: int32(name='CpuOptionsCore'),
  cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore'),
  cpuOptionsNuma?: string(name='CpuOptionsNuma'),
  ephemeralStorage?: int32(name='EphemeralStorage'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  container?: [ 
    {
      readinessProbe: {
        timeoutSeconds?: int32(name='TimeoutSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        httpGet: {
            scheme?: string(name='Scheme'),
            path?: string(name='Path'),
            port?: int32(name='Port'),
        }(name='HttpGet'),
        periodSeconds?: int32(name='PeriodSeconds'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      livenessProbe: {
        periodSeconds?: int32(name='PeriodSeconds'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        httpGet: {
            scheme?: string(name='Scheme'),
            port?: int32(name='Port'),
            path?: string(name='Path'),
        }(name='HttpGet'),
        failureThreshold?: int32(name='FailureThreshold'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      tty?: boolean(name='Tty'),
      workingDir?: string(name='WorkingDir'),
      arg?: [ string ](name='Arg'),
      stdin?: boolean(name='Stdin'),
      volumeMount?: [ 
        {
          mountPropagation?: string(name='MountPropagation'),
          mountPath?: string(name='MountPath'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
          name?: string(name='Name'),
        }
      ](name='VolumeMount'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      stdinOnce?: boolean(name='StdinOnce'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme'),
      command?: [ string ](name='Command'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath'),
      port?: [ 
        {
          protocol?: string(name='Protocol'),
          port?: int32(name='Port'),
        }
      ](name='Port'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost'),
      gpu?: int32(name='Gpu'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost'),
      image?: string(name='Image'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader'),
      cpu?: float(name='Cpu'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort'),
      lifecyclePostStartHandlerHttpGetHttpHeader?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeader'),
    }
  ](name='Container'),
  volume?: [ 
    {
      diskVolume: {
        diskSize?: int32(name='DiskSize'),
        fsType?: string(name='FsType'),
        diskId?: string(name='DiskId'),
      }(name='DiskVolume'),
      NFSVolume: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      flexVolume: {
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
        driver?: string(name='Driver'),
      }(name='FlexVolume'),
      hostPathVolume: {
        type?: string(name='Type'),
        path?: string(name='Path'),
      }(name='HostPathVolume'),
      configFileVolume: {
        defaultMode?: int32(name='DefaultMode'),
        configFileToPath?: [ 
          {
            path?: string(name='Path'),
            mode?: int32(name='Mode'),
            content?: string(name='Content'),
          }
        ](name='ConfigFileToPath'),
      }(name='ConfigFileVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
      type?: string(name='Type'),
      name?: string(name='Name'),
    }
  ](name='Volume'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      image?: string(name='Image'),
      volumeMount?: [ 
        {
          mountPropagation?: string(name='MountPropagation'),
          mountPath?: string(name='MountPath'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
          name?: string(name='Name'),
        }
      ](name='VolumeMount'),
      port?: [ 
        {
          protocol?: string(name='Protocol'),
          port?: int32(name='Port'),
        }
      ](name='Port'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      workingDir?: string(name='WorkingDir'),
      cpu?: float(name='Cpu'),
      arg?: [ string ](name='Arg'),
      command?: [ string ](name='Command'),
      gpu?: int32(name='Gpu'),
      memory?: float(name='Memory'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
      name?: string(name='Name'),
    }
  ](name='InitContainer'),
  hostAliase?: [ 
    {
      ip?: string(name='Ip'),
      hostname?: [ string ](name='Hostname'),
    }
  ](name='HostAliase'),
  arn?: [ 
    {
      roleArn?: string(name='RoleArn'),
      roleType?: string(name='RoleType'),
      assumeRoleFor?: string(name='AssumeRoleFor'),
    }
  ](name='Arn'),
  ntpServer?: [ string ](name='NtpServer'),
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain'),
      instanceName?: string(name='InstanceName'),
      instanceId?: string(name='InstanceId'),
      regionId?: string(name='RegionId'),
    }
  ](name='AcrRegistryInfo'),
}

model CreateContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
  containerGroupId?: string(name='ContainerGroupId'),
}

model CreateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateContainerGroupResponseBody(name='body'),
}

async function createContainerGroupWithOptions(request: CreateContainerGroupRequest, runtime: Util.RuntimeOptions): CreateContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["SecurityGroupId"] = request.securityGroupId;
  query["VSwitchId"] = request.vSwitchId;
  query["ContainerGroupName"] = request.containerGroupName;
  query["RestartPolicy"] = request.restartPolicy;
  query["EipInstanceId"] = request.eipInstanceId;
  query["Cpu"] = request.cpu;
  query["Memory"] = request.memory;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["DnsPolicy"] = request.dnsPolicy;
  query["ClientToken"] = request.clientToken;
  query["InstanceType"] = request.instanceType;
  query["SlsEnable"] = request.slsEnable;
  query["ImageSnapshotId"] = request.imageSnapshotId;
  query["RamRoleName"] = request.ramRoleName;
  query["TerminationGracePeriodSeconds"] = request.terminationGracePeriodSeconds;
  query["AutoMatchImageCache"] = request.autoMatchImageCache;
  query["Ipv6AddressCount"] = request.ipv6AddressCount;
  query["ActiveDeadlineSeconds"] = request.activeDeadlineSeconds;
  query["SpotStrategy"] = request.spotStrategy;
  query["SpotPriceLimit"] = request.spotPriceLimit;
  query["ScheduleStrategy"] = request.scheduleStrategy;
  query["TenantVSwitchId"] = request.tenantVSwitchId;
  query["TenantSecurityGroupId"] = request.tenantSecurityGroupId;
  query["CorePattern"] = request.corePattern;
  query["ShareProcessNamespace"] = request.shareProcessNamespace;
  query["ProductOnEciMode"] = request.productOnEciMode;
  query["SecondaryENIPolicy"] = request.secondaryENIPolicy;
  query["AutoCreateEip"] = request.autoCreateEip;
  query["EipBandwidth"] = request.eipBandwidth;
  query["EipISP"] = request.eipISP;
  query["EipCommonBandwidthPackage"] = request.eipCommonBandwidthPackage;
  query["HostName"] = request.hostName;
  query["IngressBandwidth"] = request.ingressBandwidth;
  query["EgressBandwidth"] = request.egressBandwidth;
  query["CpuOptionsCore"] = request.cpuOptionsCore;
  query["CpuOptionsThreadsPerCore"] = request.cpuOptionsThreadsPerCore;
  query["CpuOptionsNuma"] = request.cpuOptionsNuma;
  query["EphemeralStorage"] = request.ephemeralStorage;
  query["Tag"] = request.tag;
  query["ImageRegistryCredential"] = request.imageRegistryCredential;
  query["Container"] = request.container;
  query["Volume"] = request.volume;
  query["InitContainer"] = request.initContainer;
  query["HostAliase"] = request.hostAliase;
  query["Arn"] = request.arn;
  query["NtpServer"] = request.ntpServer;
  query["AcrRegistryInfo"] = request.acrRegistryInfo;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createContainerGroup(request: CreateContainerGroupRequest): CreateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerGroupWithOptions(request, runtime);
}

model CreateImageCacheRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  securityGroupId?: string(name='SecurityGroupId'),
  vSwitchId?: string(name='VSwitchId'),
  imageCacheName?: string(name='ImageCacheName'),
  eipInstanceId?: string(name='EipInstanceId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  clientToken?: string(name='ClientToken'),
  imageCacheSize?: int32(name='ImageCacheSize'),
  retentionDays?: int32(name='RetentionDays'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  image?: [ string ](name='Image'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model CreateImageCacheResponseBody = {
  requestId?: string(name='RequestId'),
  imageCacheId?: string(name='ImageCacheId'),
  containerGroupId?: string(name='ContainerGroupId'),
}

model CreateImageCacheResponse = {
  headers: map[string]string(name='headers'),
  body: CreateImageCacheResponseBody(name='body'),
}

async function createImageCacheWithOptions(request: CreateImageCacheRequest, runtime: Util.RuntimeOptions): CreateImageCacheResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["SecurityGroupId"] = request.securityGroupId;
  query["VSwitchId"] = request.vSwitchId;
  query["ImageCacheName"] = request.imageCacheName;
  query["EipInstanceId"] = request.eipInstanceId;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["ClientToken"] = request.clientToken;
  query["ImageCacheSize"] = request.imageCacheSize;
  query["RetentionDays"] = request.retentionDays;
  query["AutoMatchImageCache"] = request.autoMatchImageCache;
  query["ImageRegistryCredential"] = request.imageRegistryCredential;
  query["Image"] = request.image;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageCache',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImageCache(request: CreateImageCacheRequest): CreateImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageCacheWithOptions(request, runtime);
}

model DeleteContainerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteContainerGroupResponseBody(name='body'),
}

async function deleteContainerGroupWithOptions(request: DeleteContainerGroupRequest, runtime: Util.RuntimeOptions): DeleteContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContainerGroup(request: DeleteContainerGroupRequest): DeleteContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerGroupWithOptions(request, runtime);
}

model DeleteImageCacheRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  imageCacheId?: string(name='ImageCacheId'),
  clientToken?: string(name='ClientToken'),
}

model DeleteImageCacheResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageCacheResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteImageCacheResponseBody(name='body'),
}

async function deleteImageCacheWithOptions(request: DeleteImageCacheRequest, runtime: Util.RuntimeOptions): DeleteImageCacheResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ImageCacheId"] = request.imageCacheId;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImageCache',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImageCache(request: DeleteImageCacheRequest): DeleteImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageCacheWithOptions(request, runtime);
}

model DescribeContainerGroupMetricRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  period?: string(name='Period'),
}

model DescribeContainerGroupMetricResponseBody = {
  requestId?: string(name='RequestId'),
  containerGroupId?: string(name='ContainerGroupId'),
  records?: [ 
    {
      network?: {
        interfaces?: [ 
          {
            rxErrors?: long(name='RxErrors'),
            txDrops?: long(name='TxDrops'),
            txBytes?: long(name='TxBytes'),
            rxPackets?: long(name='RxPackets'),
            txPackets?: long(name='TxPackets'),
            name?: string(name='Name'),
            txErrors?: long(name='TxErrors'),
            rxBytes?: long(name='RxBytes'),
            rxDrops?: long(name='RxDrops'),
          }
        ](name='Interfaces'),
      }(name='Network'),
      CPU?: {
        usageNanoCores?: long(name='UsageNanoCores'),
        limit?: long(name='Limit'),
        usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
        load?: long(name='Load'),
      }(name='CPU'),
      disk?: [ 
        {
          writeBytes?: long(name='WriteBytes'),
          writeIO?: long(name='WriteIO'),
          device?: string(name='Device'),
          readIO?: long(name='ReadIO'),
          readBytes?: long(name='ReadBytes'),
        }
      ](name='Disk'),
      timestamp?: string(name='Timestamp'),
      memory?: {
        rss?: long(name='Rss'),
        usageBytes?: long(name='UsageBytes'),
        workingSet?: long(name='WorkingSet'),
        availableBytes?: long(name='AvailableBytes'),
        cache?: long(name='Cache'),
      }(name='Memory'),
      filesystem?: [ 
        {
          capacity?: long(name='Capacity'),
          available?: long(name='Available'),
          fsName?: string(name='FsName'),
          usage?: long(name='Usage'),
        }
      ](name='Filesystem'),
      containers?: [ 
        {
          CPU?: {
            usageNanoCores?: long(name='UsageNanoCores'),
            limit?: long(name='Limit'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
            load?: long(name='Load'),
          }(name='CPU'),
          memory?: {
            rss?: long(name='Rss'),
            usageBytes?: long(name='UsageBytes'),
            workingSet?: long(name='WorkingSet'),
            availableBytes?: long(name='AvailableBytes'),
            cache?: long(name='Cache'),
          }(name='Memory'),
          name?: string(name='Name'),
        }
      ](name='Containers'),
    }
  ](name='Records'),
}

model DescribeContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerGroupMetricResponseBody(name='body'),
}

async function describeContainerGroupMetricWithOptions(request: DescribeContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupMetricResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["StartTime"] = request.startTime;
  query["EndTime"] = request.endTime;
  query["Period"] = request.period;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupMetric',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupMetric(request: DescribeContainerGroupMetricRequest): DescribeContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupMetricWithOptions(request, runtime);
}

model DescribeContainerGroupPriceRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
  instanceType?: string(name='InstanceType'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  ephemeralStorage?: int32(name='EphemeralStorage'),
}

model DescribeContainerGroupPriceResponseBody = {
  requestId?: string(name='RequestId'),
  priceInfo?: {
    spotPrices?: {
      spotPrice?: [ 
      {
        zoneId?: string(name='ZoneId'),
        spotPrice?: float(name='SpotPrice'),
        instanceType?: string(name='InstanceType'),
        originPrice?: float(name='OriginPrice'),
      }
    ](name='SpotPrice')
    }(name='SpotPrices'),
    price?: {
      discountPrice?: float(name='DiscountPrice'),
      tradePrice?: float(name='TradePrice'),
      originalPrice?: float(name='OriginalPrice'),
      detailInfos?: {
        detailInfo?: [ 
        {
          resource?: string(name='Resource'),
          discountPrice?: float(name='DiscountPrice'),
          tradePrice?: float(name='TradePrice'),
          originalPrice?: float(name='OriginalPrice'),
          rules?: {
            rule?: [ 
            {
              description?: string(name='Description'),
              ruleId?: long(name='RuleId'),
            }
          ](name='Rule')
          }(name='Rules'),
        }
      ](name='DetailInfo')
      }(name='DetailInfos'),
      currency?: string(name='Currency'),
    }(name='Price'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rule')
    }(name='Rules'),
  }(name='PriceInfo'),
}

model DescribeContainerGroupPriceResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerGroupPriceResponseBody(name='body'),
}

async function describeContainerGroupPriceWithOptions(request: DescribeContainerGroupPriceRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupPriceResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["Cpu"] = request.cpu;
  query["Memory"] = request.memory;
  query["InstanceType"] = request.instanceType;
  query["SpotStrategy"] = request.spotStrategy;
  query["ZoneId"] = request.zoneId;
  query["SpotPriceLimit"] = request.spotPriceLimit;
  query["EphemeralStorage"] = request.ephemeralStorage;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupPrice',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupPrice(request: DescribeContainerGroupPriceRequest): DescribeContainerGroupPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupPriceWithOptions(request, runtime);
}

model DescribeContainerGroupsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  zoneId?: string(name='ZoneId'),
  vSwitchId?: string(name='VSwitchId'),
  nextToken?: string(name='NextToken'),
  limit?: int32(name='Limit'),
  containerGroupIds?: string(name='ContainerGroupIds'),
  containerGroupName?: string(name='ContainerGroupName'),
  status?: string(name='Status'),
  resourceGroupId?: string(name='ResourceGroupId'),
  withEvent?: boolean(name='WithEvent'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeContainerGroupsResponseBody = {
  totalCount?: int32(name='TotalCount'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  containerGroups?: [ 
    {
      status?: string(name='Status'),
      creationTime?: string(name='CreationTime'),
      vpcId?: string(name='VpcId'),
      internetIp?: string(name='InternetIp'),
      tenantSecurityGroupId?: string(name='TenantSecurityGroupId'),
      securityGroupId?: string(name='SecurityGroupId'),
      hostAliases?: [ 
        {
          hostnames?: [ string ](name='Hostnames'),
          ip?: string(name='Ip'),
        }
      ](name='HostAliases'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      events?: [ 
        {
          type?: string(name='Type'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          reason?: string(name='Reason'),
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
        }
      ](name='Events'),
      succeededTime?: string(name='SucceededTime'),
      spotStrategy?: string(name='SpotStrategy'),
      ephemeralStorage?: int32(name='EphemeralStorage'),
      tenantEniInstanceId?: string(name='TenantEniInstanceId'),
      discount?: int32(name='Discount'),
      restartPolicy?: string(name='RestartPolicy'),
      memory?: float(name='Memory'),
      tenantVSwitchId?: string(name='TenantVSwitchId'),
      containers?: [ 
        {
          livenessProbe?: {
            successThreshold?: int32(name='SuccessThreshold'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds'),
            failureThreshold?: int32(name='FailureThreshold'),
            timeoutSeconds?: int32(name='TimeoutSeconds'),
            tcpSocket?: {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }(name='TcpSocket'),
            execs?: [ string ](name='Execs'),
            httpGet?: {
              scheme?: string(name='Scheme'),
              path?: string(name='Path'),
              port?: int32(name='Port'),
            }(name='HttpGet'),
            periodSeconds?: int32(name='PeriodSeconds'),
          }(name='LivenessProbe'),
          commands?: [ string ](name='Commands'),
          volumeMounts?: [ 
            {
              mountPropagation?: string(name='MountPropagation'),
              mountPath?: string(name='MountPath'),
              readOnly?: boolean(name='ReadOnly'),
              name?: string(name='Name'),
            }
          ](name='VolumeMounts'),
          args?: [ string ](name='Args'),
          image?: string(name='Image'),
          ports?: [ 
            {
              protocol?: string(name='Protocol'),
              port?: int32(name='Port'),
            }
          ](name='Ports'),
          restartCount?: int32(name='RestartCount'),
          imagePullPolicy?: string(name='ImagePullPolicy'),
          stdinOnce?: boolean(name='StdinOnce'),
          cpu?: float(name='Cpu'),
          previousState?: {
            startTime?: string(name='StartTime'),
            finishTime?: string(name='FinishTime'),
            detailStatus?: string(name='DetailStatus'),
            state?: string(name='State'),
            message?: string(name='Message'),
            signal?: int32(name='Signal'),
            exitCode?: int32(name='ExitCode'),
            reason?: string(name='Reason'),
          }(name='PreviousState'),
          tty?: boolean(name='Tty'),
          workingDir?: string(name='WorkingDir'),
          currentState?: {
            startTime?: string(name='StartTime'),
            finishTime?: string(name='FinishTime'),
            detailStatus?: string(name='DetailStatus'),
            state?: string(name='State'),
            message?: string(name='Message'),
            signal?: int32(name='Signal'),
            exitCode?: int32(name='ExitCode'),
            reason?: string(name='Reason'),
          }(name='CurrentState'),
          ready?: boolean(name='Ready'),
          gpu?: int32(name='Gpu'),
          securityContext?: {
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser?: long(name='RunAsUser'),
            capability?: {
              adds?: [ string ](name='Adds'),
            }(name='Capability'),
          }(name='SecurityContext'),
          memory?: float(name='Memory'),
          stdin?: boolean(name='Stdin'),
          name?: string(name='Name'),
          environmentVars?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
          readinessProbe?: {
            successThreshold?: int32(name='SuccessThreshold'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds'),
            failureThreshold?: int32(name='FailureThreshold'),
            timeoutSeconds?: int32(name='TimeoutSeconds'),
            tcpSocket?: {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }(name='TcpSocket'),
            execs?: [ string ](name='Execs'),
            httpGet?: {
              scheme?: string(name='Scheme'),
              path?: string(name='Path'),
              port?: int32(name='Port'),
            }(name='HttpGet'),
            periodSeconds?: int32(name='PeriodSeconds'),
          }(name='ReadinessProbe'),
        }
      ](name='Containers'),
      eniInstanceId?: string(name='EniInstanceId'),
      initContainers?: [ 
        {
          volumeMounts?: [ 
            {
              mountPropagation?: string(name='MountPropagation'),
              mountPath?: string(name='MountPath'),
              readOnly?: boolean(name='ReadOnly'),
              name?: string(name='Name'),
            }
          ](name='VolumeMounts'),
          args?: [ string ](name='Args'),
          image?: string(name='Image'),
          ports?: [ 
            {
              protocol?: string(name='Protocol'),
              port?: int32(name='Port'),
            }
          ](name='Ports'),
          restartCount?: int32(name='RestartCount'),
          imagePullPolicy?: string(name='ImagePullPolicy'),
          previousState?: {
            startTime?: string(name='StartTime'),
            finishTime?: string(name='FinishTime'),
            detailStatus?: string(name='DetailStatus'),
            state?: string(name='State'),
            message?: string(name='Message'),
            signal?: int32(name='Signal'),
            exitCode?: int32(name='ExitCode'),
            reason?: string(name='Reason'),
          }(name='PreviousState'),
          workingDir?: string(name='WorkingDir'),
          cpu?: float(name='Cpu'),
          currentState?: {
            startTime?: string(name='StartTime'),
            finishTime?: string(name='FinishTime'),
            detailStatus?: string(name='DetailStatus'),
            state?: string(name='State'),
            message?: string(name='Message'),
            signal?: int32(name='Signal'),
            exitCode?: int32(name='ExitCode'),
            reason?: string(name='Reason'),
          }(name='CurrentState'),
          command?: [ string ](name='Command'),
          ready?: boolean(name='Ready'),
          gpu?: int32(name='Gpu'),
          securityContext?: {
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser?: long(name='RunAsUser'),
            capability?: {
              adds?: [ string ](name='Adds'),
            }(name='Capability'),
          }(name='SecurityContext'),
          memory?: float(name='Memory'),
          name?: string(name='Name'),
          environmentVars?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
        }
      ](name='InitContainers'),
      containerGroupId?: string(name='ContainerGroupId'),
      tenantEniIp?: string(name='TenantEniIp'),
      instanceType?: string(name='InstanceType'),
      intranetIp?: string(name='IntranetIp'),
      ipv6Address?: string(name='Ipv6Address'),
      regionId?: string(name='RegionId'),
      dnsConfig?: {
        searches?: [ string ](name='Searches'),
        options?: [ 
          {
            value?: string(name='Value'),
            name?: string(name='Name'),
          }
        ](name='Options'),
        nameServers?: [ string ](name='NameServers'),
      }(name='DnsConfig'),
      volumes?: [ 
        {
          type?: string(name='Type'),
          diskVolumeDiskId?: string(name='DiskVolumeDiskId'),
          NFSVolumeReadOnly?: boolean(name='NFSVolumeReadOnly'),
          configFileVolumeConfigFileToPaths?: [ 
            {
              path?: string(name='Path'),
              content?: string(name='Content'),
            }
          ](name='ConfigFileVolumeConfigFileToPaths'),
          flexVolumeFsType?: string(name='FlexVolumeFsType'),
          flexVolumeDriver?: string(name='FlexVolumeDriver'),
          diskVolumeFsType?: string(name='DiskVolumeFsType'),
          flexVolumeOptions?: string(name='FlexVolumeOptions'),
          NFSVolumeServer?: string(name='NFSVolumeServer'),
          NFSVolumePath?: string(name='NFSVolumePath'),
          name?: string(name='Name'),
        }
      ](name='Volumes'),
      ramRoleName?: string(name='RamRoleName'),
      vSwitchId?: string(name='VSwitchId'),
      cpu?: float(name='Cpu'),
      expiredTime?: string(name='ExpiredTime'),
      resourceGroupId?: string(name='ResourceGroupId'),
      zoneId?: string(name='ZoneId'),
      containerGroupName?: string(name='ContainerGroupName'),
      eciSecurityContext?: {
        sysctls?: [ 
          {
            value?: string(name='Value'),
            name?: string(name='Name'),
          }
        ](name='Sysctls'),
      }(name='EciSecurityContext'),
      failedTime?: string(name='FailedTime'),
    }
  ](name='ContainerGroups'),
}

model DescribeContainerGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerGroupsResponseBody(name='body'),
}

async function describeContainerGroupsWithOptions(request: DescribeContainerGroupsRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ZoneId"] = request.zoneId;
  query["VSwitchId"] = request.vSwitchId;
  query["NextToken"] = request.nextToken;
  query["Limit"] = request.limit;
  query["ContainerGroupIds"] = request.containerGroupIds;
  query["ContainerGroupName"] = request.containerGroupName;
  query["Status"] = request.status;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["WithEvent"] = request.withEvent;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroups',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroups(request: DescribeContainerGroupsRequest): DescribeContainerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupsWithOptions(request, runtime);
}

model DescribeContainerLogRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  containerName?: string(name='ContainerName'),
  startTime?: string(name='StartTime'),
  tail?: int32(name='Tail'),
  lastTime?: boolean(name='LastTime'),
  sinceSeconds?: int32(name='SinceSeconds'),
  limitBytes?: long(name='LimitBytes'),
  timestamps?: boolean(name='Timestamps'),
}

model DescribeContainerLogResponseBody = {
  requestId?: string(name='RequestId'),
  containerName?: string(name='ContainerName'),
  content?: string(name='Content'),
}

model DescribeContainerLogResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeContainerLogResponseBody(name='body'),
}

async function describeContainerLogWithOptions(request: DescribeContainerLogRequest, runtime: Util.RuntimeOptions): DescribeContainerLogResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["ContainerName"] = request.containerName;
  query["StartTime"] = request.startTime;
  query["Tail"] = request.tail;
  query["LastTime"] = request.lastTime;
  query["SinceSeconds"] = request.sinceSeconds;
  query["LimitBytes"] = request.limitBytes;
  query["Timestamps"] = request.timestamps;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerLog',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerLog(request: DescribeContainerLogRequest): DescribeContainerLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerLogWithOptions(request, runtime);
}

model DescribeImageCachesRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  imageCacheId?: string(name='ImageCacheId'),
  imageCacheName?: string(name='ImageCacheName'),
  snapshotId?: string(name='SnapshotId'),
  image?: string(name='Image'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeImageCachesResponseBody = {
  requestId?: string(name='RequestId'),
  imageCaches?: [ 
    {
      images?: [ string ](name='Images'),
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      progress?: string(name='Progress'),
      expireDateTime?: string(name='ExpireDateTime'),
      containerGroupId?: string(name='ContainerGroupId'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      events?: [ 
        {
          type?: string(name='Type'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
        }
      ](name='Events'),
      imageCacheId?: string(name='ImageCacheId'),
      regionId?: string(name='RegionId'),
      snapshotId?: string(name='SnapshotId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      imageCacheSize?: int32(name='ImageCacheSize'),
      imageCacheName?: string(name='ImageCacheName'),
    }
  ](name='ImageCaches'),
}

model DescribeImageCachesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeImageCachesResponseBody(name='body'),
}

async function describeImageCachesWithOptions(request: DescribeImageCachesRequest, runtime: Util.RuntimeOptions): DescribeImageCachesResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ImageCacheId"] = request.imageCacheId;
  query["ImageCacheName"] = request.imageCacheName;
  query["SnapshotId"] = request.snapshotId;
  query["Image"] = request.image;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Tag"] = request.tag;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCaches',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageCaches(request: DescribeImageCachesRequest): DescribeImageCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCachesWithOptions(request, runtime);
}

model DescribeMultiContainerGroupMetricRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupIds?: string(name='ContainerGroupIds'),
  resourceGroupId?: string(name='ResourceGroupId'),
  metricType?: string(name='MetricType'),
}

model DescribeMultiContainerGroupMetricResponseBody = {
  requestId?: string(name='RequestId'),
  monitorDatas?: [ 
    {
      records?: [ 
        {
          network?: {
            interfaces?: [ 
              {
                rxErrors?: long(name='RxErrors'),
                txDrops?: long(name='TxDrops'),
                txBytes?: long(name='TxBytes'),
                rxPackets?: long(name='RxPackets'),
                txPackets?: long(name='TxPackets'),
                name?: string(name='Name'),
                txErrors?: long(name='TxErrors'),
                rxBytes?: long(name='RxBytes'),
                rxDrops?: long(name='RxDrops'),
              }
            ](name='Interfaces'),
          }(name='Network'),
          CPU?: {
            usageNanoCores?: long(name='UsageNanoCores'),
            limit?: long(name='Limit'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
            load?: long(name='Load'),
          }(name='CPU'),
          disk?: [ 
            {
              writeBytes?: long(name='WriteBytes'),
              device?: string(name='Device'),
              writeIo?: long(name='WriteIo'),
              readBytes?: long(name='ReadBytes'),
              readIo?: long(name='ReadIo'),
            }
          ](name='Disk'),
          timestamp?: string(name='Timestamp'),
          memory?: {
            rss?: long(name='Rss'),
            usageBytes?: long(name='UsageBytes'),
            workingSet?: long(name='WorkingSet'),
            availableBytes?: long(name='AvailableBytes'),
            cache?: long(name='Cache'),
          }(name='Memory'),
          containers?: [ 
            {
              CPU?: {
                usageNanoCores?: long(name='UsageNanoCores'),
                limit?: long(name='Limit'),
                usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
                load?: long(name='Load'),
              }(name='CPU'),
              memory?: {
                rss?: long(name='Rss'),
                usageBytes?: long(name='UsageBytes'),
                workingSet?: long(name='WorkingSet'),
                availableBytes?: long(name='AvailableBytes'),
                cache?: long(name='Cache'),
              }(name='Memory'),
              name?: string(name='Name'),
            }
          ](name='Containers'),
          filesystem?: [ 
            {
              capacity?: long(name='Capacity'),
              available?: long(name='Available'),
              fsName?: string(name='FsName'),
              usage?: long(name='Usage'),
            }
          ](name='Filesystem'),
        }
      ](name='Records'),
      containerInfos?: [ 
        {
          aliases?: [ string ](name='Aliases'),
          containerSpec?: {
            creationTime?: string(name='CreationTime'),
            image?: string(name='Image'),
            labels?: string(name='Labels'),
            hasCustomMetrics?: boolean(name='HasCustomMetrics'),
            hasCpu?: boolean(name='HasCpu'),
            envs?: string(name='Envs'),
            hasDiskIo?: boolean(name='HasDiskIo'),
            hasFilesystem?: boolean(name='HasFilesystem'),
            hasNetwork?: boolean(name='HasNetwork'),
            containerMemory?: {
              limit?: long(name='Limit'),
              swapLimit?: long(name='SwapLimit'),
              reservation?: long(name='Reservation'),
            }(name='ContainerMemory'),
            hasMemory?: boolean(name='HasMemory'),
            containerCpu?: {
              quota?: long(name='Quota'),
              mask?: string(name='Mask'),
              limit?: long(name='Limit'),
              maxLimit?: long(name='MaxLimit'),
              period?: long(name='Period'),
            }(name='ContainerCpu'),
          }(name='ContainerSpec'),
          containerStats?: [ 
            {
              networkStats?: {
                rxDropped?: long(name='RxDropped'),
                tcp?: {
                  closeWait?: long(name='CloseWait'),
                  finWait2?: long(name='FinWait2'),
                  lastAck?: long(name='LastAck'),
                  closing?: long(name='Closing'),
                  listen?: long(name='Listen'),
                  timeWait?: long(name='TimeWait'),
                  established?: long(name='Established'),
                  finWait1?: long(name='FinWait1'),
                  close?: long(name='Close'),
                  synRecv?: long(name='SynRecv'),
                  synSent?: long(name='SynSent'),
                }(name='Tcp'),
                txErrors?: long(name='TxErrors'),
                rxErrors?: long(name='RxErrors'),
                interfaceStats?: [ 
                  {
                    rxErrors?: long(name='RxErrors'),
                    rxDropped?: long(name='RxDropped'),
                    txDropped?: long(name='TxDropped'),
                    txBytes?: long(name='TxBytes'),
                    rxPackets?: long(name='RxPackets'),
                    txErrors?: long(name='TxErrors'),
                    txPackets?: long(name='TxPackets'),
                    rxBytes?: long(name='RxBytes'),
                    name?: string(name='Name'),
                  }
                ](name='InterfaceStats'),
                tcp6?: {
                  closeWait?: long(name='CloseWait'),
                  finWait2?: long(name='FinWait2'),
                  lastAck?: long(name='LastAck'),
                  closing?: long(name='Closing'),
                  listen?: long(name='Listen'),
                  timeWait?: long(name='TimeWait'),
                  established?: long(name='Established'),
                  finWait1?: long(name='FinWait1'),
                  close?: long(name='Close'),
                  synRecv?: long(name='SynRecv'),
                  synSent?: long(name='SynSent'),
                }(name='Tcp6'),
                txDropped?: long(name='TxDropped'),
                udp?: {
                  txQueued?: long(name='TxQueued'),
                  listen?: long(name='Listen'),
                  dropped?: long(name='Dropped'),
                  rxQueued?: long(name='RxQueued'),
                }(name='Udp'),
                txBytes?: long(name='TxBytes'),
                udp6?: {
                  txQueued?: long(name='TxQueued'),
                  listen?: long(name='Listen'),
                  dropped?: long(name='Dropped'),
                  rxQueued?: long(name='RxQueued'),
                }(name='Udp6'),
                rxPackets?: long(name='RxPackets'),
                name?: string(name='Name'),
                rxBytes?: long(name='RxBytes'),
                txPackets?: long(name='TxPackets'),
              }(name='NetworkStats'),
              fsStats?: [ 
                {
                  type?: string(name='Type'),
                  readsMerged?: long(name='ReadsMerged'),
                  hasInodes?: boolean(name='HasInodes'),
                  readsCompleted?: long(name='ReadsCompleted'),
                  writesMerged?: long(name='WritesMerged'),
                  inodesFree?: long(name='InodesFree'),
                  available?: long(name='Available'),
                  usage?: long(name='Usage'),
                  inodes?: long(name='Inodes'),
                  baseUsage?: long(name='BaseUsage'),
                  sectorsRead?: long(name='SectorsRead'),
                  writeTime?: long(name='WriteTime'),
                  sectorsWritten?: long(name='SectorsWritten'),
                  readTime?: long(name='ReadTime'),
                  limit?: long(name='Limit'),
                  device?: string(name='Device'),
                  writesCompleted?: long(name='WritesCompleted'),
                  ioTime?: long(name='IoTime'),
                  weightedIoTime?: long(name='WeightedIoTime'),
                  ioInProgress?: long(name='IoInProgress'),
                }
              ](name='FsStats'),
              acceleratorStats?: [ 
                {
                  model?: string(name='Model'),
                  minor?: long(name='Minor'),
                  temperature?: long(name='Temperature'),
                  powerUsage?: long(name='PowerUsage'),
                  memoryTotal?: long(name='MemoryTotal'),
                  make?: string(name='Make'),
                  dutyCycle?: long(name='DutyCycle'),
                  memoryUsed?: long(name='MemoryUsed'),
                  id?: string(name='Id'),
                }
              ](name='AcceleratorStats'),
              cpuStats?: {
                cpuUsage?: {
                  user?: long(name='User'),
                  perCpuUsages?: [ long ](name='PerCpuUsages'),
                  total?: long(name='Total'),
                  system?: long(name='System'),
                }(name='CpuUsage'),
                loadAverage?: long(name='LoadAverage'),
                cpuCFS?: {
                  throttledTime?: long(name='ThrottledTime'),
                  periods?: long(name='Periods'),
                  throttledPeriods?: long(name='ThrottledPeriods'),
                }(name='CpuCFS'),
              }(name='CpuStats'),
              timestamp?: string(name='Timestamp'),
              memoryStats?: {
                failCnt?: long(name='FailCnt'),
                maxUsage?: long(name='MaxUsage'),
                hierarchicalData?: {
                  pgmajFault?: long(name='PgmajFault'),
                  pgFault?: long(name='PgFault'),
                }(name='HierarchicalData'),
                rss?: long(name='Rss'),
                containerData?: {
                  pgmajFault?: long(name='PgmajFault'),
                  pgFault?: long(name='PgFault'),
                }(name='ContainerData'),
                workingSet?: long(name='WorkingSet'),
                swap?: long(name='Swap'),
                cache?: long(name='Cache'),
                usage?: long(name='Usage'),
              }(name='MemoryStats'),
              taskStats?: {
                nrUninterruptible?: long(name='NrUninterruptible'),
                nrRunning?: long(name='NrRunning'),
                nrSleeping?: long(name='NrSleeping'),
                nrIoWait?: long(name='NrIoWait'),
                nrStopped?: long(name='NrStopped'),
              }(name='TaskStats'),
              diskIoStats?: {
                ioServiced?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoServiced'),
                ioServiceTime?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoServiceTime'),
                ioServiceBytes?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoServiceBytes'),
                ioMerged?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoMerged'),
                sectors?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='Sectors'),
                ioQueued?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoQueued'),
                ioTime?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoTime'),
                ioWaitTime?: [ 
                  {
                    stats?: string(name='Stats'),
                    minor?: long(name='Minor'),
                    major?: long(name='Major'),
                    device?: string(name='Device'),
                  }
                ](name='IoWaitTime'),
              }(name='DiskIoStats'),
            }
          ](name='ContainerStats'),
          labels?: string(name='Labels'),
          namespace?: string(name='Namespace'),
          name?: string(name='Name'),
          id?: string(name='Id'),
        }
      ](name='ContainerInfos'),
      containerGroupId?: string(name='ContainerGroupId'),
    }
  ](name='MonitorDatas'),
}

model DescribeMultiContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeMultiContainerGroupMetricResponseBody(name='body'),
}

async function describeMultiContainerGroupMetricWithOptions(request: DescribeMultiContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeMultiContainerGroupMetricResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupIds"] = request.containerGroupIds;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["MetricType"] = request.metricType;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiContainerGroupMetric',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiContainerGroupMetric(request: DescribeMultiContainerGroupMetricRequest): DescribeMultiContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiContainerGroupMetricWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
}

model DescribeRegionsResponseBody = {
  requestId?: string(name='RequestId'),
  regions?: [ 
    {
      zones?: [ string ](name='Zones'),
      recommendZones?: [ string ](name='RecommendZones'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
    }
  ](name='Regions'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model ExecContainerCommandRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  containerName?: string(name='ContainerName'),
  command?: string(name='Command'),
  TTY?: boolean(name='TTY'),
  stdin?: boolean(name='Stdin'),
}

model ExecContainerCommandResponseBody = {
  requestId?: string(name='RequestId'),
  webSocketUri?: string(name='WebSocketUri'),
  httpUrl?: string(name='HttpUrl'),
}

model ExecContainerCommandResponse = {
  headers: map[string]string(name='headers'),
  body: ExecContainerCommandResponseBody(name='body'),
}

async function execContainerCommandWithOptions(request: ExecContainerCommandRequest, runtime: Util.RuntimeOptions): ExecContainerCommandResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["ContainerName"] = request.containerName;
  query["Command"] = request.command;
  query["TTY"] = request.TTY;
  query["Stdin"] = request.stdin;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ExecContainerCommand',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function execContainerCommand(request: ExecContainerCommandRequest): ExecContainerCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return execContainerCommandWithOptions(request, runtime);
}

model ListUsageRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
}

model ListUsageResponseBody = {
  requestId?: string(name='RequestId'),
  attributes?: map[string]any(name='Attributes'),
}

model ListUsageResponse = {
  headers: map[string]string(name='headers'),
  body: ListUsageResponseBody(name='body'),
}

async function listUsageWithOptions(request: ListUsageRequest, runtime: Util.RuntimeOptions): ListUsageResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'ListUsage',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsage(request: ListUsageRequest): ListUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsageWithOptions(request, runtime);
}

model RestartContainerGroupRequest {
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  clientToken?: string(name='ClientToken'),
}

model RestartContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: RestartContainerGroupResponseBody(name='body'),
}

async function restartContainerGroupWithOptions(request: RestartContainerGroupRequest, runtime: Util.RuntimeOptions): RestartContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["ClientToken"] = request.clientToken;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'RestartContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartContainerGroup(request: RestartContainerGroupRequest): RestartContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartContainerGroupWithOptions(request, runtime);
}

model UpdateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    search?: [ string ](name='Search'),
    option?: [ 
      {
        value?: string(name='Value'),
        name?: string(name='Name'),
      }
    ](name='Option'),
  }(name='DnsConfig'),
  ownerId?: long(name='OwnerId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  ownerAccount?: string(name='OwnerAccount'),
  regionId?: string(name='RegionId'),
  containerGroupId?: string(name='ContainerGroupId'),
  restartPolicy?: string(name='RestartPolicy'),
  clientToken?: string(name='ClientToken'),
  cpu?: float(name='Cpu'),
  memory?: float(name='Memory'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  volume?: [ 
    {
      NFSVolume: {
        path?: string(name='Path'),
        server?: string(name='Server'),
        readOnly?: boolean(name='ReadOnly'),
      }(name='NFSVolume'),
      configFileVolume: {
        configFileToPath?: [ 
          {
            path?: string(name='Path'),
            content?: string(name='Content'),
          }
        ](name='ConfigFileToPath'),
      }(name='ConfigFileVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
      }(name='EmptyDirVolume'),
      type?: string(name='Type'),
      name?: string(name='Name'),
    }
  ](name='Volume'),
  container?: [ 
    {
      readinessProbe: {
        timeoutSeconds?: int32(name='TimeoutSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        httpGet: {
            scheme?: string(name='Scheme'),
            path?: string(name='Path'),
            port?: int32(name='Port'),
        }(name='HttpGet'),
        periodSeconds?: int32(name='PeriodSeconds'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      livenessProbe: {
        periodSeconds?: int32(name='PeriodSeconds'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        httpGet: {
            scheme?: string(name='Scheme'),
            port?: int32(name='Port'),
            path?: string(name='Path'),
        }(name='HttpGet'),
        failureThreshold?: int32(name='FailureThreshold'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      tty?: boolean(name='Tty'),
      workingDir?: string(name='WorkingDir'),
      arg?: [ string ](name='Arg'),
      stdin?: boolean(name='Stdin'),
      volumeMount?: [ 
        {
          mountPropagation?: string(name='MountPropagation'),
          mountPath?: string(name='MountPath'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
          name?: string(name='Name'),
        }
      ](name='VolumeMount'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      stdinOnce?: boolean(name='StdinOnce'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme'),
      command?: [ string ](name='Command'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath'),
      port?: [ 
        {
          protocol?: string(name='Protocol'),
          port?: int32(name='Port'),
        }
      ](name='Port'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme'),
      lifecyclePostStartHandlerHttpGetHttpHeaders?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeaders'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost'),
      gpu?: int32(name='Gpu'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost'),
      image?: string(name='Image'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          value?: string(name='Value'),
          name?: string(name='Name'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader'),
      cpu?: float(name='Cpu'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort'),
    }
  ](name='Container'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      image?: string(name='Image'),
      volumeMount?: [ 
        {
          mountPropagation?: string(name='MountPropagation'),
          mountPath?: string(name='MountPath'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
          name?: string(name='Name'),
        }
      ](name='VolumeMount'),
      port?: [ 
        {
          protocol?: string(name='Protocol'),
          port?: int32(name='Port'),
        }
      ](name='Port'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      stdinOnce?: boolean(name='StdinOnce'),
      cpu?: float(name='Cpu'),
      tty?: boolean(name='Tty'),
      workingDir?: string(name='WorkingDir'),
      command?: [ string ](name='Command'),
      arg?: [ string ](name='Arg'),
      gpu?: int32(name='Gpu'),
      memory?: float(name='Memory'),
      stdin?: boolean(name='Stdin'),
      name?: string(name='Name'),
    }
  ](name='InitContainer'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
}

model UpdateContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateContainerGroupResponseBody(name='body'),
}

async function updateContainerGroupWithOptions(request: UpdateContainerGroupRequest, runtime: Util.RuntimeOptions): UpdateContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  query["OwnerId"] = request.ownerId;
  query["ResourceOwnerAccount"] = request.resourceOwnerAccount;
  query["ResourceOwnerId"] = request.resourceOwnerId;
  query["OwnerAccount"] = request.ownerAccount;
  query["RegionId"] = request.regionId;
  query["RegionId"] = request.regionId;
  query["ContainerGroupId"] = request.containerGroupId;
  query["RestartPolicy"] = request.restartPolicy;
  query["ClientToken"] = request.clientToken;
  query["Cpu"] = request.cpu;
  query["Memory"] = request.memory;
  query["ResourceGroupId"] = request.resourceGroupId;
  query["Tag"] = request.tag;
  query["Volume"] = request.volume;
  query["Container"] = request.container;
  query["InitContainer"] = request.initContainer;
  query["ImageRegistryCredential"] = request.imageRegistryCredential;
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = Util.toMap(request),
  };
  var params = new OpenApi.Params{
    action = 'UpdateContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'json',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateContainerGroup(request: UpdateContainerGroupRequest): UpdateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerGroupWithOptions(request, runtime);
}

