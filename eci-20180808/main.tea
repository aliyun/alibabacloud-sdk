/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('eci', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model CreateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    option?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Option'),
    search?: [ string ](name='Search'),
  }(name='DnsConfig'),
  hostSecurityContext?: {
    sysctl?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Sysctl'),
  }(name='HostSecurityContext'),
  securityContext?: {
    sysctl?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Sysctl'),
  }(name='SecurityContext'),
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='AcrRegistryInfo'),
  activeDeadlineSeconds?: long(name='ActiveDeadlineSeconds'),
  arn?: [ 
    {
      assumeRoleFor?: string(name='AssumeRoleFor'),
      roleArn?: string(name='RoleArn'),
      roleType?: string(name='RoleType'),
    }
  ](name='Arn'),
  autoCreateEip?: boolean(name='AutoCreateEip'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  clientToken?: string(name='ClientToken'),
  container?: [ 
    {
      livenessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg'),
      command?: [ string ](name='Command'),
      cpu?: float(name='Cpu'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      gpu?: int32(name='Gpu'),
      image?: string(name='Image'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost'),
      lifecyclePostStartHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeader'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      port?: [ 
        {
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='Port'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
      tty?: boolean(name='Tty'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath'),
          mountPropagation?: string(name='MountPropagation'),
          name?: string(name='Name'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='Container'),
  containerGroupName?: string(name='ContainerGroupName'),
  corePattern?: string(name='CorePattern'),
  cpu?: float(name='Cpu'),
  cpuOptionsCore?: int32(name='CpuOptionsCore'),
  cpuOptionsNuma?: string(name='CpuOptionsNuma'),
  cpuOptionsThreadsPerCore?: int32(name='CpuOptionsThreadsPerCore'),
  dnsPolicy?: string(name='DnsPolicy'),
  egressBandwidth?: long(name='EgressBandwidth'),
  eipBandwidth?: int32(name='EipBandwidth'),
  eipCommonBandwidthPackage?: string(name='EipCommonBandwidthPackage'),
  eipISP?: string(name='EipISP'),
  eipInstanceId?: string(name='EipInstanceId'),
  ephemeralStorage?: int32(name='EphemeralStorage'),
  hostAliase?: [ 
    {
      hostname?: [ string ](name='Hostname'),
      ip?: string(name='Ip'),
    }
  ](name='HostAliase'),
  hostName?: string(name='HostName'),
  imageAccelerateMode?: string(name='ImageAccelerateMode'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  imageSnapshotId?: string(name='ImageSnapshotId'),
  ingressBandwidth?: long(name='IngressBandwidth'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg'),
      command?: [ string ](name='Command'),
      cpu?: float(name='Cpu'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      gpu?: int32(name='Gpu'),
      image?: string(name='Image'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      port?: [ 
        {
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='Port'),
      terminationMessagePath?: string(name='TerminationMessagePath'),
      terminationMessagePolicy?: string(name='TerminationMessagePolicy'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath'),
          mountPropagation?: string(name='MountPropagation'),
          name?: string(name='Name'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='InitContainer'),
  insecureRegistry?: string(name='InsecureRegistry'),
  instanceType?: string(name='InstanceType'),
  ipv6AddressCount?: int32(name='Ipv6AddressCount'),
  ipv6GatewayBandwidth?: string(name='Ipv6GatewayBandwidth'),
  ipv6GatewayBandwidthEnable?: boolean(name='Ipv6GatewayBandwidthEnable'),
  memory?: float(name='Memory'),
  ntpServer?: [ string ](name='NtpServer'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plainHttpRegistry?: string(name='PlainHttpRegistry'),
  productOnEciMode?: string(name='ProductOnEciMode'),
  ramRoleName?: string(name='RamRoleName'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restartPolicy?: string(name='RestartPolicy'),
  scheduleStrategy?: string(name='ScheduleStrategy'),
  secondaryENIPolicy?: string(name='SecondaryENIPolicy'),
  securityGroupId?: string(name='SecurityGroupId'),
  shareProcessNamespace?: boolean(name='ShareProcessNamespace'),
  slsEnable?: boolean(name='SlsEnable'),
  spotDuration?: long(name='SpotDuration'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
  strictSpot?: boolean(name='StrictSpot'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  tenantSecurityGroupId?: string(name='TenantSecurityGroupId'),
  tenantVSwitchId?: string(name='TenantVSwitchId'),
  terminationGracePeriodSeconds?: long(name='TerminationGracePeriodSeconds'),
  vSwitchId?: string(name='VSwitchId'),
  volume?: [ 
    {
      configFileVolume: {
        configFileToPath?: [ 
          {
            content?: string(name='Content'),
            mode?: int32(name='Mode'),
            path?: string(name='Path'),
          }
        ](name='ConfigFileToPath'),
        defaultMode?: int32(name='DefaultMode'),
      }(name='ConfigFileVolume'),
      diskVolume: {
        diskId?: string(name='DiskId'),
        diskSize?: int32(name='DiskSize'),
        fsType?: string(name='FsType'),
      }(name='DiskVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
        sizeLimit?: string(name='SizeLimit'),
      }(name='EmptyDirVolume'),
      flexVolume: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Volume'),
  zoneId?: string(name='ZoneId'),
}

model CreateContainerGroupResponseBody = {
  containerGroupId?: string(name='ContainerGroupId'),
  requestId?: string(name='RequestId'),
}

model CreateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateContainerGroupResponseBody(name='body'),
}

async function createContainerGroupWithOptions(request: CreateContainerGroupRequest, runtime: Util.RuntimeOptions): CreateContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acrRegistryInfo)) {
    query['AcrRegistryInfo'] = request.acrRegistryInfo;
  }
  if (!Util.isUnset(request.activeDeadlineSeconds)) {
    query['ActiveDeadlineSeconds'] = request.activeDeadlineSeconds;
  }
  if (!Util.isUnset(request.arn)) {
    query['Arn'] = request.arn;
  }
  if (!Util.isUnset(request.autoCreateEip)) {
    query['AutoCreateEip'] = request.autoCreateEip;
  }
  if (!Util.isUnset(request.autoMatchImageCache)) {
    query['AutoMatchImageCache'] = request.autoMatchImageCache;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.containerGroupName)) {
    query['ContainerGroupName'] = request.containerGroupName;
  }
  if (!Util.isUnset(request.corePattern)) {
    query['CorePattern'] = request.corePattern;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.cpuOptionsCore)) {
    query['CpuOptionsCore'] = request.cpuOptionsCore;
  }
  if (!Util.isUnset(request.cpuOptionsNuma)) {
    query['CpuOptionsNuma'] = request.cpuOptionsNuma;
  }
  if (!Util.isUnset(request.cpuOptionsThreadsPerCore)) {
    query['CpuOptionsThreadsPerCore'] = request.cpuOptionsThreadsPerCore;
  }
  if (!Util.isUnset(request.dnsPolicy)) {
    query['DnsPolicy'] = request.dnsPolicy;
  }
  if (!Util.isUnset(request.egressBandwidth)) {
    query['EgressBandwidth'] = request.egressBandwidth;
  }
  if (!Util.isUnset(request.eipBandwidth)) {
    query['EipBandwidth'] = request.eipBandwidth;
  }
  if (!Util.isUnset(request.eipCommonBandwidthPackage)) {
    query['EipCommonBandwidthPackage'] = request.eipCommonBandwidthPackage;
  }
  if (!Util.isUnset(request.eipISP)) {
    query['EipISP'] = request.eipISP;
  }
  if (!Util.isUnset(request.eipInstanceId)) {
    query['EipInstanceId'] = request.eipInstanceId;
  }
  if (!Util.isUnset(request.ephemeralStorage)) {
    query['EphemeralStorage'] = request.ephemeralStorage;
  }
  if (!Util.isUnset(request.hostAliase)) {
    query['HostAliase'] = request.hostAliase;
  }
  if (!Util.isUnset(request.hostName)) {
    query['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.imageAccelerateMode)) {
    query['ImageAccelerateMode'] = request.imageAccelerateMode;
  }
  if (!Util.isUnset(request.imageRegistryCredential)) {
    query['ImageRegistryCredential'] = request.imageRegistryCredential;
  }
  if (!Util.isUnset(request.imageSnapshotId)) {
    query['ImageSnapshotId'] = request.imageSnapshotId;
  }
  if (!Util.isUnset(request.ingressBandwidth)) {
    query['IngressBandwidth'] = request.ingressBandwidth;
  }
  if (!Util.isUnset(request.initContainer)) {
    query['InitContainer'] = request.initContainer;
  }
  if (!Util.isUnset(request.insecureRegistry)) {
    query['InsecureRegistry'] = request.insecureRegistry;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.ipv6AddressCount)) {
    query['Ipv6AddressCount'] = request.ipv6AddressCount;
  }
  if (!Util.isUnset(request.ipv6GatewayBandwidth)) {
    query['Ipv6GatewayBandwidth'] = request.ipv6GatewayBandwidth;
  }
  if (!Util.isUnset(request.ipv6GatewayBandwidthEnable)) {
    query['Ipv6GatewayBandwidthEnable'] = request.ipv6GatewayBandwidthEnable;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ntpServer)) {
    query['NtpServer'] = request.ntpServer;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plainHttpRegistry)) {
    query['PlainHttpRegistry'] = request.plainHttpRegistry;
  }
  if (!Util.isUnset(request.productOnEciMode)) {
    query['ProductOnEciMode'] = request.productOnEciMode;
  }
  if (!Util.isUnset(request.ramRoleName)) {
    query['RamRoleName'] = request.ramRoleName;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restartPolicy)) {
    query['RestartPolicy'] = request.restartPolicy;
  }
  if (!Util.isUnset(request.scheduleStrategy)) {
    query['ScheduleStrategy'] = request.scheduleStrategy;
  }
  if (!Util.isUnset(request.secondaryENIPolicy)) {
    query['SecondaryENIPolicy'] = request.secondaryENIPolicy;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.shareProcessNamespace)) {
    query['ShareProcessNamespace'] = request.shareProcessNamespace;
  }
  if (!Util.isUnset(request.slsEnable)) {
    query['SlsEnable'] = request.slsEnable;
  }
  if (!Util.isUnset(request.spotDuration)) {
    query['SpotDuration'] = request.spotDuration;
  }
  if (!Util.isUnset(request.spotPriceLimit)) {
    query['SpotPriceLimit'] = request.spotPriceLimit;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.strictSpot)) {
    query['StrictSpot'] = request.strictSpot;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.tenantSecurityGroupId)) {
    query['TenantSecurityGroupId'] = request.tenantSecurityGroupId;
  }
  if (!Util.isUnset(request.tenantVSwitchId)) {
    query['TenantVSwitchId'] = request.tenantVSwitchId;
  }
  if (!Util.isUnset(request.terminationGracePeriodSeconds)) {
    query['TerminationGracePeriodSeconds'] = request.terminationGracePeriodSeconds;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.volume)) {
    query['Volume'] = request.volume;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  if (!Util.isUnset(request.dnsConfig)) {
    query['DnsConfig'] = request.dnsConfig;
  }
  if (!Util.isUnset(request.hostSecurityContext)) {
    query['HostSecurityContext'] = request.hostSecurityContext;
  }
  if (!Util.isUnset(request.securityContext)) {
    query['SecurityContext'] = request.securityContext;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createContainerGroup(request: CreateContainerGroupRequest): CreateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createContainerGroupWithOptions(request, runtime);
}

model CreateImageCacheRequest {
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='AcrRegistryInfo'),
  annotations?: string(name='Annotations'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  clientToken?: string(name='ClientToken'),
  eipInstanceId?: string(name='EipInstanceId'),
  eliminationStrategy?: string(name='EliminationStrategy'),
  flash?: boolean(name='Flash'),
  flashCopyCount?: int32(name='FlashCopyCount'),
  image?: [ string ](name='Image'),
  imageCacheName?: string(name='ImageCacheName'),
  imageCacheSize?: int32(name='ImageCacheSize'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  insecureRegistry?: string(name='InsecureRegistry'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  plainHttpRegistry?: string(name='PlainHttpRegistry'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retentionDays?: int32(name='RetentionDays'),
  securityGroupId?: string(name='SecurityGroupId'),
  standardCopyCount?: int32(name='StandardCopyCount'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model CreateImageCacheResponseBody = {
  containerGroupId?: string(name='ContainerGroupId'),
  imageCacheId?: string(name='ImageCacheId'),
  requestId?: string(name='RequestId'),
}

model CreateImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateImageCacheResponseBody(name='body'),
}

async function createImageCacheWithOptions(request: CreateImageCacheRequest, runtime: Util.RuntimeOptions): CreateImageCacheResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acrRegistryInfo)) {
    query['AcrRegistryInfo'] = request.acrRegistryInfo;
  }
  if (!Util.isUnset(request.annotations)) {
    query['Annotations'] = request.annotations;
  }
  if (!Util.isUnset(request.autoMatchImageCache)) {
    query['AutoMatchImageCache'] = request.autoMatchImageCache;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eipInstanceId)) {
    query['EipInstanceId'] = request.eipInstanceId;
  }
  if (!Util.isUnset(request.eliminationStrategy)) {
    query['EliminationStrategy'] = request.eliminationStrategy;
  }
  if (!Util.isUnset(request.flash)) {
    query['Flash'] = request.flash;
  }
  if (!Util.isUnset(request.flashCopyCount)) {
    query['FlashCopyCount'] = request.flashCopyCount;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageCacheName)) {
    query['ImageCacheName'] = request.imageCacheName;
  }
  if (!Util.isUnset(request.imageCacheSize)) {
    query['ImageCacheSize'] = request.imageCacheSize;
  }
  if (!Util.isUnset(request.imageRegistryCredential)) {
    query['ImageRegistryCredential'] = request.imageRegistryCredential;
  }
  if (!Util.isUnset(request.insecureRegistry)) {
    query['InsecureRegistry'] = request.insecureRegistry;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.plainHttpRegistry)) {
    query['PlainHttpRegistry'] = request.plainHttpRegistry;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.standardCopyCount)) {
    query['StandardCopyCount'] = request.standardCopyCount;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateImageCache',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createImageCache(request: CreateImageCacheRequest): CreateImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return createImageCacheWithOptions(request, runtime);
}

model CreateInstanceOpsTaskRequest {
  containerGroupId?: string(name='ContainerGroupId'),
  opsType?: string(name='OpsType'),
  opsValue?: string(name='OpsValue'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model CreateInstanceOpsTaskResponseBody = {
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
}

model CreateInstanceOpsTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateInstanceOpsTaskResponseBody(name='body'),
}

async function createInstanceOpsTaskWithOptions(request: CreateInstanceOpsTaskRequest, runtime: Util.RuntimeOptions): CreateInstanceOpsTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.opsType)) {
    query['OpsType'] = request.opsType;
  }
  if (!Util.isUnset(request.opsValue)) {
    query['OpsValue'] = request.opsValue;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateInstanceOpsTask',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createInstanceOpsTask(request: CreateInstanceOpsTaskRequest): CreateInstanceOpsTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createInstanceOpsTaskWithOptions(request, runtime);
}

model CreateVirtualNodeRequest {
  clientToken?: string(name='ClientToken'),
  eipInstanceId?: string(name='EipInstanceId'),
  enablePublicNetwork?: boolean(name='EnablePublicNetwork'),
  kubeConfig?: string(name='KubeConfig'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  rotateCertificateEnabled?: boolean(name='RotateCertificateEnabled'),
  securityGroupId?: string(name='SecurityGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  taint?: [ 
    {
      effect?: string(name='Effect'),
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Taint'),
  tlsBootstrapEnabled?: boolean(name='TlsBootstrapEnabled'),
  vSwitchId?: string(name='VSwitchId'),
  virtualNodeName?: string(name='VirtualNodeName'),
  zoneId?: string(name='ZoneId'),
}

model CreateVirtualNodeResponseBody = {
  requestId?: string(name='RequestId'),
  virtualNodeId?: string(name='VirtualNodeId'),
}

model CreateVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVirtualNodeResponseBody(name='body'),
}

async function createVirtualNodeWithOptions(request: CreateVirtualNodeRequest, runtime: Util.RuntimeOptions): CreateVirtualNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eipInstanceId)) {
    query['EipInstanceId'] = request.eipInstanceId;
  }
  if (!Util.isUnset(request.enablePublicNetwork)) {
    query['EnablePublicNetwork'] = request.enablePublicNetwork;
  }
  if (!Util.isUnset(request.kubeConfig)) {
    query['KubeConfig'] = request.kubeConfig;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.rotateCertificateEnabled)) {
    query['RotateCertificateEnabled'] = request.rotateCertificateEnabled;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.taint)) {
    query['Taint'] = request.taint;
  }
  if (!Util.isUnset(request.tlsBootstrapEnabled)) {
    query['TlsBootstrapEnabled'] = request.tlsBootstrapEnabled;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.virtualNodeName)) {
    query['VirtualNodeName'] = request.virtualNodeName;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVirtualNode',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVirtualNode(request: CreateVirtualNodeRequest): CreateVirtualNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVirtualNodeWithOptions(request, runtime);
}

model DeleteContainerGroupRequest {
  clientToken?: string(name='ClientToken'),
  containerGroupId?: string(name='ContainerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteContainerGroupResponseBody(name='body'),
}

async function deleteContainerGroupWithOptions(request: DeleteContainerGroupRequest, runtime: Util.RuntimeOptions): DeleteContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteContainerGroup(request: DeleteContainerGroupRequest): DeleteContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteContainerGroupWithOptions(request, runtime);
}

model DeleteImageCacheRequest {
  clientToken?: string(name='ClientToken'),
  imageCacheId?: string(name='ImageCacheId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DeleteImageCacheResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteImageCacheResponseBody(name='body'),
}

async function deleteImageCacheWithOptions(request: DeleteImageCacheRequest, runtime: Util.RuntimeOptions): DeleteImageCacheResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.imageCacheId)) {
    query['ImageCacheId'] = request.imageCacheId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteImageCache',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteImageCache(request: DeleteImageCacheRequest): DeleteImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteImageCacheWithOptions(request, runtime);
}

model DeleteVirtualNodeRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  virtualNodeId?: string(name='VirtualNodeId'),
}

model DeleteVirtualNodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVirtualNodeResponseBody(name='body'),
}

async function deleteVirtualNodeWithOptions(request: DeleteVirtualNodeRequest, runtime: Util.RuntimeOptions): DeleteVirtualNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.virtualNodeId)) {
    query['VirtualNodeId'] = request.virtualNodeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVirtualNode',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVirtualNode(request: DeleteVirtualNodeRequest): DeleteVirtualNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVirtualNodeWithOptions(request, runtime);
}

model DescribeAvailableResourceRequest {
  destinationResource?: {
    category?: string(name='Category'),
    cores?: float(name='Cores'),
    memory?: float(name='Memory'),
    value?: string(name='Value'),
  }(name='DestinationResource'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spotResource?: {
    spotDuration?: int32(name='SpotDuration'),
    spotPriceLimit?: double(name='SpotPriceLimit'),
    spotStrategy?: string(name='SpotStrategy'),
  }(name='SpotResource'),
  zoneId?: string(name='ZoneId'),
}

model DescribeAvailableResourceResponseBody = {
  availableZones?: {
    availableZone?: [ 
    {
      availableResources?: {
        availableResource?: [ 
        {
          supportedResources?: {
            supportedResource?: [ 
            {
              statusCategory?: string(name='StatusCategory'),
              value?: string(name='Value'),
            }
          ](name='SupportedResource')
          }(name='SupportedResources'),
          type?: string(name='Type'),
        }
      ](name='AvailableResource')
      }(name='AvailableResources'),
      regionId?: string(name='RegionId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='AvailableZone')
  }(name='AvailableZones'),
  requestId?: string(name='RequestId'),
}

model DescribeAvailableResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeAvailableResourceResponseBody(name='body'),
}

async function describeAvailableResourceWithOptions(request: DescribeAvailableResourceRequest, runtime: Util.RuntimeOptions): DescribeAvailableResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.destinationResource)) {
    query['DestinationResource'] = request.destinationResource;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spotResource)) {
    query['SpotResource'] = request.spotResource;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeAvailableResource',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeAvailableResource(request: DescribeAvailableResourceRequest): DescribeAvailableResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeAvailableResourceWithOptions(request, runtime);
}

model DescribeContainerGroupEventsRequest {
  condition?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Condition'),
  containerGroupIds?: string(name='ContainerGroupIds'),
  eventSource?: string(name='EventSource'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sinceSecond?: int32(name='SinceSecond'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeContainerGroupEventsResponseBody = {
  data?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId'),
      events?: [ 
        {
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          metadata?: {
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
          }(name='Metadata'),
          reason?: string(name='Reason'),
          reportingComponent?: string(name='ReportingComponent'),
          reportingInstance?: string(name='ReportingInstance'),
          source?: {
            component?: string(name='Component'),
            host?: string(name='Host'),
          }(name='Source'),
          type?: string(name='Type'),
          involvedObject?: {
            apiVersion?: string(name='ApiVersion'),
            kind?: string(name='Kind'),
            name?: string(name='Name'),
            namespace?: string(name='Namespace'),
            uid?: string(name='Uid'),
          }(name='involvedObject'),
        }
      ](name='Events'),
    }
  ](name='Data'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeContainerGroupEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupEventsResponseBody(name='body'),
}

async function describeContainerGroupEventsWithOptions(request: DescribeContainerGroupEventsRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupEventsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.containerGroupIds)) {
    query['ContainerGroupIds'] = request.containerGroupIds;
  }
  if (!Util.isUnset(request.eventSource)) {
    query['EventSource'] = request.eventSource;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sinceSecond)) {
    query['SinceSecond'] = request.sinceSecond;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupEvents',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupEvents(request: DescribeContainerGroupEventsRequest): DescribeContainerGroupEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupEventsWithOptions(request, runtime);
}

model DescribeContainerGroupMetricRequest {
  containerGroupId?: string(name='ContainerGroupId'),
  endTime?: string(name='EndTime'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  period?: string(name='Period'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  startTime?: string(name='StartTime'),
}

model DescribeContainerGroupMetricResponseBody = {
  containerGroupId?: string(name='ContainerGroupId'),
  records?: [ 
    {
      CPU?: {
        limit?: long(name='Limit'),
        load?: long(name='Load'),
        usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
        usageNanoCores?: long(name='UsageNanoCores'),
      }(name='CPU'),
      containers?: [ 
        {
          CPU?: {
            limit?: long(name='Limit'),
            load?: long(name='Load'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
            usageNanoCores?: long(name='UsageNanoCores'),
          }(name='CPU'),
          memory?: {
            availableBytes?: long(name='AvailableBytes'),
            cache?: long(name='Cache'),
            rss?: long(name='Rss'),
            usageBytes?: long(name='UsageBytes'),
            workingSet?: long(name='WorkingSet'),
          }(name='Memory'),
          name?: string(name='Name'),
        }
      ](name='Containers'),
      disk?: [ 
        {
          device?: string(name='Device'),
          readBytes?: long(name='ReadBytes'),
          readIO?: long(name='ReadIO'),
          writeBytes?: long(name='WriteBytes'),
          writeIO?: long(name='WriteIO'),
        }
      ](name='Disk'),
      filesystem?: [ 
        {
          available?: long(name='Available'),
          capacity?: long(name='Capacity'),
          category?: string(name='Category'),
          fsName?: string(name='FsName'),
          usage?: long(name='Usage'),
        }
      ](name='Filesystem'),
      memory?: {
        availableBytes?: long(name='AvailableBytes'),
        cache?: long(name='Cache'),
        rss?: long(name='Rss'),
        usageBytes?: long(name='UsageBytes'),
        workingSet?: long(name='WorkingSet'),
      }(name='Memory'),
      network?: {
        interfaces?: [ 
          {
            name?: string(name='Name'),
            rxBytes?: long(name='RxBytes'),
            rxDrops?: long(name='RxDrops'),
            rxErrors?: long(name='RxErrors'),
            rxPackets?: long(name='RxPackets'),
            txBytes?: long(name='TxBytes'),
            txDrops?: long(name='TxDrops'),
            txErrors?: long(name='TxErrors'),
            txPackets?: long(name='TxPackets'),
          }
        ](name='Interfaces'),
      }(name='Network'),
      timestamp?: string(name='Timestamp'),
    }
  ](name='Records'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupMetricResponseBody(name='body'),
}

async function describeContainerGroupMetricWithOptions(request: DescribeContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.period)) {
    query['Period'] = request.period;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupMetric',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupMetric(request: DescribeContainerGroupMetricRequest): DescribeContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupMetricWithOptions(request, runtime);
}

model DescribeContainerGroupPriceRequest {
  cpu?: float(name='Cpu'),
  ephemeralStorage?: int32(name='EphemeralStorage'),
  instanceType?: string(name='InstanceType'),
  memory?: float(name='Memory'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  spotPriceLimit?: float(name='SpotPriceLimit'),
  spotStrategy?: string(name='SpotStrategy'),
  zoneId?: string(name='ZoneId'),
}

model DescribeContainerGroupPriceResponseBody = {
  priceInfo?: {
    price?: {
      currency?: string(name='Currency'),
      detailInfos?: {
        detailInfo?: [ 
        {
          discountPrice?: float(name='DiscountPrice'),
          originalPrice?: float(name='OriginalPrice'),
          resource?: string(name='Resource'),
          rules?: {
            rule?: [ 
            {
              description?: string(name='Description'),
              ruleId?: long(name='RuleId'),
            }
          ](name='Rule')
          }(name='Rules'),
          tradePrice?: float(name='TradePrice'),
        }
      ](name='DetailInfo')
      }(name='DetailInfos'),
      discountPrice?: float(name='DiscountPrice'),
      originalPrice?: float(name='OriginalPrice'),
      tradePrice?: float(name='TradePrice'),
    }(name='Price'),
    rules?: {
      rule?: [ 
      {
        description?: string(name='Description'),
        ruleId?: long(name='RuleId'),
      }
    ](name='Rule')
    }(name='Rules'),
    spotPrices?: {
      spotPrice?: [ 
      {
        instanceType?: string(name='InstanceType'),
        originPrice?: float(name='OriginPrice'),
        spotPrice?: float(name='SpotPrice'),
        zoneId?: string(name='ZoneId'),
      }
    ](name='SpotPrice')
    }(name='SpotPrices'),
  }(name='PriceInfo'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerGroupPriceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupPriceResponseBody(name='body'),
}

async function describeContainerGroupPriceWithOptions(request: DescribeContainerGroupPriceRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupPriceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.ephemeralStorage)) {
    query['EphemeralStorage'] = request.ephemeralStorage;
  }
  if (!Util.isUnset(request.instanceType)) {
    query['InstanceType'] = request.instanceType;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.spotPriceLimit)) {
    query['SpotPriceLimit'] = request.spotPriceLimit;
  }
  if (!Util.isUnset(request.spotStrategy)) {
    query['SpotStrategy'] = request.spotStrategy;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupPrice',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupPrice(request: DescribeContainerGroupPriceRequest): DescribeContainerGroupPriceResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupPriceWithOptions(request, runtime);
}

model DescribeContainerGroupStatusRequest {
  condition?: [ 
    {
      status?: string(name='Status'),
      type?: string(name='Type'),
    }
  ](name='Condition'),
  containerGroupIds?: string(name='ContainerGroupIds'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sinceSecond?: int32(name='SinceSecond'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  zoneId?: string(name='ZoneId'),
}

model DescribeContainerGroupStatusResponseBody = {
  data?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId'),
      name?: string(name='Name'),
      namespace?: string(name='Namespace'),
      podStatus?: {
        conditions?: [ 
          {
            message?: string(name='Message'),
            reason?: string(name='Reason'),
            lastTransitionTime?: string(name='lastTransitionTime'),
            status?: string(name='status'),
            type?: string(name='type'),
          }
        ](name='Conditions'),
        containerStatuses?: [ 
          {
            image?: string(name='Image'),
            imageID?: string(name='ImageID'),
            lastState?: {
              running?: {
                startedAtstartedAt?: string(name='StartedAtstartedAt'),
              }(name='Running'),
              terminated?: {
                containerID?: string(name='ContainerID'),
                exitCode?: int32(name='ExitCode'),
                finishedAt?: string(name='FinishedAt'),
                message?: string(name='Message'),
                reason?: string(name='Reason'),
                signal?: int32(name='Signal'),
                startedAt?: string(name='StartedAt'),
              }(name='Terminated'),
              waiting?: {
                message?: string(name='Message'),
                reason?: string(name='Reason'),
              }(name='Waiting'),
            }(name='LastState'),
            name?: string(name='Name'),
            ready?: boolean(name='Ready'),
            restartCount?: int32(name='RestartCount'),
            started?: boolean(name='Started'),
            state?: {
              running?: {
                startedAtstartedAt?: string(name='StartedAtstartedAt'),
              }(name='Running'),
              terminated?: {
                containerID?: string(name='ContainerID'),
                exitCode?: int32(name='ExitCode'),
                finishedAt?: string(name='FinishedAt'),
                message?: string(name='Message'),
                reason?: string(name='Reason'),
                signal?: int32(name='Signal'),
                startedAt?: string(name='StartedAt'),
              }(name='Terminated'),
              waiting?: {
                message?: string(name='Message'),
                reason?: string(name='Reason'),
              }(name='Waiting'),
            }(name='State'),
          }
        ](name='ContainerStatuses'),
        hostIp?: string(name='HostIp'),
        phase?: string(name='Phase'),
        podIp?: string(name='PodIp'),
        podIps?: [ 
          {
            ip?: string(name='Ip'),
          }
        ](name='PodIps'),
        qosClass?: string(name='QosClass'),
        startTime?: string(name='StartTime'),
      }(name='PodStatus'),
      status?: string(name='Status'),
      uuid?: string(name='uuid'),
    }
  ](name='Data'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeContainerGroupStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupStatusResponseBody(name='body'),
}

async function describeContainerGroupStatusWithOptions(request: DescribeContainerGroupStatusRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupStatusResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.condition)) {
    query['Condition'] = request.condition;
  }
  if (!Util.isUnset(request.containerGroupIds)) {
    query['ContainerGroupIds'] = request.containerGroupIds;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sinceSecond)) {
    query['SinceSecond'] = request.sinceSecond;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroupStatus',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroupStatus(request: DescribeContainerGroupStatusRequest): DescribeContainerGroupStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupStatusWithOptions(request, runtime);
}

model DescribeContainerGroupsRequest {
  containerGroupIds?: string(name='ContainerGroupIds'),
  containerGroupName?: string(name='ContainerGroupName'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  withEvent?: boolean(name='WithEvent'),
  zoneId?: string(name='ZoneId'),
}

model DescribeContainerGroupsResponseBody = {
  containerGroups?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId'),
      containerGroupName?: string(name='ContainerGroupName'),
      containers?: [ 
        {
          args?: [ string ](name='Args'),
          commands?: [ string ](name='Commands'),
          cpu?: float(name='Cpu'),
          currentState?: {
            detailStatus?: string(name='DetailStatus'),
            exitCode?: int32(name='ExitCode'),
            finishTime?: string(name='FinishTime'),
            message?: string(name='Message'),
            reason?: string(name='Reason'),
            signal?: int32(name='Signal'),
            startTime?: string(name='StartTime'),
            state?: string(name='State'),
          }(name='CurrentState'),
          environmentVars?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
          gpu?: int32(name='Gpu'),
          image?: string(name='Image'),
          imagePullPolicy?: string(name='ImagePullPolicy'),
          livenessProbe?: {
            execs?: [ string ](name='Execs'),
            failureThreshold?: int32(name='FailureThreshold'),
            httpGet?: {
              path?: string(name='Path'),
              port?: int32(name='Port'),
              scheme?: string(name='Scheme'),
            }(name='HttpGet'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds'),
            periodSeconds?: int32(name='PeriodSeconds'),
            successThreshold?: int32(name='SuccessThreshold'),
            tcpSocket?: {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }(name='TcpSocket'),
            timeoutSeconds?: int32(name='TimeoutSeconds'),
          }(name='LivenessProbe'),
          memory?: float(name='Memory'),
          name?: string(name='Name'),
          ports?: [ 
            {
              port?: int32(name='Port'),
              protocol?: string(name='Protocol'),
            }
          ](name='Ports'),
          previousState?: {
            detailStatus?: string(name='DetailStatus'),
            exitCode?: int32(name='ExitCode'),
            finishTime?: string(name='FinishTime'),
            message?: string(name='Message'),
            reason?: string(name='Reason'),
            signal?: int32(name='Signal'),
            startTime?: string(name='StartTime'),
            state?: string(name='State'),
          }(name='PreviousState'),
          readinessProbe?: {
            execs?: [ string ](name='Execs'),
            failureThreshold?: int32(name='FailureThreshold'),
            httpGet?: {
              path?: string(name='Path'),
              port?: int32(name='Port'),
              scheme?: string(name='Scheme'),
            }(name='HttpGet'),
            initialDelaySeconds?: int32(name='InitialDelaySeconds'),
            periodSeconds?: int32(name='PeriodSeconds'),
            successThreshold?: int32(name='SuccessThreshold'),
            tcpSocket?: {
              host?: string(name='Host'),
              port?: int32(name='Port'),
            }(name='TcpSocket'),
            timeoutSeconds?: int32(name='TimeoutSeconds'),
          }(name='ReadinessProbe'),
          ready?: boolean(name='Ready'),
          restartCount?: int32(name='RestartCount'),
          securityContext?: {
            capability?: {
              adds?: [ string ](name='Adds'),
            }(name='Capability'),
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser?: long(name='RunAsUser'),
          }(name='SecurityContext'),
          stdin?: boolean(name='Stdin'),
          stdinOnce?: boolean(name='StdinOnce'),
          tty?: boolean(name='Tty'),
          volumeMounts?: [ 
            {
              mountPath?: string(name='MountPath'),
              mountPropagation?: string(name='MountPropagation'),
              name?: string(name='Name'),
              readOnly?: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          workingDir?: string(name='WorkingDir'),
        }
      ](name='Containers'),
      cpu?: float(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      discount?: int32(name='Discount'),
      dnsConfig?: {
        nameServers?: [ string ](name='NameServers'),
        options?: [ 
          {
            name?: string(name='Name'),
            value?: string(name='Value'),
          }
        ](name='Options'),
        searches?: [ string ](name='Searches'),
      }(name='DnsConfig'),
      eciSecurityContext?: {
        sysctls?: [ 
          {
            name?: string(name='Name'),
            value?: string(name='Value'),
          }
        ](name='Sysctls'),
      }(name='EciSecurityContext'),
      eniInstanceId?: string(name='EniInstanceId'),
      ephemeralStorage?: int32(name='EphemeralStorage'),
      events?: [ 
        {
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='Events'),
      expiredTime?: string(name='ExpiredTime'),
      failedTime?: string(name='FailedTime'),
      hostAliases?: [ 
        {
          hostnames?: [ string ](name='Hostnames'),
          ip?: string(name='Ip'),
        }
      ](name='HostAliases'),
      initContainers?: [ 
        {
          args?: [ string ](name='Args'),
          command?: [ string ](name='Command'),
          cpu?: float(name='Cpu'),
          currentState?: {
            detailStatus?: string(name='DetailStatus'),
            exitCode?: int32(name='ExitCode'),
            finishTime?: string(name='FinishTime'),
            message?: string(name='Message'),
            reason?: string(name='Reason'),
            signal?: int32(name='Signal'),
            startTime?: string(name='StartTime'),
            state?: string(name='State'),
          }(name='CurrentState'),
          environmentVars?: [ 
            {
              key?: string(name='Key'),
              value?: string(name='Value'),
              valueFrom?: {
                fieldRef?: {
                  fieldPath?: string(name='FieldPath'),
                }(name='FieldRef'),
              }(name='ValueFrom'),
            }
          ](name='EnvironmentVars'),
          gpu?: int32(name='Gpu'),
          image?: string(name='Image'),
          imagePullPolicy?: string(name='ImagePullPolicy'),
          memory?: float(name='Memory'),
          name?: string(name='Name'),
          ports?: [ 
            {
              port?: int32(name='Port'),
              protocol?: string(name='Protocol'),
            }
          ](name='Ports'),
          previousState?: {
            detailStatus?: string(name='DetailStatus'),
            exitCode?: int32(name='ExitCode'),
            finishTime?: string(name='FinishTime'),
            message?: string(name='Message'),
            reason?: string(name='Reason'),
            signal?: int32(name='Signal'),
            startTime?: string(name='StartTime'),
            state?: string(name='State'),
          }(name='PreviousState'),
          ready?: boolean(name='Ready'),
          restartCount?: int32(name='RestartCount'),
          securityContext?: {
            capability?: {
              adds?: [ string ](name='Adds'),
            }(name='Capability'),
            readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
            runAsUser?: long(name='RunAsUser'),
          }(name='SecurityContext'),
          volumeMounts?: [ 
            {
              mountPath?: string(name='MountPath'),
              mountPropagation?: string(name='MountPropagation'),
              name?: string(name='Name'),
              readOnly?: boolean(name='ReadOnly'),
            }
          ](name='VolumeMounts'),
          workingDir?: string(name='WorkingDir'),
        }
      ](name='InitContainers'),
      instanceType?: string(name='InstanceType'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      ipv6Address?: string(name='Ipv6Address'),
      memory?: float(name='Memory'),
      ramRoleName?: string(name='RamRoleName'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      restartPolicy?: string(name='RestartPolicy'),
      securityGroupId?: string(name='SecurityGroupId'),
      spotPriceLimit?: double(name='SpotPriceLimit'),
      spotStrategy?: string(name='SpotStrategy'),
      status?: string(name='Status'),
      succeededTime?: string(name='SucceededTime'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      tenantEniInstanceId?: string(name='TenantEniInstanceId'),
      tenantEniIp?: string(name='TenantEniIp'),
      tenantSecurityGroupId?: string(name='TenantSecurityGroupId'),
      tenantVSwitchId?: string(name='TenantVSwitchId'),
      vSwitchId?: string(name='VSwitchId'),
      volumes?: [ 
        {
          configFileVolumeConfigFileToPaths?: [ 
            {
              content?: string(name='Content'),
              path?: string(name='Path'),
            }
          ](name='ConfigFileVolumeConfigFileToPaths'),
          diskVolumeDiskId?: string(name='DiskVolumeDiskId'),
          diskVolumeFsType?: string(name='DiskVolumeFsType'),
          flexVolumeDriver?: string(name='FlexVolumeDriver'),
          flexVolumeFsType?: string(name='FlexVolumeFsType'),
          flexVolumeOptions?: string(name='FlexVolumeOptions'),
          NFSVolumePath?: string(name='NFSVolumePath'),
          NFSVolumeReadOnly?: boolean(name='NFSVolumeReadOnly'),
          NFSVolumeServer?: string(name='NFSVolumeServer'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Volumes'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='ContainerGroups'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeContainerGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerGroupsResponseBody(name='body'),
}

async function describeContainerGroupsWithOptions(request: DescribeContainerGroupsRequest, runtime: Util.RuntimeOptions): DescribeContainerGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupIds)) {
    query['ContainerGroupIds'] = request.containerGroupIds;
  }
  if (!Util.isUnset(request.containerGroupName)) {
    query['ContainerGroupName'] = request.containerGroupName;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.withEvent)) {
    query['WithEvent'] = request.withEvent;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerGroups',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerGroups(request: DescribeContainerGroupsRequest): DescribeContainerGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerGroupsWithOptions(request, runtime);
}

model DescribeContainerLogRequest {
  containerGroupId?: string(name='ContainerGroupId'),
  containerName?: string(name='ContainerName'),
  lastTime?: boolean(name='LastTime'),
  limitBytes?: long(name='LimitBytes'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  sinceSeconds?: int32(name='SinceSeconds'),
  startTime?: string(name='StartTime'),
  tail?: int32(name='Tail'),
  timestamps?: boolean(name='Timestamps'),
}

model DescribeContainerLogResponseBody = {
  containerName?: string(name='ContainerName'),
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
}

model DescribeContainerLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerLogResponseBody(name='body'),
}

async function describeContainerLogWithOptions(request: DescribeContainerLogRequest, runtime: Util.RuntimeOptions): DescribeContainerLogResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.lastTime)) {
    query['LastTime'] = request.lastTime;
  }
  if (!Util.isUnset(request.limitBytes)) {
    query['LimitBytes'] = request.limitBytes;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.sinceSeconds)) {
    query['SinceSeconds'] = request.sinceSeconds;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.tail)) {
    query['Tail'] = request.tail;
  }
  if (!Util.isUnset(request.timestamps)) {
    query['Timestamps'] = request.timestamps;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerLog',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerLog(request: DescribeContainerLogRequest): DescribeContainerLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerLogWithOptions(request, runtime);
}

model DescribeImageCachesRequest {
  image?: string(name='Image'),
  imageCacheId?: string(name='ImageCacheId'),
  imageCacheName?: string(name='ImageCacheName'),
  matchImage?: [ string ](name='MatchImage'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  snapshotId?: string(name='SnapshotId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeImageCachesResponseBody = {
  imageCaches?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId'),
      creationTime?: string(name='CreationTime'),
      eliminationStrategy?: string(name='EliminationStrategy'),
      events?: [ 
        {
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          type?: string(name='Type'),
        }
      ](name='Events'),
      expireDateTime?: string(name='ExpireDateTime'),
      flashSnapshotId?: string(name='FlashSnapshotId'),
      imageCacheId?: string(name='ImageCacheId'),
      imageCacheName?: string(name='ImageCacheName'),
      imageCacheSize?: int32(name='ImageCacheSize'),
      images?: [ string ](name='Images'),
      lastMatchedTime?: string(name='LastMatchedTime'),
      progress?: string(name='Progress'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      snapshotId?: string(name='SnapshotId'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
    }
  ](name='ImageCaches'),
  requestId?: string(name='RequestId'),
}

model DescribeImageCachesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeImageCachesResponseBody(name='body'),
}

async function describeImageCachesWithOptions(request: DescribeImageCachesRequest, runtime: Util.RuntimeOptions): DescribeImageCachesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageCacheId)) {
    query['ImageCacheId'] = request.imageCacheId;
  }
  if (!Util.isUnset(request.imageCacheName)) {
    query['ImageCacheName'] = request.imageCacheName;
  }
  if (!Util.isUnset(request.matchImage)) {
    query['MatchImage'] = request.matchImage;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeImageCaches',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeImageCaches(request: DescribeImageCachesRequest): DescribeImageCachesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeImageCachesWithOptions(request, runtime);
}

model DescribeInstanceOpsRecordsRequest {
  containerGroupId?: string(name='ContainerGroupId'),
  opsType?: string(name='OpsType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeInstanceOpsRecordsResponseBody = {
  records?: [ 
    {
      createTime?: string(name='CreateTime'),
      expireTime?: string(name='ExpireTime'),
      opsStatus?: string(name='OpsStatus'),
      opsType?: string(name='OpsType'),
      resultContent?: string(name='ResultContent'),
      resultType?: string(name='ResultType'),
    }
  ](name='Records'),
  requestId?: string(name='RequestId'),
}

model DescribeInstanceOpsRecordsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeInstanceOpsRecordsResponseBody(name='body'),
}

async function describeInstanceOpsRecordsWithOptions(request: DescribeInstanceOpsRecordsRequest, runtime: Util.RuntimeOptions): DescribeInstanceOpsRecordsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.opsType)) {
    query['OpsType'] = request.opsType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeInstanceOpsRecords',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeInstanceOpsRecords(request: DescribeInstanceOpsRecordsRequest): DescribeInstanceOpsRecordsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeInstanceOpsRecordsWithOptions(request, runtime);
}

model DescribeMultiContainerGroupMetricRequest {
  containerGroupIds?: string(name='ContainerGroupIds'),
  metricType?: string(name='MetricType'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeMultiContainerGroupMetricResponseBody = {
  monitorDatas?: [ 
    {
      containerGroupId?: string(name='ContainerGroupId'),
      records?: [ 
        {
          CPU?: {
            limit?: long(name='Limit'),
            load?: long(name='Load'),
            usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
            usageNanoCores?: long(name='UsageNanoCores'),
          }(name='CPU'),
          containers?: [ 
            {
              CPU?: {
                limit?: long(name='Limit'),
                load?: long(name='Load'),
                usageCoreNanoSeconds?: long(name='UsageCoreNanoSeconds'),
                usageNanoCores?: long(name='UsageNanoCores'),
              }(name='CPU'),
              memory?: {
                availableBytes?: long(name='AvailableBytes'),
                cache?: long(name='Cache'),
                rss?: long(name='Rss'),
                usageBytes?: long(name='UsageBytes'),
                workingSet?: long(name='WorkingSet'),
              }(name='Memory'),
              name?: string(name='Name'),
            }
          ](name='Containers'),
          disk?: [ 
            {
              device?: string(name='Device'),
              readBytes?: long(name='ReadBytes'),
              readIo?: long(name='ReadIo'),
              writeBytes?: long(name='WriteBytes'),
              writeIo?: long(name='WriteIo'),
            }
          ](name='Disk'),
          filesystem?: [ 
            {
              available?: long(name='Available'),
              capacity?: long(name='Capacity'),
              fsName?: string(name='FsName'),
              usage?: long(name='Usage'),
            }
          ](name='Filesystem'),
          memory?: {
            availableBytes?: long(name='AvailableBytes'),
            cache?: long(name='Cache'),
            rss?: long(name='Rss'),
            usageBytes?: long(name='UsageBytes'),
            workingSet?: long(name='WorkingSet'),
          }(name='Memory'),
          network?: {
            interfaces?: [ 
              {
                name?: string(name='Name'),
                rxBytes?: long(name='RxBytes'),
                rxDrops?: long(name='RxDrops'),
                rxErrors?: long(name='RxErrors'),
                rxPackets?: long(name='RxPackets'),
                txBytes?: long(name='TxBytes'),
                txDrops?: long(name='TxDrops'),
                txErrors?: long(name='TxErrors'),
                txPackets?: long(name='TxPackets'),
              }
            ](name='Interfaces'),
          }(name='Network'),
          timestamp?: string(name='Timestamp'),
        }
      ](name='Records'),
    }
  ](name='MonitorDatas'),
  requestId?: string(name='RequestId'),
}

model DescribeMultiContainerGroupMetricResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeMultiContainerGroupMetricResponseBody(name='body'),
}

async function describeMultiContainerGroupMetricWithOptions(request: DescribeMultiContainerGroupMetricRequest, runtime: Util.RuntimeOptions): DescribeMultiContainerGroupMetricResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.containerGroupIds)) {
    query['ContainerGroupIds'] = request.containerGroupIds;
  }
  if (!Util.isUnset(request.metricType)) {
    query['MetricType'] = request.metricType;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeMultiContainerGroupMetric',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeMultiContainerGroupMetric(request: DescribeMultiContainerGroupMetricRequest): DescribeMultiContainerGroupMetricResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeMultiContainerGroupMetricWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model DescribeRegionsResponseBody = {
  regions?: [ 
    {
      recommendZones?: [ string ](name='RecommendZones'),
      regionEndpoint?: string(name='RegionEndpoint'),
      regionId?: string(name='RegionId'),
      zones?: [ string ](name='Zones'),
    }
  ](name='Regions'),
  requestId?: string(name='RequestId'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeVirtualNodesRequest {
  clientToken?: string(name='ClientToken'),
  limit?: long(name='Limit'),
  nextToken?: string(name='NextToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  virtualNodeIds?: string(name='VirtualNodeIds'),
  virtualNodeName?: string(name='VirtualNodeName'),
  zoneId?: string(name='ZoneId'),
}

model DescribeVirtualNodesResponseBody = {
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
  virtualNodes?: [ 
    {
      clusterId?: string(name='ClusterId'),
      cpu?: float(name='Cpu'),
      creationTime?: string(name='CreationTime'),
      eniInstanceId?: string(name='EniInstanceId'),
      events?: [ 
        {
          count?: int32(name='Count'),
          firstTimestamp?: string(name='FirstTimestamp'),
          lastTimestamp?: string(name='LastTimestamp'),
          message?: string(name='Message'),
          name?: string(name='Name'),
          reason?: string(name='Reason'),
          type?: string(name='Type'),
        }
      ](name='Events'),
      internetIp?: string(name='InternetIp'),
      intranetIp?: string(name='IntranetIp'),
      memory?: float(name='Memory'),
      ramRoleName?: string(name='RamRoleName'),
      regionId?: string(name='RegionId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      securityGroupId?: string(name='SecurityGroupId'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      vSwitchId?: string(name='VSwitchId'),
      virtualNodeId?: string(name='VirtualNodeId'),
      virtualNodeName?: string(name='VirtualNodeName'),
      vpcId?: string(name='VpcId'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='VirtualNodes'),
}

model DescribeVirtualNodesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVirtualNodesResponseBody(name='body'),
}

async function describeVirtualNodesWithOptions(request: DescribeVirtualNodesRequest, runtime: Util.RuntimeOptions): DescribeVirtualNodesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.virtualNodeIds)) {
    query['VirtualNodeIds'] = request.virtualNodeIds;
  }
  if (!Util.isUnset(request.virtualNodeName)) {
    query['VirtualNodeName'] = request.virtualNodeName;
  }
  if (!Util.isUnset(request.zoneId)) {
    query['ZoneId'] = request.zoneId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVirtualNodes',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVirtualNodes(request: DescribeVirtualNodesRequest): DescribeVirtualNodesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVirtualNodesWithOptions(request, runtime);
}

model ExecContainerCommandRequest {
  command?: string(name='Command'),
  containerGroupId?: string(name='ContainerGroupId'),
  containerName?: string(name='ContainerName'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  stdin?: boolean(name='Stdin'),
  sync?: boolean(name='Sync'),
  TTY?: boolean(name='TTY'),
}

model ExecContainerCommandResponseBody = {
  httpUrl?: string(name='HttpUrl'),
  requestId?: string(name='RequestId'),
  syncResponse?: string(name='SyncResponse'),
  webSocketUri?: string(name='WebSocketUri'),
}

model ExecContainerCommandResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecContainerCommandResponseBody(name='body'),
}

async function execContainerCommandWithOptions(request: ExecContainerCommandRequest, runtime: Util.RuntimeOptions): ExecContainerCommandResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.command)) {
    query['Command'] = request.command;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.containerName)) {
    query['ContainerName'] = request.containerName;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.stdin)) {
    query['Stdin'] = request.stdin;
  }
  if (!Util.isUnset(request.sync)) {
    query['Sync'] = request.sync;
  }
  if (!Util.isUnset(request.TTY)) {
    query['TTY'] = request.TTY;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecContainerCommand',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function execContainerCommand(request: ExecContainerCommandRequest): ExecContainerCommandResponse {
  var runtime = new Util.RuntimeOptions{};
  return execContainerCommandWithOptions(request, runtime);
}

model ListUsageRequest {
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model ListUsageResponseBody = {
  attributes?: map[string]any(name='Attributes'),
  requestId?: string(name='RequestId'),
}

model ListUsageResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListUsageResponseBody(name='body'),
}

async function listUsageWithOptions(request: ListUsageRequest, runtime: Util.RuntimeOptions): ListUsageResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListUsage',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listUsage(request: ListUsageRequest): ListUsageResponse {
  var runtime = new Util.RuntimeOptions{};
  return listUsageWithOptions(request, runtime);
}

model ResizeContainerGroupVolumeRequest {
  clientToken?: string(name='ClientToken'),
  containerGroupId?: string(name='ContainerGroupId'),
  newSize?: long(name='NewSize'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  volumeName?: string(name='VolumeName'),
}

model ResizeContainerGroupVolumeResponseBody = {
  requestId?: string(name='RequestId'),
}

model ResizeContainerGroupVolumeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ResizeContainerGroupVolumeResponseBody(name='body'),
}

async function resizeContainerGroupVolumeWithOptions(request: ResizeContainerGroupVolumeRequest, runtime: Util.RuntimeOptions): ResizeContainerGroupVolumeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.newSize)) {
    query['NewSize'] = request.newSize;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.volumeName)) {
    query['VolumeName'] = request.volumeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ResizeContainerGroupVolume',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function resizeContainerGroupVolume(request: ResizeContainerGroupVolumeRequest): ResizeContainerGroupVolumeResponse {
  var runtime = new Util.RuntimeOptions{};
  return resizeContainerGroupVolumeWithOptions(request, runtime);
}

model RestartContainerGroupRequest {
  clientToken?: string(name='ClientToken'),
  containerGroupId?: string(name='ContainerGroupId'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
}

model RestartContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model RestartContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RestartContainerGroupResponseBody(name='body'),
}

async function restartContainerGroupWithOptions(request: RestartContainerGroupRequest, runtime: Util.RuntimeOptions): RestartContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RestartContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function restartContainerGroup(request: RestartContainerGroupRequest): RestartContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return restartContainerGroupWithOptions(request, runtime);
}

model UpdateContainerGroupRequest {
  dnsConfig?: {
    nameServer?: [ string ](name='NameServer'),
    option?: [ 
      {
        name?: string(name='Name'),
        value?: string(name='Value'),
      }
    ](name='Option'),
    search?: [ string ](name='Search'),
  }(name='DnsConfig'),
  clientToken?: string(name='ClientToken'),
  container?: [ 
    {
      livenessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='LivenessProbe'),
      readinessProbe: {
        exec: {
            command?: [ string ](name='Command'),
        }(name='Exec'),
        failureThreshold?: int32(name='FailureThreshold'),
        httpGet: {
            path?: string(name='Path'),
            port?: int32(name='Port'),
            scheme?: string(name='Scheme'),
        }(name='HttpGet'),
        initialDelaySeconds?: int32(name='InitialDelaySeconds'),
        periodSeconds?: int32(name='PeriodSeconds'),
        successThreshold?: int32(name='SuccessThreshold'),
        tcpSocket: {
            port?: int32(name='Port'),
        }(name='TcpSocket'),
        timeoutSeconds?: int32(name='TimeoutSeconds'),
      }(name='ReadinessProbe'),
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg'),
      command?: [ string ](name='Command'),
      cpu?: float(name='Cpu'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      gpu?: int32(name='Gpu'),
      image?: string(name='Image'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      lifecyclePostStartHandlerExec?: [ string ](name='LifecyclePostStartHandlerExec'),
      lifecyclePostStartHandlerHttpGetHost?: string(name='LifecyclePostStartHandlerHttpGetHost'),
      lifecyclePostStartHandlerHttpGetHttpHeaders?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePostStartHandlerHttpGetHttpHeaders'),
      lifecyclePostStartHandlerHttpGetPath?: string(name='LifecyclePostStartHandlerHttpGetPath'),
      lifecyclePostStartHandlerHttpGetPort?: int32(name='LifecyclePostStartHandlerHttpGetPort'),
      lifecyclePostStartHandlerHttpGetScheme?: string(name='LifecyclePostStartHandlerHttpGetScheme'),
      lifecyclePostStartHandlerTcpSocketHost?: string(name='LifecyclePostStartHandlerTcpSocketHost'),
      lifecyclePostStartHandlerTcpSocketPort?: int32(name='LifecyclePostStartHandlerTcpSocketPort'),
      lifecyclePreStopHandlerExec?: [ string ](name='LifecyclePreStopHandlerExec'),
      lifecyclePreStopHandlerHttpGetHost?: string(name='LifecyclePreStopHandlerHttpGetHost'),
      lifecyclePreStopHandlerHttpGetHttpHeader?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='LifecyclePreStopHandlerHttpGetHttpHeader'),
      lifecyclePreStopHandlerHttpGetPath?: string(name='LifecyclePreStopHandlerHttpGetPath'),
      lifecyclePreStopHandlerHttpGetPort?: int32(name='LifecyclePreStopHandlerHttpGetPort'),
      lifecyclePreStopHandlerHttpGetScheme?: string(name='LifecyclePreStopHandlerHttpGetScheme'),
      lifecyclePreStopHandlerTcpSocketHost?: string(name='LifecyclePreStopHandlerTcpSocketHost'),
      lifecyclePreStopHandlerTcpSocketPort?: int32(name='LifecyclePreStopHandlerTcpSocketPort'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      port?: [ 
        {
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='Port'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      tty?: boolean(name='Tty'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath'),
          mountPropagation?: string(name='MountPropagation'),
          name?: string(name='Name'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='Container'),
  containerGroupId?: string(name='ContainerGroupId'),
  cpu?: float(name='Cpu'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  initContainer?: [ 
    {
      securityContext: {
        capability: {
            add?: [ string ](name='Add'),
        }(name='Capability'),
        readOnlyRootFilesystem?: boolean(name='ReadOnlyRootFilesystem'),
        runAsUser?: long(name='RunAsUser'),
      }(name='SecurityContext'),
      arg?: [ string ](name='Arg'),
      command?: [ string ](name='Command'),
      cpu?: float(name='Cpu'),
      environmentVar?: [ 
        {
          fieldRef: {
            fieldPath?: string(name='FieldPath'),
          }(name='FieldRef'),
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='EnvironmentVar'),
      gpu?: int32(name='Gpu'),
      image?: string(name='Image'),
      imagePullPolicy?: string(name='ImagePullPolicy'),
      memory?: float(name='Memory'),
      name?: string(name='Name'),
      port?: [ 
        {
          port?: int32(name='Port'),
          protocol?: string(name='Protocol'),
        }
      ](name='Port'),
      stdin?: boolean(name='Stdin'),
      stdinOnce?: boolean(name='StdinOnce'),
      tty?: boolean(name='Tty'),
      volumeMount?: [ 
        {
          mountPath?: string(name='MountPath'),
          mountPropagation?: string(name='MountPropagation'),
          name?: string(name='Name'),
          readOnly?: boolean(name='ReadOnly'),
          subPath?: string(name='SubPath'),
        }
      ](name='VolumeMount'),
      workingDir?: string(name='WorkingDir'),
    }
  ](name='InitContainer'),
  memory?: float(name='Memory'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  restartPolicy?: string(name='RestartPolicy'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  updateType?: string(name='UpdateType'),
  volume?: [ 
    {
      configFileVolume: {
        configFileToPath?: [ 
          {
            content?: string(name='Content'),
            path?: string(name='Path'),
          }
        ](name='ConfigFileToPath'),
      }(name='ConfigFileVolume'),
      emptyDirVolume: {
        medium?: string(name='Medium'),
        sizeLimit?: string(name='SizeLimit'),
      }(name='EmptyDirVolume'),
      flexVolume: {
        driver?: string(name='Driver'),
        fsType?: string(name='FsType'),
        options?: string(name='Options'),
      }(name='FlexVolume'),
      hostPathVolume: {
        path?: string(name='Path'),
        type?: string(name='Type'),
      }(name='HostPathVolume'),
      NFSVolume: {
        path?: string(name='Path'),
        readOnly?: boolean(name='ReadOnly'),
        server?: string(name='Server'),
      }(name='NFSVolume'),
      name?: string(name='Name'),
      type?: string(name='Type'),
    }
  ](name='Volume'),
}

model UpdateContainerGroupResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateContainerGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateContainerGroupResponseBody(name='body'),
}

async function updateContainerGroupWithOptions(request: UpdateContainerGroupRequest, runtime: Util.RuntimeOptions): UpdateContainerGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.container)) {
    query['Container'] = request.container;
  }
  if (!Util.isUnset(request.containerGroupId)) {
    query['ContainerGroupId'] = request.containerGroupId;
  }
  if (!Util.isUnset(request.cpu)) {
    query['Cpu'] = request.cpu;
  }
  if (!Util.isUnset(request.imageRegistryCredential)) {
    query['ImageRegistryCredential'] = request.imageRegistryCredential;
  }
  if (!Util.isUnset(request.initContainer)) {
    query['InitContainer'] = request.initContainer;
  }
  if (!Util.isUnset(request.memory)) {
    query['Memory'] = request.memory;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.restartPolicy)) {
    query['RestartPolicy'] = request.restartPolicy;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.updateType)) {
    query['UpdateType'] = request.updateType;
  }
  if (!Util.isUnset(request.volume)) {
    query['Volume'] = request.volume;
  }
  if (!Util.isUnset(request.dnsConfig)) {
    query['DnsConfig'] = request.dnsConfig;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateContainerGroup',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateContainerGroup(request: UpdateContainerGroupRequest): UpdateContainerGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateContainerGroupWithOptions(request, runtime);
}

model UpdateImageCacheRequest {
  acrRegistryInfo?: [ 
    {
      domain?: [ string ](name='Domain'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      regionId?: string(name='RegionId'),
    }
  ](name='AcrRegistryInfo'),
  autoMatchImageCache?: boolean(name='AutoMatchImageCache'),
  clientToken?: string(name='ClientToken'),
  eipInstanceId?: string(name='EipInstanceId'),
  eliminationStrategy?: string(name='EliminationStrategy'),
  flash?: boolean(name='Flash'),
  flashCopyCount?: int32(name='FlashCopyCount'),
  image?: [ string ](name='Image'),
  imageCacheId?: string(name='ImageCacheId'),
  imageCacheName?: string(name='ImageCacheName'),
  imageCacheSize?: int32(name='ImageCacheSize'),
  imageRegistryCredential?: [ 
    {
      password?: string(name='Password'),
      server?: string(name='Server'),
      userName?: string(name='UserName'),
    }
  ](name='ImageRegistryCredential'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  retentionDays?: int32(name='RetentionDays'),
  securityGroupId?: string(name='SecurityGroupId'),
  standardCopyCount?: int32(name='StandardCopyCount'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
}

model UpdateImageCacheResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateImageCacheResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateImageCacheResponseBody(name='body'),
}

async function updateImageCacheWithOptions(request: UpdateImageCacheRequest, runtime: Util.RuntimeOptions): UpdateImageCacheResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.acrRegistryInfo)) {
    query['AcrRegistryInfo'] = request.acrRegistryInfo;
  }
  if (!Util.isUnset(request.autoMatchImageCache)) {
    query['AutoMatchImageCache'] = request.autoMatchImageCache;
  }
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eipInstanceId)) {
    query['EipInstanceId'] = request.eipInstanceId;
  }
  if (!Util.isUnset(request.eliminationStrategy)) {
    query['EliminationStrategy'] = request.eliminationStrategy;
  }
  if (!Util.isUnset(request.flash)) {
    query['Flash'] = request.flash;
  }
  if (!Util.isUnset(request.flashCopyCount)) {
    query['FlashCopyCount'] = request.flashCopyCount;
  }
  if (!Util.isUnset(request.image)) {
    query['Image'] = request.image;
  }
  if (!Util.isUnset(request.imageCacheId)) {
    query['ImageCacheId'] = request.imageCacheId;
  }
  if (!Util.isUnset(request.imageCacheName)) {
    query['ImageCacheName'] = request.imageCacheName;
  }
  if (!Util.isUnset(request.imageCacheSize)) {
    query['ImageCacheSize'] = request.imageCacheSize;
  }
  if (!Util.isUnset(request.imageRegistryCredential)) {
    query['ImageRegistryCredential'] = request.imageRegistryCredential;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.standardCopyCount)) {
    query['StandardCopyCount'] = request.standardCopyCount;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateImageCache',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateImageCache(request: UpdateImageCacheRequest): UpdateImageCacheResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateImageCacheWithOptions(request, runtime);
}

model UpdateVirtualNodeRequest {
  clientToken?: string(name='ClientToken'),
  ownerAccount?: string(name='OwnerAccount'),
  ownerId?: long(name='OwnerId'),
  regionId?: string(name='RegionId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  resourceOwnerAccount?: string(name='ResourceOwnerAccount'),
  resourceOwnerId?: long(name='ResourceOwnerId'),
  securityGroupId?: string(name='SecurityGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vSwitchId?: string(name='VSwitchId'),
  virtualNodeId?: string(name='VirtualNodeId'),
  virtualNodeName?: string(name='VirtualNodeName'),
}

model UpdateVirtualNodeResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateVirtualNodeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVirtualNodeResponseBody(name='body'),
}

async function updateVirtualNodeWithOptions(request: UpdateVirtualNodeRequest, runtime: Util.RuntimeOptions): UpdateVirtualNodeResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.ownerAccount)) {
    query['OwnerAccount'] = request.ownerAccount;
  }
  if (!Util.isUnset(request.ownerId)) {
    query['OwnerId'] = request.ownerId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.regionId)) {
    query['RegionId'] = request.regionId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.resourceOwnerAccount)) {
    query['ResourceOwnerAccount'] = request.resourceOwnerAccount;
  }
  if (!Util.isUnset(request.resourceOwnerId)) {
    query['ResourceOwnerId'] = request.resourceOwnerId;
  }
  if (!Util.isUnset(request.securityGroupId)) {
    query['SecurityGroupId'] = request.securityGroupId;
  }
  if (!Util.isUnset(request.tag)) {
    query['Tag'] = request.tag;
  }
  if (!Util.isUnset(request.vSwitchId)) {
    query['VSwitchId'] = request.vSwitchId;
  }
  if (!Util.isUnset(request.virtualNodeId)) {
    query['VirtualNodeId'] = request.virtualNodeId;
  }
  if (!Util.isUnset(request.virtualNodeName)) {
    query['VirtualNodeName'] = request.virtualNodeName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVirtualNode',
    version = '2018-08-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVirtualNode(request: UpdateVirtualNodeRequest): UpdateVirtualNodeResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVirtualNodeWithOptions(request, runtime);
}

