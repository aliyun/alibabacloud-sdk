/**
 *
 */
import BaseClientBuilder;
import TeaAsyncHandler;
import TeaRequest;
import AsyncRequestBody;
import RequestBody;
import AsyncResponseHandler;
import ClientConfiguration;
import ClientExecutionParams;
extends BaseClientBuilder;
type @product = string
type @version = string
type @endpointRule = string
type @endpointMap = map[string]string
type @REQUEST = TeaRequest
type @handler = TeaAsyncHandler

init(configuration: ClientConfiguration){
  @handler = new TeaAsyncHandler(configuration);
  @product = 'hbr';
  @version = '2017-09-08';
  @endpointRule = '';
  @endpointMap = {
  };
}

function close(): void {
  @handler.close();
}

model OtsDetail {
  tableNames?: [ string ](name='TableNames', description='OTS table name list'),
}

model CancelBackupJobRequest {
  jobId: string(name='JobId', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model CancelBackupJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelBackupJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelBackupJobResponseBody(name='body'),
}

async function cancelBackupJob(request: CancelBackupJobRequest): CancelBackupJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelBackupJob', 'POST', '/', 'json', false, 'json', request);
}

model CancelRestoreJobRequest {
  restoreId: string(name='RestoreId', position='Query'),
  vaultId: string(name='VaultId', position='Query'),
}

model CancelRestoreJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  body: CancelRestoreJobResponseBody(name='body'),
}

async function cancelRestoreJob(request: CancelRestoreJobRequest): CancelRestoreJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CancelRestoreJob', 'POST', '/', 'json', false, 'json', request);
}

model CreateBackupPlanRequest {
  backupType: string(name='BackupType', position='Query'),
  bucket?: string(name='Bucket', position='Query'),
  createTime?: long(name='CreateTime', position='Query'),
  exclude?: string(name='Exclude', position='Body'),
  fileSystemId?: string(name='FileSystemId', position='Query'),
  include?: string(name='Include', position='Body'),
  instanceGroupId?: string(name='InstanceGroupId', position='Query'),
  instanceId?: string(name='InstanceId', position='Body'),
  instanceName?: string(name='InstanceName', position='Body'),
  options?: string(name='Options', position='Body'),
  otsDetail?: OtsDetail(name='OtsDetail', position='Body'),
  path?: [ string ](name='Path', position='Body'),
  planName: string(name='PlanName', position='Query'),
  prefix?: string(name='Prefix', position='Query'),
  retention?: long(name='Retention', position='Query'),
  schedule: string(name='Schedule', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
  speedLimit?: string(name='SpeedLimit', position='Body'),
  vaultId?: string(name='VaultId', position='Query'),
}

model CreateBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  planId?: string(name='PlanId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateBackupPlan', 'POST', '/', 'json', true, 'form', request);
}

model CreateReplicationVaultRequest {
  description?: string(name='Description', position='Query'),
  redundancyType?: string(name='RedundancyType', position='Query'),
  replicationSourceRegionId: string(name='ReplicationSourceRegionId', position='Query'),
  replicationSourceVaultId: string(name='ReplicationSourceVaultId', position='Query'),
  vaultName: string(name='VaultName', position='Query'),
  vaultRegionId: string(name='VaultRegionId', position='Query'),
  vaultStorageClass?: string(name='VaultStorageClass', position='Query'),
}

model CreateReplicationVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  vaultId?: string(name='VaultId'),
}

model CreateReplicationVaultResponse = {
  headers: map[string]string(name='headers'),
  body: CreateReplicationVaultResponseBody(name='body'),
}

async function createReplicationVault(request: CreateReplicationVaultRequest): CreateReplicationVaultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateReplicationVault', 'POST', '/', 'json', false, 'json', request);
}

model CreateRestoreJobRequest {
  exclude?: string(name='Exclude', position='Body'),
  include?: string(name='Include', position='Body'),
  otsDetail?: {
    batchChannelCount?: int32(name='BatchChannelCount'),
    overwriteExisting?: boolean(name='OverwriteExisting'),
  }(name='OtsDetail', position='Body'),
  restoreType: string(name='RestoreType', position='Query'),
  snapshotHash?: string(name='SnapshotHash', position='Query'),
  snapshotId?: string(name='SnapshotId', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
  targetBucket?: string(name='TargetBucket', position='Query'),
  targetCreateTime?: long(name='TargetCreateTime', position='Query'),
  targetFileSystemId?: string(name='TargetFileSystemId', position='Query'),
  targetInstanceId?: string(name='TargetInstanceId', position='Body'),
  targetInstanceName?: string(name='TargetInstanceName', position='Query'),
  targetPath?: string(name='TargetPath', position='Body'),
  targetPrefix?: string(name='TargetPrefix', position='Query'),
  targetTableName?: string(name='TargetTableName', position='Query'),
  targetTime?: long(name='TargetTime', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model CreateRestoreJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  restoreId?: string(name='RestoreId'),
  success?: boolean(name='Success'),
}

model CreateRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  body: CreateRestoreJobResponseBody(name='body'),
}

async function createRestoreJob(request: CreateRestoreJobRequest): CreateRestoreJobResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateRestoreJob', 'POST', '/', 'json', true, 'form', request);
}

model CreateVaultRequest {
  bucketName?: string(name='BucketName', position='Query'),
  compressionAlgorithm?: string(name='CompressionAlgorithm', position='Query'),
  description?: string(name='Description', position='Query'),
  endpoint?: string(name='Endpoint', position='Query'),
  redundancyType?: string(name='RedundancyType', position='Query'),
  vaultAccessKeyId?: string(name='VaultAccessKeyId', position='Query'),
  vaultAccessKeySecret?: string(name='VaultAccessKeySecret', position='Query'),
  vaultName: string(name='VaultName', position='Query'),
  vaultRegionId: string(name='VaultRegionId', position='Query'),
  vaultStorageClass?: string(name='VaultStorageClass', position='Query'),
  vaultType?: string(name='VaultType', position='Query'),
}

model CreateVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  vaultId?: string(name='VaultId'),
}

model CreateVaultResponse = {
  headers: map[string]string(name='headers'),
  body: CreateVaultResponseBody(name='body'),
}

async function createVault(request: CreateVaultRequest): CreateVaultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'CreateVault', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupClientRequest {
  clientId: string(name='ClientId', position='Query'),
}

model DeleteBackupClientResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupClientResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBackupClientResponseBody(name='body'),
}

async function deleteBackupClient(request: DeleteBackupClientRequest): DeleteBackupClientResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackupClient', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupClientResourceRequest {
  clientIds: map[string]any(name='ClientIds', position='Query'),
}

model DeleteBackupClientResourceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupClientResourceResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBackupClientResourceResponseBody(name='body'),
}

async function deleteBackupClientResource(request: DeleteBackupClientResourceRequest): DeleteBackupClientResourceResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackupClientResource', 'POST', '/', 'json', false, 'json', request);
}

model DeleteBackupPlanRequest {
  planId: string(name='PlanId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model DeleteBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteBackupPlanResponseBody(name='body'),
}

async function deleteBackupPlan(request: DeleteBackupPlanRequest): DeleteBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model DeleteSnapshotRequest {
  clientId?: string(name='ClientId', position='Query'),
  force?: boolean(name='Force', position='Query'),
  instanceId?: string(name='InstanceId', position='Query'),
  snapshotId: string(name='SnapshotId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  token?: string(name='Token', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model DeleteSnapshotResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteSnapshot', 'POST', '/', 'json', false, 'json', request);
}

model DeleteVaultRequest {
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  token?: string(name='Token', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model DeleteVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVaultResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteVaultResponseBody(name='body'),
}

async function deleteVault(request: DeleteVaultRequest): DeleteVaultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DeleteVault', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', position='Body'),
  clientType: string(name='ClientType', position='Query'),
  instanceIds?: map[string]any(name='InstanceIds', position='Body'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Body'),
}

model DescribeBackupClientsResponseBody = {
  clients?: [ 
    {
      appliance?: boolean(name='Appliance'),
      archType?: string(name='ArchType'),
      backupStatus?: string(name='BackupStatus'),
      clientId?: string(name='ClientId'),
      clientType?: string(name='ClientType'),
      clientVersion?: string(name='ClientVersion'),
      createdTime?: long(name='CreatedTime'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      maxClientVersion?: string(name='MaxClientVersion'),
      osType?: string(name='OsType'),
      privateIpV4?: string(name='PrivateIpV4'),
      settings?: {
        dataNetworkType?: string(name='DataNetworkType'),
        dataProxySetting?: string(name='DataProxySetting'),
        maxCpuCore?: string(name='MaxCpuCore'),
        maxWorker?: string(name='MaxWorker'),
        proxyHost?: string(name='ProxyHost'),
        proxyPassword?: string(name='ProxyPassword'),
        proxyPort?: int32(name='ProxyPort'),
        proxyUser?: string(name='ProxyUser'),
        useHttps?: string(name='UseHttps'),
      }(name='Settings'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      updatedTime?: long(name='UpdatedTime'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Clients'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupClientsResponseBody(name='body'),
}

async function describeBackupClients(request: DescribeBackupClientsRequest): DescribeBackupClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupClients', 'POST', '/', 'json', true, 'form', request);
}

model DescribeBackupJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  sortDirection?: string(name='SortDirection', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
}

model DescribeBackupJobs2ResponseBody = {
  backupJobs?: {
    backupJob?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      errorMessage?: string(name='ErrorMessage'),
      exclude?: string(name='Exclude'),
      fileSystemId?: string(name='FileSystemId'),
      include?: string(name='Include'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      options?: string(name='Options'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames'),
      }(name='OtsDetail'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      planId?: string(name='PlanId'),
      prefix?: string(name='Prefix'),
      progress?: int32(name='Progress'),
      sourceType?: string(name='SourceType'),
      speed?: long(name='Speed'),
      speedLimit?: string(name='SpeedLimit'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      tableName?: string(name='TableName'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='BackupJob')
  }(name='BackupJobs'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupJobs2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupJobs2ResponseBody(name='body'),
}

async function describeBackupJobs2(request: DescribeBackupJobs2Request): DescribeBackupJobs2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupJobs2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeBackupPlansRequest {
  filters?: [ 
    {
      key?: string(name='Key'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  sourceType: string(name='SourceType', position='Query'),
}

model DescribeBackupPlansResponseBody = {
  backupPlans?: {
    backupPlan?: [ 
    {
      backupSourceGroupId?: string(name='BackupSourceGroupId'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      clientId?: string(name='ClientId'),
      clusterId?: string(name='ClusterId'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      dataSourceId?: string(name='DataSourceId'),
      detail?: string(name='Detail'),
      disabled?: boolean(name='Disabled'),
      exclude?: string(name='Exclude'),
      fileSystemId?: string(name='FileSystemId'),
      include?: string(name='Include'),
      instanceGroupId?: string(name='InstanceGroupId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      options?: string(name='Options'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames'),
      }(name='OtsDetail'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      planId?: string(name='PlanId'),
      planName?: string(name='PlanName'),
      prefix?: string(name='Prefix'),
      resources?: {
        resource?: [ 
        {
          extra?: string(name='Extra'),
          resourceId?: string(name='ResourceId'),
          sourceType?: string(name='SourceType'),
        }
      ](name='Resource')
      }(name='Resources'),
      retention?: long(name='Retention'),
      rules?: {
        rule?: [ 
        {
          backupType?: string(name='BackupType'),
          destinationRegionId?: string(name='DestinationRegionId'),
          destinationRetention?: long(name='DestinationRetention'),
          disabled?: boolean(name='Disabled'),
          doCopy?: boolean(name='DoCopy'),
          retention?: long(name='Retention'),
          ruleId?: string(name='RuleId'),
          ruleName?: string(name='RuleName'),
          schedule?: string(name='Schedule'),
        }
      ](name='Rule')
      }(name='Rules'),
      schedule?: string(name='Schedule'),
      sourceType?: string(name='SourceType'),
      speedLimit?: string(name='SpeedLimit'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration'),
        trialExpireTime?: long(name='TrialExpireTime'),
        trialStartTime?: long(name='TrialStartTime'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime'),
      }(name='TrialInfo'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='BackupPlan')
  }(name='BackupPlans'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupPlansResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeBackupPlansResponseBody(name='body'),
}

async function describeBackupPlans(request: DescribeBackupPlansRequest): DescribeBackupPlansResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeBackupPlans', 'POST', '/', 'json', false, 'json', request);
}

model DescribeOtsTableSnapshotsRequest {
  endTime?: long(name='EndTime', position='Body'),
  limit?: int32(name='Limit', position='Body'),
  nextToken?: string(name='NextToken', position='Body'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      tableNames?: [ string ](name='TableNames'),
    }
  ](name='OtsInstances', position='Body'),
  snapshotIds?: [ string ](name='SnapshotIds', position='Body'),
  startTime?: long(name='StartTime', position='Body'),
}

model DescribeOtsTableSnapshotsResponseBody = {
  code?: string(name='Code'),
  limit?: int32(name='Limit'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      actualBytes?: string(name='ActualBytes'),
      backupType?: string(name='BackupType'),
      bytesTotal?: long(name='BytesTotal'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      instanceName?: string(name='InstanceName'),
      jobId?: string(name='JobId'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      rangeEnd?: long(name='RangeEnd'),
      rangeStart?: long(name='RangeStart'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      tableName?: string(name='TableName'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Snapshots'),
  success?: boolean(name='Success'),
}

model DescribeOtsTableSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeOtsTableSnapshotsResponseBody(name='body'),
}

async function describeOtsTableSnapshots(request: DescribeOtsTableSnapshotsRequest): DescribeOtsTableSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeOtsTableSnapshots', 'POST', '/', 'json', true, 'form', request);
}

model DescribeRecoverableOtsInstancesRequest {
}

model DescribeRecoverableOtsInstancesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      tableNames?: [ string ](name='TableNames'),
    }
  ](name='OtsInstances'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRecoverableOtsInstancesResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRecoverableOtsInstancesResponseBody(name='body'),
}

async function describeRecoverableOtsInstances(request: DescribeRecoverableOtsInstancesRequest): DescribeRecoverableOtsInstancesResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRecoverableOtsInstances', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRegionsRequest {
  needVaultCount?: boolean(name='NeedVaultCount', position='Query'),
}

model DescribeRegionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
      vaultCount?: int32(name='VaultCount'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeRestoreJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters', position='Query'),
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  restoreType?: string(name='RestoreType', position='Query'),
}

model DescribeRestoreJobs2ResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  restoreJobs?: {
    restoreJob?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clusterId?: string(name='ClusterId'),
      completeTime?: long(name='CompleteTime'),
      createdTime?: long(name='CreatedTime'),
      errorFile?: string(name='ErrorFile'),
      errorMessage?: string(name='ErrorMessage'),
      exclude?: string(name='Exclude'),
      expireTime?: long(name='ExpireTime'),
      include?: string(name='Include'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      options?: string(name='Options'),
      parentId?: string(name='ParentId'),
      progress?: int32(name='Progress'),
      restoreId?: string(name='RestoreId'),
      restoreType?: string(name='RestoreType'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      speed?: long(name='Speed'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      targetBucket?: string(name='TargetBucket'),
      targetClientId?: string(name='TargetClientId'),
      targetCreateTime?: long(name='TargetCreateTime'),
      targetDataSourceId?: string(name='TargetDataSourceId'),
      targetFileSystemId?: string(name='TargetFileSystemId'),
      targetInstanceId?: string(name='TargetInstanceId'),
      targetInstanceName?: string(name='TargetInstanceName'),
      targetPath?: string(name='TargetPath'),
      targetPrefix?: string(name='TargetPrefix'),
      targetTableName?: string(name='TargetTableName'),
      targetTime?: long(name='TargetTime'),
      udmDetail?: string(name='UdmDetail'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='RestoreJob')
  }(name='RestoreJobs'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRestoreJobs2Response = {
  headers: map[string]string(name='headers'),
  body: DescribeRestoreJobs2ResponseBody(name='body'),
}

async function describeRestoreJobs2(request: DescribeRestoreJobs2Request): DescribeRestoreJobs2Response {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeRestoreJobs2', 'POST', '/', 'json', false, 'json', request);
}

model DescribeTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  taskId?: string(name='TaskId', position='Query'),
  token?: string(name='Token', position='Query'),
}

model DescribeTaskResponseBody = {
  code?: string(name='Code'),
  completedTime?: long(name='CompletedTime'),
  createdTime?: long(name='CreatedTime'),
  description?: string(name='Description'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
  updatedTime?: long(name='UpdatedTime'),
}

model DescribeTaskResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeTaskResponseBody(name='body'),
}

async function describeTask(request: DescribeTaskRequest): DescribeTaskResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeTask', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVaultReplicationRegionsRequest {
  token?: string(name='Token', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model DescribeVaultReplicationRegionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  regions?: {
    regionId?: [ string ](name='RegionId')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeVaultReplicationRegionsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVaultReplicationRegionsResponseBody(name='body'),
}

async function describeVaultReplicationRegions(request: DescribeVaultReplicationRegionsRequest): DescribeVaultReplicationRegionsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVaultReplicationRegions', 'POST', '/', 'json', false, 'json', request);
}

model DescribeVaultsRequest {
  pageNumber?: int32(name='PageNumber', minimum=1, position='Query'),
  pageSize?: int32(name='PageSize', minimum=1, maximum=100, position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  status?: string(name='Status', position='Query'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag', position='Body'),
  vaultId?: string(name='VaultId', position='Query'),
  vaultRegionId?: string(name='VaultRegionId', position='Query'),
  vaultType?: string(name='VaultType', position='Query'),
}

model DescribeVaultsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  vaults?: {
    vault?: [ 
    {
      backupPlanStatistics?: {
        commonNas?: int32(name='CommonNas'),
        csg?: int32(name='Csg'),
        ecsFile?: int32(name='EcsFile'),
        ecsHana?: int32(name='EcsHana'),
        isilon?: int32(name='Isilon'),
        localFile?: int32(name='LocalFile'),
        localVm?: int32(name='LocalVm'),
        mySql?: int32(name='MySql'),
        nas?: int32(name='Nas'),
        oracle?: int32(name='Oracle'),
        oss?: int32(name='Oss'),
        ots?: int32(name='Ots'),
        sqlServer?: int32(name='SqlServer'),
      }(name='BackupPlanStatistics'),
      bucketName?: string(name='BucketName'),
      bytesDone?: long(name='BytesDone'),
      chargeType?: string(name='ChargeType'),
      compressionAlgorithm?: string(name='CompressionAlgorithm'),
      createdTime?: long(name='CreatedTime'),
      dedup?: boolean(name='Dedup'),
      description?: string(name='Description'),
      encryptType?: string(name='EncryptType'),
      endpoint?: {
        classic?: string(name='Classic'),
        pub?: string(name='Pub'),
        vpc?: string(name='Vpc'),
      }(name='Endpoint'),
      indexAvailable?: boolean(name='IndexAvailable'),
      indexLevel?: string(name='IndexLevel'),
      indexUpdateTime?: long(name='IndexUpdateTime'),
      latestReplicationTime?: long(name='LatestReplicationTime'),
      redundancyType?: string(name='RedundancyType'),
      replication?: boolean(name='Replication'),
      replicationProgress?: {
        historicalReplicationProgress?: int32(name='HistoricalReplicationProgress'),
        newReplicationProgress?: long(name='NewReplicationProgress'),
      }(name='ReplicationProgress'),
      replicationSourceRegionId?: string(name='ReplicationSourceRegionId'),
      replicationSourceVaultId?: string(name='ReplicationSourceVaultId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      retention?: long(name='Retention'),
      searchEnabled?: boolean(name='SearchEnabled'),
      snapshotCount?: long(name='SnapshotCount'),
      sourceTypes?: {
        sourceType?: [ string ](name='SourceType')
      }(name='SourceTypes'),
      status?: string(name='Status'),
      storageSize?: long(name='StorageSize'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration'),
        trialExpireTime?: long(name='TrialExpireTime'),
        trialStartTime?: long(name='TrialStartTime'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime'),
      }(name='TrialInfo'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
      vaultName?: string(name='VaultName'),
      vaultRegionId?: string(name='VaultRegionId'),
      vaultStatusMessage?: string(name='VaultStatusMessage'),
      vaultStorageClass?: string(name='VaultStorageClass'),
      vaultType?: string(name='VaultType'),
      wormEnabled?: boolean(name='WormEnabled'),
    }
  ](name='Vault')
  }(name='Vaults'),
}

model DescribeVaultsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeVaultsResponseBody(name='body'),
}

async function describeVaults(request: DescribeVaultsRequest): DescribeVaultsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DescribeVaults', 'POST', '/', 'json', true, 'form', request);
}

model DetachNasFileSystemRequest {
  createTime: string(name='CreateTime', position='Query'),
  fileSystemId: string(name='FileSystemId', position='Query'),
}

model DetachNasFileSystemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model DetachNasFileSystemResponse = {
  headers: map[string]string(name='headers'),
  body: DetachNasFileSystemResponseBody(name='body'),
}

async function detachNasFileSystem(request: DetachNasFileSystemRequest): DetachNasFileSystemResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DetachNasFileSystem', 'POST', '/', 'json', false, 'json', request);
}

model DisableBackupPlanRequest {
  planId: string(name='PlanId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model DisableBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: DisableBackupPlanResponseBody(name='body'),
}

async function disableBackupPlan(request: DisableBackupPlanRequest): DisableBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'DisableBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model EnableBackupPlanRequest {
  planId: string(name='PlanId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model EnableBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: EnableBackupPlanResponseBody(name='body'),
}

async function enableBackupPlan(request: EnableBackupPlanRequest): EnableBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'EnableBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model ExecuteBackupPlanRequest {
  planId: string(name='PlanId', position='Query'),
  ruleId?: string(name='RuleId', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model ExecuteBackupPlanResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: ExecuteBackupPlanResponseBody(name='body'),
}

async function executeBackupPlan(request: ExecuteBackupPlanRequest): ExecuteBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'ExecuteBackupPlan', 'POST', '/', 'json', false, 'json', request);
}

model GenerateRamPolicyRequest {
  actionType: string(name='ActionType', position='Query'),
  requireBasePolicy?: boolean(name='RequireBasePolicy', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  vaultId: string(name='VaultId', position='Query'),
}

model GenerateRamPolicyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  policyDocument?: string(name='PolicyDocument'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateRamPolicyResponse = {
  headers: map[string]string(name='headers'),
  body: GenerateRamPolicyResponseBody(name='body'),
}

async function generateRamPolicy(request: GenerateRamPolicyRequest): GenerateRamPolicyResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'GenerateRamPolicy', 'POST', '/', 'json', false, 'json', request);
}

model InstallBackupClientsRequest {
  instanceIds: map[string]any(name='InstanceIds', position='Query'),
}

model InstallBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model InstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  body: InstallBackupClientsResponseBody(name='body'),
}

async function installBackupClients(request: InstallBackupClientsRequest): InstallBackupClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'InstallBackupClients', 'POST', '/', 'json', false, 'json', request);
}

model SearchHistoricalSnapshotsRequest {
  limit?: int32(name='Limit', position='Query'),
  nextToken?: string(name='NextToken', position='Query'),
  query?: map[string]any(name='Query', position='Query'),
  sourceType: string(name='SourceType', position='Query'),
}

model SearchHistoricalSnapshotsResponseBody = {
  code?: string(name='Code'),
  limit?: int32(name='Limit'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: {
    snapshot?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      errorFile?: string(name='ErrorFile'),
      fileSystemId?: string(name='FileSystemId'),
      instanceId?: string(name='InstanceId'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      jobId?: string(name='JobId'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      path?: string(name='Path'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      prefix?: string(name='Prefix'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Snapshot')
  }(name='Snapshots'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model SearchHistoricalSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  body: SearchHistoricalSnapshotsResponseBody(name='body'),
}

async function searchHistoricalSnapshots(request: SearchHistoricalSnapshotsRequest): SearchHistoricalSnapshotsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'SearchHistoricalSnapshots', 'POST', '/', 'json', false, 'json', request);
}

model UninstallBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', position='Query'),
  instanceIds?: map[string]any(name='InstanceIds', position='Query'),
}

model UninstallBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UninstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  body: UninstallBackupClientsResponseBody(name='body'),
}

async function uninstallBackupClients(request: UninstallBackupClientsRequest): UninstallBackupClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UninstallBackupClients', 'POST', '/', 'json', false, 'json', request);
}

model UpdateBackupPlanRequest {
  exclude?: string(name='Exclude', position='Body'),
  include?: string(name='Include', position='Body'),
  options?: string(name='Options', position='Body'),
  otsDetail?: OtsDetail(name='OtsDetail', position='Body'),
  path?: [ string ](name='Path', position='Query'),
  planId: string(name='PlanId', position='Query'),
  planName?: string(name='PlanName', position='Query'),
  prefix?: string(name='Prefix', position='Query'),
  retention?: long(name='Retention', position='Query'),
  schedule?: string(name='Schedule', position='Query'),
  sourceType?: string(name='SourceType', position='Query'),
  speedLimit?: string(name='SpeedLimit', position='Query'),
  updatePaths?: boolean(name='UpdatePaths', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model UpdateBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateBackupPlanResponseBody(name='body'),
}

async function updateBackupPlan(request: UpdateBackupPlanRequest): UpdateBackupPlanResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateBackupPlan', 'POST', '/', 'json', true, 'form', request);
}

model UpdateClientSettingsRequest {
  clientId: string(name='ClientId', position='Query'),
  dataNetworkType?: string(name='DataNetworkType', position='Query'),
  dataProxySetting?: string(name='DataProxySetting', position='Query'),
  maxCpuCore?: int32(name='MaxCpuCore', minimum=0, maximum=999, position='Query'),
  maxWorker?: int32(name='MaxWorker', minimum=0, maximum=999, position='Query'),
  proxyHost?: string(name='ProxyHost', position='Query'),
  proxyPassword?: string(name='ProxyPassword', position='Query'),
  proxyPort?: int32(name='ProxyPort', minimum=1, maximum=65536, position='Query'),
  proxyUser?: string(name='ProxyUser', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  useHttps?: boolean(name='UseHttps', position='Query'),
  vaultId?: string(name='VaultId', position='Query'),
}

model UpdateClientSettingsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClientSettingsResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateClientSettingsResponseBody(name='body'),
}

async function updateClientSettings(request: UpdateClientSettingsRequest): UpdateClientSettingsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateClientSettings', 'POST', '/', 'json', false, 'json', request);
}

model UpdateVaultRequest {
  description?: string(name='Description', position='Query'),
  resourceGroupId?: string(name='ResourceGroupId', position='Query'),
  vaultId: string(name='VaultId', position='Query'),
  vaultName?: string(name='VaultName', position='Query'),
}

model UpdateVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateVaultResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateVaultResponseBody(name='body'),
}

async function updateVault(request: UpdateVaultRequest): UpdateVaultResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpdateVault', 'POST', '/', 'json', false, 'json', request);
}

model UpgradeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', position='Query'),
  instanceIds?: map[string]any(name='InstanceIds', position='Query'),
}

model UpgradeBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UpgradeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  body: UpgradeBackupClientsResponseBody(name='body'),
}

async function upgradeBackupClients(request: UpgradeBackupClientsRequest): UpgradeBackupClientsResponse {
  @handler.validateRequestModel(request);
  return @handler.do('RPC', 'UpgradeBackupClients', 'POST', '/', 'json', false, 'json', request);
}

