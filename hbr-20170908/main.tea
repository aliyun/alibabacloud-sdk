/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'hbr.aliyuncs.com',
    cn-beijing-finance-1 = 'hbr.aliyuncs.com',
    cn-beijing-finance-pop = 'hbr.aliyuncs.com',
    cn-beijing-gov-1 = 'hbr.aliyuncs.com',
    cn-beijing-nu16-b01 = 'hbr.aliyuncs.com',
    cn-edge-1 = 'hbr.aliyuncs.com',
    cn-fujian = 'hbr.aliyuncs.com',
    cn-haidian-cm12-c01 = 'hbr.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'hbr.aliyuncs.com',
    cn-hangzhou-test-306 = 'hbr.aliyuncs.com',
    cn-hongkong-finance-pop = 'hbr.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'hbr.aliyuncs.com',
    cn-qingdao-nebula = 'hbr.aliyuncs.com',
    cn-shanghai-et15-b01 = 'hbr.aliyuncs.com',
    cn-shanghai-et2-b01 = 'hbr.aliyuncs.com',
    cn-shanghai-inner = 'hbr.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'hbr.aliyuncs.com',
    cn-shenzhen-inner = 'hbr.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'hbr.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'hbr.aliyuncs.com',
    cn-wuhan = 'hbr.aliyuncs.com',
    cn-wulanchabu = 'hbr.aliyuncs.com',
    cn-yushanfang = 'hbr.aliyuncs.com',
    cn-zhangbei = 'hbr.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'hbr.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'hbr.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'hbr.aliyuncs.com',
    eu-west-1-oxs = 'hbr.aliyuncs.com',
    rus-west-1-pop = 'hbr.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('hbr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model OtsDetail {
  tableNames?: [ string ](name='TableNames'),
}

model OtsTableRestoreDetail {
  batchChannelCount?: int32(name='BatchChannelCount'),
  indexNameSuffix?: string(name='IndexNameSuffix'),
  overwriteExisting?: boolean(name='OverwriteExisting'),
  reGenerateAutoIncrementPK?: boolean(name='ReGenerateAutoIncrementPK'),
  restoreIndex?: boolean(name='RestoreIndex'),
  restoreSearchIndex?: boolean(name='RestoreSearchIndex'),
  searchIndexNameSuffix?: string(name='SearchIndexNameSuffix'),
}

model Report {
  failedFiles?: string(name='FailedFiles', example='temp/report/r-0000dnz7p4pk31u6madf_failed.csv'),
  skippedFiles?: string(name='SkippedFiles', example='temp/report/r-0000dnz7p4pk31u6madf_skipped.csv'),
  successFiles?: string(name='SuccessFiles', example='temp/report/r-0000dnz7p4pk31u6madf_success.csv'),
  totalFiles?: string(name='TotalFiles', example='temp/report/r-0000dnz7p4pk31u6madf_total.csv'),
}

model Rule {
  backupType?: string(name='BackupType'),
  destinationRegionId?: string(name='DestinationRegionId'),
  destinationRetention?: long(name='DestinationRetention'),
  disabled?: boolean(name='Disabled'),
  doCopy?: boolean(name='DoCopy'),
  retention?: long(name='Retention'),
  ruleName?: string(name='RuleName'),
  schedule?: string(name='Schedule'),
}

model AddContainerClusterRequest {
  clusterType?: string(name='ClusterType', description='Cluster type, which only supports ACK, that indicates Alibaba Cloud Container Service.', example='ACK'),
  description?: string(name='Description', description='The description of cluster.', example='description ack pv backup'),
  identifier?: string(name='Identifier', description='Cluster ID.', example='cca8f35f0e0d84540b49d994511c2c87a'),
  name?: string(name='Name', description='Cluster name.', example='ack_pv_backup_location'),
  networkType?: string(name='NetworkType', description='Network type, values includes:

- CLASSIC: classic network.
- VPC: virtual private cloud.', example='VPC'),
}

model AddContainerClusterResponseBody = {
  clusterId?: string(name='ClusterId', description='The cluster id.', example='cc-00049slr9iuvvv6pp134'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='1FCBC078-FFCB-542A-8555-566477679720'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

- true: indicates that the request is successful.
- false: indicates that the request fails.', example='true'),
  token?: string(name='Token', description='The token.', example='eyJhY2NvdW*****VnZpgXQC5A=='),
}

model AddContainerClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddContainerClusterResponseBody(name='body'),
}

async function addContainerClusterWithOptions(request: AddContainerClusterRequest, runtime: Util.RuntimeOptions): AddContainerClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addContainerCluster(request: AddContainerClusterRequest): AddContainerClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerClusterWithOptions(request, runtime);
}

model CancelBackupJobRequest {
  jobId?: string(name='JobId', description='The ID of the backup job.', example='j-******************************'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*****************************'),
}

model CancelBackupJobResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model CancelBackupJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelBackupJobResponseBody(name='body'),
}

async function cancelBackupJobWithOptions(request: CancelBackupJobRequest, runtime: Util.RuntimeOptions): CancelBackupJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelBackupJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelBackupJob(request: CancelBackupJobRequest): CancelBackupJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelBackupJobWithOptions(request, runtime);
}

model CancelRestoreJobRequest {
  restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='r-*********************'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model CancelRestoreJobResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The value 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model CancelRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelRestoreJobResponseBody(name='body'),
}

async function cancelRestoreJobWithOptions(request: CancelRestoreJobRequest, runtime: Util.RuntimeOptions): CancelRestoreJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.restoreId)) {
    query['RestoreId'] = request.restoreId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelRestoreJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelRestoreJob(request: CancelRestoreJobRequest): CancelRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelRestoreJobWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId', description='The ID of the new resource group. You can view the available resource groups in the Resource Management console.', example='rg-bp67acfmxazb4p****'),
  resourceId?: string(name='ResourceId', description='The ID of the resource. The value of this parameter varies with the resource type. For example, if the ResourceType parameter is set to vault, the ResourceId parameter specifies the ID of the backup vault.', example='v-0002vido6j5zyh5k****'),
  resourceType?: string(name='ResourceType', description='The type of the resource. Valid values:

*   **vault**: backup vault
*   **client**: backup client
*   **hanainstance**: SAP HANA instance', example='vault'),
}

model ChangeResourceGroupResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='C438054F-9088-5D1B-AED0-0EA86D9C65F4'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

/**
  * *   In the Hybrid Backup Recovery (HBR), you can use resource groups to manage resources such as backup vaults, backup clients, and SAP HANA instances.
  * *   A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, a backup vault, or an SAP HANA instance.
  * *   You can sort resources owned by your Alibaba Cloud account into various resource groups. This facilitates resource management among multiple projects or applications within your Alibaba Cloud account and simplifies permission management.
  *
  * @param request ChangeResourceGroupRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    body['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   In the Hybrid Backup Recovery (HBR), you can use resource groups to manage resources such as backup vaults, backup clients, and SAP HANA instances.
  * *   A resource is a cloud service entity that you create on Alibaba Cloud, such as an ECS instance, a backup vault, or an SAP HANA instance.
  * *   You can sort resources owned by your Alibaba Cloud account into various resource groups. This facilitates resource management among multiple projects or applications within your Alibaba Cloud account and simplifies permission management.
  *
  * @param request ChangeResourceGroupRequest
  * @return ChangeResourceGroupResponse
 */
async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateBackupJobRequest {
  backupType?: string(name='BackupType', description='The backup type. Valid value: 

- **COMPLETE**:  full backup.
- **INCREMENTAL**: incremental backup.', example='INCREMENTAL'),
  clusterId?: string(name='ClusterId', description='The ID of a cluster.', example='cl-00068btz******oku'),
  containerClusterId?: string(name='ContainerClusterId', description='The cluster id of container.', example='cc-000f23fcdspg5a6x4i00'),
  containerResources?: string(name='ContainerResources', description='The information about container resources.', example='[{\\"resourceType\\":\\"PV\\",\\"backupMethod\\":\\"FILE\\",\\"resourceId\\":\\"674dac6d-74cd-47e9-a675-09e2f10d2c45\\",\\"resourceInfo\\":\\"{\\\\\\"pv_name\\\\\\":\\\\\\"nas-650dac6d-74cd-47e9-a675-09e2f10d2c45\\\\\\",\\\\\\"pv_size\\\\\\":\\\\\\"8Gi\\\\\\",\\\\\\"storage_class\\\\\\":\\\\\\"alibabacloud-cnfs-nas\\\\\\",\\\\\\"pvc_name\\\\\\":\\\\\\"data-postgresql-default-0\\\\\\",\\\\\\"namespace\\\\\\":\\\\\\"database\\\\\\"}\\",\\"host\\":\\"cn-huhehaote.192.168.13.133\\",\\"hostPrefix\\":\\"6f5e758e-8d35-4584-b9ce-8333adfc7547/volumes/kubernetes.io~csi/nas-670dac6d-74cd-47e9-a675-09e2f10d2c45/mount\\",\\"pvPath\\":\\"/\\"}]'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  exclude?: string(name='Exclude', description='This parameter indicates the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  include?: string(name='Include', description='The paths to the files that are included in the backup job.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  initiatedByAck?: boolean(name='InitiatedByAck'),
  instanceId?: string(name='InstanceId'),
  jobName?: string(name='JobName', description='The name of a backup job.', example='k8s-backup-infra-20220131150046-hbr'),
  options?: string(name='Options', description='This parameter indicates whether Windows VSS is used to define a backup path.

- This parameter is available only for Windows ECS instances.
- If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to ` ["UseVSS":true]`.
- If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
  retention?: long(name='Retention', description='The retention period of backup data.', example='15'),
  sourceType?: string(name='SourceType', description='The backup type. Valid value: **CONTAINER**, which indicates container backup.', example='CONTAINER'),
  speedLimit?: string(name='SpeedLimit', description='This parameter indicates the throttling rules. Format: `{start}{end}{bandwidth}`. Multiple throttling rules are separated with vertical bars `({start}|{end}|{bandwidth})`. A specified time range cannot overlap with another one.

- **start**: the start hour
- **end**: the end hour
- **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:NaN'),
  vaultId?: string(name='VaultId', description='The ID of a vault.', example='v-000h3tvhlkali7o5xy1v'),
}

model CreateBackupJobResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  jobId?: string(name='JobId', description='The ID of the backup job.', example='job-000csy09q50a2jdcbwbo'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='25F49E7B-7E39-542E-83AD-62E6E7F73786'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

- true: The call is successful.
- false: The call fails.', example='true'),
}

model CreateBackupJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupJobResponseBody(name='body'),
}

async function createBackupJobWithOptions(request: CreateBackupJobRequest, runtime: Util.RuntimeOptions): CreateBackupJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerClusterId)) {
    query['ContainerClusterId'] = request.containerClusterId;
  }
  if (!Util.isUnset(request.containerResources)) {
    query['ContainerResources'] = request.containerResources;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.exclude)) {
    query['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    query['Include'] = request.include;
  }
  if (!Util.isUnset(request.initiatedByAck)) {
    query['InitiatedByAck'] = request.initiatedByAck;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobName)) {
    query['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.speedLimit)) {
    query['SpeedLimit'] = request.speedLimit;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupJob(request: CreateBackupJobRequest): CreateBackupJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupJobWithOptions(request, runtime);
}

model CreateBackupPlanRequest {
  backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
  bucket?: string(name='Bucket', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies the name of the OSS bucket.', example='hbr-backup-oss'),
  createTime?: long(name='CreateTime', description='This parameter is required only if the **SourceType** parameter is set to **NAS**. This parameter specifies the time to create the file system. This value must be a UNIX timestamp. Unit: seconds.', example='1607436917'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  detail?: map[string]any(name='Detail', description='The detail about the ECS instance backup, the format of value type is JSON.

* snapshotGroup: whether to use a snapshot-consistent group (only enhanced SSDs (ESSDs)).
* appConsistent:  whether to enable the application-consistent backup feature (use with preScriptPath and postScriptPath only).
* preScriptPath: the pre-freeze scripts path.
* postScriptPath: the post-thaw scripts path.', example='{\\"EnableFsFreeze\\":true,\\"appConsistent\\":false,\\"postScriptPath\\":\\"\\",\\"preScriptPath\\":\\"\\",\\"snapshotGroup\\":true,\\"timeoutInSeconds\\":60}'),
  exclude?: string(name='Exclude', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  fileSystemId?: string(name='FileSystemId', description='This parameter is required only if the **SourceType** parameter is set to **NAS**. This parameter specifies the ID of the NAS file system.', example='005494'),
  include?: string(name='Include', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that you want to back up. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  instanceId?: string(name='InstanceId', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the ID of the ECS instance.', example='i-m5e*****6q'),
  instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
  keepLatestSnapshots?: long(name='KeepLatestSnapshots'),
  options?: string(name='Options', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies whether to use Windows VSS to define a backup path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
  otsDetail?: OtsDetail(name='OtsDetail', description='The details about the Tablestore instance.'),
  path?: [ string ](name='Path', description='The backup paths.'),
  planName?: string(name='PlanName', description='The name of the backup plan. The name must be 1 to 64 characters in length. The name of a backup plan for each type of data source must be unique within a backup vault.', example='planname'),
  prefix?: string(name='Prefix', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies a prefix. After a prefix is specified, only objects whose names start with the prefix are backed up.', example='oss-prefix'),
  retention?: long(name='Retention', description='The retention period of backup data. Minimum value: 1. Unit: days.', example='7'),
  rule?: [ 
    {
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      destinationRegionId?: string(name='DestinationRegionId', description='The ID of the region where the remote backup vault resides.', example='cn-hangzhou'),
      destinationRetention?: long(name='DestinationRetention', description='The retention period of backup data.', example='7'),
      disabled?: boolean(name='Disabled', description='Indicates whether the policy is disabled.', example='false'),
      doCopy?: boolean(name='DoCopy', description='Indicates whether the snapshot data is backed up to the backup vault.', example='false'),
      retention?: long(name='Retention', description='The retention period of backup data.', example='7'),
      ruleName?: string(name='RuleName', description='The name of the policy.', example='rule-test-name'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='C|0|0 0 18 1 1 ?'),
    }
  ](name='Rule', description='The list of backup policies. This parameter is returned only for disk backup.'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
  speedLimit?: string(name='SpeedLimit', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the throttling rules. Format: `{start}|{end}|{bandwidth}`. Separate multiple throttling rules with vertical bars (|). A specified time range cannot overlap with another time range.

*   **start**: the start time.
*   **end**: the end time.
*   **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:5120'),
  udmRegionId?: string(name='UdmRegionId', description='The region id of an ECS instance backup.', example='cn-shanghai'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
}

model CreateBackupPlanShrinkRequest {
  backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
  bucket?: string(name='Bucket', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies the name of the OSS bucket.', example='hbr-backup-oss'),
  createTime?: long(name='CreateTime', description='This parameter is required only if the **SourceType** parameter is set to **NAS**. This parameter specifies the time to create the file system. This value must be a UNIX timestamp. Unit: seconds.', example='1607436917'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  detailShrink?: string(name='Detail', description='The detail about the ECS instance backup, the format of value type is JSON.

* snapshotGroup: whether to use a snapshot-consistent group (only enhanced SSDs (ESSDs)).
* appConsistent:  whether to enable the application-consistent backup feature (use with preScriptPath and postScriptPath only).
* preScriptPath: the pre-freeze scripts path.
* postScriptPath: the post-thaw scripts path.', example='{\\"EnableFsFreeze\\":true,\\"appConsistent\\":false,\\"postScriptPath\\":\\"\\",\\"preScriptPath\\":\\"\\",\\"snapshotGroup\\":true,\\"timeoutInSeconds\\":60}'),
  exclude?: string(name='Exclude', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  fileSystemId?: string(name='FileSystemId', description='This parameter is required only if the **SourceType** parameter is set to **NAS**. This parameter specifies the ID of the NAS file system.', example='005494'),
  include?: string(name='Include', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that you want to back up. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  instanceId?: string(name='InstanceId', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the ID of the ECS instance.', example='i-m5e*****6q'),
  instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
  keepLatestSnapshots?: long(name='KeepLatestSnapshots'),
  options?: string(name='Options', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies whether to use Windows VSS to define a backup path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
  otsDetailShrink?: string(name='OtsDetail', description='The details about the Tablestore instance.'),
  path?: [ string ](name='Path', description='The backup paths.'),
  planName?: string(name='PlanName', description='The name of the backup plan. The name must be 1 to 64 characters in length. The name of a backup plan for each type of data source must be unique within a backup vault.', example='planname'),
  prefix?: string(name='Prefix', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies a prefix. After a prefix is specified, only objects whose names start with the prefix are backed up.', example='oss-prefix'),
  retention?: long(name='Retention', description='The retention period of backup data. Minimum value: 1. Unit: days.', example='7'),
  rule?: [ 
    {
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      destinationRegionId?: string(name='DestinationRegionId', description='The ID of the region where the remote backup vault resides.', example='cn-hangzhou'),
      destinationRetention?: long(name='DestinationRetention', description='The retention period of backup data.', example='7'),
      disabled?: boolean(name='Disabled', description='Indicates whether the policy is disabled.', example='false'),
      doCopy?: boolean(name='DoCopy', description='Indicates whether the snapshot data is backed up to the backup vault.', example='false'),
      retention?: long(name='Retention', description='The retention period of backup data.', example='7'),
      ruleName?: string(name='RuleName', description='The name of the policy.', example='rule-test-name'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='C|0|0 0 18 1 1 ?'),
    }
  ](name='Rule', description='The list of backup policies. This parameter is returned only for disk backup.'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
  speedLimit?: string(name='SpeedLimit', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the throttling rules. Format: `{start}|{end}|{bandwidth}`. Separate multiple throttling rules with vertical bars (|). A specified time range cannot overlap with another time range.

*   **start**: the start time.
*   **end**: the end time.
*   **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:5120'),
  udmRegionId?: string(name='UdmRegionId', description='The region id of an ECS instance backup.', example='cn-shanghai'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
}

model CreateBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupPlanResponseBody(name='body'),
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param tmpReq CreateBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateBackupPlanResponse
 */
async function createBackupPlanWithOptions(tmpReq: CreateBackupPlanRequest, runtime: Util.RuntimeOptions): CreateBackupPlanResponse {
  Util.validateModel(tmpReq);
  var request = new CreateBackupPlanShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detail)) {
    request.detailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detail, 'Detail', 'json');
  }
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.detailShrink)) {
    query['Detail'] = request.detailShrink;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.keepLatestSnapshots)) {
    query['KeepLatestSnapshots'] = request.keepLatestSnapshots;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.rule)) {
    body['Rule'] = request.rule;
  }
  if (!Util.isUnset(request.speedLimit)) {
    body['SpeedLimit'] = request.speedLimit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param request CreateBackupPlanRequest
  * @return CreateBackupPlanResponse
 */
async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPlanWithOptions(request, runtime);
}

model CreateClientsRequest {
  alertSetting?: string(name='AlertSetting', description='The alert settings. Valid value: INHERITED, which indicates that the HBR client sends alert notifications by using the same method configured for the backup vault.', example='INHERITED'),
  clientInfo?: string(name='ClientInfo', description='The installation information of the HBR clients.', example='[  {    "instanceId": "i-bp116lr******te9q2",    "accessKeyId": "",    "accessKeySecret": "",    "clusterId": "cl-000csy09q******9rfz9",    "sourceTypes": [      "HANA"    ]  },  {    "instanceId": "i-bp116lrux******hte9q4",    "accessKeyId": "",    "accessKeySecret": "",    "clusterId": "cl-000csy09q5094vw9rfz9",    "sourceTypes": [      "HANA"    ]  }]'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aekzvx7d3c4kpny'),
  useHttps?: boolean(name='UseHttps', description='Specifies whether to transmit data over HTTPS. Valid values:

*   true: transmits data over HTTPS.
*   false: transmits data over HTTP.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0001ufe******kgm'),
}

model CreateClientsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  instanceStatuses?: {
    instanceStatus?: [ 
    {
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-2zegp3cdu******uj9i'),
      validInstance?: boolean(name='ValidInstance', description='Indicates whether an HBR client can be installed on the ECS instance. Valid values:

*   true: An HBR client can be installed on the ECS instance.
*   false: An HBR client cannot be installed on the ECS instance.', example='true'),
    }
  ](name='InstanceStatus')
  }(name='InstanceStatuses', description='The status of the ECS instance. If the status of an ECS instance cannot meet the requirements to install an HBR client and the value of the InstanceIds parameter is greater than 1, an error message is returned based on the value of this parameter.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4A8A9AE4-F798-5E6D-853E-10F9F5A1BD4E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous job. You can call the DescribeTask operation to query the execution result of the asynchronous job.', example='t-000h9x5t02vhyksf1x7k'),
}

model CreateClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClientsResponseBody(name='body'),
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and pricing of Hybrid Backup Recovery (HBR). For more information, see [Billable items and billing methods](~~89062~~).
  *
  * @param request CreateClientsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateClientsResponse
 */
async function createClientsWithOptions(request: CreateClientsRequest, runtime: Util.RuntimeOptions): CreateClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useHttps)) {
    query['UseHttps'] = request.useHttps;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * Before you call this operation, make sure that you fully understand the billing methods and pricing of Hybrid Backup Recovery (HBR). For more information, see [Billable items and billing methods](~~89062~~).
  *
  * @param request CreateClientsRequest
  * @return CreateClientsResponse
 */
async function createClients(request: CreateClientsRequest): CreateClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClientsWithOptions(request, runtime);
}

model CreateHanaBackupPlanRequest {
  backupPrefix?: string(name='BackupPrefix', description='The backup prefix.', example='DIFF_DATA_BACKUP'),
  backupType?: string(name='BackupType', description='The backup type. Valid values:

*   COMPLETE: full backup
*   INCREMENTAL: incremental backup
*   DIFFERENTIAL: differential backup', example='COMPLETE'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-00024vyjj9******v'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  planName?: string(name='PlanName', description='The name of the backup plan.', example='plan-20220110-113108'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmvnf22m7itha'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval must follow the ISO 8601 standard. For example, PT1H specifies an interval of 1 hour. P1D specifies an interval of one day.', example='I|1602673264|P1D'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0002pcwhdn******wmi'),
}

model CreateHanaBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='pl-000756jdlk2zmqig2nea'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='33AA3AAE-89E1-5D3A-A51D-0C0A80850F68'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreateHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaBackupPlanResponseBody(name='body'),
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param request CreateHanaBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateHanaBackupPlanResponse
 */
async function createHanaBackupPlanWithOptions(request: CreateHanaBackupPlanRequest, runtime: Util.RuntimeOptions): CreateHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param request CreateHanaBackupPlanRequest
  * @return CreateHanaBackupPlanResponse
 */
async function createHanaBackupPlan(request: CreateHanaBackupPlanRequest): CreateHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaBackupPlanWithOptions(request, runtime);
}

model CreateHanaInstanceRequest {
  alertSetting?: string(name='AlertSetting', description='The alert settings. Valid value: INHERITED, which indicates that the backup client sends alert notifications in the same way as the backup vault.', example='INHERITED'),
  ecsInstanceId?: string(name='EcsInstanceId', description='The IDs of ECS instances that host the SAP HANA instance to be registered. HBR installs backup clients on the specified ECS instances.', example='[\\"i-uf6ir9y******hvisj\\"]'),
  hanaName?: string(name='HanaName', description='The name of the SAP HANA instance.', example='HANA-DEV'),
  host?: string(name='Host', description='The private or internal IP address of the host where the primary node of the SAP HANA instance resides.', example='47.100.XX.XX'),
  instanceNumber?: int32(name='InstanceNumber', description='The instance number of the SAP HANA system.', example='00'),
  password?: string(name='Password', description='The password that is used to connect with the SAP HANA database.', example='************'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm4ebtpkzx7zy'),
  sid?: string(name='Sid', description='The security identifier (SID) of the SAP HANA database.

For more information, see [How to find sid user and instance number of HANA db?](https://answers.sap.com/questions/555192/how-to-find-sid-user-and-instance-number-of-hana-d.html?spm=a2c4g.11186623.0.0.55c34b4ftZeXNK)', example='HXE'),
  useSsl?: boolean(name='UseSsl', description='Specifies whether to connect with the SAP HANA database over Secure Sockets Layer (SSL).', example='true'),
  userName?: string(name='UserName', description='The username of the SYSTEMDB database.', example='admin'),
  validateCertificate?: boolean(name='ValidateCertificate', description='Specifies whether to verify the SSL certificate of the SAP HANA database.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0003v4a******gfv2'),
}

model CreateHanaInstanceResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000dp1sz******6hn'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EB526A5D-1FE2-51C1-B790-1732C1DBA969'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreateHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaInstanceResponseBody(name='body'),
}

/**
  * To register an SAP HANA instance, you must configure the connection parameters of the SAP HANA instance. After the SAP HANA instance is registered, HBR installs an HBR client on the ECS instance that hosts the SAP HANA instance.
  *
  * @param request CreateHanaInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateHanaInstanceResponse
 */
async function createHanaInstanceWithOptions(request: CreateHanaInstanceRequest, runtime: Util.RuntimeOptions): CreateHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.ecsInstanceId)) {
    query['EcsInstanceId'] = request.ecsInstanceId;
  }
  if (!Util.isUnset(request.hanaName)) {
    query['HanaName'] = request.hanaName;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceNumber)) {
    query['InstanceNumber'] = request.instanceNumber;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.useSsl)) {
    query['UseSsl'] = request.useSsl;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.validateCertificate)) {
    query['ValidateCertificate'] = request.validateCertificate;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To register an SAP HANA instance, you must configure the connection parameters of the SAP HANA instance. After the SAP HANA instance is registered, HBR installs an HBR client on the ECS instance that hosts the SAP HANA instance.
  *
  * @param request CreateHanaInstanceRequest
  * @return CreateHanaInstanceResponse
 */
async function createHanaInstance(request: CreateHanaInstanceRequest): CreateHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaInstanceWithOptions(request, runtime);
}

model CreateHanaRestoreRequest {
  backupId?: long(name='BackupId', description='The ID of the backup.', example='1645628400235'),
  backupPrefix?: string(name='BackupPrefix', description='The backup prefix.', example='COMPLETE_DATA_BACKUP_2022_05_02_15_39'),
  checkAccess?: boolean(name='CheckAccess', description='Specifies whether to validate the differential backup and log backup. Valid values: true and false. If you set the value to true, HBR checks whether the required differential backup and log backup are available before the restore job starts. If the differential backup or log backup is unavailable, HBR does not start the restore job.', example='false'),
  clearLog?: boolean(name='ClearLog', description='Specifies whether to delete all log entries from the log area after the log entries are restored. Valid values: true and false. If you set the value to false, all log entries are deleted from the log area after the log entries are restored.', example='false'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance that you want to restore.', example='cl-000fbrs5******ka9w'),
  databaseName?: string(name='DatabaseName', description='The name of the database that you want to restore.', example='TS2'),
  logPosition?: long(name='LogPosition', description='The log position to which you want to restore the database. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_LOG_POSITION**.', example='0'),
  mode?: string(name='Mode', description='The recovery mode. Valid values:

*   **RECOVERY_TO_MOST_RECENT**: restores the database to the recently available state to which the database has been backed up.
*   **RECOVERY_TO_POINT_IN_TIME**: restores the database to a specified point in time.
*   **RECOVERY_TO_SPECIFIC_BACKUP**: restores the database to a specified backup.
*   **RECOVERY_TO_LOG_POSITION**: restores the database to a specified log position.', example='RECOVERY_TO_POINT_IN_TIME'),
  recoveryPointInTime?: long(name='RecoveryPointInTime', description='The point in time to which you want to restore the database. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_POINT_IN_TIME**. HBR restores the database to a state closest to the specified point in time.', example='1635315505'),
  sidAdmin?: string(name='SidAdmin', description='The SID admin account that is created by SAP HANA.', example='DB'),
  source?: string(name='Source', description='The name of the source system. This parameter specifies the name of the source database that you want to restore. You must set the parameter in the `<Source database name>@SID` format.', example='HNP@HNP'),
  sourceClusterId?: string(name='SourceClusterId', description='The ID of the source SAP HANA instance.', example='cl-000ii8tzv******xm0t'),
  systemCopy?: boolean(name='SystemCopy', description='Specifies whether to restore the database to a different instance.', example='false'),
  useCatalog?: boolean(name='UseCatalog', description='Specifies whether to use a catalog backup to restore the database. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_SPECIFIC_BACKUP**. If you do not use a catalog backup, you must specify the prefix of a backup file. Then, HBR finds the backup file based on the specified prefix and restores the backup file.', example='false'),
  useDelta?: boolean(name='UseDelta', description='Specifies whether to use a differential backup or an incremental backup to restore the database. Valid values: true and false. If you want to use a differential backup or an incremental backup to restore the database, set the value to true. If you set the value to false, HBR uses a log backup to restore the database.', example='true'),
  volumeId?: int32(name='VolumeId', description='The ID of the volume that you want to restore. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_LOG_POSITION**.', example='0'),
}

model CreateHanaRestoreResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EEC65C22-2152-5E31-8AD6-D6CBF1BFF49F'),
  restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='hr-000fb9bz190p1rse6jwv'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreateHanaRestoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaRestoreResponseBody(name='body'),
}

/**
  * If you call this operation to restore a database, the database is restored to a specified state. Proceed with caution. For more information, see [Restore databases to an SAP HANA instance](~~101178~~).
  *
  * @param request CreateHanaRestoreRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateHanaRestoreResponse
 */
async function createHanaRestoreWithOptions(request: CreateHanaRestoreRequest, runtime: Util.RuntimeOptions): CreateHanaRestoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.checkAccess)) {
    query['CheckAccess'] = request.checkAccess;
  }
  if (!Util.isUnset(request.clearLog)) {
    query['ClearLog'] = request.clearLog;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.logPosition)) {
    query['LogPosition'] = request.logPosition;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.recoveryPointInTime)) {
    query['RecoveryPointInTime'] = request.recoveryPointInTime;
  }
  if (!Util.isUnset(request.sidAdmin)) {
    query['SidAdmin'] = request.sidAdmin;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceClusterId)) {
    query['SourceClusterId'] = request.sourceClusterId;
  }
  if (!Util.isUnset(request.systemCopy)) {
    query['SystemCopy'] = request.systemCopy;
  }
  if (!Util.isUnset(request.useCatalog)) {
    query['UseCatalog'] = request.useCatalog;
  }
  if (!Util.isUnset(request.useDelta)) {
    query['UseDelta'] = request.useDelta;
  }
  if (!Util.isUnset(request.volumeId)) {
    query['VolumeId'] = request.volumeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaRestore',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you call this operation to restore a database, the database is restored to a specified state. Proceed with caution. For more information, see [Restore databases to an SAP HANA instance](~~101178~~).
  *
  * @param request CreateHanaRestoreRequest
  * @return CreateHanaRestoreResponse
 */
async function createHanaRestore(request: CreateHanaRestoreRequest): CreateHanaRestoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaRestoreWithOptions(request, runtime);
}

model CreatePolicyBindingsRequest {
  policyBindingList?: [ 
    {
      advancedOptions?: {
        udmDetail?: {
          appConsistent?: boolean(name='AppConsistent', description='Specifies whether to enable application consistency. You can enable application consistency only if all disks are ESSDs.', example='false'),
          diskIdList?: [ string ](name='DiskIdList', description='The IDs of disks that need to be protected. If all disks need to be protected, this parameter is empty.'),
          enableFsFreeze?: boolean(name='EnableFsFreeze', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies whether to enable Linux fsfreeze to put file systems into the read-only state before application-consistent snapshots are created. Default value: true.', example='true'),
          enableWriters?: boolean(name='EnableWriters', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies whether to create application-consistent snapshots. Valid values:

*   true: creates application-consistent snapshots
*   false: creates file system-consistent snapshots

Default value: true.', example='true'),
          excludeDiskIdList?: [ string ](name='ExcludeDiskIdList', description='The IDs of the disks that do not need to be protected. If the DiskIdList parameter is not empty, this parameter is ignored.'),
          postScriptPath?: string(name='PostScriptPath', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies the path of the post-thaw scripts that are executed after application-consistent snapshots are created.', example='/tmp/postscript.sh'),
          preScriptPath?: string(name='PreScriptPath', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies the path of the pre-freeze scripts that are executed before application-consistent snapshots are created.', example='/tmp/prescript.sh'),
          ramRoleName?: string(name='RamRoleName', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies the name of the RAM role that is required to create application-consistent snapshots.', example='AliyunECSInstanceForHbrRole'),
          snapshotGroup?: boolean(name='SnapshotGroup', description='Specifies whether to create a snapshot-consistent group. You can create a snapshot-consistent group only if all disks are enhanced SSDs (ESSDs).', example='true'),
          timeoutInSeconds?: long(name='TimeoutInSeconds', description='This parameter is required only if you set the **AppConsistent** parameter to **true**. This parameter specifies the I/O freeze timeout period. Default value: 30. Unit: seconds.', example='30'),
        }(name='UdmDetail', description='The details of ECS instance backup.'),
      }(name='AdvancedOptions', description='Advanced options.'),
      crossAccountRoleName?: string(name='CrossAccountRoleName'),
      crossAccountType?: string(name='CrossAccountType'),
      crossAccountUserId?: long(name='CrossAccountUserId'),
      dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='i-bp1************dl8'),
      disabled?: string(name='Disabled', description='Specifies whether to disable the backup policy for the data source. Valid values:

*   true: disables the backup policy for the data source
*   false: enables the backup policy for the data source', example='true'),
      policyBindingDescription?: string(name='PolicyBindingDescription', description='The description of the association.', example='Bind data sources to a backup policy'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
    }
  ](name='PolicyBindingList', description='The data sources that you want to bind to the backup policy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************8ep'),
}

model CreatePolicyBindingsShrinkRequest {
  policyBindingListShrink?: string(name='PolicyBindingList', description='The data sources that you want to bind to the backup policy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************8ep'),
}

model CreatePolicyBindingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='82CC5B6C-72F7-5D39-92F6-67887DF9AD46'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreatePolicyBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyBindingsResponseBody(name='body'),
}

/**
  * *   You can bind data sources to only one policy in each request.
  * *   Elastic Compute Service (ECS) instances can be bound to only one policy.
  *
  * @param tmpReq CreatePolicyBindingsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreatePolicyBindingsResponse
 */
async function createPolicyBindingsWithOptions(tmpReq: CreatePolicyBindingsRequest, runtime: Util.RuntimeOptions): CreatePolicyBindingsResponse {
  Util.validateModel(tmpReq);
  var request = new CreatePolicyBindingsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policyBindingList)) {
    request.policyBindingListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policyBindingList, 'PolicyBindingList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.policyBindingListShrink)) {
    query['PolicyBindingList'] = request.policyBindingListShrink;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicyBindings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You can bind data sources to only one policy in each request.
  * *   Elastic Compute Service (ECS) instances can be bound to only one policy.
  *
  * @param request CreatePolicyBindingsRequest
  * @return CreatePolicyBindingsResponse
 */
async function createPolicyBindings(request: CreatePolicyBindingsRequest): CreatePolicyBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyBindingsWithOptions(request, runtime);
}

model CreatePolicyV2Request {
  policyDescription?: string(name='PolicyDescription', description='The description of the backup policy.', example='Data is backed up at 10:00:00 every day and replicated to the China (Shanghai) region for geo-redundancy.'),
  policyName?: string(name='PolicyName', description='The name of the backup policy.', example='Daily Local Backup + Remote Backup'),
  rules?: [ 
    {
      backupType?: string(name='BackupType', description='This parameter is required only if you set the **RuleType** parameter to **BACKUP**. The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      replicationRegionId?: string(name='ReplicationRegionId', description='This parameter is required only if you set the **RuleType** parameter to **REPLICATION**. The ID of the destination region.', example='cn-shanghai'),
      retention?: long(name='Retention', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION** or **REPLICATION**.

*   If you set the **RuleType** parameter to **TRANSITION**, this parameter specifies the retention period of the backup data. Minimum value: 1. Unit: days.
*   If you set the **RuleType** parameter to **REPLICATION**, this parameter specifies the retention period of remote backups. Minimum value: 1. Unit: days.', example='7'),
      retentionRules?: [ 
        {
          advancedRetentionType?: string(name='AdvancedRetentionType', description='The type of the special retention rule. Valid values:

*   **WEEKLY**: retains weekly backups
*   **MONTHLY**: retains monthly backups
*   **YEARLY**: retains yearly backups', example='YEARLY'),
          retention?: long(name='Retention', description='The retention period of the backup data. Minimum value: 1. Unit: days.', example='730'),
          whichSnapshot?: long(name='WhichSnapshot', description='Specifies which backup is retained based on the special retention rule. Only the first backup can be retained.', example='1'),
        }
      ](name='RetentionRules', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION**. This parameter specifies the special retention rules.'),
      ruleType?: string(name='RuleType', description='The type of the rule. Each backup policy must have at least one rule of the **BACKUP** type and only one rule of the **TRANSITION** type.

*   **BACKUP**: backup rule
*   **TRANSITION**: lifecycle rule
*   **REPLICATION**: replication rule', example='BACKUP'),
      schedule?: string(name='Schedule', description='This parameter is required only if you set the **RuleType** parameter to **BACKUP**. This parameter specifies the backup schedule settings. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval must follow the ISO 8601 standard. For example, PT1H specifies an interval of one hour. P1D specifies an interval of one day.', example='I|1648647166|P1D'),
    }
  ](name='Rules', description='The rules in the backup policy.'),
}

model CreatePolicyV2ShrinkRequest {
  policyDescription?: string(name='PolicyDescription', description='The description of the backup policy.', example='Data is backed up at 10:00:00 every day and replicated to the China (Shanghai) region for geo-redundancy.'),
  policyName?: string(name='PolicyName', description='The name of the backup policy.', example='Daily Local Backup + Remote Backup'),
  rulesShrink?: string(name='Rules', description='The rules in the backup policy.'),
}

model CreatePolicyV2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000000zemnuyx2li3y9y'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='EEC65C22-2152-5E31-8AD6-D6CBF1BFF49F'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreatePolicyV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyV2ResponseBody(name='body'),
}

/**
  * A backup policy records the information required for backup. After you execute a backup policy, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   A backup policy supports multiple data sources. The data sources can be only Elastic Compute Service (ECS) instances.
  * *   You can specify only one interval as a backup cycle in a backup policy.
  * *   Each backup policy allows you to back up data to only one backup vault.
  *
  * @param tmpReq CreatePolicyV2Request
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreatePolicyV2Response
 */
async function createPolicyV2WithOptions(tmpReq: CreatePolicyV2Request, runtime: Util.RuntimeOptions): CreatePolicyV2Response {
  Util.validateModel(tmpReq);
  var request = new CreatePolicyV2ShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.rules)) {
    request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, 'Rules', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyDescription)) {
    body['PolicyDescription'] = request.policyDescription;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.rulesShrink)) {
    body['Rules'] = request.rulesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicyV2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * A backup policy records the information required for backup. After you execute a backup policy, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   A backup policy supports multiple data sources. The data sources can be only Elastic Compute Service (ECS) instances.
  * *   You can specify only one interval as a backup cycle in a backup policy.
  * *   Each backup policy allows you to back up data to only one backup vault.
  *
  * @param request CreatePolicyV2Request
  * @return CreatePolicyV2Response
 */
async function createPolicyV2(request: CreatePolicyV2Request): CreatePolicyV2Response {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyV2WithOptions(request, runtime);
}

model CreateReplicationVaultRequest {
  description?: string(name='Description', description='The description of the backup vault. The description must be 0 to 255 characters in length.', example='description'),
  redundancyType?: string(name='RedundancyType', description='The data redundancy type of the backup vault. Valid values:

- LRS: Locally redundant storage (LRS) is enabled for the backup vault. HBR stores the copies of each object on multiple devices of different facilities in the same zone. This way, HBR ensures data durability and availability even if hardware failures occur.
- ZRS: Zone-redundant storage (ZRS) is enabled for the backup vault. HBR uses the multi-zone mechanism to distribute data across three zones within the same region. If a zone becomes unavailable, the data can still be accessed.', example='LRS'),
  replicationSourceRegionId?: string(name='ReplicationSourceRegionId', description='The ID of the region where the source vault resides.', example='cn-hangzhou'),
  replicationSourceVaultId?: string(name='ReplicationSourceVaultId', description='The ID of the source vault.', example='v-*********************'),
  vaultName?: string(name='VaultName', description='The name of the backup vault. The name must be 1 to 64 characters in length.', example='mirrorvaultname'),
  vaultRegionId?: string(name='VaultRegionId', description='The ID of the region where the backup vault resides.', example='cn-shanghai'),
  vaultStorageClass?: string(name='VaultStorageClass', description='The storage type of the backup vault. Valid value: **STANDARD**. The value indicates standard storage.', example='STANDARD'),
}

model CreateReplicationVaultResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request was successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request was successful, "successful" is returned. If the request failed, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request was successful. Valid values:

*   true: The request was successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the initialization task used to initialize the backup vault.

You can call the DescribeTask operation to query the status of an initialization task.', example='t-*********************'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model CreateReplicationVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateReplicationVaultResponseBody(name='body'),
}

/**
  * After a backup vault is created, the backup vault is in the INITIALIZING state, and the system automatically runs an initialization task to initialize the backup vault. After the initialization task is completed, the backup vault is in the CREATED state.
  *
  * @param request CreateReplicationVaultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateReplicationVaultResponse
 */
async function createReplicationVaultWithOptions(request: CreateReplicationVaultRequest, runtime: Util.RuntimeOptions): CreateReplicationVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.redundancyType)) {
    query['RedundancyType'] = request.redundancyType;
  }
  if (!Util.isUnset(request.replicationSourceRegionId)) {
    query['ReplicationSourceRegionId'] = request.replicationSourceRegionId;
  }
  if (!Util.isUnset(request.replicationSourceVaultId)) {
    query['ReplicationSourceVaultId'] = request.replicationSourceVaultId;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultStorageClass)) {
    query['VaultStorageClass'] = request.vaultStorageClass;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateReplicationVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After a backup vault is created, the backup vault is in the INITIALIZING state, and the system automatically runs an initialization task to initialize the backup vault. After the initialization task is completed, the backup vault is in the CREATED state.
  *
  * @param request CreateReplicationVaultRequest
  * @return CreateReplicationVaultResponse
 */
async function createReplicationVault(request: CreateReplicationVaultRequest): CreateReplicationVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReplicationVaultWithOptions(request, runtime);
}

model CreateRestoreJobRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  exclude?: string(name='Exclude', description='The paths to the files that you do not want to restore. No files in the specified paths are restored. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  include?: string(name='Include', description='The paths to the files that you want to restore. All files in the specified paths are restored. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  initiatedByAck?: boolean(name='InitiatedByAck'),
  otsDetail?: OtsTableRestoreDetail(name='OtsDetail', description='The details about the Tablestore instance.', example='instancename'),
  restoreType?: string(name='RestoreType', description='The type of the restore destination. Valid values:

*   **ECS_FILE**: restores data to Elastic Compute Service (ECS) files
*   **OSS**: restores data to Object Storage Service (OSS) buckets
*   **NAS**: restores data to Apsara File Storage NAS file systems
*   **OTS_TABLE**: restores data to Tablestore instances
*   **UDM_ECS_ROLLBACK**: restores data to ECS instances', example='ECS_FILE'),
  snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
  snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-********************'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: OSS buckets
*   **NAS**: NAS file systems
*   **OTS_TABLE**: Tablestore instances
*   **UDM_ECS**: ECS instances', example='ECS_FILE'),
  targetBucket?: string(name='TargetBucket', description='This parameter is required only if the **RestoreType** parameter is set to **OSS**. This parameter specifies the name of the OSS bucket to which you want to restore data.', example='hbr-backup-oss'),
  targetContainer?: string(name='TargetContainer'),
  targetContainerClusterId?: string(name='TargetContainerClusterId'),
  targetCreateTime?: long(name='TargetCreateTime', description='This parameter is required only if the **RestoreType** parameter is set to **NAS**. This parameter specifies the time when the file system was created.', example='1554347313'),
  targetFileSystemId?: string(name='TargetFileSystemId', description='This parameter is required only if the **RestoreType** parameter is set to **NAS**. This parameter specifies the ID of the file system to which you want to restore data.', example='005494'),
  targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required only if the **RestoreType** parameter is set to **ECS_FILE**. This parameter specifies the ID of the ECS instance to which you want to restore data.', example='i-*********************'),
  targetInstanceName?: string(name='TargetInstanceName', description='The name of the Tablestore instance to which you want to restore data.', example='instancename'),
  targetPath?: string(name='TargetPath', description='This parameter is required only if the **RestoreType** parameter is set to **ECS_FILE**. This parameter specifies the destination file path.', example='C:\\'),
  targetPrefix?: string(name='TargetPrefix', description='This parameter is required only if the **RestoreType** parameter is set to **OSS**. This parameter specifies the prefix of objects that you want to restore.', example='hbr'),
  targetTableName?: string(name='TargetTableName', description='The name of the table that stores the restored data.', example='tablename'),
  targetTime?: long(name='TargetTime', description='The time when data is restored to the Tablestore instance. This value is a UNIX timestamp. Unit: seconds.', example='1642496881'),
  udmDetail?: map[string]any(name='UdmDetail', description='The details about server backup.', example='{\\"sourceInstanceId\\":\\"i-uf62te6pm3iwsyxyz66q\\",\\"bootAfterRestore\\":false}'),
  udmRegionId?: string(name='UdmRegionId'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault to which the backup snapshot belongs.', example='v-*********************'),
}

model CreateRestoreJobShrinkRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  exclude?: string(name='Exclude', description='The paths to the files that you do not want to restore. No files in the specified paths are restored. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  include?: string(name='Include', description='The paths to the files that you want to restore. All files in the specified paths are restored. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  initiatedByAck?: boolean(name='InitiatedByAck'),
  otsDetailShrink?: string(name='OtsDetail', description='The details about the Tablestore instance.', example='instancename'),
  restoreType?: string(name='RestoreType', description='The type of the restore destination. Valid values:

*   **ECS_FILE**: restores data to Elastic Compute Service (ECS) files
*   **OSS**: restores data to Object Storage Service (OSS) buckets
*   **NAS**: restores data to Apsara File Storage NAS file systems
*   **OTS_TABLE**: restores data to Tablestore instances
*   **UDM_ECS_ROLLBACK**: restores data to ECS instances', example='ECS_FILE'),
  snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
  snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-********************'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: OSS buckets
*   **NAS**: NAS file systems
*   **OTS_TABLE**: Tablestore instances
*   **UDM_ECS**: ECS instances', example='ECS_FILE'),
  targetBucket?: string(name='TargetBucket', description='This parameter is required only if the **RestoreType** parameter is set to **OSS**. This parameter specifies the name of the OSS bucket to which you want to restore data.', example='hbr-backup-oss'),
  targetContainer?: string(name='TargetContainer'),
  targetContainerClusterId?: string(name='TargetContainerClusterId'),
  targetCreateTime?: long(name='TargetCreateTime', description='This parameter is required only if the **RestoreType** parameter is set to **NAS**. This parameter specifies the time when the file system was created.', example='1554347313'),
  targetFileSystemId?: string(name='TargetFileSystemId', description='This parameter is required only if the **RestoreType** parameter is set to **NAS**. This parameter specifies the ID of the file system to which you want to restore data.', example='005494'),
  targetInstanceId?: string(name='TargetInstanceId', description='This parameter is required only if the **RestoreType** parameter is set to **ECS_FILE**. This parameter specifies the ID of the ECS instance to which you want to restore data.', example='i-*********************'),
  targetInstanceName?: string(name='TargetInstanceName', description='The name of the Tablestore instance to which you want to restore data.', example='instancename'),
  targetPath?: string(name='TargetPath', description='This parameter is required only if the **RestoreType** parameter is set to **ECS_FILE**. This parameter specifies the destination file path.', example='C:\\'),
  targetPrefix?: string(name='TargetPrefix', description='This parameter is required only if the **RestoreType** parameter is set to **OSS**. This parameter specifies the prefix of objects that you want to restore.', example='hbr'),
  targetTableName?: string(name='TargetTableName', description='The name of the table that stores the restored data.', example='tablename'),
  targetTime?: long(name='TargetTime', description='The time when data is restored to the Tablestore instance. This value is a UNIX timestamp. Unit: seconds.', example='1642496881'),
  udmDetailShrink?: string(name='UdmDetail', description='The details about server backup.', example='{\\"sourceInstanceId\\":\\"i-uf62te6pm3iwsyxyz66q\\",\\"bootAfterRestore\\":false}'),
  udmRegionId?: string(name='UdmRegionId'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault to which the backup snapshot belongs.', example='v-*********************'),
}

model CreateRestoreJobResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='r-*********************'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model CreateRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRestoreJobResponseBody(name='body'),
}

async function createRestoreJobWithOptions(tmpReq: CreateRestoreJobRequest, runtime: Util.RuntimeOptions): CreateRestoreJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRestoreJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  if (!Util.isUnset(tmpReq.udmDetail)) {
    request.udmDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.udmDetail, 'UdmDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.initiatedByAck)) {
    query['InitiatedByAck'] = request.initiatedByAck;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.targetBucket)) {
    query['TargetBucket'] = request.targetBucket;
  }
  if (!Util.isUnset(request.targetContainer)) {
    query['TargetContainer'] = request.targetContainer;
  }
  if (!Util.isUnset(request.targetContainerClusterId)) {
    query['TargetContainerClusterId'] = request.targetContainerClusterId;
  }
  if (!Util.isUnset(request.targetCreateTime)) {
    query['TargetCreateTime'] = request.targetCreateTime;
  }
  if (!Util.isUnset(request.targetFileSystemId)) {
    query['TargetFileSystemId'] = request.targetFileSystemId;
  }
  if (!Util.isUnset(request.targetInstanceName)) {
    query['TargetInstanceName'] = request.targetInstanceName;
  }
  if (!Util.isUnset(request.targetPrefix)) {
    query['TargetPrefix'] = request.targetPrefix;
  }
  if (!Util.isUnset(request.targetTableName)) {
    query['TargetTableName'] = request.targetTableName;
  }
  if (!Util.isUnset(request.targetTime)) {
    query['TargetTime'] = request.targetTime;
  }
  if (!Util.isUnset(request.udmDetailShrink)) {
    query['UdmDetail'] = request.udmDetailShrink;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    body['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetPath)) {
    body['TargetPath'] = request.targetPath;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRestoreJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRestoreJob(request: CreateRestoreJobRequest): CreateRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRestoreJobWithOptions(request, runtime);
}

model CreateTempFileUploadUrlRequest {
  fileName?: string(name='FileName', example='file-list.txt'),
}

model CreateTempFileUploadUrlResponseBody = {
  bucketName?: string(name='BucketName', example='hbr-temp-bucket'),
  code?: string(name='Code', example='200'),
  endpoint?: string(name='Endpoint', example='oss-cn-shenzhen.aliyuncs.com'),
  expireTime?: long(name='ExpireTime', example='1654326678'),
  message?: string(name='Message', example='successful'),
  ossAccessKeyId?: string(name='OssAccessKeyId', example='LTAI****Up'),
  policy?: string(name='Policy', example='eyJleH****V19'),
  requestId?: string(name='RequestId', example='F4EEB401-DD21-588D-AE3B-1E835C7655E1'),
  signature?: string(name='Signature', example='RmhI****0A='),
  success?: boolean(name='Success', example='true'),
  tempFileKey?: string(name='TempFileKey', example='temp/1440155109798732/upload/2022-07-29/49bed34c-b430-4e7e-89b1-4be2b734f95c/iaclone.diff'),
}

model CreateTempFileUploadUrlResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTempFileUploadUrlResponseBody(name='body'),
}

async function createTempFileUploadUrlWithOptions(request: CreateTempFileUploadUrlRequest, runtime: Util.RuntimeOptions): CreateTempFileUploadUrlResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.fileName)) {
    query['FileName'] = request.fileName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateTempFileUploadUrl',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTempFileUploadUrl(request: CreateTempFileUploadUrlRequest): CreateTempFileUploadUrlResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTempFileUploadUrlWithOptions(request, runtime);
}

model CreateVaultRequest {
  description?: string(name='Description', description='The description of the backup vault. The description must be 0 to 255 characters in length.', example='description'),
  encryptType?: string(name='EncryptType', description='This parameter specifies the method that is used to encrypt the data in the backup vault.. This parameter is required only if the **VaultType** parameter is set to **STANDARD**.
- **HBR-managed** (default value): You can use the default encryption method of HBR.
- **KMS**: You can use Key Management Service (KMS) to encrypt data that is stored in the backup vault. If you select this option, you must specify the KMS KeyId parameter.', example='KMS'),
  kmsKeyId?: string(name='KmsKeyId', description='You can use Key Management Service (KMS) to encrypt data that is stored in the backup vault. If you select this option, you must specify the KMS KeyId parameter.', example='alias/yzs-hhht'),
  redundancyType?: string(name='RedundancyType', description='The data redundancy type of the backup vault. Valid values:

*   LRS: Locally redundant storage (LRS) is enabled for the backup vault. HBR stores the copies of each object on multiple devices of different facilities in the same zone. This way, HBR ensures data durability and availability even if hardware failures occur.
*   ZRS: Zone-redundant storage (ZRS) is enabled for the backup vault. HBR uses the multi-zone mechanism to distribute data across three zones within the same region. If a zone becomes unavailable, the data can still be accessed.', example='LRS'),
  vaultName?: string(name='VaultName', description='The name of the backup vault. The name must be 1 to 64 characters in length.', example='backupvaultname'),
  vaultRegionId?: string(name='VaultRegionId', description='The ID of the region where the backup vault resides.', example='cn-shanghai'),
  vaultStorageClass?: string(name='VaultStorageClass', description='The storage type of the backup vault. Valid value: **STANDARD**, which indicates standard storage.', example='STANDARD'),
  vaultType?: string(name='VaultType', description='The type of the backup vault. Valid value: **STANDARD**, which indicates a standard backup vault.', example='STANDARD'),
}

model CreateVaultResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the initialization task used to initialize the backup vault. You can call the DescribeTask operation to query the status of an initialization task.', example='t-*********************'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model CreateVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVaultResponseBody(name='body'),
}

/**
  * *   Each Alibaba Cloud account can create up to 100 backup vaults.
  * *   After a backup vault is created, the backup vault is in the INITIALIZING state, and the system automatically runs an initialization task to initialize the backup vault. After the initialization task is completed, the backup vault is in the CREATED state. A backup job can use a backup vault to store backup data only if the backup vault is in the CREATED state.
  *
  * @param request CreateVaultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return CreateVaultResponse
 */
async function createVaultWithOptions(request: CreateVaultRequest, runtime: Util.RuntimeOptions): CreateVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.encryptType)) {
    query['EncryptType'] = request.encryptType;
  }
  if (!Util.isUnset(request.kmsKeyId)) {
    query['KmsKeyId'] = request.kmsKeyId;
  }
  if (!Util.isUnset(request.redundancyType)) {
    query['RedundancyType'] = request.redundancyType;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultStorageClass)) {
    query['VaultStorageClass'] = request.vaultStorageClass;
  }
  if (!Util.isUnset(request.vaultType)) {
    query['VaultType'] = request.vaultType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   Each Alibaba Cloud account can create up to 100 backup vaults.
  * *   After a backup vault is created, the backup vault is in the INITIALIZING state, and the system automatically runs an initialization task to initialize the backup vault. After the initialization task is completed, the backup vault is in the CREATED state. A backup job can use a backup vault to store backup data only if the backup vault is in the CREATED state.
  *
  * @param request CreateVaultRequest
  * @return CreateVaultResponse
 */
async function createVault(request: CreateVaultRequest): CreateVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVaultWithOptions(request, runtime);
}

model DeleteBackupClientRequest {
  clientId?: string(name='ClientId', description='The ID of the backup client.', example='c-*********************'),
}

model DeleteBackupClientResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model DeleteBackupClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupClientResponseBody(name='body'),
}

/**
  * *   You cannot delete an active backup client from which a heartbeat packet is received within the previous hour. After you call the UninstallBackupClients operation to uninstall a backup client, the status of the backup client changes to inactive.
  * *   This operation deletes the resources that are related to the backup client. The following resources are included:
  *     *   Backup plans
  *     *   Backup jobs
  *     *   Backup files
  *
  * @param request DeleteBackupClientRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteBackupClientResponse
 */
async function deleteBackupClientWithOptions(request: DeleteBackupClientRequest, runtime: Util.RuntimeOptions): DeleteBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You cannot delete an active backup client from which a heartbeat packet is received within the previous hour. After you call the UninstallBackupClients operation to uninstall a backup client, the status of the backup client changes to inactive.
  * *   This operation deletes the resources that are related to the backup client. The following resources are included:
  *     *   Backup plans
  *     *   Backup jobs
  *     *   Backup files
  *
  * @param request DeleteBackupClientRequest
  * @return DeleteBackupClientResponse
 */
async function deleteBackupClient(request: DeleteBackupClientRequest): DeleteBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupClientWithOptions(request, runtime);
}

model DeleteBackupClientResourceRequest {
  clientIds?: map[string]any(name='ClientIds', description='The IDs of backup clients. You can specify a maximum of 100 client IDs.', example='["c-*********************"]'),
}

model DeleteBackupClientResourceShrinkRequest {
  clientIdsShrink?: string(name='ClientIds', description='The IDs of backup clients. You can specify a maximum of 100 client IDs.', example='["c-*********************"]'),
}

model DeleteBackupClientResourceResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DeleteBackupClientResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupClientResourceResponseBody(name='body'),
}

/**
  * This operation deletes only the resources that are related to backup clients. The resources include backup plans, backup jobs, and backup snapshots. The operation does not delete backup clients.
  *
  * @param tmpReq DeleteBackupClientResourceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteBackupClientResourceResponse
 */
async function deleteBackupClientResourceWithOptions(tmpReq: DeleteBackupClientResourceRequest, runtime: Util.RuntimeOptions): DeleteBackupClientResourceResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteBackupClientResourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupClientResource',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation deletes only the resources that are related to backup clients. The resources include backup plans, backup jobs, and backup snapshots. The operation does not delete backup clients.
  *
  * @param request DeleteBackupClientResourceRequest
  * @return DeleteBackupClientResourceResponse
 */
async function deleteBackupClientResource(request: DeleteBackupClientResourceRequest): DeleteBackupClientResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupClientResourceWithOptions(request, runtime);
}

model DeleteBackupPlanRequest {
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: The system backs up data from Elastic Compute Service (ECS) instances.
*   **OSS**: The system backs up data from Object Storage Service (OSS) buckets.
*   **NAS**: The system backs up data from Apsara File Storage NAS file systems.', example='ECS_FILE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model DeleteBackupPlanResponseBody = {
  code?: string(name='Code', description='The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model DeleteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupPlanResponseBody(name='body'),
}

/**
  * *   If you delete a backup plan, all backup jobs that are related to the backup plan are deleted.
  * *   The backup files that you create are retained.
  *
  * @param request DeleteBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteBackupPlanResponse
 */
async function deleteBackupPlanWithOptions(request: DeleteBackupPlanRequest, runtime: Util.RuntimeOptions): DeleteBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you delete a backup plan, all backup jobs that are related to the backup plan are deleted.
  * *   The backup files that you create are retained.
  *
  * @param request DeleteBackupPlanRequest
  * @return DeleteBackupPlanResponse
 */
async function deleteBackupPlan(request: DeleteBackupPlanRequest): DeleteBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPlanWithOptions(request, runtime);
}

model DeleteClientRequest {
  clientId?: string(name='ClientId', example='c-000************f3h'),
  resourceGroupId?: string(name='ResourceGroupId', example='rg-acf************kwy'),
  vaultId?: string(name='VaultId', example='v-000************gs3'),
}

model DeleteClientResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='successful'),
  requestId?: string(name='RequestId', example='C51A9094-64B7-5DC0-B9FE-5FC1AC7E081D'),
  success?: boolean(name='Success', example='true'),
}

model DeleteClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteClientResponseBody(name='body'),
}

async function deleteClientWithOptions(request: DeleteClientRequest, runtime: Util.RuntimeOptions): DeleteClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteClient(request: DeleteClientRequest): DeleteClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteClientWithOptions(request, runtime);
}

model DeleteHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000br3******0ooy2'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='pl-00035lc8pwp1azdf3qku'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm4ebtpkzx7zy'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0007o******1ssno'),
}

model DeleteHanaBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='071E4789-6256-526B-B22E-2A9CDDB9EB21'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DeleteHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHanaBackupPlanResponseBody(name='body'),
}

async function deleteHanaBackupPlanWithOptions(request: DeleteHanaBackupPlanRequest, runtime: Util.RuntimeOptions): DeleteHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHanaBackupPlan(request: DeleteHanaBackupPlanRequest): DeleteHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHanaBackupPlanWithOptions(request, runtime);
}

model DeleteHanaInstanceRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000g4z09******9cfc'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmwutpyat2kwy'),
  sid?: string(name='Sid', description='The SID of the SAP HANA database. You must specify a valid SID. The SID must be three characters in length and start with a letter. For more information, see [How to find sid user and instance number of HANA db?](https://answers.sap.com/questions/555192/how-to-find-sid-user-and-instance-number-of-hana-d.html?)', example='HXE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0008n2******ax3'),
}

model DeleteHanaInstanceResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='28EAF89A-E0D8-5C04-9A1D-B373B29BCFB9'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DeleteHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHanaInstanceResponseBody(name='body'),
}

/**
  * If you delete an SAP HANA instance, the existing backup data is also deleted and the running backup and restore jobs fail to be completed. Before you delete the SAP HANA instance, make sure that you no longer need the data in the HBR client of the instance and no backup or restore jobs are running for the instance. To delete an SAP HANA instance, you must specify the security identifier (SID) of the instance. The SID is three characters in length and starts with a letter. For more information, see [How to find sid user and instance number of HANA db?](https://answers.sap.com/questions/555192/how-to-find-sid-user-and-instance-number-of-hana-d.html?)
  *
  * @param request DeleteHanaInstanceRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteHanaInstanceResponse
 */
async function deleteHanaInstanceWithOptions(request: DeleteHanaInstanceRequest, runtime: Util.RuntimeOptions): DeleteHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete an SAP HANA instance, the existing backup data is also deleted and the running backup and restore jobs fail to be completed. Before you delete the SAP HANA instance, make sure that you no longer need the data in the HBR client of the instance and no backup or restore jobs are running for the instance. To delete an SAP HANA instance, you must specify the security identifier (SID) of the instance. The SID is three characters in length and starts with a letter. For more information, see [How to find sid user and instance number of HANA db?](https://answers.sap.com/questions/555192/how-to-find-sid-user-and-instance-number-of-hana-d.html?)
  *
  * @param request DeleteHanaInstanceRequest
  * @return DeleteHanaInstanceResponse
 */
async function deleteHanaInstance(request: DeleteHanaInstanceRequest): DeleteHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHanaInstanceWithOptions(request, runtime);
}

model DeletePolicyBindingRequest {
  dataSourceIds?: [ string ](name='DataSourceIds', description='The IDs of the data sources that you want to disassociate from the backup policy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************hgp'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model DeletePolicyBindingShrinkRequest {
  dataSourceIdsShrink?: string(name='DataSourceIds', description='The IDs of the data sources that you want to disassociate from the backup policy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************hgp'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model DeletePolicyBindingResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='3E961A5E-C5C6-566D-BFC3-0362A6A52EBA'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DeletePolicyBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyBindingResponseBody(name='body'),
}

async function deletePolicyBindingWithOptions(tmpReq: DeletePolicyBindingRequest, runtime: Util.RuntimeOptions): DeletePolicyBindingResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePolicyBindingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceIds)) {
    request.dataSourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceIds, 'DataSourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceIdsShrink)) {
    body['DataSourceIds'] = request.dataSourceIdsShrink;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyBinding',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicyBinding(request: DeletePolicyBindingRequest): DeletePolicyBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyBindingWithOptions(request, runtime);
}

model DeletePolicyV2Request {
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************2l6'),
}

model DeletePolicyV2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='33AA3AAE-89E1-5D3A-A51D-0C0A80850F68'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DeletePolicyV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyV2ResponseBody(name='body'),
}

/**
  * If you delete a backup policy, the backup policy is disassociated with all data sources. Proceed with caution.
  *
  * @param request DeletePolicyV2Request
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeletePolicyV2Response
 */
async function deletePolicyV2WithOptions(request: DeletePolicyV2Request, runtime: Util.RuntimeOptions): DeletePolicyV2Response {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyV2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete a backup policy, the backup policy is disassociated with all data sources. Proceed with caution.
  *
  * @param request DeletePolicyV2Request
  * @return DeletePolicyV2Response
 */
async function deletePolicyV2(request: DeletePolicyV2Request): DeletePolicyV2Response {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyV2WithOptions(request, runtime);
}

model DeleteSnapshotRequest {
  clientId?: string(name='ClientId', description='The ID of the backup client. If you delete a backup file for Elastic Compute Service (ECS) instances, you must set one of the **InstanceId** and ClientId parameters.', example='c-*********************'),
  force?: boolean(name='Force', description='Specifies whether to forcibly delete the most recent backup file. Valid values:

*   true: The system forcibly deletes the last backup file.
*   false: The system does not forcibly delete the last backup file. Default value: false.', example='false'),
  instanceId?: string(name='InstanceId', description='The ID of the ECS instance. If you delete a backup file for Elastic Compute Service (ECS) instances, you must set one of the **ClientId** and InstanceId parameters.', example='i-*********************'),
  snapshotId?: string(name='SnapshotId', description='The ID of the backup file.', example='s-*********************'),
  sourceType?: string(name='SourceType', description='The type of the backup source. Valid values:

*   **ECS_FILE**: indicates backup files for ECS instances.
*   **OSS**: indicates backup files for Object Storage Service (OSS) buckets.
*   **NAS**: indicates the backup files for Apsara File Storage NAS file systems.', example='ECS_FILE'),
  token?: string(name='Token', description='The token.', example='02WJDOE7'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model DeleteSnapshotResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotResponseBody(name='body'),
}

/**
  * If you delete the most recent backup file for a data source, you must set the `Force parameter to true`. Otherwise, an error occurs.
  *
  * @param request DeleteSnapshotRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteSnapshotResponse
 */
async function deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: Util.RuntimeOptions): DeleteSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshot',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you delete the most recent backup file for a data source, you must set the `Force parameter to true`. Otherwise, an error occurs.
  *
  * @param request DeleteSnapshotRequest
  * @return DeleteSnapshotResponse
 */
async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnapshotWithOptions(request, runtime);
}

model DeleteVaultRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmoiyerpacj4q'),
  token?: string(name='Token', description='The token.', example='caeba0bbb2be03f84eb48b699f0a*'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model DeleteVaultResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
}

model DeleteVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVaultResponseBody(name='body'),
}

/**
  * *   You cannot delete a backup vault within 2 hours after the backup vault is created or a backup vault that is in the INITIALIZING state.
  * *   After you delete a backup vault, all resources that are associated with the backup vault are deleted. The resources include backup clients of earlier versions, backup plans, backup jobs, snapshots, and restore jobs.
  *
  * @param request DeleteVaultRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DeleteVaultResponse
 */
async function deleteVaultWithOptions(request: DeleteVaultRequest, runtime: Util.RuntimeOptions): DeleteVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   You cannot delete a backup vault within 2 hours after the backup vault is created or a backup vault that is in the INITIALIZING state.
  * *   After you delete a backup vault, all resources that are associated with the backup vault are deleted. The resources include backup clients of earlier versions, backup plans, backup jobs, snapshots, and restore jobs.
  *
  * @param request DeleteVaultRequest
  * @return DeleteVaultResponse
 */
async function deleteVault(request: DeleteVaultRequest): DeleteVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVaultWithOptions(request, runtime);
}

model DescribeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', description='The IDs of backup clients.', example='["c-*********************"]'),
  clientType?: string(name='ClientType', description='The type of the backup client. Valid value: **ECS_CLIENT**: backup clients for Elastic Compute Service (ECS).', example='ECS_CLIENT'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIds?: map[string]any(name='InstanceIds', description='The IDs of ECS instances.', example='["i-*********************"]'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the backup vault. Valid values of N: 1 to 20.

*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`. .
*   The tag key cannot be an empty string.', example='TestKey'),
      value?: string(name='Value', description='The tag value of the backup vault. Valid values of N: 1 to 20.

*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or ` https://  `.
*   The tag value cannot be an empty string.', example='TestValue'),
    }
  ](name='Tag', description='The information about tags.', example='33738719#'),
}

model DescribeBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds', description='The IDs of backup clients.', example='["c-*********************"]'),
  clientType?: string(name='ClientType', description='The type of the backup client. Valid value: **ECS_CLIENT**: backup clients for Elastic Compute Service (ECS).', example='ECS_CLIENT'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIdsShrink?: string(name='InstanceIds', description='The IDs of ECS instances.', example='["i-*********************"]'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key of the backup vault. Valid values of N: 1 to 20.

*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`. .
*   The tag key cannot be an empty string.', example='TestKey'),
      value?: string(name='Value', description='The tag value of the backup vault. Valid values of N: 1 to 20.

*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or ` https://  `.
*   The tag value cannot be an empty string.', example='TestValue'),
    }
  ](name='Tag', description='The information about tags.', example='33738719#'),
}

model DescribeBackupClientsResponseBody = {
  clients?: [ 
    {
      appliance?: boolean(name='Appliance', description='Indicates whether the backup client is a an integrated hardware monitoring client.

- true: the backup client is an integrated hardware monitoring client.
- false: the backup client is not an integrated hardware monitoring client.', example='false'),
      archType?: string(name='ArchType', description='This parameter is returned only if the **ClientType** parameter is set to **ECS_CLIENT**. This parameter indicates the system architecture of the ECS instance on which the backup client resides. Valid values:

- amd64
- 386', example='amd64'),
      backupStatus?: string(name='BackupStatus', description='The protection status of the backup client. Valid values:

- **UNPROTECTED**: The backup client is not protected.
- **PROTECTED**: The backup client is protected.', example='PROTECTED'),
      clientId?: string(name='ClientId', description='The ID of the client.', example='c-*********************'),
      clientType?: string(name='ClientType', description='The type of the backup client. Valid value: **ECS_CLIENT**: backup clients for Elastic Compute Service (ECS).', example='ECS_CLIENT'),
      clientVersion?: string(name='ClientVersion', description='The version number of the backup client.', example='2.4.5'),
      createdTime?: long(name='CreatedTime', description='The time when the backup client was created. The time follows the UNIX time format. Unit: seconds.', example='1554347313'),
      hostname?: string(name='Hostname', description='The name of the host on which the backup client resides.', example='hostname'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.

- If the type of the backup client is ECS, the value of this parameter indicates the ID of an ECS instance.
- If the type of the backup client is on-premises, the value of this parameter indicates the hardware fingerprint that is generated based on the system information.', example='i-*********************'),
      instanceName?: string(name='InstanceName', description='This parameter is returned only if the **ClientType** parameter is set to **ECS_CLIENT**. The name of the ECS instance.', example='instancename'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime', description='The time when the last heartbeat of the backup client was received. The time follows the UNIX time format. Unit: seconds.', example='1554347313'),
      maxClientVersion?: string(name='MaxClientVersion', description='The version number of the latest backup client.', example='2.4.5'),
      osType?: string(name='OsType', description='This parameter is returned only if the **ClientType** parameter is set to **ECS_CLIENT**. This parameter indicates the system type of the backup client. Valid values:

- **windows**
- **linux**', example='linux'),
      privateIpV4?: string(name='PrivateIpV4', description='This parameter is returned only if the **ClientType** parameter is set to **ECS_CLIENT**. This parameter indicates the internal IP address of the ECS instance.', example='192.168.1.1'),
      settings?: {
        dataNetworkType?: string(name='DataNetworkType', description='The network type of the backup client. Valid values:

- **PUBLIC**: public network
- **VPC**: VPC
- **CLASSIC**: classic network', example='VPC'),
        dataProxySetting?: string(name='DataProxySetting', description='The proxy setting of the backup client. Valid values:

- **DISABLE**: No proxy is configured.
- **USE_CONTROL_PROXY**: The proxy settings are the same as the settings that are preconfigured in the system. Default value: USE_CONTROL_PROXY.
- **CUSTOM**: Custom HTTP proxy settings are configured.', example='USE_CONTROL_PROXY'),
        maxCpuCore?: string(name='MaxCpuCore', description='The number of CPU cores that can be used by a single backup job. A value of 0 indicates no limits.', example='1'),
        maxWorker?: string(name='MaxWorker', description='The number of concurrent tasks that can be included in a backup job. A value of 0 indicates no limits.', example='1'),
        proxyHost?: string(name='ProxyHost', description='The custom IP address of the proxy server.', example='192.168.11.100'),
        proxyPassword?: string(name='ProxyPassword', description='The custom password of the proxy server.', example='******'),
        proxyPort?: int32(name='ProxyPort', description='The custom port number of the proxy server.', example='3128'),
        proxyUser?: string(name='ProxyUser', description='The custom username of the proxy server.', example='user'),
        useHttps?: string(name='UseHttps', description='Indicates whether data is transmitted over HTTPS.

- true: Data is transmitted over HTTPS.
- false: Data is transmitted over HTTP.', example='false'),
      }(name='Settings', description='The settings of the backup client.'),
      status?: string(name='Status', description='The status of the backup client. Valid values:

- **REGISTERED**: The backup client is registered.
- **ACTIVATED**: The backup client is enabled.
- **DEACTIVATED**: The backup client fails to be enabled.
- **INSTALLING**: The backup client is being installed.
- **INSTALL_FAILED**: The backup client fails to be installed.
- **NOT_INSTALLED**: The backup client is not installed.
- **UPGRADING**: The backup client is being upgraded.
- **UPGRADE_FAILED**: The backup client fails to be upgraded.
- **UNINSTALLING**: The backup client is being uninstalled.
- **UNINSTALL_FAILED**: The backup client fails to be uninstalled.
- **STOPPED**: The backup client is out of service.
- **UNKNOWN**: The backup client is disconnected.', example='ACTIVATED'),
      tags?: [ 
        {
          key?: string(name='Key', description='The tag key of the backup vault. Valid values of N: 1 to 20.

- The tag key cannot start with `aliyun` or `acs:`.
- The tag key cannot contain `http://` or `https://`.
- The tag key cannot be an empty string.', example='TestKey'),
          value?: string(name='Value', description='The tag value of the backup vault. Valid values of N: 1 to 20.

- The tag value cannot start with `aliyun` or` acs:`.
- The tag value cannot contain `http://` or `https://` .
- The tag value cannot be an empty string.', example='TestValue'),
        }
      ](name='Tags', description='The information about tags.'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup client was updated. The time follows the UNIX time format. Unit: seconds.', example='1554347313'),
      zoneId?: string(name='ZoneId', description='This parameter is returned only if the **ClientType** parameter is set to **ECS_CLIENT**. This parameter indicates the region where the backup client resides.', example='cn-hangzhou-f'),
    }
  ](name='Clients', description='The backup clients.', example='{\\"Client\\": []}'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

- true: indicates that the request is successful.
- false: indicates that the request fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned backup clients that meet the specified conditions.', example='8'),
}

model DescribeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupClientsResponseBody(name='body'),
}

async function describeBackupClientsWithOptions(tmpReq: DescribeBackupClientsRequest, runtime: Util.RuntimeOptions): DescribeBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    body['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    body['InstanceIds'] = request.instanceIdsShrink;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupClients(request: DescribeBackupClientsRequest): DescribeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupClientsWithOptions(request, runtime);
}

model DescribeBackupJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key', description='The keys in the filter. Valid values:

*   **RegionId**: the ID of a region
*   **PlanId**: the ID of a backup plan
*   **JobId**: the ID of a backup job
*   **VaultId**: the ID of a backup vault
*   **InstanceId**: the ID of an ECS instance
*   **Bucket**: the name of an OSS bucket
*   **FileSystemId**: the ID of a file system
*   **Status**: the status of a backup job
*   **CreatedTime**: the start time of a backup job
*   **CompleteTime**: the end time of a backup job
*   **instanceName**: the name of a Tablestore instance', example='VaultId'),
      operator?: string(name='Operator', description='The matching method. Default value: IN. This parameter specifies the operator that you want to use to match a key and a value in the filter. Valid values:

*   **EQUAL**: equal to
*   **NOT_EQUAL**: not equal to
*   **GREATER_THAN**: greater than
*   **GREATER_THAN_OR_EQUAL**: greater than or equal to
*   **LESS_THAN**: less than
*   **LESS_THAN_OR_EQUAL**: less than or equal to
*   **BETWEEN**: specifies a JSON array as a range. The results must fall within the range in the `[Minimum value,maximum value]` format.
*   **IN**: specifies an array as a collection. The results must fall within the collection.

**

**Note** If you specify **CompleteTime** as a key to query backup jobs, you cannot use the IN operator to perform a match.', example='IN'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters', description='The key-value of the query filter.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  sortDirection?: string(name='SortDirection', description='The order in which you want to sort the results. Valid values:

*   **ASCEND**: sorts the results in ascending order
*   **DESCEND** (default value): sorts the results in descending order', example='DESCEND'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems
*   **OTS**: Tablestore instances
*   **UDM_ECS**: ECS instances
*   **UDM_ECS_DISK**: ECS disks', example='ECS_FILE'),
}

model DescribeBackupJobs2ResponseBody = {
  backupJobs?: {
    backupJob?: [ 
    {
      actualBytes?: long(name='ActualBytes', description='The actual amount of data that is backed up after duplicates are removed. Unit: bytes.', example='600'),
      actualItems?: long(name='ActualItems', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the actual number of objects that are backed up by the backup job.', example='6'),
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      bucket?: string(name='Bucket', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the name of the OSS bucket that is backed up.', example='hbr-backup-oss'),
      bytesDone?: long(name='BytesDone', description='The actual amount of data that is generated by incremental backups. Unit: bytes.', example='800'),
      bytesTotal?: long(name='BytesTotal', description='The total amount of data that is backed up from the data source. Unit: bytes.', example='1000'),
      clientId?: string(name='ClientId', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the ID of the backup client.', example='c-*********************'),
      completeTime?: long(name='CompleteTime', description='The time when the backup job was completed. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      createTime?: long(name='CreateTime', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the time when the file system was created. This value is a UNIX timestamp. Unit: seconds.', example='1607436917'),
      createdTime?: long(name='CreatedTime', description='The time when the backup job was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      crossAccountRoleName?: string(name='CrossAccountRoleName'),
      crossAccountType?: string(name='CrossAccountType'),
      crossAccountUserId?: long(name='CrossAccountUserId'),
      errorMessage?: string(name='ErrorMessage', description='The error message that is returned for the backup job.', example='PARTIAL_COMPLETE'),
      exclude?: string(name='Exclude', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
      fileSystemId?: string(name='FileSystemId', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the ID of the NAS file system.', example='005494'),
      include?: string(name='Include', description='The paths to the files that are included in the backup job.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
      instanceId?: string(name='InstanceId', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the ID of the ECS instance.', example='i-*********************'),
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
      itemsDone?: long(name='ItemsDone', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the number of objects that are backed up.', example='8'),
      itemsTotal?: long(name='ItemsTotal', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the total number of objects in the data source.', example='10'),
      jobId?: string(name='JobId', description='The ID of the backup job.', example='job-000g********w7'),
      jobName?: string(name='JobName', description='The name of the backup job.', example='jobname'),
      options?: string(name='Options', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates whether Windows VSS is used to define a backup path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames', description='The names of the destination tables in the Tablestore instance.'),
      }(name='OtsDetail', description='The details about the Tablestore instance.'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths', description='The backup paths.'),
      planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-20********35'),
      prefix?: string(name='Prefix', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the prefix of objects that are backed up.', example='example/'),
      progress?: int32(name='Progress', description='The backup progress. For example, 10000 indicates that the progress is 100%.', example='10000'),
      report?: {
        failedFiles?: string(name='FailedFiles'),
        reportTaskStatus?: string(name='ReportTaskStatus'),
        skippedFiles?: string(name='SkippedFiles'),
        successFiles?: string(name='SuccessFiles'),
        totalFiles?: string(name='TotalFiles'),
      }(name='Report'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: OSS buckets
*   **NAS**: NAS file systems', example='ECS_FILE'),
      speed?: long(name='Speed', description='The average speed at which data is backed up. Unit: KB/s.', example='500'),
      speedLimit?: string(name='SpeedLimit', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the throttling rules. Format: `{start}{end}{bandwidth}`. Multiple throttling rules are separated with vertical bars (`{start}|{end}|{bandwidth}`). A specified time range cannot overlap with another one.

*   **start**: the start hour
*   **end**: the end hour
*   **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:5120'),
      startTime?: long(name='StartTime', description='The time when the backup job started. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      status?: string(name='Status', description='The status of the backup job. Valid values:

*   **COMPLETE**: The backup job is completed.
*   **PARTIAL_COMPLETE**: The backup job is partially completed.
*   **FAILED**: The restore job has failed.', example='COMPLETE'),
      tableName?: string(name='TableName', description='The name of a destination table in the Tablestore instance.', example='table1'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup job was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
    }
  ](name='BackupJob')
  }(name='BackupJobs', description='The returned backup jobs that meet the specified conditions.'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned backup jobs that meet the specified conditions.', example='8'),
}

model DescribeBackupJobs2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupJobs2ResponseBody(name='body'),
}

async function describeBackupJobs2WithOptions(request: DescribeBackupJobs2Request, runtime: Util.RuntimeOptions): DescribeBackupJobs2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirection)) {
    query['SortDirection'] = request.sortDirection;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupJobs2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupJobs2(request: DescribeBackupJobs2Request): DescribeBackupJobs2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupJobs2WithOptions(request, runtime);
}

model DescribeBackupPlansRequest {
  filters?: [ 
    {
      key?: string(name='Key', description='The keys in the filter. Valid values:

*   **regionId**: the ID of a region
*   **restoreId**: the ID of a restore job
*   **sourceType**: the type of a data source
*   **vaultId**: the ID of a backup vault
*   **targetInstanceId**: the ID of an ECS instance
*   **targetBucket**: the name of an OSS bucket
*   **targetFileSystemId**: the ID of a file system', example='vaultId'),
      values?: [ string ](name='Values', description='The values that you want to match in the filter.', example='["v-*********************"]'),
    }
  ](name='Filters', description='The query filter.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
}

model DescribeBackupPlansResponseBody = {
  backupPlans?: {
    backupPlan?: [ 
    {
      backupSourceGroupId?: string(name='BackupSourceGroupId', description='The ID of the data source group for backup.', example='System-Database'),
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      bucket?: string(name='Bucket', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the name of the OSS bucket.', example='hbr-backup-oss'),
      clientId?: string(name='ClientId', description='The ID of the client.', example='c-000ge4w*****1qb'),
      clusterId?: string(name='ClusterId', description='The ID of the client group.', example='cl-000ht6o9******h'),
      createTime?: long(name='CreateTime', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the time when the file system was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      createdTime?: long(name='CreatedTime', description='The time when the backup plan was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      crossAccountRoleName?: string(name='CrossAccountRoleName'),
      crossAccountType?: string(name='CrossAccountType'),
      crossAccountUserId?: long(name='CrossAccountUserId'),
      dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='ds-000ht6o9*****w61'),
      detail?: string(name='Detail', description='The details about server backup.', example='{\\"doCopy\\":true,\\"doBackup\\":false,\\"instanceName\\":\\"instance example\\",\\"appConsistent\\":false,\\"destinationRegionId\\":\\"cn-shanghai\\",\\"enableFsFreeze\\":true,\\"osNameEn\\":\\"Windows Server 2019 Datacenter Edition 64-bit Chinese Version\\",\\"osName\\":\\"Windows Server 2019 Datacenter Edition 64-bit Chinese Version\\",\\"diskIdList\\":[],\\"backupVaultId\\":\\"\\",\\"snapshotGroup\\":true,\\"destinationRetention\\":35,\\"platform\\":\\"Windows Server 2012\\",\\"timeoutInSeconds\\":60,\\"backupRetention\\":1,\\"osType\\":\\"windows\\",\\"preScriptPath\\":\\"\\",\\"postScriptPath\\":\\"\\",\\"enableWriters\\":true,\\"ecsDeleted\\":false}'),
      disabled?: boolean(name='Disabled', description='Indicates whether the backup plan is disabled. Valid values:

*   true: The backup plan is disabled.
*   false: The backup plan is enabled.', example='false'),
      exclude?: string(name='Exclude', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the paths to the files that are excluded from the backup job.', example='["/var", "/proc"]'),
      fileSystemId?: string(name='FileSystemId', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the ID of the NAS file system.', example='00594'),
      include?: string(name='Include', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the paths to the files that are backed up.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
      instanceGroupId?: string(name='InstanceGroupId', description='The ID of instance group.', example='i-**'),
      instanceId?: string(name='InstanceId', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the ID of the ECS instance.', example='i-*********************'),
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
      keepLatestSnapshots?: long(name='KeepLatestSnapshots'),
      options?: string(name='Options', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates whether Windows VSS is used to define a backup path.', example='{"UseVSS":false}'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames', description='The names of the destination tables in the Tablestore instance.'),
      }(name='OtsDetail', description='The details about the Tablestore instance.'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the backup paths.'),
      planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
      planName?: string(name='PlanName', description='The name of the backup plan.', example='planname'),
      prefix?: string(name='Prefix', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the prefix of objects that are backed up.', example='oss-prefix'),
      resources?: {
        resource?: [ 
        {
          extra?: string(name='Extra', description='Additional information about the data source.', example='{\\"doBackup\\":false,\\"diskName\\":\\"Data disk\\",\\"size\\":100,\\"type\\":\\"data\\",\\"category\\":\\"cloud_essd\\",\\"imageId\\":\\"\\",\\"device\\":\\"/dev/xvdb\\",\\"encrypted\\":false}'),
          resourceId?: string(name='ResourceId', description='The ID of the data source.', example='d-j6cgioir6mi19jalulu4'),
          sourceType?: string(name='SourceType', description='The type of the data source. Valid value: UDM_DISK.', example='UDM_DISK'),
        }
      ](name='Resource')
      }(name='Resources', description='The list of backup resources. This parameter is returned only for disk backup.'),
      retention?: long(name='Retention', description='The retention period of backup data.', example='7'),
      rules?: {
        rule?: [ 
        {
          backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
          destinationRegionId?: string(name='DestinationRegionId', description='The ID of the region where the remote backup vault resides.', example='cn-shanghai'),
          destinationRetention?: long(name='DestinationRetention', description='The retention period of backup data.', example='90'),
          disabled?: boolean(name='Disabled', description='Indicates whether the policy is disabled.', example='true'),
          doCopy?: boolean(name='DoCopy', description='Indicates whether the snapshot data is backed up to the backup vault.', example='false'),
          retention?: long(name='Retention', description='The retention period of backup data.', example='90'),
          ruleId?: string(name='RuleId', description='The ID of the policy.', example='rule-0008i52rf0ulpni6kn6m'),
          ruleName?: string(name='RuleName', description='The name of the policy.', example='Disk Golden Rule'),
          schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   `startTime`: the time at which the system starts to run a backup job. The time follows the UNIX time format. Unit: seconds.
*   `interval`: the interval at which the system runs a backup job. The interval follows the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1631685600|P1D'),
        }
      ](name='Rule')
      }(name='Rules', description='The list of backup policies. This parameter is returned only for disk backup.'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time follows the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval follows the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: OSS buckets
*   **NAS**: NAS file systems', example='ECS_FILE'),
      speedLimit?: string(name='SpeedLimit', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the throttling rules. Format: `{start}|{end}|{bandwidth}`. Separate multiple throttling rules with vertical bars (`|`). A specified time range cannot overlap with another one.

*   start: the start hour.
*   end: the end hour.
*   bandwidth: the bandwidth. Unit: KB/s.', example='0:24:5120'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration', description='Indicates whether you are billed based on the pay-as-you-go method after the free trial ends.', example='true'),
        trialExpireTime?: long(name='TrialExpireTime', description='The expiration time of the free trial.', example='1584597600'),
        trialStartTime?: long(name='TrialStartTime', description='The start time of the free trial.', example='1579413159'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime', description='The time when the free-trial repository is released.', example='1594965600'),
      }(name='TrialInfo', description='The free trial information.'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup plan was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
    }
  ](name='BackupPlan')
  }(name='BackupPlans', description='The returned backup plans that meet the specified conditions.'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned backup plans that meet the specified conditions.', example='8'),
}

model DescribeBackupPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPlansResponseBody(name='body'),
}

async function describeBackupPlansWithOptions(request: DescribeBackupPlansRequest, runtime: Util.RuntimeOptions): DescribeBackupPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPlans',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPlans(request: DescribeBackupPlansRequest): DescribeBackupPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPlansWithOptions(request, runtime);
}

model DescribeClientsRequest {
  clientId?: string(name='ClientId', description='The ID of the backup client.', example='c-000ed600******6b0'),
  clientType?: string(name='ClientType', description='The type of the backup client. Valid value:**ECS_AGENT**, which indicates an SAP HANA backup client.', example='ECS_AGENT'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0005ni1******2l87'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmw6bxl7o5qyq'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid value:**HANA**, which indicates SAP HANA backup.', example='HANA'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0001vk0z******xdyr'),
}

model DescribeClientsResponseBody = {
  clients?: {
    client?: [ 
    {
      alertSetting?: string(name='AlertSetting', description='The alert settings. Valid value: INHERITED, which indicates that the backup client sends alert notifications in the same way as the backup vault.', example='INHERITED'),
      clientId?: string(name='ClientId', description='The ID of the backup client.', example='c-00062uu******2fgj'),
      clientName?: string(name='ClientName', description='The name of the backup client.', example='client-20211224-101226'),
      clientType?: string(name='ClientType', description='The type of the backup client. Valid value:**ECS_AGENT**, which indicates an SAP HANA backup client.', example='ECS_AGENT'),
      clientVersion?: string(name='ClientVersion', description='The version number of the backup client.', example='1.11.16'),
      clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0008c48frr******ncpk'),
      createdTime?: long(name='CreatedTime', description='The time when the backup client was created.', example='1554347313'),
      instanceId?: string(name='InstanceId', description='The ID of the instance.', example='i-wz9b6wya******n8yo'),
      instanceName?: string(name='InstanceName', description='The name of the ECS instance.', example='swh-hbr'),
      maxVersion?: string(name='MaxVersion', description='The maximum version number of the backup client.', example='1.11.23'),
      networkType?: string(name='NetworkType', description='The network type. Valid values:

*   **CLASSIC**: classic network
*   **VPC**: virtual private cloud (VPC)', example='VPC'),
      status?: string(name='Status', description='The status of the backup client. Valid values:

*   **REGISTERED**: The backup client is registered.
*   **ACTIVATED**: The backup client is enabled.
*   **DEACTIVATED**: The backup client fails to be enabled.
*   **INSTALLING**: The backup client is being installed.
*   **INSTALL_FAILED**: The backup client fails to be installed.
*   **NOT_INSTALLED**: The backup client is not installed.
*   **UPGRADING**: The backup client is being upgraded.
*   **UPGRADE_FAILED**: The backup client fails to be upgraded.
*   **UNINSTALLING**: The backup client is being uninstalled.
*   **UNINSTALL_FAILED**: The backup client fails to be uninstalled.
*   **STOPPED**: The backup client is out of service.
*   **UNKNOWN**: The backup client is disconnected.', example='ACTIVATED'),
      statusMessage?: string(name='StatusMessage', description='The status information.', example='HANA_NOT_SUPPORT'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup client was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      useHttps?: boolean(name='UseHttps', description='Indicates whether data is transmitted over HTTPS. Valid values:

*   true: Data is transmitted over HTTPS.
*   false: Data is transmitted over HTTP.', example='false'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-00029mx6o******n85lg'),
    }
  ](name='Client')
  }(name='Clients', description='The backup clients.'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='17189276-465D-5EF3-8FFD-0FF51B5A41A0'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='12'),
}

model DescribeClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClientsResponseBody(name='body'),
}

/**
  * This operation is applicable only to SAP HANA backup. For backup clients of other data sources, call the DescribeBackupClients operation.
  *
  * @param request DescribeClientsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeClientsResponse
 */
async function describeClientsWithOptions(request: DescribeClientsRequest, runtime: Util.RuntimeOptions): DescribeClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * This operation is applicable only to SAP HANA backup. For backup clients of other data sources, call the DescribeBackupClients operation.
  *
  * @param request DescribeClientsRequest
  * @return DescribeClientsResponse
 */
async function describeClients(request: DescribeClientsRequest): DescribeClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientsWithOptions(request, runtime);
}

model DescribeContainerClusterRequest {
  clusterId?: string(name='ClusterId', description='The cluster id.', example='cc-0007xt00u1q2lownbhg9'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
}

model DescribeContainerClusterResponseBody = {
  clusters?: [ 
    {
      agentStatus?: string(name='AgentStatus', description='Agent status.', example='READY'),
      clusterId?: string(name='ClusterId', description='The cluster id.', example='cl-0006gwppd0jtttpmb0ri'),
      clusterType?: string(name='ClusterType', description='Cluster type, which only supports ACK, that indicates Alibaba Cloud Container Service.', example='ACK'),
      description?: string(name='Description', description='The description of container cluster.', example='description ack pv backup'),
      identifier?: string(name='Identifier', description='Cluster ID.', example='c5bbd0931a30947f4ab85efd19380a72d'),
      name?: string(name='Name', description='Cluster name.', example='ack_pv_backup_location'),
      networkType?: string(name='NetworkType', description='Network type, values includes:

- CLASSIC: classic network.
- VPC: virtual private cloud.', example='VPC'),
      token?: string(name='Token', description='The Token.', example='eyJhY2Nvd******A/VnZpgXQC5A=='),
    }
  ](name='Clusters', description='The clusters.'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CC94B755-C3C2-5B9D-BD77-E0FE819A4DB2'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

- true: The call is successful.
- false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned container cluster that meet the specified conditions.', example='8'),
}

model DescribeContainerClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerClusterResponseBody(name='body'),
}

async function describeContainerClusterWithOptions(request: DescribeContainerClusterRequest, runtime: Util.RuntimeOptions): DescribeContainerClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerCluster(request: DescribeContainerClusterRequest): DescribeContainerClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerClusterWithOptions(request, runtime);
}

model DescribeHanaBackupPlansRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000chxz******lz7bk'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmvywqfey5njq'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000i4lg4kz******ahl'),
}

model DescribeHanaBackupPlansResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  hanaBackupPlans?: {
    hanaBackupPlan?: [ 
    {
      backupPrefix?: string(name='BackupPrefix', description='The backup prefix.', example='COMPLETE_DATA_BACKUP'),
      backupType?: string(name='BackupType', description='The backup type. Valid values:

*   COMPLETE: full backup
*   INCREMENTAL: incremental backup
*   DIFFERENTIAL: differential backup', example='COMPLETE'),
      clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0002scknka*****'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
      disabled?: boolean(name='Disabled', description='Indicates whether the backup plan is disabled. Valid values:

*   true: The backup plan is disabled.
*   false: The backup plan is enabled.', example='false'),
      planId?: string(name='PlanId', description='The ID of the backup plan.', example='pl-0000tnyndg3ne5m4ubeu'),
      planName?: string(name='PlanName', description='The name of the backup plan.', example='plan-20220118-141153'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time follows the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval follows the ISO 8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000csihw82pqkd7hcjws'),
    }
  ](name='HanaBackupPlan')
  }(name='HanaBackupPlans', description='The details of the backup plan.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F029C1C7-26B6-5ADD-A73E-D85CCD7C73A9'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned entries.', example='6'),
}

model DescribeHanaBackupPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupPlansResponseBody(name='body'),
}

async function describeHanaBackupPlansWithOptions(request: DescribeHanaBackupPlansRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupPlans',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaBackupPlans(request: DescribeHanaBackupPlansRequest): DescribeHanaBackupPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupPlansWithOptions(request, runtime);
}

model DescribeHanaBackupSettingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-00068btz******oku'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000css******za5uyqr'),
}

model DescribeHanaBackupSettingResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  hanaBackupSetting?: {
    catalogBackupParameterFile?: string(name='CatalogBackupParameterFile', description='The configuration file for catalog backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
    catalogBackupUsingBackint?: boolean(name='CatalogBackupUsingBackint', description='Indicates whether Backint is used to back up catalogs. Valid values:

*   true: Backint is used to back up catalogs.
*   false: Backint is not used to back up catalogs.', example='false'),
    dataBackupParameterFile?: string(name='DataBackupParameterFile', description='The configuration file for data backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
    databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
    enableAutoLogBackup?: boolean(name='EnableAutoLogBackup', description='Indicates whether automatic log backup is enabled. Valid values:

*   **true**: Automatic log backup is enabled.
*   **false**: Automatic log backup is disabled.', example='true'),
    logBackupParameterFile?: string(name='LogBackupParameterFile', description='The configuration file for log backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
    logBackupTimeout?: long(name='LogBackupTimeout', description='The interval at which logs are backed up. Unit: seconds.', example='900'),
    logBackupUsingBackint?: boolean(name='LogBackupUsingBackint', description='Indicates whether Backint is used to back up logs. Valid values:

*   true: Backint is used to back up logs.
*   false: Backint is not used to back up logs.', example='true'),
  }(name='HanaBackupSetting', description='The backup settings.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='9D0DB5BC-5071-5ADF-BCD1-14EBB0C17C54'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DescribeHanaBackupSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupSettingResponseBody(name='body'),
}

/**
  * If you want to query the backup retention period of a database, you can call the DescribeHanaRetentionSetting operation.
  *
  * @param request DescribeHanaBackupSettingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeHanaBackupSettingResponse
 */
async function describeHanaBackupSettingWithOptions(request: DescribeHanaBackupSettingRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you want to query the backup retention period of a database, you can call the DescribeHanaRetentionSetting operation.
  *
  * @param request DescribeHanaBackupSettingRequest
  * @return DescribeHanaBackupSettingResponse
 */
async function describeHanaBackupSetting(request: DescribeHanaBackupSettingRequest): DescribeHanaBackupSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupSettingWithOptions(request, runtime);
}

model DescribeHanaBackupsAsyncRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-00098******yuqvu'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='BPD'),
  includeDifferential?: boolean(name='IncludeDifferential', description='Specifies whether to include differential backups in the query results. Valid values:

*   true: includes differential backups.
*   false: excludes differential backups.', example='false'),
  includeIncremental?: boolean(name='IncludeIncremental', description='Specifies whether to include incremental backups in the query results. Valid values:

*   true: includes incremental backups.
*   false: excludes incremental backups.', example='true'),
  includeLog?: boolean(name='IncludeLog', description='Specifies whether to include log backups in the query results. Valid values:

*   true: includes log backups.
*   false: excludes log backups.', example='true'),
  logPosition?: long(name='LogPosition', description='The log position to which you want to restore the database. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_LOG_POSITION**.', example='0'),
  mode?: string(name='Mode', description='The recovery mode. Valid values:

*   **RECOVERY_TO_MOST_RECENT**: restores the database to the recently available state to which the database has been backed up.
*   **RECOVERY_TO_POINT_IN_TIME**: restores the database to a specified point in time.
*   **RECOVERY_TO_SPECIFIC_BACKUP**: restores the database to a specified backup.
*   **RECOVERY_TO_LOG_POSITION**: restores the database to a specified log position.', example='RECOVERY_TO_SPECIFIC_BACKUP'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  recoveryPointInTime?: long(name='RecoveryPointInTime', description='The point in time to which you want to restore the database. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_POINT_IN_TIME**. HBR restores the database to a state closest to the specified point in time.', example='1649851200'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmz7mced2ldhy'),
  source?: string(name='Source', description='The name of the source system. This parameter specifies the name of the source database that you want to restore. You must set the parameter in the `<Source database name>@SID` format.', example='P01@HP1'),
  sourceClusterId?: string(name='SourceClusterId', description='The ID of the source SAP HANA instance.', example='cl-0000g3m******5cj'),
  systemCopy?: boolean(name='SystemCopy', description='Specifies whether to restore the database to a different instance. Valid values:

*   true: restores the database to a different instance.
*   false: restores the database within the same instance.', example='true'),
  useBackint?: boolean(name='UseBackint', description='Specifies whether Backint is used. Valid values:

*   true: Backint is used.
*   false: Backint is not used.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000270c******pi81'),
  volumeId?: int32(name='VolumeId', description='The ID of the volume that you want to restore. This parameter is valid only if you set the Mode parameter to **RECOVERY_TO_LOG_POSITION**.', example='0'),
}

model DescribeHanaBackupsAsyncResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='31F97233-8563-563D-8880-914B00EEA928'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous job. You can call the DescribeTask operation to query the execution result of the asynchronous job.', example='t-0006xmbplrqebt9dhkth'),
}

model DescribeHanaBackupsAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupsAsyncResponseBody(name='body'),
}

/**
  * After you call the DescribeHanaBackupsAsync operation to query the SAP HANA backups that meet the specified conditions, call the DescribeTask operation to query the execution result of the asynchronous job.
  *
  * @param request DescribeHanaBackupsAsyncRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeHanaBackupsAsyncResponse
 */
async function describeHanaBackupsAsyncWithOptions(request: DescribeHanaBackupsAsyncRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupsAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.includeDifferential)) {
    query['IncludeDifferential'] = request.includeDifferential;
  }
  if (!Util.isUnset(request.includeIncremental)) {
    query['IncludeIncremental'] = request.includeIncremental;
  }
  if (!Util.isUnset(request.includeLog)) {
    query['IncludeLog'] = request.includeLog;
  }
  if (!Util.isUnset(request.logPosition)) {
    query['LogPosition'] = request.logPosition;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recoveryPointInTime)) {
    query['RecoveryPointInTime'] = request.recoveryPointInTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceClusterId)) {
    query['SourceClusterId'] = request.sourceClusterId;
  }
  if (!Util.isUnset(request.systemCopy)) {
    query['SystemCopy'] = request.systemCopy;
  }
  if (!Util.isUnset(request.useBackint)) {
    query['UseBackint'] = request.useBackint;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.volumeId)) {
    query['VolumeId'] = request.volumeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupsAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After you call the DescribeHanaBackupsAsync operation to query the SAP HANA backups that meet the specified conditions, call the DescribeTask operation to query the execution result of the asynchronous job.
  *
  * @param request DescribeHanaBackupsAsyncRequest
  * @return DescribeHanaBackupsAsyncResponse
 */
async function describeHanaBackupsAsync(request: DescribeHanaBackupsAsyncRequest): DescribeHanaBackupsAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupsAsyncWithOptions(request, runtime);
}

model DescribeHanaDatabasesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000hpc******uv14x'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmw2azsegupmi'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-00063fq******8xjr'),
}

model DescribeHanaDatabasesResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  hanaDatabases?: {
    hanaDatabase?: [ 
    {
      activeStatus?: string(name='ActiveStatus', description='Indicates whether the database is started. Valid values:

*   **YES**: The database is started.
*   **NO**: The database is not started.', example='YES'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
      detail?: string(name='Detail', description='The detailed information.', example='master'),
      host?: string(name='Host', description='The hostname.', example='izbp1jbf3zy******antqmz'),
      serviceName?: string(name='ServiceName', description='The name of the service.', example='indexserver'),
      sqlPort?: int32(name='SqlPort', description='The port number.', example='30013'),
    }
  ](name='HanaDatabase')
  }(name='HanaDatabases', description='The information about SAP HANA databases.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='DAAB6A29-34EB-5F56-962F-D5BDBFE8A5C2'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned entries.', example='10'),
}

model DescribeHanaDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaDatabasesResponseBody(name='body'),
}

/**
  * After you register an SAP HANA instance and install a backup client on the instance, you can call this operation to query the information about SAP HANA databases. You can call the StartHanaDatabaseAsync operation to start a database and call the StopHanaDatabaseAsync operation to stop a database.
  *
  * @param request DescribeHanaDatabasesRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeHanaDatabasesResponse
 */
async function describeHanaDatabasesWithOptions(request: DescribeHanaDatabasesRequest, runtime: Util.RuntimeOptions): DescribeHanaDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaDatabases',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * After you register an SAP HANA instance and install a backup client on the instance, you can call this operation to query the information about SAP HANA databases. You can call the StartHanaDatabaseAsync operation to start a database and call the StopHanaDatabaseAsync operation to stop a database.
  *
  * @param request DescribeHanaDatabasesRequest
  * @return DescribeHanaDatabasesResponse
 */
async function describeHanaDatabases(request: DescribeHanaDatabasesRequest): DescribeHanaDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaDatabasesWithOptions(request, runtime);
}

model DescribeHanaInstancesRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0001zfc******50pr3'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aekz24ikcjyqjkq'),
  tag?: [ 
    {
      key?: string(name='Key', description='The tag key.', example='ace:rm:rgld'),
      value?: string(name='Value', description='The tag value.', example='rg-acfmwutpyat2kwy'),
    }
  ](name='Tag', description='The tags of SAP HANA instance.'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000b0ov******6zs'),
}

model DescribeHanaInstancesResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  hanas?: {
    hana?: [ 
    {
      alertSetting?: string(name='AlertSetting', description='The alert settings. Valid value: INHERITED, which indicates that the backup client sends alert notifications in the same way as the backup vault.', example='INHERITED'),
      clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0004cf6g6******0yd7y'),
      hanaName?: string(name='HanaName', description='The name of the SAP HANA instance.', example='HANA-DEV'),
      host?: string(name='Host', description='The private or internal IP address of the host where the primary node of the SAP HANA instance resides.', example='47.100.XX.XX'),
      instanceNumber?: int32(name='InstanceNumber', description='The instance number of the SAP HANA system.', example='00'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of resource group.', example='rg-acfmvnf22m7itha'),
      status?: long(name='Status', description='The status of the SAP HANA instance. Valid values:

*   INITIALIZING: The instance is being initialized.
*   INITIALIZED: The instance is registered.
*   INVALID_HANA_NODE: The instance is invalid.
*   INITIALIZE_FAILED: The client fails to be installed on the instance.', example='INITIALIZED'),
      statusMessage?: string(name='StatusMessage', description='The status information.', example='INSTALL_CLIENT_FAILED'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key.', example='ace:rm:rgld'),
          value?: string(name='Value', description='The tag value.', example='rg-acfmwutpyat2kwy'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags of the SAP HANA instance.'),
      useSsl?: boolean(name='UseSsl', description='Indicates whether the SAP HANA instance is connected over Secure Sockets Layer (SSL). Valid values:

*   true: The SAP HANA instance is connected over SSL.
*   false: The SAP HANA instance is not connected over SSL.', example='true'),
      userName?: string(name='UserName', description='The username of the SYSTEMDB database.', example='admin'),
      validateCertificate?: boolean(name='ValidateCertificate', description='Indicates whether the SSL certificate of the SAP HANA instance is verified.', example='false'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0000s974******1hl'),
    }
  ](name='Hana')
  }(name='Hanas', description='The information about the SAP HANA instances.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4003DD68-3C3C-5071-B4FC-631A6C1BAC1C'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='21'),
}

model DescribeHanaInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaInstancesResponseBody(name='body'),
}

async function describeHanaInstancesWithOptions(request: DescribeHanaInstancesRequest, runtime: Util.RuntimeOptions): DescribeHanaInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaInstances',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaInstances(request: DescribeHanaInstancesRequest): DescribeHanaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaInstancesWithOptions(request, runtime);
}

model DescribeHanaRestoresRequest {
  backupId?: long(name='BackupId', description='The ID of the backup.', example='1632754800158'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000b******soejg'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm4ebtpkzx7zy'),
  restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='r-0007o3vqfukfe92hvf13'),
  restoreStatus?: string(name='RestoreStatus', description='The status of the restore job. Valid values:

*   **RUNNING**: The restore job is running.
*   **COMPLETE**: The restore job is completed.
*   **PARTIAL_COMPLETE**: The restore job is partially completed.
*   **FAILED**: The restore job has failed.
*   **CANCELED**: The restore job is canceled.
*   **EXPIRED**: The restore job has timed out.', example='COMPLETE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000au6bq******mpu'),
}

model DescribeHanaRestoresResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  hanaRestore?: {
    hanaRestores?: [ 
    {
      backupID?: long(name='BackupID', description='The ID of the backup.', example='1635315505'),
      backupPrefix?: string(name='BackupPrefix', description='The backup prefix.', example='INC_DATA_BACKUP'),
      checkAccess?: boolean(name='CheckAccess', description='Indicates whether the differential backup and log backup are validated. Valid values:

*   true: HBR checks whether the required differential backup and log backup are available before the restore job starts. If the differential backup or log backup is unavailable, HBR does not start the restore job.
*   false: HBR does not check whether the required differential backup and log backup are available before the restore job starts.', example='true'),
      clearLog?: boolean(name='ClearLog', description='Indicates whether all log entries are deleted from the log area after the log entries are restored. Valid values: true and false. If the return value is false, all log entries are deleted from the log area after the log entries are restored.', example='true'),
      clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance that is restored.', example='cl-000923yu******p00j4'),
      currentPhase?: int32(name='CurrentPhase', description='The current recovery phase. This value is obtained from SAP HANA.', example='2'),
      currentProgress?: long(name='CurrentProgress', description='The current progress. This value is obtained from SAP HANA.', example='1'),
      databaseName?: string(name='DatabaseName', description='The name of the database.', example='BWD'),
      databaseRestoreId?: long(name='DatabaseRestoreId', description='The ID of the database recovery.', example='1644038961030'),
      endTime?: long(name='EndTime', description='The time when the restore job ends. This value is a UNIX timestamp. Unit: seconds.', example='1634356382'),
      logPosition?: long(name='LogPosition', description='The log position to which the database is restored. This parameter is returned only if the value of the Mode parameter is **RECOVERY_TO_LOG_POSITION**.', example='0'),
      maxPhase?: int32(name='MaxPhase', description='The maximum recovery phase. This value is obtained from SAP HANA.', example='4'),
      maxProgress?: long(name='MaxProgress', description='The maximum progress. This value is obtained from SAP HANA.', example='1'),
      message?: string(name='Message', description='The details of the recovery phase.', example='SQL Error 448 - recovery could not be completed:'),
      mode?: string(name='Mode', description='The recovery mode. Valid values:

*   **RECOVERY_TO_MOST_RECENT**: The database is restored to the recently available state to which the database has been backed up.
*   **RECOVERY_TO_POINT_IN_TIME**: The database is restored to a specified point in time.
*   **RECOVERY_TO_SPECIFIC_BACKUP**: The database is restored to a specified backup.
*   **RECOVERY_TO_LOG_POSITION**: The database is restored to a specified log position.', example='RECOVERY_TO_SPECIFIC_BACKUP'),
      phase?: string(name='Phase', description='The recovery phase.', example='restart'),
      reachedTime?: long(name='ReachedTime', description='The point in time at which the database is restored.', example='1635315505'),
      recoveryPointInTime?: long(name='RecoveryPointInTime', description='The point in time to which the database is restored. This parameter is returned only if the value of the Mode parameter is **RECOVERY_TO_POINT_IN_TIME**. HBR restores the database to a state closest to the specified point in time.', example='1649851200'),
      restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='r-000c1en183ayn9sesgqh'),
      source?: string(name='Source', description='The name of the source system. This parameter indicates the name of the source database that is restored. Format: `<Source database name>@SID`.', example='PRD@H4P'),
      sourceClusterId?: string(name='SourceClusterId', description='The ID of the source SAP HANA instance.', example='cl-0000g3mvy******5cj'),
      startTime?: long(name='StartTime', description='The time when the restore job starts. This value is a UNIX timestamp. Unit: seconds.', example='1636970413'),
      state?: string(name='State', description='The recovery status. This value is obtained from SAP HANA.', example='successful'),
      status?: string(name='Status', description='The status of the restore job. Valid values:

*   **RUNNING**: The restore job is running.
*   **COMPLETE**: The restore job is completed.
*   **PARTIAL_COMPLETE**: The restore job is partially completed.
*   **FAILED**: The restore job has failed.
*   **CANCELED**: The restore job is canceled.
*   **EXPIRED**: The restore job has timed out.', example='COMPLETE'),
      systemCopy?: boolean(name='SystemCopy', description='Indicates whether the database is restored to a different instance. Valid values:

*   true: The database is restored to a different instance.
*   false: The database is restored within the same instance.', example='true'),
      useCatalog?: boolean(name='UseCatalog', description='Indicates whether a catalog backup is used to restore the database. This parameter is returned only if the value of the Mode parameter is **RECOVERY_TO_SPECIFIC_BACKUP**. If the return value is false, HBR finds the backup file based on the specified prefix and then restores the backup file.', example='false'),
      useDelta?: boolean(name='UseDelta', description='Indicates whether a differential backup or an incremental backup is used to restore the database. Valid values: true and false. If the return value is true, HBR uses a differential backup or an incremental backup to restore the database. If the return value is false, HBR uses a log backup to restore the database.', example='true'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000g9acf******gta'),
      volumeId?: int32(name='VolumeId', description='The ID of the volume that is restored. This parameter is returned only if the value of the Mode parameter is **RECOVERY_TO_LOG_POSITION**.', example='0'),
    }
  ](name='HanaRestores')
  }(name='HanaRestore', description='The information about restore jobs.'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7DEFC897-8F05-5C05-912C-C9A9510FBFF1'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='19'),
}

model DescribeHanaRestoresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaRestoresResponseBody(name='body'),
}

async function describeHanaRestoresWithOptions(request: DescribeHanaRestoresRequest, runtime: Util.RuntimeOptions): DescribeHanaRestoresResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.restoreId)) {
    query['RestoreId'] = request.restoreId;
  }
  if (!Util.isUnset(request.restoreStatus)) {
    query['RestoreStatus'] = request.restoreStatus;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaRestores',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaRestores(request: DescribeHanaRestoresRequest): DescribeHanaRestoresResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaRestoresWithOptions(request, runtime);
}

model DescribeHanaRetentionSettingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0002ys1i******wwtf'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='C4P'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000ii8t******ntrt2'),
}

model DescribeHanaRetentionSettingResponseBody = {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0003jyv******fsku5m'),
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='Q01'),
  disabled?: boolean(name='Disabled', description='Indicates whether the backup is permanently retained. Valid values:

*   true: The backup is permanently retained.
*   false: The backup is retained for the specified number of days.', example='false'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='280DD872-EE25-52E8-9CB4-491067173DD0'),
  retentionDays?: long(name='RetentionDays', description='The number of days for which the backup is retained. If the value of the Disabled parameter is false, the backup is retained for the number of days specified by this parameter.', example='3650'),
  schedule?: string(name='Schedule', description='The policy to update the retention period. Format: `I|{startTime}|{interval}`, which indicates that the retention period is updated at an interval of {interval} starting from {startTime}.

*   startTime: the time at which the system starts to update the retention period. The time follows the UNIX time format. Unit: seconds.
*   interval: the interval at which the system updates the retention period. The interval follows the ISO 8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|0|P1D'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006wkn7******zkn'),
}

model DescribeHanaRetentionSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaRetentionSettingResponseBody(name='body'),
}

/**
  * *   If you want to query the backup parameters of a database, you can call the DescribeHanaBackupSetting operation.
  * *   HBR deletes the expired catalogs and data that are related to Backint and file backup. The deleted catalogs and data cannot be restored. We recommend that you set the retention period based on your business requirements.
  *
  * @param request DescribeHanaRetentionSettingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DescribeHanaRetentionSettingResponse
 */
async function describeHanaRetentionSettingWithOptions(request: DescribeHanaRetentionSettingRequest, runtime: Util.RuntimeOptions): DescribeHanaRetentionSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaRetentionSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you want to query the backup parameters of a database, you can call the DescribeHanaBackupSetting operation.
  * *   HBR deletes the expired catalogs and data that are related to Backint and file backup. The deleted catalogs and data cannot be restored. We recommend that you set the retention period based on your business requirements.
  *
  * @param request DescribeHanaRetentionSettingRequest
  * @return DescribeHanaRetentionSettingResponse
 */
async function describeHanaRetentionSetting(request: DescribeHanaRetentionSettingRequest): DescribeHanaRetentionSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaRetentionSettingWithOptions(request, runtime);
}

model DescribeOtsTableSnapshotsRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  endTime?: long(name='EndTime', description='The end time of the backup. This value must be a UNIX timestamp. Unit: seconds.', example='1652068250881'),
  limit?: int32(name='Limit', description='The maximum number of rows that you want the current query to return.', example='100'),
  nextToken?: string(name='NextToken', description='The token that is required to obtain the next page of backup snapshots.', example='caeba0bbb2be03f84eb48b699f0a****'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
      tableNames?: [ string ](name='TableNames', description='The names of the tables in the Tablestore instance.'),
    }
  ](name='OtsInstances', description='The list of Tablestore instances that are backed up.'),
  snapshotIds?: [ string ](name='SnapshotIds', description='The list of snapshot IDs.'),
  startTime?: long(name='StartTime', description='The start time of the backup. This value must be a UNIX timestamp. Unit: seconds.', example='1611109271630'),
}

model DescribeOtsTableSnapshotsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  limit?: int32(name='Limit', description='The number of backup snapshots that are displayed on the current page.', example='10'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  nextToken?: string(name='NextToken', description='The token that is required to obtain the next page of backup snapshots.', example='caeba0bbb2be03f84eb48b699f0a'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='09376812-6290-5E36-B504-E8010D72D1F0'),
  snapshots?: [ 
    {
      actualBytes?: string(name='ActualBytes', description='The actual amount of backup snapshots after duplicates are removed. Unit: bytes.', example='0'),
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      bytesTotal?: long(name='BytesTotal', description='The total amount of data. Unit: bytes.', example='0'),
      completeTime?: long(name='CompleteTime', description='The time when the backup snapshot was completed. This value is a UNIX timestamp. Unit: seconds.', example='1642496679'),
      createTime?: long(name='CreateTime', description='The time when the Tablestore instance was created. This value is a UNIX timestamp. Unit: seconds.', example='1607436917'),
      createdTime?: long(name='CreatedTime', description='The time when the backup snapshot was created. This value is a UNIX timestamp. Unit: seconds.', example='1642496679'),
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
      jobId?: string(name='JobId', description='The ID of the backup job.', example='job-00030j3chkt******2'),
      parentSnapshotHash?: string(name='ParentSnapshotHash', description='The hash value of the parent backup snapshot.', example='f2fe..'),
      rangeEnd?: long(name='RangeEnd', description='The time when the backup job ended. This value is a UNIX timestamp. Unit: seconds.', example='1642521709966'),
      rangeStart?: long(name='RangeStart', description='The time when the backup job started. This value is a UNIX timestamp. Unit: seconds.', example='1642492553038'),
      retention?: long(name='Retention', description='The retention period of the backup snapshot.', example='730'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
      snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-00047mxg17p26*****b'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

- **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
- **OSS**: backup snapshots for Object Storage Service (OSS) buckets
- **NAS**: backup snapshots for Apsara File Storage NAS file systems
- **OTS_TABLE**: backup snapshots for Tablestore instances', example='OTS_TABLE'),
      startTime?: long(name='StartTime', description='The start time of the backup snapshot. This value is a UNIX timestamp. Unit: seconds.', example='1642496543'),
      status?: string(name='Status', description='The status of the backup job. Valid values:

- **COMPLETE**: The backup job is completed.
- **PARTIAL_COMPLETE**: The backup job is partially completed.
- **FAILED**: The backup job has failed.', example='COMPLETE'),
      tableName?: string(name='TableName', description='The name of the table in the Tablestore instance.', example='table2'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup snapshot was updated. This value is a UNIX timestamp. Unit: seconds.', example='1642496679'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault that stores the backup snapshot.', example='v-00030j*******sn'),
    }
  ](name='Snapshots', description='The list of backup snapshots.'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DescribeOtsTableSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOtsTableSnapshotsResponseBody(name='body'),
}

async function describeOtsTableSnapshotsWithOptions(request: DescribeOtsTableSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeOtsTableSnapshotsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.otsInstances)) {
    bodyFlat['OtsInstances'] = request.otsInstances;
  }
  if (!Util.isUnset(request.snapshotIds)) {
    bodyFlat['SnapshotIds'] = request.snapshotIds;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOtsTableSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOtsTableSnapshots(request: DescribeOtsTableSnapshotsRequest): DescribeOtsTableSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOtsTableSnapshotsWithOptions(request, runtime);
}

model DescribePoliciesV2Request {
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is used to obtain the next page of backup policies.', example='caeba0bbb2be03f84eb48b699f0a'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************2l6'),
}

model DescribePoliciesV2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  nextToken?: string(name='NextToken', description='The token that is used to obtain the next page of backup policies.', example='caeba0bbb2be03f84eb48b699f0a'),
  policies?: [ 
    {
      createdTime?: long(name='CreatedTime', description='The time when the backup policy was created. This value is a UNIX timestamp. Unit: seconds.', example='1650248136'),
      policyBindingCount?: long(name='PolicyBindingCount', description='The number of data sources that are bound to the backup policy.', example='5'),
      policyDescription?: string(name='PolicyDescription', description='The description of the backup policy.', example='Data is backed up at 10:00:00 every day and replicated to the China (Shanghai) region for geo-redundancy.'),
      policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************bkz'),
      policyName?: string(name='PolicyName', description='The name of the backup policy.', example='Daily Local Backup + Remote Backup'),
      rules?: [ 
        {
          backupType?: string(name='BackupType', description='This parameter is returned only if the value of the **RuleType** parameter is **BACKUP**. This parameter indicates the backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
          replicationRegionId?: string(name='ReplicationRegionId', description='This parameter is returned only if the value of the **RuleType** parameter is **REPLICATION**. This parameter indicates the ID of the destination region.', example='cn-shanghai'),
          retention?: long(name='Retention', description='This parameter is returned only if the value of the **RuleType** parameter is **TRANSITION** or **REPLICATION**.

*   If the value of the **RuleType** parameter is **TRANSITION**, this parameter indicates the retention period of the backup data. Minimum value: 1. Unit: days.
*   If the value of the **RuleType** parameter is **REPLICATION**, this parameter indicates the retention period of remote backups. Minimum value: 1. Unit: days.', example='7'),
          retentionRules?: [ 
            {
              advancedRetentionType?: string(name='AdvancedRetentionType', description='The type of the special retention rule. Valid values:

*   **WEEKLY**: retains weekly backups
*   **MONTHLY**: retains monthly backups
*   **YEARLY**: retains yearly backups', example='YEARLY'),
              retention?: long(name='Retention', description='The retention period of the backup data. Minimum value: 1. Unit: days.', example='730'),
              whichSnapshot?: long(name='WhichSnapshot', description='Indicates which backup is retained based on the special retention rule. Only the first backup can be retained.', example='1'),
            }
          ](name='RetentionRules', description='This parameter is returned only if the value of the **RuleType** parameter is **TRANSITION**. This parameter indicates the special retention rules.'),
          ruleId?: string(name='RuleId', description='The ID of the rule.', example='rule-000************f1e'),
          ruleType?: string(name='RuleType', description='The type of the rule. Each backup policy must have at least one rule of the **BACKUP** type and only one rule of the **TRANSITION** type.

*   **BACKUP**: backup rule
*   **TRANSITION**: lifecycle rule
*   **REPLICATION**: replication rule', example='BACKUP'),
          schedule?: string(name='Schedule', description='This parameter is returned only if the value of the **RuleType** parameter is **BACKUP**. This parameter indicates the backup schedule settings. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` indicates that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval follows the ISO 8601 standard. For example, PT1H indicates an interval of one hour. P1D indicates an interval of one day.', example='I|1648647166|P1D'),
        }
      ](name='Rules', description='The rules in the backup policy.'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup policy was updated. This value is a UNIX timestamp. Unit: seconds.', example='1662080404'),
    }
  ](name='Policies', description='The list of backup policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned entries.', example='12'),
}

model DescribePoliciesV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePoliciesV2ResponseBody(name='body'),
}

async function describePoliciesV2WithOptions(request: DescribePoliciesV2Request, runtime: Util.RuntimeOptions): DescribePoliciesV2Response {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePoliciesV2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePoliciesV2(request: DescribePoliciesV2Request): DescribePoliciesV2Response {
  var runtime = new Util.RuntimeOptions{};
  return describePoliciesV2WithOptions(request, runtime);
}

model DescribePolicyBindingsRequest {
  dataSourceIds?: [ string ](name='DataSourceIds', description='The list of data source IDs.'),
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is used to obtain the next page of results.', example='caeba0bbb2be03f84eb48b699f0a'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************hky'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model DescribePolicyBindingsShrinkRequest {
  dataSourceIdsShrink?: string(name='DataSourceIds', description='The list of data source IDs.'),
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is used to obtain the next page of results.', example='caeba0bbb2be03f84eb48b699f0a'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************hky'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model DescribePolicyBindingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  maxResults?: int32(name='MaxResults', description='The number of results for each query.

Valid values: 10 to 100. Default value: 10.', example='10'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  nextToken?: string(name='NextToken', description='The token that is used to obtain the next page of results.', example='caeba0bbb2be03f84eb48b699f0a'),
  policyBindings?: [ 
    {
      advancedOptions?: {
        udmDetail?: {
          appConsistent?: boolean(name='AppConsistent', description='Indicates whether application consistency is enabled. You can enable application consistency only if all disks are ESSDs.', example='false'),
          diskIdList?: [ string ](name='DiskIdList', description='The IDs of disks that need to be protected. If all disks need to be protected, this parameter is empty.'),
          enableFsFreeze?: boolean(name='EnableFsFreeze', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates whether to enable Linux fsfreeze to put file systems into the read-only state before application-consistent snapshots are created. Default value: true.', example='true'),
          enableWriters?: boolean(name='EnableWriters', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates whether application-consistent snapshots are created.

*   true: Application-consistent snapshots are created.
*   false: File system-consistent snapshots are created.

Default value: true.', example='true'),
          excludeDiskIdList?: [ string ](name='ExcludeDiskIdList', description='The IDs of the disks that do not need to be protected. If the DiskIdList parameter is not empty, this parameter is ignored.'),
          postScriptPath?: string(name='PostScriptPath', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates the path of the post-thaw scripts that are executed after application-consistent snapshots are created.', example='/tmp/postscript.sh'),
          preScriptPath?: string(name='PreScriptPath', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates the path of the pre-freeze scripts that are executed before application-consistent snapshots are created.', example='/tmp/prescript.sh'),
          ramRoleName?: string(name='RamRoleName', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates the name of the RAM role that is required to create application-consistent snapshots.', example='AliyunECSInstanceForHbrRole'),
          snapshotGroup?: boolean(name='SnapshotGroup', description='Indicates whether a snapshot-consistent group is created. You can create a snapshot-consistent group only if all disks are enhanced SSDs (ESSDs).', example='true'),
          timeoutInSeconds?: long(name='TimeoutInSeconds', description='This parameter is returned only if the value of the **AppConsistent** parameter is **true**. This parameter indicates the I/O freeze timeout period. Default value: 30. Unit: seconds.', example='30'),
        }(name='UdmDetail', description='The details of ECS instance backup.'),
      }(name='AdvancedOptions', description='Advanced options.'),
      createdTime?: long(name='CreatedTime', description='The time when the backup policy was created. This value is a UNIX timestamp. Unit: seconds.', example='1661399570'),
      crossAccountRoleName?: string(name='CrossAccountRoleName'),
      crossAccountType?: string(name='CrossAccountType'),
      crossAccountUserId?: long(name='CrossAccountUserId'),
      dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='i-8vb************5ly'),
      disabled?: boolean(name='Disabled', description='Indicates whether the backup policy is enabled for the data source.

*   true: The backup policy is disabled.
*   false: The backup policy is enabled.', example='true'),
      policyBindingDescription?: string(name='PolicyBindingDescription', description='The description of the association.', example='po-000************eslc-i-uf6************y5g'),
      policyBindingId?: string(name='PolicyBindingId', description='The ID of the association.', example='pd-000************slc'),
      policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************56y'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup policy was updated. This value is a UNIX timestamp. Unit: seconds.', example='1653611573'),
    }
  ](name='PolicyBindings', description='The list of backup policies.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='5225929A-4EBD-55EE-9FE1-4A130E582A76'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of returned entries.', example='38'),
}

model DescribePolicyBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyBindingsResponseBody(name='body'),
}

async function describePolicyBindingsWithOptions(tmpReq: DescribePolicyBindingsRequest, runtime: Util.RuntimeOptions): DescribePolicyBindingsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribePolicyBindingsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceIds)) {
    request.dataSourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceIds, 'DataSourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceIdsShrink)) {
    body['DataSourceIds'] = request.dataSourceIdsShrink;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyBindings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePolicyBindings(request: DescribePolicyBindingsRequest): DescribePolicyBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePolicyBindingsWithOptions(request, runtime);
}

model DescribeRecoverableOtsInstancesRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
}

model DescribeRecoverableOtsInstancesResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance that can be restored.', example='instancename'),
      tableNames?: [ string ](name='TableNames', description='The names of the tables in the Tablestore instance.'),
    }
  ](name='OtsInstances', description='The list of Tablestore instances that can be restored and the tables in the instances.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='14DC089E-5DD3-5028-AEDB-93D78E11DB2A'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DescribeRecoverableOtsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecoverableOtsInstancesResponseBody(name='body'),
}

async function describeRecoverableOtsInstancesWithOptions(request: DescribeRecoverableOtsInstancesRequest, runtime: Util.RuntimeOptions): DescribeRecoverableOtsInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRecoverableOtsInstances',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecoverableOtsInstances(request: DescribeRecoverableOtsInstancesRequest): DescribeRecoverableOtsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecoverableOtsInstancesWithOptions(request, runtime);
}

model DescribeRegionsRequest {
  needVaultCount?: boolean(name='NeedVaultCount', description='Specifies whether to return detailed information. Default value: false.', example='false'),
}

model DescribeRegionsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName', description='The name of the region.', example='China (Hangzhou)'),
      regionId?: string(name='RegionId', description='The ID of the region.', example='cn-hangzhou'),
      vaultCount?: int32(name='VaultCount', description='The number of repositories in the region.', example='11'),
    }
  ](name='Region')
  }(name='Regions', description='The list of regions.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B3395EC6-7A4A-5282-A9AB-7A442F2CFC90'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.needVaultCount)) {
    query['NeedVaultCount'] = request.needVaultCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRestoreJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key', description='The keys in the filter. Valid values:

*   **RegionId**: the ID of a region
*   **PlanId**: the ID of a backup plan
*   **JobId**: the ID of a backup job
*   **VaultId**: the ID of a backup vault
*   **InstanceId**: the ID of an ECS instance
*   **Bucket**: the name of an OSS bucket
*   **FileSystemId**: the ID of a file system
*   **Status**: the status of a backup job
*   **CompleteTime**: the end time of a backup job', example='VaultId'),
      operator?: string(name='Operator', description='The matching method. Default value: IN. This parameter specifies the operator that you want to use to match a key and a value in the filter. Valid values:

*   **EQUAL**: equal to
*   **NOT_EQUAL**: not equal to
*   **GREATER_THAN**: greater than
*   **GREATER_THAN_OR_EQUAL**: greater than or equal to
*   **LESS_THAN**: less than
*   **LESS_THAN_OR_EQUAL**: less than or equal to
*   **BETWEEN**: specifies a JSON array as a range. The results must fall within the range in the `[Minimum value,maximum value]` format.
*   **IN**: specifies an array as a collection. The results must fall within the collection.

**

**Note** If you specify **CompleteTime** as a key to query backup jobs, you cannot use the IN operator to perform a match.', example='IN'),
      values?: [ string ](name='Values', description='The value of the query filter.'),
    }
  ](name='Filters', description='The key-value of the query filter.'),
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  restoreType?: string(name='RestoreType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems
*   **OTS_TABLE**: Tablestore instances
*   **UDM_ECS_ROLLBACK**: ECS instances', example='ECS_FILE'),
}

model DescribeRestoreJobs2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='1'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  restoreJobs?: {
    restoreJob?: [ 
    {
      actualBytes?: long(name='ActualBytes', description='The actual amount of data that is restored after duplicates are removed. Unit: bytes.', example='600'),
      actualItems?: long(name='ActualItems', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the actual number of objects that are restored by the restore job.', example='6'),
      bytesDone?: long(name='BytesDone', description='The amount of data that was restored. Unit: bytes.', example='800'),
      bytesTotal?: long(name='BytesTotal', description='The total amount of data that is restored from the data source. Unit: bytes.', example='1000'),
      clusterId?: string(name='ClusterId', description='The ID of the client group used for restoration.', example='cl-000******hp6'),
      completeTime?: long(name='CompleteTime', description='The time when the restore job was completed. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      createdTime?: long(name='CreatedTime', description='The time when the restore job was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      crossAccountRoleName?: string(name='CrossAccountRoleName', description='The role name created in the original account RAM of cross account backup managed by the current account.', example='BackupRole'),
      crossAccountType?: string(name='CrossAccountType', description='The type of cross account backup.
- SELF_ACCOUNT:  Local account backup. 
- CROSS_ACCOUNT: Cross account backup.', example='SELF_ACCOUNT'),
      crossAccountUserId?: long(name='CrossAccountUserId', description='The original account ID of cross account backup managed by the current account.', example='158975xxxxxx4625'),
      errorFile?: string(name='ErrorFile', description='The list of files that failed to be restored.', example='"test.csv"'),
      errorMessage?: string(name='ErrorMessage', description='The error message that is returned for the restore job.', example='PARTIAL_COMPLETE'),
      exclude?: string(name='Exclude', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the paths to the files that are excluded from the restore job. The value can be 1 to 255 characters in length.', example='["/var", "/proc"]'),
      expireTime?: long(name='ExpireTime', description='The time when the restore job expires.', example='1634714531'),
      include?: string(name='Include', description='The paths to the files that are included in the restore job.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
      itemsDone?: long(name='ItemsDone', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the number of restored objects.', example='8'),
      itemsTotal?: long(name='ItemsTotal', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the total number of objects in the data source.', example='10'),
      options?: string(name='Options', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates whether Windows VSS is used to define a restoration path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot restore data from multiple directories.', example='{"UseVSS":false}'),
      otsDetail?: {
        batchChannelCount?: int32(name='BatchChannelCount', description='The number of channels processed by each Tablestore restore job.', example='2'),
        overwriteExisting?: boolean(name='OverwriteExisting', description='Indicates whether the existing Tablestore restore job was overwritten.', example='false'),
      }(name='OtsDetail', description='The details about the Tablestore instance.'),
      parentId?: string(name='ParentId', description='The ID of the parent job.', example='r-0003hd2an3x4dyv0l18b'),
      progress?: int32(name='Progress', description='The progress of the restore job. For example, 10000 indicates that the progress is 100%.', example='10000'),
      report?: {
        failedFiles?: string(name='FailedFiles'),
        reportTaskStatus?: string(name='ReportTaskStatus'),
        skippedFiles?: string(name='SkippedFiles'),
        successFiles?: string(name='SuccessFiles'),
        totalFiles?: string(name='TotalFiles'),
      }(name='Report'),
      restoreId?: string(name='RestoreId', description='The ID of the restore job.', example='r-0003*****8a'),
      restoreType?: string(name='RestoreType', description='The type of the restore job.', example='ECS_FILE'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
      snapshotId?: string(name='SnapshotId', description='The ID of the snapshot used for restoration.', example='s-0002******ga88'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS files
*   **OSS**: OSS buckets
*   **NAS**: NAS file systems
*   **OTS_TABLE**: Tablestore instances
*   **UDM_ECS**: ECS instances', example='ECS_FILE'),
      speed?: long(name='Speed', description='The average speed at which data was restored. Unit: KB/s.', example='500'),
      startTime?: long(name='StartTime', description='The start time of the restore job. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      status?: string(name='Status', description='The status of the restore job. Valid values:

*   **COMPLETE**: The restore job is completed.
*   **PARTIAL_COMPLETE**: The restore job is partially completed.
*   **FAILED**: The restore job has failed.', example='COMPLETE'),
      targetBucket?: string(name='TargetBucket', description='The name of the destination OSS bucket. This parameter is returned only for OSS buckets.', example='target-bucket'),
      targetClientId?: string(name='TargetClientId', description='The ID of the destination client.', example='c-000e*****397'),
      targetCreateTime?: long(name='TargetCreateTime', description='This parameter is returned only for NAS file systems. This parameter indicates the time when the file system was created.', example='1634714531'),
      targetDataSourceId?: string(name='TargetDataSourceId', description='The ID of the destination data source.', example='ds-000*****997'),
      targetFileSystemId?: string(name='TargetFileSystemId', description='The ID of the destination NAS file system. This parameter is returned only for NAS file systems.', example='0be9****9c9'),
      targetInstanceId?: string(name='TargetInstanceId', description='The ID of the destination instance for the restore job.', example='i-2ze3m7ktcgw******cs'),
      targetInstanceName?: string(name='TargetInstanceName', description='The name of the destination Tablestore instance.', example='instancename'),
      targetPath?: string(name='TargetPath', description='The destination file path of the restore job.', example='"D:\\\\rebk"'),
      targetPrefix?: string(name='TargetPrefix', description='The prefix of objects that are restored. This parameter is returned only for OSS buckets.', example='"/target"'),
      targetTableName?: string(name='TargetTableName', description='The name of the table that stores the restored data.', example='tablename'),
      targetTime?: long(name='TargetTime', description='The time when data was restored to the Tablestore instance. This value is a UNIX timestamp. Unit: seconds.', example='1642560261'),
      udmDetail?: string(name='UdmDetail', description='The details about server backup.', example='{\\"doCopy\\":true,\\"doBackup\\":false,\\"instanceName\\":\\"instance example\\",\\"appConsistent\\":false,\\"destinationRegionId\\":\\"cn-shanghai\\",\\"enableFsFreeze\\":true,\\"osNameEn\\":\\"Windows Server  2019 Data Center Edition 64bit Chinese Edition\\",\\"osName\\":\\"Windows Server  2019 Data Center Edition 64bit Chinese Edition\\",\\"diskIdList\\":[],\\"backupVaultId\\":\\"\\",\\"snapshotGroup\\":true,\\"destinationRetention\\":35,\\"platform\\":\\"Windows Server 2012\\",\\"timeoutInSeconds\\":60,\\"backupRetention\\":1,\\"osType\\":\\"windows\\",\\"preScriptPath\\":\\"\\",\\"postScriptPath\\":\\"\\",\\"enableWriters\\":true,\\"ecsDeleted\\":false}'),
      updatedTime?: long(name='UpdatedTime', description='The time when the restore job was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
    }
  ](name='RestoreJob')
  }(name='RestoreJobs', description='The details about the restore job.', example='{\\"RestoreJob\\": []}'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of returned entries.', example='1'),
}

model DescribeRestoreJobs2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreJobs2ResponseBody(name='body'),
}

async function describeRestoreJobs2WithOptions(request: DescribeRestoreJobs2Request, runtime: Util.RuntimeOptions): DescribeRestoreJobs2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreJobs2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreJobs2(request: DescribeRestoreJobs2Request): DescribeRestoreJobs2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreJobs2WithOptions(request, runtime);
}

model DescribeTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmvywqfey5njq'),
  taskId?: string(name='TaskId', description='The ID of the job.', example='t-*********************'),
  token?: string(name='Token', description='The access token.', example='01W3ZZOQ'),
}

model DescribeTaskResponseBody = {
  code?: string(name='Code', description='HttpCode', example='200'),
  completedTime?: long(name='CompletedTime', description='The time when the job was completed. This value is a UNIX timestamp. Unit: seconds.', example='1615607706'),
  createdTime?: long(name='CreatedTime', description='The time when the job was created. This value is a UNIX timestamp. Unit: seconds.', example='1615607706'),
  description?: string(name='Description', description='The status of the job. Valid values:

*   **created**: The job is created.
*   **expired**: The job expires.
*   **completed**: The job is completed.
*   **cancelled**: The job is canceled.', example='completed'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  name?: string(name='Name', description='The name of the job.', example='InstallBackupClientsTask'),
  progress?: int32(name='Progress', description='The progress of the job. Valid values: 0 to 100. Unit: percentage (%). If the job fails, the value -1 is returned.', example='100'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  result?: string(name='Result', description='The result of the job.', example='{}'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  updatedTime?: long(name='UpdatedTime', description='The time when the job was updated. This value is a UNIX timestamp. Unit: seconds.', example='1615607706'),
}

model DescribeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTaskResponseBody(name='body'),
}

async function describeTaskWithOptions(request: DescribeTaskRequest, runtime: Util.RuntimeOptions): DescribeTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTask',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTask(request: DescribeTaskRequest): DescribeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTaskWithOptions(request, runtime);
}

model DescribeUdmSnapshotsRequest {
  diskId?: string(name='DiskId', description='The ID of the disk.', example='d-bp1560750pclffpzxy70'),
  endTime?: long(name='EndTime', description='The end of the time range to query. This value must be a UNIX timestamp. Unit: seconds.', example='1643092168'),
  instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-bp18x2k7sw925ir7ofh8'),
  jobId?: string(name='JobId', description='The ID of the backup job.', example='job-*********************'),
  snapshotIds?: map[string]any(name='SnapshotIds', description='The list of backup snapshots.', example='[\\"s-000e3vhhu62xsm6v92r0\\"]'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS file
*   **OSS**: Object Storage Service (OSS) bucket
*   **NAS**: Apsara File Storage NAS file system
*   **UDM_DISK**: ECS instance', example='UDM_ECS'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value must be a UNIX timestamp. Unit: seconds.', example='1642057551'),
  udmRegionId?: string(name='UdmRegionId', description='The ID of the region where the ECS instance resides.', example='cn-hangzhou'),
}

model DescribeUdmSnapshotsShrinkRequest {
  diskId?: string(name='DiskId', description='The ID of the disk.', example='d-bp1560750pclffpzxy70'),
  endTime?: long(name='EndTime', description='The end of the time range to query. This value must be a UNIX timestamp. Unit: seconds.', example='1643092168'),
  instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-bp18x2k7sw925ir7ofh8'),
  jobId?: string(name='JobId', description='The ID of the backup job.', example='job-*********************'),
  snapshotIdsShrink?: string(name='SnapshotIds', description='The list of backup snapshots.', example='[\\"s-000e3vhhu62xsm6v92r0\\"]'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: ECS file
*   **OSS**: Object Storage Service (OSS) bucket
*   **NAS**: Apsara File Storage NAS file system
*   **UDM_DISK**: ECS instance', example='UDM_ECS'),
  startTime?: long(name='StartTime', description='The beginning of the time range to query. This value must be a UNIX timestamp. Unit: seconds.', example='1642057551'),
  udmRegionId?: string(name='UdmRegionId', description='The ID of the region where the ECS instance resides.', example='cn-hangzhou'),
}

model DescribeUdmSnapshotsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='51CDEECB-7001-51CC-94AC-2A0F2A4B71D2'),
  snapshots?: [ 
    {
      actualBytes?: string(name='ActualBytes', description='The size of the backup snapshot. Unit: bytes.', example='600'),
      advancedRetentionType?: string(name='AdvancedRetentionType'),
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      bytesTotal?: long(name='BytesTotal', description='The total amount of data. Unit: bytes.', example='1000'),
      completeTime?: long(name='CompleteTime', description='The time when the backup snapshot was completed. This value is a UNIX timestamp. Unit: seconds.', example='1646895666'),
      createTime?: long(name='CreateTime', description='The time when the backup snapshot was created.', example='1607436917'),
      createdTime?: long(name='CreatedTime', description='The time when the backup snapshot was created. This value is a UNIX timestamp. Unit: seconds.', example='1642496679'),
      detail?: {
        consistentLevel?: string(name='ConsistentLevel', description='The consistency level.', example='CRASH'),
        containOsDisk?: boolean(name='ContainOsDisk', description='Indicates whether the system disk is included.', example='true'),
        diskCategory?: string(name='DiskCategory'),
        diskDevName?: string(name='DiskDevName', description='The name of the disk.', example='/dev/xvdb'),
        diskHbrSnapshotIdWithDeviceMap?: map[string]any(name='DiskHbrSnapshotIdWithDeviceMap', description='The mapping between the device and the recovery point ID.', example='{
    "/dev/xvdb":"s-0000u7y6wm3v1e7hxh5a",					 
    "/dev/xvda":"s-0004bl6yr5pt89jjsv5a"
}'),
        diskIdList?: [ string ](name='DiskIdList', description='The ID of the disk that is backed up at the recovery point.'),
        downgradeReason?: string(name='DowngradeReason', description='The reason for the downgrade.', example='HBR.NoRamRoleBound'),
        hostName?: string(name='HostName'),
        instanceIdWithDiskIdListMap?: map[string]any(name='InstanceIdWithDiskIdListMap', description='The mapping between the instance ID and the disk ID.', example='{
    "i-bp1dlp0keohh7ids4uo6":"d-bp1e6427vhd320hifvs",					 
    "i-bp1dlp0keohh7ids4uo6":"d-bp1e6427vhd320hifvd"
}'),
        instanceName?: string(name='InstanceName', description='The name of the instance.', example='swh-hbr'),
        instanceType?: string(name='InstanceType'),
        instantAccess?: boolean(name='InstantAccess'),
        nativeSnapshotIdList?: [ string ](name='NativeSnapshotIdList', description='The ID of the snapshot.'),
        osDiskId?: string(name='OsDiskId', description='The ID of the system disk.', example='d-bp1e6427vhd320hifvc'),
        osName?: string(name='OsName', description='The name of the operating system.', example='Debian 10.10 64-bit (UEFI)'),
        osNameEn?: string(name='OsNameEn', description='The English name of the operating system.', example='Debian  11.1 64 bit'),
        osType?: string(name='OsType', description='The type of the operating system. Valid values: linux and windows.', example='windows'),
        performanceLevel?: string(name='PerformanceLevel'),
        platform?: string(name='Platform', description='The system platform.', example='CentOS'),
        snapshotGroupId?: string(name='SnapshotGroupId', description='The ID of the snapshot group.', example='ssg-uf6856txcaq31uj***'),
        systemDisk?: boolean(name='SystemDisk', description='Indicates whether the disk is a system disk.', example='true'),
        vmName?: string(name='VmName', description='The name of the instance.', example='BNSHSVR42 IPGUARD'),
      }(name='Detail', description='The snapshot details.'),
      diskId?: string(name='DiskId', description='The ID of the cloud disk or local disk.', example='d-2ze86h5fga5r******a8ef'),
      expireTime?: long(name='ExpireTime'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-bp1f0pe78dxi******gxd'),
      jobId?: string(name='JobId', description='The ID of the backup job.', example='job-00030j3chkt******2'),
      nativeSnapshotId?: string(name='NativeSnapshotId', description='The ID of the snapshot.', example='s-00047mg17p26x*****b'),
      nativeSnapshotInfo?: string(name='NativeSnapshotInfo', description='The snapshot information.', example='{
					"sourceDiskId":"d-bp17misjuy636t82v7b0",
					"lastModifiedTime":"2022-03-09T11:35:12Z",
					"snapshotSN":"64588-429372675-857161235",
					"snapshotId":"s-bp1fbtwv3e6xr6wpe9e0",
					"creationTime":"2022-03-09T11:31:12Z",
					"snapshotType":"user",
					"usage":"none",
					"description":"",
					"sourceStorageType":"disk",
					"tags":[
						{
							"tagValue":"job-0007e0wqjl0imbrtkmnm",
							"tagKey":"HBR JobId"
						}
					],
					"productCode":"",
					"encrypted":false,
					"sourceDiskType":"system",
					"retentionDays":30,
					"snapshotName":"Created-from-HBR-job:job-0007e0wqjl0imbrtkmnm",
					"kMSKeyId":"",
					"progress":"100%",
					"category":"standard",
					"sourceDiskSize":"20",
					"status":"accomplished"
				}'),
      parentSnapshotHash?: string(name='ParentSnapshotHash', description='The hash value of the parent backup snapshot.', example='f2fe..'),
      prefix?: string(name='Prefix', description='The prefix of the backup snapshot.', example='example/'),
      realSnapshotTime?: long(name='RealSnapshotTime', description='The timestamp of the backup snapshot. Unit: milliseconds.', example='1642496679'),
      retention?: long(name='Retention', description='The retention period of the backup snapshot. Unit: days.', example='7'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
      snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-00047mxg17p26*****b'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

- **ECS_FILE**: ECS file
- **OSS**: OSS bucket
- **NAS**: NAS file system
- **OTS_TABLE**: Tablestore instance
- **UDM_DISK**: ECS instance', example='UDM_ECS'),
      startTime?: long(name='StartTime', description='The start time of the backup snapshot. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      status?: string(name='Status', description='The status of the backup job. Valid values:

- **COMPLETE**: The backup job is completed.
- **PARTIAL_COMPLETE**: The backup job is partially completed.
- **FAILED**: The backup job has failed.', example='COMPLETE'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup snapshot was updated. This value is a UNIX timestamp. Unit: seconds.', example='1642496679'),
    }
  ](name='Snapshots', description='The details about backup snapshots.'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: long(name='TotalCount', description='The total number of backup snapshots.', example='3'),
}

model DescribeUdmSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUdmSnapshotsResponseBody(name='body'),
}

async function describeUdmSnapshotsWithOptions(tmpReq: DescribeUdmSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeUdmSnapshotsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeUdmSnapshotsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.snapshotIds)) {
    request.snapshotIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.snapshotIds, 'SnapshotIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.snapshotIdsShrink)) {
    body['SnapshotIds'] = request.snapshotIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUdmSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUdmSnapshots(request: DescribeUdmSnapshotsRequest): DescribeUdmSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUdmSnapshotsWithOptions(request, runtime);
}

model DescribeVaultReplicationRegionsRequest {
  token?: string(name='Token', description='The access token.', example='01W3ZZOQ'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-00030j3c******sn'),
}

model DescribeVaultReplicationRegionsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  regions?: {
    regionId?: [ string ](name='RegionId')
  }(name='Regions', description='The regions that support cross-region replication.'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F4EEB401-DD21-588D-AE3B-1E835C7655E1'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DescribeVaultReplicationRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVaultReplicationRegionsResponseBody(name='body'),
}

async function describeVaultReplicationRegionsWithOptions(request: DescribeVaultReplicationRegionsRequest, runtime: Util.RuntimeOptions): DescribeVaultReplicationRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVaultReplicationRegions',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVaultReplicationRegions(request: DescribeVaultReplicationRegionsRequest): DescribeVaultReplicationRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVaultReplicationRegionsWithOptions(request, runtime);
}

model DescribeVaultsRequest {
  pageNumber?: int32(name='PageNumber', description='The number of the page to return. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries to return on each page. Valid values: 1 to 99. Default value: 10.', example='10'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-*********************'),
  status?: string(name='Status', description='The status of the backup vault. Vaild values:

*   **UNKNOWN**: The backup vault is in an unknown state.
*   **INITIALIZING**: The backup vault is being initialized.
*   **CREATED**: The backup vault is created.
*   **ERROR**: An error occurs on the backup vault.', example='CREATED'),
  tag?: [ 
    {
      key?: string(name='Key', description='The key of the tag.', example='key1'),
      value?: string(name='Value', description='The value of the tag.', example='value1'),
    }
  ](name='Tag', description='Tags.', example='6a745bceffb042959b3b5206d6f12ad1'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
  vaultRegionId?: string(name='VaultRegionId', description='The ID of the region where the backup vault resides.', example='cn-shanghai'),
  vaultType?: string(name='VaultType', description='The type of the backup vault. Valid value: **STANDARD**, which indicates a standard backup vault.', example='STANDARD'),
}

model DescribeVaultsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  pageNumber?: int32(name='PageNumber', description='The page number of the returned page. Pages start from page 1. Default value: 1.', example='1'),
  pageSize?: int32(name='PageSize', description='The number of entries returned per page. Valid values: 1 to 99. Default value: 10.', example='10'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of backup vaults that are returned.', example='8'),
  vaults?: {
    vault?: [ 
    {
      backupPlanStatistics?: {
        commonNas?: int32(name='CommonNas', description='The number of backup plans for General-purpose NAS file systems.', example='1'),
        csg?: int32(name='Csg', description='The number of backup plans for Cloud Storage Gateway (CSG).', example='1'),
        ecsFile?: int32(name='EcsFile', description='The number of backup plans for Elastic Compute Service (ECS) files.', example='1'),
        ecsHana?: int32(name='EcsHana', description='The number of backup plans for SAP HANA instances.', example='1'),
        isilon?: int32(name='Isilon', description='The number of backup plans for Isilon storage systems.', example='1'),
        localFile?: int32(name='LocalFile', description='The number of backup plans for on-premises servers.', example='1'),
        localVm?: int32(name='LocalVm', description='The number of backup plans for on-premises virtual machines (VMs).', example='1'),
        mySql?: int32(name='MySql', description='The number of backup plans for MySQL databases.', example='1'),
        nas?: int32(name='Nas', description='The number of backup plans for NAS file systems.', example='1'),
        oracle?: int32(name='Oracle', description='The number of backup plans for Oracle databases.', example='1'),
        oss?: int32(name='Oss', description='The number of backup plans for OSS buckets.', example='1'),
        ots?: int32(name='Ots', description='The number of backup plans for Tablestore instances.', example='1'),
        sqlServer?: int32(name='SqlServer', description='The number of backup plans for SQL Server databases.', example='1'),
      }(name='BackupPlanStatistics', description='The statistics of backup plans that use the backup vault.'),
      bucketName?: string(name='BucketName', description='The name of the OSS bucket used by the backup vault.', example='hbr-0005i51******t58'),
      bytesDone?: long(name='BytesDone', description='The amount of data that is backed up. Unit: bytes.', example='20'),
      chargeType?: string(name='ChargeType', description='The billing method of the backup vault.', example='FREE'),
      chargedStorageSize?: long(name='ChargedStorageSize'),
      compressionAlgorithm?: string(name='CompressionAlgorithm', description='The encryption algorithm used to compress the backup vault. Valid values:

- DISABLED: The backup vault is not compressed.
- SNAPPY: The backup vault is compressed by using the SNAPPY encryption algorithm.
- ZSTD: The backup vault is compressed by using Zstandard, a fast compression algorithm that provides high compression ratios.', example='ZSTD'),
      createdTime?: long(name='CreatedTime', description='The time when the backup vault was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      dedup?: boolean(name='Dedup', description='Indicates whether the deduplication feature is enabled.', example='true'),
      description?: string(name='Description', description='The description of the backup vault.', example='vault description'),
      encryptType?: string(name='EncryptType', description='The encryption type of the backup vault.

- NONE: The backup vault is not encrypted.
- HBR_PRIVATE: The backup vault is encrypted by using HBR-provided keys. This is the default value.
- KMS: The backup vault is encrypted by using custom KMS keys.', example='HBR_PRIVATE'),
      indexAvailable?: boolean(name='IndexAvailable', description='Indicates whether indexes are available. Indexes are available when they are not being updated.', example='true'),
      indexLevel?: string(name='IndexLevel', description='The index level.

*   OFF: No indexes are created.
*   META: Metadata indexes are created.
*   ALL: Full-text indexes are created.', example='OFF'),
      indexUpdateTime?: long(name='IndexUpdateTime', description='The time when the index was updated.', example='1639645628'),
      kmsKeyId?: string(name='KmsKeyId', description='The key id or alias name of Alibaba Cloud Kms. It is required and valid only when encrypt_type is KMS.', example='578ac195-ac5d-4f6d-af62-f1c8d13bdc48'),
      latestReplicationTime?: long(name='LatestReplicationTime', description='The time when the last remote backup is synchronized. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      redundancyType?: string(name='RedundancyType', description='The data redundancy type of the backup vault. Valid values:

- LRS: Locally redundant storage (LRS) is enabled for the backup vault. HBR stores the copies of each object on multiple devices of different facilities in the same zone. This way, HBR ensures data durability and availability even if hardware failures occur.
- ZRS: Zone-redundant storage (ZRS) is enabled for the backup vault. HBR uses the multi-zone mechanism to distribute data across three zones within the same region. If a zone becomes unavailable, the data can still be accessed.', example='LRS'),
      replication?: boolean(name='Replication', description='Indicates whether the backup vault is a remote backup vault.

*   true: The backup vault is a remote backup vault.
*   false: The backup vault is an on-premises backup vault.', example='false'),
      replicationProgress?: {
        historicalReplicationProgress?: int32(name='HistoricalReplicationProgress', description='The progress of historical data synchronization from the backup vault to the mirror vault. Valid values: 0 to 100.', example='100'),
        newReplicationProgress?: long(name='NewReplicationProgress', description='The latest synchronization time of incremental data in the mirror vault.', example='1579413159'),
      }(name='ReplicationProgress', description='The progress of data synchronization from the backup vault to the mirror vault.'),
      replicationSourceRegionId?: string(name='ReplicationSourceRegionId', description='The ID of the region where the remote backup vault resides.', example='v-*********************'),
      replicationSourceVaultId?: string(name='ReplicationSourceVaultId', description='The ID of the source vault that corresponds to the remote backup vault.', example='v-*********************'),
      resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-*********************'),
      retention?: long(name='Retention', description='The retention period of the backup vault.', example='2'),
      searchEnabled?: boolean(name='SearchEnabled', description='Indicates whether the backup search feature is enabled.', example='true'),
      snapshotCount?: long(name='SnapshotCount', description='The number of snapshots in the backup vault.', example='0'),
      sourceTypes?: {
        sourceType?: [ string ](name='SourceType')
      }(name='SourceTypes', description='The information about the data source.'),
      status?: string(name='Status', description='The status of the backup vault. Vaild values:

*   **UNKNOWN**: The backup vault is in an unknown state.
*   **INITIALIZING**: The backup vault is being initialized.
*   **CREATED**: The backup vault is created.
*   **ERROR**: An error occurs on the backup vault.', example='CREATED'),
      storageSize?: long(name='StorageSize', description='The usage of the backup vault. Unit: bytes.', example='10'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key', description='The tag key of the backup vault. Valid values of N: 1 to 20.

*   The tag key cannot start with `aliyun` or `acs:`.
*   The tag key cannot contain `http://` or `https://`.
*   The tag key cannot be an empty string.', example='aaa'),
          value?: string(name='Value', description='The tag value of the backup vault. Valid values of N: 1 to 20.

*   The tag value cannot start with `aliyun` or `acs:`.
*   The tag value cannot contain `http://` or `https://`
*   The tag value cannot be an empty string.', example='a1'),
        }
      ](name='Tag')
      }(name='Tags', description='The tags of the backup vault.'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration', description='Indicates whether you are billed based on the pay-as-you-go method after the free trial ends.', example='true'),
        trialExpireTime?: long(name='TrialExpireTime', description='The expiration time of the free trial.', example='1584597600'),
        trialStartTime?: long(name='TrialStartTime', description='The start time of the free trial.', example='1579413159'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime', description='The time when the free-trial backup vault is released.', example='1594965600'),
      }(name='TrialInfo', description='The free trial information.'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup vault was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
      vaultName?: string(name='VaultName', description='The name of the backup vault.', example='vaultname'),
      vaultRegionId?: string(name='VaultRegionId', description='The ID of the region where the backup vault resides.', example='cn-shanghai'),
      vaultStatusMessage?: string(name='VaultStatusMessage', description='The status message that is returned when the backup vault is in the ERROR state. This parameter is available only for remote backup vaults. Valid values:

*   **UNKNOWN_ERROR**: An unknown error occurs.
*   **SOURCE_VAULT_ALREADY_HAS_REPLICATION **: A mirror vault is configured for the source vault.', example='SOURCE_VAULT_ALREADY_HAS_REPLICATION'),
      vaultStorageClass?: string(name='VaultStorageClass', description='The storage type of the backup vault. Valid value: **STANDARD**, which indicates standard storage.', example='STANDARD'),
      vaultType?: string(name='VaultType', description='The type of the backup vault. Valid value: **STANDARD**, which indicates a standard backup vault.', example='STANDARD'),
      wormEnabled?: boolean(name='WormEnabled', description='Indicates whether the backup locking feature is enabled.', example='true'),
    }
  ](name='Vault')
  }(name='Vaults', description='The backup vaults.', example='{\\"Vault\\": []}'),
}

model DescribeVaultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVaultsResponseBody(name='body'),
}

async function describeVaultsWithOptions(request: DescribeVaultsRequest, runtime: Util.RuntimeOptions): DescribeVaultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultType)) {
    query['VaultType'] = request.vaultType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVaults',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVaults(request: DescribeVaultsRequest): DescribeVaultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVaultsWithOptions(request, runtime);
}

model DetachNasFileSystemRequest {
  createTime?: string(name='CreateTime', description='The time when the file system was created. The time must be in the UNIX format. Unit: seconds.', example='1607436917'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  fileSystemId?: string(name='FileSystemId', description='The ID of the file system.', example='005494'),
}

model DetachNasFileSystemResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of Asynchronous task. You can obtain task results by calling DescribeTask.', example='t-*********************'),
}

model DetachNasFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachNasFileSystemResponseBody(name='body'),
}

/**
  * *   If the request is successful, the specified mount target is deleted.
  * *   After you create a backup plan for an Apsara File Storage NAS file system, HBR automatically creates a mount target for the file system. To delete the mount target, you must call this operation. If you move the point over the mount target in the **Status** column on the Mount Targets tab, a message appears. The message includes the following content: **The mount target is created by an Alibaba Cloud service. You cannot perform an operation on the mount target. Service name: HBR**.
  *
  * @param request DetachNasFileSystemRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DetachNasFileSystemResponse
 */
async function detachNasFileSystemWithOptions(request: DetachNasFileSystemRequest, runtime: Util.RuntimeOptions): DetachNasFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachNasFileSystem',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If the request is successful, the specified mount target is deleted.
  * *   After you create a backup plan for an Apsara File Storage NAS file system, HBR automatically creates a mount target for the file system. To delete the mount target, you must call this operation. If you move the point over the mount target in the **Status** column on the Mount Targets tab, a message appears. The message includes the following content: **The mount target is created by an Alibaba Cloud service. You cannot perform an operation on the mount target. Service name: HBR**.
  *
  * @param request DetachNasFileSystemRequest
  * @return DetachNasFileSystemResponse
 */
async function detachNasFileSystem(request: DetachNasFileSystemRequest): DetachNasFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachNasFileSystemWithOptions(request, runtime);
}

model DisableBackupPlanRequest {
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: The system backs up data from Elastic Compute Service (ECS) instances.
*   **OSS**: The system backs up data from Object Storage Service (OSS) buckets.
*   **NAS**: The system backs up data from Apsara File Storage NAS file systems.', example='ECS_FILE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model DisableBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model DisableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableBackupPlanResponseBody(name='body'),
}

/**
  * If the request is successful, the specified backup plan is disabled. If you call the DescribeBackupPlans operation to query backup plans, the Disabled parameter is set to true for the backup plan.
  *
  * @param request DisableBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableBackupPlanResponse
 */
async function disableBackupPlanWithOptions(request: DisableBackupPlanRequest, runtime: Util.RuntimeOptions): DisableBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the request is successful, the specified backup plan is disabled. If you call the DescribeBackupPlans operation to query backup plans, the Disabled parameter is set to true for the backup plan.
  *
  * @param request DisableBackupPlanRequest
  * @return DisableBackupPlanResponse
 */
async function disableBackupPlan(request: DisableBackupPlanRequest): DisableBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableBackupPlanWithOptions(request, runtime);
}

model DisableHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0003tu******y5oc'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='pl-0006o11ectqr650ceoct'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm3erpwweavki'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000f9z******vilrr'),
}

model DisableHanaBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='FFC87EC8-8126-5967-9C4D-82715F8DFC97'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model DisableHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableHanaBackupPlanResponseBody(name='body'),
}

/**
  * To enable the backup plan again, call the EnableHanaBackupPlan operation.
  *
  * @param request DisableHanaBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return DisableHanaBackupPlanResponse
 */
async function disableHanaBackupPlanWithOptions(request: DisableHanaBackupPlanRequest, runtime: Util.RuntimeOptions): DisableHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To enable the backup plan again, call the EnableHanaBackupPlan operation.
  *
  * @param request DisableHanaBackupPlanRequest
  * @return DisableHanaBackupPlanResponse
 */
async function disableHanaBackupPlan(request: DisableHanaBackupPlanRequest): DisableHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHanaBackupPlanWithOptions(request, runtime);
}

model EnableBackupPlanRequest {
  planId?: string(name='PlanId', description='The ID of the backup schedule.', example='plan-*********************'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: The system backs up data from Elastic Compute Service (ECS) instances.
*   **OSS**: The system backs up data from Object Storage Service (OSS) buckets.
*   **NAS**: The system backs up data from Apsara File Storage NAS file systems.', example='ECS_FILE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model EnableBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model EnableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableBackupPlanResponseBody(name='body'),
}

/**
  * If the request is successful, the system enables the backup plan and backs up data based on the polices that are specified in the backup plan. If you call the DescribeBackupPlans operation to query backup plans, the Disabled parameter is automatically set to false for the backup plan.
  *
  * @param request EnableBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnableBackupPlanResponse
 */
async function enableBackupPlanWithOptions(request: EnableBackupPlanRequest, runtime: Util.RuntimeOptions): EnableBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If the request is successful, the system enables the backup plan and backs up data based on the polices that are specified in the backup plan. If you call the DescribeBackupPlans operation to query backup plans, the Disabled parameter is automatically set to false for the backup plan.
  *
  * @param request EnableBackupPlanRequest
  * @return EnableBackupPlanResponse
 */
async function enableBackupPlan(request: EnableBackupPlanRequest): EnableBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBackupPlanWithOptions(request, runtime);
}

model EnableHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0001zfcn******0pr3'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm4ebtpkzx7zy'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-00030j3c******sn'),
}

model EnableHanaBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model EnableHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableHanaBackupPlanResponseBody(name='body'),
}

/**
  * To disable the backup plan again, call the DisableHanaBackupPlan operation.
  *
  * @param request EnableHanaBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return EnableHanaBackupPlanResponse
 */
async function enableHanaBackupPlanWithOptions(request: EnableHanaBackupPlanRequest, runtime: Util.RuntimeOptions): EnableHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To disable the backup plan again, call the DisableHanaBackupPlan operation.
  *
  * @param request EnableHanaBackupPlanRequest
  * @return EnableHanaBackupPlanResponse
 */
async function enableHanaBackupPlan(request: EnableHanaBackupPlanRequest): EnableHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHanaBackupPlanWithOptions(request, runtime);
}

model ExecuteBackupPlanRequest {
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-*********************'),
  ruleId?: string(name='RuleId', description='The ID of the backup rule.', example='rule-0002*****ux8'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
}

model ExecuteBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  jobId?: string(name='JobId', description='The ID of the backup job.', example='job-*********************'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model ExecuteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteBackupPlanResponseBody(name='body'),
}

async function executeBackupPlanWithOptions(request: ExecuteBackupPlanRequest, runtime: Util.RuntimeOptions): ExecuteBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeBackupPlan(request: ExecuteBackupPlanRequest): ExecuteBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeBackupPlanWithOptions(request, runtime);
}

model ExecutePolicyV2Request {
  dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='i-bp1************dtv'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************hky'),
  ruleId?: string(name='RuleId', description='The ID of the rule. A rule can be executed only if of the **RuleType** is **BACKUP**.', example='rule-0002*****ux8'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model ExecutePolicyV2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  jobId?: string(name='JobId', description='The ID of the backup job.', example='job-*********************'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F4EEB401-DD21-588D-AE3B-1E835C7655E1'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model ExecutePolicyV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecutePolicyV2ResponseBody(name='body'),
}

async function executePolicyV2WithOptions(request: ExecutePolicyV2Request, runtime: Util.RuntimeOptions): ExecutePolicyV2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecutePolicyV2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executePolicyV2(request: ExecutePolicyV2Request): ExecutePolicyV2Response {
  var runtime = new Util.RuntimeOptions{};
  return executePolicyV2WithOptions(request, runtime);
}

model GenerateRamPolicyRequest {
  actionType?: string(name='ActionType', description='The type of the policy that you want to generate. Valid values:

*   custom: custom policy
*   system: system policy', example='system'),
  requireBasePolicy?: boolean(name='RequireBasePolicy', description='Specifies whether to generate the policy based on an existing instance-specific rule. Valid values:

*   true
*   false', example='true'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-*********************'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0007al3m******7ao'),
}

model GenerateRamPolicyResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  policyDocument?: string(name='PolicyDocument', description='The content of the policy.', example='{     "Version": "1",     "Statement": [         {             "Effect": "Deny",             "Action": [                 "hbr:CreateRestore",                 "hbr:CreateRestoreJob",                 "hbr:CreateHanaRestore",                 "hbr:CreateUniRestorePlan",                 "hbr:CreateSqlServerRestore"             ],             "Resource": [                 "acs:hbr:*:1178******531:vault/v-000******blx06",                 "acs:hbr:*:1178******531:vault/v-000******blx06/client/*"             ]         }     ] }'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model GenerateRamPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateRamPolicyResponseBody(name='body'),
}

async function generateRamPolicyWithOptions(request: GenerateRamPolicyRequest, runtime: Util.RuntimeOptions): GenerateRamPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.requireBasePolicy)) {
    query['RequireBasePolicy'] = request.requireBasePolicy;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateRamPolicy',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateRamPolicy(request: GenerateRamPolicyRequest): GenerateRamPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateRamPolicyWithOptions(request, runtime);
}

model GetTempFileDownloadLinkRequest {
  tempFileKey?: string(name='TempFileKey', example='temp/1797733170015112/report/r-000jdzknbp39cnf9hs99/r-000jdzknbp39cnf9hs99-total.csv'),
}

model GetTempFileDownloadLinkResponseBody = {
  code?: string(name='Code', example='200'),
  message?: string(name='Message', example='successful'),
  requestId?: string(name='RequestId', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', example='true'),
  url?: string(name='Url', example='https://a-hbr-temp-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/job-0007yg2i0m6705wdhgb6_0.csv?Expires=1649406469&OSSAccessKeyId=LTAIjGotF8wX****&Signature=26%2BgjegCrRmMDCpS5jzyG4ivKU8%3D'),
}

model GetTempFileDownloadLinkResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTempFileDownloadLinkResponseBody(name='body'),
}

async function getTempFileDownloadLinkWithOptions(request: GetTempFileDownloadLinkRequest, runtime: Util.RuntimeOptions): GetTempFileDownloadLinkResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.tempFileKey)) {
    query['TempFileKey'] = request.tempFileKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTempFileDownloadLink',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTempFileDownloadLink(request: GetTempFileDownloadLinkRequest): GetTempFileDownloadLinkResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTempFileDownloadLinkWithOptions(request, runtime);
}

model InstallBackupClientsRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIds?: map[string]any(name='InstanceIds', description='The IDs of ECS instances. You can specify up to 20 IDs.', example='["i-0xi5wj5*****v3j3bh2gj5"]'),
}

model InstallBackupClientsShrinkRequest {
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIdsShrink?: string(name='InstanceIds', description='The IDs of ECS instances. You can specify up to 20 IDs.', example='["i-0xi5wj5*****v3j3bh2gj5"]'),
}

model InstallBackupClientsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode', description='The error code that is returned. Valid values:

- If the value is empty, the request is successful.
- **InstanceNotExists**: The ECS instance does not exist.
- **InstanceNotRunning**: The ECS instance is not running.
- **CloudAssistNotRunningOnInstance**: Cloud Assistant is unavailable.', example='InstanceNotExists'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-0xi5w***v3j3bh2gj5'),
      validInstance?: boolean(name='ValidInstance', description='Indicates whether a backup client can be installed on the ECS instance.

- true: A backup client can be installed on the ECS instance.
- false: A backup client cannot be installed on the ECS instance.', example='true'),
    }
  ](name='InstanceStatuses', description='The status of ECS instances.'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

- true: indicates that the request is successful.
- false: indicates that the request fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task. You can call the DescribeTask to query the execution result of the asynchronous task.', example='t-*********************'),
}

model InstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallBackupClientsResponseBody(name='body'),
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to install a backup client on an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes. We recommend that you call the DescribeTask operation to run the first query 30 seconds after you call the UninstallBackupClients operation to uninstall backup clients. Then, run the next queries at an interval of 30 seconds.
  *
  * @param tmpReq InstallBackupClientsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return InstallBackupClientsResponse
 */
async function installBackupClientsWithOptions(tmpReq: InstallBackupClientsRequest, runtime: Util.RuntimeOptions): InstallBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new InstallBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to install a backup client on an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes. We recommend that you call the DescribeTask operation to run the first query 30 seconds after you call the UninstallBackupClients operation to uninstall backup clients. Then, run the next queries at an interval of 30 seconds.
  *
  * @param request InstallBackupClientsRequest
  * @return InstallBackupClientsResponse
 */
async function installBackupClients(request: InstallBackupClientsRequest): InstallBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return installBackupClientsWithOptions(request, runtime);
}

model OpenHbrServiceResponseBody = {
  orderId?: string(name='OrderId', example='215463686160696'),
  requestId?: string(name='RequestId', example='F4A1D5F4-5055-549A-8B25-6DD23311E299'),
}

model OpenHbrServiceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: OpenHbrServiceResponseBody(name='body'),
}

async function openHbrServiceWithOptions(runtime: Util.RuntimeOptions): OpenHbrServiceResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'OpenHbrService',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function openHbrService(): OpenHbrServiceResponse {
  var runtime = new Util.RuntimeOptions{};
  return openHbrServiceWithOptions(runtime);
}

model SearchHistoricalSnapshotsRequest {
  limit?: int32(name='Limit', description='The maximum number of rows that you want the current query to return.

To query only the number of matched rows without the need to return specific data, you can set the Limit parameter to `0`. Then, the operation returns only the number of matched rows.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is required to obtain the next page of backup snapshots.', example='caeba0bbb2be03f84eb48b699f0a****'),
  query?: [ any ](name='Query', description='The query conditions. Example:

```

[
  {
    "field": "VaultId",
    "value": "v-0003rf9m*****qx5",
    "operation": "MATCH_TERM"
  },
  {
    "field": "InstanceId",
    "value": "i-bp1i20zq2*****e9368m",
    "operation": "MATCH_TERM"
  },
  {
    "field": "PlanId",
    "value": "plan-0005vk*****gkd1iu4f",
    "operation": "MATCH_TERM"
  },
  {
    "field": "CompleteTime",
    "value": 1626769913,
    "operation": "GREATER_THAN_OR_EQUAL"
  }
]
                                
```

*   The following fields are supported:

    *   VaultId: specifies the ID of the backup vault. This field is required.
    *   InstanceId: specifies the ID of the ECS instance. If the SourceType parameter is set to ECS_FILE, this field is required.
    *   Bucket: specifies the ID of the OSS bucket. If the SourceType parameter is set to OSS, this field is required.
    *   FileSystemId: specifies the ID of the NAS file system. If the SourceType parameter is set to NAS, this field is required.
    *   CreateTime: specifies the time when the NAS file system was created. If the SourceType parameter is set to NAS, this field is required.
    *   CompleteTime: specifies the time when the backup snapshot was completed.

*   The following operations are supported:

    *   MATCH_TERM: exact match.
    *   GREATER_THAN: greater than.
    *   GREATER_THAN_OR_EQUAL: greater than or equal to.
    *   LESS_THAN: less than.
    *   LESS_THAN_OR_EQUAL: less than or equal to.
    *   BETWEEN: specifies a JSON array as a range. The results must fall within the range in the `[Minimum value,maximum value]` format.
    *   IN: specifies an array as a collection. The results must fall within the collection.
    *   NOT_IN: specifies an array as a collection. The results cannot fall within the collection.', example='[   {     "field": "VaultId",     "value": "v-0003rf9m17pap3ltpqx5",     "operation": "MATCH_TERM"   },   {     "field": "InstanceId",     "value": "i-bp1i20zq2wuzdie9368m",     "operation": "MATCH_TERM"   },   {     "field": "PlanId",     "value": "plan-0005vkqhpesqgkd1iu4f",     "operation": "MATCH_TERM"   },   {     "field": "CompleteTime",     "value": 1626769913,     "operation": "GREATER_THAN_OR_EQUAL"   } ]'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
*   **OSS**: backup snapshots for Object Storage Service (OSS) buckets
*   **NAS**: backup snapshots for Apsara File Storage NAS file systems', example='ECS_FILE'),
}

model SearchHistoricalSnapshotsShrinkRequest {
  limit?: int32(name='Limit', description='The maximum number of rows that you want the current query to return.

To query only the number of matched rows without the need to return specific data, you can set the Limit parameter to `0`. Then, the operation returns only the number of matched rows.', example='10'),
  nextToken?: string(name='NextToken', description='The token that is required to obtain the next page of backup snapshots.', example='caeba0bbb2be03f84eb48b699f0a****'),
  queryShrink?: string(name='Query', description='The query conditions. Example:

```

[
  {
    "field": "VaultId",
    "value": "v-0003rf9m*****qx5",
    "operation": "MATCH_TERM"
  },
  {
    "field": "InstanceId",
    "value": "i-bp1i20zq2*****e9368m",
    "operation": "MATCH_TERM"
  },
  {
    "field": "PlanId",
    "value": "plan-0005vk*****gkd1iu4f",
    "operation": "MATCH_TERM"
  },
  {
    "field": "CompleteTime",
    "value": 1626769913,
    "operation": "GREATER_THAN_OR_EQUAL"
  }
]
                                
```

*   The following fields are supported:

    *   VaultId: specifies the ID of the backup vault. This field is required.
    *   InstanceId: specifies the ID of the ECS instance. If the SourceType parameter is set to ECS_FILE, this field is required.
    *   Bucket: specifies the ID of the OSS bucket. If the SourceType parameter is set to OSS, this field is required.
    *   FileSystemId: specifies the ID of the NAS file system. If the SourceType parameter is set to NAS, this field is required.
    *   CreateTime: specifies the time when the NAS file system was created. If the SourceType parameter is set to NAS, this field is required.
    *   CompleteTime: specifies the time when the backup snapshot was completed.

*   The following operations are supported:

    *   MATCH_TERM: exact match.
    *   GREATER_THAN: greater than.
    *   GREATER_THAN_OR_EQUAL: greater than or equal to.
    *   LESS_THAN: less than.
    *   LESS_THAN_OR_EQUAL: less than or equal to.
    *   BETWEEN: specifies a JSON array as a range. The results must fall within the range in the `[Minimum value,maximum value]` format.
    *   IN: specifies an array as a collection. The results must fall within the collection.
    *   NOT_IN: specifies an array as a collection. The results cannot fall within the collection.', example='[   {     "field": "VaultId",     "value": "v-0003rf9m17pap3ltpqx5",     "operation": "MATCH_TERM"   },   {     "field": "InstanceId",     "value": "i-bp1i20zq2wuzdie9368m",     "operation": "MATCH_TERM"   },   {     "field": "PlanId",     "value": "plan-0005vkqhpesqgkd1iu4f",     "operation": "MATCH_TERM"   },   {     "field": "CompleteTime",     "value": 1626769913,     "operation": "GREATER_THAN_OR_EQUAL"   } ]'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: backup snapshots for Elastic Compute Service (ECS) files
*   **OSS**: backup snapshots for Object Storage Service (OSS) buckets
*   **NAS**: backup snapshots for Apsara File Storage NAS file systems', example='ECS_FILE'),
}

model SearchHistoricalSnapshotsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  limit?: int32(name='Limit', description='The number of historical backup snapshots that are displayed on the current page.', example='10'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  nextToken?: string(name='NextToken', description='The token that is required to obtain the next page of backup snapshots.', example='BE'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  snapshots?: {
    snapshot?: [ 
    {
      actualBytes?: long(name='ActualBytes', description='The actual amount of backup snapshots after duplicates are removed. Unit: bytes.', example='600'),
      actualItems?: long(name='ActualItems', description='The actual number of backup snapshots.

**

**Note** This parameter is available only for file backup.', example='6'),
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      bucket?: string(name='Bucket', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the name of the OSS bucket.', example='hbr-backup-oss'),
      bytesDone?: long(name='BytesDone', description='The actual amount of data that is generated by incremental backups. Unit: bytes.', example='800'),
      bytesTotal?: long(name='BytesTotal', description='The total amount of data. Unit: bytes.', example='1000'),
      clientId?: string(name='ClientId', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the ID of the backup client.', example='c-*********************'),
      completeTime?: long(name='CompleteTime', description='The time when the backup snapshot was completed. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      createTime?: long(name='CreateTime', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the time when the file system was created. This value is a UNIX timestamp. Unit: seconds.', example='1607436917'),
      createdTime?: long(name='CreatedTime', description='The time when the backup snapshot was created. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      errorFile?: string(name='ErrorFile', description='The files that record the information about backup failures, including the information about partially completed backups.', example='Item	Error Message C:\\Program Files (x86)\\Symantec\\Symantec Endpoint Protection\\14.3.558.0000.105\\Bin\\service.dat	Open: open \\\\?\\C:\\Program Files (x86)\\Symantec\\Symantec Endpoint Protection\\14.3.558.0000.105\\Bin\\service.dat: The process cannot access the file because it is being used by another process. C:\\ProgramData\\McAfee\\Agent\\data\\InstallerFiles\\172e8a3b04b7ab0fd0215f4fb7707e3744b37d83b6743b3eacb94447c74dc9af_contrib.ini	Open: open \\\\?\\C:\\ProgramData\\McAfee\\Agent\\data\\InstallerFiles\\172e8a3b04b7ab0fd0215f4fb7707e3744b37d83b6743b3eacb94447c74dc9af_contrib.ini: Access is denied.'),
      expireTime?: long(name='ExpireTime', description='The time when the backup snapshot expires.', example='1640334062'),
      fileSystemId?: string(name='FileSystemId', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the ID of the NAS file system.', example='005494'),
      instanceId?: string(name='InstanceId', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the ID of the ECS instance.', example='i-*********************'),
      instanceName?: string(name='InstanceName', description='The name of the Tablestore instance.', example='instancename'),
      itemsDone?: long(name='ItemsDone', description='The number of objects that are backed up.

**

**Note** This parameter is available only for file backup.', example='8'),
      itemsTotal?: long(name='ItemsTotal', description='The total number of objects in the data source.

**

**Note** This parameter is available only for file backup.', example='10'),
      jobId?: string(name='JobId', description='The ID of the backup job.', example='v-*********************'),
      parentSnapshotHash?: string(name='ParentSnapshotHash', description='The hash value of the parent backup snapshot.', example='f2fe..'),
      path?: string(name='Path', description='This parameter is returned only if the **SourceType** parameter is set to **ECS_FILE**. This parameter indicates the path to the files that are backed up.', example='["/home"]'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths', description='This parameter is returned only if the **SourceType** parameter is set to **NAS**. This parameter indicates the path to the files that are backed up.', example='"/home"'),
      prefix?: string(name='Prefix', description='This parameter is returned only if the **SourceType** parameter is set to **OSS**. This parameter indicates the prefix of objects that are backed up.', example='example/'),
      rangeEnd?: long(name='RangeEnd', description='The time when the backup job ended. This value is a UNIX timestamp. Unit: seconds.', example='1642521709966'),
      rangeStart?: long(name='RangeStart', description='The time when the backup job started. This value is a UNIX timestamp. Unit: seconds.', example='1642492553038'),
      retention?: long(name='Retention', description='The retention period of the backup snapshot.', example='7'),
      snapshotHash?: string(name='SnapshotHash', description='The hash value of the backup snapshot.', example='f2fe...'),
      snapshotId?: string(name='SnapshotId', description='The ID of the backup snapshot.', example='s-*********************'),
      sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: backup snapshots for ECS files
*   **OSS**: backup snapshots for OSS buckets
*   **NAS**: backup snapshots for NAS file systems', example='ECS_FILE'),
      startTime?: long(name='StartTime', description='The start time of the backup snapshot. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      status?: string(name='Status', description='The status of the backup job. Valid values:

*   **COMPLETE**: The backup job is completed.
*   **PARTIAL_COMPLETE**: The backup job is partially completed.
*   **FAILED**: The backup job has failed.', example='COMPLETE'),
      tableName?: string(name='TableName', description='The name of the table in the Tablestore instance.', example='table2'),
      updatedTime?: long(name='UpdatedTime', description='The time when the backup snapshot was updated. This value is a UNIX timestamp. Unit: seconds.', example='1554347313'),
      vaultId?: string(name='VaultId', description='The ID of the backup vault that stores the backup snapshot.', example='v-0003rf9m17pap3ltpqx5'),
    }
  ](name='Snapshot')
  }(name='Snapshots', description='The historical backup snapshots.'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
  totalCount?: int32(name='TotalCount', description='The total number of returned backup snapshots that meet the specified conditions.', example='20'),
}

model SearchHistoricalSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchHistoricalSnapshotsResponseBody(name='body'),
}

async function searchHistoricalSnapshotsWithOptions(tmpReq: SearchHistoricalSnapshotsRequest, runtime: Util.RuntimeOptions): SearchHistoricalSnapshotsResponse {
  Util.validateModel(tmpReq);
  var request = new SearchHistoricalSnapshotsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.query)) {
    request.queryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.query, 'Query', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.queryShrink)) {
    query['Query'] = request.queryShrink;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchHistoricalSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchHistoricalSnapshots(request: SearchHistoricalSnapshotsRequest): SearchHistoricalSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchHistoricalSnapshotsWithOptions(request, runtime);
}

model StartHanaDatabaseAsyncRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000a9ipe******sme'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='HXE'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0000hrh******vhr3i'),
}

model StartHanaDatabaseAsyncResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the job that is used to initialize the backup vault. You can call the DescribeTask operation to query the status of the job.', example='t-000bjt479yefheij1o0x'),
}

model StartHanaDatabaseAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartHanaDatabaseAsyncResponseBody(name='body'),
}

/**
  * To stop the database again, call the StopHanaDatabaseAsync operation.
  *
  * @param request StartHanaDatabaseAsyncRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StartHanaDatabaseAsyncResponse
 */
async function startHanaDatabaseAsyncWithOptions(request: StartHanaDatabaseAsyncRequest, runtime: Util.RuntimeOptions): StartHanaDatabaseAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartHanaDatabaseAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To stop the database again, call the StopHanaDatabaseAsync operation.
  *
  * @param request StartHanaDatabaseAsyncRequest
  * @return StartHanaDatabaseAsyncResponse
 */
async function startHanaDatabaseAsync(request: StartHanaDatabaseAsyncRequest): StartHanaDatabaseAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return startHanaDatabaseAsyncWithOptions(request, runtime);
}

model StopHanaDatabaseAsyncRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000dw******45ijer'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='BWP'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006wkn******gzkn'),
}

model StopHanaDatabaseAsyncResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='CD8B903B-DE8F-5969-9414-B2C634D504D9'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous job. You can call the DescribeTask operation to query the execution result of the asynchronous job.', example='t-0007o3vqfukgd3y5bxxr'),
}

model StopHanaDatabaseAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopHanaDatabaseAsyncResponseBody(name='body'),
}

/**
  * To start the database again, call the StartHanaDatabaseAsync operation.
  *
  * @param request StopHanaDatabaseAsyncRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return StopHanaDatabaseAsyncResponse
 */
async function stopHanaDatabaseAsyncWithOptions(request: StopHanaDatabaseAsyncRequest, runtime: Util.RuntimeOptions): StopHanaDatabaseAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopHanaDatabaseAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * To start the database again, call the StartHanaDatabaseAsync operation.
  *
  * @param request StopHanaDatabaseAsyncRequest
  * @return StopHanaDatabaseAsyncResponse
 */
async function stopHanaDatabaseAsync(request: StopHanaDatabaseAsyncRequest): StopHanaDatabaseAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopHanaDatabaseAsyncWithOptions(request, runtime);
}

model UninstallBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', description='The IDs of backup clients. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 20. Otherwise, an error occurs.', example='["c-*********************"]'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIds?: map[string]any(name='InstanceIds', description='The IDs of ECS instances. You can specify up to 20 IDs.', example='["i-0xi5wj5*****v3j3bh2gj5"]'),
}

model UninstallBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds', description='The IDs of backup clients. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 20. Otherwise, an error occurs.', example='["c-*********************"]'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIdsShrink?: string(name='InstanceIds', description='The IDs of ECS instances. You can specify up to 20 IDs.', example='["i-0xi5wj5*****v3j3bh2gj5"]'),
}

model UninstallBackupClientsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode', description='The error code that is returned. Valid values:

- If the value is empty, the request is successful.
- **InstanceNotExists**: The ECS instance does not exist.
- **InstanceNotRunning**: The ECS instance is not running.
- **CloudAssistNotRunningOnInstance**: Cloud Assistant is unavailable.', example='InstanceNotExists'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-0xi5w***v3j3bh2gj5'),
      validInstance?: boolean(name='ValidInstance', description='Indicates whether a backup client can be installed on the ECS instance.

- true: A backup client can be installed on the ECS instance.
- false: A backup client cannot be installed on the ECS instance.', example='true'),
    }
  ](name='InstanceStatuses', description='The status of the ECS instance.'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task. You can call the DescribeTask operation to query the execution result of the asynchronous task.', example='t-*********************'),
}

model UninstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallBackupClientsResponseBody(name='body'),
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to uninstall a backup client from an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes. We recommend that you call the DescribeTask operation to run the first query 30 seconds after you call the UninstallBackupClients operation to uninstall backup clients. Then, run the next queries at an interval of 30 seconds.
  *
  * @param tmpReq UninstallBackupClientsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UninstallBackupClientsResponse
 */
async function uninstallBackupClientsWithOptions(tmpReq: UninstallBackupClientsRequest, runtime: Util.RuntimeOptions): UninstallBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new UninstallBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to uninstall a backup client from an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes. We recommend that you call the DescribeTask operation to run the first query 30 seconds after you call the UninstallBackupClients operation to uninstall backup clients. Then, run the next queries at an interval of 30 seconds.
  *
  * @param request UninstallBackupClientsRequest
  * @return UninstallBackupClientsResponse
 */
async function uninstallBackupClients(request: UninstallBackupClientsRequest): UninstallBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallBackupClientsWithOptions(request, runtime);
}

model UninstallClientRequest {
  clientId?: string(name='ClientId', description='The ID of the HBR client.', example='c-000iuqo******zi3rn'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm3erpwweavki'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0008n2q******ax3'),
}

model UninstallClientResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='048A2164-3732-5DF5-88B5-F97FA56DAEB1'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous job. You can call the DescribeTask operation to query the execution result of the asynchronous job.', example='t-0009qs5qcnvuvqrl2mxl'),
}

model UninstallClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallClientResponseBody(name='body'),
}

/**
  * If you call this operation, the specified HBR client is uninstalled. To reinstall the HBR client, call the CreateClients operation.
  *
  * @param request UninstallClientRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UninstallClientResponse
 */
async function uninstallClientWithOptions(request: UninstallClientRequest, runtime: Util.RuntimeOptions): UninstallClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you call this operation, the specified HBR client is uninstalled. To reinstall the HBR client, call the CreateClients operation.
  *
  * @param request UninstallClientRequest
  * @return UninstallClientResponse
 */
async function uninstallClient(request: UninstallClientRequest): UninstallClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallClientWithOptions(request, runtime);
}

model UpdateBackupPlanRequest {
  detail?: map[string]any(name='Detail', description='The detail about the ECS instance backup, the format of value type is JSON.

* snapshotGroup: whether to use a snapshot-consistent group (only enhanced SSDs (ESSDs)).
* appConsistent: whether to enable the application-consistent backup feature (use with preScriptPath and postScriptPath only).
* preScriptPath: the pre-freeze scripts path.
* postScriptPath: the post-thaw scripts path.', example='{\\"EnableFsFreeze\\":true,\\"appConsistent\\":false,\\"postScriptPath\\":\\"\\",\\"preScriptPath\\":\\"\\",\\"snapshotGroup\\":true,\\"timeoutInSeconds\\":60}'),
  exclude?: string(name='Exclude', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  include?: string(name='Include', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that you want to back up. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  keepLatestSnapshots?: long(name='KeepLatestSnapshots'),
  options?: string(name='Options', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies whether to use Windows VSS to define a backup path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
  otsDetail?: OtsDetail(name='OtsDetail', description='The details about the Tablestore instance.'),
  path?: [ string ](name='Path', description='The backup paths.'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-20211***735'),
  planName?: string(name='PlanName', description='The name of the backup plan.', example='planname'),
  prefix?: string(name='Prefix', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies a prefix. After a prefix is specified, only objects whose names start with the prefix are backed up.', example='oss-prefix'),
  retention?: long(name='Retention', description='The retention period of backup data. Minimum value: 1. Unit: days.', example='7'),
  rule?: [ 
    {
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      destinationRegionId?: string(name='DestinationRegionId', description='The ID of the region where the remote backup vault resides.', example='cn-shanghai'),
      destinationRetention?: long(name='DestinationRetention', description='The retention period of backup data.', example='7'),
      disabled?: boolean(name='Disabled', description='Indicates whether the policy is disabled.', example='false'),
      doCopy?: boolean(name='DoCopy', description='Indicates whether the snapshot data is backed up to the backup vault.', example='false'),
      retention?: long(name='Retention', description='The retention period of backup data.', example='7'),
      ruleName?: string(name='RuleName', description='The name of the policy.', example='rule-test-name'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1631685600|P1D'),
    }
  ](name='Rule', description='The backup plan rule.'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
  speedLimit?: string(name='SpeedLimit', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the throttling rules. You can limit the bandwidth that is used for data backup during peak hours to ensure business continuity. Format: `{start}|{end}|{bandwidth}`. Separate multiple throttling rules with vertical bars (|). A specified time range cannot overlap with another time range.

*   **start**: the start hour
*   **end**: the end hour
*   **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:5120'),
  updatePaths?: boolean(name='UpdatePaths', description='Specifies whether to update the backup path if the backup path is empty. Valid values:

*   true: The system replaces the original backup path with the specified backup path.
*   false: The system does not update the original backup path. The system backs up data based on the backup path that you specified when you created the backup plan.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
}

model UpdateBackupPlanShrinkRequest {
  detailShrink?: string(name='Detail', description='The detail about the ECS instance backup, the format of value type is JSON.

* snapshotGroup: whether to use a snapshot-consistent group (only enhanced SSDs (ESSDs)).
* appConsistent: whether to enable the application-consistent backup feature (use with preScriptPath and postScriptPath only).
* preScriptPath: the pre-freeze scripts path.
* postScriptPath: the post-thaw scripts path.', example='{\\"EnableFsFreeze\\":true,\\"appConsistent\\":false,\\"postScriptPath\\":\\"\\",\\"preScriptPath\\":\\"\\",\\"snapshotGroup\\":true,\\"timeoutInSeconds\\":60}'),
  exclude?: string(name='Exclude', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that are excluded from the backup job. The value must be 1 to 255 characters in length.', example='["/var", "/proc"]'),
  include?: string(name='Include', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the paths to the files that you want to back up. The value must be 1 to 255 characters in length.', example='["/home/alice/*.pdf", "/home/bob/*.txt"]'),
  keepLatestSnapshots?: long(name='KeepLatestSnapshots'),
  options?: string(name='Options', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies whether to use Windows VSS to define a backup path.

*   This parameter is available only for Windows ECS instances.
*   If data changes occur in the backup source, the source data must be the same as the data to be backed up before the system sets this parameter to `["UseVSS":true]`.
*   If you use VSS, you cannot back up data from multiple directories.', example='{"UseVSS":false}'),
  otsDetailShrink?: string(name='OtsDetail', description='The details about the Tablestore instance.'),
  path?: [ string ](name='Path', description='The backup paths.'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='plan-20211***735'),
  planName?: string(name='PlanName', description='The name of the backup plan.', example='planname'),
  prefix?: string(name='Prefix', description='This parameter is required only if the **SourceType** parameter is set to **OSS**. This parameter specifies a prefix. After a prefix is specified, only objects whose names start with the prefix are backed up.', example='oss-prefix'),
  retention?: long(name='Retention', description='The retention period of backup data. Minimum value: 1. Unit: days.', example='7'),
  rule?: [ 
    {
      backupType?: string(name='BackupType', description='The backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      destinationRegionId?: string(name='DestinationRegionId', description='The ID of the region where the remote backup vault resides.', example='cn-shanghai'),
      destinationRetention?: long(name='DestinationRetention', description='The retention period of backup data.', example='7'),
      disabled?: boolean(name='Disabled', description='Indicates whether the policy is disabled.', example='false'),
      doCopy?: boolean(name='DoCopy', description='Indicates whether the snapshot data is backed up to the backup vault.', example='false'),
      retention?: long(name='Retention', description='The retention period of backup data.', example='7'),
      ruleName?: string(name='RuleName', description='The name of the policy.', example='rule-test-name'),
      schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1631685600|P1D'),
    }
  ](name='Rule', description='The backup plan rule.'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the `{startTime}` parameter and the subsequent backup jobs at an interval that is specified in the `{interval}` parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   **startTime**: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   **interval**: the interval at which the system runs a backup job. The interval must follow the ISO8601 standard. For example, PT1H indicates an interval of 1 hour. P1D indicates an interval of one day.', example='I|1602673264|P1D'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **ECS_FILE**: Elastic Compute Service (ECS) files
*   **OSS**: Object Storage Service (OSS) buckets
*   **NAS**: Apsara File Storage NAS file systems', example='ECS_FILE'),
  speedLimit?: string(name='SpeedLimit', description='This parameter is required only if the **SourceType** parameter is set to **ECS_FILE**. This parameter specifies the throttling rules. You can limit the bandwidth that is used for data backup during peak hours to ensure business continuity. Format: `{start}|{end}|{bandwidth}`. Separate multiple throttling rules with vertical bars (|). A specified time range cannot overlap with another time range.

*   **start**: the start hour
*   **end**: the end hour
*   **bandwidth**: the bandwidth. Unit: KB/s.', example='0:24:5120'),
  updatePaths?: boolean(name='UpdatePaths', description='Specifies whether to update the backup path if the backup path is empty. Valid values:

*   true: The system replaces the original backup path with the specified backup path.
*   false: The system does not update the original backup path. The system backs up data based on the backup path that you specified when you created the backup plan.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0006******q'),
}

model UpdateBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful.

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBackupPlanResponseBody(name='body'),
}

async function updateBackupPlanWithOptions(tmpReq: UpdateBackupPlanRequest, runtime: Util.RuntimeOptions): UpdateBackupPlanResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateBackupPlanShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detail)) {
    request.detailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detail, 'Detail', 'json');
  }
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.detailShrink)) {
    query['Detail'] = request.detailShrink;
  }
  if (!Util.isUnset(request.keepLatestSnapshots)) {
    query['KeepLatestSnapshots'] = request.keepLatestSnapshots;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.speedLimit)) {
    query['SpeedLimit'] = request.speedLimit;
  }
  if (!Util.isUnset(request.updatePaths)) {
    query['UpdatePaths'] = request.updatePaths;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.rule)) {
    body['Rule'] = request.rule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBackupPlan(request: UpdateBackupPlanRequest): UpdateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBackupPlanWithOptions(request, runtime);
}

model UpdateClientSettingsRequest {
  clientId?: string(name='ClientId', description='The ID of the backup client.', example='c-*********************'),
  dataNetworkType?: string(name='DataNetworkType', description='The network type of the backup client. Valid values:

*   **PUBLIC**: public network
*   **VPC**: VPC.
*   **CLASSIC**: classic network', example='VPC'),
  dataProxySetting?: string(name='DataProxySetting', description='The proxy settings of the backup client. Valid values:

*   **DISABLE**: No proxy is configured.
*   **USE_CONTROL_PROXY **: The proxy settings are the same as the settings that are predefined by the system. Default value: USE_CONTROL_PROXY.
*   **CUSTOM**: Custom HTTP proxy settings are configured.', example='USE_CONTROL_PROXY'),
  maxCpuCore?: int32(name='MaxCpuCore', description='The number of CPU cores that can be used by a single backup job. A value of 0 indicates no limits.', example='1'),
  maxWorker?: int32(name='MaxWorker', description='The number of concurrent tasks that can be included in a backup job. A value of 0 indicates no limits.', example='1'),
  proxyHost?: string(name='ProxyHost', description='The custom IP address of the proxy server.', example='192.168.11.100'),
  proxyPassword?: string(name='ProxyPassword', description='The custom password of the proxy server.', example='******'),
  proxyPort?: int32(name='ProxyPort', description='The custom port number of the proxy server.', example='3128'),
  proxyUser?: string(name='ProxyUser', description='The custom username of the proxy server.', example='user'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of resource group.', example='rg-*********************'),
  useHttps?: boolean(name='UseHttps', description='Specifies whether to transmit data over HTTPS.

*   true: The system transmits data over HTTPS.
*   false: The system transmits data over HTTP.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault. If you use a backup client of an earlier version, you must set this parameter.', example='v-*********************'),
}

model UpdateClientSettingsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model UpdateClientSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClientSettingsResponseBody(name='body'),
}

/**
  * You can call this operation to update the settings of a backup client of an earlier version or the latest version.
  *
  * @param request UpdateClientSettingsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateClientSettingsResponse
 */
async function updateClientSettingsWithOptions(request: UpdateClientSettingsRequest, runtime: Util.RuntimeOptions): UpdateClientSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.dataNetworkType)) {
    query['DataNetworkType'] = request.dataNetworkType;
  }
  if (!Util.isUnset(request.dataProxySetting)) {
    query['DataProxySetting'] = request.dataProxySetting;
  }
  if (!Util.isUnset(request.maxCpuCore)) {
    query['MaxCpuCore'] = request.maxCpuCore;
  }
  if (!Util.isUnset(request.maxWorker)) {
    query['MaxWorker'] = request.maxWorker;
  }
  if (!Util.isUnset(request.proxyHost)) {
    query['ProxyHost'] = request.proxyHost;
  }
  if (!Util.isUnset(request.proxyPassword)) {
    query['ProxyPassword'] = request.proxyPassword;
  }
  if (!Util.isUnset(request.proxyPort)) {
    query['ProxyPort'] = request.proxyPort;
  }
  if (!Util.isUnset(request.proxyUser)) {
    query['ProxyUser'] = request.proxyUser;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useHttps)) {
    query['UseHttps'] = request.useHttps;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClientSettings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to update the settings of a backup client of an earlier version or the latest version.
  *
  * @param request UpdateClientSettingsRequest
  * @return UpdateClientSettingsResponse
 */
async function updateClientSettings(request: UpdateClientSettingsRequest): UpdateClientSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClientSettingsWithOptions(request, runtime);
}

model UpdateHanaBackupPlanRequest {
  backupPrefix?: string(name='BackupPrefix', description='The backup prefix.', example='COMPLETE_DATA_BACKUP'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-0005dhe******f38'),
  planId?: string(name='PlanId', description='The ID of the backup plan.', example='pl-000br3cm4dqvmtph7cul'),
  planName?: string(name='PlanName', description='The name of the backup plan.', example='plan-20211109-162411'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmze36euddwjq'),
  schedule?: string(name='Schedule', description='The backup policy. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval must follow the ISO 8601 standard. For example, PT1H specifies an interval of 1 hour. P1D specifies an interval of one day.', example='I|1602673264|P1D'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0000rcw******5c6'),
}

model UpdateHanaBackupPlanResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='F23BCC67-09B4-582C-AE70-C813C8548DCC'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdateHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaBackupPlanResponseBody(name='body'),
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param request UpdateHanaBackupPlanRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateHanaBackupPlanResponse
 */
async function updateHanaBackupPlanWithOptions(request: UpdateHanaBackupPlanRequest, runtime: Util.RuntimeOptions): UpdateHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   A backup plan defines the data source, backup policy, and other configurations. After you execute a backup plan, a backup job is generated to record the backup progress and the backup result. If a backup job is completed, a backup snapshot is generated. You can use a backup snapshot to create a restore job.
  * *   You can specify only one type of data source in a backup plan.
  * *   You can specify only one interval as a backup cycle in a backup plan.
  * *   Each backup plan allows you to back up data to only one backup vault.
  *
  * @param request UpdateHanaBackupPlanRequest
  * @return UpdateHanaBackupPlanResponse
 */
async function updateHanaBackupPlan(request: UpdateHanaBackupPlanRequest): UpdateHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaBackupPlanWithOptions(request, runtime);
}

model UpdateHanaBackupSettingRequest {
  catalogBackupParameterFile?: string(name='CatalogBackupParameterFile', description='The configuration file for catalog backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
  catalogBackupUsingBackint?: boolean(name='CatalogBackupUsingBackint', description='Specifies whether to use Backint to back up catalogs. Valid values:

*   true: Backint is used to back up catalogs.
*   false: Backint is not used to back up catalogs.', example='true'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000ezvg******8znz'),
  dataBackupParameterFile?: string(name='DataBackupParameterFile', description='The configuration file for data backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  enableAutoLogBackup?: boolean(name='EnableAutoLogBackup', description='Specifies whether to enable automatic log backup. Valid values:

*   **true**: enables automatic log backup.
*   **false**: disables automatic log backup.', example='true'),
  logBackupParameterFile?: string(name='LogBackupParameterFile', description='The configuration file for log backup.', example='/usr/sap/SID/SYS/global/hdb/opt/hdbconfig/param'),
  logBackupTimeout?: long(name='LogBackupTimeout', description='The interval at which logs are backed up. Unit: seconds.', example='900'),
  logBackupUsingBackint?: boolean(name='LogBackupUsingBackint', description='Specifies whether to use Backint to back up logs. Valid values:

*   true: Backint is used to back up logs.
*   false: Backint is not used to back up logs.', example='true'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0005n******rluw5'),
}

model UpdateHanaBackupSettingResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='4892D474-9A4A-5298-BCD3-E46112A1EFD0'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdateHanaBackupSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaBackupSettingResponseBody(name='body'),
}

/**
  * If you want to update the backup retention period of a database, you can call the UpdateHanaRetentionSetting operation.
  *
  * @param request UpdateHanaBackupSettingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateHanaBackupSettingResponse
 */
async function updateHanaBackupSettingWithOptions(request: UpdateHanaBackupSettingRequest, runtime: Util.RuntimeOptions): UpdateHanaBackupSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.catalogBackupParameterFile)) {
    query['CatalogBackupParameterFile'] = request.catalogBackupParameterFile;
  }
  if (!Util.isUnset(request.catalogBackupUsingBackint)) {
    query['CatalogBackupUsingBackint'] = request.catalogBackupUsingBackint;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataBackupParameterFile)) {
    query['DataBackupParameterFile'] = request.dataBackupParameterFile;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.enableAutoLogBackup)) {
    query['EnableAutoLogBackup'] = request.enableAutoLogBackup;
  }
  if (!Util.isUnset(request.logBackupParameterFile)) {
    query['LogBackupParameterFile'] = request.logBackupParameterFile;
  }
  if (!Util.isUnset(request.logBackupTimeout)) {
    query['LogBackupTimeout'] = request.logBackupTimeout;
  }
  if (!Util.isUnset(request.logBackupUsingBackint)) {
    query['LogBackupUsingBackint'] = request.logBackupUsingBackint;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaBackupSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you want to update the backup retention period of a database, you can call the UpdateHanaRetentionSetting operation.
  *
  * @param request UpdateHanaBackupSettingRequest
  * @return UpdateHanaBackupSettingResponse
 */
async function updateHanaBackupSetting(request: UpdateHanaBackupSettingRequest): UpdateHanaBackupSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaBackupSettingWithOptions(request, runtime);
}

model UpdateHanaInstanceRequest {
  alertSetting?: string(name='AlertSetting', description='The alert settings. Valid value: INHERITED, which indicates that the backup client sends alert notifications in the same way as the backup vault.', example='INHERITED'),
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-000axjt******c6j8'),
  hanaName?: string(name='HanaName', description='The name of the SAP HANA instance.', example='SAP-HANA-DEV'),
  host?: string(name='Host', description='The private or internal IP address of the host where the primary node of the SAP HANA instance resides.', example='47.100.XX.XX'),
  instanceNumber?: int32(name='InstanceNumber', description='The instance number of the SAP HANA system.', example='00'),
  password?: string(name='Password', description='The password that is used to connect with the SAP HANA database.', example='**********'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-aekzvx7d3c4kpny'),
  useSsl?: boolean(name='UseSsl', description='Specifies whether to connect with the SAP HANA database over Secure Sockets Layer (SSL). Valid values:

*   true: The SAP HANA database is connected over SSL.
*   false: The SAP HANA database is not connected over SSL.', example='true'),
  userName?: string(name='UserName', description='The username of the SYSTEMDB database.', example='admin'),
  validateCertificate?: boolean(name='ValidateCertificate', description='Specifies whether to verify the SSL certificate of the SAP HANA database. Valid values:

*   true: The SSL certificate of the SAP HANA instance is verified.
*   false: The SSL certificate of the SAP HANA instance is not verified.', example='false'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-0003v4ah******9xp'),
}

model UpdateHanaInstanceResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call was successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='A6AB6D5A-9D21-5529-9335-A894FB045ED6'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdateHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaInstanceResponseBody(name='body'),
}

async function updateHanaInstanceWithOptions(request: UpdateHanaInstanceRequest, runtime: Util.RuntimeOptions): UpdateHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hanaName)) {
    query['HanaName'] = request.hanaName;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceNumber)) {
    query['InstanceNumber'] = request.instanceNumber;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useSsl)) {
    query['UseSsl'] = request.useSsl;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.validateCertificate)) {
    query['ValidateCertificate'] = request.validateCertificate;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHanaInstance(request: UpdateHanaInstanceRequest): UpdateHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaInstanceWithOptions(request, runtime);
}

model UpdateHanaRetentionSettingRequest {
  clusterId?: string(name='ClusterId', description='The ID of the SAP HANA instance.', example='cl-00024vyjj******srrq'),
  databaseName?: string(name='DatabaseName', description='The name of the database.', example='SYSTEMDB'),
  disabled?: boolean(name='Disabled', description='Specifies whether to permanently retain the backup. Valid values:

*   true: The backup is permanently retained.
*   false: The backup is retained for the specified number of days.', example='false'),
  retentionDays?: long(name='RetentionDays', description='The number of days for which the backup is retained. If you set the Disabled parameter to false, the backup is retained for the number of days specified by this parameter.', example='90'),
  schedule?: string(name='Schedule', description='The policy to update the retention period. Format: `I|{startTime}|{interval}`. The retention period is updated at an interval of {interval} starting from {startTime}.

*   startTime: the time at which the system starts to update the retention period. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system updates the retention period. The interval must follow the ISO 8601 standard. For example, PT1H specifies an interval of 1 hour and P1D specifies an interval of one day.', example='I|0|P1D'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000fb0v2ly******k6'),
}

model UpdateHanaRetentionSettingResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='7BEE26EB-8EE3-57A0-A9DE-5FD700165DE5'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdateHanaRetentionSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaRetentionSettingResponseBody(name='body'),
}

/**
  * *   If you want to update the backup parameters of a database, you can call the UpdateHanaBackupSetting operation.
  * *   HBR deletes the expired catalogs and data that are related to Backint and file backup. The deleted catalogs and data cannot be restored. We recommend that you set the retention period based on your business requirements.
  *
  * @param request UpdateHanaRetentionSettingRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdateHanaRetentionSettingResponse
 */
async function updateHanaRetentionSettingWithOptions(request: UpdateHanaRetentionSettingRequest, runtime: Util.RuntimeOptions): UpdateHanaRetentionSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.disabled)) {
    query['Disabled'] = request.disabled;
  }
  if (!Util.isUnset(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaRetentionSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   If you want to update the backup parameters of a database, you can call the UpdateHanaBackupSetting operation.
  * *   HBR deletes the expired catalogs and data that are related to Backint and file backup. The deleted catalogs and data cannot be restored. We recommend that you set the retention period based on your business requirements.
  *
  * @param request UpdateHanaRetentionSettingRequest
  * @return UpdateHanaRetentionSettingResponse
 */
async function updateHanaRetentionSetting(request: UpdateHanaRetentionSettingRequest): UpdateHanaRetentionSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaRetentionSettingWithOptions(request, runtime);
}

model UpdatePolicyBindingRequest {
  advancedOptions?: {
    udmDetail?: {
      appConsistent?: boolean(name='AppConsistent', description='Specifies whether to enable application consistency. You can enable application consistency only if all disks are ESSDs.', example='false'),
      diskIdList?: [ string ](name='DiskIdList', description='The IDs of disks that need to be protected. If all disks need to be protected, this parameter is empty.'),
      enableFsFreeze?: boolean(name='EnableFsFreeze', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies whether to enable Linux fsfreeze to put file systems into the read-only state before application-consistent snapshots are created. Default value: true.', example='true'),
      enableWriters?: boolean(name='EnableWriters', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies whether to create application-consistent snapshots.

*   true: creates application-consistent snapshots
*   false: creates file system-consistent snapshots

Default value: true.', example='true'),
      excludeDiskIdList?: [ string ](name='ExcludeDiskIdList', description='The IDs of the disks that do not need to be protected. If the DiskIdList parameter is not empty, this parameter is ignored.'),
      postScriptPath?: string(name='PostScriptPath', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies the path of the post-thaw scripts that are executed after application-consistent snapshots are created.', example='/tmp/postscript.sh'),
      preScriptPath?: string(name='PreScriptPath', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies the path of the pre-freeze scripts that are executed before application-consistent snapshots are created.', example='/tmp/prescript.sh'),
      ramRoleName?: string(name='RamRoleName', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies the name of the RAM role that is required to create application-consistent snapshots.', example='AliyunECSInstanceForHbrRole'),
      snapshotGroup?: boolean(name='SnapshotGroup', description='Specifies whether to create a snapshot-consistent group. You can create a snapshot-consistent group only if all disks are enhanced SSDs (ESSDs).', example='true'),
      timeoutInSeconds?: long(name='TimeoutInSeconds', description='This parameter is required only if the value of the **AppConsistent** parameter is **true**. This parameter specifies the I/O freeze timeout period. Default value: 30. Unit: seconds.', example='30'),
    }(name='UdmDetail', description='The details of ECS instance backup.'),
  }(name='AdvancedOptions', description='Advanced options.'),
  dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='i-bp1************dtv'),
  disabled?: boolean(name='Disabled', description='Specifies whether to disable the backup policy for the data source.

*   true: disables the backup policy for the data source
*   false: enables the backup policy for the data source', example='true'),
  policyBindingDescription?: string(name='PolicyBindingDescription', description='The description of the association.', example='po-000************5xx-i-2ze************nw4'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************ky9'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model UpdatePolicyBindingShrinkRequest {
  advancedOptionsShrink?: string(name='AdvancedOptions', description='Advanced options.'),
  dataSourceId?: string(name='DataSourceId', description='The ID of the data source.', example='i-bp1************dtv'),
  disabled?: boolean(name='Disabled', description='Specifies whether to disable the backup policy for the data source.

*   true: disables the backup policy for the data source
*   false: enables the backup policy for the data source', example='true'),
  policyBindingDescription?: string(name='PolicyBindingDescription', description='The description of the association.', example='po-000************5xx-i-2ze************nw4'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************ky9'),
  sourceType?: string(name='SourceType', description='The type of the data source. Valid values:

*   **UDM_ECS**: ECS instance backup', example='UDM_ECS'),
}

model UpdatePolicyBindingResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='B6F24C46-54B9-519B-9AB8-A8988D705E67'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdatePolicyBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePolicyBindingResponseBody(name='body'),
}

async function updatePolicyBindingWithOptions(tmpReq: UpdatePolicyBindingRequest, runtime: Util.RuntimeOptions): UpdatePolicyBindingResponse {
  Util.validateModel(tmpReq);
  var request = new UpdatePolicyBindingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.advancedOptions)) {
    request.advancedOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.advancedOptions, 'AdvancedOptions', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.advancedOptionsShrink)) {
    query['AdvancedOptions'] = request.advancedOptionsShrink;
  }
  if (!Util.isUnset(request.disabled)) {
    query['Disabled'] = request.disabled;
  }
  if (!Util.isUnset(request.policyBindingDescription)) {
    query['PolicyBindingDescription'] = request.policyBindingDescription;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePolicyBinding',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePolicyBinding(request: UpdatePolicyBindingRequest): UpdatePolicyBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePolicyBindingWithOptions(request, runtime);
}

model UpdatePolicyV2Request {
  policyDescription?: string(name='PolicyDescription', description='The description of the backup policy.', example='Data is backed up at 10:00:00 every day and replicated to the China (Shanghai) region for geo-redundancy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************viy'),
  policyName?: string(name='PolicyName', description='The name of the backup policy.', example='Daily Local Backup + Remote Backup'),
  rules?: [ 
    {
      archiveDays?: long(name='ArchiveDays', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION**. This parameter specifies the time when data is dumped from a backup vault to an archive vault. Unit: days.', example='90'),
      backupType?: string(name='BackupType', description='This parameter is required only if you set the **RuleType** parameter to **BACKUP**. This parameter specifies the backup type. Valid value: **COMPLETE**, which indicates full backup.', example='COMPLETE'),
      coldArchiveDays?: long(name='ColdArchiveDays', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION**. This parameter specifies the time when data is dumped from a backup vault to a cold archive vault. Unit: days.', example='365'),
      replicationRegionId?: string(name='ReplicationRegionId', description='This parameter is required only if you set the **RuleType** parameter to **REPLICATION**. This parameter specifies the ID of the destination region.', example='cn-shanghai'),
      retention?: long(name='Retention', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION** or **REPLICATION**.

*   If you set the **RuleType** parameter to **TRANSITION**, this parameter specifies the retention period of the backup data. Minimum value: 1. Unit: days.
*   If you set the **RuleType** parameter to **REPLICATION**, this parameter specifies the retention period of remote backups. Minimum value: 1. Unit: days.', example='7'),
      retentionRules?: [ 
        {
          advancedRetentionType?: string(name='AdvancedRetentionType', description='The type of the special retention rule. Valid values:

*   **WEEKLY**: retains weekly backups
*   **MONTHLY**: retains monthly backups
*   **YEARLY**: retains yearly backups', example='YEARLY'),
          retention?: long(name='Retention', description='The retention period of the backup data. Minimum value: 1. Unit: days.', example='365'),
          whichSnapshot?: long(name='WhichSnapshot', description='Specifies which backup is retained based on the special retention rule. Only the first backup can be retained.', example='1'),
        }
      ](name='RetentionRules', description='This parameter is required only if you set the **RuleType** parameter to **TRANSITION**. This parameter specifies the special retention rules.'),
      ruleId?: string(name='RuleId', description='The ID of the rule.', example='rule-000************rof'),
      ruleType?: string(name='RuleType', description='The type of the rule. Each backup policy must have at least one rule of the **BACKUP** type and only one rule of the **TRANSITION** type.

*   **BACKUP**: backup rule
*   **TRANSITION**: lifecycle rule
*   **REPLICATION**: replication rule', example='BACKUP'),
      schedule?: string(name='Schedule', description='This parameter is required only if you set the **RuleType** parameter to **BACKUP**. This parameter specifies the backup schedule settings. Format: `I|{startTime}|{interval}`. The system runs the first backup job at a point in time that is specified in the {startTime} parameter and the subsequent backup jobs at an interval that is specified in the {interval} parameter. The system does not run a backup job before the specified point in time. Each backup job, except the first one, starts only after the previous backup job is completed. For example, `I|1631685600|P1D` specifies that the system runs the first backup job at 14:00:00 on September 15, 2021 and the subsequent backup jobs once a day.

*   startTime: the time at which the system starts to run a backup job. The time must follow the UNIX time format. Unit: seconds.
*   interval: the interval at which the system runs a backup job. The interval must follow the ISO 8601 standard. For example, PT1H specifies an interval of one hour. P1D specifies an interval of one day.', example='I|1648647166|P1D'),
    }
  ](name='Rules', description='The rules in the backup policy.'),
}

model UpdatePolicyV2ShrinkRequest {
  policyDescription?: string(name='PolicyDescription', description='The description of the backup policy.', example='Data is backed up at 10:00:00 every day and replicated to the China (Shanghai) region for geo-redundancy.'),
  policyId?: string(name='PolicyId', description='The ID of the backup policy.', example='po-000************viy'),
  policyName?: string(name='PolicyName', description='The name of the backup policy.', example='Daily Local Backup + Remote Backup'),
  rulesShrink?: string(name='Rules', description='The rules in the backup policy.'),
}

model UpdatePolicyV2ResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
}

model UpdatePolicyV2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePolicyV2ResponseBody(name='body'),
}

/**
  * If you modify a backup policy, the modification takes effect on all data sources that are bound to the backup policy. Proceed with caution.
  *
  * @param tmpReq UpdatePolicyV2Request
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpdatePolicyV2Response
 */
async function updatePolicyV2WithOptions(tmpReq: UpdatePolicyV2Request, runtime: Util.RuntimeOptions): UpdatePolicyV2Response {
  Util.validateModel(tmpReq);
  var request = new UpdatePolicyV2ShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.rules)) {
    request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, 'Rules', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.policyDescription)) {
    body['PolicyDescription'] = request.policyDescription;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.rulesShrink)) {
    body['Rules'] = request.rulesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePolicyV2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * If you modify a backup policy, the modification takes effect on all data sources that are bound to the backup policy. Proceed with caution.
  *
  * @param request UpdatePolicyV2Request
  * @return UpdatePolicyV2Response
 */
async function updatePolicyV2(request: UpdatePolicyV2Request): UpdatePolicyV2Response {
  var runtime = new Util.RuntimeOptions{};
  return updatePolicyV2WithOptions(request, runtime);
}

model UpdateVaultRequest {
  description?: string(name='Description', description='The description of the backup vault. The description must be 0 to 255 characters in length.', example='vault description'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfm2fa2xeiebyy'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-*********************'),
  vaultName?: string(name='VaultName', description='The name of the backup vault. The name must be 1 to 64 characters in length.', example='vaultname'),
}

model UpdateVaultResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: indicates that the request is successful.
*   false: indicates that the request fails.', example='true'),
}

model UpdateVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVaultResponseBody(name='body'),
}

async function updateVaultWithOptions(request: UpdateVaultRequest, runtime: Util.RuntimeOptions): UpdateVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVault(request: UpdateVaultRequest): UpdateVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVaultWithOptions(request, runtime);
}

model UpgradeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds', description='The IDs of ECS instances. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 100.', example='["i-0xi5wj******3j3bh2gj5"]'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIds?: map[string]any(name='InstanceIds', description='The IDs of backup clients. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 100.', example='["c-*********************"]'),
}

model UpgradeBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds', description='The IDs of ECS instances. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 100.', example='["i-0xi5wj******3j3bh2gj5"]'),
  crossAccountRoleName?: string(name='CrossAccountRoleName'),
  crossAccountType?: string(name='CrossAccountType'),
  crossAccountUserId?: long(name='CrossAccountUserId'),
  instanceIdsShrink?: string(name='InstanceIds', description='The IDs of backup clients. The sum of the number of backup client IDs and the number of ECS instance IDs cannot exceed 100.', example='["c-*********************"]'),
}

model UpgradeBackupClientsResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the request is successful.', example='200'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode', description='The error code that is returned. Valid values:

- If the value is empty, the request is successful.
- **InstanceNotExists**: The ECS instance does not exist.
- **InstanceNotRunning**: The ECS instance is not running.
- **CloudAssistNotRunningOnInstance**: Cloud Assistant is unavailable.', example='InstanceNotExists'),
      instanceId?: string(name='InstanceId', description='The ID of the ECS instance.', example='i-0xi5w***v3j3bh2gj5'),
      validInstance?: boolean(name='ValidInstance', description='Indicates whether a backup client can be installed on the ECS instance.

- true: A backup client can be installed on the ECS instance.
- false: A backup client cannot be installed on the ECS instance.', example='true'),
    }
  ](name='InstanceStatuses', description='The status of the ECS instance.

If the status of an ECS instance cannot meet the requirements to install a backup client and the value of the InstanceIds parameter is greater than 1, an error message is returned based on the value of this parameter.'),
  message?: string(name='Message', description='The message that is returned. If the request is successful, a value of successful is returned. If the request fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='473469C7-AA6F-4DC5-B3DB-A3DC0DE3C83E'),
  success?: boolean(name='Success', description='Indicates whether the request is successful. Valid values:

*   true: The request is successful.
*   false: The request failed.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous task. You can call the DescribeTask operation to query the execution result of the asynchronous task.', example='t-*********************'),
}

model UpgradeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeBackupClientsResponseBody(name='body'),
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to upgrade a backup client that is installed on an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes.
  *
  * @param tmpReq UpgradeBackupClientsRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeBackupClientsResponse
 */
async function upgradeBackupClientsWithOptions(tmpReq: UpgradeBackupClientsRequest, runtime: Util.RuntimeOptions): UpgradeBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new UpgradeBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.crossAccountRoleName)) {
    query['CrossAccountRoleName'] = request.crossAccountRoleName;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossAccountUserId)) {
    query['CrossAccountUserId'] = request.crossAccountUserId;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * *   This operation creates an asynchronous task at the backend and calls Cloud Assistant to upgrade a backup client that is installed on an ECS instance.
  * *   You can call the DescribeTask operation to query the execution result of an asynchronous task.
  * *   The timeout period of an asynchronous task is 15 minutes.
  *
  * @param request UpgradeBackupClientsRequest
  * @return UpgradeBackupClientsResponse
 */
async function upgradeBackupClients(request: UpgradeBackupClientsRequest): UpgradeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeBackupClientsWithOptions(request, runtime);
}

model UpgradeClientRequest {
  clientId?: string(name='ClientId', description='The ID of the backup client.', example='c-000boklw******63a9'),
  resourceGroupId?: string(name='ResourceGroupId', description='The ID of the resource group.', example='rg-acfmy6uja5wyc2i'),
  vaultId?: string(name='VaultId', description='The ID of the backup vault.', example='v-000djw8ci******3ic'),
}

model UpgradeClientResponseBody = {
  code?: string(name='Code', description='The HTTP status code. The status code 200 indicates that the call is successful.', example='200'),
  message?: string(name='Message', description='The message that is returned. If the call is successful, "successful" is returned. If the call fails, an error message is returned.', example='successful'),
  requestId?: string(name='RequestId', description='The ID of the request.', example='22D97921-16BD-547C-B175-1DC25B1DCD73'),
  success?: boolean(name='Success', description='Indicates whether the call is successful. Valid values:

*   true: The call is successful.
*   false: The call fails.', example='true'),
  taskId?: string(name='TaskId', description='The ID of the asynchronous job. You can call the DescribeTask operation to query the execution result of the asynchronous job.', example='t-000i97jujk0z58a2ignf'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeClientResponseBody(name='body'),
}

/**
  * You can call this operation to upgrade a backup client to the latest version. After the backup client is upgraded, the version of the backup client cannot be rolled back.
  *
  * @param request UpgradeClientRequest
  * @param runtime runtime options for this request RuntimeOptions
  * @return UpgradeClientResponse
 */
async function upgradeClientWithOptions(request: UpgradeClientRequest, runtime: Util.RuntimeOptions): UpgradeClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

/**
  * You can call this operation to upgrade a backup client to the latest version. After the backup client is upgraded, the version of the backup client cannot be rolled back.
  *
  * @param request UpgradeClientRequest
  * @return UpgradeClientResponse
 */
async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClientWithOptions(request, runtime);
}

