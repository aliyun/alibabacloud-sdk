/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  @endpointMap = {
    ap-northeast-2-pop = 'hbr.aliyuncs.com',
    cn-beijing-finance-1 = 'hbr.aliyuncs.com',
    cn-beijing-finance-pop = 'hbr.aliyuncs.com',
    cn-beijing-gov-1 = 'hbr.aliyuncs.com',
    cn-beijing-nu16-b01 = 'hbr.aliyuncs.com',
    cn-edge-1 = 'hbr.aliyuncs.com',
    cn-fujian = 'hbr.aliyuncs.com',
    cn-haidian-cm12-c01 = 'hbr.aliyuncs.com',
    cn-hangzhou-bj-b01 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-prod-1 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-1 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-2 = 'hbr.aliyuncs.com',
    cn-hangzhou-internal-test-3 = 'hbr.aliyuncs.com',
    cn-hangzhou-test-306 = 'hbr.aliyuncs.com',
    cn-hongkong-finance-pop = 'hbr.aliyuncs.com',
    cn-huhehaote-nebula-1 = 'hbr.aliyuncs.com',
    cn-qingdao-nebula = 'hbr.aliyuncs.com',
    cn-shanghai-et15-b01 = 'hbr.aliyuncs.com',
    cn-shanghai-et2-b01 = 'hbr.aliyuncs.com',
    cn-shanghai-inner = 'hbr.aliyuncs.com',
    cn-shanghai-internal-test-1 = 'hbr.aliyuncs.com',
    cn-shenzhen-inner = 'hbr.aliyuncs.com',
    cn-shenzhen-st4-d01 = 'hbr.aliyuncs.com',
    cn-shenzhen-su18-b01 = 'hbr.aliyuncs.com',
    cn-wuhan = 'hbr.aliyuncs.com',
    cn-wulanchabu = 'hbr.aliyuncs.com',
    cn-yushanfang = 'hbr.aliyuncs.com',
    cn-zhangbei = 'hbr.aliyuncs.com',
    cn-zhangbei-na61-b01 = 'hbr.aliyuncs.com',
    cn-zhangjiakou-na62-a01 = 'hbr.aliyuncs.com',
    cn-zhengzhou-nebula-1 = 'hbr.aliyuncs.com',
    eu-west-1-oxs = 'hbr.aliyuncs.com',
    rus-west-1-pop = 'hbr.aliyuncs.com',
  };

  checkConfig(config);
  @endpoint = getEndpoint('hbr', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model OtsDetail {
  tableNames?: [ string ](name='TableNames', description='OTS table name list'),
}

model OtsTableRestoreDetail {
  batchChannelCount?: int32(name='BatchChannelCount', description='Concurrent processing channel count for each restore task'),
  indexNameSuffix?: string(name='IndexNameSuffix', description='Specify a suffix to restored index name'),
  overwriteExisting?: boolean(name='OverwriteExisting', description='Overwrite existing table or not'),
  reGenerateAutoIncrementPK?: boolean(name='ReGenerateAutoIncrementPK', description='Re-generate auto incrmental primary key or not'),
  restoreIndex?: boolean(name='RestoreIndex', description='Restore index or not'),
  restoreSearchIndex?: boolean(name='RestoreSearchIndex', description='Restore search index or not'),
  searchIndexNameSuffix?: string(name='SearchIndexNameSuffix', description='Specify a suffix to restored search index name'),
}

model Rule {
  backupType?: string(name='BackupType', description='backup type'),
  destinationRegionId?: string(name='DestinationRegionId', description='copy target region id'),
  destinationRetention?: long(name='DestinationRetention', description='retention for remote replication'),
  disabled?: boolean(name='Disabled', description='disable the rule or not'),
  doCopy?: boolean(name='DoCopy', description='copy to other region'),
  retention?: long(name='Retention', description='retention of backup'),
  ruleName?: string(name='RuleName', description='rule name'),
  schedule?: string(name='Schedule', description='schedule setting'),
}

model AddContainerClusterRequest {
  clusterType?: string(name='ClusterType'),
  description?: string(name='Description'),
  identifier?: string(name='Identifier'),
  name?: string(name='Name'),
  networkType?: string(name='NetworkType'),
}

model AddContainerClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  token?: string(name='Token'),
}

model AddContainerClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddContainerClusterResponseBody(name='body'),
}

async function addContainerClusterWithOptions(request: AddContainerClusterRequest, runtime: Util.RuntimeOptions): AddContainerClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterType)) {
    query['ClusterType'] = request.clusterType;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.identifier)) {
    query['Identifier'] = request.identifier;
  }
  if (!Util.isUnset(request.name)) {
    query['Name'] = request.name;
  }
  if (!Util.isUnset(request.networkType)) {
    query['NetworkType'] = request.networkType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddContainerCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addContainerCluster(request: AddContainerClusterRequest): AddContainerClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addContainerClusterWithOptions(request, runtime);
}

model AddObClusterRequest {
  clientId?: string(name='ClientId'),
  clusterName?: string(name='ClusterName'),
  description?: string(name='Description'),
  host?: string(name='Host'),
  password?: string(name='Password'),
  port?: string(name='Port'),
  username?: string(name='Username'),
}

model AddObClusterResponseBody = {
  clusterId?: string(name='ClusterId'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model AddObClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AddObClusterResponseBody(name='body'),
}

async function addObClusterWithOptions(request: AddObClusterRequest, runtime: Util.RuntimeOptions): AddObClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clusterName)) {
    query['ClusterName'] = request.clusterName;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.port)) {
    query['Port'] = request.port;
  }
  if (!Util.isUnset(request.username)) {
    query['Username'] = request.username;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'AddObCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function addObCluster(request: AddObClusterRequest): AddObClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return addObClusterWithOptions(request, runtime);
}

model CancelBackupJobRequest {
  jobId?: string(name='JobId'),
  vaultId?: string(name='VaultId'),
}

model CancelBackupJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelBackupJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelBackupJobResponseBody(name='body'),
}

async function cancelBackupJobWithOptions(request: CancelBackupJobRequest, runtime: Util.RuntimeOptions): CancelBackupJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelBackupJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelBackupJob(request: CancelBackupJobRequest): CancelBackupJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelBackupJobWithOptions(request, runtime);
}

model CancelRestoreJobRequest {
  restoreId?: string(name='RestoreId'),
  vaultId?: string(name='VaultId'),
}

model CancelRestoreJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CancelRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CancelRestoreJobResponseBody(name='body'),
}

async function cancelRestoreJobWithOptions(request: CancelRestoreJobRequest, runtime: Util.RuntimeOptions): CancelRestoreJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.restoreId)) {
    query['RestoreId'] = request.restoreId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CancelRestoreJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function cancelRestoreJob(request: CancelRestoreJobRequest): CancelRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return cancelRestoreJobWithOptions(request, runtime);
}

model ChangeResourceGroupRequest {
  newResourceGroupId?: string(name='NewResourceGroupId'),
  resourceId?: string(name='ResourceId'),
  resourceType?: string(name='ResourceType'),
}

model ChangeResourceGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ChangeResourceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ChangeResourceGroupResponseBody(name='body'),
}

async function changeResourceGroupWithOptions(request: ChangeResourceGroupRequest, runtime: Util.RuntimeOptions): ChangeResourceGroupResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.newResourceGroupId)) {
    body['NewResourceGroupId'] = request.newResourceGroupId;
  }
  if (!Util.isUnset(request.resourceId)) {
    body['ResourceId'] = request.resourceId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ChangeResourceGroup',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function changeResourceGroup(request: ChangeResourceGroupRequest): ChangeResourceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return changeResourceGroupWithOptions(request, runtime);
}

model CreateBackupJobRequest {
  backupType?: string(name='BackupType'),
  clusterId?: string(name='ClusterId'),
  containerClusterId?: string(name='ContainerClusterId'),
  containerResources?: string(name='ContainerResources'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  jobName?: string(name='JobName'),
  options?: string(name='Options'),
  retention?: long(name='Retention'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
  vaultId?: string(name='VaultId'),
}

model CreateBackupJobResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBackupJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupJobResponseBody(name='body'),
}

async function createBackupJobWithOptions(request: CreateBackupJobRequest, runtime: Util.RuntimeOptions): CreateBackupJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.containerClusterId)) {
    query['ContainerClusterId'] = request.containerClusterId;
  }
  if (!Util.isUnset(request.containerResources)) {
    query['ContainerResources'] = request.containerResources;
  }
  if (!Util.isUnset(request.exclude)) {
    query['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    query['Include'] = request.include;
  }
  if (!Util.isUnset(request.jobName)) {
    query['JobName'] = request.jobName;
  }
  if (!Util.isUnset(request.options)) {
    query['Options'] = request.options;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.speedLimit)) {
    query['SpeedLimit'] = request.speedLimit;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupJob(request: CreateBackupJobRequest): CreateBackupJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupJobWithOptions(request, runtime);
}

model CreateBackupPlanRequest {
  backupType?: string(name='BackupType'),
  bucket?: string(name='Bucket'),
  createTime?: long(name='CreateTime'),
  crossAccountType?: string(name='CrossAccountType'),
  crossOwnerId?: long(name='CrossOwnerId'),
  crossRamRole?: string(name='CrossRamRole'),
  detail?: map[string]any(name='Detail'),
  exclude?: string(name='Exclude'),
  fileSystemId?: string(name='FileSystemId'),
  include?: string(name='Include'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  options?: string(name='Options'),
  otsDetail?: OtsDetail(name='OtsDetail'),
  path?: [ string ](name='Path'),
  planName?: string(name='PlanName'),
  prefix?: string(name='Prefix'),
  retention?: long(name='Retention'),
  rule?: [ 
    {
      backupType?: string(name='BackupType'),
      destinationRegionId?: string(name='DestinationRegionId'),
      destinationRetention?: long(name='DestinationRetention'),
      disabled?: boolean(name='Disabled'),
      doCopy?: boolean(name='DoCopy'),
      retention?: long(name='Retention'),
      ruleName?: string(name='RuleName'),
      schedule?: string(name='Schedule'),
    }
  ](name='Rule'),
  schedule?: string(name='Schedule'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
  udmRegionId?: string(name='UdmRegionId'),
  vaultId?: string(name='VaultId'),
}

model CreateBackupPlanShrinkRequest {
  backupType?: string(name='BackupType'),
  bucket?: string(name='Bucket'),
  createTime?: long(name='CreateTime'),
  crossAccountType?: string(name='CrossAccountType'),
  crossOwnerId?: long(name='CrossOwnerId'),
  crossRamRole?: string(name='CrossRamRole'),
  detailShrink?: string(name='Detail'),
  exclude?: string(name='Exclude'),
  fileSystemId?: string(name='FileSystemId'),
  include?: string(name='Include'),
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
  options?: string(name='Options'),
  otsDetailShrink?: string(name='OtsDetail'),
  path?: [ string ](name='Path'),
  planName?: string(name='PlanName'),
  prefix?: string(name='Prefix'),
  retention?: long(name='Retention'),
  rule?: [ 
    {
      backupType?: string(name='BackupType'),
      destinationRegionId?: string(name='DestinationRegionId'),
      destinationRetention?: long(name='DestinationRetention'),
      disabled?: boolean(name='Disabled'),
      doCopy?: boolean(name='DoCopy'),
      retention?: long(name='Retention'),
      ruleName?: string(name='RuleName'),
      schedule?: string(name='Schedule'),
    }
  ](name='Rule'),
  schedule?: string(name='Schedule'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
  udmRegionId?: string(name='UdmRegionId'),
  vaultId?: string(name='VaultId'),
}

model CreateBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  planId?: string(name='PlanId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateBackupPlanResponseBody(name='body'),
}

async function createBackupPlanWithOptions(tmpReq: CreateBackupPlanRequest, runtime: Util.RuntimeOptions): CreateBackupPlanResponse {
  Util.validateModel(tmpReq);
  var request = new CreateBackupPlanShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detail)) {
    request.detailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detail, 'Detail', 'json');
  }
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.bucket)) {
    query['Bucket'] = request.bucket;
  }
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossOwnerId)) {
    query['CrossOwnerId'] = request.crossOwnerId;
  }
  if (!Util.isUnset(request.crossRamRole)) {
    query['CrossRamRole'] = request.crossRamRole;
  }
  if (!Util.isUnset(request.detailShrink)) {
    query['Detail'] = request.detailShrink;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.path)) {
    body['Path'] = request.path;
  }
  if (!Util.isUnset(request.rule)) {
    body['Rule'] = request.rule;
  }
  if (!Util.isUnset(request.speedLimit)) {
    body['SpeedLimit'] = request.speedLimit;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createBackupPlan(request: CreateBackupPlanRequest): CreateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createBackupPlanWithOptions(request, runtime);
}

model CreateClientsRequest {
  alertSetting?: string(name='AlertSetting'),
  clientInfo?: string(name='ClientInfo'),
  resourceGroupId?: string(name='ResourceGroupId'),
  useHttps?: boolean(name='UseHttps'),
  vaultId?: string(name='VaultId'),
}

model CreateClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: {
    instanceStatus?: [ 
    {
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatus')
  }(name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model CreateClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateClientsResponseBody(name='body'),
}

async function createClientsWithOptions(request: CreateClientsRequest, runtime: Util.RuntimeOptions): CreateClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.clientInfo)) {
    query['ClientInfo'] = request.clientInfo;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useHttps)) {
    query['UseHttps'] = request.useHttps;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createClients(request: CreateClientsRequest): CreateClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createClientsWithOptions(request, runtime);
}

model CreateHanaBackupPlanRequest {
  backupPrefix?: string(name='BackupPrefix'),
  backupType?: string(name='BackupType'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  planName?: string(name='PlanName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  schedule?: string(name='Schedule'),
  vaultId?: string(name='VaultId'),
}

model CreateHanaBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  planId?: string(name='PlanId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaBackupPlanResponseBody(name='body'),
}

async function createHanaBackupPlanWithOptions(request: CreateHanaBackupPlanRequest, runtime: Util.RuntimeOptions): CreateHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.backupType)) {
    query['BackupType'] = request.backupType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHanaBackupPlan(request: CreateHanaBackupPlanRequest): CreateHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaBackupPlanWithOptions(request, runtime);
}

model CreateHanaInstanceRequest {
  alertSetting?: string(name='AlertSetting'),
  ecsInstanceId?: string(name='EcsInstanceId'),
  hanaName?: string(name='HanaName'),
  host?: string(name='Host'),
  instanceNumber?: int32(name='InstanceNumber'),
  password?: string(name='Password'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sid?: string(name='Sid'),
  useSsl?: boolean(name='UseSsl'),
  userName?: string(name='UserName'),
  validateCertificate?: boolean(name='ValidateCertificate'),
  vaultId?: string(name='VaultId'),
}

model CreateHanaInstanceResponseBody = {
  clusterId?: string(name='ClusterId'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaInstanceResponseBody(name='body'),
}

async function createHanaInstanceWithOptions(request: CreateHanaInstanceRequest, runtime: Util.RuntimeOptions): CreateHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.ecsInstanceId)) {
    query['EcsInstanceId'] = request.ecsInstanceId;
  }
  if (!Util.isUnset(request.hanaName)) {
    query['HanaName'] = request.hanaName;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceNumber)) {
    query['InstanceNumber'] = request.instanceNumber;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.useSsl)) {
    query['UseSsl'] = request.useSsl;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.validateCertificate)) {
    query['ValidateCertificate'] = request.validateCertificate;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHanaInstance(request: CreateHanaInstanceRequest): CreateHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaInstanceWithOptions(request, runtime);
}

model CreateHanaRestoreRequest {
  backupId?: long(name='BackupId'),
  backupPrefix?: string(name='BackupPrefix'),
  checkAccess?: boolean(name='CheckAccess'),
  clearLog?: boolean(name='ClearLog'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  logPosition?: long(name='LogPosition'),
  mode?: string(name='Mode'),
  recoveryPointInTime?: long(name='RecoveryPointInTime'),
  sidAdmin?: string(name='SidAdmin'),
  source?: string(name='Source'),
  sourceClusterId?: string(name='SourceClusterId'),
  systemCopy?: boolean(name='SystemCopy'),
  useCatalog?: boolean(name='UseCatalog'),
  useDelta?: boolean(name='UseDelta'),
  volumeId?: int32(name='VolumeId'),
}

model CreateHanaRestoreResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  restoreId?: string(name='RestoreId'),
  success?: boolean(name='Success'),
}

model CreateHanaRestoreResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateHanaRestoreResponseBody(name='body'),
}

async function createHanaRestoreWithOptions(request: CreateHanaRestoreRequest, runtime: Util.RuntimeOptions): CreateHanaRestoreResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.checkAccess)) {
    query['CheckAccess'] = request.checkAccess;
  }
  if (!Util.isUnset(request.clearLog)) {
    query['ClearLog'] = request.clearLog;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.logPosition)) {
    query['LogPosition'] = request.logPosition;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.recoveryPointInTime)) {
    query['RecoveryPointInTime'] = request.recoveryPointInTime;
  }
  if (!Util.isUnset(request.sidAdmin)) {
    query['SidAdmin'] = request.sidAdmin;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceClusterId)) {
    query['SourceClusterId'] = request.sourceClusterId;
  }
  if (!Util.isUnset(request.systemCopy)) {
    query['SystemCopy'] = request.systemCopy;
  }
  if (!Util.isUnset(request.useCatalog)) {
    query['UseCatalog'] = request.useCatalog;
  }
  if (!Util.isUnset(request.useDelta)) {
    query['UseDelta'] = request.useDelta;
  }
  if (!Util.isUnset(request.volumeId)) {
    query['VolumeId'] = request.volumeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateHanaRestore',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createHanaRestore(request: CreateHanaRestoreRequest): CreateHanaRestoreResponse {
  var runtime = new Util.RuntimeOptions{};
  return createHanaRestoreWithOptions(request, runtime);
}

model CreatePolicy2Request {
  policyDescription?: string(name='PolicyDescription'),
  policyName?: string(name='PolicyName'),
  rules?: [ 
    {
      archiveDays?: long(name='ArchiveDays'),
      archiveVaultId?: string(name='ArchiveVaultId', description='Transition'),
      backupType?: string(name='BackupType', description='Backup Rule (COMPLETE: Complete backup type, INCREMENTAL: Incremental backup type, DIFFERENTIAL: Differential backup type, LOG: Transaction log backup type, INDEX: 不备份数据，只对元数据建立索引, ARCHIVE: 归档, ARCHIVE_BY_SEARCH: 根据搜索结果进行归档)'),
      coldArchiveDays?: long(name='ColdArchiveDays'),
      continuous?: boolean(name='Continuous'),
      cycles?: long(name='Cycles'),
      replicationRegionId?: string(name='ReplicationRegionId', description='Replication'),
      replicationVaultId?: string(name='ReplicationVaultId'),
      retention?: long(name='Retention', description='Expiration'),
      retentionRules?: [ 
        {
          retention?: long(name='Retention'),
          scheduleType?: string(name='ScheduleType'),
          whichSnapshot?: long(name='WhichSnapshot'),
        }
      ](name='RetentionRules'),
      ruleType?: string(name='RuleType', description='TRANSITION: 过渡类规则, BACKUP: 定时类规则, REPLICATION: 镜像类规则'),
      schedule?: string(name='Schedule'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Rules'),
}

model CreatePolicy2ShrinkRequest {
  policyDescription?: string(name='PolicyDescription'),
  policyName?: string(name='PolicyName'),
  rulesShrink?: string(name='Rules'),
}

model CreatePolicy2ResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  policyId?: string(name='PolicyId'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePolicy2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicy2ResponseBody(name='body'),
}

async function createPolicy2WithOptions(tmpReq: CreatePolicy2Request, runtime: Util.RuntimeOptions): CreatePolicy2Response {
  Util.validateModel(tmpReq);
  var request = new CreatePolicy2ShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.rules)) {
    request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, 'Rules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.policyDescription)) {
    body['PolicyDescription'] = request.policyDescription;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.rulesShrink)) {
    body['Rules'] = request.rulesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicy2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPolicy2(request: CreatePolicy2Request): CreatePolicy2Response {
  var runtime = new Util.RuntimeOptions{};
  return createPolicy2WithOptions(request, runtime);
}

model CreatePolicyBindingsRequest {
  policyBindingList?: [ 
    {
      advancedOptions?: {
        udmDetail?: {
          appConsistent?: boolean(name='AppConsistent'),
          diskIdList?: [ string ](name='DiskIdList'),
          enableFsFreeze?: boolean(name='EnableFsFreeze'),
          enableWriters?: boolean(name='EnableWriters'),
          excludeDiskIdList?: [ string ](name='ExcludeDiskIdList'),
          postScriptPath?: string(name='PostScriptPath'),
          preScriptPath?: string(name='PreScriptPath'),
          ramRoleName?: string(name='RamRoleName'),
          snapshotGroup?: boolean(name='SnapshotGroup'),
          timeoutInSeconds?: long(name='TimeoutInSeconds'),
        }(name='UdmDetail'),
      }(name='AdvancedOptions'),
      dataSourceId?: string(name='DataSourceId'),
      disabled?: string(name='Disabled'),
      exclude?: string(name='Exclude'),
      include?: string(name='Include'),
      policyBindingDescription?: string(name='PolicyBindingDescription'),
      source?: string(name='Source'),
      sourceType?: string(name='SourceType'),
      speedLimit?: string(name='SpeedLimit'),
    }
  ](name='PolicyBindingList'),
  policyId?: string(name='PolicyId'),
}

model CreatePolicyBindingsShrinkRequest {
  policyBindingListShrink?: string(name='PolicyBindingList'),
  policyId?: string(name='PolicyId'),
}

model CreatePolicyBindingsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreatePolicyBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePolicyBindingsResponseBody(name='body'),
}

async function createPolicyBindingsWithOptions(tmpReq: CreatePolicyBindingsRequest, runtime: Util.RuntimeOptions): CreatePolicyBindingsResponse {
  Util.validateModel(tmpReq);
  var request = new CreatePolicyBindingsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.policyBindingList)) {
    request.policyBindingListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.policyBindingList, 'PolicyBindingList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.policyBindingListShrink)) {
    query['PolicyBindingList'] = request.policyBindingListShrink;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePolicyBindings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPolicyBindings(request: CreatePolicyBindingsRequest): CreatePolicyBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPolicyBindingsWithOptions(request, runtime);
}

model CreateReplicationVaultRequest {
  description?: string(name='Description'),
  redundancyType?: string(name='RedundancyType'),
  replicationSourceRegionId?: string(name='ReplicationSourceRegionId'),
  replicationSourceVaultId?: string(name='ReplicationSourceVaultId'),
  vaultName?: string(name='VaultName'),
  vaultRegionId?: string(name='VaultRegionId'),
  vaultStorageClass?: string(name='VaultStorageClass'),
}

model CreateReplicationVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  vaultId?: string(name='VaultId'),
}

model CreateReplicationVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateReplicationVaultResponseBody(name='body'),
}

async function createReplicationVaultWithOptions(request: CreateReplicationVaultRequest, runtime: Util.RuntimeOptions): CreateReplicationVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.redundancyType)) {
    query['RedundancyType'] = request.redundancyType;
  }
  if (!Util.isUnset(request.replicationSourceRegionId)) {
    query['ReplicationSourceRegionId'] = request.replicationSourceRegionId;
  }
  if (!Util.isUnset(request.replicationSourceVaultId)) {
    query['ReplicationSourceVaultId'] = request.replicationSourceVaultId;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultStorageClass)) {
    query['VaultStorageClass'] = request.vaultStorageClass;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateReplicationVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createReplicationVault(request: CreateReplicationVaultRequest): CreateReplicationVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return createReplicationVaultWithOptions(request, runtime);
}

model CreateRestoreJobRequest {
  crossAccountType?: string(name='CrossAccountType'),
  crossOwnerId?: long(name='CrossOwnerId'),
  crossRamRole?: string(name='CrossRamRole'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  otsDetail?: OtsTableRestoreDetail(name='OtsDetail'),
  restoreType?: string(name='RestoreType'),
  snapshotHash?: string(name='SnapshotHash'),
  snapshotId?: string(name='SnapshotId'),
  sourceType?: string(name='SourceType'),
  targetBucket?: string(name='TargetBucket'),
  targetCreateTime?: long(name='TargetCreateTime'),
  targetFileSystemId?: string(name='TargetFileSystemId'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetInstanceName?: string(name='TargetInstanceName'),
  targetPath?: string(name='TargetPath'),
  targetPrefix?: string(name='TargetPrefix'),
  targetTableName?: string(name='TargetTableName'),
  targetTime?: long(name='TargetTime'),
  udmDetail?: map[string]any(name='UdmDetail'),
  vaultId?: string(name='VaultId'),
}

model CreateRestoreJobShrinkRequest {
  crossAccountType?: string(name='CrossAccountType'),
  crossOwnerId?: long(name='CrossOwnerId'),
  crossRamRole?: string(name='CrossRamRole'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  otsDetailShrink?: string(name='OtsDetail'),
  restoreType?: string(name='RestoreType'),
  snapshotHash?: string(name='SnapshotHash'),
  snapshotId?: string(name='SnapshotId'),
  sourceType?: string(name='SourceType'),
  targetBucket?: string(name='TargetBucket'),
  targetCreateTime?: long(name='TargetCreateTime'),
  targetFileSystemId?: string(name='TargetFileSystemId'),
  targetInstanceId?: string(name='TargetInstanceId'),
  targetInstanceName?: string(name='TargetInstanceName'),
  targetPath?: string(name='TargetPath'),
  targetPrefix?: string(name='TargetPrefix'),
  targetTableName?: string(name='TargetTableName'),
  targetTime?: long(name='TargetTime'),
  udmDetailShrink?: string(name='UdmDetail'),
  vaultId?: string(name='VaultId'),
}

model CreateRestoreJobResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  restoreId?: string(name='RestoreId'),
  success?: boolean(name='Success'),
}

model CreateRestoreJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRestoreJobResponseBody(name='body'),
}

async function createRestoreJobWithOptions(tmpReq: CreateRestoreJobRequest, runtime: Util.RuntimeOptions): CreateRestoreJobResponse {
  Util.validateModel(tmpReq);
  var request = new CreateRestoreJobShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  if (!Util.isUnset(tmpReq.udmDetail)) {
    request.udmDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.udmDetail, 'UdmDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.crossAccountType)) {
    query['CrossAccountType'] = request.crossAccountType;
  }
  if (!Util.isUnset(request.crossOwnerId)) {
    query['CrossOwnerId'] = request.crossOwnerId;
  }
  if (!Util.isUnset(request.crossRamRole)) {
    query['CrossRamRole'] = request.crossRamRole;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  if (!Util.isUnset(request.snapshotHash)) {
    query['SnapshotHash'] = request.snapshotHash;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.targetBucket)) {
    query['TargetBucket'] = request.targetBucket;
  }
  if (!Util.isUnset(request.targetCreateTime)) {
    query['TargetCreateTime'] = request.targetCreateTime;
  }
  if (!Util.isUnset(request.targetFileSystemId)) {
    query['TargetFileSystemId'] = request.targetFileSystemId;
  }
  if (!Util.isUnset(request.targetInstanceName)) {
    query['TargetInstanceName'] = request.targetInstanceName;
  }
  if (!Util.isUnset(request.targetPrefix)) {
    query['TargetPrefix'] = request.targetPrefix;
  }
  if (!Util.isUnset(request.targetTableName)) {
    query['TargetTableName'] = request.targetTableName;
  }
  if (!Util.isUnset(request.targetTime)) {
    query['TargetTime'] = request.targetTime;
  }
  if (!Util.isUnset(request.udmDetailShrink)) {
    query['UdmDetail'] = request.udmDetailShrink;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.targetInstanceId)) {
    body['TargetInstanceId'] = request.targetInstanceId;
  }
  if (!Util.isUnset(request.targetPath)) {
    body['TargetPath'] = request.targetPath;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRestoreJob',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRestoreJob(request: CreateRestoreJobRequest): CreateRestoreJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRestoreJobWithOptions(request, runtime);
}

model CreateUdmEcsInstanceGroupRequest {
  diskIdMap?: map[string]any(name='DiskIdMap'),
  excludeDiskIdMap?: map[string]any(name='ExcludeDiskIdMap'),
  instanceGroupName?: string(name='InstanceGroupName', description='required parameters'),
  instanceIds?: [ string ](name='InstanceIds', description='optional parameters'),
}

model CreateUdmEcsInstanceGroupShrinkRequest {
  diskIdMapShrink?: string(name='DiskIdMap'),
  excludeDiskIdMapShrink?: string(name='ExcludeDiskIdMap'),
  instanceGroupName?: string(name='InstanceGroupName', description='required parameters'),
  instanceIds?: [ string ](name='InstanceIds', description='optional parameters'),
}

model CreateUdmEcsInstanceGroupResponseBody = {
  code?: string(name='Code'),
  instanceGroupId?: string(name='InstanceGroupId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model CreateUdmEcsInstanceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateUdmEcsInstanceGroupResponseBody(name='body'),
}

async function createUdmEcsInstanceGroupWithOptions(tmpReq: CreateUdmEcsInstanceGroupRequest, runtime: Util.RuntimeOptions): CreateUdmEcsInstanceGroupResponse {
  Util.validateModel(tmpReq);
  var request = new CreateUdmEcsInstanceGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.diskIdMap)) {
    request.diskIdMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.diskIdMap, 'DiskIdMap', 'json');
  }
  if (!Util.isUnset(tmpReq.excludeDiskIdMap)) {
    request.excludeDiskIdMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.excludeDiskIdMap, 'ExcludeDiskIdMap', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.diskIdMapShrink)) {
    query['DiskIdMap'] = request.diskIdMapShrink;
  }
  if (!Util.isUnset(request.excludeDiskIdMapShrink)) {
    query['ExcludeDiskIdMap'] = request.excludeDiskIdMapShrink;
  }
  if (!Util.isUnset(request.instanceGroupName)) {
    query['InstanceGroupName'] = request.instanceGroupName;
  }
  if (!Util.isUnset(request.instanceIds)) {
    query['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateUdmEcsInstanceGroup',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createUdmEcsInstanceGroup(request: CreateUdmEcsInstanceGroupRequest): CreateUdmEcsInstanceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createUdmEcsInstanceGroupWithOptions(request, runtime);
}

model CreateVaultRequest {
  bucketName?: string(name='BucketName'),
  compressionAlgorithm?: string(name='CompressionAlgorithm'),
  description?: string(name='Description'),
  endpoint?: string(name='Endpoint'),
  redundancyType?: string(name='RedundancyType'),
  vaultAccessKeyId?: string(name='VaultAccessKeyId'),
  vaultAccessKeySecret?: string(name='VaultAccessKeySecret'),
  vaultName?: string(name='VaultName'),
  vaultRegionId?: string(name='VaultRegionId'),
  vaultStorageClass?: string(name='VaultStorageClass'),
  vaultType?: string(name='VaultType'),
}

model CreateVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
  vaultId?: string(name='VaultId'),
}

model CreateVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateVaultResponseBody(name='body'),
}

async function createVaultWithOptions(request: CreateVaultRequest, runtime: Util.RuntimeOptions): CreateVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.bucketName)) {
    query['BucketName'] = request.bucketName;
  }
  if (!Util.isUnset(request.compressionAlgorithm)) {
    query['CompressionAlgorithm'] = request.compressionAlgorithm;
  }
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.endpoint)) {
    query['Endpoint'] = request.endpoint;
  }
  if (!Util.isUnset(request.redundancyType)) {
    query['RedundancyType'] = request.redundancyType;
  }
  if (!Util.isUnset(request.vaultAccessKeyId)) {
    query['VaultAccessKeyId'] = request.vaultAccessKeyId;
  }
  if (!Util.isUnset(request.vaultAccessKeySecret)) {
    query['VaultAccessKeySecret'] = request.vaultAccessKeySecret;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultStorageClass)) {
    query['VaultStorageClass'] = request.vaultStorageClass;
  }
  if (!Util.isUnset(request.vaultType)) {
    query['VaultType'] = request.vaultType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'CreateVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createVault(request: CreateVaultRequest): CreateVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return createVaultWithOptions(request, runtime);
}

model DeleteBackupClientRequest {
  clientId?: string(name='ClientId'),
}

model DeleteBackupClientResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupClientResponseBody(name='body'),
}

async function deleteBackupClientWithOptions(request: DeleteBackupClientRequest, runtime: Util.RuntimeOptions): DeleteBackupClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupClient(request: DeleteBackupClientRequest): DeleteBackupClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupClientWithOptions(request, runtime);
}

model DeleteBackupClientResourceRequest {
  clientIds?: map[string]any(name='ClientIds'),
}

model DeleteBackupClientResourceShrinkRequest {
  clientIdsShrink?: string(name='ClientIds'),
}

model DeleteBackupClientResourceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupClientResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupClientResourceResponseBody(name='body'),
}

async function deleteBackupClientResourceWithOptions(tmpReq: DeleteBackupClientResourceRequest, runtime: Util.RuntimeOptions): DeleteBackupClientResourceResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteBackupClientResourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupClientResource',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupClientResource(request: DeleteBackupClientResourceRequest): DeleteBackupClientResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupClientResourceWithOptions(request, runtime);
}

model DeleteBackupPlanRequest {
  planId?: string(name='PlanId'),
  sourceType?: string(name='SourceType'),
  vaultId?: string(name='VaultId'),
}

model DeleteBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteBackupPlanResponseBody(name='body'),
}

async function deleteBackupPlanWithOptions(request: DeleteBackupPlanRequest, runtime: Util.RuntimeOptions): DeleteBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteBackupPlan(request: DeleteBackupPlanRequest): DeleteBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteBackupPlanWithOptions(request, runtime);
}

model DeleteCrossAccountRequest {
  crossOwnerId?: long(name='CrossOwnerId'),
  crossRamRole?: string(name='CrossRamRole'),
}

model DeleteCrossAccountResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteCrossAccountResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteCrossAccountResponseBody(name='body'),
}

async function deleteCrossAccountWithOptions(request: DeleteCrossAccountRequest, runtime: Util.RuntimeOptions): DeleteCrossAccountResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.crossOwnerId)) {
    query['CrossOwnerId'] = request.crossOwnerId;
  }
  if (!Util.isUnset(request.crossRamRole)) {
    query['CrossRamRole'] = request.crossRamRole;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteCrossAccount',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteCrossAccount(request: DeleteCrossAccountRequest): DeleteCrossAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteCrossAccountWithOptions(request, runtime);
}

model DeleteHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId'),
  planId?: string(name='PlanId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model DeleteHanaBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHanaBackupPlanResponseBody(name='body'),
}

async function deleteHanaBackupPlanWithOptions(request: DeleteHanaBackupPlanRequest, runtime: Util.RuntimeOptions): DeleteHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHanaBackupPlan(request: DeleteHanaBackupPlanRequest): DeleteHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHanaBackupPlanWithOptions(request, runtime);
}

model DeleteHanaInstanceRequest {
  clusterId?: string(name='ClusterId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sid?: string(name='Sid'),
  vaultId?: string(name='VaultId'),
}

model DeleteHanaInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteHanaInstanceResponseBody(name='body'),
}

async function deleteHanaInstanceWithOptions(request: DeleteHanaInstanceRequest, runtime: Util.RuntimeOptions): DeleteHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sid)) {
    query['Sid'] = request.sid;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteHanaInstance(request: DeleteHanaInstanceRequest): DeleteHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteHanaInstanceWithOptions(request, runtime);
}

model DeleteObClusterRequest {
  clusterId?: string(name='ClusterId'),
}

model DeleteObClusterResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteObClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteObClusterResponseBody(name='body'),
}

async function deleteObClusterWithOptions(request: DeleteObClusterRequest, runtime: Util.RuntimeOptions): DeleteObClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteObCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteObCluster(request: DeleteObClusterRequest): DeleteObClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteObClusterWithOptions(request, runtime);
}

model DeletePolicy2Request {
  policyId?: string(name='PolicyId'),
}

model DeletePolicy2ResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePolicy2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicy2ResponseBody(name='body'),
}

async function deletePolicy2WithOptions(request: DeletePolicy2Request, runtime: Util.RuntimeOptions): DeletePolicy2Response {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicy2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicy2(request: DeletePolicy2Request): DeletePolicy2Response {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicy2WithOptions(request, runtime);
}

model DeletePolicyBindingRequest {
  dataSourceIds?: [ string ](name='DataSourceIds'),
  policyId?: string(name='PolicyId'),
  sourceType?: string(name='SourceType'),
}

model DeletePolicyBindingShrinkRequest {
  dataSourceIdsShrink?: string(name='DataSourceIds'),
  policyId?: string(name='PolicyId'),
  sourceType?: string(name='SourceType'),
}

model DeletePolicyBindingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeletePolicyBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePolicyBindingResponseBody(name='body'),
}

async function deletePolicyBindingWithOptions(tmpReq: DeletePolicyBindingRequest, runtime: Util.RuntimeOptions): DeletePolicyBindingResponse {
  Util.validateModel(tmpReq);
  var request = new DeletePolicyBindingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceIds)) {
    request.dataSourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceIds, 'DataSourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataSourceIdsShrink)) {
    body['DataSourceIds'] = request.dataSourceIdsShrink;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePolicyBinding',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePolicyBinding(request: DeletePolicyBindingRequest): DeletePolicyBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePolicyBindingWithOptions(request, runtime);
}

model DeleteSnapshotRequest {
  clientId?: string(name='ClientId'),
  force?: boolean(name='Force'),
  instanceId?: string(name='InstanceId'),
  snapshotId?: string(name='SnapshotId'),
  sourceType?: string(name='SourceType'),
  token?: string(name='Token'),
  vaultId?: string(name='VaultId'),
}

model DeleteSnapshotResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteSnapshotResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSnapshotResponseBody(name='body'),
}

async function deleteSnapshotWithOptions(request: DeleteSnapshotRequest, runtime: Util.RuntimeOptions): DeleteSnapshotResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.force)) {
    query['Force'] = request.force;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.snapshotId)) {
    query['SnapshotId'] = request.snapshotId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSnapshot',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSnapshot(request: DeleteSnapshotRequest): DeleteSnapshotResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSnapshotWithOptions(request, runtime);
}

model DeleteUdmEcsInstanceGroupRequest {
  deleteUdmEcsInstance?: boolean(name='DeleteUdmEcsInstance'),
  instanceGroupId?: string(name='InstanceGroupId'),
}

model DeleteUdmEcsInstanceGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteUdmEcsInstanceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteUdmEcsInstanceGroupResponseBody(name='body'),
}

async function deleteUdmEcsInstanceGroupWithOptions(request: DeleteUdmEcsInstanceGroupRequest, runtime: Util.RuntimeOptions): DeleteUdmEcsInstanceGroupResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deleteUdmEcsInstance)) {
    query['DeleteUdmEcsInstance'] = request.deleteUdmEcsInstance;
  }
  if (!Util.isUnset(request.instanceGroupId)) {
    query['InstanceGroupId'] = request.instanceGroupId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteUdmEcsInstanceGroup',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteUdmEcsInstanceGroup(request: DeleteUdmEcsInstanceGroupRequest): DeleteUdmEcsInstanceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteUdmEcsInstanceGroupWithOptions(request, runtime);
}

model DeleteVaultRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  token?: string(name='Token'),
  userAccountId?: long(name='UserAccountId'),
  vaultId?: string(name='VaultId'),
}

model DeleteVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DeleteVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteVaultResponseBody(name='body'),
}

async function deleteVaultWithOptions(request: DeleteVaultRequest, runtime: Util.RuntimeOptions): DeleteVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.userAccountId)) {
    query['UserAccountId'] = request.userAccountId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteVault(request: DeleteVaultRequest): DeleteVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteVaultWithOptions(request, runtime);
}

model DescribeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds'),
  clientType?: string(name='ClientType'),
  instanceIds?: map[string]any(name='InstanceIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds'),
  clientType?: string(name='ClientType'),
  instanceIdsShrink?: string(name='InstanceIds'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
}

model DescribeBackupClientsResponseBody = {
  clients?: [ 
    {
      appliance?: boolean(name='Appliance'),
      archType?: string(name='ArchType'),
      backupStatus?: string(name='BackupStatus'),
      clientId?: string(name='ClientId'),
      clientType?: string(name='ClientType'),
      clientVersion?: string(name='ClientVersion'),
      createdTime?: long(name='CreatedTime'),
      hostname?: string(name='Hostname'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      lastHeartBeatTime?: long(name='LastHeartBeatTime'),
      maxClientVersion?: string(name='MaxClientVersion'),
      osType?: string(name='OsType'),
      privateIpV4?: string(name='PrivateIpV4'),
      settings?: {
        dataNetworkType?: string(name='DataNetworkType'),
        dataProxySetting?: string(name='DataProxySetting'),
        maxCpuCore?: string(name='MaxCpuCore'),
        maxWorker?: string(name='MaxWorker'),
        proxyHost?: string(name='ProxyHost'),
        proxyPassword?: string(name='ProxyPassword'),
        proxyPort?: int32(name='ProxyPort'),
        proxyUser?: string(name='ProxyUser'),
        useHttps?: string(name='UseHttps'),
      }(name='Settings'),
      status?: string(name='Status'),
      tags?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tags'),
      updatedTime?: long(name='UpdatedTime'),
      zoneId?: string(name='ZoneId'),
    }
  ](name='Clients'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupClientsResponseBody(name='body'),
}

async function describeBackupClientsWithOptions(tmpReq: DescribeBackupClientsRequest, runtime: Util.RuntimeOptions): DescribeBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    body['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    body['InstanceIds'] = request.instanceIdsShrink;
  }
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupClients(request: DescribeBackupClientsRequest): DescribeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupClientsWithOptions(request, runtime);
}

model DescribeBackupJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sortDirection?: string(name='SortDirection'),
  sourceType?: string(name='SourceType'),
}

model DescribeBackupJobs2ResponseBody = {
  backupJobs?: {
    backupJob?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      errorMessage?: string(name='ErrorMessage'),
      exclude?: string(name='Exclude'),
      fileSystemId?: string(name='FileSystemId'),
      include?: string(name='Include'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      jobId?: string(name='JobId'),
      jobName?: string(name='JobName'),
      options?: string(name='Options'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames'),
      }(name='OtsDetail'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      planId?: string(name='PlanId'),
      prefix?: string(name='Prefix'),
      progress?: int32(name='Progress'),
      sourceType?: string(name='SourceType'),
      speed?: long(name='Speed'),
      speedLimit?: string(name='SpeedLimit'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      tableName?: string(name='TableName'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='BackupJob')
  }(name='BackupJobs'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupJobs2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupJobs2ResponseBody(name='body'),
}

async function describeBackupJobs2WithOptions(request: DescribeBackupJobs2Request, runtime: Util.RuntimeOptions): DescribeBackupJobs2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sortDirection)) {
    query['SortDirection'] = request.sortDirection;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupJobs2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupJobs2(request: DescribeBackupJobs2Request): DescribeBackupJobs2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupJobs2WithOptions(request, runtime);
}

model DescribeBackupPlansRequest {
  filters?: [ 
    {
      key?: string(name='Key'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  sourceType?: string(name='SourceType'),
}

model DescribeBackupPlansResponseBody = {
  backupPlans?: {
    backupPlan?: [ 
    {
      backupSourceGroupId?: string(name='BackupSourceGroupId'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      clientId?: string(name='ClientId'),
      clusterId?: string(name='ClusterId'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      crossAccountType?: string(name='CrossAccountType'),
      crossOwnerId?: long(name='CrossOwnerId'),
      crossRamRole?: string(name='CrossRamRole'),
      dataSourceId?: string(name='DataSourceId'),
      detail?: string(name='Detail'),
      disabled?: boolean(name='Disabled'),
      exclude?: string(name='Exclude'),
      fileSystemId?: string(name='FileSystemId'),
      include?: string(name='Include'),
      instanceGroupId?: string(name='InstanceGroupId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      options?: string(name='Options'),
      otsDetail?: {
        tableNames?: {
          tableName?: [ string ](name='TableName')
        }(name='TableNames'),
      }(name='OtsDetail'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      planId?: string(name='PlanId'),
      planName?: string(name='PlanName'),
      prefix?: string(name='Prefix'),
      resources?: {
        resource?: [ 
        {
          extra?: string(name='Extra'),
          resourceId?: string(name='ResourceId'),
          sourceType?: string(name='SourceType'),
        }
      ](name='Resource')
      }(name='Resources'),
      retention?: long(name='Retention'),
      rules?: {
        rule?: [ 
        {
          backupType?: string(name='BackupType'),
          destinationRegionId?: string(name='DestinationRegionId'),
          destinationRetention?: long(name='DestinationRetention'),
          disabled?: boolean(name='Disabled'),
          doCopy?: boolean(name='DoCopy'),
          retention?: long(name='Retention'),
          ruleId?: string(name='RuleId'),
          ruleName?: string(name='RuleName'),
          schedule?: string(name='Schedule'),
        }
      ](name='Rule')
      }(name='Rules'),
      schedule?: string(name='Schedule'),
      sourceType?: string(name='SourceType'),
      speedLimit?: string(name='SpeedLimit'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration'),
        trialExpireTime?: long(name='TrialExpireTime'),
        trialStartTime?: long(name='TrialStartTime'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime'),
      }(name='TrialInfo'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='BackupPlan')
  }(name='BackupPlans'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeBackupPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupPlansResponseBody(name='body'),
}

async function describeBackupPlansWithOptions(request: DescribeBackupPlansRequest, runtime: Util.RuntimeOptions): DescribeBackupPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupPlans',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupPlans(request: DescribeBackupPlansRequest): DescribeBackupPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupPlansWithOptions(request, runtime);
}

model DescribeBackupSetRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeBackupSetResponseBody = {
  backupSetList?: {
    backupSet?: [ 
    {
      backupType?: string(name='BackupType'),
      bsKey?: int32(name='BsKey'),
      clusterId?: string(name='ClusterId'),
      completionTime?: int32(name='CompletionTime'),
      compressed?: string(name='Compressed'),
      copyId?: int32(name='CopyId'),
      createdTime?: long(name='CreatedTime'),
      encryptionMode?: string(name='EncryptionMode'),
      outputBytes?: int32(name='OutputBytes'),
      outputRateBytes?: int32(name='OutputRateBytes'),
      startTime?: int32(name='StartTime'),
      status?: string(name='Status'),
      totalOutputBytes?: int32(name='TotalOutputBytes'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='BackupSet')
  }(name='BackupSetList'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeBackupSetResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeBackupSetResponseBody(name='body'),
}

async function describeBackupSetWithOptions(request: DescribeBackupSetRequest, runtime: Util.RuntimeOptions): DescribeBackupSetResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeBackupSet',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeBackupSet(request: DescribeBackupSetRequest): DescribeBackupSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeBackupSetWithOptions(request, runtime);
}

model DescribeClientsRequest {
  clientId?: string(name='ClientId'),
  clientType?: string(name='ClientType'),
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  sourceType?: string(name='SourceType'),
  vaultId?: string(name='VaultId'),
}

model DescribeClientsResponseBody = {
  clients?: {
    client?: [ 
    {
      alertSetting?: string(name='AlertSetting'),
      clientId?: string(name='ClientId'),
      clientName?: string(name='ClientName'),
      clientType?: string(name='ClientType'),
      clientVersion?: string(name='ClientVersion'),
      clusterId?: string(name='ClusterId'),
      createdTime?: long(name='CreatedTime'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      maxVersion?: string(name='MaxVersion'),
      networkType?: string(name='NetworkType'),
      status?: string(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      updatedTime?: long(name='UpdatedTime'),
      useHttps?: boolean(name='UseHttps'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Client')
  }(name='Clients'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeClientsResponseBody(name='body'),
}

async function describeClientsWithOptions(request: DescribeClientsRequest, runtime: Util.RuntimeOptions): DescribeClientsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.clientType)) {
    query['ClientType'] = request.clientType;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeClients(request: DescribeClientsRequest): DescribeClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeClientsWithOptions(request, runtime);
}

model DescribeContainerClusterRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeContainerClusterResponseBody = {
  clusters?: [ 
    {
      agentStatus?: string(name='AgentStatus'),
      clusterId?: string(name='ClusterId'),
      clusterType?: string(name='ClusterType'),
      description?: string(name='Description'),
      identifier?: string(name='Identifier'),
      name?: string(name='Name'),
      networkType?: string(name='NetworkType'),
      token?: string(name='Token'),
    }
  ](name='Clusters'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeContainerClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeContainerClusterResponseBody(name='body'),
}

async function describeContainerClusterWithOptions(request: DescribeContainerClusterRequest, runtime: Util.RuntimeOptions): DescribeContainerClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeContainerCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeContainerCluster(request: DescribeContainerClusterRequest): DescribeContainerClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeContainerClusterWithOptions(request, runtime);
}

model DescribeCrossAccountsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeCrossAccountsResponseBody = {
  code?: string(name='Code'),
  crossAccounts?: {
    crossAccount?: [ 
    {
      alias?: string(name='Alias'),
      createdTime?: long(name='CreatedTime'),
      crossOwnerId?: long(name='CrossOwnerId'),
      crossRamRole?: string(name='CrossRamRole'),
      id?: long(name='Id'),
      ownerId?: long(name='OwnerId'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='CrossAccount')
  }(name='CrossAccounts'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeCrossAccountsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeCrossAccountsResponseBody(name='body'),
}

async function describeCrossAccountsWithOptions(request: DescribeCrossAccountsRequest, runtime: Util.RuntimeOptions): DescribeCrossAccountsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeCrossAccounts',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeCrossAccounts(request: DescribeCrossAccountsRequest): DescribeCrossAccountsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeCrossAccountsWithOptions(request, runtime);
}

model DescribeHanaBackupPlansRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaBackupPlansResponseBody = {
  code?: string(name='Code'),
  hanaBackupPlans?: {
    hanaBackupPlan?: [ 
    {
      backupPrefix?: string(name='BackupPrefix'),
      backupType?: string(name='BackupType'),
      clusterId?: string(name='ClusterId'),
      databaseName?: string(name='DatabaseName'),
      disabled?: boolean(name='Disabled'),
      planId?: string(name='PlanId'),
      planName?: string(name='PlanName'),
      schedule?: string(name='Schedule'),
      vaultId?: string(name='VaultId'),
    }
  ](name='HanaBackupPlan')
  }(name='HanaBackupPlans'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeHanaBackupPlansResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupPlansResponseBody(name='body'),
}

async function describeHanaBackupPlansWithOptions(request: DescribeHanaBackupPlansRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupPlansResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupPlans',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaBackupPlans(request: DescribeHanaBackupPlansRequest): DescribeHanaBackupPlansResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupPlansWithOptions(request, runtime);
}

model DescribeHanaBackupSettingRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaBackupSettingResponseBody = {
  code?: string(name='Code'),
  hanaBackupSetting?: {
    catalogBackupParameterFile?: string(name='CatalogBackupParameterFile'),
    catalogBackupUsingBackint?: boolean(name='CatalogBackupUsingBackint'),
    dataBackupParameterFile?: string(name='DataBackupParameterFile'),
    databaseName?: string(name='DatabaseName'),
    enableAutoLogBackup?: boolean(name='EnableAutoLogBackup'),
    logBackupParameterFile?: string(name='LogBackupParameterFile'),
    logBackupTimeout?: long(name='LogBackupTimeout'),
    logBackupUsingBackint?: boolean(name='LogBackupUsingBackint'),
  }(name='HanaBackupSetting'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeHanaBackupSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupSettingResponseBody(name='body'),
}

async function describeHanaBackupSettingWithOptions(request: DescribeHanaBackupSettingRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaBackupSetting(request: DescribeHanaBackupSettingRequest): DescribeHanaBackupSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupSettingWithOptions(request, runtime);
}

model DescribeHanaBackupsAsyncRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  includeDifferential?: boolean(name='IncludeDifferential'),
  includeIncremental?: boolean(name='IncludeIncremental'),
  includeLog?: boolean(name='IncludeLog'),
  logPosition?: long(name='LogPosition'),
  mode?: string(name='Mode'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  recoveryPointInTime?: long(name='RecoveryPointInTime'),
  resourceGroupId?: string(name='ResourceGroupId'),
  source?: string(name='Source'),
  sourceClusterId?: string(name='SourceClusterId'),
  systemCopy?: boolean(name='SystemCopy'),
  useBackint?: boolean(name='UseBackint'),
  vaultId?: string(name='VaultId'),
  volumeId?: int32(name='VolumeId'),
}

model DescribeHanaBackupsAsyncResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model DescribeHanaBackupsAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaBackupsAsyncResponseBody(name='body'),
}

async function describeHanaBackupsAsyncWithOptions(request: DescribeHanaBackupsAsyncRequest, runtime: Util.RuntimeOptions): DescribeHanaBackupsAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.includeDifferential)) {
    query['IncludeDifferential'] = request.includeDifferential;
  }
  if (!Util.isUnset(request.includeIncremental)) {
    query['IncludeIncremental'] = request.includeIncremental;
  }
  if (!Util.isUnset(request.includeLog)) {
    query['IncludeLog'] = request.includeLog;
  }
  if (!Util.isUnset(request.logPosition)) {
    query['LogPosition'] = request.logPosition;
  }
  if (!Util.isUnset(request.mode)) {
    query['Mode'] = request.mode;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.recoveryPointInTime)) {
    query['RecoveryPointInTime'] = request.recoveryPointInTime;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceClusterId)) {
    query['SourceClusterId'] = request.sourceClusterId;
  }
  if (!Util.isUnset(request.systemCopy)) {
    query['SystemCopy'] = request.systemCopy;
  }
  if (!Util.isUnset(request.useBackint)) {
    query['UseBackint'] = request.useBackint;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.volumeId)) {
    query['VolumeId'] = request.volumeId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaBackupsAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaBackupsAsync(request: DescribeHanaBackupsAsyncRequest): DescribeHanaBackupsAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaBackupsAsyncWithOptions(request, runtime);
}

model DescribeHanaDatabasesRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaDatabasesResponseBody = {
  code?: string(name='Code'),
  hanaDatabases?: {
    hanaDatabase?: [ 
    {
      activeStatus?: string(name='ActiveStatus'),
      databaseName?: string(name='DatabaseName'),
      detail?: string(name='Detail'),
      host?: string(name='Host'),
      serviceName?: string(name='ServiceName'),
      sqlPort?: int32(name='SqlPort'),
    }
  ](name='HanaDatabase')
  }(name='HanaDatabases'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeHanaDatabasesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaDatabasesResponseBody(name='body'),
}

async function describeHanaDatabasesWithOptions(request: DescribeHanaDatabasesRequest, runtime: Util.RuntimeOptions): DescribeHanaDatabasesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaDatabases',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaDatabases(request: DescribeHanaDatabasesRequest): DescribeHanaDatabasesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaDatabasesWithOptions(request, runtime);
}

model DescribeHanaInstancesRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaInstancesResponseBody = {
  code?: string(name='Code'),
  hanas?: {
    hana?: [ 
    {
      alertSetting?: string(name='AlertSetting'),
      clusterId?: string(name='ClusterId'),
      hanaName?: string(name='HanaName'),
      host?: string(name='Host'),
      instanceNumber?: int32(name='InstanceNumber'),
      resourceGroupId?: string(name='ResourceGroupId'),
      status?: long(name='Status'),
      statusMessage?: string(name='StatusMessage'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      useSsl?: boolean(name='UseSsl'),
      userName?: string(name='UserName'),
      validateCertificate?: boolean(name='ValidateCertificate'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Hana')
  }(name='Hanas'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHanaInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaInstancesResponseBody(name='body'),
}

async function describeHanaInstancesWithOptions(request: DescribeHanaInstancesRequest, runtime: Util.RuntimeOptions): DescribeHanaInstancesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaInstances',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaInstances(request: DescribeHanaInstancesRequest): DescribeHanaInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaInstancesWithOptions(request, runtime);
}

model DescribeHanaRestoresRequest {
  backupId?: long(name='BackupId'),
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  restoreId?: string(name='RestoreId'),
  restoreStatus?: string(name='RestoreStatus'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaRestoresResponseBody = {
  code?: string(name='Code'),
  hanaRestore?: {
    hanaRestores?: [ 
    {
      backupID?: long(name='BackupID'),
      backupPrefix?: string(name='BackupPrefix'),
      checkAccess?: boolean(name='CheckAccess'),
      clearLog?: boolean(name='ClearLog'),
      clusterId?: string(name='ClusterId'),
      currentPhase?: int32(name='CurrentPhase'),
      currentProgress?: long(name='CurrentProgress'),
      databaseName?: string(name='DatabaseName'),
      databaseRestoreId?: long(name='DatabaseRestoreId'),
      endTime?: long(name='EndTime'),
      logPosition?: long(name='LogPosition'),
      maxPhase?: int32(name='MaxPhase'),
      maxProgress?: long(name='MaxProgress'),
      message?: string(name='Message'),
      mode?: string(name='Mode'),
      phase?: string(name='Phase'),
      reachedTime?: long(name='ReachedTime'),
      recoveryPointInTime?: long(name='RecoveryPointInTime'),
      restoreId?: string(name='RestoreId'),
      source?: string(name='Source'),
      sourceClusterId?: string(name='SourceClusterId'),
      startTime?: long(name='StartTime'),
      state?: string(name='State'),
      status?: string(name='Status'),
      systemCopy?: boolean(name='SystemCopy'),
      useCatalog?: boolean(name='UseCatalog'),
      useDelta?: boolean(name='UseDelta'),
      vaultId?: string(name='VaultId'),
      volumeId?: int32(name='VolumeId'),
    }
  ](name='HanaRestores')
  }(name='HanaRestore'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeHanaRestoresResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaRestoresResponseBody(name='body'),
}

async function describeHanaRestoresWithOptions(request: DescribeHanaRestoresRequest, runtime: Util.RuntimeOptions): DescribeHanaRestoresResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupId)) {
    query['BackupId'] = request.backupId;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.restoreId)) {
    query['RestoreId'] = request.restoreId;
  }
  if (!Util.isUnset(request.restoreStatus)) {
    query['RestoreStatus'] = request.restoreStatus;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaRestores',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaRestores(request: DescribeHanaRestoresRequest): DescribeHanaRestoresResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaRestoresWithOptions(request, runtime);
}

model DescribeHanaRetentionSettingRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaRetentionSettingResponseBody = {
  clusterId?: string(name='ClusterId'),
  code?: string(name='Code'),
  databaseName?: string(name='DatabaseName'),
  disabled?: boolean(name='Disabled'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  retentionDays?: long(name='RetentionDays'),
  schedule?: string(name='Schedule'),
  success?: boolean(name='Success'),
  vaultId?: string(name='VaultId'),
}

model DescribeHanaRetentionSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeHanaRetentionSettingResponseBody(name='body'),
}

async function describeHanaRetentionSettingWithOptions(request: DescribeHanaRetentionSettingRequest, runtime: Util.RuntimeOptions): DescribeHanaRetentionSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeHanaRetentionSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeHanaRetentionSetting(request: DescribeHanaRetentionSettingRequest): DescribeHanaRetentionSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeHanaRetentionSettingWithOptions(request, runtime);
}

model DescribeObClusterRequest {
  clusterId?: string(name='ClusterId'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
}

model DescribeObClusterResponseBody = {
  clusters?: {
    cluster?: [ 
    {
      clientId?: string(name='ClientId'),
      clusterId?: string(name='ClusterId'),
      clusterName?: string(name='ClusterName'),
      createdTime?: long(name='CreatedTime'),
      description?: string(name='Description'),
      host?: string(name='Host'),
      logArchiveTime?: long(name='LogArchiveTime'),
      port?: int32(name='Port'),
      retention?: long(name='Retention'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Cluster')
  }(name='Clusters'),
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeObClusterResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeObClusterResponseBody(name='body'),
}

async function describeObClusterWithOptions(request: DescribeObClusterRequest, runtime: Util.RuntimeOptions): DescribeObClusterResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeObCluster',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeObCluster(request: DescribeObClusterRequest): DescribeObClusterResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeObClusterWithOptions(request, runtime);
}

model DescribeOtsTableSnapshotsRequest {
  endTime?: long(name='EndTime'),
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      tableNames?: [ string ](name='TableNames'),
    }
  ](name='OtsInstances'),
  snapshotIds?: [ string ](name='SnapshotIds'),
  startTime?: long(name='StartTime'),
}

model DescribeOtsTableSnapshotsResponseBody = {
  code?: string(name='Code'),
  limit?: int32(name='Limit'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      actualBytes?: string(name='ActualBytes'),
      backupType?: string(name='BackupType'),
      bytesTotal?: long(name='BytesTotal'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      instanceName?: string(name='InstanceName'),
      jobId?: string(name='JobId'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      rangeEnd?: long(name='RangeEnd'),
      rangeStart?: long(name='RangeStart'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      tableName?: string(name='TableName'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Snapshots'),
  success?: boolean(name='Success'),
}

model DescribeOtsTableSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeOtsTableSnapshotsResponseBody(name='body'),
}

async function describeOtsTableSnapshotsWithOptions(request: DescribeOtsTableSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeOtsTableSnapshotsResponse {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.endTime)) {
    body['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.limit)) {
    body['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  var bodyFlat : map[string]any= {};
  if (!Util.isUnset(request.otsInstances)) {
    bodyFlat['OtsInstances'] = request.otsInstances;
  }
  if (!Util.isUnset(request.snapshotIds)) {
    bodyFlat['SnapshotIds'] = request.snapshotIds;
  }
  if (!Util.isUnset(request.startTime)) {
    body['StartTime'] = request.startTime;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeOtsTableSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeOtsTableSnapshots(request: DescribeOtsTableSnapshotsRequest): DescribeOtsTableSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeOtsTableSnapshotsWithOptions(request, runtime);
}

model DescribePolicies2Request {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  policyId?: string(name='PolicyId'),
}

model DescribePolicies2ResponseBody = {
  code?: string(name='Code'),
  maxResults?: int32(name='MaxResults'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  policies?: [ 
    {
      createdTime?: long(name='CreatedTime'),
      policyBindingCount?: long(name='PolicyBindingCount'),
      policyDescription?: string(name='PolicyDescription'),
      policyId?: string(name='PolicyId'),
      policyName?: string(name='PolicyName'),
      rules?: [ 
        {
          archiveDays?: long(name='ArchiveDays'),
          archiveVaultId?: string(name='ArchiveVaultId'),
          backupType?: string(name='BackupType', description='COMPLETE, INCREMENTAL, DIFFERENTIAL, LOG'),
          coldArchiveDays?: long(name='ColdArchiveDays'),
          continuous?: boolean(name='Continuous'),
          replicationRegionId?: string(name='ReplicationRegionId'),
          replicationVaultId?: string(name='ReplicationVaultId'),
          retention?: long(name='Retention'),
          retentionRules?: [ 
            {
              retention?: long(name='Retention'),
              scheduleType?: string(name='ScheduleType', description='DAILY, WEEKLY, MONTHLY, YEARLY'),
              whichSnapshot?: long(name='WhichSnapshot'),
            }
          ](name='RetentionRules'),
          ruleId?: string(name='RuleId'),
          ruleType?: string(name='RuleType', description='TRANSITION, BACKUP, REPLICATION'),
          schedule?: string(name='Schedule'),
          selector?: {
            key?: string(name='Key'),
            value?: string(name='Value'),
          }(name='Selector'),
          vaultId?: string(name='VaultId'),
        }
      ](name='Rules'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='Policies'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribePolicies2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicies2ResponseBody(name='body'),
}

async function describePolicies2WithOptions(request: DescribePolicies2Request, runtime: Util.RuntimeOptions): DescribePolicies2Response {
  Util.validateModel(request);
  var body : map[string]any= {};
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicies2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePolicies2(request: DescribePolicies2Request): DescribePolicies2Response {
  var runtime = new Util.RuntimeOptions{};
  return describePolicies2WithOptions(request, runtime);
}

model DescribePolicyBindingsRequest {
  dataSourceIds?: [ string ](name='DataSourceIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  policyId?: string(name='PolicyId'),
  sourceType?: string(name='SourceType'),
}

model DescribePolicyBindingsShrinkRequest {
  dataSourceIdsShrink?: string(name='DataSourceIds'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  policyId?: string(name='PolicyId'),
  sourceType?: string(name='SourceType'),
}

model DescribePolicyBindingsResponseBody = {
  code?: string(name='Code'),
  maxResults?: int32(name='MaxResults'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  policyBindings?: [ 
    {
      advancedOptions?: {
        udmDetail?: {
          appConsistent?: boolean(name='AppConsistent'),
          backupRetention?: long(name='BackupRetention'),
          backupVaultId?: string(name='BackupVaultId'),
          diskIdList?: [ string ](name='DiskIdList'),
          doBackup?: boolean(name='DoBackup'),
          enableFsFreeze?: boolean(name='EnableFsFreeze'),
          enableWriters?: boolean(name='EnableWriters'),
          excludeDiskIdList?: [ string ](name='ExcludeDiskIdList'),
          postScriptPath?: string(name='PostScriptPath'),
          preScriptPath?: string(name='PreScriptPath'),
          ramRoleName?: string(name='RamRoleName'),
          snapshotGroup?: boolean(name='SnapshotGroup'),
          timeoutInSeconds?: long(name='TimeoutInSeconds'),
        }(name='UdmDetail'),
      }(name='AdvancedOptions'),
      createdTime?: long(name='CreatedTime'),
      dataSourceId?: string(name='DataSourceId'),
      disabled?: boolean(name='Disabled'),
      exclude?: string(name='Exclude'),
      include?: string(name='Include'),
      policyBindingDescription?: string(name='PolicyBindingDescription'),
      policyBindingId?: string(name='PolicyBindingId'),
      policyId?: string(name='PolicyId'),
      source?: string(name='Source'),
      sourceType?: string(name='SourceType'),
      speedLimit?: string(name='SpeedLimit'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='PolicyBindings'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribePolicyBindingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribePolicyBindingsResponseBody(name='body'),
}

async function describePolicyBindingsWithOptions(tmpReq: DescribePolicyBindingsRequest, runtime: Util.RuntimeOptions): DescribePolicyBindingsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribePolicyBindingsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSourceIds)) {
    request.dataSourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSourceIds, 'DataSourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataSourceIdsShrink)) {
    body['DataSourceIds'] = request.dataSourceIdsShrink;
  }
  if (!Util.isUnset(request.maxResults)) {
    body['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    body['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribePolicyBindings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describePolicyBindings(request: DescribePolicyBindingsRequest): DescribePolicyBindingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describePolicyBindingsWithOptions(request, runtime);
}

model DescribeRecoverableOtsInstancesResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  otsInstances?: [ 
    {
      instanceName?: string(name='InstanceName'),
      tableNames?: [ string ](name='TableNames'),
    }
  ](name='OtsInstances'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRecoverableOtsInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRecoverableOtsInstancesResponseBody(name='body'),
}

async function describeRecoverableOtsInstancesWithOptions(runtime: Util.RuntimeOptions): DescribeRecoverableOtsInstancesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'DescribeRecoverableOtsInstances',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRecoverableOtsInstances(): DescribeRecoverableOtsInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRecoverableOtsInstancesWithOptions(runtime);
}

model DescribeRegionsRequest {
  needVaultCount?: boolean(name='NeedVaultCount'),
}

model DescribeRegionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  regions?: {
    region?: [ 
    {
      localName?: string(name='LocalName'),
      regionId?: string(name='RegionId'),
      vaultCount?: int32(name='VaultCount'),
    }
  ](name='Region')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRegionsResponseBody(name='body'),
}

async function describeRegionsWithOptions(request: DescribeRegionsRequest, runtime: Util.RuntimeOptions): DescribeRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.needVaultCount)) {
    query['NeedVaultCount'] = request.needVaultCount;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRegions',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRegions(request: DescribeRegionsRequest): DescribeRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeRegionsWithOptions(request, runtime);
}

model DescribeRestoreJobs2Request {
  filters?: [ 
    {
      key?: string(name='Key'),
      operator?: string(name='Operator'),
      values?: [ string ](name='Values'),
    }
  ](name='Filters'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  restoreType?: string(name='RestoreType'),
}

model DescribeRestoreJobs2ResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  restoreJobs?: {
    restoreJob?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clusterId?: string(name='ClusterId'),
      completeTime?: long(name='CompleteTime'),
      createdTime?: long(name='CreatedTime'),
      crossAccountType?: string(name='CrossAccountType'),
      crossOwnerId?: long(name='CrossOwnerId'),
      crossRamRole?: string(name='CrossRamRole'),
      errorFile?: string(name='ErrorFile'),
      errorMessage?: string(name='ErrorMessage'),
      exclude?: string(name='Exclude'),
      expireTime?: long(name='ExpireTime'),
      include?: string(name='Include'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      options?: string(name='Options'),
      otsDetail?: {
        batchChannelCount?: int32(name='BatchChannelCount'),
        overwriteExisting?: boolean(name='OverwriteExisting'),
      }(name='OtsDetail'),
      parentId?: string(name='ParentId'),
      progress?: int32(name='Progress'),
      restoreId?: string(name='RestoreId'),
      restoreType?: string(name='RestoreType'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      speed?: long(name='Speed'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      targetBucket?: string(name='TargetBucket'),
      targetClientId?: string(name='TargetClientId'),
      targetCreateTime?: long(name='TargetCreateTime'),
      targetDataSourceId?: string(name='TargetDataSourceId'),
      targetFileSystemId?: string(name='TargetFileSystemId'),
      targetInstanceId?: string(name='TargetInstanceId'),
      targetInstanceName?: string(name='TargetInstanceName'),
      targetPath?: string(name='TargetPath'),
      targetPrefix?: string(name='TargetPrefix'),
      targetTableName?: string(name='TargetTableName'),
      targetTime?: long(name='TargetTime'),
      udmDetail?: string(name='UdmDetail'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='RestoreJob')
  }(name='RestoreJobs'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model DescribeRestoreJobs2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeRestoreJobs2ResponseBody(name='body'),
}

async function describeRestoreJobs2WithOptions(request: DescribeRestoreJobs2Request, runtime: Util.RuntimeOptions): DescribeRestoreJobs2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.filters)) {
    query['Filters'] = request.filters;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.restoreType)) {
    query['RestoreType'] = request.restoreType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeRestoreJobs2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeRestoreJobs2(request: DescribeRestoreJobs2Request): DescribeRestoreJobs2Response {
  var runtime = new Util.RuntimeOptions{};
  return describeRestoreJobs2WithOptions(request, runtime);
}

model DescribeTaskRequest {
  resourceGroupId?: string(name='ResourceGroupId'),
  taskId?: string(name='TaskId'),
  token?: string(name='Token'),
}

model DescribeTaskResponseBody = {
  code?: string(name='Code'),
  completedTime?: long(name='CompletedTime'),
  createdTime?: long(name='CreatedTime'),
  description?: string(name='Description'),
  message?: string(name='Message'),
  name?: string(name='Name'),
  progress?: int32(name='Progress'),
  requestId?: string(name='RequestId'),
  result?: string(name='Result'),
  success?: boolean(name='Success'),
  updatedTime?: long(name='UpdatedTime'),
}

model DescribeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeTaskResponseBody(name='body'),
}

async function describeTaskWithOptions(request: DescribeTaskRequest, runtime: Util.RuntimeOptions): DescribeTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.taskId)) {
    query['TaskId'] = request.taskId;
  }
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeTask',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeTask(request: DescribeTaskRequest): DescribeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeTaskWithOptions(request, runtime);
}

model DescribeUdmEcsInstanceGroupsRequest {
  instanceGroupId?: string(name='InstanceGroupId'),
  instanceGroupName?: string(name='InstanceGroupName'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  udmRegionId?: string(name='UdmRegionId'),
}

model DescribeUdmEcsInstanceGroupsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
  udmEcsInstanceGroups?: [ 
    {
      backupCount?: long(name='BackupCount', description='return according planType'),
      backupPlans?: [ 
        {
          disabled?: boolean(name='Disabled'),
          planId?: string(name='PlanId'),
          retention?: long(name='Retention'),
          schedule?: string(name='Schedule'),
        }
      ](name='BackupPlans'),
      completeJobCount?: long(name='CompleteJobCount'),
      diskIdMap?: map[string]any(name='DiskIdMap'),
      doBackup?: boolean(name='DoBackup'),
      excludeDiskIdMap?: map[string]any(name='ExcludeDiskIdMap'),
      failedJobCount?: long(name='FailedJobCount'),
      firstNativeSnapshotTime?: long(name='FirstNativeSnapshotTime'),
      instanceGroupId?: string(name='InstanceGroupId'),
      instanceGroupName?: string(name='InstanceGroupName'),
      nativeSnapshotCount?: long(name='NativeSnapshotCount', description='return according planType'),
      planCount?: long(name='PlanCount'),
      runningJobCount?: long(name='RunningJobCount'),
      udmEcsInstances?: [ 
        {
          backupCount?: long(name='BackupCount', description='return according planType'),
          backupPlans?: [ 
            {
              disabled?: boolean(name='Disabled'),
              planId?: string(name='PlanId'),
              retention?: long(name='Retention'),
              schedule?: string(name='Schedule'),
            }
          ](name='BackupPlans'),
          completeJobCount?: long(name='CompleteJobCount'),
          disks?: [ 
            {
              activated?: boolean(name='Activated'),
              category?: string(name='Category'),
              device?: string(name='Device'),
              diskId?: string(name='DiskId'),
              diskName?: string(name='DiskName'),
              encrypted?: boolean(name='Encrypted'),
              imageId?: string(name='ImageId'),
              size?: int32(name='Size'),
              sourceRegionId?: string(name='SourceRegionId'),
              type?: string(name='Type'),
              vaultId?: string(name='VaultId'),
            }
          ](name='Disks'),
          doBackup?: boolean(name='DoBackup'),
          ecsDeleted?: boolean(name='EcsDeleted', description='Whether target ecs instance is deleted'),
          eipAddress?: string(name='EipAddress'),
          failedJobCount?: long(name='FailedJobCount'),
          firstNativeSnapshotTime?: long(name='FirstNativeSnapshotTime'),
          innerIpAddress?: string(name='InnerIpAddress'),
          instanceGroupId?: string(name='InstanceGroupId'),
          instanceId?: string(name='InstanceId'),
          instanceName?: string(name='InstanceName'),
          nativeSnapshotCount?: long(name='NativeSnapshotCount', description='return according planType'),
          planCount?: long(name='PlanCount'),
          privateIpAddress?: string(name='PrivateIpAddress'),
          publicIpAddress?: string(name='PublicIpAddress'),
          replicated?: boolean(name='Replicated'),
          runningJobCount?: long(name='RunningJobCount'),
          sourceRegionId?: string(name='SourceRegionId'),
          vaultId?: string(name='VaultId'),
          vpcId?: string(name='VpcId'),
          vswitchId?: string(name='VswitchId'),
          zoneId?: string(name='ZoneId'),
        }
      ](name='UdmEcsInstances'),
    }
  ](name='UdmEcsInstanceGroups'),
}

model DescribeUdmEcsInstanceGroupsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUdmEcsInstanceGroupsResponseBody(name='body'),
}

async function describeUdmEcsInstanceGroupsWithOptions(request: DescribeUdmEcsInstanceGroupsRequest, runtime: Util.RuntimeOptions): DescribeUdmEcsInstanceGroupsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceGroupId)) {
    query['InstanceGroupId'] = request.instanceGroupId;
  }
  if (!Util.isUnset(request.instanceGroupName)) {
    query['InstanceGroupName'] = request.instanceGroupName;
  }
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUdmEcsInstanceGroups',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUdmEcsInstanceGroups(request: DescribeUdmEcsInstanceGroupsRequest): DescribeUdmEcsInstanceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUdmEcsInstanceGroupsWithOptions(request, runtime);
}

model DescribeUdmSnapshotsRequest {
  diskId?: string(name='DiskId'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
  snapshotIds?: map[string]any(name='SnapshotIds'),
  sourceType?: string(name='SourceType'),
  startTime?: long(name='StartTime'),
  udmRegionId?: string(name='UdmRegionId'),
}

model DescribeUdmSnapshotsShrinkRequest {
  diskId?: string(name='DiskId'),
  endTime?: long(name='EndTime'),
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
  snapshotIdsShrink?: string(name='SnapshotIds'),
  sourceType?: string(name='SourceType'),
  startTime?: long(name='StartTime'),
  udmRegionId?: string(name='UdmRegionId'),
}

model DescribeUdmSnapshotsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  snapshots?: [ 
    {
      actualBytes?: string(name='ActualBytes'),
      backupType?: string(name='BackupType'),
      bytesTotal?: long(name='BytesTotal'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      detail?: {
        consistentLevel?: string(name='ConsistentLevel'),
        containOsDisk?: boolean(name='ContainOsDisk'),
        diskDevName?: string(name='DiskDevName'),
        diskHbrSnapshotIdWithDeviceMap?: map[string]any(name='DiskHbrSnapshotIdWithDeviceMap'),
        diskIdList?: [ string ](name='DiskIdList'),
        downgradeReason?: string(name='DowngradeReason'),
        instanceIdWithDiskIdListMap?: map[string]any(name='InstanceIdWithDiskIdListMap'),
        instanceName?: string(name='InstanceName'),
        nativeSnapshotIdList?: [ string ](name='NativeSnapshotIdList'),
        osDiskId?: string(name='OsDiskId'),
        osName?: string(name='OsName'),
        osNameEn?: string(name='OsNameEn'),
        osType?: string(name='OsType'),
        platform?: string(name='Platform'),
        snapshotGroupId?: string(name='SnapshotGroupId'),
        systemDisk?: boolean(name='SystemDisk'),
        vmName?: string(name='VmName'),
      }(name='Detail'),
      diskId?: string(name='DiskId'),
      instanceId?: string(name='InstanceId'),
      jobId?: string(name='JobId'),
      nativeSnapshotId?: string(name='NativeSnapshotId'),
      nativeSnapshotInfo?: string(name='NativeSnapshotInfo'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      prefix?: string(name='Prefix'),
      realSnapshotTime?: long(name='RealSnapshotTime'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      updatedTime?: long(name='UpdatedTime'),
    }
  ](name='Snapshots'),
  success?: boolean(name='Success'),
  totalCount?: long(name='TotalCount'),
}

model DescribeUdmSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeUdmSnapshotsResponseBody(name='body'),
}

async function describeUdmSnapshotsWithOptions(tmpReq: DescribeUdmSnapshotsRequest, runtime: Util.RuntimeOptions): DescribeUdmSnapshotsResponse {
  Util.validateModel(tmpReq);
  var request = new DescribeUdmSnapshotsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.snapshotIds)) {
    request.snapshotIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.snapshotIds, 'SnapshotIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.diskId)) {
    query['DiskId'] = request.diskId;
  }
  if (!Util.isUnset(request.endTime)) {
    query['EndTime'] = request.endTime;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.jobId)) {
    query['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.startTime)) {
    query['StartTime'] = request.startTime;
  }
  if (!Util.isUnset(request.udmRegionId)) {
    query['UdmRegionId'] = request.udmRegionId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.snapshotIdsShrink)) {
    body['SnapshotIds'] = request.snapshotIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeUdmSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeUdmSnapshots(request: DescribeUdmSnapshotsRequest): DescribeUdmSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeUdmSnapshotsWithOptions(request, runtime);
}

model DescribeVaultReplicationRegionsRequest {
  token?: string(name='Token'),
  vaultId?: string(name='VaultId'),
}

model DescribeVaultReplicationRegionsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  regions?: {
    regionId?: [ string ](name='RegionId')
  }(name='Regions'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DescribeVaultReplicationRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVaultReplicationRegionsResponseBody(name='body'),
}

async function describeVaultReplicationRegionsWithOptions(request: DescribeVaultReplicationRegionsRequest, runtime: Util.RuntimeOptions): DescribeVaultReplicationRegionsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.token)) {
    query['Token'] = request.token;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVaultReplicationRegions',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVaultReplicationRegions(request: DescribeVaultReplicationRegionsRequest): DescribeVaultReplicationRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVaultReplicationRegionsWithOptions(request, runtime);
}

model DescribeVaultsRequest {
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  resourceGroupId?: string(name='ResourceGroupId'),
  status?: string(name='Status'),
  tag?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='Tag'),
  vaultId?: string(name='VaultId'),
  vaultRegionId?: string(name='VaultRegionId'),
  vaultType?: string(name='VaultType'),
}

model DescribeVaultsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  pageNumber?: int32(name='PageNumber'),
  pageSize?: int32(name='PageSize'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
  vaults?: {
    vault?: [ 
    {
      backupPlanStatistics?: {
        commonNas?: int32(name='CommonNas'),
        csg?: int32(name='Csg'),
        ecsFile?: int32(name='EcsFile'),
        ecsHana?: int32(name='EcsHana'),
        isilon?: int32(name='Isilon'),
        localFile?: int32(name='LocalFile'),
        localVm?: int32(name='LocalVm'),
        mySql?: int32(name='MySql'),
        nas?: int32(name='Nas'),
        oracle?: int32(name='Oracle'),
        oss?: int32(name='Oss'),
        ots?: int32(name='Ots'),
        sqlServer?: int32(name='SqlServer'),
      }(name='BackupPlanStatistics'),
      bucketName?: string(name='BucketName'),
      bytesDone?: long(name='BytesDone'),
      chargeType?: string(name='ChargeType'),
      compressionAlgorithm?: string(name='CompressionAlgorithm'),
      createdTime?: long(name='CreatedTime'),
      dedup?: boolean(name='Dedup'),
      description?: string(name='Description'),
      encryptType?: string(name='EncryptType'),
      indexAvailable?: boolean(name='IndexAvailable'),
      indexLevel?: string(name='IndexLevel'),
      indexUpdateTime?: long(name='IndexUpdateTime'),
      kmsKeyId?: string(name='KmsKeyId'),
      latestReplicationTime?: long(name='LatestReplicationTime'),
      redundancyType?: string(name='RedundancyType'),
      replication?: boolean(name='Replication'),
      replicationProgress?: {
        historicalReplicationProgress?: int32(name='HistoricalReplicationProgress'),
        newReplicationProgress?: long(name='NewReplicationProgress'),
      }(name='ReplicationProgress'),
      replicationSourceRegionId?: string(name='ReplicationSourceRegionId'),
      replicationSourceVaultId?: string(name='ReplicationSourceVaultId'),
      resourceGroupId?: string(name='ResourceGroupId'),
      retention?: long(name='Retention'),
      searchEnabled?: boolean(name='SearchEnabled'),
      snapshotCount?: long(name='SnapshotCount'),
      sourceTypes?: {
        sourceType?: [ string ](name='SourceType')
      }(name='SourceTypes'),
      status?: string(name='Status'),
      storageSize?: long(name='StorageSize'),
      tags?: {
        tag?: [ 
        {
          key?: string(name='Key'),
          value?: string(name='Value'),
        }
      ](name='Tag')
      }(name='Tags'),
      trialInfo?: {
        keepAfterTrialExpiration?: boolean(name='KeepAfterTrialExpiration'),
        trialExpireTime?: long(name='TrialExpireTime'),
        trialStartTime?: long(name='TrialStartTime'),
        trialVaultReleaseTime?: long(name='TrialVaultReleaseTime'),
      }(name='TrialInfo'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
      vaultName?: string(name='VaultName'),
      vaultRegionId?: string(name='VaultRegionId'),
      vaultStatusMessage?: string(name='VaultStatusMessage'),
      vaultStorageClass?: string(name='VaultStorageClass'),
      vaultType?: string(name='VaultType'),
      wormEnabled?: boolean(name='WormEnabled'),
    }
  ](name='Vault')
  }(name='Vaults'),
}

model DescribeVaultsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DescribeVaultsResponseBody(name='body'),
}

async function describeVaultsWithOptions(request: DescribeVaultsRequest, runtime: Util.RuntimeOptions): DescribeVaultsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.pageNumber)) {
    query['PageNumber'] = request.pageNumber;
  }
  if (!Util.isUnset(request.pageSize)) {
    query['PageSize'] = request.pageSize;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.status)) {
    query['Status'] = request.status;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.vaultRegionId)) {
    query['VaultRegionId'] = request.vaultRegionId;
  }
  if (!Util.isUnset(request.vaultType)) {
    query['VaultType'] = request.vaultType;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.tag)) {
    body['Tag'] = request.tag;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DescribeVaults',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function describeVaults(request: DescribeVaultsRequest): DescribeVaultsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeVaultsWithOptions(request, runtime);
}

model DetachNasFileSystemRequest {
  createTime?: string(name='CreateTime'),
  fileSystemId?: string(name='FileSystemId'),
}

model DetachNasFileSystemResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model DetachNasFileSystemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DetachNasFileSystemResponseBody(name='body'),
}

async function detachNasFileSystemWithOptions(request: DetachNasFileSystemRequest, runtime: Util.RuntimeOptions): DetachNasFileSystemResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.createTime)) {
    query['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.fileSystemId)) {
    query['FileSystemId'] = request.fileSystemId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DetachNasFileSystem',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function detachNasFileSystem(request: DetachNasFileSystemRequest): DetachNasFileSystemResponse {
  var runtime = new Util.RuntimeOptions{};
  return detachNasFileSystemWithOptions(request, runtime);
}

model DisableBackupPlanRequest {
  planId?: string(name='PlanId'),
  sourceType?: string(name='SourceType'),
  vaultId?: string(name='VaultId'),
}

model DisableBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableBackupPlanResponseBody(name='body'),
}

async function disableBackupPlanWithOptions(request: DisableBackupPlanRequest, runtime: Util.RuntimeOptions): DisableBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableBackupPlan(request: DisableBackupPlanRequest): DisableBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableBackupPlanWithOptions(request, runtime);
}

model DisableHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId'),
  planId?: string(name='PlanId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model DisableHanaBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model DisableHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableHanaBackupPlanResponseBody(name='body'),
}

async function disableHanaBackupPlanWithOptions(request: DisableHanaBackupPlanRequest, runtime: Util.RuntimeOptions): DisableHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DisableHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableHanaBackupPlan(request: DisableHanaBackupPlanRequest): DisableHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableHanaBackupPlanWithOptions(request, runtime);
}

model EnableBackupPlanRequest {
  planId?: string(name='PlanId'),
  sourceType?: string(name='SourceType'),
  vaultId?: string(name='VaultId'),
}

model EnableBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableBackupPlanResponseBody(name='body'),
}

async function enableBackupPlanWithOptions(request: EnableBackupPlanRequest, runtime: Util.RuntimeOptions): EnableBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableBackupPlan(request: EnableBackupPlanRequest): EnableBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableBackupPlanWithOptions(request, runtime);
}

model EnableHanaBackupPlanRequest {
  clusterId?: string(name='ClusterId'),
  planId?: string(name='PlanId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model EnableHanaBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model EnableHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableHanaBackupPlanResponseBody(name='body'),
}

async function enableHanaBackupPlanWithOptions(request: EnableHanaBackupPlanRequest, runtime: Util.RuntimeOptions): EnableHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'EnableHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableHanaBackupPlan(request: EnableHanaBackupPlanRequest): EnableHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableHanaBackupPlanWithOptions(request, runtime);
}

model ExecuteBackupPlanRequest {
  planId?: string(name='PlanId'),
  ruleId?: string(name='RuleId'),
  sourceType?: string(name='SourceType'),
  vaultId?: string(name='VaultId'),
}

model ExecuteBackupPlanResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecuteBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecuteBackupPlanResponseBody(name='body'),
}

async function executeBackupPlanWithOptions(request: ExecuteBackupPlanRequest, runtime: Util.RuntimeOptions): ExecuteBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ExecuteBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executeBackupPlan(request: ExecuteBackupPlanRequest): ExecuteBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return executeBackupPlanWithOptions(request, runtime);
}

model ExecutePolicy2Request {
  dataSourceId?: string(name='DataSourceId'),
  policyId?: string(name='PolicyId'),
  ruleId?: string(name='RuleId'),
  sourceType?: string(name='SourceType'),
}

model ExecutePolicy2ResponseBody = {
  code?: string(name='Code'),
  jobId?: string(name='JobId'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ExecutePolicy2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ExecutePolicy2ResponseBody(name='body'),
}

async function executePolicy2WithOptions(request: ExecutePolicy2Request, runtime: Util.RuntimeOptions): ExecutePolicy2Response {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.ruleId)) {
    query['RuleId'] = request.ruleId;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ExecutePolicy2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function executePolicy2(request: ExecutePolicy2Request): ExecutePolicy2Response {
  var runtime = new Util.RuntimeOptions{};
  return executePolicy2WithOptions(request, runtime);
}

model GenerateRamPolicyRequest {
  actionType?: string(name='ActionType'),
  requireBasePolicy?: boolean(name='RequireBasePolicy'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model GenerateRamPolicyResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  policyDocument?: string(name='PolicyDocument'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GenerateRamPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GenerateRamPolicyResponseBody(name='body'),
}

async function generateRamPolicyWithOptions(request: GenerateRamPolicyRequest, runtime: Util.RuntimeOptions): GenerateRamPolicyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.actionType)) {
    query['ActionType'] = request.actionType;
  }
  if (!Util.isUnset(request.requireBasePolicy)) {
    query['RequireBasePolicy'] = request.requireBasePolicy;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GenerateRamPolicy',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function generateRamPolicy(request: GenerateRamPolicyRequest): GenerateRamPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return generateRamPolicyWithOptions(request, runtime);
}

model GetObClusterConfigRequest {
  clusterId?: string(name='ClusterId'),
  key?: string(name='Key'),
}

model GetObClusterConfigResponseBody = {
  code?: string(name='Code'),
  config?: string(name='Config'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model GetObClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetObClusterConfigResponseBody(name='body'),
}

async function getObClusterConfigWithOptions(request: GetObClusterConfigRequest, runtime: Util.RuntimeOptions): GetObClusterConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetObClusterConfig',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getObClusterConfig(request: GetObClusterConfigRequest): GetObClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getObClusterConfigWithOptions(request, runtime);
}

model InstallBackupClientsRequest {
  instanceIds?: map[string]any(name='InstanceIds'),
}

model InstallBackupClientsShrinkRequest {
  instanceIdsShrink?: string(name='InstanceIds'),
}

model InstallBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model InstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: InstallBackupClientsResponseBody(name='body'),
}

async function installBackupClientsWithOptions(tmpReq: InstallBackupClientsRequest, runtime: Util.RuntimeOptions): InstallBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new InstallBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'InstallBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function installBackupClients(request: InstallBackupClientsRequest): InstallBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return installBackupClientsWithOptions(request, runtime);
}

model SearchHistoricalSnapshotsRequest {
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  query?: map[string]any(name='Query'),
  sourceType?: string(name='SourceType'),
}

model SearchHistoricalSnapshotsShrinkRequest {
  limit?: int32(name='Limit'),
  nextToken?: string(name='NextToken'),
  queryShrink?: string(name='Query'),
  sourceType?: string(name='SourceType'),
}

model SearchHistoricalSnapshotsResponseBody = {
  code?: string(name='Code'),
  limit?: int32(name='Limit'),
  message?: string(name='Message'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  snapshots?: {
    snapshot?: [ 
    {
      actualBytes?: long(name='ActualBytes'),
      actualItems?: long(name='ActualItems'),
      backupType?: string(name='BackupType'),
      bucket?: string(name='Bucket'),
      bytesDone?: long(name='BytesDone'),
      bytesTotal?: long(name='BytesTotal'),
      clientId?: string(name='ClientId'),
      completeTime?: long(name='CompleteTime'),
      createTime?: long(name='CreateTime'),
      createdTime?: long(name='CreatedTime'),
      errorFile?: string(name='ErrorFile'),
      expireTime?: long(name='ExpireTime'),
      fileSystemId?: string(name='FileSystemId'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      itemsDone?: long(name='ItemsDone'),
      itemsTotal?: long(name='ItemsTotal'),
      jobId?: string(name='JobId'),
      parentSnapshotHash?: string(name='ParentSnapshotHash'),
      path?: string(name='Path'),
      paths?: {
        path?: [ string ](name='Path')
      }(name='Paths'),
      prefix?: string(name='Prefix'),
      rangeEnd?: long(name='RangeEnd'),
      rangeStart?: long(name='RangeStart'),
      retention?: long(name='Retention'),
      snapshotHash?: string(name='SnapshotHash'),
      snapshotId?: string(name='SnapshotId'),
      sourceType?: string(name='SourceType'),
      startTime?: long(name='StartTime'),
      status?: string(name='Status'),
      tableName?: string(name='TableName'),
      updatedTime?: long(name='UpdatedTime'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Snapshot')
  }(name='Snapshots'),
  success?: boolean(name='Success'),
  totalCount?: int32(name='TotalCount'),
}

model SearchHistoricalSnapshotsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SearchHistoricalSnapshotsResponseBody(name='body'),
}

async function searchHistoricalSnapshotsWithOptions(tmpReq: SearchHistoricalSnapshotsRequest, runtime: Util.RuntimeOptions): SearchHistoricalSnapshotsResponse {
  Util.validateModel(tmpReq);
  var request = new SearchHistoricalSnapshotsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.query)) {
    request.queryShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.query, 'Query', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.limit)) {
    query['Limit'] = request.limit;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.queryShrink)) {
    query['Query'] = request.queryShrink;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SearchHistoricalSnapshots',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function searchHistoricalSnapshots(request: SearchHistoricalSnapshotsRequest): SearchHistoricalSnapshotsResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchHistoricalSnapshotsWithOptions(request, runtime);
}

model SetObClusterConfigRequest {
  clusterId?: string(name='ClusterId'),
  key?: string(name='Key'),
  value?: string(name='Value'),
}

model SetObClusterConfigResponseBody = {
  code?: string(name='Code'),
  config?: string(name='Config'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model SetObClusterConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: SetObClusterConfigResponseBody(name='body'),
}

async function setObClusterConfigWithOptions(request: SetObClusterConfigRequest, runtime: Util.RuntimeOptions): SetObClusterConfigResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'SetObClusterConfig',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function setObClusterConfig(request: SetObClusterConfigRequest): SetObClusterConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return setObClusterConfigWithOptions(request, runtime);
}

model StartHanaDatabaseAsyncRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  vaultId?: string(name='VaultId'),
}

model StartHanaDatabaseAsyncResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model StartHanaDatabaseAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StartHanaDatabaseAsyncResponseBody(name='body'),
}

async function startHanaDatabaseAsyncWithOptions(request: StartHanaDatabaseAsyncRequest, runtime: Util.RuntimeOptions): StartHanaDatabaseAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StartHanaDatabaseAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function startHanaDatabaseAsync(request: StartHanaDatabaseAsyncRequest): StartHanaDatabaseAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return startHanaDatabaseAsyncWithOptions(request, runtime);
}

model StopHanaDatabaseAsyncRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  vaultId?: string(name='VaultId'),
}

model StopHanaDatabaseAsyncResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model StopHanaDatabaseAsyncResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: StopHanaDatabaseAsyncResponseBody(name='body'),
}

async function stopHanaDatabaseAsyncWithOptions(request: StopHanaDatabaseAsyncRequest, runtime: Util.RuntimeOptions): StopHanaDatabaseAsyncResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'StopHanaDatabaseAsync',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function stopHanaDatabaseAsync(request: StopHanaDatabaseAsyncRequest): StopHanaDatabaseAsyncResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopHanaDatabaseAsyncWithOptions(request, runtime);
}

model UninstallBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds'),
  instanceIds?: map[string]any(name='InstanceIds'),
}

model UninstallBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds'),
  instanceIdsShrink?: string(name='InstanceIds'),
}

model UninstallBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UninstallBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallBackupClientsResponseBody(name='body'),
}

async function uninstallBackupClientsWithOptions(tmpReq: UninstallBackupClientsRequest, runtime: Util.RuntimeOptions): UninstallBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new UninstallBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallBackupClients(request: UninstallBackupClientsRequest): UninstallBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallBackupClientsWithOptions(request, runtime);
}

model UninstallClientRequest {
  clientId?: string(name='ClientId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model UninstallClientResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UninstallClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UninstallClientResponseBody(name='body'),
}

async function uninstallClientWithOptions(request: UninstallClientRequest, runtime: Util.RuntimeOptions): UninstallClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UninstallClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function uninstallClient(request: UninstallClientRequest): UninstallClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return uninstallClientWithOptions(request, runtime);
}

model UpdateBackupPlanRequest {
  detail?: map[string]any(name='Detail'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  options?: string(name='Options'),
  otsDetail?: OtsDetail(name='OtsDetail'),
  path?: [ string ](name='Path'),
  planId?: string(name='PlanId'),
  planName?: string(name='PlanName'),
  prefix?: string(name='Prefix'),
  retention?: long(name='Retention'),
  rule?: [ 
    {
      backupType?: string(name='BackupType'),
      destinationRegionId?: string(name='DestinationRegionId'),
      destinationRetention?: long(name='DestinationRetention'),
      disabled?: boolean(name='Disabled'),
      doCopy?: boolean(name='DoCopy'),
      retention?: long(name='Retention'),
      ruleName?: string(name='RuleName'),
      schedule?: string(name='Schedule'),
    }
  ](name='Rule'),
  schedule?: string(name='Schedule'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
  updatePaths?: boolean(name='UpdatePaths'),
  vaultId?: string(name='VaultId'),
}

model UpdateBackupPlanShrinkRequest {
  detailShrink?: string(name='Detail'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  options?: string(name='Options'),
  otsDetailShrink?: string(name='OtsDetail'),
  path?: [ string ](name='Path'),
  planId?: string(name='PlanId'),
  planName?: string(name='PlanName'),
  prefix?: string(name='Prefix'),
  retention?: long(name='Retention'),
  rule?: [ 
    {
      backupType?: string(name='BackupType'),
      destinationRegionId?: string(name='DestinationRegionId'),
      destinationRetention?: long(name='DestinationRetention'),
      disabled?: boolean(name='Disabled'),
      doCopy?: boolean(name='DoCopy'),
      retention?: long(name='Retention'),
      ruleName?: string(name='RuleName'),
      schedule?: string(name='Schedule'),
    }
  ](name='Rule'),
  schedule?: string(name='Schedule'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
  updatePaths?: boolean(name='UpdatePaths'),
  vaultId?: string(name='VaultId'),
}

model UpdateBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateBackupPlanResponseBody(name='body'),
}

async function updateBackupPlanWithOptions(tmpReq: UpdateBackupPlanRequest, runtime: Util.RuntimeOptions): UpdateBackupPlanResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateBackupPlanShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.detail)) {
    request.detailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.detail, 'Detail', 'json');
  }
  if (!Util.isUnset(tmpReq.otsDetail)) {
    request.otsDetailShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.otsDetail, 'OtsDetail', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.detailShrink)) {
    query['Detail'] = request.detailShrink;
  }
  if (!Util.isUnset(request.path)) {
    query['Path'] = request.path;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.prefix)) {
    query['Prefix'] = request.prefix;
  }
  if (!Util.isUnset(request.retention)) {
    query['Retention'] = request.retention;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.speedLimit)) {
    query['SpeedLimit'] = request.speedLimit;
  }
  if (!Util.isUnset(request.updatePaths)) {
    query['UpdatePaths'] = request.updatePaths;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.exclude)) {
    body['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    body['Include'] = request.include;
  }
  if (!Util.isUnset(request.options)) {
    body['Options'] = request.options;
  }
  if (!Util.isUnset(request.otsDetailShrink)) {
    body['OtsDetail'] = request.otsDetailShrink;
  }
  if (!Util.isUnset(request.rule)) {
    body['Rule'] = request.rule;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateBackupPlan(request: UpdateBackupPlanRequest): UpdateBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateBackupPlanWithOptions(request, runtime);
}

model UpdateClientSettingsRequest {
  clientId?: string(name='ClientId'),
  dataNetworkType?: string(name='DataNetworkType'),
  dataProxySetting?: string(name='DataProxySetting'),
  maxCpuCore?: int32(name='MaxCpuCore'),
  maxWorker?: int32(name='MaxWorker'),
  proxyHost?: string(name='ProxyHost'),
  proxyPassword?: string(name='ProxyPassword'),
  proxyPort?: int32(name='ProxyPort'),
  proxyUser?: string(name='ProxyUser'),
  resourceGroupId?: string(name='ResourceGroupId'),
  useHttps?: boolean(name='UseHttps'),
  vaultId?: string(name='VaultId'),
}

model UpdateClientSettingsResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateClientSettingsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateClientSettingsResponseBody(name='body'),
}

async function updateClientSettingsWithOptions(request: UpdateClientSettingsRequest, runtime: Util.RuntimeOptions): UpdateClientSettingsResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.dataNetworkType)) {
    query['DataNetworkType'] = request.dataNetworkType;
  }
  if (!Util.isUnset(request.dataProxySetting)) {
    query['DataProxySetting'] = request.dataProxySetting;
  }
  if (!Util.isUnset(request.maxCpuCore)) {
    query['MaxCpuCore'] = request.maxCpuCore;
  }
  if (!Util.isUnset(request.maxWorker)) {
    query['MaxWorker'] = request.maxWorker;
  }
  if (!Util.isUnset(request.proxyHost)) {
    query['ProxyHost'] = request.proxyHost;
  }
  if (!Util.isUnset(request.proxyPassword)) {
    query['ProxyPassword'] = request.proxyPassword;
  }
  if (!Util.isUnset(request.proxyPort)) {
    query['ProxyPort'] = request.proxyPort;
  }
  if (!Util.isUnset(request.proxyUser)) {
    query['ProxyUser'] = request.proxyUser;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useHttps)) {
    query['UseHttps'] = request.useHttps;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateClientSettings',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateClientSettings(request: UpdateClientSettingsRequest): UpdateClientSettingsResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateClientSettingsWithOptions(request, runtime);
}

model UpdateHanaBackupPlanRequest {
  backupPrefix?: string(name='BackupPrefix'),
  clusterId?: string(name='ClusterId'),
  planId?: string(name='PlanId'),
  planName?: string(name='PlanName'),
  resourceGroupId?: string(name='ResourceGroupId'),
  schedule?: string(name='Schedule'),
  vaultId?: string(name='VaultId'),
}

model UpdateHanaBackupPlanResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHanaBackupPlanResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaBackupPlanResponseBody(name='body'),
}

async function updateHanaBackupPlanWithOptions(request: UpdateHanaBackupPlanRequest, runtime: Util.RuntimeOptions): UpdateHanaBackupPlanResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.backupPrefix)) {
    query['BackupPrefix'] = request.backupPrefix;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.planId)) {
    query['PlanId'] = request.planId;
  }
  if (!Util.isUnset(request.planName)) {
    query['PlanName'] = request.planName;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaBackupPlan',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHanaBackupPlan(request: UpdateHanaBackupPlanRequest): UpdateHanaBackupPlanResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaBackupPlanWithOptions(request, runtime);
}

model UpdateHanaBackupSettingRequest {
  catalogBackupParameterFile?: string(name='CatalogBackupParameterFile'),
  catalogBackupUsingBackint?: boolean(name='CatalogBackupUsingBackint'),
  clusterId?: string(name='ClusterId'),
  dataBackupParameterFile?: string(name='DataBackupParameterFile'),
  databaseName?: string(name='DatabaseName'),
  enableAutoLogBackup?: boolean(name='EnableAutoLogBackup'),
  logBackupParameterFile?: string(name='LogBackupParameterFile'),
  logBackupTimeout?: long(name='LogBackupTimeout'),
  logBackupUsingBackint?: boolean(name='LogBackupUsingBackint'),
  vaultId?: string(name='VaultId'),
}

model UpdateHanaBackupSettingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHanaBackupSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaBackupSettingResponseBody(name='body'),
}

async function updateHanaBackupSettingWithOptions(request: UpdateHanaBackupSettingRequest, runtime: Util.RuntimeOptions): UpdateHanaBackupSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.catalogBackupParameterFile)) {
    query['CatalogBackupParameterFile'] = request.catalogBackupParameterFile;
  }
  if (!Util.isUnset(request.catalogBackupUsingBackint)) {
    query['CatalogBackupUsingBackint'] = request.catalogBackupUsingBackint;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.dataBackupParameterFile)) {
    query['DataBackupParameterFile'] = request.dataBackupParameterFile;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.enableAutoLogBackup)) {
    query['EnableAutoLogBackup'] = request.enableAutoLogBackup;
  }
  if (!Util.isUnset(request.logBackupParameterFile)) {
    query['LogBackupParameterFile'] = request.logBackupParameterFile;
  }
  if (!Util.isUnset(request.logBackupTimeout)) {
    query['LogBackupTimeout'] = request.logBackupTimeout;
  }
  if (!Util.isUnset(request.logBackupUsingBackint)) {
    query['LogBackupUsingBackint'] = request.logBackupUsingBackint;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaBackupSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHanaBackupSetting(request: UpdateHanaBackupSettingRequest): UpdateHanaBackupSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaBackupSettingWithOptions(request, runtime);
}

model UpdateHanaInstanceRequest {
  alertSetting?: string(name='AlertSetting'),
  clusterId?: string(name='ClusterId'),
  hanaName?: string(name='HanaName'),
  host?: string(name='Host'),
  instanceNumber?: int32(name='InstanceNumber'),
  password?: string(name='Password'),
  resourceGroupId?: string(name='ResourceGroupId'),
  useSsl?: boolean(name='UseSsl'),
  userName?: string(name='UserName'),
  validateCertificate?: boolean(name='ValidateCertificate'),
  vaultId?: string(name='VaultId'),
}

model UpdateHanaInstanceResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHanaInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaInstanceResponseBody(name='body'),
}

async function updateHanaInstanceWithOptions(request: UpdateHanaInstanceRequest, runtime: Util.RuntimeOptions): UpdateHanaInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.alertSetting)) {
    query['AlertSetting'] = request.alertSetting;
  }
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.hanaName)) {
    query['HanaName'] = request.hanaName;
  }
  if (!Util.isUnset(request.host)) {
    query['Host'] = request.host;
  }
  if (!Util.isUnset(request.instanceNumber)) {
    query['InstanceNumber'] = request.instanceNumber;
  }
  if (!Util.isUnset(request.password)) {
    query['Password'] = request.password;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.useSsl)) {
    query['UseSsl'] = request.useSsl;
  }
  if (!Util.isUnset(request.userName)) {
    query['UserName'] = request.userName;
  }
  if (!Util.isUnset(request.validateCertificate)) {
    query['ValidateCertificate'] = request.validateCertificate;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaInstance',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHanaInstance(request: UpdateHanaInstanceRequest): UpdateHanaInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaInstanceWithOptions(request, runtime);
}

model UpdateHanaRetentionSettingRequest {
  clusterId?: string(name='ClusterId'),
  databaseName?: string(name='DatabaseName'),
  disabled?: boolean(name='Disabled'),
  retentionDays?: long(name='RetentionDays'),
  schedule?: string(name='Schedule'),
  vaultId?: string(name='VaultId'),
}

model UpdateHanaRetentionSettingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateHanaRetentionSettingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateHanaRetentionSettingResponseBody(name='body'),
}

async function updateHanaRetentionSettingWithOptions(request: UpdateHanaRetentionSettingRequest, runtime: Util.RuntimeOptions): UpdateHanaRetentionSettingResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clusterId)) {
    query['ClusterId'] = request.clusterId;
  }
  if (!Util.isUnset(request.databaseName)) {
    query['DatabaseName'] = request.databaseName;
  }
  if (!Util.isUnset(request.disabled)) {
    query['Disabled'] = request.disabled;
  }
  if (!Util.isUnset(request.retentionDays)) {
    query['RetentionDays'] = request.retentionDays;
  }
  if (!Util.isUnset(request.schedule)) {
    query['Schedule'] = request.schedule;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateHanaRetentionSetting',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateHanaRetentionSetting(request: UpdateHanaRetentionSettingRequest): UpdateHanaRetentionSettingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateHanaRetentionSettingWithOptions(request, runtime);
}

model UpdatePolicy2Request {
  policyDescription?: string(name='PolicyDescription'),
  policyId?: string(name='PolicyId', description='required parameters'),
  policyName?: string(name='PolicyName'),
  rules?: [ 
    {
      archiveDays?: long(name='ArchiveDays'),
      archiveVaultId?: string(name='ArchiveVaultId', description='Transition'),
      backupType?: string(name='BackupType', description='Backup Rule (COMPLETE: Complete backup type, INCREMENTAL: Incremental backup type, DIFFERENTIAL: Differential backup type, LOG: Transaction log backup type, INDEX: 不备份数据，只对元数据建立索引, ARCHIVE: 归档, ARCHIVE_BY_SEARCH: 根据搜索结果进行归档)'),
      coldArchiveDays?: long(name='ColdArchiveDays'),
      continuous?: boolean(name='Continuous'),
      cycles?: long(name='Cycles'),
      replicationRegionId?: string(name='ReplicationRegionId', description='Replication'),
      replicationVaultId?: string(name='ReplicationVaultId'),
      retention?: long(name='Retention', description='Expiration'),
      retentionRules?: [ 
        {
          retention?: long(name='Retention'),
          scheduleType?: string(name='ScheduleType'),
          whichSnapshot?: long(name='WhichSnapshot'),
        }
      ](name='RetentionRules'),
      ruleId?: string(name='RuleId'),
      ruleType?: string(name='RuleType', description='TRANSITION: 过渡类规则, BACKUP: 定时类规则, REPLICATION: 镜像类规则'),
      schedule?: string(name='Schedule'),
      selector?: {
        key?: string(name='Key'),
        value?: string(name='Value'),
      }(name='Selector'),
      vaultId?: string(name='VaultId'),
    }
  ](name='Rules'),
}

model UpdatePolicy2ShrinkRequest {
  policyDescription?: string(name='PolicyDescription'),
  policyId?: string(name='PolicyId', description='required parameters'),
  policyName?: string(name='PolicyName'),
  rulesShrink?: string(name='Rules'),
}

model UpdatePolicy2ResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePolicy2Response = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePolicy2ResponseBody(name='body'),
}

async function updatePolicy2WithOptions(tmpReq: UpdatePolicy2Request, runtime: Util.RuntimeOptions): UpdatePolicy2Response {
  Util.validateModel(tmpReq);
  var request = new UpdatePolicy2ShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.rules)) {
    request.rulesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.rules, 'Rules', 'json');
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.policyDescription)) {
    body['PolicyDescription'] = request.policyDescription;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  if (!Util.isUnset(request.policyName)) {
    body['PolicyName'] = request.policyName;
  }
  if (!Util.isUnset(request.rulesShrink)) {
    body['Rules'] = request.rulesShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePolicy2',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePolicy2(request: UpdatePolicy2Request): UpdatePolicy2Response {
  var runtime = new Util.RuntimeOptions{};
  return updatePolicy2WithOptions(request, runtime);
}

model UpdatePolicyBindingRequest {
  advancedOptions?: {
    udmDetail?: {
      appConsistent?: boolean(name='AppConsistent'),
      diskIdList?: [ string ](name='DiskIdList'),
      enableFsFreeze?: boolean(name='EnableFsFreeze'),
      enableWriters?: boolean(name='EnableWriters'),
      excludeDiskIdList?: [ string ](name='ExcludeDiskIdList'),
      postScriptPath?: string(name='PostScriptPath'),
      preScriptPath?: string(name='PreScriptPath'),
      ramRoleName?: string(name='RamRoleName'),
      snapshotGroup?: boolean(name='SnapshotGroup'),
      timeoutInSeconds?: long(name='TimeoutInSeconds'),
    }(name='UdmDetail'),
  }(name='AdvancedOptions'),
  dataSourceId?: string(name='DataSourceId'),
  disabled?: boolean(name='Disabled'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  policyBindingDescription?: string(name='PolicyBindingDescription'),
  policyId?: string(name='PolicyId'),
  source?: string(name='Source'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
}

model UpdatePolicyBindingShrinkRequest {
  advancedOptionsShrink?: string(name='AdvancedOptions'),
  dataSourceId?: string(name='DataSourceId'),
  disabled?: boolean(name='Disabled'),
  exclude?: string(name='Exclude'),
  include?: string(name='Include'),
  policyBindingDescription?: string(name='PolicyBindingDescription'),
  policyId?: string(name='PolicyId'),
  source?: string(name='Source'),
  sourceType?: string(name='SourceType'),
  speedLimit?: string(name='SpeedLimit'),
}

model UpdatePolicyBindingResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdatePolicyBindingResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePolicyBindingResponseBody(name='body'),
}

async function updatePolicyBindingWithOptions(tmpReq: UpdatePolicyBindingRequest, runtime: Util.RuntimeOptions): UpdatePolicyBindingResponse {
  Util.validateModel(tmpReq);
  var request = new UpdatePolicyBindingShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.advancedOptions)) {
    request.advancedOptionsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.advancedOptions, 'AdvancedOptions', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.advancedOptionsShrink)) {
    query['AdvancedOptions'] = request.advancedOptionsShrink;
  }
  if (!Util.isUnset(request.disabled)) {
    query['Disabled'] = request.disabled;
  }
  if (!Util.isUnset(request.exclude)) {
    query['Exclude'] = request.exclude;
  }
  if (!Util.isUnset(request.include)) {
    query['Include'] = request.include;
  }
  if (!Util.isUnset(request.policyBindingDescription)) {
    query['PolicyBindingDescription'] = request.policyBindingDescription;
  }
  if (!Util.isUnset(request.source)) {
    query['Source'] = request.source;
  }
  if (!Util.isUnset(request.sourceType)) {
    query['SourceType'] = request.sourceType;
  }
  if (!Util.isUnset(request.speedLimit)) {
    query['SpeedLimit'] = request.speedLimit;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.dataSourceId)) {
    body['DataSourceId'] = request.dataSourceId;
  }
  if (!Util.isUnset(request.policyId)) {
    body['PolicyId'] = request.policyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePolicyBinding',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePolicyBinding(request: UpdatePolicyBindingRequest): UpdatePolicyBindingResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePolicyBindingWithOptions(request, runtime);
}

model UpdateUdmEcsInstanceGroupRequest {
  instanceGroupId?: string(name='InstanceGroupId', description='required parameters'),
  instanceGroupName?: string(name='InstanceGroupName', description='optional parameters'),
  instanceIds?: [ string ](name='InstanceIds'),
  diskIdMap?: map[string]any(name='diskIdMap'),
  excludeDiskIdMap?: map[string]any(name='excludeDiskIdMap'),
}

model UpdateUdmEcsInstanceGroupShrinkRequest {
  instanceGroupId?: string(name='InstanceGroupId', description='required parameters'),
  instanceGroupName?: string(name='InstanceGroupName', description='optional parameters'),
  instanceIds?: [ string ](name='InstanceIds'),
  diskIdMapShrink?: string(name='diskIdMap'),
  excludeDiskIdMapShrink?: string(name='excludeDiskIdMap'),
}

model UpdateUdmEcsInstanceGroupResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateUdmEcsInstanceGroupResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateUdmEcsInstanceGroupResponseBody(name='body'),
}

async function updateUdmEcsInstanceGroupWithOptions(tmpReq: UpdateUdmEcsInstanceGroupRequest, runtime: Util.RuntimeOptions): UpdateUdmEcsInstanceGroupResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateUdmEcsInstanceGroupShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.diskIdMap)) {
    request.diskIdMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.diskIdMap, 'diskIdMap', 'json');
  }
  if (!Util.isUnset(tmpReq.excludeDiskIdMap)) {
    request.excludeDiskIdMapShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.excludeDiskIdMap, 'excludeDiskIdMap', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.diskIdMapShrink)) {
    query['diskIdMap'] = request.diskIdMapShrink;
  }
  if (!Util.isUnset(request.excludeDiskIdMapShrink)) {
    query['excludeDiskIdMap'] = request.excludeDiskIdMapShrink;
  }
  var body : map[string]any= {};
  if (!Util.isUnset(request.instanceGroupId)) {
    body['InstanceGroupId'] = request.instanceGroupId;
  }
  if (!Util.isUnset(request.instanceGroupName)) {
    body['InstanceGroupName'] = request.instanceGroupName;
  }
  if (!Util.isUnset(request.instanceIds)) {
    body['InstanceIds'] = request.instanceIds;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateUdmEcsInstanceGroup',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateUdmEcsInstanceGroup(request: UpdateUdmEcsInstanceGroupRequest): UpdateUdmEcsInstanceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateUdmEcsInstanceGroupWithOptions(request, runtime);
}

model UpdateVaultRequest {
  description?: string(name='Description'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
  vaultName?: string(name='VaultName'),
}

model UpdateVaultResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model UpdateVaultResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateVaultResponseBody(name='body'),
}

async function updateVaultWithOptions(request: UpdateVaultRequest, runtime: Util.RuntimeOptions): UpdateVaultResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.description)) {
    query['Description'] = request.description;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  if (!Util.isUnset(request.vaultName)) {
    query['VaultName'] = request.vaultName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateVault',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateVault(request: UpdateVaultRequest): UpdateVaultResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateVaultWithOptions(request, runtime);
}

model UpgradeBackupClientsRequest {
  clientIds?: map[string]any(name='ClientIds'),
  instanceIds?: map[string]any(name='InstanceIds'),
}

model UpgradeBackupClientsShrinkRequest {
  clientIdsShrink?: string(name='ClientIds'),
  instanceIdsShrink?: string(name='InstanceIds'),
}

model UpgradeBackupClientsResponseBody = {
  code?: string(name='Code'),
  instanceStatuses?: [ 
    {
      errorCode?: string(name='ErrorCode'),
      instanceId?: string(name='InstanceId'),
      validInstance?: boolean(name='ValidInstance'),
    }
  ](name='InstanceStatuses'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UpgradeBackupClientsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeBackupClientsResponseBody(name='body'),
}

async function upgradeBackupClientsWithOptions(tmpReq: UpgradeBackupClientsRequest, runtime: Util.RuntimeOptions): UpgradeBackupClientsResponse {
  Util.validateModel(tmpReq);
  var request = new UpgradeBackupClientsShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.clientIds)) {
    request.clientIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.clientIds, 'ClientIds', 'json');
  }
  if (!Util.isUnset(tmpReq.instanceIds)) {
    request.instanceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.instanceIds, 'InstanceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.clientIdsShrink)) {
    query['ClientIds'] = request.clientIdsShrink;
  }
  if (!Util.isUnset(request.instanceIdsShrink)) {
    query['InstanceIds'] = request.instanceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeBackupClients',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeBackupClients(request: UpgradeBackupClientsRequest): UpgradeBackupClientsResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeBackupClientsWithOptions(request, runtime);
}

model UpgradeClientRequest {
  clientId?: string(name='ClientId'),
  resourceGroupId?: string(name='ResourceGroupId'),
  vaultId?: string(name='VaultId'),
}

model UpgradeClientResponseBody = {
  code?: string(name='Code'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
  taskId?: string(name='TaskId'),
}

model UpgradeClientResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpgradeClientResponseBody(name='body'),
}

async function upgradeClientWithOptions(request: UpgradeClientRequest, runtime: Util.RuntimeOptions): UpgradeClientResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientId)) {
    query['ClientId'] = request.clientId;
  }
  if (!Util.isUnset(request.resourceGroupId)) {
    query['ResourceGroupId'] = request.resourceGroupId;
  }
  if (!Util.isUnset(request.vaultId)) {
    query['VaultId'] = request.vaultId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpgradeClient',
    version = '2017-09-08',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function upgradeClient(request: UpgradeClientRequest): UpgradeClientResponse {
  var runtime = new Util.RuntimeOptions{};
  return upgradeClientWithOptions(request, runtime);
}

