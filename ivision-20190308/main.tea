/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = 'regional';
  
  checkConfig(config);
  @endpoint = getEndpoint('ivision', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model CreateFaceGroupRequest {
  ownerId?: long(name='OwnerId'),
  name?: string(name='Name'),
}

model CreateFaceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  groupId?: string(name='GroupId'),
}

model CreateFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFaceGroupResponseBody(name='body'),
}

async function createFaceGroupWithOptions(request: CreateFaceGroupRequest, runtime: Util.RuntimeOptions): CreateFaceGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CreateFaceGroup', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function createFaceGroup(request: CreateFaceGroupRequest): CreateFaceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFaceGroupWithOptions(request, runtime);
}

model CreateFilePredictRequest {
  algorithmCode?: string(name='AlgorithmCode'),
  resourceUrl?: string(name='ResourceUrl'),
  pushConfig?: string(name='PushConfig'),
  decryptConfig?: string(name='DecryptConfig'),
  clientToken?: string(name='ClientToken'),
  outputOss?: string(name='OutputOss'),
  outputRegion?: string(name='OutputRegion'),
}

model CreateFilePredictResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model CreateFilePredictResponse = {
  headers: map[string]string(name='headers'),
  body: CreateFilePredictResponseBody(name='body'),
}

async function createFilePredictWithOptions(request: CreateFilePredictRequest, runtime: Util.RuntimeOptions): CreateFilePredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateFilePredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createFilePredict(request: CreateFilePredictRequest): CreateFilePredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return createFilePredictWithOptions(request, runtime);
}

model CreateStreamPredictRequest {
  ownerId?: long(name='OwnerId'),
  clientToken?: string(name='ClientToken'),
  streamType?: string(name='StreamType'),
  streamId?: string(name='StreamId'),
  predictTemplateId?: string(name='PredictTemplateId'),
  modelIds?: string(name='ModelIds'),
  probabilityThresholds?: string(name='ProbabilityThresholds'),
  detectIntervals?: string(name='DetectIntervals'),
  output?: string(name='Output'),
  notify?: string(name='Notify'),
  autoStart?: string(name='AutoStart'),
  faceGroupId?: string(name='FaceGroupId'),
  modelUserData?: string(name='ModelUserData'),
}

model CreateStreamPredictResponseBody = {
  requestId?: string(name='RequestId'),
  predictId?: string(name='PredictId'),
}

model CreateStreamPredictResponse = {
  headers: map[string]string(name='headers'),
  body: CreateStreamPredictResponseBody(name='body'),
}

async function createStreamPredictWithOptions(request: CreateStreamPredictRequest, runtime: Util.RuntimeOptions): CreateStreamPredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateStreamPredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createStreamPredict(request: CreateStreamPredictRequest): CreateStreamPredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return createStreamPredictWithOptions(request, runtime);
}

model DeleteFaceGroupRequest {
  ownerId?: long(name='OwnerId'),
  groupId?: string(name='GroupId'),
}

model DeleteFaceGroupResponseBody = {
  requestId?: string(name='RequestId'),
  groupId?: string(name='GroupId'),
}

model DeleteFaceGroupResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFaceGroupResponseBody(name='body'),
}

async function deleteFaceGroupWithOptions(request: DeleteFaceGroupRequest, runtime: Util.RuntimeOptions): DeleteFaceGroupResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DeleteFaceGroup', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function deleteFaceGroup(request: DeleteFaceGroupRequest): DeleteFaceGroupResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFaceGroupWithOptions(request, runtime);
}

model DeleteFilePredictRequest {
  taskId?: string(name='TaskId'),
}

model DeleteFilePredictResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    taskId?: string(name='TaskId'),
  }(name='Data'),
  code?: string(name='Code'),
}

model DeleteFilePredictResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteFilePredictResponseBody(name='body'),
}

async function deleteFilePredictWithOptions(request: DeleteFilePredictRequest, runtime: Util.RuntimeOptions): DeleteFilePredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteFilePredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteFilePredict(request: DeleteFilePredictRequest): DeleteFilePredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteFilePredictWithOptions(request, runtime);
}

model DeleteStreamPredictRequest {
  ownerId?: long(name='OwnerId'),
  predictId?: string(name='PredictId'),
}

model DeleteStreamPredictResponseBody = {
  requestId?: string(name='RequestId'),
  predictId?: string(name='PredictId'),
}

model DeleteStreamPredictResponse = {
  headers: map[string]string(name='headers'),
  body: DeleteStreamPredictResponseBody(name='body'),
}

async function deleteStreamPredictWithOptions(request: DeleteStreamPredictRequest, runtime: Util.RuntimeOptions): DeleteStreamPredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DeleteStreamPredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function deleteStreamPredict(request: DeleteStreamPredictRequest): DeleteStreamPredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteStreamPredictWithOptions(request, runtime);
}

model DescribeFaceGroupsRequest {
  ownerId?: long(name='OwnerId'),
  nextPageToken?: string(name='NextPageToken'),
  currentPage?: long(name='CurrentPage'),
  pageSize?: long(name='PageSize'),
}

model DescribeFaceGroupsResponseBody = {
  totalNum?: long(name='TotalNum'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  currentPage?: long(name='CurrentPage'),
  nextPageToken?: string(name='NextPageToken'),
  groups?: [ 
    {
      creationTime?: string(name='CreationTime'),
      groupId?: string(name='GroupId'),
      name?: string(name='Name'),
    }
  ](name='Groups'),
}

model DescribeFaceGroupsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeFaceGroupsResponseBody(name='body'),
}

async function describeFaceGroupsWithOptions(request: DescribeFaceGroupsRequest, runtime: Util.RuntimeOptions): DescribeFaceGroupsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('DescribeFaceGroups', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function describeFaceGroups(request: DescribeFaceGroupsRequest): DescribeFaceGroupsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeFaceGroupsWithOptions(request, runtime);
}

model DescribeStreamPredictResultRequest {
  ownerId?: long(name='OwnerId'),
  predictId?: string(name='PredictId'),
  modelId?: string(name='ModelId'),
  startTime?: string(name='StartTime'),
  endTime?: string(name='EndTime'),
  probabilityThreshold?: string(name='ProbabilityThreshold'),
  nextPageToken?: string(name='NextPageToken'),
  currentPage?: long(name='CurrentPage'),
  pageSize?: long(name='PageSize'),
}

model DescribeStreamPredictResultResponseBody = {
  streamPredictDatas?: [ 
    {
      status?: string(name='Status'),
      predictResult?: string(name='PredictResult'),
      predictId?: string(name='PredictId'),
      predictTime?: string(name='PredictTime'),
      dataUrl?: string(name='DataUrl'),
      timestamp?: long(name='Timestamp'),
      modelId?: string(name='ModelId'),
    }
  ](name='StreamPredictDatas'),
  totalNum?: long(name='TotalNum'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  currentPage?: long(name='CurrentPage'),
  nextPageToken?: string(name='NextPageToken'),
}

model DescribeStreamPredictResultResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStreamPredictResultResponseBody(name='body'),
}

async function describeStreamPredictResultWithOptions(request: DescribeStreamPredictResultRequest, runtime: Util.RuntimeOptions): DescribeStreamPredictResultResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeStreamPredictResult', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeStreamPredictResult(request: DescribeStreamPredictResultRequest): DescribeStreamPredictResultResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStreamPredictResultWithOptions(request, runtime);
}

model DescribeStreamPredictsRequest {
  ownerId?: long(name='OwnerId'),
  predictIds?: string(name='PredictIds'),
  modelId?: string(name='ModelId'),
  nextPageToken?: string(name='NextPageToken'),
  currentPage?: long(name='CurrentPage'),
  pageSize?: long(name='PageSize'),
}

model DescribeStreamPredictsResponseBody = {
  totalNum?: long(name='TotalNum'),
  pageSize?: long(name='PageSize'),
  requestId?: string(name='RequestId'),
  currentPage?: long(name='CurrentPage'),
  nextPageToken?: string(name='NextPageToken'),
  streamPredicts?: [ 
    {
      creationTime?: string(name='CreationTime'),
      status?: string(name='Status'),
      notify?: string(name='Notify'),
      predictId?: string(name='PredictId'),
      modelUserData?: string(name='ModelUserData'),
      output?: string(name='Output'),
      predictTemplateId?: string(name='PredictTemplateId'),
      streamId?: string(name='StreamId'),
      autoStart?: string(name='AutoStart'),
      probabilityThresholds?: string(name='ProbabilityThresholds'),
      detectIntervals?: string(name='DetectIntervals'),
      streamType?: string(name='StreamType'),
      userData?: string(name='UserData'),
      modelIds?: string(name='ModelIds'),
      faceGroupId?: string(name='FaceGroupId'),
    }
  ](name='StreamPredicts'),
}

model DescribeStreamPredictsResponse = {
  headers: map[string]string(name='headers'),
  body: DescribeStreamPredictsResponseBody(name='body'),
}

async function describeStreamPredictsWithOptions(request: DescribeStreamPredictsRequest, runtime: Util.RuntimeOptions): DescribeStreamPredictsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('DescribeStreamPredicts', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function describeStreamPredicts(request: DescribeStreamPredictsRequest): DescribeStreamPredictsResponse {
  var runtime = new Util.RuntimeOptions{};
  return describeStreamPredictsWithOptions(request, runtime);
}

model GetAlgorithmDetailRequest {
  algorithmCode?: string(name='AlgorithmCode'),
}

model GetAlgorithmDetailResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    algorithmName?: string(name='AlgorithmName'),
    deployRegion?: string(name='DeployRegion'),
    currentMonthCount?: int32(name='CurrentMonthCount'),
    algorithmCode?: string(name='AlgorithmCode'),
    apiDocUrl?: string(name='ApiDocUrl'),
    currentMonthSuccessCount?: int32(name='CurrentMonthSuccessCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetAlgorithmDetailResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgorithmDetailResponseBody(name='body'),
}

async function getAlgorithmDetailWithOptions(request: GetAlgorithmDetailRequest, runtime: Util.RuntimeOptions): GetAlgorithmDetailResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAlgorithmDetail', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAlgorithmDetail(request: GetAlgorithmDetailRequest): GetAlgorithmDetailResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlgorithmDetailWithOptions(request, runtime);
}

model GetAlgorithmHistogramsRequest {
  algorithmCode?: string(name='AlgorithmCode'),
  startDate?: string(name='StartDate'),
  endDate?: string(name='EndDate'),
  aggregateType?: string(name='AggregateType'),
}

model GetAlgorithmHistogramsResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    failureCount?: int32(name='FailureCount'),
    successCount?: int32(name='SuccessCount'),
    histograms?: [ 
      {
        time?: string(name='Time'),
        failureCount?: int32(name='FailureCount'),
        successCount?: int32(name='SuccessCount'),
      }
    ](name='Histograms'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model GetAlgorithmHistogramsResponse = {
  headers: map[string]string(name='headers'),
  body: GetAlgorithmHistogramsResponseBody(name='body'),
}

async function getAlgorithmHistogramsWithOptions(request: GetAlgorithmHistogramsRequest, runtime: Util.RuntimeOptions): GetAlgorithmHistogramsResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetAlgorithmHistograms', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getAlgorithmHistograms(request: GetAlgorithmHistogramsRequest): GetAlgorithmHistogramsResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlgorithmHistogramsWithOptions(request, runtime);
}

model ImagePredictRequest {
  ownerId?: long(name='OwnerId'),
  modelId?: string(name='ModelId'),
  dataUrl?: string(name='DataUrl'),
}

model ImagePredictResponseBody = {
  requestId?: string(name='RequestId'),
  imagePredict?: {
    status?: string(name='Status'),
    predictResult?: string(name='PredictResult'),
    predictId?: string(name='PredictId'),
    predictTime?: string(name='PredictTime'),
    dataUrl?: string(name='DataUrl'),
    code?: string(name='Code'),
    message?: string(name='Message'),
    modelId?: string(name='ModelId'),
  }(name='ImagePredict'),
}

model ImagePredictResponse = {
  headers: map[string]string(name='headers'),
  body: ImagePredictResponseBody(name='body'),
}

async function imagePredictWithOptions(request: ImagePredictRequest, runtime: Util.RuntimeOptions): ImagePredictResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ImagePredict', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function imagePredict(request: ImagePredictRequest): ImagePredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return imagePredictWithOptions(request, runtime);
}

model ListMyAlgorithmRequest {
  algorithmName?: string(name='AlgorithmName'),
  pageSize?: int32(name='PageSize'),
  pageNumber?: int32(name='PageNumber'),
}

model ListMyAlgorithmResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    algorithmList?: [ 
      {
        algorithmName?: string(name='AlgorithmName'),
        deployRegion?: string(name='DeployRegion'),
        currentMonthCount?: int32(name='CurrentMonthCount'),
        algorithmCode?: string(name='AlgorithmCode'),
        apiDocUrl?: string(name='ApiDocUrl'),
        yesterdayCount?: int32(name='YesterdayCount'),
        algorithmOrder?: int32(name='AlgorithmOrder'),
      }
    ](name='AlgorithmList'),
    pageSize?: int32(name='PageSize'),
    pageNumber?: int32(name='PageNumber'),
    totalCount?: int32(name='TotalCount'),
  }(name='Data'),
  code?: string(name='Code'),
  success?: boolean(name='Success'),
}

model ListMyAlgorithmResponse = {
  headers: map[string]string(name='headers'),
  body: ListMyAlgorithmResponseBody(name='body'),
}

async function listMyAlgorithmWithOptions(request: ListMyAlgorithmRequest, runtime: Util.RuntimeOptions): ListMyAlgorithmResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListMyAlgorithm', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listMyAlgorithm(request: ListMyAlgorithmRequest): ListMyAlgorithmResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMyAlgorithmWithOptions(request, runtime);
}

model PredictPictureRequest {
  algorithmCode?: string(name='AlgorithmCode'),
  ossPath?: string(name='OssPath'),
  resourceUrl?: string(name='ResourceUrl'),
  customerData?: string(name='CustomerData'),
  imageUrl?: string(name='ImageUrl'),
}

model PredictPictureResponseBody = {
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  data?: {
    predictResult?: string(name='PredictResult'),
  }(name='Data'),
  code?: string(name='Code'),
}

model PredictPictureResponse = {
  headers: map[string]string(name='headers'),
  body: PredictPictureResponseBody(name='body'),
}

async function predictPictureWithOptions(request: PredictPictureRequest, runtime: Util.RuntimeOptions): PredictPictureResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('PredictPicture', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function predictPicture(request: PredictPictureRequest): PredictPictureResponse {
  var runtime = new Util.RuntimeOptions{};
  return predictPictureWithOptions(request, runtime);
}

model RegisterFaceRequest {
  ownerId?: long(name='OwnerId'),
  groupId?: string(name='GroupId'),
  dataType?: string(name='DataType'),
  content?: string(name='Content'),
}

model RegisterFaceResponseBody = {
  requestId?: string(name='RequestId'),
  faces?: [ 
    {
      faceToken?: string(name='FaceToken'),
      rect?: {
        top?: int32(name='Top'),
        width?: int32(name='Width'),
        height?: int32(name='Height'),
        left?: int32(name='Left'),
      }(name='Rect'),
    }
  ](name='Faces'),
  groupId?: string(name='GroupId'),
}

model RegisterFaceResponse = {
  headers: map[string]string(name='headers'),
  body: RegisterFaceResponseBody(name='body'),
}

async function registerFaceWithOptions(request: RegisterFaceRequest, runtime: Util.RuntimeOptions): RegisterFaceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('RegisterFace', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function registerFace(request: RegisterFaceRequest): RegisterFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return registerFaceWithOptions(request, runtime);
}

model SearchFaceRequest {
  ownerId?: long(name='OwnerId'),
  groupId?: string(name='GroupId'),
  probabilityThreshold?: float(name='ProbabilityThreshold'),
  count?: int32(name='Count'),
  dataType?: string(name='DataType'),
  content?: string(name='Content'),
}

model SearchFaceResponseBody = {
  rect?: {
    top?: int32(name='Top'),
    width?: int32(name='Width'),
    height?: int32(name='Height'),
    left?: int32(name='Left'),
  }(name='Rect'),
  requestId?: string(name='RequestId'),
  faceResults?: [ 
    {
      faceToken?: string(name='FaceToken'),
      probability?: float(name='Probability'),
    }
  ](name='FaceResults'),
  groupId?: string(name='GroupId'),
}

model SearchFaceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchFaceResponseBody(name='body'),
}

async function searchFaceWithOptions(request: SearchFaceRequest, runtime: Util.RuntimeOptions): SearchFaceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('SearchFace', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function searchFace(request: SearchFaceRequest): SearchFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchFaceWithOptions(request, runtime);
}

model StartStreamPredictRequest {
  ownerId?: long(name='OwnerId'),
  predictId?: string(name='PredictId'),
}

model StartStreamPredictResponseBody = {
  requestId?: string(name='RequestId'),
  predictId?: string(name='PredictId'),
}

model StartStreamPredictResponse = {
  headers: map[string]string(name='headers'),
  body: StartStreamPredictResponseBody(name='body'),
}

async function startStreamPredictWithOptions(request: StartStreamPredictRequest, runtime: Util.RuntimeOptions): StartStreamPredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StartStreamPredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function startStreamPredict(request: StartStreamPredictRequest): StartStreamPredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return startStreamPredictWithOptions(request, runtime);
}

model StopStreamPredictRequest {
  ownerId?: long(name='OwnerId'),
  predictId?: string(name='PredictId'),
}

model StopStreamPredictResponseBody = {
  requestId?: string(name='RequestId'),
  predictId?: string(name='PredictId'),
}

model StopStreamPredictResponse = {
  headers: map[string]string(name='headers'),
  body: StopStreamPredictResponseBody(name='body'),
}

async function stopStreamPredictWithOptions(request: StopStreamPredictRequest, runtime: Util.RuntimeOptions): StopStreamPredictResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('StopStreamPredict', '2019-03-08', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function stopStreamPredict(request: StopStreamPredictRequest): StopStreamPredictResponse {
  var runtime = new Util.RuntimeOptions{};
  return stopStreamPredictWithOptions(request, runtime);
}

model UnregisterFaceRequest {
  ownerId?: long(name='OwnerId'),
  groupId?: string(name='GroupId'),
  faceToken?: string(name='FaceToken'),
}

model UnregisterFaceResponseBody = {
  faceToken?: string(name='FaceToken'),
  requestId?: string(name='RequestId'),
  groupId?: string(name='GroupId'),
}

model UnregisterFaceResponse = {
  headers: map[string]string(name='headers'),
  body: UnregisterFaceResponseBody(name='body'),
}

async function unregisterFaceWithOptions(request: UnregisterFaceRequest, runtime: Util.RuntimeOptions): UnregisterFaceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('UnregisterFace', '2019-03-08', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function unregisterFace(request: UnregisterFaceRequest): UnregisterFaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return unregisterFaceWithOptions(request, runtime);
}

