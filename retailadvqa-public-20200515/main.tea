/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;

init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('retailadvqa-public', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }

  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}
model RecreateTableRequest {
  accessId?: string(name='AccessId'),
  tenantId?: string(name='TenantId'),
  tableSchema?: map[string]any(name='TableSchema'),
  ossPath?: string(name='OssPath'),
  tableName?: string(name='TableName'),
}

model RecreateTableShrinkRequest {
  accessId?: string(name='AccessId'),
  tenantId?: string(name='TenantId'),
  tableSchemaShrink?: string(name='TableSchema'),
  ossPath?: string(name='OssPath'),
  tableName?: string(name='TableName'),
}

model RecreateTableResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model RecreateTableResponse = {
  headers: map[string]string(name='headers'),
  body: RecreateTableResponseBody(name='body'),
}

async function recreateTableWithOptions(tmpReq: RecreateTableRequest, runtime: Util.RuntimeOptions): RecreateTableResponse {
  Util.validateModel(tmpReq);
  var request = new RecreateTableShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.tableSchema)) {
    request.tableSchemaShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.tableSchema, 'TableSchema', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('RecreateTable', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function recreateTable(request: RecreateTableRequest): RecreateTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return recreateTableWithOptions(request, runtime);
}

model AudiencePushStatusRequest {
  audienceId?: string(name='AudienceId'),
  workspaceId?: string(name='WorkspaceId'),
  accessId?: string(name='AccessId'),
}

model AudiencePushStatusResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: string(name='Data'),
}

model AudiencePushStatusResponse = {
  headers: map[string]string(name='headers'),
  body: AudiencePushStatusResponseBody(name='body'),
}

async function audiencePushStatusWithOptions(request: AudiencePushStatusRequest, runtime: Util.RuntimeOptions): AudiencePushStatusResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AudiencePushStatus', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function audiencePushStatus(request: AudiencePushStatusRequest): AudiencePushStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return audiencePushStatusWithOptions(request, runtime);
}

model CreateDataSourceRequest {
  accessId?: string(name='AccessId'),
  dataSourceId?: string(name='DataSourceId'),
  displayName?: string(name='DisplayName'),
  regionCode?: string(name='RegionCode'),
  databaseAddress?: string(name='DatabaseAddress'),
  databasePort?: string(name='DatabasePort'),
  databaseName?: string(name='DatabaseName'),
  databaseUserName?: string(name='DatabaseUserName'),
  databasePassword?: string(name='DatabasePassword'),
  dataSourceType?: string(name='DataSourceType'),
  workspaceId?: string(name='WorkspaceId'),
  createType?: string(name='CreateType'),
}

model CreateDataSourceResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: {
    dataSourceId?: string(name='DataSourceId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  exStack?: string(name='ExStack'),
  success?: string(name='Success'),
}

model CreateDataSourceResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDataSourceResponseBody(name='body'),
}

async function createDataSourceWithOptions(request: CreateDataSourceRequest, runtime: Util.RuntimeOptions): CreateDataSourceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDataSource', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDataSource(request: CreateDataSourceRequest): CreateDataSourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDataSourceWithOptions(request, runtime);
}

model QueryMediaResourcePackageRequest {
  accessId?: string(name='AccessId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
  resourceType?: string(name='ResourceType'),
  template?: string(name='Template'),
}

model QueryMediaResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    slrGrantedFlag?: boolean(name='SlrGrantedFlag'),
    effectiveInstanceFlag?: boolean(name='EffectiveInstanceFlag'),
    pageSize?: int32(name='PageSize'),
    bagsInfo?: string(name='BagsInfo'),
    totalCount?: int32(name='TotalCount'),
    pageCount?: int32(name='PageCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model QueryMediaResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: QueryMediaResourcePackageResponseBody(name='body'),
}

async function queryMediaResourcePackageWithOptions(request: QueryMediaResourcePackageRequest, runtime: Util.RuntimeOptions): QueryMediaResourcePackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('QueryMediaResourcePackage', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function queryMediaResourcePackage(request: QueryMediaResourcePackageRequest): QueryMediaResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return queryMediaResourcePackageWithOptions(request, runtime);
}

model ListDatasetRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
  type?: string(name='Type'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListDatasetResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: [ 
    {
      extRFM?: {
        tradeDateField?: string(name='TradeDateField'),
        dataFromType?: string(name='DataFromType'),
        tradeFrequencyField?: string(name='TradeFrequencyField'),
        tradeMoneyUnit?: int32(name='TradeMoneyUnit'),
        frequencyScoreCompareValue?: string(name='FrequencyScoreCompareValue'),
        monetaryScoreCompareValue?: string(name='MonetaryScoreCompareValue'),
        period?: int32(name='Period'),
        frequencyScoreConfig?: [ 
          {
            start?: int32(name='Start'),
            end?: int32(name='End'),
            score?: int32(name='Score'),
          }
        ](name='FrequencyScoreConfig'),
        tradeMoneyField?: string(name='TradeMoneyField'),
        monetaryScoreConfig?: [ 
          {
            start?: string(name='Start'),
            end?: string(name='End'),
            score?: string(name='Score'),
          }
        ](name='MonetaryScoreConfig'),
        recencyScoreConfig?: [ 
          {
            start?: int32(name='Start'),
            end?: int32(name='End'),
            score?: int32(name='Score'),
          }
        ](name='RecencyScoreConfig'),
        comparisonCalculateType?: int32(name='ComparisonCalculateType'),
        recencyScoreCompareValue?: string(name='RecencyScoreCompareValue'),
      }(name='ExtRFM'),
      extMappingTypes?: map[string]any(name='ExtMappingTypes'),
      uniqueFieldName?: string(name='UniqueFieldName'),
      extLabel?: {
        datasetLabelList?: [ 
          {
            columnAlias?: string(name='ColumnAlias'),
            columnName?: string(name='ColumnName'),
            tableName?: string(name='TableName'),
            colType?: string(name='ColType'),
            labelSeparator?: string(name='LabelSeparator'),
            remark?: string(name='Remark'),
          }
        ](name='DatasetLabelList'),
      }(name='ExtLabel'),
      gmtModified?: string(name='GmtModified'),
      extBehavior?: {
        behaviorObjectTypeField?: string(name='BehaviorObjectTypeField'),
        behaviorDateField?: string(name='BehaviorDateField'),
        typeField?: string(name='TypeField'),
        behaviorChannelField?: string(name='BehaviorChannelField'),
        behaviorTypeField?: string(name='BehaviorTypeField'),
        channelDimTableName?: string(name='ChannelDimTableName'),
        behaviorCountsField?: string(name='BehaviorCountsField'),
        typeDimTableName?: string(name='TypeDimTableName'),
        behaviorObjectValueField?: string(name='BehaviorObjectValueField'),
        channelField?: string(name='ChannelField'),
        objectTypeContext?: map[string]any(name='ObjectTypeContext'),
        behaviorAmountsField?: string(name='BehaviorAmountsField'),
      }(name='ExtBehavior'),
      uniqueMappingType?: string(name='UniqueMappingType'),
      gmtCreate?: string(name='GmtCreate'),
      factTable?: string(name='FactTable'),
      name?: string(name='Name'),
      dataSetType?: int32(name='DataSetType'),
      id?: string(name='Id'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: ListDatasetResponseBody(name='body'),
}

async function listDatasetWithOptions(request: ListDatasetRequest, runtime: Util.RuntimeOptions): ListDatasetResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListDataset', '2020-05-15', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listDataset(request: ListDatasetRequest): ListDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDatasetWithOptions(request, runtime);
}

model SearchAudiencesRequest {
  workspaceId?: string(name='WorkspaceId'),
  accessId?: string(name='AccessId'),
  parentId?: string(name='ParentId'),
  name?: string(name='Name'),
  pageNum?: int32(name='PageNum'),
  pageSize?: int32(name='PageSize'),
}

model SearchAudiencesResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    pageNum?: int32(name='PageNum'),
    pageSize?: int32(name='PageSize'),
    totalNum?: long(name='TotalNum'),
    content?: [ 
      {
        dataModelName?: string(name='DataModelName'),
        gmtModified?: long(name='GmtModified'),
        dbName?: string(name='DbName'),
        numberOfAudiences?: long(name='NumberOfAudiences'),
        errorMessage?: string(name='ErrorMessage'),
        dbType?: string(name='DbType'),
        permission?: string(name='Permission'),
        type?: int32(name='Type'),
        gmtCreate?: long(name='GmtCreate'),
        version?: string(name='Version'),
        parentId?: string(name='ParentId'),
        modifyUser?: string(name='ModifyUser'),
        modifyUserName?: string(name='ModifyUserName'),
        latestDataModifyStatus?: int32(name='LatestDataModifyStatus'),
        public?: boolean(name='Public'),
        subtype?: int32(name='Subtype'),
        name?: string(name='Name'),
        autoUpdateData?: boolean(name='AutoUpdateData'),
        createUser?: string(name='CreateUser'),
        id?: string(name='Id'),
        latestDataModifyTime?: long(name='LatestDataModifyTime'),
        desc?: string(name='Desc'),
      }
    ](name='Content'),
  }(name='Data'),
}

model SearchAudiencesResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAudiencesResponseBody(name='body'),
}

async function searchAudiencesWithOptions(request: SearchAudiencesRequest, runtime: Util.RuntimeOptions): SearchAudiencesResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAudiences', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAudiences(request: SearchAudiencesRequest): SearchAudiencesResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAudiencesWithOptions(request, runtime);
}

model GetInstanceInstanceInstanceRequest {
  accountId?: string(name='AccountId'),
  accountName?: string(name='AccountName'),
  accessId?: string(name='AccessId'),
}

model GetInstanceInstanceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    retInstanceInfo?: string(name='RetInstanceInfo'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetInstanceInstanceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceInstanceInstanceResponseBody(name='body'),
}

async function getInstanceInstanceInstanceWithOptions(request: GetInstanceInstanceInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceInstanceInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceInstanceInstance', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceInstanceInstance(request: GetInstanceInstanceInstanceRequest): GetInstanceInstanceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceInstanceInstanceWithOptions(request, runtime);
}

model SaveExternalAudienceRequest {
  accessId?: string(name='AccessId'),
  dataSourceId?: string(name='DataSourceId'),
  audienceId?: string(name='AudienceId'),
  audienceName?: string(name='AudienceName'),
  mappingType?: string(name='MappingType'),
  workspaceId?: string(name='WorkspaceId'),
}

model SaveExternalAudienceResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: {
    audienceId?: string(name='AudienceId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model SaveExternalAudienceResponse = {
  headers: map[string]string(name='headers'),
  body: SaveExternalAudienceResponseBody(name='body'),
}

async function saveExternalAudienceWithOptions(request: SaveExternalAudienceRequest, runtime: Util.RuntimeOptions): SaveExternalAudienceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveExternalAudience', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveExternalAudience(request: SaveExternalAudienceRequest): SaveExternalAudienceResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveExternalAudienceWithOptions(request, runtime);
}

model SaveLabelDataSetRequest {
  dsId?: string(name='DsId'),
  cubeName?: string(name='CubeName'),
  cubeId?: string(name='CubeId'),
  accessId?: string(name='AccessId'),
  tableName?: string(name='TableName'),
  workspaceId?: string(name='WorkspaceId'),
  datasetLabelList?: [ 
    {
      columnName?: string(name='ColumnName'),
      columnComment?: string(name='ColumnComment'),
      remark?: string(name='Remark'),
      columnType?: string(name='ColumnType'),
      mappingType?: string(name='MappingType'),
      uniqueIdentification?: string(name='UniqueIdentification'),
    }
  ](name='DatasetLabelList'),
}

model SaveLabelDataSetResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: {
    cubeId?: string(name='CubeId'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model SaveLabelDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: SaveLabelDataSetResponseBody(name='body'),
}

async function saveLabelDataSetWithOptions(request: SaveLabelDataSetRequest, runtime: Util.RuntimeOptions): SaveLabelDataSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SaveLabelDataSet', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function saveLabelDataSet(request: SaveLabelDataSetRequest): SaveLabelDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return saveLabelDataSetWithOptions(request, runtime);
}

model ListAccountRequest {
  workspaceId?: string(name='WorkspaceId'),
  accessId?: string(name='AccessId'),
  tenantId?: string(name='TenantId'),
  regionId?: string(name='RegionId'),
}

model ListAccountResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: [ 
    {
      aud?: string(name='Aud'),
      userId?: string(name='UserId'),
      nickName?: string(name='NickName'),
      role?: string(name='Role'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAccountResponse = {
  headers: map[string]string(name='headers'),
  body: ListAccountResponseBody(name='body'),
}

async function listAccountWithOptions(request: ListAccountRequest, runtime: Util.RuntimeOptions): ListAccountResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListAccount', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listAccount(request: ListAccountRequest): ListAccountResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAccountWithOptions(request, runtime);
}

model SearchAudienceRequest {
  audienceId?: string(name='AudienceId'),
  workspaceId?: string(name='WorkspaceId'),
  accessId?: string(name='AccessId'),
}

model SearchAudienceResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: {
    dataModelName?: string(name='DataModelName'),
    gmtModified?: long(name='GmtModified'),
    dbName?: string(name='DbName'),
    numberOfAudiences?: long(name='NumberOfAudiences'),
    errorMessage?: string(name='ErrorMessage'),
    dbType?: string(name='DbType'),
    permission?: string(name='Permission'),
    type?: int32(name='Type'),
    gmtCreate?: long(name='GmtCreate'),
    version?: string(name='Version'),
    parentId?: string(name='ParentId'),
    modifyUser?: string(name='ModifyUser'),
    modifyUserName?: string(name='ModifyUserName'),
    latestDataModifyStatus?: int32(name='LatestDataModifyStatus'),
    public?: boolean(name='Public'),
    subtype?: int32(name='Subtype'),
    name?: string(name='Name'),
    autoUpdateData?: boolean(name='AutoUpdateData'),
    createUser?: string(name='CreateUser'),
    id?: string(name='Id'),
    latestDataModifyTime?: long(name='LatestDataModifyTime'),
    desc?: string(name='Desc'),
    extendMappingTypes?: [ 
      {
        pathId?: string(name='PathId'),
        mappingType?: string(name='MappingType'),
        columnName?: string(name='ColumnName'),
        defaultIdType?: string(name='DefaultIdType'),
      }
    ](name='ExtendMappingTypes'),
  }(name='Data'),
}

model SearchAudienceResponse = {
  headers: map[string]string(name='headers'),
  body: SearchAudienceResponseBody(name='body'),
}

async function searchAudienceWithOptions(request: SearchAudienceRequest, runtime: Util.RuntimeOptions): SearchAudienceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('SearchAudience', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function searchAudience(request: SearchAudienceRequest): SearchAudienceResponse {
  var runtime = new Util.RuntimeOptions{};
  return searchAudienceWithOptions(request, runtime);
}

model LoadDataToLabelDataSetRequest {
  cubeId?: string(name='CubeId'),
  separator?: string(name='Separator'),
  accessId?: string(name='AccessId'),
  ossPath?: string(name='OssPath'),
  colNameList?: [ string ](name='ColNameList'),
}

model LoadDataToLabelDataSetResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: boolean(name='Data'),
  errorCode?: string(name='ErrorCode'),
  exStack?: string(name='ExStack'),
  success?: boolean(name='Success'),
}

model LoadDataToLabelDataSetResponse = {
  headers: map[string]string(name='headers'),
  body: LoadDataToLabelDataSetResponseBody(name='body'),
}

async function loadDataToLabelDataSetWithOptions(request: LoadDataToLabelDataSetRequest, runtime: Util.RuntimeOptions): LoadDataToLabelDataSetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('LoadDataToLabelDataSet', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function loadDataToLabelDataSet(request: LoadDataToLabelDataSetRequest): LoadDataToLabelDataSetResponse {
  var runtime = new Util.RuntimeOptions{};
  return loadDataToLabelDataSetWithOptions(request, runtime);
}

model GetMediaResourcePackageRequest {
  accessId?: string(name='AccessId'),
  pageIndex?: int32(name='PageIndex'),
  pageSize?: int32(name='PageSize'),
  status?: string(name='Status'),
  resourceType?: string(name='ResourceType'),
  template?: string(name='Template'),
}

model GetMediaResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    currentPage?: int32(name='CurrentPage'),
    slrGrantedFlag?: boolean(name='SlrGrantedFlag'),
    effectiveInstanceFlag?: boolean(name='EffectiveInstanceFlag'),
    pageSize?: int32(name='PageSize'),
    bagsInfo?: string(name='BagsInfo'),
    totalCount?: int32(name='TotalCount'),
    pageCount?: int32(name='PageCount'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model GetMediaResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: GetMediaResourcePackageResponseBody(name='body'),
}

async function getMediaResourcePackageWithOptions(request: GetMediaResourcePackageRequest, runtime: Util.RuntimeOptions): GetMediaResourcePackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetMediaResourcePackage', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getMediaResourcePackage(request: GetMediaResourcePackageRequest): GetMediaResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMediaResourcePackageWithOptions(request, runtime);
}

model CreateExportTaskRequest {
  audienceId?: string(name='AudienceId'),
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
}

model CreateExportTaskResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateExportTaskResponse = {
  headers: map[string]string(name='headers'),
  body: CreateExportTaskResponseBody(name='body'),
}

async function createExportTaskWithOptions(request: CreateExportTaskRequest, runtime: Util.RuntimeOptions): CreateExportTaskResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateExportTask', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createExportTask(request: CreateExportTaskRequest): CreateExportTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createExportTaskWithOptions(request, runtime);
}

model CheckAudienceExportStatusRequest {
  audienceId?: string(name='AudienceId'),
  accessId?: string(name='AccessId'),
  tenantId?: string(name='TenantId'),
}

model CheckAudienceExportStatusResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CheckAudienceExportStatusResponse = {
  headers: map[string]string(name='headers'),
  body: CheckAudienceExportStatusResponseBody(name='body'),
}

async function checkAudienceExportStatusWithOptions(request: CheckAudienceExportStatusRequest, runtime: Util.RuntimeOptions): CheckAudienceExportStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('CheckAudienceExportStatus', '2020-05-15', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function checkAudienceExportStatus(request: CheckAudienceExportStatusRequest): CheckAudienceExportStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkAudienceExportStatusWithOptions(request, runtime);
}

model ListWorkspaceRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
}

model ListWorkspaceResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: [ 
    {
      workspaceId?: string(name='WorkspaceId'),
      gmtCreate?: string(name='GmtCreate'),
      workspaceName?: string(name='WorkspaceName'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListWorkspaceResponse = {
  headers: map[string]string(name='headers'),
  body: ListWorkspaceResponseBody(name='body'),
}

async function listWorkspaceWithOptions(request: ListWorkspaceRequest, runtime: Util.RuntimeOptions): ListWorkspaceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListWorkspace', '2020-05-15', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listWorkspace(request: ListWorkspaceRequest): ListWorkspaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkspaceWithOptions(request, runtime);
}

model ListTableRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
}

model ListTableResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: [ 
    {
      tableName?: string(name='TableName'),
      columns?: [ 
        {
          comment?: string(name='Comment'),
          columnType?: string(name='ColumnType'),
          name?: string(name='Name'),
        }
      ](name='Columns'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListTableResponse = {
  headers: map[string]string(name='headers'),
  body: ListTableResponseBody(name='body'),
}

async function listTableWithOptions(request: ListTableRequest, runtime: Util.RuntimeOptions): ListTableResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListTable', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listTable(request: ListTableRequest): ListTableResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTableWithOptions(request, runtime);
}

model ListAudienceRequest {
  name?: string(name='Name'),
  pageNum?: string(name='PageNum'),
  pageSize?: string(name='PageSize'),
  columnName?: string(name='ColumnName'),
  order?: string(name='Order'),
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListAudienceResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: {
    pageNum?: string(name='PageNum'),
    pageSize?: string(name='PageSize'),
    totalNum?: string(name='TotalNum'),
    content?: [ 
      {
        latestDataModifyStatus?: string(name='LatestDataModifyStatus'),
        errorMessage?: string(name='ErrorMessage'),
        numberOfAudiences?: string(name='NumberOfAudiences'),
        latestDataModifyTime?: string(name='LatestDataModifyTime'),
        gmtCreate?: string(name='GmtCreate'),
        gmtModified?: string(name='GmtModified'),
        name?: string(name='Name'),
        mappingTypes?: [ string ](name='MappingTypes'),
        isDynamic?: boolean(name='IsDynamic'),
        id?: string(name='Id'),
      }
    ](name='Content'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListAudienceResponse = {
  headers: map[string]string(name='headers'),
  body: ListAudienceResponseBody(name='body'),
}

async function listAudienceWithOptions(request: ListAudienceRequest, runtime: Util.RuntimeOptions): ListAudienceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = query,
  };
  return doRPCRequest('ListAudience', '2020-05-15', 'HTTPS', 'GET', 'AK', 'json', req, runtime);
}

async function listAudience(request: ListAudienceRequest): ListAudienceResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAudienceWithOptions(request, runtime);
}

model CheckResourcepackSlrRequest {
  accessId?: string(name='AccessId'),
}

model CheckResourcepackSlrResponseBody = {
  requestId?: string(name='RequestId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model CheckResourcepackSlrResponse = {
  headers: map[string]string(name='headers'),
  body: CheckResourcepackSlrResponseBody(name='body'),
}

async function checkResourcepackSlrWithOptions(request: CheckResourcepackSlrRequest, runtime: Util.RuntimeOptions): CheckResourcepackSlrResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CheckResourcepackSlr', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function checkResourcepackSlr(request: CheckResourcepackSlrRequest): CheckResourcepackSlrResponse {
  var runtime = new Util.RuntimeOptions{};
  return checkResourcepackSlrWithOptions(request, runtime);
}

model AudienceMemberQueryRequest {
  audienceId?: string(name='AudienceId'),
  workspaceId?: string(name='WorkspaceId'),
  mappingTypes?: string(name='MappingTypes'),
  accessId?: string(name='AccessId'),
  delimiter?: string(name='Delimiter'),
}

model AudienceMemberQueryResponseBody = {
  requestId?: string(name='RequestId', description='Id of the request'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
  data?: string(name='Data'),
}

model AudienceMemberQueryResponse = {
  headers: map[string]string(name='headers'),
  body: AudienceMemberQueryResponseBody(name='body'),
}

async function audienceMemberQueryWithOptions(request: AudienceMemberQueryRequest, runtime: Util.RuntimeOptions): AudienceMemberQueryResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('AudienceMemberQuery', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function audienceMemberQuery(request: AudienceMemberQueryRequest): AudienceMemberQueryResponse {
  var runtime = new Util.RuntimeOptions{};
  return audienceMemberQueryWithOptions(request, runtime);
}

model ConsumeMediaResourcePackageRequest {
  consumeTime?: long(name='ConsumeTime'),
  consumeType?: string(name='ConsumeType'),
  productId?: string(name='ProductId'),
  consumeInfos?: string(name='ConsumeInfos'),
}

model ConsumeMediaResourcePackageResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    count?: int32(name='Count'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model ConsumeMediaResourcePackageResponse = {
  headers: map[string]string(name='headers'),
  body: ConsumeMediaResourcePackageResponseBody(name='body'),
}

async function consumeMediaResourcePackageWithOptions(request: ConsumeMediaResourcePackageRequest, runtime: Util.RuntimeOptions): ConsumeMediaResourcePackageResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ConsumeMediaResourcePackage', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function consumeMediaResourcePackage(request: ConsumeMediaResourcePackageRequest): ConsumeMediaResourcePackageResponse {
  var runtime = new Util.RuntimeOptions{};
  return consumeMediaResourcePackageWithOptions(request, runtime);
}

model CreateDatasetRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
  dataSet?: map[string]any(name='DataSet'),
  type?: string(name='Type'),
  dataSetName?: string(name='DataSetName'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateDatasetShrinkRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
  dataSetShrink?: string(name='DataSet'),
  type?: string(name='Type'),
  dataSetName?: string(name='DataSetName'),
  workspaceId?: string(name='WorkspaceId'),
}

model CreateDatasetResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: {
    id?: string(name='Id'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model CreateDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: CreateDatasetResponseBody(name='body'),
}

async function createDatasetWithOptions(tmpReq: CreateDatasetRequest, runtime: Util.RuntimeOptions): CreateDatasetResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDatasetShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.dataSet)) {
    request.dataSetShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.dataSet, 'DataSet', 'json');
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('CreateDataset', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function createDataset(request: CreateDatasetRequest): CreateDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDatasetWithOptions(request, runtime);
}

model ListMenuRequest {
  roleSign?: string(name='RoleSign'),
  accessId?: string(name='AccessId'),
  tenantId?: string(name='TenantId'),
  workspaceId?: string(name='WorkspaceId'),
}

model ListMenuResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: [ 
    {
      key?: string(name='Key'),
      url?: string(name='Url'),
      name?: string(name='Name'),
    }
  ](name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model ListMenuResponse = {
  headers: map[string]string(name='headers'),
  body: ListMenuResponseBody(name='body'),
}

async function listMenuWithOptions(request: ListMenuRequest, runtime: Util.RuntimeOptions): ListMenuResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('ListMenu', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function listMenu(request: ListMenuRequest): ListMenuResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMenuWithOptions(request, runtime);
}

model GetInstanceInstanceRequest {
  accountId?: string(name='AccountId'),
  accountName?: string(name='AccountName'),
  accessId?: string(name='AccessId'),
}

model GetInstanceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  data?: {
    retInstanceInfo?: string(name='RetInstanceInfo'),
  }(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: string(name='Success'),
}

model GetInstanceInstanceResponse = {
  headers: map[string]string(name='headers'),
  body: GetInstanceInstanceResponseBody(name='body'),
}

async function getInstanceInstanceWithOptions(request: GetInstanceInstanceRequest, runtime: Util.RuntimeOptions): GetInstanceInstanceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('GetInstanceInstance', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function getInstanceInstance(request: GetInstanceInstanceRequest): GetInstanceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInstanceInstanceWithOptions(request, runtime);
}

model UpdateDatasetRequest {
  tenantId?: string(name='TenantId'),
  accessId?: string(name='AccessId'),
  type?: string(name='Type'),
  dataSet?: string(name='DataSet'),
  dataSetName?: string(name='DataSetName'),
  dataSetId?: string(name='DataSetId'),
  workspaceId?: string(name='WorkspaceId'),
}

model UpdateDatasetResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  data?: string(name='Data'),
  errorCode?: string(name='ErrorCode'),
  success?: boolean(name='Success'),
}

model UpdateDatasetResponse = {
  headers: map[string]string(name='headers'),
  body: UpdateDatasetResponseBody(name='body'),
}

async function updateDatasetWithOptions(request: UpdateDatasetRequest, runtime: Util.RuntimeOptions): UpdateDatasetResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('UpdateDataset', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function updateDataset(request: UpdateDatasetRequest): UpdateDatasetResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDatasetWithOptions(request, runtime);
}

model LoadDataToExternalAudienceRequest {
  accessId?: string(name='AccessId'),
  audienceId?: string(name='AudienceId'),
  ossPath?: string(name='OssPath'),
}

model LoadDataToExternalAudienceResponseBody = {
  requestId?: string(name='RequestId'),
  errorDesc?: string(name='ErrorDesc'),
  traceId?: string(name='TraceId'),
  errorCode?: string(name='ErrorCode'),
  exStack?: string(name='ExStack'),
  success?: string(name='Success'),
}

model LoadDataToExternalAudienceResponse = {
  headers: map[string]string(name='headers'),
  body: LoadDataToExternalAudienceResponseBody(name='body'),
}

async function loadDataToExternalAudienceWithOptions(request: LoadDataToExternalAudienceRequest, runtime: Util.RuntimeOptions): LoadDataToExternalAudienceResponse {
  Util.validateModel(request);
  var req = new OpenApi.OpenApiRequest{ 
    body = Util.toMap(request),
  };
  return doRPCRequest('LoadDataToExternalAudience', '2020-05-15', 'HTTPS', 'POST', 'AK', 'json', req, runtime);
}

async function loadDataToExternalAudience(request: LoadDataToExternalAudienceRequest): LoadDataToExternalAudienceResponse {
  var runtime = new Util.RuntimeOptions{};
  return loadDataToExternalAudienceWithOptions(request, runtime);
}

