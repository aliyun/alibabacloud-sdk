/**
 *
 */
import Util;
import OpenApi;
import OpenApiUtil;
import EndpointUtil;

extends OpenApi;


init(config: OpenApi.Config){
  super(config);
  @endpointRule = '';
  
  checkConfig(config);
  @endpoint = getEndpoint('cmn', @regionId, @endpointRule, @network, @suffix, @endpointMap, @endpoint);
}

function getEndpoint(productId: string, regionId: string, endpointRule: string, network: string, suffix: string, endpointMap: map[string]string, endpoint: string) throws: string{
  if (!Util.empty(endpoint)) {
    return endpoint;
  }
  
  if (!Util.isUnset(endpointMap) && !Util.empty(endpointMap[regionId])) {
    return endpointMap[regionId];
  }
  return EndpointUtil.getEndpointRules(productId, regionId, endpointRule, network, suffix);
}

model Agent {
  agentId?: string(name='AgentId'),
  agentName?: string(name='AgentName'),
  agentVersion?: string(name='AgentVersion'),
  cpuUsage?: string(name='CpuUsage'),
  diskUsage?: string(name='DiskUsage'),
  gmtModify?: string(name='GmtModify'),
  ip?: string(name='Ip'),
  kernelVersion?: string(name='KernelVersion'),
  memoryUsage?: string(name='MemoryUsage'),
  securityDomain?: string(name='SecurityDomain'),
  status?: string(name='Status'),
}

model AgentsTask {
  actionType?: string(name='ActionType'),
  agentType?: string(name='AgentType'),
  agentsTaskId?: string(name='AgentsTaskId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  params?: string(name='Params'),
  status?: string(name='Status'),
}

model AggregateData {
  aggregateDataDescription?: string(name='AggregateDataDescription'),
  aggregateDataId?: string(name='AggregateDataId'),
  aggregateDataName?: string(name='AggregateDataName'),
  aggregateModeList?: [ string ](name='AggregateModeList'),
  dataItem?: string(name='DataItem'),
  deviceIdList?: [ string ](name='DeviceIdList'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  isAllDevice?: int32(name='IsAllDevice'),
  monitorItemId?: string(name='MonitorItemId'),
}

model AlarmOverview {
  alarmOverviewId?: string(name='AlarmOverviewId'),
  alarmOverviewName?: string(name='AlarmOverviewName'),
  conditionList?: [ 
    {
      conditionName?: string(name='ConditionName'),
      conditionValue?: string(name='ConditionValue'),
    }
  ](name='ConditionList'),
  serialNumber?: int32(name='SerialNumber'),
}

model AtomicStep {
  description?: string(name='Description'),
  input?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Input'),
  output?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Output'),
  stepId?: string(name='StepId'),
  stepName?: string(name='StepName'),
  stepType?: string(name='StepType'),
}

model BusinessType {
  abbr?: string(name='Abbr'),
  actionFlag?: string(name='ActionFlag'),
  businessTypeId?: string(name='BusinessTypeId'),
  createTime?: string(name='CreateTime'),
  direction?: long(name='Direction'),
  gateway?: long(name='Gateway'),
  leaseTime?: string(name='LeaseTime'),
  mask?: string(name='Mask'),
  name?: string(name='Name'),
  reserveNumber?: long(name='ReserveNumber'),
  sharing?: string(name='Sharing'),
  type?: string(name='Type'),
  updateTime?: string(name='UpdateTime'),
  vlan?: string(name='Vlan'),
  zoneType?: string(name='ZoneType'),
}

model CliTask {
  agentIp?: string(name='AgentIp'),
  cliTaskId?: string(name='CliTaskId'),
  command?: string(name='Command'),
  deviceId?: string(name='DeviceId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  output?: string(name='Output'),
  protocol?: string(name='Protocol'),
  responseCode?: string(name='ResponseCode'),
  result?: string(name='Result'),
  sessionId?: string(name='SessionId'),
  status?: string(name='Status'),
  timeout?: int32(name='Timeout'),
}

model ConfigurationSpecification {
  architecture?: string(name='Architecture'),
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  createTime?: string(name='CreateTime'),
  model?: string(name='Model'),
  relatedVariate?: [ string ](name='RelatedVariate'),
  role?: string(name='Role'),
  specificationContent?: string(name='SpecificationContent'),
  specificationName?: string(name='SpecificationName'),
  updateTime?: string(name='UpdateTime'),
  vendor?: string(name='Vendor'),
}

model ConfigurationVariate {
  comment?: string(name='Comment'),
  configurationVariateId?: string(name='ConfigurationVariateId'),
  createTime?: string(name='CreateTime'),
  formatFunction?: string(name='FormatFunction'),
  updateTime?: string(name='UpdateTime'),
  variateName?: string(name='VariateName'),
}

model ConnectionPolicy {
  algorithm?: string(name='Algorithm'),
  connectionPolicyId?: string(name='ConnectionPolicyId'),
  createTime?: string(name='CreateTime'),
  downlinkDeviceId?: string(name='DownlinkDeviceId'),
  downlinkModuleId?: string(name='DownlinkModuleId'),
  id?: string(name='Id'),
  linkCount?: long(name='LinkCount'),
  name?: string(name='Name'),
  networkArchitectureIterationId?: string(name='NetworkArchitectureIterationId'),
  updateTime?: string(name='UpdateTime'),
  uplinkDeviceId?: string(name='UplinkDeviceId'),
  uplinkModelId?: string(name='UplinkModelId'),
}

model DataView {
  dataViewChartList?: [
    DataViewChart
  ](name='DataViewChartList'),
  dataViewDescription?: string(name='DataViewDescription'),
  dataViewId?: string(name='DataViewId'),
  dataViewName?: string(name='DataViewName'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
}

model DataViewChart {
  chartType?: string(name='ChartType'),
  dataViewId?: string(name='DataViewId'),
  dataViewSource?: string(name='DataViewSource'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  grid?: string(name='Grid'),
}

model DedicatedLine {
  bandwidth?: int32(name='Bandwidth'),
  deviceId?: string(name='DeviceId'),
  devicePort?: string(name='DevicePort'),
  isp?: string(name='Isp'),
  lineGateway?: string(name='LineGateway'),
  lineId?: string(name='LineId'),
  lineIp?: string(name='LineIp'),
  lineRole?: string(name='LineRole'),
}

model Device {
  accountType?: string(name='AccountType'),
  accountVersion?: string(name='AccountVersion'),
  authPassPhrase?: string(name='AuthPassPhrase'),
  authProtocol?: string(name='AuthProtocol'),
  community?: string(name='Community'),
  deviceForm?: string(name='DeviceForm'),
  deviceId?: string(name='DeviceId'),
  deviceIp?: string(name='DeviceIp'),
  deviceMac?: string(name='DeviceMac'),
  deviceSn?: string(name='DeviceSn'),
  hostname?: string(name='Hostname'),
  model?: string(name='Model'),
  privacyPassPhrase?: string(name='PrivacyPassPhrase'),
  privacyProtocol?: string(name='PrivacyProtocol'),
  securityDomain?: string(name='SecurityDomain'),
  securityLevel?: string(name='SecurityLevel'),
  space?: string(name='Space'),
  sshAccount?: string(name='SshAccount'),
  sshPassword?: string(name='SshPassword'),
  status?: string(name='Status'),
  telnetAccount?: string(name='TelnetAccount'),
  telnetPassword?: string(name='TelnetPassword'),
  userName?: string(name='UserName'),
  vendor?: string(name='Vendor'),
}

model DeviceForm {
  accountConfig?: string(name='AccountConfig'),
  configCompare?: string(name='ConfigCompare'),
  formId?: string(name='FormId'),
  formName?: string(name='FormName'),
  propertiesList?: [
    DeviceFormProperty
  ](name='PropertiesList'),
}

model DeviceFormProperty {
  content?: string(name='Content'),
  keyword?: string(name='Keyword'),
  placeholder?: boolean(name='Placeholder'),
  required?: boolean(name='Required'),
  searchSupported?: boolean(name='SearchSupported'),
  sequence?: int32(name='Sequence'),
  tableVisible?: boolean(name='TableVisible'),
  uniqueness?: boolean(name='Uniqueness'),
  valueReference?: string(name='ValueReference'),
  valueSource?: string(name='ValueSource'),
  valueType?: string(name='ValueType'),
}

model DeviceProperty {
  content?: string(name='Content'),
  deviceForm?: string(name='DeviceForm'),
  format?: string(name='Format'),
  nameCn?: string(name='NameCn'),
  nameEn?: string(name='NameEn'),
  propertyId?: string(name='PropertyId'),
}

model DeviceResource {
  archId?: string(name='ArchId'),
  businessType?: string(name='BusinessType'),
  businessTypeId?: string(name='BusinessTypeId'),
  businessTypeParams?: string(name='BusinessTypeParams'),
  createTime?: string(name='CreateTime'),
  data?: string(name='Data'),
  deviceResource?: [ 
    {
      blockNumber?: string(name='BlockNumber'),
      business?: string(name='Business'),
      config?: string(name='Config'),
      configGenerate?: boolean(name='ConfigGenerate'),
      configTaskStatus?: string(name='ConfigTaskStatus'),
      deliveryIp?: string(name='DeliveryIp'),
      deviceNumber?: string(name='DeviceNumber'),
      deviceResourceId?: string(name='DeviceResourceId'),
      hostName?: string(name='HostName'),
      interConnection?: string(name='InterConnection'),
      location?: string(name='Location'),
      loopback?: string(name='Loopback'),
      managerIp?: string(name='ManagerIp'),
      model?: string(name='Model'),
      role?: string(name='Role'),
      setupProjectId?: string(name='SetupProjectId'),
      sn?: string(name='Sn'),
      stack?: boolean(name='Stack'),
      vendor?: string(name='Vendor'),
    }
  ](name='DeviceResource'),
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIds?: [ string ](name='DeviceResourceIds'),
  downloadType?: string(name='DownloadType'),
  ipType?: string(name='IpType'),
  listType?: string(name='ListType'),
  loopbackPort?: string(name='LoopbackPort'),
  netLocation?: string(name='NetLocation'),
  setupProjectId?: string(name='SetupProjectId'),
  type?: string(name='Type'),
}

model DeviceTask {
  deviceId?: string(name='DeviceId'),
  deviceIp?: string(name='DeviceIp'),
  deviceName?: string(name='DeviceName'),
  deviceTaskId?: string(name='DeviceTaskId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  output?: string(name='Output'),
  params?: string(name='Params'),
  responseCode?: string(name='ResponseCode'),
  result?: string(name='Result'),
  scriptId?: string(name='ScriptId'),
  scriptVersion?: string(name='ScriptVersion'),
  status?: string(name='Status'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
}

model Event {
  alarmStatus?: string(name='AlarmStatus'),
  count?: long(name='Count'),
  createTime?: string(name='CreateTime'),
  deviceId?: string(name='DeviceId'),
  eventName?: string(name='EventName'),
  eventObject?: string(name='EventObject'),
  eventObjectId?: string(name='EventObjectId'),
  eventType?: string(name='EventType'),
  message?: string(name='Message'),
  resourceDevice?: {
    hostName?: string(name='HostName'),
    physicalSpace?: string(name='PhysicalSpace'),
  }(name='ResourceDevice'),
  templateId?: string(name='TemplateId'),
  updateTime?: string(name='UpdateTime'),
}

model EventDefinition {
  createTime?: string(name='CreateTime'),
  eventId?: string(name='EventId'),
  eventName?: string(name='EventName'),
  eventType?: string(name='EventType'),
  templateId?: string(name='TemplateId'),
  updateTime?: string(name='UpdateTime'),
}

model InspectionItem {
  inspectionCrontab?: string(name='InspectionCrontab'),
  itemDescription?: string(name='ItemDescription'),
  itemId?: string(name='ItemId'),
  itemName?: string(name='ItemName'),
}

model InspectionScript {
  inspectionAlarmRules?: [ 
    {
      alarmExpression?: string(name='AlarmExpression'),
      alarmLevel?: string(name='AlarmLevel'),
      alarmOperator?: string(name='AlarmOperator'),
      alarmValue?: string(name='AlarmValue'),
    }
  ](name='InspectionAlarmRules'),
  inspectionCrontab?: string(name='InspectionCrontab'),
  itemDescription?: string(name='ItemDescription'),
  itemId?: string(name='ItemId'),
  itemName?: string(name='ItemName'),
  model?: string(name='Model'),
  role?: string(name='Role'),
  script?: string(name='Script'),
  scriptId?: string(name='ScriptId'),
  scriptStatus?: string(name='ScriptStatus'),
  vendor?: string(name='Vendor'),
}

model InspectionTask {
  deviceId?: string(name='DeviceId'),
  errorCode?: string(name='ErrorCode'),
  executionBeginTime?: string(name='ExecutionBeginTime'),
  executionEndTime?: string(name='ExecutionEndTime'),
  hostname?: string(name='Hostname'),
  IP?: string(name='IP'),
  inspectionAlarmRules?: [ 
    {
      actualValue?: string(name='ActualValue'),
      expression?: string(name='Expression'),
      level?: string(name='Level'),
      operator?: string(name='Operator'),
      value?: string(name='Value'),
    }
  ](name='InspectionAlarmRules'),
  inspectionResult?: string(name='InspectionResult'),
  itemId?: string(name='ItemId'),
  itemName?: string(name='ItemName'),
  model?: string(name='Model'),
  role?: string(name='Role'),
  space?: string(name='Space'),
  taskStatus?: string(name='TaskStatus'),
  templateId?: string(name='TemplateId'),
  vendor?: string(name='Vendor'),
}

model Ip {
  businessTypeId?: string(name='BusinessTypeId'),
  businessTypeName?: string(name='BusinessTypeName'),
  createTime?: string(name='CreateTime'),
  deviceMac?: string(name='DeviceMac'),
  deviceName?: string(name='DeviceName'),
  ipAddress?: string(name='IpAddress'),
  ipId?: string(name='IpId'),
  ipName?: string(name='IpName'),
  parentIpBlock?: string(name='ParentIpBlock'),
  port?: string(name='Port'),
  status?: string(name='Status'),
  zoneLayer?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='ZoneLayer'),
}

model IpBlock {
  application?: string(name='Application'),
  backupDeviceName?: string(name='BackupDeviceName'),
  block?: string(name='Block'),
  businessTypeId?: string(name='BusinessTypeId'),
  category?: string(name='Category'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  deviceName?: string(name='DeviceName'),
  ipBlockId?: string(name='IpBlockId'),
  mask?: string(name='Mask'),
  netBusiness?: string(name='NetBusiness'),
  netType?: string(name='NetType'),
  ownership?: string(name='Ownership'),
  parentId?: string(name='ParentId'),
  reserveParentBlock?: string(name='ReserveParentBlock'),
  resourceGroupId?: string(name='ResourceGroupId'),
  updateType?: string(name='UpdateType'),
  zoneLayer?: [ 
    {
      name?: string(name='Name'),
      value?: string(name='Value'),
    }
  ](name='ZoneLayer'),
  zoneName?: string(name='ZoneName'),
}

model IpBlockRecord {
  createTime?: string(name='CreateTime'),
  creator?: long(name='Creator'),
  description?: string(name='Description'),
  detail?: [ 
    {
      businessTypeName?: string(name='BusinessTypeName'),
      deviceName?: string(name='DeviceName'),
      gateway?: string(name='Gateway'),
      parentIpBlocks?: [ string ](name='ParentIpBlocks'),
      zoneLayer?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='ZoneLayer'),
    }
  ](name='Detail'),
  ipBlockCode?: [ string ](name='IpBlockCode'),
  ipBlockRecordId?: string(name='IpBlockRecordId'),
  netType?: string(name='NetType'),
  recordType?: string(name='RecordType'),
  status?: string(name='Status'),
  title?: string(name='Title'),
  updateTime?: string(name='UpdateTime'),
  workNo?: string(name='WorkNo'),
  zoneName?: string(name='ZoneName'),
}

model IpRecord {
  businessTypeName?: string(name='BusinessTypeName'),
  createTime?: string(name='CreateTime'),
  creator?: string(name='Creator'),
  description?: string(name='Description'),
  detail?: [ 
    {
      deviceMac?: string(name='DeviceMac'),
      deviceName?: string(name='DeviceName'),
      gateway?: string(name='Gateway'),
      ip?: string(name='Ip'),
      parentIpBlocks?: [ string ](name='ParentIpBlocks'),
      port?: string(name='Port'),
      remoteDeviceName?: string(name='RemoteDeviceName'),
      remoteIp?: string(name='RemoteIp'),
      remotePort?: string(name='RemotePort'),
      zoneLayer?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='ZoneLayer'),
    }
  ](name='Detail'),
  ipBlock?: string(name='IpBlock'),
  ipCode?: [ string ](name='IpCode'),
  ipRecordId?: string(name='IpRecordId'),
  recodeType?: string(name='RecodeType'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  zoneName?: string(name='ZoneName'),
}

model ModelToRole {
  createTime?: string(name='CreateTime'),
  id?: string(name='Id'),
  model?: string(name='Model'),
  modelToRoleId?: string(name='ModelToRoleId'),
  networkArchitectureIterationId?: string(name='NetworkArchitectureIterationId'),
  role?: string(name='Role'),
  updateTime?: string(name='UpdateTime'),
  vendor?: string(name='Vendor'),
}

model Module {
  createTime?: string(name='CreateTime'),
  device?: {
    count?: long(name='Count'),
    createTime?: string(name='CreateTime'),
    deviceCount?: long(name='DeviceCount'),
    deviceRole?: string(name='DeviceRole'),
    deviceX?: string(name='DeviceX'),
    deviceY?: string(name='DeviceY'),
    id?: string(name='Id'),
    role?: string(name='Role'),
    updateTime?: string(name='UpdateTime'),
    x?: string(name='X'),
    y?: string(name='Y'),
  }(name='Device'),
  id?: string(name='Id'),
  maxCount?: long(name='MaxCount'),
  minCount?: long(name='MinCount'),
  moduleDetails?: [ 
    {
      deviceDetails?: [ 
        {
          orderNumber?: long(name='OrderNumber'),
        }
      ](name='DeviceDetails'),
      orderNumber?: long(name='OrderNumber'),
    }
  ](name='ModuleDetails'),
  moduleId?: string(name='ModuleId'),
  moduleType?: string(name='ModuleType'),
  name?: string(name='Name'),
  parentModuleId?: string(name='ParentModuleId'),
  stack?: boolean(name='Stack'),
  updateTime?: string(name='UpdateTime'),
}

model MonitorItem {
  analysisCode?: string(name='AnalysisCode'),
  collectionType?: string(name='CollectionType'),
  config?: string(name='Config'),
  enable?: int32(name='Enable'),
  execInterval?: string(name='ExecInterval'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  monitorItemDescription?: string(name='MonitorItemDescription'),
  monitorItemId?: string(name='MonitorItemId'),
  monitorItemName?: string(name='MonitorItemName'),
  securityDomain?: string(name='SecurityDomain'),
}

model NetworkArchitecture {
  archVersionIterationId?: string(name='ArchVersionIterationId'),
  availabe?: boolean(name='Availabe'),
  children?: [ string ](name='Children'),
  createTime?: string(name='CreateTime'),
  description?: string(name='Description'),
  deviceNumber?: long(name='DeviceNumber'),
  groupNumber?: long(name='GroupNumber'),
  id?: string(name='Id'),
  name?: string(name='Name'),
  networkArchitectureId?: string(name='NetworkArchitectureId'),
  role?: string(name='Role'),
  selected?: boolean(name='Selected'),
  stack?: boolean(name='Stack'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  version?: string(name='Version'),
}

model NotificationGroup {
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  notificationGroupDescription?: string(name='NotificationGroupDescription'),
  notificationGroupId?: string(name='NotificationGroupId'),
  notificationGroupName?: string(name='NotificationGroupName'),
  notificationGroupType?: string(name='NotificationGroupType'),
  webhook?: string(name='Webhook'),
}

model Order {
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  orderId?: string(name='OrderId'),
  output?: string(name='Output'),
  params?: string(name='Params'),
  schemeId?: string(name='SchemeId'),
  schemeName?: string(name='SchemeName'),
  status?: string(name='Status'),
  title?: string(name='Title'),
}

model OrderStep {
  displayMethod?: string(name='DisplayMethod'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  jobKwargs?: string(name='JobKwargs'),
  jobMessage?: string(name='JobMessage'),
  jobReturnStatus?: string(name='JobReturnStatus'),
  jobReturnValues?: string(name='JobReturnValues'),
  jobSystem?: string(name='JobSystem'),
  orderId?: string(name='OrderId'),
  orderStepId?: string(name='OrderStepId'),
  realNextStep?: string(name='RealNextStep'),
  restriction?: [ 
    {
      label?: string(name='Label'),
      value?: string(name='Value'),
    }
  ](name='Restriction'),
  stepName?: string(name='StepName'),
  stepStatus?: string(name='StepStatus'),
  stepTitle?: string(name='StepTitle'),
  stepType?: string(name='StepType'),
}

model OsVersion {
  accessId?: string(name='AccessId'),
  createTime?: string(name='CreateTime'),
  directory?: string(name='Directory'),
  expireTime?: string(name='ExpireTime'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  host?: string(name='Host'),
  model?: string(name='Model'),
  osVersion?: string(name='OsVersion'),
  osVersionId?: string(name='OsVersionId'),
  policy?: string(name='Policy'),
  signature?: string(name='Signature'),
  status?: string(name='Status'),
  vendor?: string(name='Vendor'),
}

model PhysicalSpace {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  province?: string(name='Province'),
  spaceId?: string(name='SpaceId'),
  spaceName?: string(name='SpaceName'),
}

model PhysicalSpaceDto {
  address?: string(name='Address'),
  children?: [
    PhysicalSpaceDto
  ](name='Children'),
  city?: string(name='City'),
  country?: string(name='Country'),
  fullParentPath?: string(name='FullParentPath'),
  instance?: string(name='Instance'),
  owner?: string(name='Owner'),
  parentUid?: string(name='ParentUid'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  province?: string(name='Province'),
  remark?: string(name='Remark'),
  securityDomainList?: [ string ](name='SecurityDomainList'),
  spaceAbbreviation?: string(name='SpaceAbbreviation'),
  spaceType?: string(name='SpaceType'),
}

model Port {
  deviceId?: string(name='DeviceId'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  portCollectionId?: string(name='PortCollectionId'),
  portName?: string(name='PortName'),
}

model PortCollection {
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  portCollectionDescription?: string(name='PortCollectionDescription'),
  portCollectionId?: string(name='PortCollectionId'),
  portCollectionName?: string(name='PortCollectionName'),
  portList?: [
    Port
  ](name='PortList'),
}

model ResourceInformation {
  architectureId?: string(name='ArchitectureId'),
  createTime?: string(name='CreateTime'),
  information?: [ 
    {
      key?: string(name='Key'),
      keyAction?: string(name='KeyAction'),
      keyAttribute?: string(name='KeyAttribute'),
      keyDescription?: string(name='KeyDescription'),
    }
  ](name='Information'),
  resourceAttribute?: string(name='ResourceAttribute'),
  resourceInformationId?: string(name='ResourceInformationId'),
  resourceType?: string(name='ResourceType'),
  setupProjectId?: string(name='SetupProjectId'),
  updateTime?: string(name='UpdateTime'),
}

model ScheduleDuty {
  createTime?: string(name='CreateTime'),
  endDate?: string(name='EndDate'),
  scheduleDutyId?: string(name='ScheduleDutyId'),
  scheduleTypeIds?: [ string ](name='ScheduleTypeIds'),
  startDate?: string(name='StartDate'),
  typeWorkerList?: [ 
    {
      scheduleTypeId?: string(name='ScheduleTypeId'),
      scheduleWorkerName?: [ string ](name='ScheduleWorkerName'),
    }
  ](name='TypeWorkerList'),
  updateTime?: string(name='UpdateTime'),
  workDate?: string(name='WorkDate'),
  workType?: string(name='WorkType'),
  workerId?: string(name='WorkerId'),
  workerName?: string(name='WorkerName'),
}

model ScheduleType {
  createTime?: string(name='CreateTime'),
  key?: string(name='Key'),
  relatedWorker?: [ string ](name='RelatedWorker'),
  scheduleTypeId?: string(name='ScheduleTypeId'),
  status?: string(name='Status'),
  updateTime?: string(name='UpdateTime'),
  value?: string(name='Value'),
}

model ScheduleWorker {
  createTime?: string(name='CreateTime'),
  scheduleWorkerId?: string(name='ScheduleWorkerId'),
  updateTime?: string(name='UpdateTime'),
  workerContact?: string(name='WorkerContact'),
  workerId?: string(name='WorkerId'),
  workerName?: string(name='WorkerName'),
}

model Scheme {
  category?: string(name='Category'),
  content?: string(name='Content'),
  description?: string(name='Description'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  input?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Input'),
  output?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Output'),
  schemeId?: string(name='SchemeId'),
  schemeName?: string(name='SchemeName'),
  status?: string(name='Status'),
  view?: string(name='View'),
}

model Script {
  content?: string(name='Content'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  input?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Input'),
  output?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Output'),
  rules?: [
    ScriptRule
  ](name='Rules'),
  scriptId?: string(name='ScriptId'),
  templateId?: string(name='TemplateId'),
  versionId?: string(name='VersionId'),
}

model ScriptHistory {
  comment?: string(name='Comment'),
  content?: string(name='Content'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  input?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Input'),
  output?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Output'),
  scriptId?: string(name='ScriptId'),
  versionId?: string(name='VersionId'),
}

model ScriptRule {
  arch?: string(name='Arch'),
  domain?: string(name='Domain'),
  model?: string(name='Model'),
  os?: string(name='Os'),
  role?: string(name='Role'),
  ruleId?: string(name='RuleId'),
  scriptId?: string(name='ScriptId'),
  vendor?: string(name='Vendor'),
}

model SetupProject {
  archId?: string(name='ArchId'),
  archVersion?: string(name='ArchVersion'),
  architectureId?: string(name='ArchitectureId'),
  createTime?: string(name='CreateTime'),
  deliveryTime?: string(name='DeliveryTime'),
  description?: string(name='Description'),
  nodes?: string(name='Nodes'),
  packages?: [ 
    {
      deviceNumber?: string(name='DeviceNumber'),
      model?: string(name='Model'),
      role?: string(name='Role'),
      vendor?: string(name='Vendor'),
    }
  ](name='Packages'),
  setupProjectId?: string(name='SetupProjectId'),
  setupProjectName?: string(name='SetupProjectName'),
  spaceId?: string(name='SpaceId'),
  spaceName?: string(name='SpaceName'),
  spaceType?: string(name='SpaceType'),
  status?: string(name='Status'),
}

model SpaceModel {
  createTime?: string(name='CreateTime'),
  instance?: string(name='Instance'),
  operateType?: string(name='OperateType'),
  sort?: {
    level?: long(name='Level'),
    levelName?: string(name='LevelName'),
  }(name='Sort'),
  spaceId?: string(name='SpaceId'),
  spaceModel?: {
    createTime?: string(name='CreateTime'),
    sort?: {
      level?: long(name='Level'),
      levleName?: string(name='LevleName'),
    }(name='Sort'),
    spaceModelId?: string(name='SpaceModelId'),
    spaceType?: string(name='SpaceType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
  }(name='SpaceModel'),
  spaceModelId?: string(name='SpaceModelId'),
  spaceModelName?: string(name='SpaceModelName'),
  spaceType?: string(name='SpaceType'),
  status?: string(name='Status'),
}

model SubscriptionItem {
  alarmStatus?: string(name='AlarmStatus'),
  language?: string(name='Language'),
  monitorItemId?: string(name='MonitorItemId'),
  notificationGroupId?: string(name='NotificationGroupId'),
  notificationMode?: string(name='NotificationMode'),
  recoveryNotice?: int32(name='RecoveryNotice'),
  subscriptionItemId?: string(name='SubscriptionItemId'),
  subscriptionType?: string(name='SubscriptionType'),
  suppressionStrategy?: string(name='SuppressionStrategy'),
  triggerTimes?: int32(name='TriggerTimes'),
}

model Task {
  category?: string(name='Category'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  params?: string(name='Params'),
  responseCode?: string(name='ResponseCode'),
  result?: string(name='Result'),
  status?: string(name='Status'),
  taskId?: string(name='TaskId'),
  templateId?: string(name='TemplateId'),
  templateName?: string(name='TemplateName'),
}

model TaskLog {
  funcName?: string(name='FuncName'),
  gmtCreate?: string(name='GmtCreate'),
  level?: string(name='Level'),
  lineNo?: int32(name='LineNo'),
  logId?: string(name='LogId'),
  message?: string(name='Message'),
  taskId?: string(name='TaskId'),
}

model Template {
  category?: string(name='Category'),
  comment?: string(name='Comment'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModify?: string(name='GmtModify'),
  input?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Input'),
  output?: [ 
    {
      description?: string(name='Description'),
      name?: string(name='Name'),
      sample?: string(name='Sample'),
      type?: string(name='Type'),
    }
  ](name='Output'),
  templateName?: string(name='TemplateName'),
  templateType?: string(name='TemplateType'),
}

model TimePeriod {
  cronExpression?: string(name='CronExpression'),
  gmtCreate?: string(name='GmtCreate'),
  gmtModified?: string(name='GmtModified'),
  source?: string(name='Source'),
  timePeriodDescription?: string(name='TimePeriodDescription'),
  timePeriodId?: string(name='TimePeriodId'),
  timePeriodName?: string(name='TimePeriodName'),
}

model ZoneType {
  createTime?: string(name='CreateTime'),
  name?: string(name='Name'),
  zoneTypeId?: string(name='ZoneTypeId'),
  zoneTypeLayer?: [ 
    {
      mask?: long(name='Mask'),
      name?: string(name='Name'),
    }
  ](name='ZoneTypeLayer'),
  zoneTypeName?: string(name='ZoneTypeName'),
}

model ApplyIPRequest {
  businessTypeId?: string(name='BusinessTypeId'),
  businessTypeParams?: string(name='BusinessTypeParams'),
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIds?: [ string ](name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  ipType?: string(name='IpType'),
  loopbackPort?: string(name='LoopbackPort'),
  netLocation?: string(name='NetLocation'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ApplyIPShrinkRequest {
  businessTypeId?: string(name='BusinessTypeId'),
  businessTypeParams?: string(name='BusinessTypeParams'),
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIdsShrink?: string(name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  ipType?: string(name='IpType'),
  loopbackPort?: string(name='LoopbackPort'),
  netLocation?: string(name='NetLocation'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ApplyIPResponseBody = {
  requestId?: string(name='RequestId'),
}

model ApplyIPResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ApplyIPResponseBody(name='body'),
}

async function applyIPWithOptions(tmpReq: ApplyIPRequest, runtime: Util.RuntimeOptions): ApplyIPResponse {
  Util.validateModel(tmpReq);
  var request = new ApplyIPShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceResourceIds)) {
    request.deviceResourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceResourceIds, 'DeviceResourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.businessTypeId)) {
    query['BusinessTypeId'] = request.businessTypeId;
  }
  if (!Util.isUnset(request.businessTypeParams)) {
    query['BusinessTypeParams'] = request.businessTypeParams;
  }
  if (!Util.isUnset(request.deviceResourceId)) {
    query['DeviceResourceId'] = request.deviceResourceId;
  }
  if (!Util.isUnset(request.deviceResourceIdsShrink)) {
    query['DeviceResourceIds'] = request.deviceResourceIdsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.loopbackPort)) {
    query['LoopbackPort'] = request.loopbackPort;
  }
  if (!Util.isUnset(request.netLocation)) {
    query['NetLocation'] = request.netLocation;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    query['SetupProjectId'] = request.setupProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ApplyIP',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function applyIP(request: ApplyIPRequest): ApplyIPResponse {
  var runtime = new Util.RuntimeOptions{};
  return applyIPWithOptions(request, runtime);
}

model AutoDutyRequest {
  dutyBatch?: string(name='DutyBatch'),
  dutyName?: string(name='DutyName'),
  endDate?: string(name='EndDate'),
  instanceId?: string(name='InstanceId'),
  startDate?: string(name='StartDate'),
}

model AutoDutyResponseBody = {
  requestId?: string(name='RequestId'),
}

model AutoDutyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: AutoDutyResponseBody(name='body'),
}

async function autoDutyWithOptions(request: AutoDutyRequest, runtime: Util.RuntimeOptions): AutoDutyResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.dutyBatch)) {
    body['DutyBatch'] = request.dutyBatch;
  }
  if (!Util.isUnset(request.dutyName)) {
    body['DutyName'] = request.dutyName;
  }
  if (!Util.isUnset(request.endDate)) {
    body['EndDate'] = request.endDate;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.startDate)) {
    body['StartDate'] = request.startDate;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'AutoDuty',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function autoDuty(request: AutoDutyRequest): AutoDutyResponse {
  var runtime = new Util.RuntimeOptions{};
  return autoDutyWithOptions(request, runtime);
}

model CloseEventRequest {
  eventName?: string(name='EventName'),
  eventObjectId?: string(name='EventObjectId'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
}

model CloseEventResponseBody = {
  requestId?: string(name='RequestId'),
}

model CloseEventResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CloseEventResponseBody(name='body'),
}

async function closeEventWithOptions(request: CloseEventRequest, runtime: Util.RuntimeOptions): CloseEventResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventName)) {
    body['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventObjectId)) {
    body['EventObjectId'] = request.eventObjectId;
  }
  if (!Util.isUnset(request.eventType)) {
    body['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CloseEvent',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function closeEvent(request: CloseEventRequest): CloseEventResponse {
  var runtime = new Util.RuntimeOptions{};
  return closeEventWithOptions(request, runtime);
}

model CreateConfigurationSpecificationRequest {
  architecture?: string(name='Architecture'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  relatedVariate?: [ bytes ](name='RelatedVariate'),
  role?: string(name='Role'),
  specificationContent?: string(name='SpecificationContent'),
  specificationName?: string(name='SpecificationName'),
  vendor?: string(name='Vendor'),
}

model CreateConfigurationSpecificationShrinkRequest {
  architecture?: string(name='Architecture'),
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  relatedVariateShrink?: string(name='RelatedVariate'),
  role?: string(name='Role'),
  specificationContent?: string(name='SpecificationContent'),
  specificationName?: string(name='SpecificationName'),
  vendor?: string(name='Vendor'),
}

model CreateConfigurationSpecificationResponseBody = {
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  requestId?: string(name='RequestId'),
}

model CreateConfigurationSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigurationSpecificationResponseBody(name='body'),
}

async function createConfigurationSpecificationWithOptions(tmpReq: CreateConfigurationSpecificationRequest, runtime: Util.RuntimeOptions): CreateConfigurationSpecificationResponse {
  Util.validateModel(tmpReq);
  var request = new CreateConfigurationSpecificationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.relatedVariate)) {
    request.relatedVariateShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedVariate, 'RelatedVariate', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.architecture)) {
    body['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.relatedVariateShrink)) {
    body['RelatedVariate'] = request.relatedVariateShrink;
  }
  if (!Util.isUnset(request.role)) {
    body['Role'] = request.role;
  }
  if (!Util.isUnset(request.specificationContent)) {
    body['SpecificationContent'] = request.specificationContent;
  }
  if (!Util.isUnset(request.specificationName)) {
    body['SpecificationName'] = request.specificationName;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigurationSpecification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConfigurationSpecification(request: CreateConfigurationSpecificationRequest): CreateConfigurationSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConfigurationSpecificationWithOptions(request, runtime);
}

model CreateConfigurationVariateRequest {
  clientToken?: string(name='ClientToken'),
  comment?: string(name='Comment'),
  formatFunction?: string(name='FormatFunction'),
  instanceId?: string(name='InstanceId'),
  variateName?: string(name='VariateName'),
}

model CreateConfigurationVariateResponseBody = {
  configurationVariateId?: string(name='ConfigurationVariateId'),
  requestId?: string(name='RequestId'),
}

model CreateConfigurationVariateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateConfigurationVariateResponseBody(name='body'),
}

async function createConfigurationVariateWithOptions(request: CreateConfigurationVariateRequest, runtime: Util.RuntimeOptions): CreateConfigurationVariateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.formatFunction)) {
    body['FormatFunction'] = request.formatFunction;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.variateName)) {
    body['VariateName'] = request.variateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateConfigurationVariate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createConfigurationVariate(request: CreateConfigurationVariateRequest): CreateConfigurationVariateResponse {
  var runtime = new Util.RuntimeOptions{};
  return createConfigurationVariateWithOptions(request, runtime);
}

model CreateDedicatedLineRequest {
  bandwidth?: int32(name='Bandwidth'),
  clientToken?: string(name='ClientToken'),
  contact?: string(name='Contact'),
  dedicatedLineGateway?: string(name='DedicatedLineGateway'),
  dedicatedLineIp?: string(name='DedicatedLineIp'),
  dedicatedLineRole?: string(name='DedicatedLineRole'),
  description?: string(name='Description'),
  deviceId?: string(name='DeviceId'),
  devicePort?: string(name='DevicePort'),
  expirationDate?: string(name='ExpirationDate'),
  extAttributes?: string(name='ExtAttributes'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  ispFormId?: string(name='IspFormId'),
  ispId?: string(name='IspId'),
  keyword?: string(name='Keyword'),
  onlineDate?: string(name='OnlineDate'),
  phone?: string(name='Phone'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
}

model CreateDedicatedLineResponseBody = {
  dedicatedLineId?: string(name='DedicatedLineId'),
  requestId?: string(name='RequestId'),
}

model CreateDedicatedLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDedicatedLineResponseBody(name='body'),
}

async function createDedicatedLineWithOptions(request: CreateDedicatedLineRequest, runtime: Util.RuntimeOptions): CreateDedicatedLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bandwidth)) {
    body['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.contact)) {
    body['Contact'] = request.contact;
  }
  if (!Util.isUnset(request.dedicatedLineGateway)) {
    body['DedicatedLineGateway'] = request.dedicatedLineGateway;
  }
  if (!Util.isUnset(request.dedicatedLineIp)) {
    body['DedicatedLineIp'] = request.dedicatedLineIp;
  }
  if (!Util.isUnset(request.dedicatedLineRole)) {
    body['DedicatedLineRole'] = request.dedicatedLineRole;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.devicePort)) {
    body['DevicePort'] = request.devicePort;
  }
  if (!Util.isUnset(request.expirationDate)) {
    body['ExpirationDate'] = request.expirationDate;
  }
  if (!Util.isUnset(request.extAttributes)) {
    body['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.isp)) {
    body['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.ispFormId)) {
    body['IspFormId'] = request.ispFormId;
  }
  if (!Util.isUnset(request.ispId)) {
    body['IspId'] = request.ispId;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.onlineDate)) {
    body['OnlineDate'] = request.onlineDate;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDedicatedLine',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDedicatedLine(request: CreateDedicatedLineRequest): CreateDedicatedLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDedicatedLineWithOptions(request, runtime);
}

model CreateDeviceRequest {
  clientToken?: string(name='ClientToken'),
  deviceFormId?: string(name='DeviceFormId'),
  enablePassword?: string(name='EnablePassword'),
  extAttributes?: string(name='ExtAttributes'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  loginPassword?: string(name='LoginPassword'),
  loginType?: string(name='LoginType'),
  loginUsername?: string(name='LoginUsername'),
  mac?: string(name='Mac'),
  model?: string(name='Model'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  securityDomain?: string(name='SecurityDomain'),
  serviceStatus?: string(name='ServiceStatus'),
  sn?: string(name='Sn'),
  snmpAccountType?: string(name='SnmpAccountType'),
  snmpAccountVersion?: string(name='SnmpAccountVersion'),
  snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
  snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
  snmpCommunity?: string(name='SnmpCommunity'),
  snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
  snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
  snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
  snmpUsername?: string(name='SnmpUsername'),
  vendor?: string(name='Vendor'),
}

model CreateDeviceResponseBody = {
  deviceId?: string(name='DeviceId'),
  requestId?: string(name='RequestId'),
}

model CreateDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceResponseBody(name='body'),
}

async function createDeviceWithOptions(request: CreateDeviceRequest, runtime: Util.RuntimeOptions): CreateDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deviceFormId)) {
    body['DeviceFormId'] = request.deviceFormId;
  }
  if (!Util.isUnset(request.enablePassword)) {
    body['EnablePassword'] = request.enablePassword;
  }
  if (!Util.isUnset(request.extAttributes)) {
    body['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.hostName)) {
    body['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.ip)) {
    body['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['LoginPassword'] = request.loginPassword;
  }
  if (!Util.isUnset(request.loginType)) {
    body['LoginType'] = request.loginType;
  }
  if (!Util.isUnset(request.loginUsername)) {
    body['LoginUsername'] = request.loginUsername;
  }
  if (!Util.isUnset(request.mac)) {
    body['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.securityDomain)) {
    body['SecurityDomain'] = request.securityDomain;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    body['ServiceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.sn)) {
    body['Sn'] = request.sn;
  }
  if (!Util.isUnset(request.snmpAccountType)) {
    body['SnmpAccountType'] = request.snmpAccountType;
  }
  if (!Util.isUnset(request.snmpAccountVersion)) {
    body['SnmpAccountVersion'] = request.snmpAccountVersion;
  }
  if (!Util.isUnset(request.snmpAuthPassphrase)) {
    body['SnmpAuthPassphrase'] = request.snmpAuthPassphrase;
  }
  if (!Util.isUnset(request.snmpAuthProtocol)) {
    body['SnmpAuthProtocol'] = request.snmpAuthProtocol;
  }
  if (!Util.isUnset(request.snmpCommunity)) {
    body['SnmpCommunity'] = request.snmpCommunity;
  }
  if (!Util.isUnset(request.snmpPrivacyPassphrase)) {
    body['SnmpPrivacyPassphrase'] = request.snmpPrivacyPassphrase;
  }
  if (!Util.isUnset(request.snmpPrivacyProtocol)) {
    body['SnmpPrivacyProtocol'] = request.snmpPrivacyProtocol;
  }
  if (!Util.isUnset(request.snmpSecurityLevel)) {
    body['SnmpSecurityLevel'] = request.snmpSecurityLevel;
  }
  if (!Util.isUnset(request.snmpUsername)) {
    body['SnmpUsername'] = request.snmpUsername;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevice',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevice(request: CreateDeviceRequest): CreateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceWithOptions(request, runtime);
}

model CreateDeviceFormRequest {
  accountConfig?: boolean(name='AccountConfig'),
  clientToken?: string(name='ClientToken'),
  configCompare?: boolean(name='ConfigCompare'),
  detailDisplay?: boolean(name='DetailDisplay'),
  deviceFormName?: string(name='DeviceFormName'),
  instanceId?: string(name='InstanceId'),
  relatedDeviceFormId?: string(name='RelatedDeviceFormId'),
  resourceUse?: string(name='ResourceUse'),
  script?: string(name='Script'),
  uniqueKey?: string(name='UniqueKey'),
}

model CreateDeviceFormResponseBody = {
  deviceFormId?: string(name='DeviceFormId'),
  requestId?: string(name='RequestId'),
}

model CreateDeviceFormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDeviceFormResponseBody(name='body'),
}

async function createDeviceFormWithOptions(request: CreateDeviceFormRequest, runtime: Util.RuntimeOptions): CreateDeviceFormResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountConfig)) {
    body['AccountConfig'] = request.accountConfig;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.configCompare)) {
    body['ConfigCompare'] = request.configCompare;
  }
  if (!Util.isUnset(request.detailDisplay)) {
    body['DetailDisplay'] = request.detailDisplay;
  }
  if (!Util.isUnset(request.deviceFormName)) {
    body['DeviceFormName'] = request.deviceFormName;
  }
  if (!Util.isUnset(request.relatedDeviceFormId)) {
    body['RelatedDeviceFormId'] = request.relatedDeviceFormId;
  }
  if (!Util.isUnset(request.resourceUse)) {
    body['ResourceUse'] = request.resourceUse;
  }
  if (!Util.isUnset(request.script)) {
    body['Script'] = request.script;
  }
  if (!Util.isUnset(request.uniqueKey)) {
    body['UniqueKey'] = request.uniqueKey;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceForm',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeviceForm(request: CreateDeviceFormRequest): CreateDeviceFormResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDeviceFormWithOptions(request, runtime);
}

model CreateDevicePropertyRequest {
  clientToken?: string(name='ClientToken'),
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
  propertyContent?: string(name='PropertyContent'),
  propertyFormat?: string(name='PropertyFormat'),
  propertyKey?: string(name='PropertyKey'),
  propertyName?: string(name='PropertyName'),
}

model CreateDevicePropertyResponseBody = {
  devicePropertyId?: string(name='DevicePropertyId'),
  requestId?: string(name='RequestId'),
}

model CreateDevicePropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDevicePropertyResponseBody(name='body'),
}

async function createDevicePropertyWithOptions(request: CreateDevicePropertyRequest, runtime: Util.RuntimeOptions): CreateDevicePropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deviceFormId)) {
    body['DeviceFormId'] = request.deviceFormId;
  }
  if (!Util.isUnset(request.propertyContent)) {
    body['PropertyContent'] = request.propertyContent;
  }
  if (!Util.isUnset(request.propertyFormat)) {
    body['PropertyFormat'] = request.propertyFormat;
  }
  if (!Util.isUnset(request.propertyKey)) {
    body['PropertyKey'] = request.propertyKey;
  }
  if (!Util.isUnset(request.propertyName)) {
    body['PropertyName'] = request.propertyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDeviceProperty',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDeviceProperty(request: CreateDevicePropertyRequest): CreateDevicePropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevicePropertyWithOptions(request, runtime);
}

model CreateDevicesRequest {
  clientToken?: string(name='ClientToken'),
  deviceFormId?: string(name='DeviceFormId'),
  deviceParamModelList?: [ 
    {
      enablePassword?: string(name='EnablePassword'),
      extAttributes?: string(name='ExtAttributes'),
      hostName?: string(name='HostName'),
      ip?: string(name='Ip'),
      loginPassword?: string(name='LoginPassword'),
      loginType?: string(name='LoginType'),
      loginUsername?: string(name='LoginUsername'),
      mac?: string(name='Mac'),
      model?: string(name='Model'),
      physicalSpaceName?: string(name='PhysicalSpaceName'),
      securityDomain?: string(name='SecurityDomain'),
      serviceStatus?: string(name='ServiceStatus'),
      sn?: string(name='Sn'),
      snmpAccountType?: string(name='SnmpAccountType'),
      snmpAccountVersion?: string(name='SnmpAccountVersion'),
      snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
      snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
      snmpCommunity?: string(name='SnmpCommunity'),
      snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
      snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
      snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
      snmpUsername?: string(name='SnmpUsername'),
      vendor?: string(name='Vendor'),
    }
  ](name='DeviceParamModelList'),
  instanceId?: string(name='InstanceId'),
}

model CreateDevicesShrinkRequest {
  clientToken?: string(name='ClientToken'),
  deviceFormId?: string(name='DeviceFormId'),
  deviceParamModelListShrink?: string(name='DeviceParamModelList'),
  instanceId?: string(name='InstanceId'),
}

model CreateDevicesResponseBody = {
  deviceId?: string(name='DeviceId'),
  requestId?: string(name='RequestId'),
}

model CreateDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateDevicesResponseBody(name='body'),
}

async function createDevicesWithOptions(tmpReq: CreateDevicesRequest, runtime: Util.RuntimeOptions): CreateDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new CreateDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceParamModelList)) {
    request.deviceParamModelListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceParamModelList, 'DeviceParamModelList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deviceFormId)) {
    body['DeviceFormId'] = request.deviceFormId;
  }
  if (!Util.isUnset(request.deviceParamModelListShrink)) {
    body['DeviceParamModelList'] = request.deviceParamModelListShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateDevices',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createDevices(request: CreateDevicesRequest): CreateDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return createDevicesWithOptions(request, runtime);
}

model CreateEventDefinitionRequest {
  clientToken?: string(name='ClientToken'),
  eventName?: string(name='EventName'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  templateId?: string(name='TemplateId'),
}

model CreateEventDefinitionResponseBody = {
  eventId?: string(name='EventId'),
  requestId?: string(name='RequestId'),
}

model CreateEventDefinitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateEventDefinitionResponseBody(name='body'),
}

async function createEventDefinitionWithOptions(request: CreateEventDefinitionRequest, runtime: Util.RuntimeOptions): CreateEventDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.eventName)) {
    body['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    body['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateEventDefinition',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createEventDefinition(request: CreateEventDefinitionRequest): CreateEventDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createEventDefinitionWithOptions(request, runtime);
}

model CreateLinkJobRequest {
  autoConfirm?: boolean(name='AutoConfirm'),
  doubleConvertStrategy?: string(name='DoubleConvertStrategy'),
  instanceId?: string(name='InstanceId'),
  jobId?: string(name='JobId'),
  singleStrategy?: string(name='SingleStrategy'),
}

model CreateLinkJobResponseBody = {
  content?: string(name='Content'),
  requestId?: string(name='RequestId'),
}

model CreateLinkJobResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateLinkJobResponseBody(name='body'),
}

async function createLinkJobWithOptions(request: CreateLinkJobRequest, runtime: Util.RuntimeOptions): CreateLinkJobResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.autoConfirm)) {
    body['AutoConfirm'] = request.autoConfirm;
  }
  if (!Util.isUnset(request.doubleConvertStrategy)) {
    body['DoubleConvertStrategy'] = request.doubleConvertStrategy;
  }
  if (!Util.isUnset(request.jobId)) {
    body['JobId'] = request.jobId;
  }
  if (!Util.isUnset(request.singleStrategy)) {
    body['SingleStrategy'] = request.singleStrategy;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateLinkJob',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createLinkJob(request: CreateLinkJobRequest): CreateLinkJobResponse {
  var runtime = new Util.RuntimeOptions{};
  return createLinkJobWithOptions(request, runtime);
}

model CreateMonitorItemRequest {
  alarmRuleList?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      expression?: string(name='Expression'),
      value?: string(name='Value'),
      variable?: string(name='Variable'),
    }
  ](name='AlarmRuleList'),
  analysisCode?: string(name='AnalysisCode'),
  clientToken?: string(name='ClientToken'),
  collectionType?: string(name='CollectionType'),
  config?: string(name='Config'),
  dataItem?: string(name='DataItem'),
  deviceForm?: string(name='DeviceForm'),
  effective?: int32(name='Effective'),
  execInterval?: int32(name='ExecInterval'),
  instanceId?: string(name='InstanceId'),
  monitorItemDescription?: string(name='MonitorItemDescription'),
  monitorItemName?: string(name='MonitorItemName'),
  securityDomain?: string(name='SecurityDomain'),
  type?: string(name='Type'),
}

model CreateMonitorItemShrinkRequest {
  alarmRuleListShrink?: string(name='AlarmRuleList'),
  analysisCode?: string(name='AnalysisCode'),
  clientToken?: string(name='ClientToken'),
  collectionType?: string(name='CollectionType'),
  config?: string(name='Config'),
  dataItem?: string(name='DataItem'),
  deviceForm?: string(name='DeviceForm'),
  effective?: int32(name='Effective'),
  execInterval?: int32(name='ExecInterval'),
  instanceId?: string(name='InstanceId'),
  monitorItemDescription?: string(name='MonitorItemDescription'),
  monitorItemName?: string(name='MonitorItemName'),
  securityDomain?: string(name='SecurityDomain'),
  type?: string(name='Type'),
}

model CreateMonitorItemResponseBody = {
  monitorItemId?: string(name='MonitorItemId'),
  requestId?: string(name='RequestId'),
}

model CreateMonitorItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateMonitorItemResponseBody(name='body'),
}

async function createMonitorItemWithOptions(tmpReq: CreateMonitorItemRequest, runtime: Util.RuntimeOptions): CreateMonitorItemResponse {
  Util.validateModel(tmpReq);
  var request = new CreateMonitorItemShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alarmRuleList)) {
    request.alarmRuleListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alarmRuleList, 'AlarmRuleList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmRuleListShrink)) {
    body['AlarmRuleList'] = request.alarmRuleListShrink;
  }
  if (!Util.isUnset(request.analysisCode)) {
    body['AnalysisCode'] = request.analysisCode;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.collectionType)) {
    body['CollectionType'] = request.collectionType;
  }
  if (!Util.isUnset(request.config)) {
    body['Config'] = request.config;
  }
  if (!Util.isUnset(request.dataItem)) {
    body['DataItem'] = request.dataItem;
  }
  if (!Util.isUnset(request.deviceForm)) {
    body['DeviceForm'] = request.deviceForm;
  }
  if (!Util.isUnset(request.effective)) {
    body['Effective'] = request.effective;
  }
  if (!Util.isUnset(request.execInterval)) {
    body['ExecInterval'] = request.execInterval;
  }
  if (!Util.isUnset(request.monitorItemDescription)) {
    body['MonitorItemDescription'] = request.monitorItemDescription;
  }
  if (!Util.isUnset(request.monitorItemName)) {
    body['MonitorItemName'] = request.monitorItemName;
  }
  if (!Util.isUnset(request.securityDomain)) {
    body['SecurityDomain'] = request.securityDomain;
  }
  if (!Util.isUnset(request.type)) {
    body['Type'] = request.type;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateMonitorItem',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createMonitorItem(request: CreateMonitorItemRequest): CreateMonitorItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return createMonitorItemWithOptions(request, runtime);
}

model CreateOsVersionRequest {
  clientToken?: string(name='ClientToken'),
  createTime?: string(name='CreateTime'),
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  osVersion?: string(name='OsVersion'),
  status?: string(name='Status'),
  vendor?: string(name='Vendor'),
}

model CreateOsVersionResponseBody = {
  osVersionId?: string(name='OsVersionId'),
  requestId?: string(name='RequestId'),
}

model CreateOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateOsVersionResponseBody(name='body'),
}

async function createOsVersionWithOptions(request: CreateOsVersionRequest, runtime: Util.RuntimeOptions): CreateOsVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.createTime)) {
    body['CreateTime'] = request.createTime;
  }
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.osVersion)) {
    body['OsVersion'] = request.osVersion;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateOsVersion',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createOsVersion(request: CreateOsVersionRequest): CreateOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return createOsVersionWithOptions(request, runtime);
}

model CreatePhysicalSpaceRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  clientToken?: string(name='ClientToken'),
  country?: string(name='Country'),
  instanceId?: string(name='InstanceId'),
  owner?: string(name='Owner'),
  parentUid?: string(name='ParentUid'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  province?: string(name='Province'),
  remark?: string(name='Remark'),
  securityDomainList?: [ string ](name='SecurityDomainList'),
  spaceAbbreviation?: string(name='SpaceAbbreviation'),
  spaceType?: string(name='SpaceType'),
}

model CreatePhysicalSpaceShrinkRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  clientToken?: string(name='ClientToken'),
  country?: string(name='Country'),
  instanceId?: string(name='InstanceId'),
  owner?: string(name='Owner'),
  parentUid?: string(name='ParentUid'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  province?: string(name='Province'),
  remark?: string(name='Remark'),
  securityDomainListShrink?: string(name='SecurityDomainList'),
  spaceAbbreviation?: string(name='SpaceAbbreviation'),
  spaceType?: string(name='SpaceType'),
}

model CreatePhysicalSpaceResponseBody = {
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  requestId?: string(name='RequestId'),
}

model CreatePhysicalSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreatePhysicalSpaceResponseBody(name='body'),
}

async function createPhysicalSpaceWithOptions(tmpReq: CreatePhysicalSpaceRequest, runtime: Util.RuntimeOptions): CreatePhysicalSpaceResponse {
  Util.validateModel(tmpReq);
  var request = new CreatePhysicalSpaceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.securityDomainList)) {
    request.securityDomainListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.securityDomainList, 'SecurityDomainList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    body['City'] = request.city;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.country)) {
    body['Country'] = request.country;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.parentUid)) {
    body['ParentUid'] = request.parentUid;
  }
  if (!Util.isUnset(request.physicalSpaceName)) {
    body['PhysicalSpaceName'] = request.physicalSpaceName;
  }
  if (!Util.isUnset(request.province)) {
    body['Province'] = request.province;
  }
  if (!Util.isUnset(request.remark)) {
    body['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.securityDomainListShrink)) {
    body['SecurityDomainList'] = request.securityDomainListShrink;
  }
  if (!Util.isUnset(request.spaceAbbreviation)) {
    body['SpaceAbbreviation'] = request.spaceAbbreviation;
  }
  if (!Util.isUnset(request.spaceType)) {
    body['SpaceType'] = request.spaceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreatePhysicalSpace',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createPhysicalSpace(request: CreatePhysicalSpaceRequest): CreatePhysicalSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return createPhysicalSpaceWithOptions(request, runtime);
}

model CreateRealtimeTaskRequest {
  checkDuplicatePolicy?: string(name='CheckDuplicatePolicy'),
  clientToken?: string(name='ClientToken'),
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
  itemName?: string(name='ItemName'),
  script?: string(name='Script'),
}

model CreateRealtimeTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateRealtimeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateRealtimeTaskResponseBody(name='body'),
}

async function createRealtimeTaskWithOptions(request: CreateRealtimeTaskRequest, runtime: Util.RuntimeOptions): CreateRealtimeTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.checkDuplicatePolicy)) {
    body['CheckDuplicatePolicy'] = request.checkDuplicatePolicy;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.itemName)) {
    body['ItemName'] = request.itemName;
  }
  if (!Util.isUnset(request.script)) {
    body['Script'] = request.script;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateRealtimeTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createRealtimeTask(request: CreateRealtimeTaskRequest): CreateRealtimeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createRealtimeTaskWithOptions(request, runtime);
}

model CreateResourceInformationRequest {
  architectureId?: string(name='ArchitectureId'),
  clientToken?: string(name='ClientToken'),
  information?: [ 
    {
      key?: string(name='Key'),
      keyAction?: string(name='KeyAction'),
      keyAttribute?: string(name='KeyAttribute'),
      keyDescription?: string(name='KeyDescription'),
    }
  ](name='Information'),
  instanceId?: string(name='InstanceId'),
  resourceAttribute?: string(name='ResourceAttribute'),
  resourceType?: string(name='ResourceType'),
}

model CreateResourceInformationResponseBody = {
  requestId?: string(name='RequestId'),
  resourceInformationId?: string(name='ResourceInformationId'),
}

model CreateResourceInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateResourceInformationResponseBody(name='body'),
}

async function createResourceInformationWithOptions(request: CreateResourceInformationRequest, runtime: Util.RuntimeOptions): CreateResourceInformationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.clientToken)) {
    query['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.architectureId)) {
    body['ArchitectureId'] = request.architectureId;
  }
  var bodyFlat : map[string]any = {};
  if (!Util.isUnset(request.information)) {
    bodyFlat['Information'] = request.information;
  }
  if (!Util.isUnset(request.resourceAttribute)) {
    body['ResourceAttribute'] = request.resourceAttribute;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  body = {
    ...body,
    ...OpenApiUtil.query(bodyFlat),
  };

  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateResourceInformation',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createResourceInformation(request: CreateResourceInformationRequest): CreateResourceInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return createResourceInformationWithOptions(request, runtime);
}

model CreateSetupProjectRequest {
  deliveryTime?: string(name='DeliveryTime'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  spaceId?: string(name='SpaceId'),
}

model CreateSetupProjectResponseBody = {
  requestId?: string(name='RequestId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model CreateSetupProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSetupProjectResponseBody(name='body'),
}

async function createSetupProjectWithOptions(request: CreateSetupProjectRequest, runtime: Util.RuntimeOptions): CreateSetupProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliveryTime)) {
    body['DeliveryTime'] = request.deliveryTime;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSetupProject',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSetupProject(request: CreateSetupProjectRequest): CreateSetupProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSetupProjectWithOptions(request, runtime);
}

model CreateSpaceModelRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  sort?: [ 
    {
      level?: long(name='Level'),
      levelName?: string(name='LevelName'),
    }
  ](name='Sort'),
  spaceType?: string(name='SpaceType'),
}

model CreateSpaceModelShrinkRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  sortShrink?: string(name='Sort'),
  spaceType?: string(name='SpaceType'),
}

model CreateSpaceModelResponseBody = {
  requestId?: string(name='RequestId'),
  spaceModelId?: string(name='SpaceModelId'),
}

model CreateSpaceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateSpaceModelResponseBody(name='body'),
}

async function createSpaceModelWithOptions(tmpReq: CreateSpaceModelRequest, runtime: Util.RuntimeOptions): CreateSpaceModelResponse {
  Util.validateModel(tmpReq);
  var request = new CreateSpaceModelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sort)) {
    request.sortShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sort, 'Sort', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sortShrink)) {
    body['Sort'] = request.sortShrink;
  }
  if (!Util.isUnset(request.spaceType)) {
    body['SpaceType'] = request.spaceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateSpaceModel',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createSpaceModel(request: CreateSpaceModelRequest): CreateSpaceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return createSpaceModelWithOptions(request, runtime);
}

model CreateTaskRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  params?: string(name='Params'),
  templateId?: string(name='TemplateId'),
}

model CreateTaskResponseBody = {
  requestId?: string(name='RequestId'),
  taskId?: string(name='TaskId'),
}

model CreateTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTaskResponseBody(name='body'),
}

async function createTaskWithOptions(request: CreateTaskRequest, runtime: Util.RuntimeOptions): CreateTaskResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.params)) {
    body['Params'] = request.params;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTask(request: CreateTaskRequest): CreateTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTaskWithOptions(request, runtime);
}

model CreateTimePeriodRequest {
  clientToken?: string(name='ClientToken'),
  expression?: string(name='Expression'),
  instanceId?: string(name='InstanceId'),
  timePeriodDescription?: string(name='TimePeriodDescription'),
  timePeriodName?: string(name='TimePeriodName'),
}

model CreateTimePeriodResponseBody = {
  requestId?: string(name='RequestId'),
  timePeriodId?: string(name='TimePeriodId'),
}

model CreateTimePeriodResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateTimePeriodResponseBody(name='body'),
}

async function createTimePeriodWithOptions(request: CreateTimePeriodRequest, runtime: Util.RuntimeOptions): CreateTimePeriodResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.expression)) {
    body['Expression'] = request.expression;
  }
  if (!Util.isUnset(request.timePeriodDescription)) {
    body['TimePeriodDescription'] = request.timePeriodDescription;
  }
  if (!Util.isUnset(request.timePeriodName)) {
    body['TimePeriodName'] = request.timePeriodName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateTimePeriod',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createTimePeriod(request: CreateTimePeriodRequest): CreateTimePeriodResponse {
  var runtime = new Util.RuntimeOptions{};
  return createTimePeriodWithOptions(request, runtime);
}

model CreateWorkOrderRequest {
  alarmHappenTime?: string(name='AlarmHappenTime'),
  alarmRecoverTime?: string(name='AlarmRecoverTime'),
  alarmRelated?: string(name='AlarmRelated'),
  area?: string(name='Area'),
  circuitId?: string(name='CircuitId'),
  circuitName?: string(name='CircuitName'),
  circuitType?: string(name='CircuitType'),
  clientToken?: string(name='ClientToken'),
  deviceIp?: string(name='DeviceIp'),
  deviceIpA?: string(name='DeviceIpA'),
  deviceIpB?: string(name='DeviceIpB'),
  deviceModelA?: string(name='DeviceModelA'),
  deviceModelB?: string(name='DeviceModelB'),
  deviceName?: string(name='DeviceName'),
  deviceNameA?: string(name='DeviceNameA'),
  deviceNameB?: string(name='DeviceNameB'),
  devicePortA?: string(name='DevicePortA'),
  devicePortB?: string(name='DevicePortB'),
  deviceSnA?: string(name='DeviceSnA'),
  deviceSnB?: string(name='DeviceSnB'),
  deviceType?: string(name='DeviceType'),
  deviceVendor?: string(name='DeviceVendor'),
  deviceVendorA?: string(name='DeviceVendorA'),
  deviceVendorB?: string(name='DeviceVendorB'),
  emergencyDegree?: string(name='EmergencyDegree'),
  impactBusiness?: string(name='ImpactBusiness'),
  incidentDescription?: string(name='IncidentDescription'),
  incidentSubType?: string(name='IncidentSubType'),
  incidentType?: string(name='IncidentType'),
  instanceId?: string(name='InstanceId'),
  liableMan?: string(name='LiableMan'),
  linkMan?: string(name='LinkMan'),
  originalSubjectAlarm?: string(name='OriginalSubjectAlarm'),
  processLimited?: string(name='ProcessLimited'),
  processMan?: string(name='ProcessMan'),
  processManId?: string(name='ProcessManId'),
  skillGroups?: string(name='SkillGroups'),
  workOrderSource?: string(name='WorkOrderSource'),
  workOrderStep?: string(name='WorkOrderStep'),
  workOrderTitle?: string(name='WorkOrderTitle'),
  workOrderType?: string(name='WorkOrderType'),
}

model CreateWorkOrderResponseBody = {
  requestId?: string(name='RequestId'),
  workOrderId?: string(name='WorkOrderId'),
}

model CreateWorkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: CreateWorkOrderResponseBody(name='body'),
}

async function createWorkOrderWithOptions(request: CreateWorkOrderRequest, runtime: Util.RuntimeOptions): CreateWorkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmHappenTime)) {
    body['AlarmHappenTime'] = request.alarmHappenTime;
  }
  if (!Util.isUnset(request.alarmRecoverTime)) {
    body['AlarmRecoverTime'] = request.alarmRecoverTime;
  }
  if (!Util.isUnset(request.alarmRelated)) {
    body['AlarmRelated'] = request.alarmRelated;
  }
  if (!Util.isUnset(request.area)) {
    body['Area'] = request.area;
  }
  if (!Util.isUnset(request.circuitId)) {
    body['CircuitId'] = request.circuitId;
  }
  if (!Util.isUnset(request.circuitName)) {
    body['CircuitName'] = request.circuitName;
  }
  if (!Util.isUnset(request.circuitType)) {
    body['CircuitType'] = request.circuitType;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deviceIp)) {
    body['DeviceIp'] = request.deviceIp;
  }
  if (!Util.isUnset(request.deviceIpA)) {
    body['DeviceIpA'] = request.deviceIpA;
  }
  if (!Util.isUnset(request.deviceIpB)) {
    body['DeviceIpB'] = request.deviceIpB;
  }
  if (!Util.isUnset(request.deviceModelA)) {
    body['DeviceModelA'] = request.deviceModelA;
  }
  if (!Util.isUnset(request.deviceModelB)) {
    body['DeviceModelB'] = request.deviceModelB;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceNameA)) {
    body['DeviceNameA'] = request.deviceNameA;
  }
  if (!Util.isUnset(request.deviceNameB)) {
    body['DeviceNameB'] = request.deviceNameB;
  }
  if (!Util.isUnset(request.devicePortA)) {
    body['DevicePortA'] = request.devicePortA;
  }
  if (!Util.isUnset(request.devicePortB)) {
    body['DevicePortB'] = request.devicePortB;
  }
  if (!Util.isUnset(request.deviceSnA)) {
    body['DeviceSnA'] = request.deviceSnA;
  }
  if (!Util.isUnset(request.deviceSnB)) {
    body['DeviceSnB'] = request.deviceSnB;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.deviceVendor)) {
    body['DeviceVendor'] = request.deviceVendor;
  }
  if (!Util.isUnset(request.deviceVendorA)) {
    body['DeviceVendorA'] = request.deviceVendorA;
  }
  if (!Util.isUnset(request.deviceVendorB)) {
    body['DeviceVendorB'] = request.deviceVendorB;
  }
  if (!Util.isUnset(request.emergencyDegree)) {
    body['EmergencyDegree'] = request.emergencyDegree;
  }
  if (!Util.isUnset(request.impactBusiness)) {
    body['ImpactBusiness'] = request.impactBusiness;
  }
  if (!Util.isUnset(request.incidentDescription)) {
    body['IncidentDescription'] = request.incidentDescription;
  }
  if (!Util.isUnset(request.incidentSubType)) {
    body['IncidentSubType'] = request.incidentSubType;
  }
  if (!Util.isUnset(request.incidentType)) {
    body['IncidentType'] = request.incidentType;
  }
  if (!Util.isUnset(request.liableMan)) {
    body['LiableMan'] = request.liableMan;
  }
  if (!Util.isUnset(request.linkMan)) {
    body['LinkMan'] = request.linkMan;
  }
  if (!Util.isUnset(request.originalSubjectAlarm)) {
    body['OriginalSubjectAlarm'] = request.originalSubjectAlarm;
  }
  if (!Util.isUnset(request.processLimited)) {
    body['ProcessLimited'] = request.processLimited;
  }
  if (!Util.isUnset(request.processMan)) {
    body['ProcessMan'] = request.processMan;
  }
  if (!Util.isUnset(request.processManId)) {
    body['ProcessManId'] = request.processManId;
  }
  if (!Util.isUnset(request.skillGroups)) {
    body['SkillGroups'] = request.skillGroups;
  }
  if (!Util.isUnset(request.workOrderSource)) {
    body['WorkOrderSource'] = request.workOrderSource;
  }
  if (!Util.isUnset(request.workOrderStep)) {
    body['WorkOrderStep'] = request.workOrderStep;
  }
  if (!Util.isUnset(request.workOrderTitle)) {
    body['WorkOrderTitle'] = request.workOrderTitle;
  }
  if (!Util.isUnset(request.workOrderType)) {
    body['WorkOrderType'] = request.workOrderType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'CreateWorkOrder',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function createWorkOrder(request: CreateWorkOrderRequest): CreateWorkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return createWorkOrderWithOptions(request, runtime);
}

model DeleteConfigurationSpecificationRequest {
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteConfigurationSpecificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteConfigurationSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConfigurationSpecificationResponseBody(name='body'),
}

async function deleteConfigurationSpecificationWithOptions(request: DeleteConfigurationSpecificationRequest, runtime: Util.RuntimeOptions): DeleteConfigurationSpecificationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.configurationSpecificationId)) {
    body['ConfigurationSpecificationId'] = request.configurationSpecificationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigurationSpecification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConfigurationSpecification(request: DeleteConfigurationSpecificationRequest): DeleteConfigurationSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConfigurationSpecificationWithOptions(request, runtime);
}

model DeleteConfigurationVariateRequest {
  configurationVariateId?: string(name='ConfigurationVariateId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteConfigurationVariateResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteConfigurationVariateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteConfigurationVariateResponseBody(name='body'),
}

async function deleteConfigurationVariateWithOptions(request: DeleteConfigurationVariateRequest, runtime: Util.RuntimeOptions): DeleteConfigurationVariateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.configurationVariateId)) {
    body['ConfigurationVariateId'] = request.configurationVariateId;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteConfigurationVariate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteConfigurationVariate(request: DeleteConfigurationVariateRequest): DeleteConfigurationVariateResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteConfigurationVariateWithOptions(request, runtime);
}

model DeleteDedicatedLineRequest {
  dedicatedLineId?: string(name='DedicatedLineId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDedicatedLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDedicatedLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDedicatedLineResponseBody(name='body'),
}

async function deleteDedicatedLineWithOptions(request: DeleteDedicatedLineRequest, runtime: Util.RuntimeOptions): DeleteDedicatedLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.dedicatedLineId)) {
    body['DedicatedLineId'] = request.dedicatedLineId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDedicatedLine',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDedicatedLine(request: DeleteDedicatedLineRequest): DeleteDedicatedLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDedicatedLineWithOptions(request, runtime);
}

model DeleteDeliveryArchVersionRequest {
  deliveryArchVersionId?: string(name='DeliveryArchVersionId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDeliveryArchVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeliveryArchVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeliveryArchVersionResponseBody(name='body'),
}

async function deleteDeliveryArchVersionWithOptions(request: DeleteDeliveryArchVersionRequest, runtime: Util.RuntimeOptions): DeleteDeliveryArchVersionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliveryArchVersionId)) {
    body['DeliveryArchVersionId'] = request.deliveryArchVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeliveryArchVersion',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeliveryArchVersion(request: DeleteDeliveryArchVersionRequest): DeleteDeliveryArchVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeliveryArchVersionWithOptions(request, runtime);
}

model DeleteDeliveryProjectRequest {
  deliveryProjectId?: string(name='DeliveryProjectId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDeliveryProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeliveryProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeliveryProjectResponseBody(name='body'),
}

async function deleteDeliveryProjectWithOptions(request: DeleteDeliveryProjectRequest, runtime: Util.RuntimeOptions): DeleteDeliveryProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deliveryProjectId)) {
    body['DeliveryProjectId'] = request.deliveryProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeliveryProject',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeliveryProject(request: DeleteDeliveryProjectRequest): DeleteDeliveryProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeliveryProjectWithOptions(request, runtime);
}

model DeleteDeviceRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceResponseBody(name='body'),
}

async function deleteDeviceWithOptions(request: DeleteDeviceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevice',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevice(request: DeleteDeviceRequest): DeleteDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceWithOptions(request, runtime);
}

model DeleteDeviceFormRequest {
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDeviceFormResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeviceFormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceFormResponseBody(name='body'),
}

async function deleteDeviceFormWithOptions(request: DeleteDeviceFormRequest, runtime: Util.RuntimeOptions): DeleteDeviceFormResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceFormId)) {
    body['DeviceFormId'] = request.deviceFormId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceForm',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeviceForm(request: DeleteDeviceFormRequest): DeleteDeviceFormResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceFormWithOptions(request, runtime);
}

model DeleteDevicePropertyRequest {
  devicePropertyId?: string(name='DevicePropertyId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDevicePropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDevicePropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevicePropertyResponseBody(name='body'),
}

async function deleteDevicePropertyWithOptions(request: DeleteDevicePropertyRequest, runtime: Util.RuntimeOptions): DeleteDevicePropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.devicePropertyId)) {
    body['DevicePropertyId'] = request.devicePropertyId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceProperty',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeviceProperty(request: DeleteDevicePropertyRequest): DeleteDevicePropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevicePropertyWithOptions(request, runtime);
}

model DeleteDeviceResourceRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDeviceResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDeviceResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDeviceResourceResponseBody(name='body'),
}

async function deleteDeviceResourceWithOptions(request: DeleteDeviceResourceRequest, runtime: Util.RuntimeOptions): DeleteDeviceResourceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.deviceResourceId)) {
    query['DeviceResourceId'] = request.deviceResourceId;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDeviceResource',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDeviceResource(request: DeleteDeviceResourceRequest): DeleteDeviceResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDeviceResourceWithOptions(request, runtime);
}

model DeleteDevicesRequest {
  deviceIds?: [ string ](name='DeviceIds'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDevicesShrinkRequest {
  deviceIdsShrink?: string(name='DeviceIds'),
  instanceId?: string(name='InstanceId'),
}

model DeleteDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteDevicesResponseBody(name='body'),
}

async function deleteDevicesWithOptions(tmpReq: DeleteDevicesRequest, runtime: Util.RuntimeOptions): DeleteDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new DeleteDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceIds)) {
    request.deviceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceIds, 'DeviceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceIdsShrink)) {
    body['DeviceIds'] = request.deviceIdsShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteDevices',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteDevices(request: DeleteDevicesRequest): DeleteDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteDevicesWithOptions(request, runtime);
}

model DeleteEventDefinitionRequest {
  eventId?: string(name='EventId'),
  instanceId?: string(name='InstanceId'),
}

model DeleteEventDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteEventDefinitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteEventDefinitionResponseBody(name='body'),
}

async function deleteEventDefinitionWithOptions(request: DeleteEventDefinitionRequest, runtime: Util.RuntimeOptions): DeleteEventDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventId)) {
    body['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteEventDefinition',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteEventDefinition(request: DeleteEventDefinitionRequest): DeleteEventDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteEventDefinitionWithOptions(request, runtime);
}

model DeleteInspectionTaskRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model DeleteInspectionTaskResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteInspectionTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteInspectionTaskResponseBody(name='body'),
}

async function deleteInspectionTaskWithOptions(request: DeleteInspectionTaskRequest, runtime: Util.RuntimeOptions): DeleteInspectionTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteInspectionTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteInspectionTask(request: DeleteInspectionTaskRequest): DeleteInspectionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteInspectionTaskWithOptions(request, runtime);
}

model DeleteOsVersionRequest {
  instanceId?: string(name='InstanceId'),
  osVersionId?: string(name='OsVersionId'),
}

model DeleteOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteOsVersionResponseBody(name='body'),
}

async function deleteOsVersionWithOptions(request: DeleteOsVersionRequest, runtime: Util.RuntimeOptions): DeleteOsVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.osVersionId)) {
    body['OsVersionId'] = request.osVersionId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteOsVersion',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteOsVersion(request: DeleteOsVersionRequest): DeleteOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteOsVersionWithOptions(request, runtime);
}

model DeletePhysicalSpaceRequest {
  instanceId?: string(name='InstanceId'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
}

model DeletePhysicalSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeletePhysicalSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeletePhysicalSpaceResponseBody(name='body'),
}

async function deletePhysicalSpaceWithOptions(request: DeletePhysicalSpaceRequest, runtime: Util.RuntimeOptions): DeletePhysicalSpaceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeletePhysicalSpace',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deletePhysicalSpace(request: DeletePhysicalSpaceRequest): DeletePhysicalSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return deletePhysicalSpaceWithOptions(request, runtime);
}

model DeleteResourceInformationRequest {
  instanceId?: string(name='InstanceId'),
  resourceInformationId?: string(name='ResourceInformationId'),
}

model DeleteResourceInformationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteResourceInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteResourceInformationResponseBody(name='body'),
}

async function deleteResourceInformationWithOptions(request: DeleteResourceInformationRequest, runtime: Util.RuntimeOptions): DeleteResourceInformationResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.resourceInformationId)) {
    body['ResourceInformationId'] = request.resourceInformationId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteResourceInformation',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteResourceInformation(request: DeleteResourceInformationRequest): DeleteResourceInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteResourceInformationWithOptions(request, runtime);
}

model DeleteSetupProjectRequest {
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model DeleteSetupProjectResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSetupProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSetupProjectResponseBody(name='body'),
}

async function deleteSetupProjectWithOptions(request: DeleteSetupProjectRequest, runtime: Util.RuntimeOptions): DeleteSetupProjectResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.setupProjectId)) {
    body['SetupProjectId'] = request.setupProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSetupProject',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSetupProject(request: DeleteSetupProjectRequest): DeleteSetupProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSetupProjectWithOptions(request, runtime);
}

model DeleteSpaceModelRequest {
  instanceId?: string(name='InstanceId'),
  spaceModelId?: string(name='SpaceModelId'),
}

model DeleteSpaceModelResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteSpaceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteSpaceModelResponseBody(name='body'),
}

async function deleteSpaceModelWithOptions(request: DeleteSpaceModelRequest, runtime: Util.RuntimeOptions): DeleteSpaceModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.spaceModelId)) {
    query['SpaceModelId'] = request.spaceModelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DeleteSpaceModel',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteSpaceModel(request: DeleteSpaceModelRequest): DeleteSpaceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteSpaceModelWithOptions(request, runtime);
}

model DeleteWorkOrderRequest {
  instanceId?: string(name='InstanceId'),
  workOrderId?: string(name='WorkOrderId'),
}

model DeleteWorkOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model DeleteWorkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DeleteWorkOrderResponseBody(name='body'),
}

async function deleteWorkOrderWithOptions(request: DeleteWorkOrderRequest, runtime: Util.RuntimeOptions): DeleteWorkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.workOrderId)) {
    body['WorkOrderId'] = request.workOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DeleteWorkOrder',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function deleteWorkOrder(request: DeleteWorkOrderRequest): DeleteWorkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return deleteWorkOrderWithOptions(request, runtime);
}

model DisableNotificationRequest {
  expiryTime?: string(name='ExpiryTime'),
  instanceId?: string(name='InstanceId'),
  list?: [ 
    {
      aggregateDataId?: string(name='AggregateDataId'),
      appId?: string(name='AppId'),
      dedicatedLineId?: string(name='DedicatedLineId'),
      deviceId?: string(name='DeviceId'),
      eventId?: string(name='EventId'),
      eventObjectId?: string(name='EventObjectId'),
      monitorItemId?: string(name='MonitorItemId'),
      portCollectionId?: string(name='PortCollectionId'),
      type?: string(name='Type'),
    }
  ](name='List'),
  reason?: string(name='Reason'),
}

model DisableNotificationShrinkRequest {
  expiryTime?: string(name='ExpiryTime'),
  instanceId?: string(name='InstanceId'),
  listShrink?: string(name='List'),
  reason?: string(name='Reason'),
}

model DisableNotificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model DisableNotificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DisableNotificationResponseBody(name='body'),
}

async function disableNotificationWithOptions(tmpReq: DisableNotificationRequest, runtime: Util.RuntimeOptions): DisableNotificationResponse {
  Util.validateModel(tmpReq);
  var request = new DisableNotificationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.list)) {
    request.listShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.list, 'List', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.expiryTime)) {
    body['ExpiryTime'] = request.expiryTime;
  }
  if (!Util.isUnset(request.listShrink)) {
    body['List'] = request.listShrink;
  }
  if (!Util.isUnset(request.reason)) {
    body['Reason'] = request.reason;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'DisableNotification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function disableNotification(request: DisableNotificationRequest): DisableNotificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return disableNotificationWithOptions(request, runtime);
}

model DownloadDeviceResourceRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIds?: [ string ](name='DeviceResourceIds'),
  downloadType?: string(name='DownloadType'),
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model DownloadDeviceResourceShrinkRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIdsShrink?: string(name='DeviceResourceIds'),
  downloadType?: string(name='DownloadType'),
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model DownloadDeviceResourceResponseBody = {
  downloadUrl?: string(name='DownloadUrl'),
  requestId?: string(name='RequestId'),
}

model DownloadDeviceResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: DownloadDeviceResourceResponseBody(name='body'),
}

async function downloadDeviceResourceWithOptions(tmpReq: DownloadDeviceResourceRequest, runtime: Util.RuntimeOptions): DownloadDeviceResourceResponse {
  Util.validateModel(tmpReq);
  var request = new DownloadDeviceResourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceResourceIds)) {
    request.deviceResourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceResourceIds, 'DeviceResourceIds', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'DownloadDeviceResource',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function downloadDeviceResource(request: DownloadDeviceResourceRequest): DownloadDeviceResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return downloadDeviceResourceWithOptions(request, runtime);
}

model EnableNotificationRequest {
  instanceId?: string(name='InstanceId'),
  list?: [ 
    {
      aggregateDataId?: string(name='AggregateDataId'),
      appId?: string(name='AppId'),
      dedicatedLineId?: string(name='DedicatedLineId'),
      deviceId?: string(name='DeviceId'),
      eventId?: string(name='EventId'),
      eventObjectId?: string(name='EventObjectId'),
      monitorItemId?: string(name='MonitorItemId'),
      portCollectionId?: string(name='PortCollectionId'),
      type?: string(name='Type'),
    }
  ](name='List'),
}

model EnableNotificationShrinkRequest {
  instanceId?: string(name='InstanceId'),
  listShrink?: string(name='List'),
}

model EnableNotificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model EnableNotificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: EnableNotificationResponseBody(name='body'),
}

async function enableNotificationWithOptions(tmpReq: EnableNotificationRequest, runtime: Util.RuntimeOptions): EnableNotificationResponse {
  Util.validateModel(tmpReq);
  var request = new EnableNotificationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.list)) {
    request.listShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.list, 'List', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.listShrink)) {
    body['List'] = request.listShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'EnableNotification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function enableNotification(request: EnableNotificationRequest): EnableNotificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return enableNotificationWithOptions(request, runtime);
}

model GetAlarmStatusRequest {
  aggregateDataId?: string(name='AggregateDataId'),
  appId?: string(name='AppId'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
  monitorItemId?: string(name='MonitorItemId'),
  portCollectionId?: string(name='PortCollectionId'),
  type?: string(name='Type'),
}

model GetAlarmStatusResponseBody = {
  alarmStatus?: {
    abnormalDataItem?: string(name='AbnormalDataItem'),
    agentIp?: string(name='AgentIp'),
    aggregateData?: {
      aggregateDataDescription?: string(name='AggregateDataDescription'),
      aggregateDataId?: string(name='AggregateDataId'),
      aggregateDataName?: string(name='AggregateDataName'),
      aggregateMode?: string(name='AggregateMode'),
      dataItem?: string(name='DataItem'),
      deviceId?: string(name='DeviceId'),
      isAllDevice?: int32(name='IsAllDevice'),
      monitorItemId?: string(name='MonitorItemId'),
    }(name='AggregateData'),
    aggregateDataId?: string(name='AggregateDataId'),
    alarmRule?: string(name='AlarmRule'),
    alarmStatus?: string(name='AlarmStatus'),
    appId?: string(name='AppId'),
    collectionTime?: string(name='CollectionTime'),
    dedicatedLine?: {
      bandwidth?: string(name='Bandwidth'),
      dedicatedLineGateway?: string(name='DedicatedLineGateway'),
      dedicatedLineName?: string(name='DedicatedLineName'),
      deviceId?: string(name='DeviceId'),
      ip?: string(name='Ip'),
      portName?: string(name='PortName'),
      space?: string(name='Space'),
    }(name='DedicatedLine'),
    dedicatedLineId?: string(name='DedicatedLineId'),
    deviceId?: string(name='DeviceId'),
    firstAbnormalTime?: string(name='FirstAbnormalTime'),
    monitorItem?: {
      collectionType?: string(name='CollectionType'),
      deviceForm?: string(name='DeviceForm'),
      effective?: long(name='Effective'),
      execInterval?: string(name='ExecInterval'),
      monitorItemDescription?: string(name='MonitorItemDescription'),
      monitorItemId?: string(name='MonitorItemId'),
      monitorItemName?: string(name='MonitorItemName'),
      securityDomain?: string(name='SecurityDomain'),
    }(name='MonitorItem'),
    monitorItemId?: string(name='MonitorItemId'),
    notificationSwitch?: {
      expiryTime?: string(name='ExpiryTime'),
      reason?: string(name='Reason'),
    }(name='NotificationSwitch'),
    portCollection?: {
      portCollectionDescription?: string(name='PortCollectionDescription'),
      portCollectionId?: string(name='PortCollectionId'),
      portCollectionName?: string(name='PortCollectionName'),
      portList?: [ 
        {
          deviceId?: string(name='DeviceId'),
          portName?: string(name='PortName'),
          resourceDevice?: {
            hostName?: string(name='HostName'),
            ip?: string(name='Ip'),
            securityDomain?: string(name='SecurityDomain'),
          }(name='ResourceDevice'),
        }
      ](name='PortList'),
    }(name='PortCollection'),
    portCollectionId?: string(name='PortCollectionId'),
    receiveTime?: string(name='ReceiveTime'),
    resourceApp?: {
      appId?: string(name='AppId'),
      domain?: string(name='Domain'),
      port?: string(name='Port'),
      securityDomain?: string(name='SecurityDomain'),
      type?: string(name='Type'),
    }(name='ResourceApp'),
    resourceDevice?: {
      deviceForm?: string(name='DeviceForm'),
      deviceId?: string(name='DeviceId'),
      hostName?: string(name='HostName'),
      ip?: string(name='Ip'),
      model?: string(name='Model'),
      securityDomain?: string(name='SecurityDomain'),
      sn?: string(name='Sn'),
      space?: string(name='Space'),
      status?: string(name='Status'),
      vendor?: string(name='Vendor'),
    }(name='ResourceDevice'),
    responseCode?: string(name='ResponseCode'),
    result?: string(name='Result'),
    uniqueKey?: string(name='UniqueKey'),
  }(name='AlarmStatus'),
  requestId?: string(name='RequestId'),
}

model GetAlarmStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetAlarmStatusResponseBody(name='body'),
}

async function getAlarmStatusWithOptions(request: GetAlarmStatusRequest, runtime: Util.RuntimeOptions): GetAlarmStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetAlarmStatus',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getAlarmStatus(request: GetAlarmStatusRequest): GetAlarmStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return getAlarmStatusWithOptions(request, runtime);
}

model GetConfigurationSpecificationRequest {
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  instanceId?: string(name='InstanceId'),
}

model GetConfigurationSpecificationResponseBody = {
  configurationSpecification?: {
    architecture?: string(name='Architecture'),
    configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
    createTime?: string(name='CreateTime'),
    mode?: string(name='Mode'),
    relatedVariate?: [ string ](name='RelatedVariate'),
    role?: string(name='Role'),
    specificationContent?: string(name='SpecificationContent'),
    specificationName?: string(name='SpecificationName'),
    updateTime?: string(name='UpdateTime'),
    vendor?: string(name='Vendor'),
  }(name='ConfigurationSpecification'),
  requestId?: string(name='RequestId'),
}

model GetConfigurationSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigurationSpecificationResponseBody(name='body'),
}

async function getConfigurationSpecificationWithOptions(request: GetConfigurationSpecificationRequest, runtime: Util.RuntimeOptions): GetConfigurationSpecificationResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigurationSpecification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigurationSpecification(request: GetConfigurationSpecificationRequest): GetConfigurationSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigurationSpecificationWithOptions(request, runtime);
}

model GetConfigurationVariateRequest {
  configurationVariateId?: string(name='ConfigurationVariateId'),
  instanceId?: string(name='InstanceId'),
}

model GetConfigurationVariateResponseBody = {
  configurationVariate?: {
    comment?: string(name='Comment'),
    formatFunction?: string(name='FormatFunction'),
    variateName?: string(name='VariateName'),
  }(name='ConfigurationVariate'),
  requestId?: string(name='RequestId'),
}

model GetConfigurationVariateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetConfigurationVariateResponseBody(name='body'),
}

async function getConfigurationVariateWithOptions(request: GetConfigurationVariateRequest, runtime: Util.RuntimeOptions): GetConfigurationVariateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetConfigurationVariate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getConfigurationVariate(request: GetConfigurationVariateRequest): GetConfigurationVariateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getConfigurationVariateWithOptions(request, runtime);
}

model GetDedicatedLineRequest {
  dedicatedLineId?: string(name='DedicatedLineId'),
  instanceId?: string(name='InstanceId'),
}

model GetDedicatedLineResponseBody = {
  dedicatedLine?: {
    bandwidth?: int32(name='Bandwidth'),
    dedicatedLineGateway?: string(name='DedicatedLineGateway'),
    dedicatedLineId?: string(name='DedicatedLineId'),
    dedicatedLineIp?: string(name='DedicatedLineIp'),
    dedicatedLineRole?: string(name='DedicatedLineRole'),
    description?: string(name='Description'),
    deviceId?: string(name='DeviceId'),
    deviceName?: string(name='DeviceName'),
    devicePort?: string(name='DevicePort'),
    isp?: string(name='Isp'),
    physicalSpaceId?: string(name='PhysicalSpaceId'),
  }(name='DedicatedLine'),
  requestId?: string(name='RequestId'),
}

model GetDedicatedLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDedicatedLineResponseBody(name='body'),
}

async function getDedicatedLineWithOptions(request: GetDedicatedLineRequest, runtime: Util.RuntimeOptions): GetDedicatedLineResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDedicatedLine',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDedicatedLine(request: GetDedicatedLineRequest): GetDedicatedLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDedicatedLineWithOptions(request, runtime);
}

model GetDeviceRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceResponseBody = {
  device?: {
    deviceFormId?: string(name='DeviceFormId'),
    deviceFormName?: string(name='DeviceFormName'),
    deviceId?: string(name='DeviceId'),
    enablePassword?: string(name='EnablePassword'),
    extAttributes?: string(name='ExtAttributes'),
    hostName?: string(name='HostName'),
    ip?: string(name='Ip'),
    loginPassword?: string(name='LoginPassword'),
    loginType?: string(name='LoginType'),
    loginUsername?: string(name='LoginUsername'),
    mac?: string(name='Mac'),
    model?: string(name='Model'),
    physicalSpaceId?: string(name='PhysicalSpaceId'),
    physicalSpaceName?: string(name='PhysicalSpaceName'),
    securityDomain?: string(name='SecurityDomain'),
    serviceStatus?: string(name='ServiceStatus'),
    sn?: string(name='Sn'),
    snmpAccountType?: string(name='SnmpAccountType'),
    snmpAccountVersion?: string(name='SnmpAccountVersion'),
    snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
    snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
    snmpCommunity?: string(name='SnmpCommunity'),
    snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
    snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
    snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
    snmpUsername?: string(name='SnmpUsername'),
    vendor?: string(name='Vendor'),
  }(name='Device'),
  requestId?: string(name='RequestId'),
}

model GetDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceResponseBody(name='body'),
}

async function getDeviceWithOptions(request: GetDeviceRequest, runtime: Util.RuntimeOptions): GetDeviceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDevice',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDevice(request: GetDeviceRequest): GetDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceWithOptions(request, runtime);
}

model GetDeviceConfigRequest {
  date?: string(name='Date'),
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceConfigResponseBody = {
  deviceConfig?: string(name='DeviceConfig'),
  requestId?: string(name='RequestId'),
}

model GetDeviceConfigResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceConfigResponseBody(name='body'),
}

async function getDeviceConfigWithOptions(request: GetDeviceConfigRequest, runtime: Util.RuntimeOptions): GetDeviceConfigResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceConfig',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceConfig(request: GetDeviceConfigRequest): GetDeviceConfigResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceConfigWithOptions(request, runtime);
}

model GetDeviceConfigDateRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceConfigDateResponseBody = {
  deviceConfigDate?: [ string ](name='DeviceConfigDate'),
  requestId?: string(name='RequestId'),
}

model GetDeviceConfigDateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceConfigDateResponseBody(name='body'),
}

async function getDeviceConfigDateWithOptions(request: GetDeviceConfigDateRequest, runtime: Util.RuntimeOptions): GetDeviceConfigDateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceConfigDate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceConfigDate(request: GetDeviceConfigDateRequest): GetDeviceConfigDateResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceConfigDateWithOptions(request, runtime);
}

model GetDeviceConfigDiffRequest {
  deviceId?: string(name='DeviceId'),
  endDate?: string(name='EndDate'),
  instanceId?: string(name='InstanceId'),
  startDate?: string(name='StartDate'),
}

model GetDeviceConfigDiffResponseBody = {
  deviceConfigDiff?: {
    extractDiff?: string(name='ExtractDiff'),
    totalDiff?: string(name='TotalDiff'),
  }(name='DeviceConfigDiff'),
  requestId?: string(name='RequestId'),
}

model GetDeviceConfigDiffResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceConfigDiffResponseBody(name='body'),
}

async function getDeviceConfigDiffWithOptions(request: GetDeviceConfigDiffRequest, runtime: Util.RuntimeOptions): GetDeviceConfigDiffResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceConfigDiff',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceConfigDiff(request: GetDeviceConfigDiffRequest): GetDeviceConfigDiffResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceConfigDiffWithOptions(request, runtime);
}

model GetDeviceFormRequest {
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceFormResponseBody = {
  deviceForm?: {
    accountConfig?: boolean(name='AccountConfig'),
    attributeList?: [ 
      {
        attributeBuiltIn?: boolean(name='AttributeBuiltIn'),
        attributeFormat?: string(name='AttributeFormat'),
        attributeFuzzyQuery?: boolean(name='AttributeFuzzyQuery'),
        attributeKey?: string(name='AttributeKey'),
        attributeName?: string(name='AttributeName'),
        attributePlaceholder?: string(name='AttributePlaceholder'),
        attributeQuery?: boolean(name='AttributeQuery'),
        attributeReference?: string(name='AttributeReference'),
        attributeRequirement?: boolean(name='AttributeRequirement'),
        attributeSequence?: int32(name='AttributeSequence'),
        attributeTableDisplay?: boolean(name='AttributeTableDisplay'),
        attributeType?: string(name='AttributeType'),
        attributeUniqueness?: boolean(name='AttributeUniqueness'),
      }
    ](name='AttributeList'),
    configCompare?: boolean(name='ConfigCompare'),
    detailDisplay?: boolean(name='DetailDisplay'),
    deviceFormId?: string(name='DeviceFormId'),
    deviceFormName?: string(name='DeviceFormName'),
    formBuiltIn?: boolean(name='FormBuiltIn'),
    resourceUse?: string(name='ResourceUse'),
    script?: string(name='Script'),
    uniqueKey?: string(name='UniqueKey'),
  }(name='DeviceForm'),
  requestId?: string(name='RequestId'),
}

model GetDeviceFormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceFormResponseBody(name='body'),
}

async function getDeviceFormWithOptions(request: GetDeviceFormRequest, runtime: Util.RuntimeOptions): GetDeviceFormResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceForm',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceForm(request: GetDeviceFormRequest): GetDeviceFormResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceFormWithOptions(request, runtime);
}

model GetDeviceOpLogRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model GetDeviceOpLogResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  operationLogs?: [ 
    {
      deviceId?: string(name='DeviceId'),
      gmtModifiedTime?: string(name='GmtModifiedTime'),
      keyword?: string(name='Keyword'),
      newValue?: string(name='NewValue'),
      oldValue?: string(name='OldValue'),
      operator?: string(name='Operator'),
    }
  ](name='OperationLogs'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model GetDeviceOpLogResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceOpLogResponseBody(name='body'),
}

async function getDeviceOpLogWithOptions(request: GetDeviceOpLogRequest, runtime: Util.RuntimeOptions): GetDeviceOpLogResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceOpLog',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceOpLog(request: GetDeviceOpLogRequest): GetDeviceOpLogResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceOpLogWithOptions(request, runtime);
}

model GetDevicePropertyRequest {
  deviceFormId?: string(name='DeviceFormId'),
  devicePropertyId?: string(name='DevicePropertyId'),
  instanceId?: string(name='InstanceId'),
  propertyKey?: string(name='PropertyKey'),
}

model GetDevicePropertyResponseBody = {
  deviceProperty?: {
    builtIn?: boolean(name='BuiltIn'),
    deviceFormId?: string(name='DeviceFormId'),
    deviceFormName?: string(name='DeviceFormName'),
    devicePropertyId?: string(name='DevicePropertyId'),
    propertyContent?: string(name='PropertyContent'),
    propertyFormat?: string(name='PropertyFormat'),
    propertyKey?: string(name='PropertyKey'),
    propertyName?: string(name='PropertyName'),
  }(name='DeviceProperty'),
  requestId?: string(name='RequestId'),
}

model GetDevicePropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDevicePropertyResponseBody(name='body'),
}

async function getDevicePropertyWithOptions(request: GetDevicePropertyRequest, runtime: Util.RuntimeOptions): GetDevicePropertyResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceProperty',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceProperty(request: GetDevicePropertyRequest): GetDevicePropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDevicePropertyWithOptions(request, runtime);
}

model GetDeviceResourceRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  instanceId?: string(name='InstanceId'),
}

model GetDeviceResourceResponseBody = {
  deviceResource?: {
    blockNumber?: string(name='BlockNumber'),
    business?: string(name='Business'),
    config?: string(name='Config'),
    configTaskStatus?: string(name='ConfigTaskStatus'),
    deliveryIp?: string(name='DeliveryIp'),
    deviceNum?: string(name='DeviceNum'),
    deviceResourceId?: string(name='DeviceResourceId'),
    generateConfig?: string(name='GenerateConfig'),
    hostName?: string(name='HostName'),
    interConnection?: string(name='InterConnection'),
    location?: string(name='Location'),
    loopback?: string(name='Loopback'),
    managerIp?: string(name='ManagerIp'),
    model?: string(name='Model'),
    role?: string(name='Role'),
    setupProjectId?: string(name='SetupProjectId'),
    sn?: string(name='Sn'),
    stack?: boolean(name='Stack'),
    vendor?: string(name='Vendor'),
  }(name='DeviceResource'),
  requestId?: string(name='RequestId'),
}

model GetDeviceResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetDeviceResourceResponseBody(name='body'),
}

async function getDeviceResourceWithOptions(request: GetDeviceResourceRequest, runtime: Util.RuntimeOptions): GetDeviceResourceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetDeviceResource',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getDeviceResource(request: GetDeviceResourceRequest): GetDeviceResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getDeviceResourceWithOptions(request, runtime);
}

model GetInspectionTaskRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
  itemName?: string(name='ItemName'),
  taskId?: string(name='TaskId'),
}

model GetInspectionTaskResponseBody = {
  inspectionTask?: {
    deviceDisplay?: string(name='DeviceDisplay'),
    deviceId?: string(name='DeviceId'),
    errorCode?: string(name='ErrorCode'),
    executionBeginTime?: string(name='ExecutionBeginTime'),
    executionEndTime?: string(name='ExecutionEndTime'),
    hostName?: string(name='HostName'),
    IP?: string(name='IP'),
    inspectionAlarmRules?: [ 
      {
        actualValue?: string(name='ActualValue'),
        expression?: string(name='Expression'),
        level?: string(name='Level'),
        operator?: string(name='Operator'),
        value?: string(name='Value'),
      }
    ](name='InspectionAlarmRules'),
    inspectionResult?: string(name='InspectionResult'),
    itemId?: string(name='ItemId'),
    itemName?: string(name='ItemName'),
    model?: [ string ](name='Model'),
    scriptId?: string(name='ScriptId'),
    space?: string(name='Space'),
    taskId?: string(name='TaskId'),
    taskStatus?: string(name='TaskStatus'),
    vendor?: string(name='Vendor'),
  }(name='InspectionTask'),
  requestId?: string(name='RequestId'),
}

model GetInspectionTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetInspectionTaskResponseBody(name='body'),
}

async function getInspectionTaskWithOptions(request: GetInspectionTaskRequest, runtime: Util.RuntimeOptions): GetInspectionTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetInspectionTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getInspectionTask(request: GetInspectionTaskRequest): GetInspectionTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getInspectionTaskWithOptions(request, runtime);
}

model GetMonitorItemRequest {
  instanceId?: string(name='InstanceId'),
  monitorItemId?: string(name='MonitorItemId'),
}

model GetMonitorItemResponseBody = {
  monitorItem?: {
    alarmRuleList?: [ 
      {
        alarmStatus?: string(name='AlarmStatus'),
        expression?: string(name='Expression'),
        value?: string(name='Value'),
        variable?: string(name='Variable'),
      }
    ](name='AlarmRuleList'),
    analysisCode?: string(name='AnalysisCode'),
    collectionType?: string(name='CollectionType'),
    config?: string(name='Config'),
    createTime?: string(name='CreateTime'),
    dataItem?: string(name='DataItem'),
    deviceForm?: string(name='DeviceForm'),
    effective?: int32(name='Effective'),
    execInterval?: int32(name='ExecInterval'),
    monitorItemDescription?: string(name='MonitorItemDescription'),
    monitorItemId?: string(name='MonitorItemId'),
    monitorItemName?: string(name='MonitorItemName'),
    personalizedAlarmRuleList?: [ 
      {
        alarmStatus?: string(name='AlarmStatus'),
        expression?: string(name='Expression'),
        fieldName?: string(name='FieldName'),
        fieldValue?: string(name='FieldValue'),
        value?: string(name='Value'),
        variable?: string(name='Variable'),
      }
    ](name='PersonalizedAlarmRuleList'),
    securityDomain?: string(name='SecurityDomain'),
    type?: string(name='Type'),
    updateTime?: string(name='UpdateTime'),
  }(name='MonitorItem'),
  requestId?: string(name='RequestId'),
}

model GetMonitorItemResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetMonitorItemResponseBody(name='body'),
}

async function getMonitorItemWithOptions(request: GetMonitorItemRequest, runtime: Util.RuntimeOptions): GetMonitorItemResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetMonitorItem',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getMonitorItem(request: GetMonitorItemRequest): GetMonitorItemResponse {
  var runtime = new Util.RuntimeOptions{};
  return getMonitorItemWithOptions(request, runtime);
}

model GetOsDownloadPathRequest {
  instanceId?: string(name='InstanceId'),
  osVersionId?: string(name='OsVersionId'),
}

model GetOsDownloadPathResponseBody = {
  osVersion?: {
    downloadPath?: string(name='DownloadPath'),
  }(name='OsVersion'),
  requestId?: string(name='RequestId'),
}

model GetOsDownloadPathResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOsDownloadPathResponseBody(name='body'),
}

async function getOsDownloadPathWithOptions(request: GetOsDownloadPathRequest, runtime: Util.RuntimeOptions): GetOsDownloadPathResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOsDownloadPath',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOsDownloadPath(request: GetOsDownloadPathRequest): GetOsDownloadPathResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOsDownloadPathWithOptions(request, runtime);
}

model GetOsVersionRequest {
  instanceId?: string(name='InstanceId'),
  osVersionId?: string(name='OsVersionId'),
}

model GetOsVersionResponseBody = {
  osVersion?: [ 
    {
      downloadPath?: string(name='DownloadPath'),
    }
  ](name='OsVersion'),
  requestId?: string(name='RequestId'),
}

model GetOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOsVersionResponseBody(name='body'),
}

async function getOsVersionWithOptions(request: GetOsVersionRequest, runtime: Util.RuntimeOptions): GetOsVersionResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOsVersion',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOsVersion(request: GetOsVersionRequest): GetOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOsVersionWithOptions(request, runtime);
}

model GetOssPolicyRequest {
  instanceId?: string(name='InstanceId'),
}

model GetOssPolicyResponseBody = {
  ossPolicy?: {
    accessId?: string(name='AccessId'),
    directory?: string(name='Directory'),
    expireTime?: string(name='ExpireTime'),
    host?: string(name='Host'),
    policy?: string(name='Policy'),
    signature?: string(name='Signature'),
  }(name='OssPolicy'),
  requestId?: string(name='RequestId'),
}

model GetOssPolicyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetOssPolicyResponseBody(name='body'),
}

async function getOssPolicyWithOptions(request: GetOssPolicyRequest, runtime: Util.RuntimeOptions): GetOssPolicyResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetOssPolicy',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getOssPolicy(request: GetOssPolicyRequest): GetOssPolicyResponse {
  var runtime = new Util.RuntimeOptions{};
  return getOssPolicyWithOptions(request, runtime);
}

model GetPhysicalSpaceRequest {
  instanceId?: string(name='InstanceId'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
}

model GetPhysicalSpaceResponseBody = {
  physicalSpace?: {
    address?: string(name='Address'),
    city?: string(name='City'),
    country?: string(name='Country'),
    owner?: string(name='Owner'),
    physicalSpaceId?: string(name='PhysicalSpaceId'),
    physicalSpaceName?: string(name='PhysicalSpaceName'),
    province?: string(name='Province'),
    remark?: string(name='Remark'),
    securityDomainList?: [ string ](name='SecurityDomainList'),
    spaceAbbreviation?: string(name='SpaceAbbreviation'),
    spaceType?: string(name='SpaceType'),
  }(name='PhysicalSpace'),
  requestId?: string(name='RequestId'),
}

model GetPhysicalSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPhysicalSpaceResponseBody(name='body'),
}

async function getPhysicalSpaceWithOptions(request: GetPhysicalSpaceRequest, runtime: Util.RuntimeOptions): GetPhysicalSpaceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPhysicalSpace',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPhysicalSpace(request: GetPhysicalSpaceRequest): GetPhysicalSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPhysicalSpaceWithOptions(request, runtime);
}

model GetPhysicalSpaceTopoRequest {
  instanceId?: string(name='InstanceId'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  topoType?: string(name='TopoType'),
}

model GetPhysicalSpaceTopoResponseBody = {
  requestId?: string(name='RequestId'),
  topoData?: {
    devices?: [ 
      {
        deviceId?: string(name='DeviceId'),
        deviceRole?: string(name='DeviceRole'),
        hostName?: string(name='HostName'),
        ip?: string(name='Ip'),
      }
    ](name='Devices'),
    links?: [ 
      {
        sourceDeviceId?: string(name='SourceDeviceId'),
        sourceDeviceName?: string(name='SourceDeviceName'),
        sourcePort?: string(name='SourcePort'),
        targetDeviceId?: string(name='TargetDeviceId'),
        targetDeviceName?: string(name='TargetDeviceName'),
        targetPort?: string(name='TargetPort'),
      }
    ](name='Links'),
    updateTime?: string(name='UpdateTime'),
  }(name='TopoData'),
}

model GetPhysicalSpaceTopoResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetPhysicalSpaceTopoResponseBody(name='body'),
}

async function getPhysicalSpaceTopoWithOptions(request: GetPhysicalSpaceTopoRequest, runtime: Util.RuntimeOptions): GetPhysicalSpaceTopoResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    query['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.topoType)) {
    query['TopoType'] = request.topoType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetPhysicalSpaceTopo',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getPhysicalSpaceTopo(request: GetPhysicalSpaceTopoRequest): GetPhysicalSpaceTopoResponse {
  var runtime = new Util.RuntimeOptions{};
  return getPhysicalSpaceTopoWithOptions(request, runtime);
}

model GetRealtimeTaskRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model GetRealtimeTaskResponseBody = {
  inspectionTask?: {
    errorCode?: string(name='ErrorCode'),
    inspectionMessage?: string(name='InspectionMessage'),
    inspectionResult?: string(name='InspectionResult'),
    taskStatus?: string(name='TaskStatus'),
  }(name='InspectionTask'),
  requestId?: string(name='RequestId'),
}

model GetRealtimeTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetRealtimeTaskResponseBody(name='body'),
}

async function getRealtimeTaskWithOptions(request: GetRealtimeTaskRequest, runtime: Util.RuntimeOptions): GetRealtimeTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetRealtimeTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getRealtimeTask(request: GetRealtimeTaskRequest): GetRealtimeTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getRealtimeTaskWithOptions(request, runtime);
}

model GetScheduleWorkerRequest {
  instanceId?: string(name='InstanceId'),
  scheduleWorkerId?: string(name='ScheduleWorkerId'),
}

model GetScheduleWorkerResponseBody = {
  requestId?: string(name='RequestId'),
  scheduleWorker?: {
    createTime?: string(name='CreateTime'),
    scheduleWorkerId?: string(name='ScheduleWorkerId'),
    updateTime?: string(name='UpdateTime'),
    workerContact?: string(name='WorkerContact'),
    workerId?: string(name='WorkerId'),
    workerName?: string(name='WorkerName'),
  }(name='ScheduleWorker'),
}

model GetScheduleWorkerResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetScheduleWorkerResponseBody(name='body'),
}

async function getScheduleWorkerWithOptions(request: GetScheduleWorkerRequest, runtime: Util.RuntimeOptions): GetScheduleWorkerResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetScheduleWorker',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getScheduleWorker(request: GetScheduleWorkerRequest): GetScheduleWorkerResponse {
  var runtime = new Util.RuntimeOptions{};
  return getScheduleWorkerWithOptions(request, runtime);
}

model GetSetupProjectRequest {
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model GetSetupProjectResponseBody = {
  requestId?: string(name='RequestId'),
  setupProject?: {
    createTime?: string(name='CreateTime'),
    deliveryTime?: string(name='DeliveryTime'),
    nodes?: string(name='Nodes'),
    packages?: [ 
      {
        deviceNumber?: string(name='DeviceNumber'),
        model?: string(name='Model'),
        role?: string(name='Role'),
        vendor?: string(name='Vendor'),
      }
    ](name='Packages'),
    progress?: string(name='Progress'),
    setupProjectId?: string(name='SetupProjectId'),
    spaceId?: string(name='SpaceId'),
    spaceName?: string(name='SpaceName'),
    spaceType?: string(name='SpaceType'),
  }(name='SetupProject'),
}

model GetSetupProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSetupProjectResponseBody(name='body'),
}

async function getSetupProjectWithOptions(request: GetSetupProjectRequest, runtime: Util.RuntimeOptions): GetSetupProjectResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSetupProject',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSetupProject(request: GetSetupProjectRequest): GetSetupProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSetupProjectWithOptions(request, runtime);
}

model GetSpaceModelRequest {
  instanceId?: string(name='InstanceId'),
  spaceModelId?: string(name='SpaceModelId'),
}

model GetSpaceModelResponseBody = {
  requestId?: string(name='RequestId'),
  spaceModel?: {
    createTime?: string(name='CreateTime'),
    sort?: [ 
      {
        level?: long(name='Level'),
        levelName?: string(name='LevelName'),
      }
    ](name='Sort'),
    spaceModelId?: string(name='SpaceModelId'),
    spaceType?: string(name='SpaceType'),
    status?: string(name='Status'),
    updateTime?: string(name='UpdateTime'),
  }(name='SpaceModel'),
}

model GetSpaceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpaceModelResponseBody(name='body'),
}

async function getSpaceModelWithOptions(request: GetSpaceModelRequest, runtime: Util.RuntimeOptions): GetSpaceModelResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSpaceModel',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpaceModel(request: GetSpaceModelRequest): GetSpaceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpaceModelWithOptions(request, runtime);
}

model GetSpaceModelInstanceRequest {
  instanceId?: string(name='InstanceId'),
  operateType?: string(name='OperateType'),
  spaceId?: string(name='SpaceId'),
  spaceType?: string(name='SpaceType'),
}

model GetSpaceModelInstanceResponseBody = {
  requestId?: string(name='RequestId'),
  spaceModel?: {
    instance?: string(name='Instance'),
  }(name='SpaceModel'),
}

model GetSpaceModelInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpaceModelInstanceResponseBody(name='body'),
}

async function getSpaceModelInstanceWithOptions(request: GetSpaceModelInstanceRequest, runtime: Util.RuntimeOptions): GetSpaceModelInstanceResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSpaceModelInstance',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpaceModelInstance(request: GetSpaceModelInstanceRequest): GetSpaceModelInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpaceModelInstanceWithOptions(request, runtime);
}

model GetSpaceModelSortRequest {
  instanceId?: string(name='InstanceId'),
  operateType?: string(name='OperateType'),
  spaceType?: string(name='SpaceType'),
}

model GetSpaceModelSortResponseBody = {
  requestId?: string(name='RequestId'),
  spaceModel?: [ 
    {
      level?: long(name='Level'),
      levelName?: string(name='LevelName'),
    }
  ](name='SpaceModel'),
}

model GetSpaceModelSortResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetSpaceModelSortResponseBody(name='body'),
}

async function getSpaceModelSortWithOptions(request: GetSpaceModelSortRequest, runtime: Util.RuntimeOptions): GetSpaceModelSortResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetSpaceModelSort',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getSpaceModelSort(request: GetSpaceModelSortRequest): GetSpaceModelSortResponse {
  var runtime = new Util.RuntimeOptions{};
  return getSpaceModelSortWithOptions(request, runtime);
}

model GetTaskRequest {
  instanceId?: string(name='InstanceId'),
  taskId?: string(name='TaskId'),
}

model GetTaskResponseBody = {
  requestId?: string(name='RequestId'),
  task?: {
    category?: string(name='Category'),
    createTime?: string(name='CreateTime'),
    params?: string(name='Params'),
    responseCode?: string(name='ResponseCode'),
    result?: string(name='Result'),
    status?: string(name='Status'),
    taskId?: string(name='TaskId'),
    templateId?: string(name='TemplateId'),
    templateName?: string(name='TemplateName'),
    updateTime?: string(name='UpdateTime'),
  }(name='Task'),
}

model GetTaskResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetTaskResponseBody(name='body'),
}

async function getTaskWithOptions(request: GetTaskRequest, runtime: Util.RuntimeOptions): GetTaskResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetTask',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getTask(request: GetTaskRequest): GetTaskResponse {
  var runtime = new Util.RuntimeOptions{};
  return getTaskWithOptions(request, runtime);
}

model GetWorkOrderRequest {
  instanceId?: string(name='InstanceId'),
  workOrderId?: string(name='WorkOrderId'),
}

model GetWorkOrderResponseBody = {
  content?: {
    alarmHappenTime?: string(name='AlarmHappenTime'),
    alarmRecoverTime?: string(name='AlarmRecoverTime'),
    alarmRelated?: string(name='AlarmRelated'),
    area?: string(name='Area'),
    circuitId?: string(name='CircuitId'),
    circuitName?: string(name='CircuitName'),
    circuitType?: string(name='CircuitType'),
    deviceAlarmInfo?: string(name='DeviceAlarmInfo'),
    deviceIp?: string(name='DeviceIp'),
    deviceIpA?: string(name='DeviceIpA'),
    deviceIpB?: string(name='DeviceIpB'),
    deviceModelA?: string(name='DeviceModelA'),
    deviceModelB?: string(name='DeviceModelB'),
    deviceName?: string(name='DeviceName'),
    deviceNameA?: string(name='DeviceNameA'),
    deviceNameB?: string(name='DeviceNameB'),
    devicePortA?: string(name='DevicePortA'),
    devicePortB?: string(name='DevicePortB'),
    deviceSnA?: string(name='DeviceSnA'),
    deviceSnB?: string(name='DeviceSnB'),
    deviceType?: string(name='DeviceType'),
    deviceVendor?: string(name='DeviceVendor'),
    deviceVendorA?: string(name='DeviceVendorA'),
    deviceVendorB?: string(name='DeviceVendorB'),
    emergencyDegree?: string(name='EmergencyDegree'),
    extra?: string(name='Extra'),
    faultDuration?: string(name='FaultDuration'),
    gmtCreate?: string(name='GmtCreate'),
    gmtModified?: string(name='GmtModified'),
    hangFileName?: string(name='HangFileName'),
    hangFilePath?: string(name='HangFilePath'),
    hangReason?: string(name='HangReason'),
    impactBusiness?: string(name='ImpactBusiness'),
    incidentDescription?: string(name='IncidentDescription'),
    incidentSubType?: string(name='IncidentSubType'),
    incidentType?: string(name='IncidentType'),
    liableMan?: string(name='LiableMan'),
    linkMan?: string(name='LinkMan'),
    originalSubjectAlarm?: string(name='OriginalSubjectAlarm'),
    processLimited?: string(name='ProcessLimited'),
    processMan?: string(name='ProcessMan'),
    processManId?: string(name='ProcessManId'),
    processResult?: string(name='ProcessResult'),
    skillGroups?: string(name='SkillGroups'),
    timeout?: string(name='Timeout'),
    workOrderId?: string(name='WorkOrderId'),
    workOrderOperationDtos?: [ 
      {
        gmtCreate?: string(name='GmtCreate'),
        operation?: string(name='Operation'),
        operationId?: string(name='OperationId'),
        operator?: string(name='Operator'),
        remark?: string(name='Remark'),
        workOrderId?: string(name='WorkOrderId'),
      }
    ](name='WorkOrderOperationDtos'),
    workOrderSource?: string(name='WorkOrderSource'),
    workOrderStep?: string(name='WorkOrderStep'),
    workOrderTitle?: string(name='WorkOrderTitle'),
    workOrderType?: string(name='WorkOrderType'),
  }(name='Content'),
  requestId?: string(name='RequestId'),
}

model GetWorkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: GetWorkOrderResponseBody(name='body'),
}

async function getWorkOrderWithOptions(request: GetWorkOrderRequest, runtime: Util.RuntimeOptions): GetWorkOrderResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'GetWorkOrder',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function getWorkOrder(request: GetWorkOrderRequest): GetWorkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return getWorkOrderWithOptions(request, runtime);
}

model ListAlarmStatusRequest {
  aggregateDataName?: string(name='AggregateDataName'),
  city?: string(name='City'),
  country?: string(name='Country'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  dedicatedLineName?: string(name='DedicatedLineName'),
  deviceForm?: string(name='DeviceForm'),
  deviceId?: string(name='DeviceId'),
  domain?: string(name='Domain'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  manufacturer?: string(name='Manufacturer'),
  maxResults?: int32(name='MaxResults'),
  model?: string(name='Model'),
  monitorItemId?: string(name='MonitorItemId'),
  nextToken?: string(name='NextToken'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  portCollectionId?: string(name='PortCollectionId'),
  portCollectionName?: string(name='PortCollectionName'),
  province?: string(name='Province'),
  region?: string(name='Region'),
  role?: string(name='Role'),
  securityDomain?: string(name='SecurityDomain'),
  serviceStatus?: string(name='ServiceStatus'),
  space?: string(name='Space'),
  spaceType?: string(name='SpaceType'),
  status?: string(name='Status'),
  type?: string(name='Type'),
  uniqueKey?: string(name='UniqueKey'),
}

model ListAlarmStatusResponseBody = {
  alarmStatus?: [ 
    {
      abnormalDataItem?: string(name='AbnormalDataItem'),
      agentIp?: string(name='AgentIp'),
      aggregateData?: {
        aggregateDataName?: string(name='AggregateDataName'),
        dataItem?: string(name='DataItem'),
      }(name='AggregateData'),
      aggregateDataId?: string(name='AggregateDataId'),
      alarmRule?: string(name='AlarmRule'),
      alarmStatus?: string(name='AlarmStatus'),
      appId?: string(name='AppId'),
      collectionTime?: string(name='CollectionTime'),
      dedicatedLine?: {
        dedicatedLineName?: string(name='DedicatedLineName'),
        physicalSpace?: string(name='PhysicalSpace'),
      }(name='DedicatedLine'),
      dedicatedLineId?: string(name='DedicatedLineId'),
      deviceId?: string(name='DeviceId'),
      firstAbnormalTime?: string(name='FirstAbnormalTime'),
      monitorItem?: {
        collectionType?: string(name='CollectionType'),
        monitorItemDescription?: string(name='MonitorItemDescription'),
        monitorItemName?: string(name='MonitorItemName'),
      }(name='MonitorItem'),
      monitorItemId?: string(name='MonitorItemId'),
      notificationSwitch?: {
        expiryTime?: string(name='ExpiryTime'),
        reason?: string(name='Reason'),
      }(name='NotificationSwitch'),
      portCollection?: {
        portCollectionName?: string(name='PortCollectionName'),
      }(name='PortCollection'),
      portCollectionId?: string(name='PortCollectionId'),
      receiveTime?: string(name='ReceiveTime'),
      resourceApp?: {
        appId?: string(name='AppId'),
        domain?: string(name='Domain'),
        port?: string(name='Port'),
        securityDomain?: string(name='SecurityDomain'),
        type?: string(name='Type'),
      }(name='ResourceApp'),
      resourceDevice?: {
        deviceForm?: string(name='DeviceForm'),
        hostName?: string(name='HostName'),
        physicalSpace?: string(name='PhysicalSpace'),
      }(name='ResourceDevice'),
      responseCode?: string(name='ResponseCode'),
      result?: string(name='Result'),
      uniqueKey?: string(name='UniqueKey'),
    }
  ](name='AlarmStatus'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      count?: long(name='Count'),
      status?: string(name='Status'),
    }
  ](name='Statistics'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmStatusResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlarmStatusResponseBody(name='body'),
}

async function listAlarmStatusWithOptions(request: ListAlarmStatusRequest, runtime: Util.RuntimeOptions): ListAlarmStatusResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmStatus',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmStatus(request: ListAlarmStatusRequest): ListAlarmStatusResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmStatusWithOptions(request, runtime);
}

model ListAlarmStatusHistoriesRequest {
  aggregateDataId?: string(name='AggregateDataId'),
  appId?: string(name='AppId'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  deviceId?: string(name='DeviceId'),
  end?: long(name='End'),
  instanceId?: string(name='InstanceId'),
  monitorItemId?: string(name='MonitorItemId'),
  portCollectionId?: string(name='PortCollectionId'),
  start?: long(name='Start'),
  type?: string(name='Type'),
}

model ListAlarmStatusHistoriesResponseBody = {
  alarmStatusHistories?: [ 
    {
      timestamp?: long(name='Timestamp'),
      value?: string(name='Value'),
    }
  ](name='AlarmStatusHistories'),
  requestId?: string(name='RequestId'),
}

model ListAlarmStatusHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlarmStatusHistoriesResponseBody(name='body'),
}

async function listAlarmStatusHistoriesWithOptions(request: ListAlarmStatusHistoriesRequest, runtime: Util.RuntimeOptions): ListAlarmStatusHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmStatusHistories',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmStatusHistories(request: ListAlarmStatusHistoriesRequest): ListAlarmStatusHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmStatusHistoriesWithOptions(request, runtime);
}

model ListAlarmStatusStatisticsRequest {
  alarmStatus?: string(name='AlarmStatus'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  securityDomain?: string(name='SecurityDomain'),
  type?: string(name='Type'),
}

model ListAlarmStatusStatisticsResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      count?: long(name='Count'),
      name?: string(name='Name'),
      resourceId?: string(name='ResourceId'),
    }
  ](name='Statistics'),
  totalCount?: int32(name='TotalCount'),
}

model ListAlarmStatusStatisticsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListAlarmStatusStatisticsResponseBody(name='body'),
}

async function listAlarmStatusStatisticsWithOptions(request: ListAlarmStatusStatisticsRequest, runtime: Util.RuntimeOptions): ListAlarmStatusStatisticsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListAlarmStatusStatistics',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listAlarmStatusStatistics(request: ListAlarmStatusStatisticsRequest): ListAlarmStatusStatisticsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listAlarmStatusStatisticsWithOptions(request, runtime);
}

model ListArchitectureAttributeRequest {
  architectureId?: string(name='ArchitectureId'),
  instanceId?: string(name='InstanceId'),
  role?: string(name='Role'),
  vendor?: string(name='Vendor'),
}

model ListArchitectureAttributeResponseBody = {
  architecture?: [ 
    {
      model?: [ string ](name='Model'),
      role?: [ string ](name='Role'),
      vendor?: [ string ](name='Vendor'),
    }
  ](name='Architecture'),
  requestId?: string(name='RequestId'),
}

model ListArchitectureAttributeResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListArchitectureAttributeResponseBody(name='body'),
}

async function listArchitectureAttributeWithOptions(request: ListArchitectureAttributeRequest, runtime: Util.RuntimeOptions): ListArchitectureAttributeResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListArchitectureAttribute',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listArchitectureAttribute(request: ListArchitectureAttributeRequest): ListArchitectureAttributeResponse {
  var runtime = new Util.RuntimeOptions{};
  return listArchitectureAttributeWithOptions(request, runtime);
}

model ListConfigurationSpecificationsRequest {
  architecture?: string(name='Architecture'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  model?: string(name='Model'),
  nextToken?: string(name='NextToken'),
  role?: string(name='Role'),
  specificationName?: string(name='SpecificationName'),
  vendor?: string(name='Vendor'),
}

model ListConfigurationSpecificationsResponseBody = {
  configurationSpecification?: [ 
    {
      architecture?: string(name='Architecture'),
      configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
      createTime?: string(name='CreateTime'),
      model?: string(name='Model'),
      relatedVariate?: [ string ](name='RelatedVariate'),
      role?: string(name='Role'),
      specificationContent?: string(name='SpecificationContent'),
      specificationName?: string(name='SpecificationName'),
      updateTime?: string(name='UpdateTime'),
      vendor?: string(name='Vendor'),
    }
  ](name='ConfigurationSpecification'),
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListConfigurationSpecificationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigurationSpecificationsResponseBody(name='body'),
}

async function listConfigurationSpecificationsWithOptions(request: ListConfigurationSpecificationsRequest, runtime: Util.RuntimeOptions): ListConfigurationSpecificationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigurationSpecifications',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConfigurationSpecifications(request: ListConfigurationSpecificationsRequest): ListConfigurationSpecificationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigurationSpecificationsWithOptions(request, runtime);
}

model ListConfigurationVariateRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  variateName?: string(name='VariateName'),
}

model ListConfigurationVariateResponseBody = {
  configurationVariate?: [ 
    {
      comment?: string(name='Comment'),
      configurationVariateId?: string(name='ConfigurationVariateId'),
      createTime?: string(name='CreateTime'),
      formatFunction?: string(name='FormatFunction'),
      updateTime?: string(name='UpdateTime'),
      variateName?: string(name='VariateName'),
    }
  ](name='ConfigurationVariate'),
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListConfigurationVariateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConfigurationVariateResponseBody(name='body'),
}

async function listConfigurationVariateWithOptions(request: ListConfigurationVariateRequest, runtime: Util.RuntimeOptions): ListConfigurationVariateResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListConfigurationVariate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConfigurationVariate(request: ListConfigurationVariateRequest): ListConfigurationVariateResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConfigurationVariateWithOptions(request, runtime);
}

model ListConnectionPoliciesRequest {
  architectureIterationId?: string(name='ArchitectureIterationId'),
  connectionPolicyId?: string(name='ConnectionPolicyId'),
  downlinkArchitectureDeviceId?: string(name='DownlinkArchitectureDeviceId'),
  downlinkArchitectureModuleId?: string(name='DownlinkArchitectureModuleId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  uplinkArchitectureDeviceId?: string(name='UplinkArchitectureDeviceId'),
  uplinkArchitectureModuleId?: string(name='UplinkArchitectureModuleId'),
}

model ListConnectionPoliciesResponseBody = {
  connectionPolicy?: [ 
    {
      algorithm?: string(name='Algorithm'),
      architectureIterationId?: string(name='ArchitectureIterationId'),
      createTime?: string(name='CreateTime'),
      downlinkArchitectureDeviceId?: string(name='DownlinkArchitectureDeviceId'),
      downlinkArchitectureModuleId?: string(name='DownlinkArchitectureModuleId'),
      id?: string(name='Id'),
      linkCount?: int32(name='LinkCount'),
      name?: string(name='Name'),
      updateTime?: string(name='UpdateTime'),
      uplinkArchitectureDeviceId?: string(name='UplinkArchitectureDeviceId'),
      uplinkArchitectureModuleId?: string(name='UplinkArchitectureModuleId'),
    }
  ](name='ConnectionPolicy'),
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListConnectionPoliciesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListConnectionPoliciesResponseBody(name='body'),
}

async function listConnectionPoliciesWithOptions(request: ListConnectionPoliciesRequest, runtime: Util.RuntimeOptions): ListConnectionPoliciesResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.architectureIterationId)) {
    body['ArchitectureIterationId'] = request.architectureIterationId;
  }
  if (!Util.isUnset(request.connectionPolicyId)) {
    body['ConnectionPolicyId'] = request.connectionPolicyId;
  }
  if (!Util.isUnset(request.downlinkArchitectureDeviceId)) {
    body['DownlinkArchitectureDeviceId'] = request.downlinkArchitectureDeviceId;
  }
  if (!Util.isUnset(request.downlinkArchitectureModuleId)) {
    body['DownlinkArchitectureModuleId'] = request.downlinkArchitectureModuleId;
  }
  if (!Util.isUnset(request.uplinkArchitectureDeviceId)) {
    body['UplinkArchitectureDeviceId'] = request.uplinkArchitectureDeviceId;
  }
  if (!Util.isUnset(request.uplinkArchitectureModuleId)) {
    body['UplinkArchitectureModuleId'] = request.uplinkArchitectureModuleId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListConnectionPolicies',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listConnectionPolicies(request: ListConnectionPoliciesRequest): ListConnectionPoliciesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listConnectionPoliciesWithOptions(request, runtime);
}

model ListDedicatedLinesRequest {
  bandwidth?: int32(name='Bandwidth'),
  dedicatedLineGateway?: string(name='DedicatedLineGateway'),
  dedicatedLineIp?: string(name='DedicatedLineIp'),
  dedicatedLineRole?: string(name='DedicatedLineRole'),
  description?: string(name='Description'),
  deviceId?: string(name='DeviceId'),
  deviceName?: string(name='DeviceName'),
  devicePort?: string(name='DevicePort'),
  expirationDate?: string(name='ExpirationDate'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  ispFormId?: string(name='IspFormId'),
  ispId?: string(name='IspId'),
  keyword?: string(name='Keyword'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  onlineDate?: string(name='OnlineDate'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  spaceName?: string(name='SpaceName'),
}

model ListDedicatedLinesResponseBody = {
  dedicatedLines?: [ 
    {
      bandwidth?: int32(name='Bandwidth'),
      contact?: [ 
        {
          description?: string(name='Description'),
          email?: string(name='Email'),
          name?: string(name='Name'),
          phone?: string(name='Phone'),
        }
      ](name='Contact'),
      dedicatedLineGateway?: string(name='DedicatedLineGateway'),
      dedicatedLineId?: string(name='DedicatedLineId'),
      dedicatedLineIp?: string(name='DedicatedLineIp'),
      dedicatedLineRole?: string(name='DedicatedLineRole'),
      description?: string(name='Description'),
      deviceId?: string(name='DeviceId'),
      deviceName?: string(name='DeviceName'),
      devicePort?: string(name='DevicePort'),
      expirationDate?: string(name='ExpirationDate'),
      ext?: string(name='Ext'),
      isp?: string(name='Isp'),
      ispFormId?: string(name='IspFormId'),
      ispFormName?: string(name='IspFormName'),
      ispId?: string(name='IspId'),
      keyword?: string(name='Keyword'),
      onlineDate?: string(name='OnlineDate'),
      phone?: string(name='Phone'),
      physicalSpaceId?: string(name='PhysicalSpaceId'),
      spaceName?: string(name='SpaceName'),
    }
  ](name='DedicatedLines'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDedicatedLinesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDedicatedLinesResponseBody(name='body'),
}

async function listDedicatedLinesWithOptions(request: ListDedicatedLinesRequest, runtime: Util.RuntimeOptions): ListDedicatedLinesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDedicatedLines',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDedicatedLines(request: ListDedicatedLinesRequest): ListDedicatedLinesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDedicatedLinesWithOptions(request, runtime);
}

model ListDeviceFormsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListDeviceFormsResponseBody = {
  deviceForms?: [ 
    {
      accountConfig?: boolean(name='AccountConfig'),
      attributeList?: [ 
        {
          attributeBuiltIn?: boolean(name='AttributeBuiltIn'),
          attributeContent?: string(name='AttributeContent'),
          attributeFormat?: string(name='AttributeFormat'),
          attributeFuzzyQuery?: boolean(name='AttributeFuzzyQuery'),
          attributeKey?: string(name='AttributeKey'),
          attributeName?: string(name='AttributeName'),
          attributePlaceholder?: string(name='AttributePlaceholder'),
          attributeQuery?: boolean(name='AttributeQuery'),
          attributeReference?: string(name='AttributeReference'),
          attributeRequirement?: boolean(name='AttributeRequirement'),
          attributeSequence?: int32(name='AttributeSequence'),
          attributeTableDisplay?: boolean(name='AttributeTableDisplay'),
          attributeType?: string(name='AttributeType'),
          attributeUniqueness?: boolean(name='AttributeUniqueness'),
        }
      ](name='AttributeList'),
      configCompare?: boolean(name='ConfigCompare'),
      detailDisplay?: boolean(name='DetailDisplay'),
      deviceFormId?: string(name='DeviceFormId'),
      deviceFormName?: string(name='DeviceFormName'),
      formBuiltIn?: boolean(name='FormBuiltIn'),
      relatedDeviceFormId?: string(name='RelatedDeviceFormId'),
      resourceUse?: string(name='ResourceUse'),
      script?: string(name='Script'),
      uniqueKey?: string(name='UniqueKey'),
    }
  ](name='DeviceForms'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDeviceFormsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceFormsResponseBody(name='body'),
}

async function listDeviceFormsWithOptions(request: ListDeviceFormsRequest, runtime: Util.RuntimeOptions): ListDeviceFormsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceForms',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceForms(request: ListDeviceFormsRequest): ListDeviceFormsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceFormsWithOptions(request, runtime);
}

model ListDevicePropertiesRequest {
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListDevicePropertiesResponseBody = {
  deviceProperties?: [ 
    {
      builtIn?: boolean(name='BuiltIn'),
      deviceFormId?: string(name='DeviceFormId'),
      deviceFormName?: string(name='DeviceFormName'),
      devicePropertyId?: string(name='DevicePropertyId'),
      propertyContent?: string(name='PropertyContent'),
      propertyFormat?: string(name='PropertyFormat'),
      propertyKey?: string(name='PropertyKey'),
      propertyName?: string(name='PropertyName'),
    }
  ](name='DeviceProperties'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDevicePropertiesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevicePropertiesResponseBody(name='body'),
}

async function listDevicePropertiesWithOptions(request: ListDevicePropertiesRequest, runtime: Util.RuntimeOptions): ListDevicePropertiesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceProperties',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceProperties(request: ListDevicePropertiesRequest): ListDevicePropertiesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicePropertiesWithOptions(request, runtime);
}

model ListDeviceResourcesRequest {
  businessType?: string(name='BusinessType'),
  instanceId?: string(name='InstanceId'),
  listType?: string(name='ListType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ListDeviceResourcesResponseBody = {
  deviceResource?: [ 
    {
      blockNumber?: string(name='BlockNumber'),
      business?: string(name='Business'),
      config?: string(name='Config'),
      configTaskId?: string(name='ConfigTaskId'),
      configTaskStatus?: string(name='ConfigTaskStatus'),
      deliveryIp?: string(name='DeliveryIp'),
      deviceNumber?: string(name='DeviceNumber'),
      deviceResourceId?: string(name='DeviceResourceId'),
      generateConfig?: string(name='GenerateConfig'),
      hostName?: string(name='HostName'),
      interConnection?: string(name='InterConnection'),
      location?: string(name='Location'),
      loopback?: string(name='Loopback'),
      managerIp?: string(name='ManagerIp'),
      model?: string(name='Model'),
      params?: string(name='Params'),
      role?: string(name='Role'),
      setupProjectId?: string(name='SetupProjectId'),
      sn?: string(name='Sn'),
      specification?: string(name='Specification'),
      stack?: boolean(name='Stack'),
      vendor?: string(name='Vendor'),
    }
  ](name='DeviceResource'),
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListDeviceResourcesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceResourcesResponseBody(name='body'),
}

async function listDeviceResourcesWithOptions(request: ListDeviceResourcesRequest, runtime: Util.RuntimeOptions): ListDeviceResourcesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceResources',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceResources(request: ListDeviceResourcesRequest): ListDeviceResourcesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceResourcesWithOptions(request, runtime);
}

model ListDeviceValuesRequest {
  attributeGroup?: string(name='AttributeGroup'),
  attributeKeyword?: string(name='AttributeKeyword'),
  deviceFormId?: string(name='DeviceFormId'),
  deviceFormName?: string(name='DeviceFormName'),
  instanceId?: string(name='InstanceId'),
}

model ListDeviceValuesResponseBody = {
  deviceValues?: [ string ](name='DeviceValues'),
  requestId?: string(name='RequestId'),
}

model ListDeviceValuesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDeviceValuesResponseBody(name='body'),
}

async function listDeviceValuesWithOptions(request: ListDeviceValuesRequest, runtime: Util.RuntimeOptions): ListDeviceValuesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDeviceValues',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDeviceValues(request: ListDeviceValuesRequest): ListDeviceValuesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDeviceValuesWithOptions(request, runtime);
}

model ListDevicesRequest {
  calculateAmount?: boolean(name='CalculateAmount'),
  deviceFormId?: string(name='DeviceFormId'),
  deviceFormName?: string(name='DeviceFormName'),
  deviceIds?: [ string ](name='DeviceIds'),
  extAttributes?: string(name='ExtAttributes'),
  hostName?: [ string ](name='HostName'),
  instanceId?: string(name='InstanceId'),
  ip?: [ string ](name='Ip'),
  keyword?: string(name='Keyword'),
  mac?: [ string ](name='Mac'),
  maxResults?: int32(name='MaxResults'),
  model?: [ string ](name='Model'),
  nextToken?: string(name='NextToken'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceIds?: [ string ](name='PhysicalSpaceIds'),
  securityDomain?: [ string ](name='SecurityDomain'),
  serviceStatus?: [ string ](name='ServiceStatus'),
  sn?: [ string ](name='Sn'),
  vendor?: [ string ](name='Vendor'),
}

model ListDevicesShrinkRequest {
  calculateAmount?: boolean(name='CalculateAmount'),
  deviceFormId?: string(name='DeviceFormId'),
  deviceFormName?: string(name='DeviceFormName'),
  deviceIdsShrink?: string(name='DeviceIds'),
  extAttributes?: string(name='ExtAttributes'),
  hostNameShrink?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  ipShrink?: string(name='Ip'),
  keyword?: string(name='Keyword'),
  macShrink?: string(name='Mac'),
  maxResults?: int32(name='MaxResults'),
  modelShrink?: string(name='Model'),
  nextToken?: string(name='NextToken'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceIdsShrink?: string(name='PhysicalSpaceIds'),
  securityDomainShrink?: string(name='SecurityDomain'),
  serviceStatusShrink?: string(name='ServiceStatus'),
  snShrink?: string(name='Sn'),
  vendorShrink?: string(name='Vendor'),
}

model ListDevicesResponseBody = {
  amountDetail?: string(name='AmountDetail'),
  amountUsed?: int32(name='AmountUsed'),
  devices?: [ 
    {
      deviceFormId?: string(name='DeviceFormId'),
      deviceFormName?: string(name='DeviceFormName'),
      deviceId?: string(name='DeviceId'),
      enablePassword?: string(name='EnablePassword'),
      extAttributes?: string(name='ExtAttributes'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      hostName?: string(name='HostName'),
      ip?: string(name='Ip'),
      loginPassword?: string(name='LoginPassword'),
      loginType?: string(name='LoginType'),
      loginUsername?: string(name='LoginUsername'),
      mac?: string(name='Mac'),
      model?: string(name='Model'),
      physicalSpaceId?: string(name='PhysicalSpaceId'),
      physicalSpaceName?: string(name='PhysicalSpaceName'),
      securityDomain?: string(name='SecurityDomain'),
      serviceStatus?: string(name='ServiceStatus'),
      sn?: string(name='Sn'),
      snmpAccountType?: string(name='SnmpAccountType'),
      snmpAccountVersion?: string(name='SnmpAccountVersion'),
      snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
      snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
      snmpCommunity?: string(name='SnmpCommunity'),
      snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
      snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
      snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
      snmpUsername?: string(name='SnmpUsername'),
      vendor?: string(name='Vendor'),
    }
  ](name='Devices'),
  iotCoefficient?: int32(name='IotCoefficient'),
  maxResults?: int32(name='MaxResults'),
  networkCoefficient?: int32(name='NetworkCoefficient'),
  networkMaintenanceCoefficient?: int32(name='NetworkMaintenanceCoefficient'),
  nextToken?: int32(name='NextToken'),
  otherCoefficient?: int32(name='OtherCoefficient'),
  requestId?: string(name='RequestId'),
  serverCoefficient?: int32(name='ServerCoefficient'),
  serverMaintenanceCoefficient?: int32(name='ServerMaintenanceCoefficient'),
  totalCount?: int32(name='TotalCount'),
}

model ListDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListDevicesResponseBody(name='body'),
}

async function listDevicesWithOptions(tmpReq: ListDevicesRequest, runtime: Util.RuntimeOptions): ListDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceIds)) {
    request.deviceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceIds, 'DeviceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.hostName)) {
    request.hostNameShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.hostName, 'HostName', 'json');
  }
  if (!Util.isUnset(tmpReq.ip)) {
    request.ipShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ip, 'Ip', 'json');
  }
  if (!Util.isUnset(tmpReq.mac)) {
    request.macShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.mac, 'Mac', 'json');
  }
  if (!Util.isUnset(tmpReq.model)) {
    request.modelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.model, 'Model', 'json');
  }
  if (!Util.isUnset(tmpReq.physicalSpaceIds)) {
    request.physicalSpaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.physicalSpaceIds, 'PhysicalSpaceIds', 'json');
  }
  if (!Util.isUnset(tmpReq.securityDomain)) {
    request.securityDomainShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.securityDomain, 'SecurityDomain', 'json');
  }
  if (!Util.isUnset(tmpReq.serviceStatus)) {
    request.serviceStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.serviceStatus, 'ServiceStatus', 'json');
  }
  if (!Util.isUnset(tmpReq.sn)) {
    request.snShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sn, 'Sn', 'json');
  }
  if (!Util.isUnset(tmpReq.vendor)) {
    request.vendorShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.vendor, 'Vendor', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.calculateAmount)) {
    query['CalculateAmount'] = request.calculateAmount;
  }
  if (!Util.isUnset(request.deviceFormId)) {
    query['DeviceFormId'] = request.deviceFormId;
  }
  if (!Util.isUnset(request.deviceFormName)) {
    query['DeviceFormName'] = request.deviceFormName;
  }
  if (!Util.isUnset(request.deviceIdsShrink)) {
    query['DeviceIds'] = request.deviceIdsShrink;
  }
  if (!Util.isUnset(request.extAttributes)) {
    query['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.hostNameShrink)) {
    query['HostName'] = request.hostNameShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ipShrink)) {
    query['Ip'] = request.ipShrink;
  }
  if (!Util.isUnset(request.keyword)) {
    query['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.macShrink)) {
    query['Mac'] = request.macShrink;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.modelShrink)) {
    query['Model'] = request.modelShrink;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    query['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.physicalSpaceIdsShrink)) {
    query['PhysicalSpaceIds'] = request.physicalSpaceIdsShrink;
  }
  if (!Util.isUnset(request.securityDomainShrink)) {
    query['SecurityDomain'] = request.securityDomainShrink;
  }
  if (!Util.isUnset(request.serviceStatusShrink)) {
    query['ServiceStatus'] = request.serviceStatusShrink;
  }
  if (!Util.isUnset(request.snShrink)) {
    query['Sn'] = request.snShrink;
  }
  if (!Util.isUnset(request.vendorShrink)) {
    query['Vendor'] = request.vendorShrink;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListDevices',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listDevices(request: ListDevicesRequest): ListDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listDevicesWithOptions(request, runtime);
}

model ListEventDefinitionsRequest {
  eventId?: string(name='EventId'),
  eventName?: string(name='EventName'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListEventDefinitionsResponseBody = {
  eventDefinitions?: [
    EventDefinition
  ](name='EventDefinitions'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListEventDefinitionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventDefinitionsResponseBody(name='body'),
}

async function listEventDefinitionsWithOptions(request: ListEventDefinitionsRequest, runtime: Util.RuntimeOptions): ListEventDefinitionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEventDefinitions',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEventDefinitions(request: ListEventDefinitionsRequest): ListEventDefinitionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventDefinitionsWithOptions(request, runtime);
}

model ListEventsRequest {
  alarmStatus?: string(name='AlarmStatus'),
  deviceId?: string(name='DeviceId'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
}

model ListEventsResponseBody = {
  events?: [
    Event
  ](name='Events'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  statistics?: [ 
    {
      count?: int32(name='Count'),
      status?: string(name='Status'),
    }
  ](name='Statistics'),
  totalCount?: int32(name='TotalCount'),
}

model ListEventsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListEventsResponseBody(name='body'),
}

async function listEventsWithOptions(request: ListEventsRequest, runtime: Util.RuntimeOptions): ListEventsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListEvents',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listEvents(request: ListEventsRequest): ListEventsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listEventsWithOptions(request, runtime);
}

model ListInspectionDevicesRequest {
  instanceId?: string(name='InstanceId'),
  model?: [ string ](name='Model'),
  role?: string(name='Role'),
  vendor?: string(name='Vendor'),
}

model ListInspectionDevicesShrinkRequest {
  instanceId?: string(name='InstanceId'),
  modelShrink?: string(name='Model'),
  role?: string(name='Role'),
  vendor?: string(name='Vendor'),
}

model ListInspectionDevicesResponseBody = {
  inspectionScripts?: [ 
    {
      deviceId?: string(name='DeviceId'),
      deviceState?: string(name='DeviceState'),
      hostName?: string(name='HostName'),
      manageIp?: string(name='ManageIp'),
      model?: string(name='Model'),
      role?: string(name='Role'),
      space?: string(name='Space'),
      vendor?: string(name='Vendor'),
    }
  ](name='InspectionScripts'),
  requestId?: string(name='RequestId'),
}

model ListInspectionDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInspectionDevicesResponseBody(name='body'),
}

async function listInspectionDevicesWithOptions(tmpReq: ListInspectionDevicesRequest, runtime: Util.RuntimeOptions): ListInspectionDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new ListInspectionDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.model)) {
    request.modelShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.model, 'Model', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInspectionDevices',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInspectionDevices(request: ListInspectionDevicesRequest): ListInspectionDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInspectionDevicesWithOptions(request, runtime);
}

model ListInspectionTaskReportsRequest {
  inspectionItemId?: string(name='InspectionItemId'),
  instanceId?: string(name='InstanceId'),
  vendor?: string(name='Vendor'),
}

model ListInspectionTaskReportsResponseBody = {
  inspectionTask?: [ 
    {
      actualDeviceNumber?: long(name='ActualDeviceNumber'),
      alarmNumber?: long(name='AlarmNumber'),
      alarmStatistic?: [ 
        {
          criticalNumber?: long(name='CriticalNumber'),
          inspectionItem?: string(name='InspectionItem'),
          model?: string(name='Model'),
          vendor?: string(name='Vendor'),
          warningNumber?: long(name='WarningNumber'),
        }
      ](name='AlarmStatistic'),
      criticalNumber?: long(name='CriticalNumber'),
      criticalRate?: string(name='CriticalRate'),
      deviceRate?: string(name='DeviceRate'),
      failureStatistic?: string(name='FailureStatistic'),
      failureTaskNumber?: long(name='FailureTaskNumber'),
      failureTaskRate?: string(name='FailureTaskRate'),
      normalNumber?: long(name='NormalNumber'),
      normalRate?: string(name='NormalRate'),
      runningTaskNumber?: long(name='RunningTaskNumber'),
      runningTaskRate?: string(name='RunningTaskRate'),
      successTaskNumber?: long(name='SuccessTaskNumber'),
      successTaskRate?: string(name='SuccessTaskRate'),
      taskNumber?: long(name='TaskNumber'),
      totalDeviceNumber?: long(name='TotalDeviceNumber'),
      warningNumber?: long(name='WarningNumber'),
      warningRate?: string(name='WarningRate'),
    }
  ](name='InspectionTask'),
  requestId?: string(name='RequestId'),
}

model ListInspectionTaskReportsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInspectionTaskReportsResponseBody(name='body'),
}

async function listInspectionTaskReportsWithOptions(request: ListInspectionTaskReportsRequest, runtime: Util.RuntimeOptions): ListInspectionTaskReportsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInspectionTaskReports',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInspectionTaskReports(request: ListInspectionTaskReportsRequest): ListInspectionTaskReportsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInspectionTaskReportsWithOptions(request, runtime);
}

model ListInspectionTasksRequest {
  alarmStatus?: [ string ](name='AlarmStatus'),
  deviceType?: string(name='DeviceType'),
  hostName?: string(name='HostName'),
  IP?: string(name='IP'),
  instanceId?: string(name='InstanceId'),
  itemId?: string(name='ItemId'),
  maxResults?: int32(name='MaxResults'),
  model?: string(name='Model'),
  nextToken?: string(name='NextToken'),
  role?: string(name='Role'),
  space?: string(name='Space'),
  taskStatus?: string(name='TaskStatus'),
  vendor?: string(name='Vendor'),
}

model ListInspectionTasksShrinkRequest {
  alarmStatusShrink?: string(name='AlarmStatus'),
  deviceType?: string(name='DeviceType'),
  hostName?: string(name='HostName'),
  IP?: string(name='IP'),
  instanceId?: string(name='InstanceId'),
  itemId?: string(name='ItemId'),
  maxResults?: int32(name='MaxResults'),
  model?: string(name='Model'),
  nextToken?: string(name='NextToken'),
  role?: string(name='Role'),
  space?: string(name='Space'),
  taskStatus?: string(name='TaskStatus'),
  vendor?: string(name='Vendor'),
}

model ListInspectionTasksResponseBody = {
  inspectionTasks?: [ 
    {
      alarmStatus?: string(name='AlarmStatus'),
      deviceId?: string(name='DeviceId'),
      deviceType?: string(name='DeviceType'),
      errorCode?: string(name='ErrorCode'),
      executionBeginTime?: string(name='ExecutionBeginTime'),
      executionEndTime?: string(name='ExecutionEndTime'),
      hostName?: string(name='HostName'),
      IP?: string(name='IP'),
      inspectionAlarmRules?: [ 
        {
          actualValue?: string(name='ActualValue'),
          alarmExpression?: string(name='AlarmExpression'),
          alarmLevel?: string(name='AlarmLevel'),
          alarmOperator?: string(name='AlarmOperator'),
          alarmValue?: string(name='AlarmValue'),
        }
      ](name='InspectionAlarmRules'),
      inspectionMessage?: string(name='InspectionMessage'),
      inspectionResult?: string(name='InspectionResult'),
      isInspectionResultTruncation?: boolean(name='IsInspectionResultTruncation'),
      itemId?: string(name='ItemId'),
      itemName?: string(name='ItemName'),
      model?: [ string ](name='Model'),
      role?: string(name='Role'),
      scriptId?: string(name='ScriptId'),
      space?: string(name='Space'),
      taskId?: string(name='TaskId'),
      taskStatus?: string(name='TaskStatus'),
      vendor?: string(name='Vendor'),
    }
  ](name='InspectionTasks'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListInspectionTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInspectionTasksResponseBody(name='body'),
}

async function listInspectionTasksWithOptions(tmpReq: ListInspectionTasksRequest, runtime: Util.RuntimeOptions): ListInspectionTasksResponse {
  Util.validateModel(tmpReq);
  var request = new ListInspectionTasksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.alarmStatus)) {
    request.alarmStatusShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.alarmStatus, 'AlarmStatus', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListInspectionTasks',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInspectionTasks(request: ListInspectionTasksRequest): ListInspectionTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInspectionTasksWithOptions(request, runtime);
}

model ListInstancesResponseBody = {
  instances?: [ 
    {
      instanceDeviceMaxCount?: string(name='InstanceDeviceMaxCount'),
      instanceEndDate?: string(name='InstanceEndDate'),
      instanceId?: string(name='InstanceId'),
      instanceName?: string(name='InstanceName'),
      instanceOpenDate?: string(name='InstanceOpenDate'),
      instanceSpec?: string(name='InstanceSpec'),
      instanceStatus?: string(name='InstanceStatus'),
    }
  ](name='Instances'),
  requestId?: string(name='RequestId'),
}

model ListInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListInstancesResponseBody(name='body'),
}

async function listInstancesWithOptions(runtime: Util.RuntimeOptions): ListInstancesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListInstances',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listInstances(): ListInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listInstancesWithOptions(runtime);
}

model ListIpBlocksRequest {
  bottomNode?: boolean(name='BottomNode'),
  category?: string(name='Category'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  ipBlockCode?: string(name='IpBlockCode'),
  ipList?: [ string ](name='IpList'),
  leafNode?: boolean(name='LeafNode'),
  maxResults?: int32(name='MaxResults'),
  netBusiness?: string(name='NetBusiness'),
  netType?: string(name='NetType'),
  nextToken?: string(name='NextToken'),
  parentUid?: string(name='ParentUid'),
  status?: string(name='Status'),
  subNetBusiness?: string(name='SubNetBusiness'),
  topParent?: boolean(name='TopParent'),
  treeType?: boolean(name='TreeType'),
  zoneName?: string(name='ZoneName'),
}

model ListIpBlocksShrinkRequest {
  bottomNode?: boolean(name='BottomNode'),
  category?: string(name='Category'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  ipBlockCode?: string(name='IpBlockCode'),
  ipListShrink?: string(name='IpList'),
  leafNode?: boolean(name='LeafNode'),
  maxResults?: int32(name='MaxResults'),
  netBusiness?: string(name='NetBusiness'),
  netType?: string(name='NetType'),
  nextToken?: string(name='NextToken'),
  parentUid?: string(name='ParentUid'),
  status?: string(name='Status'),
  subNetBusiness?: string(name='SubNetBusiness'),
  topParent?: boolean(name='TopParent'),
  treeType?: boolean(name='TreeType'),
  zoneName?: string(name='ZoneName'),
}

model ListIpBlocksResponseBody = {
  ipBlock?: [ 
    {
      abbr?: string(name='Abbr'),
      application?: string(name='Application'),
      backupDeviceName?: string(name='BackupDeviceName'),
      businessTypeId?: string(name='BusinessTypeId'),
      businessTypeName?: string(name='BusinessTypeName'),
      category?: string(name='Category'),
      description?: string(name='Description'),
      deviceName?: string(name='DeviceName'),
      ipBlockCode?: string(name='IpBlockCode'),
      ipBlockId?: string(name='IpBlockId'),
      ipBlocks?: [ string ](name='IpBlocks'),
      isLock?: long(name='IsLock'),
      limitZoneTypes?: string(name='LimitZoneTypes'),
      netBusiness?: string(name='NetBusiness'),
      netType?: string(name='NetType'),
      ownership?: string(name='Ownership'),
      parentId?: string(name='ParentId'),
      queryIpList?: [ string ](name='QueryIpList'),
      splitRate?: double(name='SplitRate'),
      status?: string(name='Status'),
      subBusinessTypeName?: string(name='SubBusinessTypeName'),
      tasks?: [ 
        {
          domain?: string(name='Domain'),
          gmtCreateTime?: string(name='GmtCreateTime'),
          gmtModifiedTime?: string(name='GmtModifiedTime'),
          ip?: string(name='Ip'),
          ipList?: [ 
            {
              devId?: string(name='DevId'),
              devName?: string(name='DevName'),
              ip?: string(name='Ip'),
              origin?: string(name='Origin'),
              ping?: string(name='Ping'),
            }
          ](name='IpList'),
          msg?: string(name='Msg'),
          status?: string(name='Status'),
          taskId?: string(name='TaskId'),
          totalIpCount?: long(name='TotalIpCount'),
        }
      ](name='Tasks'),
      zoneLayer?: [ 
        {
          name?: string(name='Name'),
          value?: string(name='Value'),
        }
      ](name='ZoneLayer'),
      zoneName?: string(name='ZoneName'),
    }
  ](name='IpBlock'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListIpBlocksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListIpBlocksResponseBody(name='body'),
}

async function listIpBlocksWithOptions(tmpReq: ListIpBlocksRequest, runtime: Util.RuntimeOptions): ListIpBlocksResponse {
  Util.validateModel(tmpReq);
  var request = new ListIpBlocksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.ipList)) {
    request.ipListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.ipList, 'IpList', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListIpBlocks',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listIpBlocks(request: ListIpBlocksRequest): ListIpBlocksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listIpBlocksWithOptions(request, runtime);
}

model ListLinksRequest {
  deviceNameA?: string(name='DeviceNameA'),
  deviceNameB?: string(name='DeviceNameB'),
  ipA?: string(name='IpA'),
  ipB?: string(name='IpB'),
  linkName?: string(name='LinkName'),
  linkNo?: string(name='LinkNo'),
  linkStatus?: string(name='LinkStatus'),
  linkType?: string(name='LinkType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  portA?: string(name='PortA'),
  portB?: string(name='PortB'),
}

model ListLinksResponseBody = {
  content?: [ 
    {
      deviceNameA?: string(name='DeviceNameA'),
      deviceNameB?: string(name='DeviceNameB'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      idxA?: string(name='IdxA'),
      idxB?: string(name='IdxB'),
      ipA?: string(name='IpA'),
      ipB?: string(name='IpB'),
      jobId?: string(name='JobId'),
      linkName?: string(name='LinkName'),
      linkNo?: string(name='LinkNo'),
      linkStatus?: string(name='LinkStatus'),
      linkType?: string(name='LinkType'),
      message?: string(name='Message'),
      portA?: string(name='PortA'),
      portB?: string(name='PortB'),
      portDescA?: string(name='PortDescA'),
      portDescB?: string(name='PortDescB'),
      portStatusA?: string(name='PortStatusA'),
      portStatusB?: string(name='PortStatusB'),
      portTypeA?: string(name='PortTypeA'),
      portTypeB?: string(name='PortTypeB'),
      regionId?: string(name='RegionId'),
    }
  ](name='Content'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLinksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLinksResponseBody(name='body'),
}

async function listLinksWithOptions(request: ListLinksRequest, runtime: Util.RuntimeOptions): ListLinksResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLinks',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLinks(request: ListLinksRequest): ListLinksResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLinksWithOptions(request, runtime);
}

model ListLogsRequest {
  alarmStatus?: string(name='AlarmStatus'),
  content?: string(name='Content'),
  deviceId?: string(name='DeviceId'),
  end?: long(name='End'),
  instanceId?: string(name='InstanceId'),
  logType?: string(name='LogType'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  sort?: string(name='Sort'),
  start?: long(name='Start'),
}

model ListLogsResponseBody = {
  logs?: [ 
    {
      alarmObject?: string(name='AlarmObject'),
      alarmStatus?: string(name='AlarmStatus'),
      alarmType?: string(name='AlarmType'),
      deviceId?: string(name='DeviceId'),
      log?: string(name='Log'),
      receiveTime?: string(name='ReceiveTime'),
      resourceDevice?: {
        hostName?: string(name='HostName'),
        physicalSpace?: string(name='PhysicalSpace'),
      }(name='ResourceDevice'),
      time?: string(name='Time'),
    }
  ](name='Logs'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListLogsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListLogsResponseBody(name='body'),
}

async function listLogsWithOptions(request: ListLogsRequest, runtime: Util.RuntimeOptions): ListLogsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListLogs',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listLogs(request: ListLogsRequest): ListLogsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listLogsWithOptions(request, runtime);
}

model ListMonitorDataRequest {
  aggregateDataId?: string(name='AggregateDataId'),
  aggregationType?: string(name='AggregationType'),
  appId?: string(name='AppId'),
  dataItem?: string(name='DataItem'),
  dataType?: string(name='DataType'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  deviceId?: string(name='DeviceId'),
  end?: long(name='End'),
  instanceId?: string(name='InstanceId'),
  key?: string(name='Key'),
  monitorItemId?: string(name='MonitorItemId'),
  portCollectionId?: string(name='PortCollectionId'),
  start?: long(name='Start'),
}

model ListMonitorDataResponseBody = {
  monitorData?: [ 
    {
      dataItem?: string(name='DataItem'),
      key?: string(name='Key'),
      timestamp?: long(name='Timestamp'),
      value?: string(name='Value'),
    }
  ](name='MonitorData'),
  requestId?: string(name='RequestId'),
}

model ListMonitorDataResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListMonitorDataResponseBody(name='body'),
}

async function listMonitorDataWithOptions(request: ListMonitorDataRequest, runtime: Util.RuntimeOptions): ListMonitorDataResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListMonitorData',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listMonitorData(request: ListMonitorDataRequest): ListMonitorDataResponse {
  var runtime = new Util.RuntimeOptions{};
  return listMonitorDataWithOptions(request, runtime);
}

model ListNotificationHistoriesRequest {
  aggregateDataId?: string(name='AggregateDataId'),
  alarmStatus?: string(name='AlarmStatus'),
  appId?: string(name='AppId'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  deviceId?: string(name='DeviceId'),
  end?: long(name='End'),
  eventItemId?: string(name='EventItemId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  message?: string(name='Message'),
  monitorItemId?: string(name='MonitorItemId'),
  nextToken?: string(name='NextToken'),
  notificationGroupId?: string(name='NotificationGroupId'),
  notificationMode?: string(name='NotificationMode'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  portCollectionId?: string(name='PortCollectionId'),
  start?: long(name='Start'),
  status?: string(name='Status'),
  type?: string(name='Type'),
}

model ListNotificationHistoriesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  notificationHistories?: [ 
    {
      aggregateDataId?: string(name='AggregateDataId'),
      alarmStatus?: string(name='AlarmStatus'),
      appId?: string(name='AppId'),
      dedicatedLineId?: string(name='DedicatedLineId'),
      deviceId?: string(name='DeviceId'),
      message?: string(name='Message'),
      monitorItemId?: string(name='MonitorItemId'),
      notificationGroupId?: string(name='NotificationGroupId'),
      notificationGroupName?: string(name='NotificationGroupName'),
      notificationMode?: string(name='NotificationMode'),
      output?: string(name='Output'),
      portCollectionId?: string(name='PortCollectionId'),
      status?: string(name='Status'),
      time?: string(name='Time'),
    }
  ](name='NotificationHistories'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListNotificationHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListNotificationHistoriesResponseBody(name='body'),
}

async function listNotificationHistoriesWithOptions(request: ListNotificationHistoriesRequest, runtime: Util.RuntimeOptions): ListNotificationHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListNotificationHistories',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listNotificationHistories(request: ListNotificationHistoriesRequest): ListNotificationHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listNotificationHistoriesWithOptions(request, runtime);
}

model ListOsVersionsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListOsVersionsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  osVersion?: [ 
    {
      createTime?: string(name='CreateTime'),
      fileName?: string(name='FileName'),
      filePath?: string(name='FilePath'),
      model?: string(name='Model'),
      osVersion?: string(name='OsVersion'),
      osVersionId?: string(name='OsVersionId'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
      vendor?: string(name='Vendor'),
    }
  ](name='OsVersion'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListOsVersionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListOsVersionsResponseBody(name='body'),
}

async function listOsVersionsWithOptions(request: ListOsVersionsRequest, runtime: Util.RuntimeOptions): ListOsVersionsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListOsVersions',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listOsVersions(request: ListOsVersionsRequest): ListOsVersionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listOsVersionsWithOptions(request, runtime);
}

model ListPhysicalSpacesRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceIds?: [ string ](name='PhysicalSpaceIds'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
}

model ListPhysicalSpacesShrinkRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceIdsShrink?: string(name='PhysicalSpaceIds'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
}

model ListPhysicalSpacesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  physicalSpaces?: [ 
    {
      address?: string(name='Address'),
      city?: string(name='City'),
      country?: string(name='Country'),
      instance?: string(name='Instance'),
      owner?: string(name='Owner'),
      physicalSpaceId?: string(name='PhysicalSpaceId'),
      physicalSpaceName?: string(name='PhysicalSpaceName'),
      province?: string(name='Province'),
      remark?: string(name='Remark'),
      securityDomainList?: [ string ](name='SecurityDomainList'),
      spaceAbbreviation?: string(name='SpaceAbbreviation'),
      spaceType?: string(name='SpaceType'),
    }
  ](name='PhysicalSpaces'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListPhysicalSpacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListPhysicalSpacesResponseBody(name='body'),
}

async function listPhysicalSpacesWithOptions(tmpReq: ListPhysicalSpacesRequest, runtime: Util.RuntimeOptions): ListPhysicalSpacesResponse {
  Util.validateModel(tmpReq);
  var request = new ListPhysicalSpacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.physicalSpaceIds)) {
    request.physicalSpaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.physicalSpaceIds, 'PhysicalSpaceIds', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListPhysicalSpaces',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listPhysicalSpaces(request: ListPhysicalSpacesRequest): ListPhysicalSpacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listPhysicalSpacesWithOptions(request, runtime);
}

model ListRegionsResponseBody = {
  code?: string(name='Code'),
  data?: string(name='Data'),
  message?: string(name='Message'),
  requestId?: string(name='RequestId'),
  success?: boolean(name='Success'),
}

model ListRegionsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListRegionsResponseBody(name='body'),
}

async function listRegionsWithOptions(runtime: Util.RuntimeOptions): ListRegionsResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListRegions',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listRegions(): ListRegionsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listRegionsWithOptions(runtime);
}

model ListResourceInformationsRequest {
  architectureId?: string(name='ArchitectureId'),
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListResourceInformationsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  resourceInformation?: [ 
    {
      information?: [ 
        {
          key?: string(name='Key'),
          keyAction?: string(name='KeyAction'),
          keyAttribute?: string(name='KeyAttribute'),
          keyDescription?: string(name='KeyDescription'),
        }
      ](name='Information'),
      resourceAttribute?: string(name='ResourceAttribute'),
      resourceInformationId?: string(name='ResourceInformationId'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='ResourceInformation'),
  totalCount?: int32(name='TotalCount'),
}

model ListResourceInformationsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInformationsResponseBody(name='body'),
}

async function listResourceInformationsWithOptions(request: ListResourceInformationsRequest, runtime: Util.RuntimeOptions): ListResourceInformationsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInformations',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceInformations(request: ListResourceInformationsRequest): ListResourceInformationsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceInformationsWithOptions(request, runtime);
}

model ListResourceInstancesRequest {
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ListResourceInstancesResponseBody = {
  logicResource?: [ 
    {
      keyList?: [ 
        {
          key?: string(name='Key'),
          keyAction?: string(name='KeyAction'),
          keyAttribute?: string(name='KeyAttribute'),
          keyDescription?: string(name='KeyDescription'),
          value?: string(name='Value'),
        }
      ](name='KeyList'),
      resourceAttribute?: string(name='ResourceAttribute'),
      resourceType?: string(name='ResourceType'),
    }
  ](name='LogicResource'),
  requestId?: string(name='RequestId'),
}

model ListResourceInstancesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceInstancesResponseBody(name='body'),
}

async function listResourceInstancesWithOptions(request: ListResourceInstancesRequest, runtime: Util.RuntimeOptions): ListResourceInstancesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListResourceInstances',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceInstances(request: ListResourceInstancesRequest): ListResourceInstancesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceInstancesWithOptions(request, runtime);
}

model ListResourceTypesResponseBody = {
  requestId?: string(name='RequestId'),
  resourceType?: [ 
    {
      key?: string(name='Key'),
      resourceType?: string(name='ResourceType'),
      resourceTypeName?: string(name='ResourceTypeName'),
    }
  ](name='ResourceType'),
}

model ListResourceTypesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListResourceTypesResponseBody(name='body'),
}

async function listResourceTypesWithOptions(runtime: Util.RuntimeOptions): ListResourceTypesResponse {
  var req = new OpenApi.OpenApiRequest{};
  var params = new OpenApi.Params{
    action = 'ListResourceTypes',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listResourceTypes(): ListResourceTypesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listResourceTypesWithOptions(runtime);
}

model ListSetupProjectsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  spaceId?: string(name='SpaceId'),
  status?: string(name='Status'),
}

model ListSetupProjectsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  setupProject?: [ 
    {
      archVersion?: string(name='ArchVersion'),
      architectureId?: string(name='ArchitectureId'),
      createTime?: string(name='CreateTime'),
      deliveryTime?: string(name='DeliveryTime'),
      description?: string(name='Description'),
      nodes?: string(name='Nodes'),
      packages?: [ 
        {
          deviceNumber?: long(name='DeviceNumber'),
          model?: string(name='Model'),
          role?: string(name='Role'),
          vendor?: string(name='Vendor'),
        }
      ](name='Packages'),
      progress?: string(name='Progress'),
      setupProjectId?: string(name='SetupProjectId'),
      spaceId?: string(name='SpaceId'),
      spaceName?: string(name='SpaceName'),
      spaceType?: string(name='SpaceType'),
    }
  ](name='SetupProject'),
  totalCount?: int32(name='TotalCount'),
}

model ListSetupProjectsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSetupProjectsResponseBody(name='body'),
}

async function listSetupProjectsWithOptions(request: ListSetupProjectsRequest, runtime: Util.RuntimeOptions): ListSetupProjectsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSetupProjects',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSetupProjects(request: ListSetupProjectsRequest): ListSetupProjectsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSetupProjectsWithOptions(request, runtime);
}

model ListSpaceModelsRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  spaceType?: string(name='SpaceType'),
  status?: string(name='Status'),
}

model ListSpaceModelsResponseBody = {
  maxResults?: long(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  requestId?: string(name='RequestId'),
  spaceModel?: [ 
    {
      createTime?: string(name='CreateTime'),
      sort?: [ 
        {
          level?: long(name='Level'),
          levelName?: string(name='LevelName'),
        }
      ](name='Sort'),
      spaceModelId?: string(name='SpaceModelId'),
      spaceType?: string(name='SpaceType'),
      status?: string(name='Status'),
      updateTime?: string(name='UpdateTime'),
    }
  ](name='SpaceModel'),
  totalCount?: int32(name='TotalCount'),
}

model ListSpaceModelsResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListSpaceModelsResponseBody(name='body'),
}

async function listSpaceModelsWithOptions(request: ListSpaceModelsRequest, runtime: Util.RuntimeOptions): ListSpaceModelsResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListSpaceModels',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listSpaceModels(request: ListSpaceModelsRequest): ListSpaceModelsResponse {
  var runtime = new Util.RuntimeOptions{};
  return listSpaceModelsWithOptions(request, runtime);
}

model ListTasksHistoriesRequest {
  deviceId?: string(name='DeviceId'),
  instanceId?: string(name='InstanceId'),
  itemId?: string(name='ItemId'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: string(name='NextToken'),
}

model ListTasksHistoriesResponseBody = {
  inspectionTasks?: [ 
    {
      deviceDisplay?: string(name='DeviceDisplay'),
      errorCode?: string(name='ErrorCode'),
      executionBeginTime?: string(name='ExecutionBeginTime'),
      executionEndTime?: string(name='ExecutionEndTime'),
      inspectionAlarmRules?: [ 
        {
          actualValue?: string(name='ActualValue'),
          alarmExpression?: string(name='AlarmExpression'),
          alarmLevel?: string(name='AlarmLevel'),
          alarmOperator?: string(name='AlarmOperator'),
          alarmValue?: string(name='AlarmValue'),
        }
      ](name='InspectionAlarmRules'),
      inspectionResult?: string(name='InspectionResult'),
      taskId?: string(name='TaskId'),
    }
  ](name='InspectionTasks'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListTasksHistoriesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTasksHistoriesResponseBody(name='body'),
}

async function listTasksHistoriesWithOptions(request: ListTasksHistoriesRequest, runtime: Util.RuntimeOptions): ListTasksHistoriesResponse {
  Util.validateModel(request);
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTasksHistories',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTasksHistories(request: ListTasksHistoriesRequest): ListTasksHistoriesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTasksHistoriesWithOptions(request, runtime);
}

model ListTreePhysicalSpacesRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceIds?: [ string ](name='PhysicalSpaceIds'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  tree?: boolean(name='Tree'),
}

model ListTreePhysicalSpacesShrinkRequest {
  instanceId?: string(name='InstanceId'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  physicalSpaceIdsShrink?: string(name='PhysicalSpaceIds'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  tree?: boolean(name='Tree'),
}

model ListTreePhysicalSpacesResponseBody = {
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  physicalSpaces?: [
    PhysicalSpaceDto
  ](name='PhysicalSpaces'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListTreePhysicalSpacesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListTreePhysicalSpacesResponseBody(name='body'),
}

async function listTreePhysicalSpacesWithOptions(tmpReq: ListTreePhysicalSpacesRequest, runtime: Util.RuntimeOptions): ListTreePhysicalSpacesResponse {
  Util.validateModel(tmpReq);
  var request = new ListTreePhysicalSpacesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.physicalSpaceIds)) {
    request.physicalSpaceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.physicalSpaceIds, 'PhysicalSpaceIds', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ListTreePhysicalSpaces',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listTreePhysicalSpaces(request: ListTreePhysicalSpacesRequest): ListTreePhysicalSpacesResponse {
  var runtime = new Util.RuntimeOptions{};
  return listTreePhysicalSpacesWithOptions(request, runtime);
}

model ListWorkOrdersRequest {
  deviceSnA?: string(name='DeviceSnA'),
  instanceId?: string(name='InstanceId'),
  maxResults?: string(name='MaxResults'),
  nextToken?: string(name='NextToken'),
  workOrderSource?: string(name='WorkOrderSource'),
  workOrderStep?: string(name='WorkOrderStep'),
  workOrderTitle?: string(name='WorkOrderTitle'),
}

model ListWorkOrdersResponseBody = {
  content?: [ 
    {
      alarmHappenTime?: string(name='AlarmHappenTime'),
      alarmRecoverTime?: string(name='AlarmRecoverTime'),
      alarmRelated?: string(name='AlarmRelated'),
      area?: string(name='Area'),
      circuitId?: string(name='CircuitId'),
      circuitName?: string(name='CircuitName'),
      circuitType?: string(name='CircuitType'),
      deviceAlarmInfo?: string(name='DeviceAlarmInfo'),
      deviceIp?: string(name='DeviceIp'),
      deviceIpA?: string(name='DeviceIpA'),
      deviceIpB?: string(name='DeviceIpB'),
      deviceModelA?: string(name='DeviceModelA'),
      deviceModelB?: string(name='DeviceModelB'),
      deviceName?: string(name='DeviceName'),
      deviceNameA?: string(name='DeviceNameA'),
      deviceNameB?: string(name='DeviceNameB'),
      devicePortA?: string(name='DevicePortA'),
      devicePortB?: string(name='DevicePortB'),
      deviceSnA?: string(name='DeviceSnA'),
      deviceSnB?: string(name='DeviceSnB'),
      deviceType?: string(name='DeviceType'),
      deviceVendor?: string(name='DeviceVendor'),
      deviceVendorA?: string(name='DeviceVendorA'),
      deviceVendorB?: string(name='DeviceVendorB'),
      emergencyDegree?: string(name='EmergencyDegree'),
      extra?: string(name='Extra'),
      faultDuration?: string(name='FaultDuration'),
      gmtCreate?: string(name='GmtCreate'),
      gmtModified?: string(name='GmtModified'),
      hangFileName?: string(name='HangFileName'),
      hangFilePath?: string(name='HangFilePath'),
      hangReason?: string(name='HangReason'),
      impactBusiness?: string(name='ImpactBusiness'),
      incidentDescription?: string(name='IncidentDescription'),
      incidentSubType?: string(name='IncidentSubType'),
      incidentType?: string(name='IncidentType'),
      liableMan?: string(name='LiableMan'),
      linkMan?: string(name='LinkMan'),
      originalSubjectAlarm?: string(name='OriginalSubjectAlarm'),
      processLimited?: string(name='ProcessLimited'),
      processMan?: string(name='ProcessMan'),
      processManId?: string(name='ProcessManId'),
      processResult?: string(name='ProcessResult'),
      skillGroups?: string(name='SkillGroups'),
      timeout?: string(name='Timeout'),
      workOrderId?: string(name='WorkOrderId'),
      workOrderOperationDtos?: [ 
        {
          gmtCreate?: string(name='GmtCreate'),
          operation?: string(name='Operation'),
          operationId?: string(name='OperationId'),
          operator?: string(name='Operator'),
          remark?: string(name='Remark'),
          workOrderId?: string(name='WorkOrderId'),
        }
      ](name='WorkOrderOperationDtos'),
      workOrderSource?: string(name='WorkOrderSource'),
      workOrderStep?: string(name='WorkOrderStep'),
      workOrderTitle?: string(name='WorkOrderTitle'),
      workOrderType?: string(name='WorkOrderType'),
    }
  ](name='Content'),
  maxResults?: int32(name='MaxResults'),
  nextToken?: int32(name='NextToken'),
  requestId?: string(name='RequestId'),
  totalCount?: int32(name='TotalCount'),
}

model ListWorkOrdersResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ListWorkOrdersResponseBody(name='body'),
}

async function listWorkOrdersWithOptions(request: ListWorkOrdersRequest, runtime: Util.RuntimeOptions): ListWorkOrdersResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.maxResults)) {
    query['MaxResults'] = request.maxResults;
  }
  if (!Util.isUnset(request.nextToken)) {
    query['NextToken'] = request.nextToken;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceSnA)) {
    body['DeviceSnA'] = request.deviceSnA;
  }
  if (!Util.isUnset(request.workOrderSource)) {
    body['WorkOrderSource'] = request.workOrderSource;
  }
  if (!Util.isUnset(request.workOrderStep)) {
    body['WorkOrderStep'] = request.workOrderStep;
  }
  if (!Util.isUnset(request.workOrderTitle)) {
    body['WorkOrderTitle'] = request.workOrderTitle;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'ListWorkOrders',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function listWorkOrders(request: ListWorkOrdersRequest): ListWorkOrdersResponse {
  var runtime = new Util.RuntimeOptions{};
  return listWorkOrdersWithOptions(request, runtime);
}

model LockSpaceModelRequest {
  instanceId?: string(name='InstanceId'),
  spaceModelId?: string(name='SpaceModelId'),
}

model LockSpaceModelResponseBody = {
  requestId?: string(name='RequestId'),
}

model LockSpaceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: LockSpaceModelResponseBody(name='body'),
}

async function lockSpaceModelWithOptions(request: LockSpaceModelRequest, runtime: Util.RuntimeOptions): LockSpaceModelResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.spaceModelId)) {
    query['SpaceModelId'] = request.spaceModelId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'LockSpaceModel',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function lockSpaceModel(request: LockSpaceModelRequest): LockSpaceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return lockSpaceModelWithOptions(request, runtime);
}

model ReleaseIPRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIds?: [ string ](name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  ipType?: string(name='IpType'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ReleaseIPShrinkRequest {
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIdsShrink?: string(name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  ipType?: string(name='IpType'),
  setupProjectId?: string(name='SetupProjectId'),
}

model ReleaseIPResponseBody = {
  requestId?: string(name='RequestId'),
}

model ReleaseIPResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: ReleaseIPResponseBody(name='body'),
}

async function releaseIPWithOptions(tmpReq: ReleaseIPRequest, runtime: Util.RuntimeOptions): ReleaseIPResponse {
  Util.validateModel(tmpReq);
  var request = new ReleaseIPShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceResourceIds)) {
    request.deviceResourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceResourceIds, 'DeviceResourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.deviceResourceId)) {
    query['DeviceResourceId'] = request.deviceResourceId;
  }
  if (!Util.isUnset(request.deviceResourceIdsShrink)) {
    query['DeviceResourceIds'] = request.deviceResourceIdsShrink;
  }
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.ipType)) {
    query['IpType'] = request.ipType;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    query['SetupProjectId'] = request.setupProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'ReleaseIP',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function releaseIP(request: ReleaseIPRequest): ReleaseIPResponse {
  var runtime = new Util.RuntimeOptions{};
  return releaseIPWithOptions(request, runtime);
}

model RemarkWorkOrderRequest {
  clientToken?: string(name='ClientToken'),
  instanceId?: string(name='InstanceId'),
  operator?: string(name='Operator'),
  remark?: string(name='Remark'),
  workOrderId?: string(name='WorkOrderId'),
}

model RemarkWorkOrderResponseBody = {
  operationId?: string(name='OperationId'),
  requestId?: string(name='RequestId'),
}

model RemarkWorkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RemarkWorkOrderResponseBody(name='body'),
}

async function remarkWorkOrderWithOptions(request: RemarkWorkOrderRequest, runtime: Util.RuntimeOptions): RemarkWorkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.operator)) {
    body['Operator'] = request.operator;
  }
  if (!Util.isUnset(request.remark)) {
    body['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.workOrderId)) {
    body['WorkOrderId'] = request.workOrderId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'RemarkWorkOrder',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function remarkWorkOrder(request: RemarkWorkOrderRequest): RemarkWorkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return remarkWorkOrderWithOptions(request, runtime);
}

model RetryTasksRequest {
  instanceId?: string(name='InstanceId'),
  retryTasks?: [ 
    {
      deviceId?: string(name='DeviceId'),
      itemName?: string(name='ItemName'),
      scriptId?: string(name='ScriptId'),
    }
  ](name='RetryTasks'),
}

model RetryTasksShrinkRequest {
  instanceId?: string(name='InstanceId'),
  retryTasksShrink?: string(name='RetryTasks'),
}

model RetryTasksResponseBody = {
  requestId?: string(name='RequestId'),
}

model RetryTasksResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: RetryTasksResponseBody(name='body'),
}

async function retryTasksWithOptions(tmpReq: RetryTasksRequest, runtime: Util.RuntimeOptions): RetryTasksResponse {
  Util.validateModel(tmpReq);
  var request = new RetryTasksShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.retryTasks)) {
    request.retryTasksShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.retryTasks, 'RetryTasks', 'json');
  }
  var query = OpenApiUtil.query(Util.toMap(request));
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'RetryTasks',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'GET',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function retryTasks(request: RetryTasksRequest): RetryTasksResponse {
  var runtime = new Util.RuntimeOptions{};
  return retryTasksWithOptions(request, runtime);
}

model UpdateConfigurationSpecificationRequest {
  architecture?: string(name='Architecture'),
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  relatedVariate?: [ bytes ](name='RelatedVariate'),
  role?: string(name='Role'),
  specificationContent?: string(name='SpecificationContent'),
  specificationName?: string(name='SpecificationName'),
  vendor?: string(name='Vendor'),
}

model UpdateConfigurationSpecificationShrinkRequest {
  architecture?: string(name='Architecture'),
  configurationSpecificationId?: string(name='ConfigurationSpecificationId'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  relatedVariateShrink?: string(name='RelatedVariate'),
  role?: string(name='Role'),
  specificationContent?: string(name='SpecificationContent'),
  specificationName?: string(name='SpecificationName'),
  vendor?: string(name='Vendor'),
}

model UpdateConfigurationSpecificationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateConfigurationSpecificationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigurationSpecificationResponseBody(name='body'),
}

async function updateConfigurationSpecificationWithOptions(tmpReq: UpdateConfigurationSpecificationRequest, runtime: Util.RuntimeOptions): UpdateConfigurationSpecificationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateConfigurationSpecificationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.relatedVariate)) {
    request.relatedVariateShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.relatedVariate, 'RelatedVariate', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.architecture)) {
    body['Architecture'] = request.architecture;
  }
  if (!Util.isUnset(request.configurationSpecificationId)) {
    body['ConfigurationSpecificationId'] = request.configurationSpecificationId;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.relatedVariateShrink)) {
    body['RelatedVariate'] = request.relatedVariateShrink;
  }
  if (!Util.isUnset(request.role)) {
    body['Role'] = request.role;
  }
  if (!Util.isUnset(request.specificationContent)) {
    body['SpecificationContent'] = request.specificationContent;
  }
  if (!Util.isUnset(request.specificationName)) {
    body['SpecificationName'] = request.specificationName;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigurationSpecification',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfigurationSpecification(request: UpdateConfigurationSpecificationRequest): UpdateConfigurationSpecificationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigurationSpecificationWithOptions(request, runtime);
}

model UpdateConfigurationVariateRequest {
  comment?: string(name='Comment'),
  configurationVariateId?: string(name='ConfigurationVariateId'),
  formatFunction?: string(name='FormatFunction'),
  instanceId?: string(name='InstanceId'),
  variateName?: string(name='VariateName'),
}

model UpdateConfigurationVariateResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateConfigurationVariateResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateConfigurationVariateResponseBody(name='body'),
}

async function updateConfigurationVariateWithOptions(request: UpdateConfigurationVariateRequest, runtime: Util.RuntimeOptions): UpdateConfigurationVariateResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.comment)) {
    body['Comment'] = request.comment;
  }
  if (!Util.isUnset(request.configurationVariateId)) {
    body['ConfigurationVariateId'] = request.configurationVariateId;
  }
  if (!Util.isUnset(request.formatFunction)) {
    body['FormatFunction'] = request.formatFunction;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.variateName)) {
    body['VariateName'] = request.variateName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateConfigurationVariate',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateConfigurationVariate(request: UpdateConfigurationVariateRequest): UpdateConfigurationVariateResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateConfigurationVariateWithOptions(request, runtime);
}

model UpdateDedicatedLineRequest {
  bandwidth?: int32(name='Bandwidth'),
  contact?: string(name='Contact'),
  dedicatedLineGateway?: string(name='DedicatedLineGateway'),
  dedicatedLineId?: string(name='DedicatedLineId'),
  dedicatedLineIp?: string(name='DedicatedLineIp'),
  dedicatedLineRole?: string(name='DedicatedLineRole'),
  description?: string(name='Description'),
  deviceId?: string(name='DeviceId'),
  devicePort?: string(name='DevicePort'),
  expirationDate?: string(name='ExpirationDate'),
  extAttributes?: string(name='ExtAttributes'),
  instanceId?: string(name='InstanceId'),
  isp?: string(name='Isp'),
  ispId?: string(name='IspId'),
  keyword?: string(name='Keyword'),
  onlineDate?: string(name='OnlineDate'),
  phone?: string(name='Phone'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
}

model UpdateDedicatedLineResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDedicatedLineResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDedicatedLineResponseBody(name='body'),
}

async function updateDedicatedLineWithOptions(request: UpdateDedicatedLineRequest, runtime: Util.RuntimeOptions): UpdateDedicatedLineResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.bandwidth)) {
    body['Bandwidth'] = request.bandwidth;
  }
  if (!Util.isUnset(request.contact)) {
    body['Contact'] = request.contact;
  }
  if (!Util.isUnset(request.dedicatedLineGateway)) {
    body['DedicatedLineGateway'] = request.dedicatedLineGateway;
  }
  if (!Util.isUnset(request.dedicatedLineId)) {
    body['DedicatedLineId'] = request.dedicatedLineId;
  }
  if (!Util.isUnset(request.dedicatedLineIp)) {
    body['DedicatedLineIp'] = request.dedicatedLineIp;
  }
  if (!Util.isUnset(request.dedicatedLineRole)) {
    body['DedicatedLineRole'] = request.dedicatedLineRole;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.devicePort)) {
    body['DevicePort'] = request.devicePort;
  }
  if (!Util.isUnset(request.expirationDate)) {
    body['ExpirationDate'] = request.expirationDate;
  }
  if (!Util.isUnset(request.extAttributes)) {
    body['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.isp)) {
    body['Isp'] = request.isp;
  }
  if (!Util.isUnset(request.ispId)) {
    body['IspId'] = request.ispId;
  }
  if (!Util.isUnset(request.keyword)) {
    body['Keyword'] = request.keyword;
  }
  if (!Util.isUnset(request.onlineDate)) {
    body['OnlineDate'] = request.onlineDate;
  }
  if (!Util.isUnset(request.phone)) {
    body['Phone'] = request.phone;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDedicatedLine',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDedicatedLine(request: UpdateDedicatedLineRequest): UpdateDedicatedLineResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDedicatedLineWithOptions(request, runtime);
}

model UpdateDeviceRequest {
  deviceId?: string(name='DeviceId'),
  enablePassword?: string(name='EnablePassword'),
  extAttributes?: string(name='ExtAttributes'),
  hostName?: string(name='HostName'),
  instanceId?: string(name='InstanceId'),
  ip?: string(name='Ip'),
  loginPassword?: string(name='LoginPassword'),
  loginType?: string(name='LoginType'),
  loginUsername?: string(name='LoginUsername'),
  mac?: string(name='Mac'),
  model?: string(name='Model'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  securityDomain?: string(name='SecurityDomain'),
  serviceStatus?: string(name='ServiceStatus'),
  sn?: string(name='Sn'),
  snmpAccountType?: string(name='SnmpAccountType'),
  snmpAccountVersion?: string(name='SnmpAccountVersion'),
  snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
  snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
  snmpCommunity?: string(name='SnmpCommunity'),
  snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
  snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
  snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
  snmpUsername?: string(name='SnmpUsername'),
  vendor?: string(name='Vendor'),
}

model UpdateDeviceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDeviceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceResponseBody(name='body'),
}

async function updateDeviceWithOptions(request: UpdateDeviceRequest, runtime: Util.RuntimeOptions): UpdateDeviceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceId)) {
    body['DeviceId'] = request.deviceId;
  }
  if (!Util.isUnset(request.enablePassword)) {
    body['EnablePassword'] = request.enablePassword;
  }
  if (!Util.isUnset(request.extAttributes)) {
    body['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.hostName)) {
    body['HostName'] = request.hostName;
  }
  if (!Util.isUnset(request.ip)) {
    body['Ip'] = request.ip;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['LoginPassword'] = request.loginPassword;
  }
  if (!Util.isUnset(request.loginType)) {
    body['LoginType'] = request.loginType;
  }
  if (!Util.isUnset(request.loginUsername)) {
    body['LoginUsername'] = request.loginUsername;
  }
  if (!Util.isUnset(request.mac)) {
    body['Mac'] = request.mac;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.securityDomain)) {
    body['SecurityDomain'] = request.securityDomain;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    body['ServiceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.sn)) {
    body['Sn'] = request.sn;
  }
  if (!Util.isUnset(request.snmpAccountType)) {
    body['SnmpAccountType'] = request.snmpAccountType;
  }
  if (!Util.isUnset(request.snmpAccountVersion)) {
    body['SnmpAccountVersion'] = request.snmpAccountVersion;
  }
  if (!Util.isUnset(request.snmpAuthPassphrase)) {
    body['SnmpAuthPassphrase'] = request.snmpAuthPassphrase;
  }
  if (!Util.isUnset(request.snmpAuthProtocol)) {
    body['SnmpAuthProtocol'] = request.snmpAuthProtocol;
  }
  if (!Util.isUnset(request.snmpCommunity)) {
    body['SnmpCommunity'] = request.snmpCommunity;
  }
  if (!Util.isUnset(request.snmpPrivacyPassphrase)) {
    body['SnmpPrivacyPassphrase'] = request.snmpPrivacyPassphrase;
  }
  if (!Util.isUnset(request.snmpPrivacyProtocol)) {
    body['SnmpPrivacyProtocol'] = request.snmpPrivacyProtocol;
  }
  if (!Util.isUnset(request.snmpSecurityLevel)) {
    body['SnmpSecurityLevel'] = request.snmpSecurityLevel;
  }
  if (!Util.isUnset(request.snmpUsername)) {
    body['SnmpUsername'] = request.snmpUsername;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevice',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevice(request: UpdateDeviceRequest): UpdateDeviceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceWithOptions(request, runtime);
}

model UpdateDeviceFormRequest {
  accountConfig?: boolean(name='AccountConfig'),
  attributeList?: [ 
    {
      attributeFormat?: string(name='AttributeFormat'),
      attributeFuzzyQuery?: boolean(name='AttributeFuzzyQuery'),
      attributeKey?: string(name='AttributeKey'),
      attributeName?: string(name='AttributeName'),
      attributePlaceholder?: string(name='AttributePlaceholder'),
      attributeQuery?: boolean(name='AttributeQuery'),
      attributeReference?: string(name='AttributeReference'),
      attributeRequirement?: boolean(name='AttributeRequirement'),
      attributeSequence?: int32(name='AttributeSequence'),
      attributeTableDisplay?: boolean(name='AttributeTableDisplay'),
      attributeType?: string(name='AttributeType'),
      attributeUniqueness?: boolean(name='AttributeUniqueness'),
    }
  ](name='AttributeList'),
  configCompare?: boolean(name='ConfigCompare'),
  detailDisplay?: boolean(name='DetailDisplay'),
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
  relatedDeviceFormId?: string(name='RelatedDeviceFormId'),
  script?: string(name='Script'),
}

model UpdateDeviceFormShrinkRequest {
  accountConfig?: boolean(name='AccountConfig'),
  attributeListShrink?: string(name='AttributeList'),
  configCompare?: boolean(name='ConfigCompare'),
  detailDisplay?: boolean(name='DetailDisplay'),
  deviceFormId?: string(name='DeviceFormId'),
  instanceId?: string(name='InstanceId'),
  relatedDeviceFormId?: string(name='RelatedDeviceFormId'),
  script?: string(name='Script'),
}

model UpdateDeviceFormResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDeviceFormResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceFormResponseBody(name='body'),
}

async function updateDeviceFormWithOptions(tmpReq: UpdateDeviceFormRequest, runtime: Util.RuntimeOptions): UpdateDeviceFormResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDeviceFormShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.attributeList)) {
    request.attributeListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.attributeList, 'AttributeList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.accountConfig)) {
    body['AccountConfig'] = request.accountConfig;
  }
  if (!Util.isUnset(request.attributeListShrink)) {
    body['AttributeList'] = request.attributeListShrink;
  }
  if (!Util.isUnset(request.configCompare)) {
    body['ConfigCompare'] = request.configCompare;
  }
  if (!Util.isUnset(request.detailDisplay)) {
    body['DetailDisplay'] = request.detailDisplay;
  }
  if (!Util.isUnset(request.deviceFormId)) {
    body['DeviceFormId'] = request.deviceFormId;
  }
  if (!Util.isUnset(request.relatedDeviceFormId)) {
    body['RelatedDeviceFormId'] = request.relatedDeviceFormId;
  }
  if (!Util.isUnset(request.script)) {
    body['Script'] = request.script;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceForm',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceForm(request: UpdateDeviceFormRequest): UpdateDeviceFormResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceFormWithOptions(request, runtime);
}

model UpdateDevicePropertyRequest {
  devicePropertyId?: string(name='DevicePropertyId'),
  instanceId?: string(name='InstanceId'),
  propertyContent?: string(name='PropertyContent'),
  propertyFormat?: string(name='PropertyFormat'),
  propertyName?: string(name='PropertyName'),
}

model UpdateDevicePropertyResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDevicePropertyResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevicePropertyResponseBody(name='body'),
}

async function updateDevicePropertyWithOptions(request: UpdateDevicePropertyRequest, runtime: Util.RuntimeOptions): UpdateDevicePropertyResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.devicePropertyId)) {
    body['DevicePropertyId'] = request.devicePropertyId;
  }
  if (!Util.isUnset(request.propertyContent)) {
    body['PropertyContent'] = request.propertyContent;
  }
  if (!Util.isUnset(request.propertyFormat)) {
    body['PropertyFormat'] = request.propertyFormat;
  }
  if (!Util.isUnset(request.propertyName)) {
    body['PropertyName'] = request.propertyName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceProperty',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceProperty(request: UpdateDevicePropertyRequest): UpdateDevicePropertyResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevicePropertyWithOptions(request, runtime);
}

model UpdateDeviceResourceRequest {
  data?: string(name='Data'),
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIds?: [ string ](name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
  updateType?: string(name='UpdateType'),
}

model UpdateDeviceResourceShrinkRequest {
  data?: string(name='Data'),
  deviceResourceId?: string(name='DeviceResourceId'),
  deviceResourceIdsShrink?: string(name='DeviceResourceIds'),
  instanceId?: string(name='InstanceId'),
  setupProjectId?: string(name='SetupProjectId'),
  updateType?: string(name='UpdateType'),
}

model UpdateDeviceResourceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDeviceResourceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDeviceResourceResponseBody(name='body'),
}

async function updateDeviceResourceWithOptions(tmpReq: UpdateDeviceResourceRequest, runtime: Util.RuntimeOptions): UpdateDeviceResourceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDeviceResourceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceResourceIds)) {
    request.deviceResourceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceResourceIds, 'DeviceResourceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.data)) {
    body['Data'] = request.data;
  }
  if (!Util.isUnset(request.deviceResourceId)) {
    body['DeviceResourceId'] = request.deviceResourceId;
  }
  if (!Util.isUnset(request.deviceResourceIdsShrink)) {
    body['DeviceResourceIds'] = request.deviceResourceIdsShrink;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    body['SetupProjectId'] = request.setupProjectId;
  }
  if (!Util.isUnset(request.updateType)) {
    body['UpdateType'] = request.updateType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDeviceResource',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDeviceResource(request: UpdateDeviceResourceRequest): UpdateDeviceResourceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDeviceResourceWithOptions(request, runtime);
}

model UpdateDevicesRequest {
  deviceIds?: [ string ](name='DeviceIds'),
  enablePassword?: string(name='EnablePassword'),
  extAttributes?: string(name='ExtAttributes'),
  instanceId?: string(name='InstanceId'),
  loginPassword?: string(name='LoginPassword'),
  loginType?: string(name='LoginType'),
  loginUsername?: string(name='LoginUsername'),
  model?: string(name='Model'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  securityDomain?: string(name='SecurityDomain'),
  serviceStatus?: string(name='ServiceStatus'),
  snmpAccountType?: string(name='SnmpAccountType'),
  snmpAccountVersion?: string(name='SnmpAccountVersion'),
  snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
  snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
  snmpCommunity?: string(name='SnmpCommunity'),
  snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
  snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
  snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
  snmpUsername?: string(name='SnmpUsername'),
  vendor?: string(name='Vendor'),
}

model UpdateDevicesShrinkRequest {
  deviceIdsShrink?: string(name='DeviceIds'),
  enablePassword?: string(name='EnablePassword'),
  extAttributes?: string(name='ExtAttributes'),
  instanceId?: string(name='InstanceId'),
  loginPassword?: string(name='LoginPassword'),
  loginType?: string(name='LoginType'),
  loginUsername?: string(name='LoginUsername'),
  model?: string(name='Model'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  securityDomain?: string(name='SecurityDomain'),
  serviceStatus?: string(name='ServiceStatus'),
  snmpAccountType?: string(name='SnmpAccountType'),
  snmpAccountVersion?: string(name='SnmpAccountVersion'),
  snmpAuthPassphrase?: string(name='SnmpAuthPassphrase'),
  snmpAuthProtocol?: string(name='SnmpAuthProtocol'),
  snmpCommunity?: string(name='SnmpCommunity'),
  snmpPrivacyPassphrase?: string(name='SnmpPrivacyPassphrase'),
  snmpPrivacyProtocol?: string(name='SnmpPrivacyProtocol'),
  snmpSecurityLevel?: string(name='SnmpSecurityLevel'),
  snmpUsername?: string(name='SnmpUsername'),
  vendor?: string(name='Vendor'),
}

model UpdateDevicesResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateDevicesResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateDevicesResponseBody(name='body'),
}

async function updateDevicesWithOptions(tmpReq: UpdateDevicesRequest, runtime: Util.RuntimeOptions): UpdateDevicesResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateDevicesShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.deviceIds)) {
    request.deviceIdsShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.deviceIds, 'DeviceIds', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.deviceIdsShrink)) {
    body['DeviceIds'] = request.deviceIdsShrink;
  }
  if (!Util.isUnset(request.enablePassword)) {
    body['EnablePassword'] = request.enablePassword;
  }
  if (!Util.isUnset(request.extAttributes)) {
    body['ExtAttributes'] = request.extAttributes;
  }
  if (!Util.isUnset(request.loginPassword)) {
    body['LoginPassword'] = request.loginPassword;
  }
  if (!Util.isUnset(request.loginType)) {
    body['LoginType'] = request.loginType;
  }
  if (!Util.isUnset(request.loginUsername)) {
    body['LoginUsername'] = request.loginUsername;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.physicalSpaceName)) {
    body['PhysicalSpaceName'] = request.physicalSpaceName;
  }
  if (!Util.isUnset(request.securityDomain)) {
    body['SecurityDomain'] = request.securityDomain;
  }
  if (!Util.isUnset(request.serviceStatus)) {
    body['ServiceStatus'] = request.serviceStatus;
  }
  if (!Util.isUnset(request.snmpAccountType)) {
    body['SnmpAccountType'] = request.snmpAccountType;
  }
  if (!Util.isUnset(request.snmpAccountVersion)) {
    body['SnmpAccountVersion'] = request.snmpAccountVersion;
  }
  if (!Util.isUnset(request.snmpAuthPassphrase)) {
    body['SnmpAuthPassphrase'] = request.snmpAuthPassphrase;
  }
  if (!Util.isUnset(request.snmpAuthProtocol)) {
    body['SnmpAuthProtocol'] = request.snmpAuthProtocol;
  }
  if (!Util.isUnset(request.snmpCommunity)) {
    body['SnmpCommunity'] = request.snmpCommunity;
  }
  if (!Util.isUnset(request.snmpPrivacyPassphrase)) {
    body['SnmpPrivacyPassphrase'] = request.snmpPrivacyPassphrase;
  }
  if (!Util.isUnset(request.snmpPrivacyProtocol)) {
    body['SnmpPrivacyProtocol'] = request.snmpPrivacyProtocol;
  }
  if (!Util.isUnset(request.snmpSecurityLevel)) {
    body['SnmpSecurityLevel'] = request.snmpSecurityLevel;
  }
  if (!Util.isUnset(request.snmpUsername)) {
    body['SnmpUsername'] = request.snmpUsername;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateDevices',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateDevices(request: UpdateDevicesRequest): UpdateDevicesResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateDevicesWithOptions(request, runtime);
}

model UpdateEventDefinitionRequest {
  eventId?: string(name='EventId'),
  eventName?: string(name='EventName'),
  eventType?: string(name='EventType'),
  instanceId?: string(name='InstanceId'),
  templateId?: string(name='TemplateId'),
}

model UpdateEventDefinitionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateEventDefinitionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateEventDefinitionResponseBody(name='body'),
}

async function updateEventDefinitionWithOptions(request: UpdateEventDefinitionRequest, runtime: Util.RuntimeOptions): UpdateEventDefinitionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.eventId)) {
    body['EventId'] = request.eventId;
  }
  if (!Util.isUnset(request.eventName)) {
    body['EventName'] = request.eventName;
  }
  if (!Util.isUnset(request.eventType)) {
    body['EventType'] = request.eventType;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.templateId)) {
    body['TemplateId'] = request.templateId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateEventDefinition',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateEventDefinition(request: UpdateEventDefinitionRequest): UpdateEventDefinitionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateEventDefinitionWithOptions(request, runtime);
}

model UpdateInformationKeyActionRequest {
  instanceId?: string(name='InstanceId'),
  key?: string(name='Key'),
  keyAction?: string(name='KeyAction'),
  resourceInformationId?: string(name='ResourceInformationId'),
  setupProjectId?: string(name='SetupProjectId'),
  value?: string(name='Value'),
}

model UpdateInformationKeyActionResponseBody = {
  actionMessage?: string(name='ActionMessage'),
  requestId?: string(name='RequestId'),
}

model UpdateInformationKeyActionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInformationKeyActionResponseBody(name='body'),
}

async function updateInformationKeyActionWithOptions(request: UpdateInformationKeyActionRequest, runtime: Util.RuntimeOptions): UpdateInformationKeyActionResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.key)) {
    query['Key'] = request.key;
  }
  if (!Util.isUnset(request.keyAction)) {
    query['KeyAction'] = request.keyAction;
  }
  if (!Util.isUnset(request.resourceInformationId)) {
    query['ResourceInformationId'] = request.resourceInformationId;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    query['SetupProjectId'] = request.setupProjectId;
  }
  if (!Util.isUnset(request.value)) {
    query['Value'] = request.value;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInformationKeyAction',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInformationKeyAction(request: UpdateInformationKeyActionRequest): UpdateInformationKeyActionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInformationKeyActionWithOptions(request, runtime);
}

model UpdateInstanceRequest {
  instanceId?: string(name='InstanceId'),
  instanceName?: string(name='InstanceName'),
}

model UpdateInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateInstanceResponseBody(name='body'),
}

async function updateInstanceWithOptions(request: UpdateInstanceRequest, runtime: Util.RuntimeOptions): UpdateInstanceResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.instanceName)) {
    body['InstanceName'] = request.instanceName;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateInstance',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateInstance(request: UpdateInstanceRequest): UpdateInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateInstanceWithOptions(request, runtime);
}

model UpdateOsVersionRequest {
  fileName?: string(name='FileName'),
  filePath?: string(name='FilePath'),
  instanceId?: string(name='InstanceId'),
  model?: string(name='Model'),
  osVersion?: string(name='OsVersion'),
  osVersionId?: string(name='OsVersionId'),
  status?: string(name='Status'),
  vendor?: string(name='Vendor'),
}

model UpdateOsVersionResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateOsVersionResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateOsVersionResponseBody(name='body'),
}

async function updateOsVersionWithOptions(request: UpdateOsVersionRequest, runtime: Util.RuntimeOptions): UpdateOsVersionResponse {
  Util.validateModel(request);
  var body : map[string]any = {};
  if (!Util.isUnset(request.fileName)) {
    body['FileName'] = request.fileName;
  }
  if (!Util.isUnset(request.filePath)) {
    body['FilePath'] = request.filePath;
  }
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.model)) {
    body['Model'] = request.model;
  }
  if (!Util.isUnset(request.osVersion)) {
    body['OsVersion'] = request.osVersion;
  }
  if (!Util.isUnset(request.osVersionId)) {
    body['OsVersionId'] = request.osVersionId;
  }
  if (!Util.isUnset(request.status)) {
    body['Status'] = request.status;
  }
  if (!Util.isUnset(request.vendor)) {
    body['Vendor'] = request.vendor;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateOsVersion',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateOsVersion(request: UpdateOsVersionRequest): UpdateOsVersionResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateOsVersionWithOptions(request, runtime);
}

model UpdatePhysicalSpaceRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  instanceId?: string(name='InstanceId'),
  moveAction?: string(name='MoveAction'),
  owner?: string(name='Owner'),
  parentUid?: string(name='ParentUid'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  province?: string(name='Province'),
  remark?: string(name='Remark'),
  securityDomainList?: [ string ](name='SecurityDomainList'),
  spaceAbbreviation?: string(name='SpaceAbbreviation'),
  spaceType?: string(name='SpaceType'),
  targetUid?: string(name='TargetUid'),
}

model UpdatePhysicalSpaceShrinkRequest {
  address?: string(name='Address'),
  city?: string(name='City'),
  country?: string(name='Country'),
  instanceId?: string(name='InstanceId'),
  moveAction?: string(name='MoveAction'),
  owner?: string(name='Owner'),
  parentUid?: string(name='ParentUid'),
  physicalSpaceId?: string(name='PhysicalSpaceId'),
  physicalSpaceName?: string(name='PhysicalSpaceName'),
  province?: string(name='Province'),
  remark?: string(name='Remark'),
  securityDomainListShrink?: string(name='SecurityDomainList'),
  spaceAbbreviation?: string(name='SpaceAbbreviation'),
  spaceType?: string(name='SpaceType'),
  targetUid?: string(name='TargetUid'),
}

model UpdatePhysicalSpaceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdatePhysicalSpaceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdatePhysicalSpaceResponseBody(name='body'),
}

async function updatePhysicalSpaceWithOptions(tmpReq: UpdatePhysicalSpaceRequest, runtime: Util.RuntimeOptions): UpdatePhysicalSpaceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdatePhysicalSpaceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.securityDomainList)) {
    request.securityDomainListShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.securityDomainList, 'SecurityDomainList', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.address)) {
    body['Address'] = request.address;
  }
  if (!Util.isUnset(request.city)) {
    body['City'] = request.city;
  }
  if (!Util.isUnset(request.country)) {
    body['Country'] = request.country;
  }
  if (!Util.isUnset(request.moveAction)) {
    body['MoveAction'] = request.moveAction;
  }
  if (!Util.isUnset(request.owner)) {
    body['Owner'] = request.owner;
  }
  if (!Util.isUnset(request.parentUid)) {
    body['ParentUid'] = request.parentUid;
  }
  if (!Util.isUnset(request.physicalSpaceId)) {
    body['PhysicalSpaceId'] = request.physicalSpaceId;
  }
  if (!Util.isUnset(request.physicalSpaceName)) {
    body['PhysicalSpaceName'] = request.physicalSpaceName;
  }
  if (!Util.isUnset(request.province)) {
    body['Province'] = request.province;
  }
  if (!Util.isUnset(request.remark)) {
    body['Remark'] = request.remark;
  }
  if (!Util.isUnset(request.securityDomainListShrink)) {
    body['SecurityDomainList'] = request.securityDomainListShrink;
  }
  if (!Util.isUnset(request.spaceAbbreviation)) {
    body['SpaceAbbreviation'] = request.spaceAbbreviation;
  }
  if (!Util.isUnset(request.spaceType)) {
    body['SpaceType'] = request.spaceType;
  }
  if (!Util.isUnset(request.targetUid)) {
    body['TargetUid'] = request.targetUid;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdatePhysicalSpace',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updatePhysicalSpace(request: UpdatePhysicalSpaceRequest): UpdatePhysicalSpaceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updatePhysicalSpaceWithOptions(request, runtime);
}

model UpdateProjectProgressRequest {
  instanceId?: string(name='InstanceId'),
  progress?: string(name='Progress'),
  setupProjectId?: string(name='SetupProjectId'),
}

model UpdateProjectProgressResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateProjectProgressResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateProjectProgressResponseBody(name='body'),
}

async function updateProjectProgressWithOptions(request: UpdateProjectProgressRequest, runtime: Util.RuntimeOptions): UpdateProjectProgressResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.progress)) {
    body['Progress'] = request.progress;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    body['SetupProjectId'] = request.setupProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateProjectProgress',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateProjectProgress(request: UpdateProjectProgressRequest): UpdateProjectProgressResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateProjectProgressWithOptions(request, runtime);
}

model UpdateResourceInformationRequest {
  information?: [ 
    {
      key?: string(name='Key'),
      keyAction?: string(name='KeyAction'),
      keyAttribute?: string(name='KeyAttribute'),
      keyDescription?: string(name='KeyDescription'),
      setupProjectId?: string(name='SetupProjectId'),
    }
  ](name='Information'),
  instanceId?: string(name='InstanceId'),
  resourceAttribute?: string(name='ResourceAttribute'),
  resourceInformationId?: string(name='ResourceInformationId'),
  resourceType?: string(name='ResourceType'),
}

model UpdateResourceInformationShrinkRequest {
  informationShrink?: string(name='Information'),
  instanceId?: string(name='InstanceId'),
  resourceAttribute?: string(name='ResourceAttribute'),
  resourceInformationId?: string(name='ResourceInformationId'),
  resourceType?: string(name='ResourceType'),
}

model UpdateResourceInformationResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateResourceInformationResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceInformationResponseBody(name='body'),
}

async function updateResourceInformationWithOptions(tmpReq: UpdateResourceInformationRequest, runtime: Util.RuntimeOptions): UpdateResourceInformationResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateResourceInformationShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.information)) {
    request.informationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.information, 'Information', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.informationShrink)) {
    body['Information'] = request.informationShrink;
  }
  if (!Util.isUnset(request.resourceAttribute)) {
    body['ResourceAttribute'] = request.resourceAttribute;
  }
  if (!Util.isUnset(request.resourceInformationId)) {
    body['ResourceInformationId'] = request.resourceInformationId;
  }
  if (!Util.isUnset(request.resourceType)) {
    body['ResourceType'] = request.resourceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInformation',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceInformation(request: UpdateResourceInformationRequest): UpdateResourceInformationResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceInformationWithOptions(request, runtime);
}

model UpdateResourceInstanceRequest {
  instanceId?: string(name='InstanceId'),
  resourceInformation?: [ 
    {
      key?: string(name='Key'),
      value?: string(name='Value'),
    }
  ](name='ResourceInformation'),
  resourceInformationId?: string(name='ResourceInformationId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model UpdateResourceInstanceShrinkRequest {
  instanceId?: string(name='InstanceId'),
  resourceInformationShrink?: string(name='ResourceInformation'),
  resourceInformationId?: string(name='ResourceInformationId'),
  setupProjectId?: string(name='SetupProjectId'),
}

model UpdateResourceInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateResourceInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateResourceInstanceResponseBody(name='body'),
}

async function updateResourceInstanceWithOptions(tmpReq: UpdateResourceInstanceRequest, runtime: Util.RuntimeOptions): UpdateResourceInstanceResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateResourceInstanceShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.resourceInformation)) {
    request.resourceInformationShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.resourceInformation, 'ResourceInformation', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.resourceInformationShrink)) {
    query['ResourceInformation'] = request.resourceInformationShrink;
  }
  if (!Util.isUnset(request.resourceInformationId)) {
    query['ResourceInformationId'] = request.resourceInformationId;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    query['SetupProjectId'] = request.setupProjectId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateResourceInstance',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateResourceInstance(request: UpdateResourceInstanceRequest): UpdateResourceInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateResourceInstanceWithOptions(request, runtime);
}

model UpdateSetupProjectRequest {
  architectureId?: string(name='ArchitectureId'),
  deliveryTime?: string(name='DeliveryTime'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  nodes?: string(name='Nodes'),
  packages?: [ 
    {
      deviceNumber?: long(name='DeviceNumber'),
      model?: string(name='Model'),
      role?: string(name='Role'),
      vendor?: string(name='Vendor'),
    }
  ](name='Packages'),
  setupProjectId?: string(name='SetupProjectId'),
  spaceId?: string(name='SpaceId'),
}

model UpdateSetupProjectShrinkRequest {
  architectureId?: string(name='ArchitectureId'),
  deliveryTime?: string(name='DeliveryTime'),
  description?: string(name='Description'),
  instanceId?: string(name='InstanceId'),
  nodes?: string(name='Nodes'),
  packagesShrink?: string(name='Packages'),
  setupProjectId?: string(name='SetupProjectId'),
  spaceId?: string(name='SpaceId'),
}

model UpdateSetupProjectResponseBody = {
  requestId?: string(name='RequestId'),
  setupProjectId?: string(name='SetupProjectId'),
  setupProjectName?: string(name='SetupProjectName'),
  setupProjectSpecification?: string(name='SetupProjectSpecification'),
}

model UpdateSetupProjectResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSetupProjectResponseBody(name='body'),
}

async function updateSetupProjectWithOptions(tmpReq: UpdateSetupProjectRequest, runtime: Util.RuntimeOptions): UpdateSetupProjectResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSetupProjectShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.packages)) {
    request.packagesShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.packages, 'Packages', 'json');
  }
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.architectureId)) {
    body['ArchitectureId'] = request.architectureId;
  }
  if (!Util.isUnset(request.deliveryTime)) {
    body['DeliveryTime'] = request.deliveryTime;
  }
  if (!Util.isUnset(request.description)) {
    body['Description'] = request.description;
  }
  if (!Util.isUnset(request.nodes)) {
    body['Nodes'] = request.nodes;
  }
  if (!Util.isUnset(request.packagesShrink)) {
    body['Packages'] = request.packagesShrink;
  }
  if (!Util.isUnset(request.setupProjectId)) {
    body['SetupProjectId'] = request.setupProjectId;
  }
  if (!Util.isUnset(request.spaceId)) {
    body['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSetupProject',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSetupProject(request: UpdateSetupProjectRequest): UpdateSetupProjectResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSetupProjectWithOptions(request, runtime);
}

model UpdateSpaceModelRequest {
  instanceId?: string(name='InstanceId'),
  sort?: [ 
    {
      level?: long(name='Level'),
      levelName?: string(name='LevelName'),
    }
  ](name='Sort'),
  spaceModelId?: string(name='SpaceModelId'),
  spaceType?: string(name='SpaceType'),
}

model UpdateSpaceModelShrinkRequest {
  instanceId?: string(name='InstanceId'),
  sortShrink?: string(name='Sort'),
  spaceModelId?: string(name='SpaceModelId'),
  spaceType?: string(name='SpaceType'),
}

model UpdateSpaceModelResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSpaceModelResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSpaceModelResponseBody(name='body'),
}

async function updateSpaceModelWithOptions(tmpReq: UpdateSpaceModelRequest, runtime: Util.RuntimeOptions): UpdateSpaceModelResponse {
  Util.validateModel(tmpReq);
  var request = new UpdateSpaceModelShrinkRequest{};
  OpenApiUtil.convert(tmpReq, request);
  if (!Util.isUnset(tmpReq.sort)) {
    request.sortShrink = OpenApiUtil.arrayToStringWithSpecifiedStyle(tmpReq.sort, 'Sort', 'json');
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.instanceId)) {
    body['InstanceId'] = request.instanceId;
  }
  if (!Util.isUnset(request.sortShrink)) {
    body['Sort'] = request.sortShrink;
  }
  if (!Util.isUnset(request.spaceModelId)) {
    body['SpaceModelId'] = request.spaceModelId;
  }
  if (!Util.isUnset(request.spaceType)) {
    body['SpaceType'] = request.spaceType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSpaceModel',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSpaceModel(request: UpdateSpaceModelRequest): UpdateSpaceModelResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSpaceModelWithOptions(request, runtime);
}

model UpdateSpaceModelInstanceRequest {
  instance?: string(name='Instance'),
  spaceId?: string(name='SpaceId'),
}

model UpdateSpaceModelInstanceResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateSpaceModelInstanceResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateSpaceModelInstanceResponseBody(name='body'),
}

async function updateSpaceModelInstanceWithOptions(request: UpdateSpaceModelInstanceRequest, runtime: Util.RuntimeOptions): UpdateSpaceModelInstanceResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instance)) {
    query['Instance'] = request.instance;
  }
  if (!Util.isUnset(request.spaceId)) {
    query['SpaceId'] = request.spaceId;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
  };
  var params = new OpenApi.Params{
    action = 'UpdateSpaceModelInstance',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateSpaceModelInstance(request: UpdateSpaceModelInstanceRequest): UpdateSpaceModelInstanceResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateSpaceModelInstanceWithOptions(request, runtime);
}

model UpdateWorkOrderRequest {
  alarmHappenTime?: string(name='AlarmHappenTime'),
  alarmRecoverTime?: string(name='AlarmRecoverTime'),
  alarmRelated?: string(name='AlarmRelated'),
  area?: string(name='Area'),
  circuitId?: string(name='CircuitId'),
  circuitName?: string(name='CircuitName'),
  circuitType?: string(name='CircuitType'),
  clientToken?: string(name='ClientToken'),
  deviceIp?: string(name='DeviceIp'),
  deviceIpA?: string(name='DeviceIpA'),
  deviceIpB?: string(name='DeviceIpB'),
  deviceModelA?: string(name='DeviceModelA'),
  deviceModelB?: string(name='DeviceModelB'),
  deviceName?: string(name='DeviceName'),
  deviceNameA?: string(name='DeviceNameA'),
  deviceNameB?: string(name='DeviceNameB'),
  devicePortA?: string(name='DevicePortA'),
  devicePortB?: string(name='DevicePortB'),
  deviceSnA?: string(name='DeviceSnA'),
  deviceSnB?: string(name='DeviceSnB'),
  deviceType?: string(name='DeviceType'),
  deviceVendor?: string(name='DeviceVendor'),
  deviceVendorA?: string(name='DeviceVendorA'),
  deviceVendorB?: string(name='DeviceVendorB'),
  emergencyDegree?: string(name='EmergencyDegree'),
  extra?: string(name='Extra'),
  hangFileName?: string(name='HangFileName'),
  hangFilePath?: string(name='HangFilePath'),
  hangReason?: string(name='HangReason'),
  impactBusiness?: string(name='ImpactBusiness'),
  incidentDescription?: string(name='IncidentDescription'),
  incidentSubType?: string(name='IncidentSubType'),
  incidentType?: string(name='IncidentType'),
  instanceId?: string(name='InstanceId'),
  liableMan?: string(name='LiableMan'),
  linkMan?: string(name='LinkMan'),
  originalSubjectAlarm?: string(name='OriginalSubjectAlarm'),
  processLimited?: string(name='ProcessLimited'),
  processMan?: string(name='ProcessMan'),
  processManId?: string(name='ProcessManId'),
  processResult?: string(name='ProcessResult'),
  skillGroups?: string(name='SkillGroups'),
  workOrderId?: string(name='WorkOrderId'),
  workOrderSource?: string(name='WorkOrderSource'),
  workOrderStep?: string(name='WorkOrderStep'),
  workOrderTitle?: string(name='WorkOrderTitle'),
  workOrderType?: string(name='WorkOrderType'),
}

model UpdateWorkOrderResponseBody = {
  requestId?: string(name='RequestId'),
}

model UpdateWorkOrderResponse = {
  headers: map[string]string(name='headers'),
  statusCode: int32(name='statusCode'),
  body: UpdateWorkOrderResponseBody(name='body'),
}

async function updateWorkOrderWithOptions(request: UpdateWorkOrderRequest, runtime: Util.RuntimeOptions): UpdateWorkOrderResponse {
  Util.validateModel(request);
  var query = {};
  if (!Util.isUnset(request.instanceId)) {
    query['InstanceId'] = request.instanceId;
  }
  var body : map[string]any = {};
  if (!Util.isUnset(request.alarmHappenTime)) {
    body['AlarmHappenTime'] = request.alarmHappenTime;
  }
  if (!Util.isUnset(request.alarmRecoverTime)) {
    body['AlarmRecoverTime'] = request.alarmRecoverTime;
  }
  if (!Util.isUnset(request.alarmRelated)) {
    body['AlarmRelated'] = request.alarmRelated;
  }
  if (!Util.isUnset(request.area)) {
    body['Area'] = request.area;
  }
  if (!Util.isUnset(request.circuitId)) {
    body['CircuitId'] = request.circuitId;
  }
  if (!Util.isUnset(request.circuitName)) {
    body['CircuitName'] = request.circuitName;
  }
  if (!Util.isUnset(request.circuitType)) {
    body['CircuitType'] = request.circuitType;
  }
  if (!Util.isUnset(request.clientToken)) {
    body['ClientToken'] = request.clientToken;
  }
  if (!Util.isUnset(request.deviceIp)) {
    body['DeviceIp'] = request.deviceIp;
  }
  if (!Util.isUnset(request.deviceIpA)) {
    body['DeviceIpA'] = request.deviceIpA;
  }
  if (!Util.isUnset(request.deviceIpB)) {
    body['DeviceIpB'] = request.deviceIpB;
  }
  if (!Util.isUnset(request.deviceModelA)) {
    body['DeviceModelA'] = request.deviceModelA;
  }
  if (!Util.isUnset(request.deviceModelB)) {
    body['DeviceModelB'] = request.deviceModelB;
  }
  if (!Util.isUnset(request.deviceName)) {
    body['DeviceName'] = request.deviceName;
  }
  if (!Util.isUnset(request.deviceNameA)) {
    body['DeviceNameA'] = request.deviceNameA;
  }
  if (!Util.isUnset(request.deviceNameB)) {
    body['DeviceNameB'] = request.deviceNameB;
  }
  if (!Util.isUnset(request.devicePortA)) {
    body['DevicePortA'] = request.devicePortA;
  }
  if (!Util.isUnset(request.devicePortB)) {
    body['DevicePortB'] = request.devicePortB;
  }
  if (!Util.isUnset(request.deviceSnA)) {
    body['DeviceSnA'] = request.deviceSnA;
  }
  if (!Util.isUnset(request.deviceSnB)) {
    body['DeviceSnB'] = request.deviceSnB;
  }
  if (!Util.isUnset(request.deviceType)) {
    body['DeviceType'] = request.deviceType;
  }
  if (!Util.isUnset(request.deviceVendor)) {
    body['DeviceVendor'] = request.deviceVendor;
  }
  if (!Util.isUnset(request.deviceVendorA)) {
    body['DeviceVendorA'] = request.deviceVendorA;
  }
  if (!Util.isUnset(request.deviceVendorB)) {
    body['DeviceVendorB'] = request.deviceVendorB;
  }
  if (!Util.isUnset(request.emergencyDegree)) {
    body['EmergencyDegree'] = request.emergencyDegree;
  }
  if (!Util.isUnset(request.extra)) {
    body['Extra'] = request.extra;
  }
  if (!Util.isUnset(request.hangFileName)) {
    body['HangFileName'] = request.hangFileName;
  }
  if (!Util.isUnset(request.hangFilePath)) {
    body['HangFilePath'] = request.hangFilePath;
  }
  if (!Util.isUnset(request.hangReason)) {
    body['HangReason'] = request.hangReason;
  }
  if (!Util.isUnset(request.impactBusiness)) {
    body['ImpactBusiness'] = request.impactBusiness;
  }
  if (!Util.isUnset(request.incidentDescription)) {
    body['IncidentDescription'] = request.incidentDescription;
  }
  if (!Util.isUnset(request.incidentSubType)) {
    body['IncidentSubType'] = request.incidentSubType;
  }
  if (!Util.isUnset(request.incidentType)) {
    body['IncidentType'] = request.incidentType;
  }
  if (!Util.isUnset(request.liableMan)) {
    body['LiableMan'] = request.liableMan;
  }
  if (!Util.isUnset(request.linkMan)) {
    body['LinkMan'] = request.linkMan;
  }
  if (!Util.isUnset(request.originalSubjectAlarm)) {
    body['OriginalSubjectAlarm'] = request.originalSubjectAlarm;
  }
  if (!Util.isUnset(request.processLimited)) {
    body['ProcessLimited'] = request.processLimited;
  }
  if (!Util.isUnset(request.processMan)) {
    body['ProcessMan'] = request.processMan;
  }
  if (!Util.isUnset(request.processManId)) {
    body['ProcessManId'] = request.processManId;
  }
  if (!Util.isUnset(request.processResult)) {
    body['ProcessResult'] = request.processResult;
  }
  if (!Util.isUnset(request.skillGroups)) {
    body['SkillGroups'] = request.skillGroups;
  }
  if (!Util.isUnset(request.workOrderId)) {
    body['WorkOrderId'] = request.workOrderId;
  }
  if (!Util.isUnset(request.workOrderSource)) {
    body['WorkOrderSource'] = request.workOrderSource;
  }
  if (!Util.isUnset(request.workOrderStep)) {
    body['WorkOrderStep'] = request.workOrderStep;
  }
  if (!Util.isUnset(request.workOrderTitle)) {
    body['WorkOrderTitle'] = request.workOrderTitle;
  }
  if (!Util.isUnset(request.workOrderType)) {
    body['WorkOrderType'] = request.workOrderType;
  }
  var req = new OpenApi.OpenApiRequest{ 
    query = OpenApiUtil.query(query),
    body = OpenApiUtil.parseToMap(body),
  };
  var params = new OpenApi.Params{
    action = 'UpdateWorkOrder',
    version = '2020-08-25',
    protocol = 'HTTPS',
    pathname = '/',
    method = 'POST',
    authType = 'AK',
    style = 'RPC',
    reqBodyType = 'formData',
    bodyType = 'json',
  };
  return callApi(params, req, runtime);
}

async function updateWorkOrder(request: UpdateWorkOrderRequest): UpdateWorkOrderResponse {
  var runtime = new Util.RuntimeOptions{};
  return updateWorkOrderWithOptions(request, runtime);
}

